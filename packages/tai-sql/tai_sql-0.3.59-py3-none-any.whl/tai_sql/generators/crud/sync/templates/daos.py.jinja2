# Este archivo ha sido generado autom√°ticamente por tai-sql
# No modifiques este archivo directamente
{% import "macros.jinja2" as macros %}
{{ imports|join('\n') }}

# Logger
logger = Alphi.get_logger_by_name("{{ logger_name }}")


{% for model in models %}
{% set all_pk_autoincrement = true %}
{% for column in model.columns %}
    {% if column.args.get('primary_key', False) and not column.args.get('autoincrement', False) %}
        {% set all_pk_autoincrement = false %}
    {% endif %}
{% endfor %}
class {{ model.name }}SyncDAO:
    """
    Clase DAO s√≠ncrona para el modelo {{ model.name }}.
    
    Proporciona operaciones completas de Create, Read, Update y Delete
    para el modelo {{ model.name }} con soporte para gesti√≥n autom√°tica
    y manual de sesiones SQLAlchemy.
    
    Caracter√≠sticas principales:
    - Soporte dual: sesiones autom√°ticas o compartidas
    - Type hints completos para mejor experiencia de desarrollo
    - Manejo robusto de errores con rollback autom√°tico
    - Operaciones optimizadas con flush para obtener IDs
    - Filtros flexibles en todas las operaciones de b√∫squeda
    
    M√©todos de lectura:
        find(**filters, session=None): Busca un √∫nico registro
        find_many(limit, offset, order_by, order, **filters, session=None): Busca m√∫ltiples registros
        count(**filters, session=None): Cuenta registros
    
    {% if not model.is_view %}
    M√©todos de escritura:
        create(**data, session=None): Crea un nuevo registro
        create_many(records, session=None): Crea m√∫ltiples registros
        update(filters, **data, session=None): Actualiza registros existentes
        delete(**filters, session=None): Elimina registros

    {% endif %}
    Par√°metros de sesi√≥n:
        Todos los m√©todos aceptan un par√°metro opcional 'session':
        - Si session=None: Se crea una sesi√≥n autom√°tica con commit
        - Si session=Session: Se usa la sesi√≥n proporcionada (para transacciones)
    
    Ejemplos de uso:
        ```python
        # Operaciones simples (sesi√≥n autom√°tica)
        crud = {{ model.name }}SyncDAO(session_manager)
        {% if model.columns %}
        {% set first_column = model.columns[0] %}
        {% if not first_column.args.get('autoincrement', False) %}
        record = crud.create({{ first_column.name }}="valor")
        {% endif %}
        {% endif %}
        found = crud.find_by_id(1)
        
        # Operaciones transaccionales (sesi√≥n compartida)
        with session_manager.transaction() as session:
            record1 = crud.create(data="valor1", session=session)
            record2 = crud.create(data="valor2", session=session)
            # Ambos se crean en la misma transacci√≥n
        ```
    """
    
    # Constantes de validaci√≥n para agregaciones
    OPERATION_TYPE_VALIDATORS = {
        'sum': ['INTEGER', 'FLOAT', 'NUMERIC', 'DECIMAL', 'DOUBLE', 'REAL', 'BIGINT', 'SMALLINT', 'TINYINT'],
        'mean': ['INTEGER', 'FLOAT', 'NUMERIC', 'DECIMAL', 'DOUBLE', 'REAL', 'BIGINT', 'SMALLINT', 'TINYINT'],
        'max': ['INTEGER', 'FLOAT', 'NUMERIC', 'DECIMAL', 'DOUBLE', 'REAL', 'BIGINT', 'SMALLINT', 'TINYINT', 'DATETIME', 'TIMESTAMP', 'DATE', 'TIME'],
        'min': ['INTEGER', 'FLOAT', 'NUMERIC', 'DECIMAL', 'DOUBLE', 'REAL', 'BIGINT', 'SMALLINT', 'TINYINT', 'DATETIME', 'TIMESTAMP', 'DATE', 'TIME'],
        'count': ['INTEGER', 'FLOAT', 'NUMERIC', 'DECIMAL', 'DOUBLE', 'REAL', 'BIGINT', 'SMALLINT', 'TINYINT', 'DATETIME', 'TIMESTAMP', 'DATE', 'TIME', 'VARCHAR', 'TEXT', 'CHAR', 'STRING', 'BOOLEAN', 'BOOL']
    }
    
    OPERATION_FUNCTIONS = {
        'sum': func.sum,
        'mean': func.avg,
        'max': func.max,
        'min': func.min,
        'count': func.count
    }
    
    def __init__(self, session_manager: SyncSessionManager):
        """
        Inicializa el SyncDAO con un gestor de sesiones.
        
        Args:
            session_manager: Gestor de sesiones s√≠ncronas
        """
        self.session_manager = session_manager
        {% if not model.is_view %}
        self._df_validator = {{ model.name }}DataFrameValidator()
        {% endif %}

    {% if not model.is_view %}
    @error_handler
    def find(
        self,
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        {{ column.name }}: {{ column.type }},
        {% endif %}
        {% endfor %}
        includes: Optional[List[str]] = None,
        rls: Optional[Union[List[RLS], RLS]] = None,
        session: Optional[Session] = None
    ) -> Optional[{{ model.name }}Read]:
        """
        Busca un √∫nico registro por primary key con carga optimizada de relaciones.
        
        Args:
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            {{ column.name }}: Filtrar por {{ column.name }}
            {% endif %}
            {% endfor %}
            includes: Lista de relaciones a incluir  (formato: 'relation' o 'relation.nested')
            session: Sesi√≥n existente (opcional)
            
        Returns:
            Instancia del modelo o None si no se encuentra

        Examples:
            Incluir relaci√≥n simple

            await dao.find(id=1, includes=['author'])
            
            Incluir relaciones anidadas

            await dao.find(id=1, includes=['author', 'author.posts'])
            
            M√∫ltiples relaciones

            await dao.find(id=1, includes=['author', 'comments', 'tags'])
        """
        logger.info(f"[{{ schema_name }}] üîç Buscando {{ model.name }}:")
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        logger.info(f"[{{ schema_name }}]     {{ column.name }}={{ '{' }}{{ column.name }}{{ '}' }}")
        {% endif %}
        {% endfor %}
        logger.info(f"[{{ schema_name }}]     includes={includes}")

        # Construir query base
        query = select({{ model.name }})
        
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        query = query.where({{ model.name }}.{{ column.name }} == {{ column.name }})
        {% endif %}
        {% endfor %}

        # Aplicar regla RLS (si existe)
        if rls is not None:
            query = RLSQueryApplicator.apply_rls(query, {{ model.name }}, rls)

        # Aplicar opciones de carga optimizada
        if includes:
            loading_options = get_loading_options({{ model.name }}, includes)
            if loading_options:
                query = query.options(*loading_options)

        # Ejecutar query
        def execute_query(session: Session) -> Optional[{{ model.name }}Read]:
            result = session.execute(query)
            instance = result.scalars().first()
            
            if instance:
                logger.info(f"[{{ schema_name }}] ‚úÖ {{ model.name }} encontrado exitosamente")
                return {{ model.name }}Read.from_instance(
                    instance, 
                    includes=includes, 
                    max_depth={{ max_depth }}
                )
            else:
                logger.info(f"[{{ schema_name }}] üì≠ {{ model.name }} no encontrado")
                return None

        if session is not None:
            return execute_query(session)
        else:
            with self.session_manager.get_session() as session:
                return execute_query(session)
    {% endif %}
    
    @error_handler
    def find_many(
        self,
        limit: Optional[int] = None, 
        offset: Optional[int] = None,
        order_by: Optional[List[str]] = None,
        order: Literal["ASC", "DESC"] = "ASC",
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        includes: Optional[List[str]] = None,
        rls: Optional[Union[List[RLS], RLS]] = None,
        session: Optional[Session] = None
    ) -> List[{{ model.name }}Read]:
        """
        Busca m√∫ltiples registros, filtrados, con carga optimizada de relaciones.
        
        Args:
        - limit: L√≠mite de registros a retornar
        - offset: N√∫mero de registros a saltar
        - order_by: Lista de nombres de columnas para ordenar los resultados
        - order: ASC/DESC (por defecto ASC). Solo se aplica si se especifica order_by.
        {{ macros.generate_query_args(model).rstrip('\n') | indent(8) }}
        - includes: Lista de relaciones a incluir (formato: 'relation' o 'relation.nested')
        - session: Sesi√≥n existente (opcional)
            
        Returns:
            Lista de instancias del modelo

        Examples:
            B√∫squeda simple con relaciones

            dao.find_many(limit=10, includes=['author'])
            
            Relaciones anidadas

            dao.find_many(
                ..., 
                includes=['author', 'author.profile', 'comments']
            )
            
            Ordenamiento ascendente por columnas

            dao.find_many(order_by=['created_at', 'name'], order='ASC')
            
            Ordenamiento descendente por columnas

            await dao.find_many(order_by=['created_at', 'name'], order='DESC')
            
            Paginaci√≥n

            # Obtener los primeros 10 registros
            dao.find_many(limit=10)
            
            # Obtener los √∫ltimos 5 registros ordenados por fecha
            dao.find_many(limit=5, order_by=['created_at'], order='DESC')
            
            # Paginaci√≥n con offset
            dao.find_many(limit=10, offset=20)
        """
        logger.info(f"[{{ schema_name }}] üîç Buscando m√∫ltiples {{ model.name }}:")
        logger.info(f"[{{ schema_name }}]     limit={limit}")
        logger.info(f"[{{ schema_name }}]     offset={offset}")
        logger.info(f"[{{ schema_name }}]     order_by={order_by}")
        logger.info(f"[{{ schema_name }}]     order={order}")
        logger.info(f"[{{ schema_name }}]     includes={includes}")

        # Construir query base
        query = select({{ model.name }})
        
        # Filters
        filters = {}
        
        # Aplicar filtros de b√∫squeda
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8)  }}
        
        # Log de par√°metros aplicados
        if filters:
            logger.info(f"[{{ schema_name }}]     filters={filters}")

        # Aplicar regla RLS (si existe)
        if rls is not None:
            query = RLSQueryApplicator.apply_rls(query, {{ model.name }}, rls)
        
        # Aplicar opciones de carga optimizada
        if includes:
            loading_options = get_loading_options({{ model.name }}, includes)
            if loading_options:
                query = query.options(*loading_options)
        
        # Aplicar ordenamiento
        if order_by:
            for column_name in order_by:
                if hasattr({{ model.name }}, column_name):
                    column = getattr({{ model.name }}, column_name)
                    if order.upper() == "DESC":
                        query = query.order_by(column.desc())
                    elif order.upper() == "ASC":
                        query = query.order_by(column.asc())
                else:
                    logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è Columna '{column_name}' no existe en modelo {{ model.name }}, ignorando en order_by")

        # Aplicar l√≠mite (solo valores positivos)
        if limit is not None and limit > 0:
            query = query.limit(limit)

        # Aplicar paginaci√≥n
        if offset is not None:
            query = query.offset(offset)

        # Ejecutar query
        def execute_query(session: Session) -> List[{{ model.name }}Read]:
            results = session.execute(query)
            instances = results.scalars().all()
            
            logger.info(f"[{{ schema_name }}] ‚úÖ Encontrados {len(instances)} registros {{ model.name }}")

            return [
                {{ model.name }}Read.from_instance(
                    instance, 
                    includes=includes, 
                    max_depth={{ max_depth }}
                ) 
                for instance in instances
            ]
        
        if session is not None:
            return execute_query(session)
        else:
            with self.session_manager.get_session() as session:
                return execute_query(session)

    def as_dataframe(
        self,
        limit: Optional[int] = None, 
        offset: Optional[int] = None,
        {% for column in model.columns %}
        {% if not column.args.get('autoincrement', False) %}
        {% if column.args.get('primary_key', False) or column.is_foreign_key %}
        {{ column.name }}: Optional[{{ column.type }}] = None,
        {% elif 'str' == column.type or 'Text' == column.type or 'bool' == column.type %}
        {{ column.name }}: Optional[{{ column.type }}] = None,
        {% elif  'date' == column.type or 'int' == column.type or 'BigInteger' == column.type %}
        {{ column.name }}: Optional[{{ column.type }}] = None,
        min_{{ column.name }}: Optional[{{ column.type }}] = None,
        max_{{ column.name }}: Optional[{{ column.type }}] = None,
        {% elif 'float' == column.type or 'Numeric' == column.type or 'datetime' == column.type or 'time' == column.type %}
        min_{{ column.name }}: Optional[{{ column.type }}] = None,
        max_{{ column.name }}: Optional[{{ column.type }}] = None,
        {% else %}
        {{ column.name }}: Optional[{{ column.type }}] = None,
        {% endif %}
        {% endif %}
        {% endfor %}
    ) -> DataFrame:
        """
        Busca m√∫ltiples registros estableciendo filtros y devuelve el resultado como pandas DataFrame.
        
        Args:
            limit: L√≠mite de registros a retornar (positivo para primeros n, negativo para √∫ltimos n - requiere order_by)
            offset: N√∫mero de registros a saltar
            {% for column in model.columns %}
            {% if not column.args.get('autoincrement', False) %}
            {% if column.args.get('primary_key', False) or column.is_foreign_key %}
            {{ column.name }}: Filtrar por {{ column.name }}
            {% elif 'str' == column.type or 'Text' == column.type or 'bool' == column.type %}
            {{ column.name }}: Filtrar por {{ column.name }}
            {% elif  'date' == column.type or 'int' == column.type or 'BigInteger' == column.type %}
            {{ column.name }}: Filtrar por {{ column.name }},
            min_{{ column.name }}: Filtrar por fecha m√≠nima (inclu√≠da)
            max_{{ column.name }}: Filtrar por fecha m√°xima (inclu√≠da)
            {% elif 'float' == column.type or 'Numeric' == column.type or 'datetime' == column.type or 'time' == column.type %}
            min_{{ column.name }}: Filtrar por valor m√≠nimo de {{ column.name }} (inclu√≠do)
            max_{{ column.name }}: Filtrar por valor m√°ximo de {{ column.name }} (inclu√≠do)
            {% else %}
            {{ column.name }}: Filtrar por {{ column.name }}
            {% endif %}
            {% endif %}
            {% endfor %}
            
        Returns:
            pandas.DataFrame con los registros encontrados
            
        Raises:
            ImportError: Si pandas no est√° instalado
            
        Example:
            ```python
            
            # Obtener todos los registros como DataFrame
            df = db_api.{{ model.name.lower() }}.as_dataframe()
            
            # Con filtros y l√≠mites
            df = db_api.{{ model.name.lower() }}.as_dataframe(
                limit=100,
                {% if model.columns %}
                {{ model.columns[0].name }}="valor_filtro"
                {% endif %}
            )
            
            # An√°lisis de datos
            print(df.describe())
            print(df.head())
            
            # Exportar a CSV
            df.to_csv('{{ model.name.lower() }}_data.csv', index=False)
            ```
        """
        try:
            import pandas as pd
        except ImportError:
            raise ImportError(
                "pandas no est√° instalado. Para usar find_as_dataframe(), instala pandas:\n"
                "pip install pandas\n"
                "o si usas poetry:\n"
                "poetry add pandas"
            )
        
        # Obtener los registros usando find_many
        records = self.find_many(
            limit=limit,
            offset=offset,
            {% for column in model.columns %}
            {% if not column.args.get('autoincrement', False) %}
            {% if column.args.get('primary_key', False) or column.is_foreign_key %}
            {{ column.name }}={{ column.name }},
            {% elif 'str' == column.type or 'Text' == column.type or 'bool' == column.type %}
            {{ column.name }}={{ column.name }},
            {% elif  'date' == column.type or 'int' == column.type or 'BigInteger' == column.type %}
            {{ column.name }}={{ column.name }},
            min_{{ column.name }}=min_{{ column.name }},
            max_{{ column.name }}=max_{{ column.name }},
            {% elif 'float' == column.type or 'Numeric' == column.type or 'datetime' == column.type or 'time' == column.type %}
            min_{{ column.name }}=min_{{ column.name }},
            max_{{ column.name }}=max_{{ column.name }},
            {% else %}
            {{ column.name }}={{ column.name }},
            {% endif %}
            {% endif %}
            {% endfor %}
        )

        # Si no hay registros, devolver DataFrame vac√≠o con las columnas del modelo
        if not records:
            return pd.DataFrame(columns=[
                {% for column in model.columns %}
                '{{ column.name }}'{{ ',' if not loop.last }}
                {% endfor %}
            ])

        data = [record.to_dict() for record in records]
        
        # Crear DataFrame
        df = pd.DataFrame(data)
        
        # Optimizar tipos de datos si es posible
        return self._optimize_dataframe_dtypes(df)

    def _optimize_dataframe_dtypes(self, df: DataFrame) -> DataFrame:
        """
        Optimiza los tipos de datos del DataFrame bas√°ndose en las columnas del modelo.
        
        Args:
            df: DataFrame a optimizar
            
        Returns:
            DataFrame con tipos de datos optimizados
        """
        try:
            import pandas as pd
        except ImportError:
            # Si pandas no est√° disponible, devolver el DataFrame tal como est√°
            return df
        
        if df.empty:
            return df
        
        # Mapeo de tipos SQLAlchemy a tipos pandas optimizados
        type_mapping = {
            {% for column in model.columns %}
            '{{ column.name }}': {% if 'int' == column.type or 'BigInteger' == column.type %}'int64'{% elif 'float' == column.type or 'Numeric' == column.type %}'float64'{% elif 'bool' == column.type %}'boolean'{% elif 'datetime' == column.type %}'datetime64[ns]'{% elif 'date' == column.type %}'datetime64[ns]'{% elif 'str' == column.type or 'Text' == column.type %}'string'{% else %}'object'{% endif %}{{ ',' if not loop.last }}
            {% endfor %}
        }
        
        # Aplicar conversiones de tipo de forma segura
        for column, target_type in type_mapping.items():
            if column in df.columns:
                try:
                    if target_type == 'int64':
                        # Manejar valores nulos en columnas enteras
                        df[column] = pd.to_numeric(df[column], errors='coerce').astype('Int64')
                    elif target_type == 'float64':
                        df[column] = pd.to_numeric(df[column], errors='coerce')
                    elif target_type == 'boolean':
                        df[column] = df[column].astype('boolean')
                    elif target_type == 'datetime64[ns]':
                        df[column] = pd.to_datetime(df[column], errors='coerce')
                    elif target_type == 'string':
                        df[column] = df[column].astype('string')
                    # 'object' se deja como est√°
                except Exception:
                    # Si falla la conversi√≥n, mantener el tipo original
                    continue
        
        return df

    {% if not model.is_view %}
    def from_dataframe(
        self,
        df: DataFrame,
        {% if not all_pk_autoincrement %}
        mode: Literal['create', 'upsert'] = "upsert",
        {% endif %}
        validate_types: bool = False,
        ignore_extra_columns: bool = False,
        fill_missing_nullable: bool = True
    ) -> int:
        """
        Ingesta un DataFrame de pandas en la tabla correspondiente.
        
        Realiza validaciones de esquema y tipos de datos antes de la inserci√≥n,
        y permite diferentes modos de inserci√≥n (create o upsert).
        
        Args:
            df: DataFrame de pandas con los datos a insertar
            {% if not all_pk_autoincrement %}
            mode ('upsert'): Modo de inserci√≥n - 'create' o 'upsert'
            {% endif %}
            validate_types (False): Si True, valida tipos de datos del DataFrame
            ignore_extra_columns (False): Si True, ignora columnas extra del DataFrame
            fill_missing_nullable (True): Si True, llena con None las columnas nullable faltantes
            
        Returns:
            N√∫mero de registros creados o actualizados
            
        Raises:
            ImportError: Si pandas no est√° instalado
            ValueError: Si el DataFrame no cumple con el esquema requerido
            TypeError: Si los tipos de datos no son compatibles
            
        Example:
            ```python
            import pandas as pd
            
            crud = {{ model.name }}SyncDAO(session_manager)
            
            # Crear DataFrame
            df = pd.DataFrame({
                {% for column in model.columns %}
                '{{ column.name }}': [{% if 'int' == column.type %}1, 2, 3{% elif 'str' == column.type %}'valor1', 'valor2', 'valor3'{% elif 'bool' == column.type %}True, False, True{% else %}None, None, None{% endif %}]{{ ',' if not loop.last }}
                {% endfor %}
            })
            
            # Inserci√≥n simple
            records = crud.from_df(df)
            
            # Upsert con validaciones relajadas
            records = crud.from_df(
                df, 
                mode='upsert',
                ignore_extra_columns=True
            )
            ```
        """
        
        if df.empty:
            return []

        {% if not all_pk_autoincrement %}
        # Validar modo
        if mode not in ['create', 'upsert']:
            raise ValueError("mode debe ser 'create' o 'upsert'")
        {% endif %}
        
        # Realizar validaciones del esquema
        self._df_validator.validate_dataframe_schema(df, ignore_extra_columns, fill_missing_nullable)
        
        # Validar tipos de datos si se solicita
        if validate_types:
            self._df_validator.validate_dataframe_types(df)
        
        # Preparar DataFrame para inserci√≥n
        cleaned_df = self._df_validator.prepare_dataframe_for_insertion(df, ignore_extra_columns, fill_missing_nullable)
        
        # Convertir DataFrame a lista de diccionarios
        records_data = cleaned_df.to_dict('records')
        
        # Limpiar valores NaN/None problem√°ticos
        records_data = self._df_validator.clean_records_data(records_data)
        
        # Ejecutar inserci√≥n seg√∫n el modo
        {% if not all_pk_autoincrement %}
        if mode == 'create':
            return self.create_many([{{ model.name }}Create.from_dict(record) for record in records_data])
        else:  # upsert
            return self.upsert_many([{{ model.name }}Create.from_dict(record) for record in records_data])
        {% else %}
        return self.create_many([{{ model.name }}Create.from_dict(record) for record in records_data])
        {% endif %}

    @error_handler
    def create(
        self, 
        {{ model.tablename }}: {{ model.name }}Create,
        session: Optional[Session] = None
    ) -> {{ model.name }}Read:
        """
        Crea un nuevo registro.
        
        Args:
            {{ model.tablename }}: Datos del {{ model.tablename }} a crear
            session: Sesi√≥n existente (opcional)
            
        Returns:
            Instancia del modelo creado
        """
        logger.info(f"[{{ schema_name }}] üÜï Creando nuevo {{ model.name }}")

        instance = {{ model.tablename }}.to_instance()

        if session is not None:
            session.add(instance)
            session.flush()  # Asegura que se genere el ID si es autoincrement
            included = load_relationships_from_dto(session, instance, {{ model.tablename }})
            data = {{ model.name }}Read.from_created_instance(instance, included)
        else:
            with self.session_manager.get_session() as session:
                session.add(instance)
                session.flush()
                included = load_relationships_from_dto(session, instance, {{ model.tablename }})
                data = {{ model.name }}Read.from_created_instance(instance, included)

        {% set pk_fields = [] %}
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        {% set _ = pk_fields.append(column.name) %}
        {% endif %}
        {% endfor %}
        {% if pk_fields %}
        logger.info(f"[{{ schema_name }}] ‚úÖ {{ model.name }} creado exitosamente con {% for pk in pk_fields %}{{ pk }}={getattr(data, '{{ pk }}', 'N/A')}{% if not loop.last %}, {% endif %}{% endfor %}")
        {% else %}
        logger.info(f"[{{ schema_name }}] ‚úÖ {{ model.name }} creado exitosamente")
        {% endif %}
        return data
    
    @error_handler
    def create_many(self, records: List[{{ model.name }}Create], session: Optional[Session] = None) -> int:
        """
        Crea m√∫ltiples registros en la tabla {{ model.tablename }}.
        
        Args:
            records: Lista de {{ model.name }}Create con los datos de los registros
            session: Sesi√≥n existente (opcional)
            
        Returns:
            N√∫mero de registros creados

        """
        logger.info(f"[{{ schema_name }}] üî¢ Creando {len(records)} registros {{ model.name }}")

        instances = []
        for record in records:
            instances.append(record.to_instance())
        
        if session is not None:
            session.add_all(instances)
            session.flush()  # Asegura que se generen los IDs si son autoincrement
        else:
            with self.session_manager.get_session() as session:
                session.add_all(instances)
                session.flush()  # Asegura que se generen los IDs si son autoincrement

        logger.info(f"[{{ schema_name }}] ‚úÖ {len(instances)} registros {{ model.name }} creados exitosamente")

        return len(instances)
    
    @error_handler
    def update(
        self, 
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        {{ column.name }}: {{ column.type }},
        {% endif -%}
        {% endfor %}
        updated_values: {{ model.name }}UpdateValues,
        session: Optional[Session] = None
    ) -> int:
        """
        Actualiza registros que coincidan con los filtros.
        
        Args:
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            {{ column.name }}: Identificador del registro
            {% endif -%}
            {% endfor %}
            updated_values: Datos a actualizar
            session: Sesi√≥n existente (opcional)
            
        Returns:
            N√∫mero de registros actualizados
        """

        update_data = updated_values.to_dict()

        if not update_data:  # Solo actualizar si hay datos
            return 0

        logger.info(f"[{{ schema_name }}] üîÑ Actualizando {{ model.name }}:")
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        logger.info(f"[{{ schema_name }}]     {{ column.name }}={{ '{' }}{{ column.name }}{{ '}' }}")
        {% endif %}
        {% endfor %}
        logger.info(f"[{{ schema_name }}]     valores={updated_values.to_dict()}")

        query = select({{ model.name }})

        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        query = query.where({{ model.name }}.{{ column.name }} == {{ column.name }})
        {% endif -%}
        {% endfor %}
        
        if session is not None:
            result = session.execute(query)
            record = result.scalar_one_or_none()
            if record is None:
                return 0
            for key, value in update_data.items():
                setattr(record, key, value)

            session.flush()  # Aplicar cambios a la base de datos  
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query)
                record = result.scalar_one_or_none()
                if record is None:
                    return 0
                for key, value in update_data.items():
                    setattr(record, key, value)

                session.flush()  # Aplicar cambios a la base de datos
        
        logger.info(f"[public]  ‚úÖ 1 registros {{ model.name }} actualizados exitosamente")

        return 1
    
    @error_handler
    def update_many(
        self,
        payload: {{ model.name }}Update, 
        session: Optional[Session] = None
    ) -> int:
        """
        Actualiza m√∫ltiples registros bas√°ndose en campos de coincidencia.
        
        Args:
            payload: Datos de actualizaci√≥n y filtros
            session: Sesi√≥n existente (opcional)
            
        Returns:
            N√∫mero total de registros actualizados
        """
        logger.info(f"[{{ schema_name }}] üîÑ Actualizando m√∫ltiples {{ model.name }} con filtros: {payload.filter.to_dict()}, valores: {payload.values.to_dict()}")

        filters = payload.filter.to_dict()
        values = payload.values.to_dict()
        
        if not filters and not values:  # Solo actualizar si hay filtros y valores
            return 0

        query = update({{ model.name }})

        for key, value in filters.items():
            query = query.where(getattr({{ model.name }}, key) == value)
        
        query = query.values(**values)
                
        if session is not None:
            result = session.execute(query)
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query)
        
        logger.info(f"[{{ schema_name }}] ‚úÖ {result.rowcount} registros {{ model.name }} actualizados masivamente exitosamente")

        return result.rowcount
    
    {% if not all_pk_autoincrement %}
    @error_handler
    def upsert(
        self,
        {{ model.tablename }}: {{ model.name }}Create,
        match_fields: List[str] = [
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            '{{ column.name }}'{{ ', ' if not loop.last }}
            {% endif %}
            {% endfor %}
        ],
        session: Optional[Session] = None
    ) -> {{ model.name }}DTO:
        """
        Inserta o actualiza un registro (upsert).
        
        Args:
            {{ model.tablename }}: Datos del registro a insertar o actualizar
            match_fields: Campos a usar para verificar si el registro existe. 
                         Por defecto usa las claves primarias.
            session: Sesi√≥n existente (opcional)
            
        Returns:
            Instancia del modelo (creada o actualizada)
        """
        logger.info(f"[{{ schema_name }}] üîÑ Upsert {{ model.name }} con campos de coincidencia: {match_fields}, datos: {{ "{" }}{{ model.tablename }}.to_dict(){{ "}" }}")

        record_dict = {{ model.tablename }}.to_dict()

        # Buscar registro existente usando los campos de coincidencia
        if not match_fields:
            raise ValueError("match_fields no puede estar vac√≠o. Debe contener al menos un campo para identificar registros.")

        for field in match_fields:
            if not field in record_dict:
                raise ValueError(f"El campo '{field}' debe estar presente en '{{ model.tablename }}' para upsert.")
            if record_dict[field] is None:
                raise ValueError(f"El campo '{field}' no puede ser None. Debe tener un valor para upsert.")

        filters = {field: getattr({{ model.tablename }}, field) for field in match_fields}

        def execute_query(session: Session) -> Optional[{{ model.name }}]:

            query = select({{ model.name }})
        
            for key, value in filters.items():
                query = query.where(getattr({{ model.name }}, key) == value)

            result = await session.execute(query)
            existing = result.scalars().first()
            
            if existing:
                # Actualizar registro existente usando la instancia de SQLAlchemy
                update_data = {k: v for k, v in record_dict.items() if k not in match_fields}

                if update_data:
                    # Actualizar atributos directamente en la instancia
                    for key, value in update_data.items():
                        if hasattr(existing, key):
                            setattr(existing, key, value)
                    
                    session.flush()  # Aplicar cambios a la base de datos
                return existing

            else:
                # Crear nuevo registro
                instance = {{ model.name }}(**record_dict)
                session.add(instance)
                session.flush()
                return instance

        if session is not None:
            instance = execute_query(session)
            result = {{ model.name }}Read.from_instance(instance)
            logger.info(f"[{{ schema_name }}] ‚úÖ Upsert {{ model.name }} completado exitosamente")
            return result
            
        else:
            with self.session_manager.get_session() as session:
                instance = execute_query(session)
                result = {{ model.name }}Read.from_instance(instance)
                logger.info(f"[{{ schema_name }}] ‚úÖ Upsert {{ model.name }} completado exitosamente")
                return result
    
    @error_handler
    def upsert_many(
        self,
        records: List[{{ model.name }}Create],
        match_fields: List[str] = [
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            '{{ column.name }}'{{ ', ' if not loop.last }}
            {% endif %}
            {% endfor %}
        ],
        session: Optional[Session] = None
    ) -> int:
        """
        Inserta o actualiza m√∫ltiples registros.
        
        Args:
            {{ model.tablename }}: Lista de registros a insertar o actualizar
            match_fields: Campos a usar para verificar si los registros existen
            session: Sesi√≥n existente (opcional)
            
        Returns:
            N√∫mero de registros creados o actualizados
        """
        logger.info(f"[{{ schema_name }}] üîÑ Upsert masivo {{ model.name }} con {len(records)} registros, campos de coincidencia: {match_fields}")

        results = []

        if session is not None:
            for record in records:
                result = self.upsert(record, match_fields, session)
                results.append(result)
        else:
            with self.session_manager.get_session() as session:
                for record in records:
                    result = self.upsert(record, match_fields, session)
                    results.append(result)

        logger.info(f"[{{ schema_name }}] ‚úÖ Upsert masivo {{ model.name }} completado: {len(results)} registros procesados")

        return len(results)
    
    {% endif %}
    @error_handler
    def delete(
        self, 
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        {{ column.name }}: {{ column.type }},
        {% endif %}
        {% endfor %}
        session: Optional[Session] = None
    ) -> int:
        """
        Elimina un registro atentiendo a su primary key.
        
        Args:
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            {{ column.name }}: Filtrar por {{ column.name }} para eliminar
            {% endif %}
            {% endfor %}
            session: Sesi√≥n existente (opcional)
            
        Returns:
            N√∫mero de registros eliminados
        """
        logger.info(f"[{{ schema_name }}] üóëÔ∏è Eliminando {{ model.name }}:")
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        logger.info(f"[{{ schema_name }}]    {{ column.name }}={{ '{' }}{{ column.name }}{{ '}' }}")
        {% endif %}
        {% endfor %}

        query = delete({{ model.name }})
        
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        query = query.where({{ model.name }}.{{ column.name }} == {{ column.name }})
        {% endif %}
        {% endfor %}

        if session is not None:
            result = session.execute(query)
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query)

        logger.info(f"[{{ schema_name }}] ‚úÖ {result.rowcount} registros {{ model.name }} eliminados exitosamente")

        return result.rowcount
    
    @error_handler
    def delete_many(self, filters_list: List[Dict[str, Any]] = [], session: Optional[Session] = None) -> int:
        """
        Elimina m√∫ltiples registros bas√°ndose en una lista de filtros.
        
        Args:
            filters_list: Lista de diccionarios con filtros para cada eliminaci√≥n
            
        Returns:
            N√∫mero total de registros eliminados
        """
        logger.info(f"[{{ schema_name }}] üóëÔ∏è  Eliminando m√∫ltiples {{ model.name }} con {len(filters_list)} filtros")

        def execute_query(session: Session) -> int:
            query = delete({{ model.name }})
            for filters in filters_list:
                for key, value in filters.items():
                    if hasattr({{ model.name }}, key):
                        query = query.where(getattr({{ model.name }}, key) == value)
                
            result = session.execute(query)
            return result.rowcount
        
        if session is not None:
            total_deleted = execute_query(session)
        else:
            with self.session_manager.get_session() as session:
                total_deleted = execute_query(session)
        
        logger.info(f"[{{ schema_name }}] ‚úÖ {total_deleted} registros {{ model.name }} eliminados masivamente exitosamente")

        return total_deleted
    {% endif %}
    
    @error_handler
    def count(
        self,
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[Session] = None
    ) -> int:
        """
        Cuenta registros que coincidan con los filtros.
        
        Args:
        {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
        - session: Sesi√≥n existente (opcional)
            
        Returns:
            N√∫mero de registros que coinciden con los filtros
        """
        logger.info(f"[{{ schema_name }}] üî¢ Contando registros {{ model.name }} con filtros aplicados")
        
        query = select(func.count()).select_from({{ model.name }})
        
        # Filters
        filters = {}
        
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8) }}
        
        # Log de par√°metros aplicados
        if filters:
            logger.info(f"[{{ schema_name }}]     filters={filters}")

        if session is not None:
            result = session.execute(query).scalar()
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query).scalar()

        count_result = result.scalar() or 0
        logger.info(f"[{{ schema_name }}] ‚úÖ Conteo {{ model.name }} completado: {count_result} registros")
        return count_result

    @error_handler
    def sum(
        self,
        agg_fields: List[str],
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[Session] = None
    ) -> AggregationResult:
        """
        Suma los valores de campos espec√≠ficos que coincidan con los filtros.
        
        Args:
            - agg_fields: Lista de nombres de campos a sumar
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            - session: Sesi√≥n existente (opcional)
            
        Returns:
            AggregationResult con informaci√≥n detallada de la operaci√≥n:
            - success: True si al menos un campo fue procesado
            - data: Diccionario con las sumas {"sum_<field>": value}
            - processed_fields: Lista de campos procesados exitosamente
            - warnings: Lista de advertencias (campos no num√©ricos)
            - errors: Lista de errores (campos inexistentes)
            - metadata: Informaci√≥n adicional sobre la operaci√≥n
        """
        logger.info(f"[{{ schema_name }}] üßÆ Sumando campos {agg_fields} de registros {{ model.name }} con filtros aplicados")
        
        warnings = []
        errors = []
        valid_fields = []
        
        if not agg_fields:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No se proporcionaron campos para sumar")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=[],
                errors=["No se proporcionaron campos para sumar"],
                metadata={"total_requested_fields": 0}
            )
        
        # Validar que los campos existen en el modelo y son de tipo v√°lido
        for field in agg_fields:
            if hasattr({{ model.name }}, field):
                column = getattr({{ model.name }}, field)
                column_type = str(column.type).upper()
                # Usar validadores gen√©ricos
                if any(valid_type in column_type for valid_type in self.OPERATION_TYPE_VALIDATORS['sum']):
                    valid_fields.append(field)
                else:
                    warning_msg = f"Campo '{field}' de tipo '{column_type}' no es v√°lido para suma"
                    warnings.append(warning_msg)
                    logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {warning_msg}")
            else:
                error_msg = f"Campo '{field}' no existe en modelo {{ model.name }}"
                errors.append(error_msg)
                logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
        
        if not valid_fields:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No hay campos v√°lidos para sumar")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=warnings,
                errors=errors,
                metadata={
                    "total_requested_fields": len(agg_fields),
                    "valid_fields_count": 0
                }
            )
        
        # Construir las expresiones de suma
        sum_expressions = []
        for field in valid_fields:
            column = getattr({{ model.name }}, field)
            sum_expressions.append(func.sum(column).label(f"sum_{field}"))
        
        query = select(*sum_expressions)
        
        # Filters
        filters = {}
        
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8) }}
        
        # Log de par√°metros aplicados
        if filters:
            logger.info(f"[{{ schema_name }}]     filters={filters}")

        if session is not None:
            result = session.execute(query)
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query)

        # Obtener el resultado y construir el diccionario
        row = result.first()
        sum_result = {}
        
        if row:
            for field in valid_fields:
                sum_key = f"sum_{field}"
                sum_value = getattr(row, sum_key)
                sum_result[sum_key] = float(sum_value) if sum_value is not None else None
        else:
            # Si no hay resultados, devolver None para todos los campos
            for field in valid_fields:
                sum_result[f"sum_{field}"] = None
        
        logger.info(f"[{{ schema_name }}] ‚úÖ Suma {{ model.name }} completada: {sum_result}")
        
        return AggregationResult(
            success=True,
            data=sum_result,
            processed_fields=valid_fields,
            warnings=warnings,
            errors=errors,
            metadata={
                "total_requested_fields": len(agg_fields),
                "valid_fields_count": len(valid_fields),
                "operation": "sum"
            }
        )
    
    @error_handler
    def mean(
        self,
        agg_fields: List[str],
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[Session] = None
    ) -> AggregationResult:
        """
        Calcula la media de los valores de campos espec√≠ficos que coincidan con los filtros.
        
        Args:
            - agg_fields: Lista de nombres de campos para calcular la media
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            - session: Sesi√≥n existente (opcional)
            
        Returns:
            AggregationResult con informaci√≥n detallada de la operaci√≥n:
            - success: True si al menos un campo fue procesado
            - data: Diccionario con las medias {"mean_<field>": value}
            - processed_fields: Lista de campos procesados exitosamente
            - warnings: Lista de advertencias (campos no num√©ricos)
            - errors: Lista de errores (campos inexistentes)
            - metadata: Informaci√≥n adicional sobre la operaci√≥n
        """
        logger.info(f"[{{ schema_name }}] üìä Calculando media de campos {agg_fields} de registros {{ model.name }} con filtros aplicados")
        
        warnings = []
        errors = []
        valid_fields = []
        
        if not agg_fields:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No se proporcionaron campos para calcular la media")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=[],
                errors=["No se proporcionaron campos para calcular la media"],
                metadata={"total_requested_fields": 0}
            )
        
        # Validar que los campos existen en el modelo y son de tipo v√°lido
        for field in agg_fields:
            if hasattr({{ model.name }}, field):
                column = getattr({{ model.name }}, field)
                column_type = str(column.type).upper()
                # Usar validadores gen√©ricos
                if any(valid_type in column_type for valid_type in self.OPERATION_TYPE_VALIDATORS['mean']):
                    valid_fields.append(field)
                else:
                    warning_msg = f"Campo '{field}' de tipo '{column_type}' no es v√°lido para media"
                    warnings.append(warning_msg)
                    logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {warning_msg}")
            else:
                error_msg = f"Campo '{field}' no existe en modelo {{ model.name }}"
                errors.append(error_msg)
                logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
        
        if not valid_fields:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No hay campos v√°lidos para calcular la media")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=warnings,
                errors=errors,
                metadata={
                    "total_requested_fields": len(agg_fields),
                    "valid_fields_count": 0
                }
            )
        
        # Construir las expresiones de media
        mean_expressions = []
        for field in valid_fields:
            column = getattr({{ model.name }}, field)
            mean_expressions.append(func.avg(column).label(f"mean_{field}"))
        
        query = select(*mean_expressions)
        
        # Filters
        filters = {}
        
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8) }}
        
        # Log de par√°metros aplicados
        if filters:
            logger.info(f"[{{ schema_name }}]     filters={filters}")

        if session is not None:
            result = session.execute(query)
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query)

        # Obtener el resultado y construir el diccionario
        row = result.first()
        mean_result = {}
        
        if row:
            for field in valid_fields:
                mean_key = f"mean_{field}"
                mean_value = getattr(row, mean_key)
                mean_result[mean_key] = float(mean_value) if mean_value is not None else None
        else:
            # Si no hay resultados, devolver None para todos los campos
            for field in valid_fields:
                mean_result[f"mean_{field}"] = None
        
        logger.info(f"[{{ schema_name }}] ‚úÖ Media {{ model.name }} completada: {mean_result}")
        
        return AggregationResult(
            success=True,
            data=mean_result,
            processed_fields=valid_fields,
            warnings=warnings,
            errors=errors,
            metadata={
                "total_requested_fields": len(agg_fields),
                "valid_fields_count": len(valid_fields),
                "operation": "mean"
            }
        )
    
    @error_handler
    def max(
        self,
        agg_fields: List[str],
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[Session] = None
    ) -> AggregationResult:
        """
        Encuentra el valor m√°ximo de campos espec√≠ficos que coincidan con los filtros.
        
        Args:
            - agg_fields: Lista de nombres de campos para encontrar el m√°ximo
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            - session: Sesi√≥n existente (opcional)
            
        Returns:
            AggregationResult con informaci√≥n detallada de la operaci√≥n:
            - success: True si al menos un campo fue procesado
            - data: Diccionario con los m√°ximos {"max_<field>": value}
            - processed_fields: Lista de campos procesados exitosamente
            - warnings: Lista de advertencias (campos no v√°lidos)
            - errors: Lista de errores (campos inexistentes)
            - metadata: Informaci√≥n adicional sobre la operaci√≥n
        """
        logger.info(f"[{{ schema_name }}] üî∫ Calculando m√°ximo de campos {agg_fields} de registros {{ model.name }} con filtros aplicados")
        
        warnings = []
        errors = []
        valid_fields = []
        field_types = {}  # Trackear el tipo de cada campo para parsear el resultado
        
        if not agg_fields:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No se proporcionaron campos para calcular el m√°ximo")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=[],
                errors=["No se proporcionaron campos para calcular el m√°ximo"],
                metadata={"total_requested_fields": 0}
            )
        
        # Validar que los campos existen en el modelo y son de tipo v√°lido
        for field in agg_fields:
            if hasattr({{ model.name }}, field):
                column = getattr({{ model.name }}, field)
                column_type = str(column.type).upper()
                # Usar validadores gen√©ricos
                if any(valid_type in column_type for valid_type in self.OPERATION_TYPE_VALIDATORS['max']):
                    # Determinar el tipo del campo
                    if any(num_type in column_type for num_type in ['INTEGER', 'FLOAT', 'NUMERIC', 'DECIMAL', 'DOUBLE', 'REAL', 'BIGINT', 'SMALLINT', 'TINYINT']):
                        field_types[field] = 'numeric'
                    elif any(date_type in column_type for date_type in ['DATETIME', 'TIMESTAMP', 'DATE', 'TIME']):
                        field_types[field] = 'datetime'
                    valid_fields.append(field)
                else:
                    warning_msg = f"Campo '{field}' de tipo '{column_type}' no es v√°lido para m√°ximo"
                    warnings.append(warning_msg)
                    logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {warning_msg}")
            else:
                error_msg = f"Campo '{field}' no existe en modelo {{ model.name }}"
                errors.append(error_msg)
                logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
        
        if not valid_fields:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No hay campos v√°lidos para calcular el m√°ximo")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=warnings,
                errors=errors,
                metadata={
                    "total_requested_fields": len(agg_fields),
                    "valid_fields_count": 0
                }
            )
        
        # Construir las expresiones de m√°ximo
        max_expressions = []
        for field in valid_fields:
            column = getattr({{ model.name }}, field)
            max_expressions.append(func.max(column).label(f"max_{field}"))
        
        query = select(*max_expressions)
        
        # Filters
        filters = {}
        
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8) }}
        
        # Log de par√°metros aplicados
        if filters:
            logger.info(f"[{{ schema_name }}]     filters={filters}")

        if session is not None:
            result = session.execute(query)
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query)

        # Obtener el resultado y construir el diccionario
        row = result.first()
        max_result = {}
        
        if row:
            for field in valid_fields:
                max_key = f"max_{field}"
                max_value = getattr(row, max_key)
                if max_value is not None:
                    # Parsear seg√∫n el tipo de campo
                    if field_types[field] == 'numeric':
                        max_result[max_key] = float(max_value)
                    elif field_types[field] == 'datetime':
                        max_result[max_key] = max_value.isoformat() if hasattr(max_value, 'isoformat') else str(max_value)
                else:
                    max_result[max_key] = None
        else:
            # Si no hay resultados, devolver None para todos los campos
            for field in valid_fields:
                max_result[f"max_{field}"] = None
        
        logger.info(f"[{{ schema_name }}] ‚úÖ M√°ximo {{ model.name }} completado: {max_result}")
        
        return AggregationResult(
            success=True,
            data=max_result,
            processed_fields=valid_fields,
            warnings=warnings,
            errors=errors,
            metadata={
                "total_requested_fields": len(agg_fields),
                "valid_fields_count": len(valid_fields),
                "field_types": field_types,
                "operation": "max"
            }
        )
    
    @error_handler
    def min(
        self,
        agg_fields: List[str],
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[Session] = None
    ) -> AggregationResult:
        """
        Encuentra el valor m√≠nimo de campos espec√≠ficos que coincidan con los filtros.
        
        Args:
            - agg_fields: Lista de nombres de campos para encontrar el m√≠nimo
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            - session: Sesi√≥n existente (opcional)
            
        Returns:
            AggregationResult con informaci√≥n detallada de la operaci√≥n:
            - success: True si al menos un campo fue procesado
            - data: Diccionario con los m√≠nimos {"min_<field>": value}
            - processed_fields: Lista de campos procesados exitosamente
            - warnings: Lista de advertencias (campos no v√°lidos)
            - errors: Lista de errores (campos inexistentes)
            - metadata: Informaci√≥n adicional sobre la operaci√≥n
        """
        logger.info(f"[{{ schema_name }}] üîª Calculando m√≠nimo de campos {agg_fields} de registros {{ model.name }} con filtros aplicados")
        
        warnings = []
        errors = []
        valid_fields = []
        field_types = {}  # Trackear el tipo de cada campo para parsear el resultado
        
        if not agg_fields:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No se proporcionaron campos para calcular el m√≠nimo")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=[],
                errors=["No se proporcionaron campos para calcular el m√≠nimo"],
                metadata={"total_requested_fields": 0}
            )
        
        # Validar que los campos existen en el modelo y son de tipo v√°lido
        for field in agg_fields:
            if hasattr({{ model.name }}, field):
                column = getattr({{ model.name }}, field)
                column_type = str(column.type).upper()
                # Usar validadores gen√©ricos
                if any(valid_type in column_type for valid_type in self.OPERATION_TYPE_VALIDATORS['min']):
                    # Determinar el tipo del campo
                    if any(num_type in column_type for num_type in ['INTEGER', 'FLOAT', 'NUMERIC', 'DECIMAL', 'DOUBLE', 'REAL', 'BIGINT', 'SMALLINT', 'TINYINT']):
                        field_types[field] = 'numeric'
                    elif any(date_type in column_type for date_type in ['DATETIME', 'TIMESTAMP', 'DATE', 'TIME']):
                        field_types[field] = 'datetime'
                    valid_fields.append(field)
                else:
                    warning_msg = f"Campo '{field}' de tipo '{column_type}' no es v√°lido para m√≠nimo"
                    warnings.append(warning_msg)
                    logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {warning_msg}")
                    logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {warning_msg}")
            else:
                error_msg = f"Campo '{field}' no existe en modelo {{ model.name }}"
                errors.append(error_msg)
                logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
        
        if not valid_fields:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No hay campos v√°lidos para calcular el m√≠nimo")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=warnings,
                errors=errors,
                metadata={
                    "total_requested_fields": len(agg_fields),
                    "valid_fields_count": 0
                }
            )
        
        # Construir las expresiones de m√≠nimo
        min_expressions = []
        for field in valid_fields:
            column = getattr({{ model.name }}, field)
            min_expressions.append(func.min(column).label(f"min_{field}"))
        
        query = select(*min_expressions)
        
        # Filters
        filters = {}
        
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8) }}
        
        # Log de par√°metros aplicados
        if filters:
            logger.info(f"[{{ schema_name }}]     filters={filters}")

        if session is not None:
            result = session.execute(query)
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query)

        # Obtener el resultado y construir el diccionario
        row = result.first()
        min_result = {}
        
        if row:
            for field in valid_fields:
                min_key = f"min_{field}"
                min_value = getattr(row, min_key)
                if min_value is not None:
                    # Parsear seg√∫n el tipo de campo
                    if field_types[field] == 'numeric':
                        min_result[min_key] = float(min_value)
                    elif field_types[field] == 'datetime':
                        min_result[min_key] = min_value.isoformat() if hasattr(min_value, 'isoformat') else str(min_value)
                else:
                    min_result[min_key] = None
        else:
            # Si no hay resultados, devolver None para todos los campos
            for field in valid_fields:
                min_result[f"min_{field}"] = None
        
        logger.info(f"[{{ schema_name }}] ‚úÖ M√≠nimo {{ model.name }} completado: {min_result}")
        
        return AggregationResult(
            success=True,
            data=min_result,
            processed_fields=valid_fields,
            warnings=warnings,
            errors=errors,
            metadata={
                "total_requested_fields": len(agg_fields),
                "valid_fields_count": len(valid_fields),
                "field_types": field_types,
                "operation": "min"
            }
        )
    
    @error_handler
    def agg(
        self,
        aggregations: Dict[str, Union[List[str], List[Dict[str, Any]]]],
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[Session] = None
    ) -> AggregationResult:
        """
        Realiza m√∫ltiples operaciones de agregaci√≥n en una sola consulta.
        
        Args:
            - aggregations: Diccionario con operaciones y campos/expresiones a agregar.
                           Formato:
                           {
                               "sum": ["field1", "field2/field3", {"expr": "revenue-cost", "as": "profit"}],
                               "mean": ["field4", "(field5+field6)/2"],
                               "max": ["created_at"],
                               "min": ["updated_at"],
                               "count": ["id", "status"]
                           }
                           
                           Cada campo puede ser:
                           - str: Nombre de campo simple o expresi√≥n aritm√©tica
                           - dict: Objeto con 'expr' (expresi√≥n) y opcionalmente 'as' (alias)
                           
                           Operaciones soportadas:
                           - sum: Suma de valores num√©ricos
                           - mean: Promedio de valores num√©ricos
                           - max: Valor m√°ximo (num√©rico o fechas)
                           - min: Valor m√≠nimo (num√©rico o fechas)
                           - count: Conteo de registros (cualquier tipo de campo)
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            - session: Sesi√≥n existente (opcional)
            
        Returns:
            AggregationResult con informaci√≥n detallada de todas las operaciones:
            - success: True si al menos un campo fue procesado
            - data: Diccionario con todos los resultados {"operation_field": value} o {"operation_alias": value}
            - processed_fields: Lista de todos los campos/expresiones procesados exitosamente
            - warnings: Lista de advertencias (campos no v√°lidos para su operaci√≥n)
            - errors: Lista de errores (operaciones no soportadas, campos inexistentes, errores en expresiones)
            - metadata: Informaci√≥n detallada por operaci√≥n
            
        Examples:
            ```python
            # Expresiones simples en strings
            result = dao.agg(
                aggregations={
                    "sum": ["price/quantity", "total*tax"],
                    "mean": ["(revenue-cost)/items"]
                },
                category="electronics"
            )
            print(result.data["sum_price_quantity"])
            
            # Con aliases personalizados
            result = dao.agg(
                aggregations={
                    "sum": [
                        {"expr": "revenue-cost", "as": "profit"},
                        {"expr": "price*quantity", "as": "total_value"}
                    ]
                },
                category="electronics"
            )
            print(result.data["sum_profit"])
            
            # Mixto: campos simples y expresiones
            result = dao.agg(
                aggregations={
                    "sum": ["price", "total"],
                    "mean": ["quantity"],
                    "max": ["created_at"],
                    "min": ["updated_at"],
                    "count": ["id"]
                }
            )
            print(result.data["sum_price"])
            print(result.data["mean_quantity"])
            print(result.data["count_id"])
            print(result.metadata["operations_summary"])
            ```
        """
        logger.info(f"[{{ schema_name }}] üéØ Realizando agregaciones m√∫ltiples en {{ model.name }}: {list(aggregations.keys())}")
        
        warnings = []
        errors = []
        all_valid_fields = []
        operations_metadata = {}
        
        if not aggregations:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No se proporcionaron operaciones de agregaci√≥n")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=[],
                errors=["No se proporcionaron operaciones de agregaci√≥n"],
                metadata={"total_operations": 0}
            )
        
        # Validar y construir expresiones de agregaci√≥n
        agg_expressions = []
        
        for operation, fields in aggregations.items():
            # Validar que la operaci√≥n es soportada
            if operation not in self.OPERATION_TYPE_VALIDATORS:
                error_msg = f"Operaci√≥n '{operation}' no soportada. Operaciones v√°lidas: {list(self.OPERATION_TYPE_VALIDATORS.keys())}"
                errors.append(error_msg)
                logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
                continue
            
            if not fields:
                warning_msg = f"No se proporcionaron campos para la operaci√≥n '{operation}'"
                warnings.append(warning_msg)
                logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {warning_msg}")
                continue
            
            # Validar campos para esta operaci√≥n
            valid_fields_for_operation = []
            field_types_for_operation = {}
            field_label_mapping = {}  # Mapeo de field_key -> label_name
            
            for field in fields:
                try:
                    # Extraer expresi√≥n y alias
                    if isinstance(field, dict):
                        expression = field.get('expr', field.get('expression', ''))
                        alias = field.get('as', field.get('alias'))
                        if not expression:
                            error_msg = f"Diccionario de campo sin 'expr' o 'expression': {field}"
                            errors.append(error_msg)
                            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
                            continue
                    else:
                        expression = str(field)
                        alias = None
                    
                    # Detectar si es una expresi√≥n aritm√©tica
                    is_expression = any(op in expression for op in ['+', '-', '*', '/', '%', '(', ')'])
                    
                    if is_expression:
                        # Parsear expresi√≥n usando ExpressionParser
                        try:
                            column_expr = ExpressionParser.parse(expression, {{ model.name }})
                            
                            # Generar label y field_key
                            if alias:
                                field_key = alias
                                label_name = f"{operation}_{alias}"
                            else:
                                clean_expr = ExpressionParser.get_field_name(expression)
                                field_key = clean_expr
                                label_name = f"{operation}_{clean_expr}"
                            
                            # Agregar a campos v√°lidos
                            valid_fields_for_operation.append(field_key)
                            all_valid_fields.append(field_key)
                            field_label_mapping[field_key] = label_name
                            
                            # Construir expresi√≥n de agregaci√≥n
                            sql_func = self.OPERATION_FUNCTIONS[operation]
                            agg_expressions.append(sql_func(column_expr).label(label_name))
                            
                            # Las expresiones siempre son num√©ricas
                            if operation in ['max', 'min']:
                                field_types_for_operation[field_key] = 'numeric'
                            
                        except ValueError as e:
                            error_msg = f"Error al parsear expresi√≥n '{expression}': {str(e)}"
                            errors.append(error_msg)
                            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
                    
                    else:
                        # Campo simple (l√≥gica actual)
                        if hasattr({{ model.name }}, expression):
                            column = getattr({{ model.name }}, expression)
                            column_type = str(column.type).upper()
                            
                            # Validar tipo usando validadores gen√©ricos
                            if any(valid_type in column_type for valid_type in self.OPERATION_TYPE_VALIDATORS[operation]):
                                # Generar label y field_key
                                if alias:
                                    field_key = alias
                                    label_name = f"{operation}_{alias}"
                                else:
                                    field_key = expression
                                    label_name = f"{operation}_{expression}"
                                
                                valid_fields_for_operation.append(field_key)
                                all_valid_fields.append(field_key)
                                field_label_mapping[field_key] = label_name
                                
                                # Determinar tipo de campo para max/min
                                if operation in ['max', 'min']:
                                    if any(num_type in column_type for num_type in ['INTEGER', 'FLOAT', 'NUMERIC', 'DECIMAL', 'DOUBLE', 'REAL', 'BIGINT', 'SMALLINT', 'TINYINT']):
                                        field_types_for_operation[field_key] = 'numeric'
                                    elif any(date_type in column_type for date_type in ['DATETIME', 'TIMESTAMP', 'DATE', 'TIME']):
                                        field_types_for_operation[field_key] = 'datetime'
                                
                                # Construir expresi√≥n SQL
                                sql_func = self.OPERATION_FUNCTIONS[operation]
                                agg_expressions.append(sql_func(column).label(label_name))
                            else:
                                warning_msg = f"Campo '{expression}' de tipo '{column_type}' no es v√°lido para operaci√≥n '{operation}'"
                                warnings.append(warning_msg)
                                logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {warning_msg}")
                        else:
                            error_msg = f"Campo '{expression}' no existe en modelo {{ model.name }}"
                            errors.append(error_msg)
                            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
                
                except Exception as e:
                    error_msg = f"Error inesperado procesando campo '{field}': {str(e)}"
                    errors.append(error_msg)
                    logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è {error_msg}")
            
            # Guardar metadata de esta operaci√≥n
            if valid_fields_for_operation:
                operations_metadata[operation] = {
                    "requested_fields": [f if isinstance(f, str) else f.get('expr', str(f)) for f in fields],
                    "valid_fields": valid_fields_for_operation,
                    "field_label_mapping": field_label_mapping,
                    "valid_count": len(valid_fields_for_operation),
                    "invalid_count": len(fields) - len(valid_fields_for_operation)
                }
                
                if operation in ['max', 'min'] and field_types_for_operation:
                    operations_metadata[operation]["field_types"] = field_types_for_operation
        
        # Si no hay expresiones v√°lidas, retornar error
        if not agg_expressions:
            logger.warning(f"[{{ schema_name }}] ‚ö†Ô∏è No hay operaciones v√°lidas para ejecutar")
            return AggregationResult(
                success=False,
                data={},
                processed_fields=[],
                warnings=warnings,
                errors=errors,
                metadata={
                    "total_operations": len(aggregations),
                    "valid_operations": 0,
                    "operations_summary": operations_metadata
                }
            )
        
        # Construir query con todas las agregaciones
        query = select(*agg_expressions)
        
        # Filters
        filters = {}
        
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8) }}
        
        # Log de par√°metros aplicados
        if filters:
            logger.info(f"[{{ schema_name }}]     filters={filters}")

        if session is not None:
            result = session.execute(query)
        else:
            with self.session_manager.get_session() as session:
                result = session.execute(query)

        # Obtener el resultado y construir el diccionario
        row = result.first()
        agg_result = {}
        
        if row:
            for operation, metadata in operations_metadata.items():
                field_label_mapping = metadata.get("field_label_mapping", {})
                for field in metadata["valid_fields"]:
                    # Usar el label real que se gener√≥, no el nombre del campo
                    label_name = field_label_mapping.get(field, f"{operation}_{field}")
                    result_value = getattr(row, label_name)
                    
                    # La clave en el resultado sigue siendo operation_field para consistencia
                    result_key = f"{operation}_{field}"
                    
                    if result_value is not None:
                        # Parsear seg√∫n el tipo de campo y operaci√≥n
                        if operation == 'count':
                            agg_result[result_key] = int(result_value)
                        elif operation in ['max', 'min'] and 'field_types' in metadata:
                            if metadata['field_types'].get(field) == 'datetime':
                                agg_result[result_key] = result_value.isoformat() if hasattr(result_value, 'isoformat') else str(result_value)
                            else:
                                agg_result[result_key] = float(result_value)
                        elif operation in ['sum', 'mean']:
                            agg_result[result_key] = float(result_value)
                        else:
                            agg_result[result_key] = result_value
                    else:
                        agg_result[result_key] = None if operation != 'count' else 0
        else:
            # Si no hay resultados, devolver None para todos los campos (0 para count)
            for operation, metadata in operations_metadata.items():
                for field in metadata["valid_fields"]:
                    result_key = f"{operation}_{field}"
                    agg_result[result_key] = 0 if operation == 'count' else None
        
        logger.info(f"[{{ schema_name }}] ‚úÖ Agregaciones m√∫ltiples {{ model.name }} completadas: {len(agg_expressions)} expresiones procesadas")
        
        return AggregationResult(
            success=True,
            data=agg_result,
            processed_fields=all_valid_fields,
            warnings=warnings,
            errors=errors,
            metadata={
                "total_operations": len(aggregations),
                "valid_operations": len(operations_metadata),
                "total_expressions": len(agg_expressions),
                "operations_summary": operations_metadata
            }
        )
    
    @error_handler
    def exists(
        self,
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[Session] = None
    ) -> bool:
        """
        Verifica si existe al menos un registro que coincida con los filtros.
        
        Args:
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            session: Sesi√≥n existente (opcional)
            
        Returns:
            True si existe al menos un registro, False en caso contrario
        """
        logger.info(f"[{{ schema_name }}] ‚ùì Verificando existencia de registros {{ model.name }}")
        records = self.count(
            {{ macros.asing_parameters(model).rstrip('\n') | indent(12) }}
            session=session
        )
        exists_result = records > 0
        logger.info(f"[{{ schema_name }}] ‚úÖ Verificaci√≥n {{ model.name }} completada: {'existe' if exists_result else 'no existe'}")
        return exists_result
    
{% endfor %}