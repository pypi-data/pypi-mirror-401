toolsets:
  kubernetes/core:
    description: "Read access to cluster resources (excluding secrets and other sensitive data)"
    docs_url: "https://holmesgpt.dev/data-sources/builtin-toolsets/kubernetes/"
    icon_url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRPKA-U9m5BxYQDF1O7atMfj9EMMXEoGu4t0Q&s"
    tags:
      - core
    prerequisites:
      - command: "kubectl version --client"

    # Note: Many tools in this toolset use transformers with llm_summarize
    # to automatically summarize large kubectl outputs when a fast model is configured.
    # This reduces context window usage while preserving key information for debugging.

    tools:
      - name: "kubectl_describe"
        description: >
          Run kubectl describe <kind> <name> -n <namespace>,
          call this when users ask for description,
          for example when a user asks
            - 'describe pod xyz-123'
            - 'show service xyz-123 in namespace my-ns'
        command: "kubectl describe {{ kind }} {{ name }}{% if namespace %} -n {{ namespace }}{% endif %}"
        transformers:
          - name: llm_summarize
            config:
              input_threshold: 1000
              prompt: |
                Summarize this kubectl describe output focusing on:
                - What needs attention or immediate action
                - Resource status and health indicators
                - Any errors, warnings, or non-standard states
                - Key configuration details that could affect functionality
                - When possible, mention exact field names so the user can grep for specific details
                - Be concise: aim for ≤ 50% of the original length; avoid repeating defaults/healthy/unchanged details
                - Prefer aggregates and counts; list only outliers and actionable items
                - Keep grep-friendly: include exact field names/values that matter

      - name: "kubectl_get_by_name"
        description: "Run `kubectl get <kind> <name> --show-labels`"
        command: "kubectl get --show-labels -o wide {{ kind }} {{ name }}{% if namespace %} -n {{ namespace }}{% endif %}"

      - name: "kubectl_get_by_kind_in_namespace"
        description: "Run `kubectl get <kind> -n <namespace> --show-labels` to get all resources of a given type in namespace"
        command: "kubectl get --show-labels -o wide {{ kind }} -n {{namespace}}"
        transformers:
          - name: llm_summarize
            config:
              input_threshold: 1000
              prompt: |
                Summarize this kubectl output focusing on:
                - What needs attention or immediate action
                - Group similar resources into aggregate descriptions
                - Make sure to mention outliers, errors, and non-standard states
                - List healthy resources as aggregate descriptions
                - When listing unhealthy resources, also try to use aggregate descriptions when possible
                - When possible, mention exact keywords so the user can rerun the command with | grep <keyword> and drill down
                - Be concise and avoid expansion: target ≤ 50% of input size; prefer counts + outliers over full listings

      - name: "kubectl_get_by_kind_in_cluster"
        description: "Run `kubectl get -A <kind> --show-labels` to get all resources of a given type in the cluster"
        command: "kubectl get -A --show-labels -o wide {{ kind }}"
        transformers:
          - name: llm_summarize
            config:
              input_threshold: 1000
              prompt: |
                Summarize this kubectl output focusing on:
                - What needs attention or immediate action
                - Group similar resources into a single line and description
                - Make sure to mention outliers, errors, and non-standard states
                - List healthy resources as aggregate descriptions
                - When listing unhealthy resources, also try to use aggregate descriptions when possible
                - When possible, mention exact keywords so the user can rerun the command with | grep <keyword> and drill down on the parts they care about
                - Strive for ≤ 50% of the original size; keep results compact and grep-friendly (one line per aggregate)

      - name: "kubectl_find_resource"
        description: "Run `kubectl get {{ kind }} -A --show-labels | grep {{ keyword }}` to find a resource where you know a substring of the name, IP, namespace, or labels"
        command: "kubectl get -A --show-labels -o wide {{ kind }} | grep {{ keyword }}"

      - name: "kubectl_get_yaml"
        description: "Run `kubectl get -o yaml` on a single Kubernetes resource"
        command: "kubectl get -o yaml {{ kind }} {{ name }}{% if namespace %} -n {{ namespace }}{% endif %}"

      - name: "kubectl_events"
        description: "Retrieve the events for a specific Kubernetes resource. `resource_type` can be any kubernetes resource type: 'pod', 'service', 'deployment', 'job', 'node', etc."
        command: "kubectl events --for {{resource_type}}/{{ resource_name }}{% if namespace %} -n {{ namespace }}{% endif %}"

      - name: "kubernetes_jq_query"
        user_description: "Query Kubernetes Resources: kubectl get {{kind}} --all-namespaces -o json | jq -r {{jq_expr}}"
        description: >
          Use kubectl to get json for all resources of a specific kind and filter with jq.
          IMPORTANT: The 'kind' parameter must be the plural form of the resource type
          (e.g., use "pods" not "pod", "services" not "service", "jobs" not "job").
          Do not worry about escaping the jq_expr - it will be done by the system.
          Example: .items[] | .spec.containers[].image | select(test("^gcr.io/") | not)
        script: |
          #!/bin/bash

          echo "Executing paginated query for {{ kind }} resources..."
          echo "Expression: {{ jq_expr }}"
          echo "---"

          # Get the API path for the resource kind using kubectl
          API_INFO=$(kubectl api-resources --no-headers | grep "^{{ kind }} " | head -1)

          if [ -z "$API_INFO" ]; then
            echo "Error: Unable to find resource kind '{{ kind }}'" >&2
            exit 1
          fi

          # Extract NAMESPACED value 
          if [[ "$API_INFO" == *" true "* ]]; then
            NAMESPACED="true"
            PREFIX=$(echo "$API_INFO" | sed 's/ true .*//')
          elif [[ "$API_INFO" == *" false "* ]]; then
            NAMESPACED="false"
            PREFIX=$(echo "$API_INFO" | sed 's/ false .*//')
          else
            echo "Error: Could not find NAMESPACED field (true/false) in API info" >&2
            exit 1
          fi

          # Trim trailing spaces from prefix and collapse internal spaces
          PREFIX=$(echo "$PREFIX" | sed 's/  *$//' | sed 's/  */ /g')

          IFS=' ' read -ra PREFIX_FIELDS <<< "$PREFIX"
          FIELD_COUNT=0
          for field in "${PREFIX_FIELDS[@]}"; do
            ((FIELD_COUNT++))
          done

          RESOURCE_NAME="${PREFIX_FIELDS[0]}"
          if [ $FIELD_COUNT -ge 2 ]; then
            API_VERSION="${PREFIX_FIELDS[$((FIELD_COUNT - 1))]}"
          else
            API_VERSION=""
          fi

          if [ -z "$API_VERSION" ] || [ -z "$RESOURCE_NAME" ]; then
            echo "Error: Unable to parse API info for resource kind '{{ kind }}'" >&2
            exit 1
          fi

          # Build API path
          if [[ "$API_VERSION" == "v1" ]]; then
            API_PATH="/api/v1/${RESOURCE_NAME}"
          else
            API_PATH="/apis/${API_VERSION}/${RESOURCE_NAME}"
          fi

          # Process resources in chunks using API pagination
          LIMIT=500  # Process 500 items at a time
          CONTINUE=""
          PROCESSED=0
          TOTAL_MATCHES=0

          while true; do
            # Build API query with limit and continue token
            if [ -z "$CONTINUE" ]; then
              # First request - get from all namespaces
              QUERY="${API_PATH}?limit=${LIMIT}"
            else
              # Subsequent requests with continue token
              QUERY="${API_PATH}?limit=${LIMIT}&continue=${CONTINUE}"
            fi

            OUTPUT=$(kubectl get --raw "$QUERY" 2>&1)
            exit_code=$?

            if [ $exit_code -ne 0 ]; then
              echo "Error: $OUTPUT" >&2
              exit $exit_code
            fi

            ITEMS_COUNT=$(echo "$OUTPUT" | jq '.items | length')

            MATCHES=$(echo "$OUTPUT" | jq -r {{ jq_expr }} 2>&1)
            jq_exit=$?
            if [ $jq_exit -ne 0 ]; then
              echo "Error: jq expression failed: $MATCHES" >&2
              exit $jq_exit
            fi

            if [ "$ITEMS_COUNT" -gt 0 ]; then
              if [ -n "$MATCHES" ]; then
                echo "$MATCHES"
                MATCH_COUNT=$(echo "$MATCHES" | grep -c . || true)
                TOTAL_MATCHES=$((TOTAL_MATCHES + MATCH_COUNT))
              fi

              PROCESSED=$((PROCESSED + ITEMS_COUNT))

              echo "Processed $PROCESSED items, found $TOTAL_MATCHES matches so far..." >&2
            fi

            CONTINUE=$(echo "$OUTPUT" | jq -r '.metadata.continue // empty')

            if [ -z "$CONTINUE" ]; then
              break
            fi
          done

          echo "---" >&2
          echo "Total items processed: $PROCESSED, matches found: $TOTAL_MATCHES" >&2
        transformers:
          - name: llm_summarize
            config:
              input_threshold: 10000
              prompt: |
                Summarize this jq query output focusing on:
                - Key patterns and commonalities in the data
                - Notable outliers, anomalies, or items that need attention
                - Group similar results into aggregate descriptions when possible
                - Highlight any empty results, null values, or missing data
                - When applicable, mention specific resource names, namespaces, or values that stand out
                - Organize findings in a structured way that helps with troubleshooting
                - Be concise: aim for ≤ 50% of the original text; prioritize aggregates and actionable outliers
                - Include grep-ready keys/values; avoid repeating entire objects or unchanged defaults

      - name: "kubernetes_tabular_query"
        user_description: "Tabular output of specific fields: kubectl get {{kind}} --all-namespaces -o custom-columns={{columns}}"
        description: >
          Extract specific fields from Kubernetes resources in tabular format with optional filtering.
          Memory-efficient way to query large clusters - only requested fields are transmitted.
          Column specification format: HEADER:FIELD_PATH,HEADER2:FIELD_PATH2,...

          Optional filtering parameter:
          - filter_pattern: Pattern to match in any column (supports grep regex)

          Examples:
          - Basic fields: NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName
          - Filter by status: filter_pattern="Running"
          - Filter out lines with <none>: filter_pattern="-v '<none>'"
          - Nested fields: CREATED:.metadata.creationTimestamp,IMAGE:.spec.containers[0].image
          - Array fields: LABELS:.metadata.labels,PORTS:.spec.ports[*].port

          Note: Output is tabular text with column headers. Filtering works on the entire line.
          Note: not allowed characters are: ' / ; and newline
        command: kubectl get {{ kind }} --all-namespaces -o custom-columns='{{ columns }}'{% if filter_pattern %} | (head -n 1; tail -n +2 | grep {{ filter_pattern }}){% endif %}
        transformers:
          - name: llm_summarize
            config:
              input_threshold: 10000
              prompt: |
                Summarize this tabular output focusing on:
                - Key patterns and trends in the data
                - Resources that need attention (errors, pending, failures)
                - Group similar items into aggregate descriptions
                - Highlight outliers or unusual values
                - Mention specific resource names only for problematic items
                - Provide counts and distributions where relevant
                - Be concise: aim for ≤ 50% of the original size
                - Keep output actionable and focused on anomalies

      - name: "kubernetes_count"
        user_description: "Count Kubernetes Resources: kubectl get {{kind}} --all-namespaces -o json | jq -c -r {{ jq_expr }}"
        description: >
          Use kubectl to get apply a jq filter and then count the results.
          Use this whenever asked to count kubernetes resources.
          IMPORTANT: The 'kind' parameter must be the plural form of the resource type
          (e.g., use "pods" not "pod", "services" not "service", "jobs" not "job").
          Use select() to filter objects before extracting properties, e.g. .items[] | select(.metadata.namespace == "test-1") | .metadata.name
          Do not worry about escaping the jq_expr it will be done by the system on an unescaped expression that you give.
          e.g. give an expression like .items[] | select(.spec.containers[].image | test("^gcr.io/") | not) | .metadata.name
        script: |
          #!/bin/bash

          echo "Command executed: kubectl get {{ kind }} --all-namespaces -o json | jq -c -r {{ jq_expr }}"
          echo "---"

          # Get the API path for the resource kind
          API_INFO=$(kubectl api-resources --no-headers | grep "^{{ kind }} " | head -1)

          if [ -z "$API_INFO" ]; then
            echo "Error: Unable to find resource kind '{{ kind }}'" >&2
            exit 1
          fi

          if [[ "$API_INFO" == *" true "* ]]; then
            NAMESPACED="true"
            PREFIX=$(echo "$API_INFO" | sed 's/ true .*//')
          elif [[ "$API_INFO" == *" false "* ]]; then
            NAMESPACED="false"
            PREFIX=$(echo "$API_INFO" | sed 's/ false .*//')
          else
            echo "Error: Could not find NAMESPACED field (true/false) in API info" >&2
            exit 1
          fi

          PREFIX=$(echo "$PREFIX" | sed 's/  *$//' | sed 's/  */ /g')

          IFS=' ' read -ra PREFIX_FIELDS <<< "$PREFIX"
          FIELD_COUNT=0
          for field in "${PREFIX_FIELDS[@]}"; do
            ((FIELD_COUNT++))
          done
          RESOURCE_NAME="${PREFIX_FIELDS[0]}"

          if [ $FIELD_COUNT -ge 2 ]; then
            API_VERSION="${PREFIX_FIELDS[$((FIELD_COUNT - 1))]}"
          else
            API_VERSION=""
          fi

          if [ -z "$API_VERSION" ] || [ -z "$RESOURCE_NAME" ]; then
            echo "Error: Unable to parse API info for resource kind '{{ kind }}'" >&2
            exit 1
          fi

          # Build API path
          if [[ "$API_VERSION" == "v1" ]]; then
            API_PATH="/api/v1/${RESOURCE_NAME}"
          else
            API_PATH="/apis/${API_VERSION}/${RESOURCE_NAME}"
          fi

          # Process resources in chunks using API pagination
          LIMIT=500
          CONTINUE=""
          ALL_MATCHES=""
          BATCH_NUM=0
          TOTAL_PROCESSED=0

          while true; do
            BATCH_NUM=$((BATCH_NUM + 1))

            if [ -z "$CONTINUE" ]; then
              QUERY="${API_PATH}?limit=${LIMIT}"
            else
              QUERY="${API_PATH}?limit=${LIMIT}&continue=${CONTINUE}"
            fi

            OUTPUT=$(kubectl get --raw "$QUERY" 2>&1)
            exit_code=$?

            if [ $exit_code -ne 0 ]; then
              echo "Error for query $QUERY: $OUTPUT" >&2
              exit $exit_code
            fi

            ITEMS_COUNT=$(echo "$OUTPUT" | jq '.items | length')
            TOTAL_PROCESSED=$((TOTAL_PROCESSED + ITEMS_COUNT))

            BATCH_MATCHES=$(echo "$OUTPUT" | jq -c -r {{ jq_expr }} 2>&1)
            jq_exit=$?
            if [ $jq_exit -ne 0 ]; then
              echo "Error: jq expression failed: $BATCH_MATCHES" >&2
              exit $jq_exit
            fi

            if [ -n "$BATCH_MATCHES" ]; then
              if [ -z "$ALL_MATCHES" ]; then
                ALL_MATCHES="$BATCH_MATCHES"
              else
                ALL_MATCHES="$ALL_MATCHES"$'\n'"$BATCH_MATCHES"
              fi
            fi

            CONTINUE=$(echo "$OUTPUT" | jq -r '.metadata.continue // empty')
            if [ -z "$CONTINUE" ]; then
              break
            fi

            echo "Processed batch $BATCH_NUM ($TOTAL_PROCESSED items so far)..." >&2
          done

          # Now process the collected matches
          filtered_matches=$(echo "$ALL_MATCHES" | grep -v '^$' | grep -v '^null$')
          if [ -z "$filtered_matches" ]; then
            count=0
            preview=""
          else
            count=$(echo "$filtered_matches" | wc -l)
            preview=$(echo "$filtered_matches" | head -n 10 | cut -c 1-200 | nl)
          fi

          echo "$count results"
          echo "---"
          echo "A *preview* of results is shown below (up to 10 results, up to 200 chars):"
          echo "$preview"
          echo "---"
          echo "Total items processed: $TOTAL_PROCESSED" >&2

    # NOTE: this is only possible for probes with a healthz endpoint - we do this to avoid giving the LLM generic
    # http GET capabilities which are more powerful than we want to expose
    #- name: "check_liveness_probe"
    #  description: "Run an http Kubernetes liveness probe for a given pod and return the results. Can be used to troubleshoot previous failures of the same probe assuming they fail now in the same manner."
    #  command: "kubectl get --raw '/api/v1/namespaces/{{pod_namespace}}/pods/{{pod_name}}:{{liveness_probe_port}}/healthz'"

    #- name: "kubectl_debug_node"
    #  description: "Run a command on a Kubernetes node"
    #  command: "kubectl debug node/mynode --image=ubuntu"

    #- name: "healthcheck_plugin"
    #  description: "Check why a kubernetes health probe is failing. First call get_healthcheck_details"
    #  command: "kubectl exec -n {{namespace}} {{ pod_name }} -- wget {{ url }}:{{port}}"

    # try adding your own tools here!
    # e.g. to query company-specific data or run your own commands

  kubernetes/live-metrics:
    description: "Provides real-time metrics for pods and nodes"
    docs_url: "https://holmesgpt.dev/data-sources/builtin-toolsets/kubernetes/"
    icon_url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRPKA-U9m5BxYQDF1O7atMfj9EMMXEoGu4t0Q&s"
    llm_instructions: |
      The kubectl_top_pods or kubectl_top_nodes do not return time series data or metrics that can be used for graphs
      Do NOT use kubectl_top_pods or kubectl_top_nodes for graph generation - it only shows current snapshot data
      kubectl_top_pods or kubectl_top_nodes are for current status checks, not historical graphs
    tags:
      - core
    prerequisites:
      - command: "kubectl top nodes"
    tools:
      - name: "kubectl_top_pods"
        description: "Retrieves real-time CPU and memory usage for each pod in the cluster."
        command: >
          kubectl top pods -A
      - name: "kubectl_top_nodes"
        description: "Retrieves real-time CPU and memory usage for each node in the cluster."
        command: >
          kubectl top nodes

  kubernetes/kube-prometheus-stack:
    description: "Fetches prometheus definition"
    docs_url: "https://holmesgpt.dev/data-sources/builtin-toolsets/kubernetes/"
    icon_url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRPKA-U9m5BxYQDF1O7atMfj9EMMXEoGu4t0Q&s"
    tags:
      - core
    tools:
      - name: "get_prometheus_target"
        description: "Fetch the definition of a Prometheus target"
        command: 'kubectl get --raw ''/api/v1/namespaces/{{prometheus_namespace}}/services/{{prometheus_service_name}}:9090/proxy/api/v1/targets'' | jq ''.data.activeTargets[] | select(.labels.job == "{{ target_name }}")'''

  kubernetes/krew-extras: # To make this work, install kube-lineage with krew
    description: "Fetches children/dependents and parents/dependencies resources using kube-lineage installed via `kubectl krew`"
    docs_url: "https://holmesgpt.dev/data-sources/builtin-toolsets/kubernetes/"
    icon_url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRPKA-U9m5BxYQDF1O7atMfj9EMMXEoGu4t0Q&s"
    tags:
      - cli
    prerequisites:
      - command: "kubectl version --client && kubectl lineage --version"
    tools:
      - name: "kubectl_lineage_children"
        description: "Get all children/dependents of a Kubernetes resource, recursively, including their status"
        command: "kubectl lineage {{ kind }} {{ name }}{% if namespace %} -n {{ namespace }}{% endif %}"
      - name: "kubectl_lineage_parents"
        description: "Get all parents/dependencies of a Kubernetes resource, recursively, including their status"
        command: "kubectl lineage {{ kind }} {{ name }}{% if namespace %} -n {{ namespace }}{% endif %} -D"

  kubernetes/kube-lineage-extras: # To make this work, build kube-lineage from source
    description: "Fetches children/dependents and parents/dependencies resources using kube-lineage"
    docs_url: "https://holmesgpt.dev/data-sources/builtin-toolsets/kubernetes/"
    icon_url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRPKA-U9m5BxYQDF1O7atMfj9EMMXEoGu4t0Q&s"
    tags:
      - cluster
    prerequisites:
      - command: "kubectl version --client && kube-lineage --version"
    tools:
      - name: "kubectl_lineage_children"
        description: "Get all children/dependents of a Kubernetes resource, recursively, including their status"
        command: "kube-lineage {{ kind }} {{ name }}{% if namespace %} -n {{ namespace }}{% endif %}"
      - name: "kubectl_lineage_parents"
        description: "Get all parents/dependencies of a Kubernetes resource, recursively, including their status"
        command: "kube-lineage {{ kind }} {{ name }}{% if namespace %} -n {{ namespace }}{% endif %} -D"
