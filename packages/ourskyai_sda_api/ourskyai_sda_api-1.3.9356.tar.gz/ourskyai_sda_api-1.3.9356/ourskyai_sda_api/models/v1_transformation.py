# coding: utf-8

"""
    OurSky SDA

    The basic flow for a new organization is as follows: 1. View the available satellite targets with the [satellite targets](#tag/satellite-targets/GET/v1/satellite-targets) endpoint. Copy the id of the target you want to observe. 2. Create an organization target with the [organization target](#tag/organization-targets/GET/v1/organization-targets) endpoint. Use the id copied from above. 3. Create a webhook with the [webhook](#tag/webhooks/POST/v1/communications/webhook) endpoint to receive OSRs automatically (preferred) or use the [OSRs](#tag/observation-sequence-results/GET/v1/observation-sequence-results) endpoint to poll for OSRs.  Check out our [examples](https://github.com/ourskyai/oursky-examples) repository to see usage in each language.

    The version of the OpenAPI document: 1.3.9356
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional, Union
from pydantic import BaseModel, Field, StrictFloat, StrictInt, conlist

class V1Transformation(BaseModel):
    """
    Plate to catplate transform with 3rd-order distortion  # noqa: E501
    """
    a: Union[StrictFloat, StrictInt] = Field(..., description="Affine transformation coefficient")
    b: Union[StrictFloat, StrictInt] = Field(..., description="Affine transformation coefficient")
    c: Union[StrictFloat, StrictInt] = Field(..., description="Affine transformation coefficient")
    d: Union[StrictFloat, StrictInt] = Field(..., description="Affine transformation coefficient")
    u0: Union[StrictFloat, StrictInt] = Field(..., description="Horizontal offset for the affine transformation")
    v0: Union[StrictFloat, StrictInt] = Field(..., description="Vertical offset for the affine transformation")
    alpha: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Scale")
    beta: Union[StrictFloat, StrictInt] = Field(..., description="Stretch")
    theta: Union[StrictFloat, StrictInt] = Field(..., description="Rotation")
    gamma: Union[StrictFloat, StrictInt] = Field(..., description="Skew")
    eps_x: Union[StrictFloat, StrictInt] = Field(..., alias="epsX", description="3rd-order plate distortion, X-direction")
    eps_y: Union[StrictFloat, StrictInt] = Field(..., alias="epsY", description="3rd-order plate distortion, Y-direction")
    ra_cen: Union[StrictFloat, StrictInt] = Field(..., alias="raCen", description="The reference RA and Dec, in radians, at U = 0, V = 0")
    dec_cen: Union[StrictFloat, StrictInt] = Field(..., alias="decCen", description="The reference RA and Dec, in radians, at U = 0, V = 0")
    px: Union[StrictFloat, StrictInt] = Field(..., description="The number of plate pixels in the X and Y directions. The following coordinate transforms use normalized plate coordinates X/Norm, Y/Norm, where Norm is sqrt(Px^2 + Py^2)/2")
    py: Union[StrictFloat, StrictInt] = Field(..., description="The number of plate pixels in the X and Y directions. The following coordinate transforms use normalized plate coordinates X/Norm, Y/Norm, where Norm is sqrt(Px^2 + Py^2)/2")
    u_coef: conlist(Union[StrictFloat, StrictInt]) = Field(..., alias="uCoef", description="The U-coefficients of the full N-th order match, if available. UCoef(0..NumCoef)")
    v_coef: conlist(Union[StrictFloat, StrictInt]) = Field(..., alias="vCoef", description="The V-coefficients of the full N-th order match, if available. VCoef(0..NumCoef)")
    x_coef: conlist(Union[StrictFloat, StrictInt]) = Field(..., alias="xCoef", description="The X-coefficients of the full N-th order match, if available. XCoef(0..NumCoef)")
    y_coef: conlist(Union[StrictFloat, StrictInt]) = Field(..., alias="yCoef", description="The Y-coefficients of the full N-th order match, if available. YCoef(0..NumCoef)")
    num_coef: StrictInt = Field(..., alias="numCoef", description="The number of coefficients + 1. 0 if there is no high-order match")
    fit_error_radians: Union[StrictFloat, StrictInt] = Field(..., alias="fitErrorRadians", description="The RMS fit error, in radians, for the simple affine + third-order distortion transform")
    fit_error_pix: Union[StrictFloat, StrictInt] = Field(..., alias="fitErrorPix", description="The RMS fit error, in pixels, for the simple affine + third-order distortion transform")
    fit_error3_radians: Union[StrictFloat, StrictInt] = Field(..., alias="fitError3Radians", description="The RMS fit error, in radians, for the full third-order transform")
    fit_error3_pix: Union[StrictFloat, StrictInt] = Field(..., alias="fitError3Pix", description="The RMS fit error, in pixels, for the full third-order transform")
    stretch: Union[StrictFloat, StrictInt] = Field(..., description="The difference in scale values between the X and Y axes, used to test the match geometry")
    skew: Union[StrictFloat, StrictInt] = Field(..., description="The image skew, used to test the match geometry")
    scale: Union[StrictFloat, StrictInt] = Field(..., description="The matched image scale, in pixels per radian")
    rotation: Union[StrictFloat, StrictInt] = Field(..., description="The image rotation, in degrees, agrees with PinPoint")
    __properties = ["a", "b", "c", "d", "u0", "v0", "alpha", "beta", "theta", "gamma", "epsX", "epsY", "raCen", "decCen", "px", "py", "uCoef", "vCoef", "xCoef", "yCoef", "numCoef", "fitErrorRadians", "fitErrorPix", "fitError3Radians", "fitError3Pix", "stretch", "skew", "scale", "rotation"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> V1Transformation:
        """Create an instance of V1Transformation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> V1Transformation:
        """Create an instance of V1Transformation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return V1Transformation.parse_obj(obj)

        _obj = V1Transformation.parse_obj({
            "a": obj.get("a"),
            "b": obj.get("b"),
            "c": obj.get("c"),
            "d": obj.get("d"),
            "u0": obj.get("u0"),
            "v0": obj.get("v0"),
            "alpha": obj.get("alpha"),
            "beta": obj.get("beta"),
            "theta": obj.get("theta"),
            "gamma": obj.get("gamma"),
            "eps_x": obj.get("epsX"),
            "eps_y": obj.get("epsY"),
            "ra_cen": obj.get("raCen"),
            "dec_cen": obj.get("decCen"),
            "px": obj.get("px"),
            "py": obj.get("py"),
            "u_coef": obj.get("uCoef"),
            "v_coef": obj.get("vCoef"),
            "x_coef": obj.get("xCoef"),
            "y_coef": obj.get("yCoef"),
            "num_coef": obj.get("numCoef"),
            "fit_error_radians": obj.get("fitErrorRadians"),
            "fit_error_pix": obj.get("fitErrorPix"),
            "fit_error3_radians": obj.get("fitError3Radians"),
            "fit_error3_pix": obj.get("fitError3Pix"),
            "stretch": obj.get("stretch"),
            "skew": obj.get("skew"),
            "scale": obj.get("scale"),
            "rotation": obj.get("rotation")
        })
        return _obj


