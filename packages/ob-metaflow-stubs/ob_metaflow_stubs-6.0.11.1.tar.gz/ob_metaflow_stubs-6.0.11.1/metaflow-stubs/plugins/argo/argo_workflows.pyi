######################################################################################################
#                                 Auto-generated Metaflow stub file                                  #
# MF version: 2.19.15.3+obcheckpoint(0.2.10);ob(v1)                                                  #
# Generated on 2026-01-13T14:42:17.053501                                                            #
######################################################################################################

from __future__ import annotations

import typing
import metaflow
if typing.TYPE_CHECKING:
    import metaflow.graph
    import metaflow.exception

from ...parameters import JSONType as JSONType
from ...metaflow_current import current as current
from ...exception import MetaflowException as MetaflowException
from ...includefile import FilePathClass as FilePathClass
from ...mf_extensions.outerbounds.remote_config import init_config as init_config
from ...parameters import deploy_time_eval as deploy_time_eval
from ..kubernetes.kube_utils import qos_requests_and_limits as qos_requests_and_limits
from ..kubernetes.kubernetes_jobsets import KubernetesArgoJobSet as KubernetesArgoJobSet
from ...user_configs.config_options import ConfigInput as ConfigInput
from .argo_client import ArgoClient as ArgoClient
from .exit_hooks import ExitHookHack as ExitHookHack
from .exit_hooks import HttpExitHook as HttpExitHook
from .exit_hooks import ContainerHook as ContainerHook

inf: float

ARGO_EVENTS_EVENT: None

ARGO_EVENTS_EVENT_BUS: str

ARGO_EVENTS_EVENT_SOURCE: None

ARGO_EVENTS_INTERNAL_WEBHOOK_URL: None

ARGO_EVENTS_SENSOR_NAMESPACE: str

ARGO_EVENTS_SERVICE_ACCOUNT: None

ARGO_EVENTS_WEBHOOK_AUTH: str

ARGO_WORKFLOWS_CAPTURE_ERROR_SCRIPT: None

ARGO_WORKFLOWS_ENV_VARS_TO_SKIP: str

ARGO_WORKFLOWS_KUBERNETES_SECRETS: str

ARGO_WORKFLOWS_UI_URL: None

AWS_SECRETS_MANAGER_DEFAULT_REGION: None

AZURE_KEY_VAULT_PREFIX: None

AZURE_STORAGE_BLOB_SERVICE_ENDPOINT: None

CARD_AZUREROOT: None

CARD_GSROOT: None

CARD_S3ROOT: None

DATASTORE_SYSROOT_AZURE: None

DATASTORE_SYSROOT_GS: None

DATASTORE_SYSROOT_S3: None

DATATOOLS_S3ROOT: None

DEFAULT_METADATA: str

DEFAULT_SECRETS_BACKEND_TYPE: None

GCP_SECRET_MANAGER_PREFIX: None

KUBERNETES_FETCH_EC2_METADATA: bool

KUBERNETES_NAMESPACE: str

KUBERNETES_SANDBOX_INIT_SCRIPT: None

KUBERNETES_SECRETS: str

S3_ENDPOINT_URL: None

S3_SERVER_SIDE_ENCRYPTION: None

SERVICE_HEADERS: dict

SERVICE_INTERNAL_URL: None

UI_URL: None

PAGERDUTY_TEMPLATE_URL: None

BASH_SAVE_LOGS: str

UBF_CONTROL: str

UBF_TASK: str

class ArgoWorkflowsException(metaflow.exception.MetaflowException, metaclass=type):
    ...

class ArgoWorkflowsSensorCleanupException(metaflow.exception.MetaflowException, metaclass=type):
    ...

class ArgoWorkflowsSchedulingException(metaflow.exception.MetaflowException, metaclass=type):
    ...

class ArgoWorkflows(object, metaclass=type):
    def __init__(self, name, graph: metaflow.graph.FlowGraph, flow, code_package_metadata, code_package_sha, code_package_url, production_token, metadata, flow_datastore, environment, event_logger, monitor, tags = None, namespace = None, username = None, max_workers = None, workflow_timeout = None, workflow_priority = None, auto_emit_argo_events = False, notify_on_error = False, notify_on_success = False, notify_slack_webhook_url = None, notify_pager_duty_integration_key = None, notify_incident_io_api_key = None, incident_io_alert_source_config_id = None, incident_io_metadata: typing.List[str] = None, enable_heartbeat_daemon = True, enable_error_msg_capture = False, workflow_title = None, workflow_description = None):
        ...
    def __str__(self):
        ...
    def deploy(self):
        ...
    def cleanup_previous_sensors(self):
        ...
    @staticmethod
    def list_templates(flow_name, all = False, page_size = 100):
        ...
    @staticmethod
    def delete(name):
        ...
    @classmethod
    def terminate(cls, flow_name, name):
        ...
    @staticmethod
    def get_workflow_status(flow_name, name):
        ...
    @staticmethod
    def suspend(name):
        ...
    @staticmethod
    def unsuspend(name):
        ...
    @staticmethod
    def parse_incident_io_metadata(metadata: typing.List[str] = None):
        """
        parse key value pairs into a dict for incident.io metadata if given
        """
        ...
    @classmethod
    def trigger(cls, name, parameters = None):
        ...
    def schedule(self):
        ...
    def trigger_explanation(self):
        ...
    @classmethod
    def get_existing_deployment(cls, name):
        ...
    @classmethod
    def get_execution(cls, name):
        ...
    def list_to_prose(self, items, singular):
        ...
    ...

class WorkflowTemplate(object, metaclass=type):
    def __init__(self):
        ...
    def metadata(self, object_meta):
        ...
    def spec(self, workflow_spec):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class ObjectMeta(object, metaclass=type):
    def __init__(self):
        ...
    def annotation(self, key, value):
        ...
    def annotations(self, annotations):
        ...
    def generate_name(self, generate_name):
        ...
    def label(self, key, value):
        ...
    def labels(self, labels):
        ...
    def name(self, name):
        ...
    def namespace(self, namespace):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class WorkflowStep(object, metaclass=type):
    def __init__(self):
        ...
    def name(self, name):
        ...
    def template(self, template):
        ...
    def arguments(self, arguments):
        ...
    def when(self, condition):
        ...
    def step(self, expression):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class WorkflowSpec(object, metaclass=type):
    def __init__(self):
        ...
    def active_deadline_seconds(self, active_deadline_seconds):
        ...
    def automount_service_account_token(self, mount = True):
        ...
    def arguments(self, arguments):
        ...
    def archive_logs(self, archive_logs = True):
        ...
    def entrypoint(self, entrypoint):
        ...
    def onExit(self, on_exit_template):
        ...
    def parallelism(self, parallelism):
        ...
    def pod_metadata(self, metadata):
        ...
    def priority(self, priority):
        ...
    def workflow_metadata(self, workflow_metadata):
        ...
    def service_account_name(self, service_account_name):
        ...
    def templates(self, templates):
        ...
    def hooks(self, hooks):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class Metadata(object, metaclass=type):
    def __init__(self):
        ...
    def annotation(self, key, value):
        ...
    def annotations(self, annotations):
        ...
    def label(self, key, value):
        ...
    def labels(self, labels):
        ...
    def labels_from(self, labels_from):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class DaemonTemplate(object, metaclass=type):
    def __init__(self, name):
        ...
    def container(self, container):
        ...
    def service_account_name(self, service_account_name):
        ...
    def retry_strategy(self, times, minutes_between_retries):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class Template(object, metaclass=type):
    def __init__(self, name):
        ...
    def active_deadline_seconds(self, active_deadline_seconds):
        ...
    def dag(self, dag_template):
        ...
    def steps(self, steps):
        ...
    def container(self, container):
        ...
    def http(self, http):
        ...
    def inputs(self, inputs):
        ...
    def outputs(self, outputs):
        ...
    def fail_fast(self, fail_fast = True):
        ...
    def metadata(self, metadata):
        ...
    def service_account_name(self, service_account_name):
        ...
    def retry_strategy(self, times, minutes_between_retries):
        ...
    def empty_dir_volume(self, name, medium = None, size_limit = None):
        """
        Create and attach an emptyDir volume for Kubernetes.
        
        Parameters:
        -----------
        name: str
            name for the volume
        size_limit: int (optional)
            sizeLimit (in MiB) for the volume
        medium: str (optional)
            storage medium of the emptyDir
        """
        ...
    def pvc_volumes(self, pvcs = None):
        """
        Create and attach Persistent Volume Claims as volumes.
        
        Parameters:
        -----------
        pvcs: Optional[Dict]
            a dictionary of pvc's and the paths they should be mounted to. e.g.
            {"pv-claim-1": "/mnt/path1", "pv-claim-2": "/mnt/path2"}
        """
        ...
    def pod_spec_patch(self, pod_spec_patch = None):
        ...
    def node_selectors(self, node_selectors):
        ...
    def tolerations(self, tolerations):
        ...
    def to_json(self):
        ...
    def resource(self, action, manifest, success_criteria, failure_criteria):
        ...
    def __str__(self):
        ...
    ...

class Inputs(object, metaclass=type):
    def __init__(self):
        ...
    def parameters(self, parameters):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class Outputs(object, metaclass=type):
    def __init__(self):
        ...
    def parameters(self, parameters):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class Parameter(object, metaclass=type):
    def __init__(self, name):
        ...
    def value(self, value):
        ...
    def default(self, value):
        ...
    def valueFrom(self, value_from):
        ...
    def description(self, description):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class DAGTemplate(object, metaclass=type):
    def __init__(self):
        ...
    def fail_fast(self, fail_fast = True):
        ...
    def tasks(self, tasks):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class DAGTask(object, metaclass=type):
    def __init__(self, name):
        ...
    def arguments(self, arguments):
        ...
    def dependencies(self, dependencies):
        ...
    def depends(self, depends: str):
        ...
    def template(self, template):
        ...
    def inline(self, template):
        ...
    def when(self, when: str):
        ...
    def with_param(self, with_param):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class Arguments(object, metaclass=type):
    def __init__(self):
        ...
    def parameters(self, parameters):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class Sensor(object, metaclass=type):
    def __init__(self):
        ...
    def metadata(self, object_meta):
        ...
    def spec(self, sensor_spec):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class SensorSpec(object, metaclass=type):
    def __init__(self):
        ...
    def replicas(self, replicas = 1):
        ...
    def template(self, sensor_template):
        ...
    def trigger(self, trigger):
        ...
    def dependencies(self, dependencies):
        ...
    def event_bus_name(self, event_bus_name):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class SensorTemplate(object, metaclass=type):
    def __init__(self):
        ...
    def service_account_name(self, service_account_name):
        ...
    def metadata(self, object_meta):
        ...
    def container(self, container):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class EventDependency(object, metaclass=type):
    def __init__(self, name):
        ...
    def event_source_name(self, event_source_name):
        ...
    def event_name(self, event_name):
        ...
    def filters(self, event_dependency_filter):
        ...
    def transform(self, event_dependency_transformer = None):
        ...
    def filters_logical_operator(self, logical_operator):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class EventDependencyFilter(object, metaclass=type):
    def __init__(self):
        ...
    def exprs(self, exprs):
        ...
    def context(self, event_context):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class Trigger(object, metaclass=type):
    def __init__(self):
        ...
    def template(self, trigger_template):
        ...
    def parameters(self, trigger_parameters):
        ...
    def policy(self, trigger_policy):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class TriggerTemplate(object, metaclass=type):
    def __init__(self, name):
        ...
    def k8s_trigger(self, k8s_trigger):
        ...
    def argo_workflow_trigger(self, argo_workflow_trigger):
        ...
    def conditions_reset(self, cron, timezone):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class ArgoWorkflowTrigger(object, metaclass=type):
    def __init__(self):
        ...
    def source(self, source):
        ...
    def parameters(self, trigger_parameters):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class TriggerParameter(object, metaclass=type):
    def __init__(self):
        ...
    def src(self, dependency_name, value, data_key = None, data_template = None):
        ...
    def dest(self, dest):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

class StandardK8STrigger(object, metaclass=type):
    def __init__(self):
        ...
    def operation(self, operation):
        ...
    def group(self, group):
        ...
    def version(self, version):
        ...
    def resource(self, resource):
        ...
    def namespace(self, namespace):
        ...
    def source(self, source):
        ...
    def parameters(self, trigger_parameters):
        ...
    def live_object(self, live_object = True):
        ...
    def patch_strategy(self, patch_strategy):
        ...
    def to_json(self):
        ...
    def __str__(self):
        ...
    ...

