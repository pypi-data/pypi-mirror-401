######################################################################################################
#                                 Auto-generated Metaflow stub file                                  #
# MF version: 2.19.15.3+obcheckpoint(0.2.10);ob(v1)                                                  #
# Generated on 2026-01-13T14:42:17.066391                                                            #
######################################################################################################

from __future__ import annotations

import metaflow
import typing
if typing.TYPE_CHECKING:
    import metaflow.exception

from ....exception import MetaflowException as MetaflowException
from ....parameters import deploy_time_eval as deploy_time_eval
from ....user_configs.config_options import ConfigInput as ConfigInput
from ..batch.batch import Batch as Batch
from .event_bridge_client import EventBridgeClient as EventBridgeClient
from .step_functions_client import StepFunctionsClient as StepFunctionsClient

EVENTS_SFN_ACCESS_IAM_ROLE: None

S3_ENDPOINT_URL: None

SFN_DYNAMO_DB_TABLE: None

SFN_EXECUTION_LOG_GROUP_ARN: None

SFN_IAM_ROLE: None

SFN_S3_DISTRIBUTED_MAP_OUTPUT_PATH: None

class StepFunctionsException(metaflow.exception.MetaflowException, metaclass=type):
    ...

class StepFunctionsSchedulingException(metaflow.exception.MetaflowException, metaclass=type):
    ...

class StepFunctions(object, metaclass=type):
    def __init__(self, name, graph, flow, code_package_metadata, code_package_sha, code_package_url, production_token, metadata, flow_datastore, environment, event_logger, monitor, tags = None, aws_batch_tags = None, namespace = None, username = None, max_workers = None, workflow_timeout = None, is_project = False, use_distributed_map = False, compress_state_machine = False):
        ...
    def to_json(self):
        ...
    def trigger_explanation(self):
        ...
    def deploy(self, log_execution_history):
        ...
    def schedule(self):
        ...
    @classmethod
    def delete(cls, name):
        ...
    @classmethod
    def terminate(cls, flow_name, name):
        ...
    @classmethod
    def trigger(cls, name, parameters):
        ...
    @classmethod
    def list(cls, name, states):
        ...
    @classmethod
    def get_existing_deployment(cls, name):
        ...
    @classmethod
    def get_execution(cls, state_machine_name, name):
        ...
    ...

class Workflow(object, metaclass=type):
    def __init__(self, name):
        ...
    def mode(self, mode):
        ...
    def start_at(self, start_at):
        ...
    def add_state(self, state):
        ...
    def timeout_seconds(self, timeout_seconds):
        ...
    def to_json(self, pretty = False):
        ...
    ...

class State(object, metaclass=type):
    def __init__(self, name):
        ...
    def resource(self, resource):
        ...
    def next(self, state):
        ...
    def end(self):
        ...
    def parameter(self, name, value):
        ...
    def output_path(self, output_path):
        ...
    def result_path(self, result_path):
        ...
    def result_selector(self, name, value):
        ...
    def retry_strategy(self, retry_strategy):
        ...
    def batch(self, job):
        ...
    def dynamo_db(self, table_name, primary_key, values):
        ...
    ...

class Pass(object, metaclass=type):
    def __init__(self, name):
        ...
    def end(self):
        ...
    def parameter(self, name, value):
        ...
    def output_path(self, output_path):
        ...
    ...

class Parallel(object, metaclass=type):
    def __init__(self, name):
        ...
    def branch(self, workflow):
        ...
    def next(self, state):
        ...
    def output_path(self, output_path):
        ...
    def result_path(self, result_path):
        ...
    ...

class Map(object, metaclass=type):
    def __init__(self, name):
        ...
    def iterator(self, workflow):
        ...
    def next(self, state):
        ...
    def items_path(self, items_path):
        ...
    def parameter(self, name, value):
        ...
    def max_concurrency(self, max_concurrency):
        ...
    def output_path(self, output_path):
        ...
    def result_path(self, result_path):
        ...
    def item_reader(self, item_reader):
        ...
    def result_writer(self, bucket, prefix):
        ...
    ...

class JSONItemReader(object, metaclass=type):
    def __init__(self):
        ...
    def resource(self, resource):
        ...
    def parameter(self, name, value):
        ...
    def output_path(self, output_path):
        ...
    ...

