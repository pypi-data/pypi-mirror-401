"""Command-line interface for Cadence.

Provides scaffolding and utility commands:
- cadence init: Initialize a new project
- cadence new cadence <name>: Generate a new cadence
- cadence new beat <name>: Generate a new beat
- cadence diagram <module>: Generate cadence diagrams
- cadence validate <module>: Validate cadence definitions

Usage:
    python -m cadence init
    python -m cadence new cadence checkout
    python -m cadence diagram myapp.cadences:checkout_cadence --format mermaid
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from textwrap import dedent


def init_command(args: argparse.Namespace) -> int:
    """Initialize a new Cadence project."""
    project_dir = Path(args.directory or ".")
    project_name = args.name or project_dir.name

    print(f"Initializing Cadence project: {project_name}")

    # Create directory structure
    dirs = [
        project_dir / "cadences",
        project_dir / "beats",
        project_dir / "tests",
    ]

    for d in dirs:
        d.mkdir(parents=True, exist_ok=True)
        init_file = d / "__init__.py"
        if not init_file.exists():
            init_file.write_text('"""Auto-generated by cadence init."""\n')

    # Create sample cadence
    cadences_init = project_dir / "cadences" / "__init__.py"
    if not cadences_init.exists() or cadences_init.read_text().strip() == '"""Auto-generated by cadence init."""':
        cadences_init.write_text(dedent(f'''
            """
            {project_name} Cadences

            Define your cadences here.
            """

            from cadence import Cadence, Context, beat
            from dataclasses import dataclass
            from typing import Optional


            @dataclass
            class SampleContext(Context):
                """Sample context for demonstration."""
                input_value: str = ""
                result: Optional[str] = None


            @beat
            async def process_input(ctx: SampleContext) -> None:
                """Process the input value."""
                ctx.result = f"Processed: {{ctx.input_value}}"


            # Define a sample cadence
            sample_cadence = (
                Cadence("sample", SampleContext())
                .then("process", process_input)
            )


            __all__ = ["sample_cadence", "SampleContext"]
        ''').strip() + "\n")

    # Create sample test
    test_file = project_dir / "tests" / "test_cadences.py"
    if not test_file.exists():
        test_file.write_text(dedent(f'''
            """Tests for {project_name} cadences."""

            import pytest
            from cadences import sample_cadence, SampleContext


            class TestSampleCadence:
                """Test the sample cadence."""

                @pytest.mark.asyncio
                async def test_sample_cadence(self):
                    """Test basic cadence execution."""
                    ctx = SampleContext(input_value="hello")
                    ctx.__post_init__()

                    result = await sample_cadence.run()

                    assert result.result == "Processed: hello"
        ''').strip() + "\n")

    # Create pyproject.toml if it doesn't exist
    pyproject = project_dir / "pyproject.toml"
    if not pyproject.exists():
        pyproject.write_text(dedent(f'''
            [project]
            name = "{project_name}"
            version = "0.1.0"
            dependencies = [
                "cadence-flow",
            ]

            [project.optional-dependencies]
            dev = [
                "pytest>=8.0",
                "pytest-asyncio>=0.23",
            ]

            [tool.pytest.ini_options]
            testpaths = ["tests"]
            asyncio_mode = "auto"
        ''').strip() + "\n")

    print("  Created: cadences/")
    print("  Created: beats/")
    print("  Created: tests/")
    print("  Created: cadences/__init__.py (sample cadence)")
    print("  Created: tests/test_cadences.py")
    if not (project_dir / "pyproject.toml").exists():
        print("  Created: pyproject.toml")

    print("\nProject initialized! Next steps:")
    print(f"  1. cd {project_dir}")
    print("  2. pip install -e .[dev]")
    print("  3. pytest")
    print("  4. Edit cadences/__init__.py to add your cadences")

    return 0


def new_cadence_command(args: argparse.Namespace) -> int:
    """Generate a new cadence file."""
    cadence_name = args.name
    output_dir = Path(args.output or "cadences")
    output_dir.mkdir(parents=True, exist_ok=True)

    # Convert to valid Python identifier
    module_name = cadence_name.lower().replace("-", "_").replace(" ", "_")
    class_name = "".join(word.title() for word in cadence_name.replace("-", " ").replace("_", " ").split())

    output_file = output_dir / f"{module_name}.py"

    if output_file.exists() and not args.force:
        print(f"Error: {output_file} already exists. Use --force to overwrite.")
        return 1

    content = dedent(f'''
        """
        {class_name} Cadence

        TODO: Add description of what this cadence does.
        """

        from cadence import Cadence, Context, beat
        from dataclasses import dataclass
        from typing import Optional, List


        @dataclass
        class {class_name}Context(Context):
            """Context for {cadence_name} cadence."""
            # TODO: Add your context fields
            id: str = ""
            result: Optional[str] = None
            errors: Optional[List[str]] = None


        # --- Beats ---

        @beat
        async def validate(ctx: {class_name}Context) -> None:
            """Validate the input."""
            if not ctx.id:
                if ctx.errors is None:
                    ctx.errors = []
                ctx.errors.append("id is required")


        @beat
        async def process(ctx: {class_name}Context) -> None:
            """Process the request."""
            # TODO: Implement processing logic
            ctx.result = f"Processed {{ctx.id}}"


        @beat
        async def finalize(ctx: {class_name}Context) -> None:
            """Finalize the operation."""
            # TODO: Cleanup, notifications, etc.
            pass


        # --- Cadence Definition ---

        {module_name}_cadence = (
            Cadence("{module_name}", {class_name}Context())
            .then("validate", validate)
            .then("process", process)
            .then("finalize", finalize)
        )


        __all__ = ["{module_name}_cadence", "{class_name}Context"]
    ''').strip() + "\n"

    output_file.write_text(content)
    print(f"Created: {output_file}")
    print(f"\nCadence class: {class_name}Context")
    print(f"Cadence variable: {module_name}_cadence")

    return 0


def new_beat_command(args: argparse.Namespace) -> int:
    """Generate a new beat file."""
    beat_name = args.name
    output_dir = Path(args.output or "beats")
    output_dir.mkdir(parents=True, exist_ok=True)

    module_name = beat_name.lower().replace("-", "_").replace(" ", "_")
    func_name = module_name

    output_file = output_dir / f"{module_name}.py"

    if output_file.exists() and not args.force:
        print(f"Error: {output_file} already exists. Use --force to overwrite.")
        return 1

    # Check for resilience options
    decorators = ["@beat"]
    if args.retry:
        decorators.insert(0, f"@retry(max_attempts={args.retry})")
    if args.timeout:
        decorators.insert(0, f"@timeout(seconds={args.timeout})")
    if args.fallback:
        decorators.insert(0, f'@fallback(default={args.fallback})')

    imports = ["from cadence import beat"]
    if args.retry:
        imports.append("from cadence import retry")
    if args.timeout:
        imports.append("from cadence import timeout")
    if args.fallback:
        imports.append("from cadence import fallback")

    decorator_str = "\n".join(decorators)
    import_str = "\n".join(imports)

    content = dedent(f'''
        """
        {beat_name} Beat

        TODO: Add description of what this beat does.
        """

        {import_str}
        from typing import Any


        {decorator_str}
        async def {func_name}(ctx: Any) -> None:
            """
            {beat_name}

            Args:
                ctx: The cadence context

            TODO: Implement this beat
            """
            pass


        __all__ = ["{func_name}"]
    ''').strip() + "\n"

    output_file.write_text(content)
    print(f"Created: {output_file}")
    print(f"Function: {func_name}")

    return 0


def diagram_command(args: argparse.Namespace) -> int:
    """Generate a diagram from a cadence."""
    from cadence.diagram import print_cadence, save_diagram, to_dot, to_mermaid

    # Parse module:attribute
    if ":" in args.cadence:
        module_path, attr_name = args.cadence.rsplit(":", 1)
    else:
        print("Error: Cadence must be specified as module:attribute (e.g., myapp.cadences:checkout_cadence)")
        return 1

    # Import the cadence
    try:
        import importlib
        module = importlib.import_module(module_path)
        cadence = getattr(module, attr_name)
    except ImportError as e:
        print(f"Error importing module: {e}")
        return 1
    except AttributeError:
        print(f"Error: {attr_name} not found in {module_path}")
        return 1

    # Generate output
    if args.output:
        save_diagram(cadence, args.output, format=args.format)
        print(f"Diagram saved to: {args.output}")
    elif args.format == "text":
        print_cadence(cadence)
    elif args.format == "mermaid":
        print(to_mermaid(cadence))
    else:
        print(to_dot(cadence))

    return 0


def validate_command(args: argparse.Namespace) -> int:
    """Validate cadence definitions."""
    # Parse module:attribute or just module
    if ":" in args.module:
        module_path, attr_name = args.module.rsplit(":", 1)
        attrs_to_check = [attr_name]
    else:
        module_path = args.module
        attrs_to_check = None

    try:
        import importlib
        module = importlib.import_module(module_path)
    except ImportError as e:
        print(f"Error importing module: {e}")
        return 1

    from cadence.cadence import Cadence

    # Find all cadences in module
    if attrs_to_check is None:
        attrs_to_check = [
            name for name in dir(module)
            if isinstance(getattr(module, name), Cadence)
        ]

    if not attrs_to_check:
        print(f"No cadences found in {module_path}")
        return 1

    errors = []
    warnings = []

    for attr_name in attrs_to_check:
        cadence = getattr(module, attr_name, None)
        if not isinstance(cadence, Cadence):
            continue

        print(f"Validating: {attr_name} ({cadence._name})")

        # Check for empty cadences
        if not cadence._nodes:
            errors.append(f"  {attr_name}: Cadence has no nodes")
            continue

        # Check node names
        node_names = set()
        for node in cadence._nodes:
            if node.name in node_names:
                warnings.append(f"  {attr_name}: Duplicate node name '{node.name}'")
            node_names.add(node.name)

        # Check for potential issues
        from cadence.nodes.parallel import ParallelNode
        for node in cadence._nodes:
            if isinstance(node, ParallelNode):
                if len(node._tasks) < 2:
                    warnings.append(
                        f"  {attr_name}: Parallel node '{node.name}' has only "
                        f"{len(node._tasks)} task(s)"
                    )

        print(f"  ✓ {len(cadence._nodes)} nodes")

    if errors:
        print("\nErrors:")
        for e in errors:
            print(f"  ✗ {e}")
        return 1

    if warnings:
        print("\nWarnings:")
        for w in warnings:
            print(f"  ⚠ {w}")

    print("\nValidation complete!")
    return 0


def main(argv: list[str] | None = None) -> int:
    """Main entry point for the CLI."""
    parser = argparse.ArgumentParser(
        prog="cadence",
        description="Cadence CLI - scaffolding and utilities",
    )
    parser.add_argument(
        "--version",
        action="version",
        version="%(prog)s 0.3.0",
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # init command
    init_parser = subparsers.add_parser("init", help="Initialize a new project")
    init_parser.add_argument(
        "directory",
        nargs="?",
        help="Project directory (default: current)",
    )
    init_parser.add_argument(
        "--name",
        help="Project name (default: directory name)",
    )

    # new command
    new_parser = subparsers.add_parser("new", help="Generate new components")
    new_subparsers = new_parser.add_subparsers(dest="component", help="Component type")

    # new cadence
    new_cadence_parser = new_subparsers.add_parser("cadence", help="Generate a new cadence")
    new_cadence_parser.add_argument("name", help="Cadence name")
    new_cadence_parser.add_argument("-o", "--output", help="Output directory (default: cadences)")
    new_cadence_parser.add_argument("-f", "--force", action="store_true", help="Overwrite existing")

    # new beat
    new_beat_parser = new_subparsers.add_parser("beat", help="Generate a new beat")
    new_beat_parser.add_argument("name", help="Beat name")
    new_beat_parser.add_argument("-o", "--output", help="Output directory (default: beats)")
    new_beat_parser.add_argument("-f", "--force", action="store_true", help="Overwrite existing")
    new_beat_parser.add_argument("--retry", type=int, help="Add @retry with max_attempts")
    new_beat_parser.add_argument("--timeout", type=float, help="Add @timeout with seconds")
    new_beat_parser.add_argument("--fallback", help="Add @fallback with default value")

    # diagram command
    diagram_parser = subparsers.add_parser("diagram", help="Generate cadence diagrams")
    diagram_parser.add_argument("cadence", help="Cadence as module:attribute")
    diagram_parser.add_argument(
        "-f", "--format",
        choices=["mermaid", "dot", "text"],
        default="mermaid",
        help="Output format",
    )
    diagram_parser.add_argument("-o", "--output", help="Output file")

    # validate command
    validate_parser = subparsers.add_parser("validate", help="Validate cadence definitions")
    validate_parser.add_argument("module", help="Module to validate (module or module:cadence)")

    args = parser.parse_args(argv)

    if args.command == "init":
        return init_command(args)
    elif args.command == "new":
        if args.component == "cadence":
            return new_cadence_command(args)
        elif args.component == "beat":
            return new_beat_command(args)
        else:
            new_parser.print_help()
            return 1
    elif args.command == "diagram":
        return diagram_command(args)
    elif args.command == "validate":
        return validate_command(args)
    else:
        parser.print_help()
        return 0


if __name__ == "__main__":
    sys.exit(main())
