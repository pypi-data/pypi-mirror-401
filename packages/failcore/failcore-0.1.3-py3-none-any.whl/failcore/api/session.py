# failcore/api/session.py
"""
Session API - legacy API for backward compatibility

Note: For new code, prefer using run() API instead.
Session is kept for backward compatibility with existing codebases.
"""

from __future__ import annotations
from typing import Any, Callable, Dict, Optional
from pathlib import Path
from datetime import datetime
from failcore.core.types.step import Step, RunContext, StepResult, generate_run_id
from ..core.executor.executor import Executor, ExecutorConfig
from ..core.tools.registry import ToolRegistry
from ..core.tools.spec import ToolSpec
from ..core.tools.metadata import ToolMetadata
from ..core.tools.invoker import ToolInvoker
from ..core.trace.recorder import JsonlTraceRecorder, NullTraceRecorder, TraceRecorder
from ..core.validate.validator import ValidatorRegistry
from ..core.validate.rules import ValidationRuleSet
from ..core.policy.policy import Policy
from ..utils.paths import get_failcore_root, get_database_path

class Session:
    """
    Session API - multiple tool calls within a single session
    
    Legacy API: This class is kept for backward compatibility.
    For new code, prefer using run() API which provides better ergonomics.
    
    Features:
    - session.call("tool", **params): Execute one step
    - session.register("tool_name", fn): Register a tool
    - Decorator-style tool registration supported
    - Failures don't raise exceptions: always returns structured result
    
    Example:
        >>> session = Session(trace="trace.jsonl")
        >>> session.register("divide", lambda a, b: a / b)
        >>> result = session.call("divide", a=6, b=2)
        >>> print(result.status, result.output.value)
    
    Decorator example:
        >>> session = Session()
        >>> @session.tool
        ... def add(a: int, b: int) -> int:
        ...     return a + b
        >>> result = session.call("add", a=1, b=2)
    
    Note:
        Session API returns StepResult objects, not direct values.
        For exception-based error handling, use run() API instead.
    """
    
    def __init__(
        self,
        trace: Optional[str] = "auto",
        validator: Optional[ValidatorRegistry] = None,
        policy: Optional[Policy] = None,
        sandbox: Optional[str] = None,
        run_id: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        auto_ingest: bool = True,
    ):
        """
        Create a new execution session
        
        Args:
            trace: Trace file path (.jsonl). Options:
                - "auto" (default): Auto-generate path .failcore/runs/<date>/<run_id>_<time>/trace.jsonl
                - str: Custom path
                - None: Disable tracing
            validator: Optional validator registry (precondition/postcondition checks)
            policy: Optional policy (resource access, cost control, etc.)
            sandbox: Optional sandbox root directory (file operation restrictions)
            run_id: Optional run_id (auto-generated by default)
            tags: Optional tags (for trace filtering)
            auto_ingest: If True, automatically ingest trace to database on close (default: True)
        
        Example:
            >>> # Simplest usage - auto trace to .failcore/runs/ + auto ingest
            >>> session = Session()
            
            >>> # Custom trace path with auto ingest
            >>> session = Session(trace="my_trace.jsonl")
            
            >>> # No tracing
            >>> session = Session(trace=None)
            
            >>> # Disable auto ingest
            >>> session = Session(auto_ingest=False)
        """
        # Generate run_id first (needed for auto trace path)
        self._run_id = run_id or generate_run_id()
        
        # Sandbox validation (v0.1.2: enforce explicit sandbox for security)
        if sandbox is None:
            # Default to .failcore/sandbox for safety
            sandbox = str(get_failcore_root() / "sandbox")
        
        # Initialize Janitor and ProcessRegistry (阶段一：Session 中心化)
        from failcore.infra.lifecycle.janitor import ResourceJanitor
        from failcore.core.process import ProcessRegistry
        
        self._janitor = ResourceJanitor()
        self._process_registry = ProcessRegistry(auto_cleanup=True)
        self._session_manifest = None  # Will be created in __enter__
        self._session_resources = None  # Will be created when needed  
        
        # Store sandbox root
        self._sandbox_root = Path(sandbox)
        
        # Tool registry with sandbox support
        self._tools = ToolRegistry(sandbox_root=sandbox)
        
        # Validator registry (create if not provided)
        if validator is None:
            validator = ValidatorRegistry()
        self._validator = validator
        
        # Store auto_ingest flag
        self._auto_ingest = auto_ingest
        
        # Handle auto trace path
        # Use POSIX format (forward slashes) for cross-platform compatibility
        if trace == "auto":
            # Generate: <project_root>/.failcore/runs/<date>/<run_id>_<time>/trace.jsonl
            # Group by date to avoid too many directories in one folder
            failcore_root = get_failcore_root()
            now = datetime.now()
            date = now.strftime("%Y%m%d")
            time = now.strftime("%H%M%S")
            run_dir = failcore_root / "runs" / date / f"{self._run_id}_{time}"
            run_dir.mkdir(parents=True, exist_ok=True)
            trace_path = (run_dir / "trace.jsonl").as_posix()
            self._recorder: TraceRecorder = JsonlTraceRecorder(trace_path)
            self._trace_path = trace_path
        elif trace is None:
            self._recorder: TraceRecorder = NullTraceRecorder()
            self._trace_path = None
        else:
            # Custom trace path - ensure directory exists
            trace_dir = Path(trace).parent
            if trace_dir != Path('.'):
                trace_dir.mkdir(parents=True, exist_ok=True)
            # Store path in POSIX format
            self._recorder: TraceRecorder = JsonlTraceRecorder(trace)
            self._trace_path = Path(trace).as_posix()
        
        # Create SessionResources (阶段一 Step 1: 统一资源容器)
        from failcore.core.executor.resources import SessionResources
        
        self._session_resources = SessionResources.create(
            session_id=self._run_id,
            sandbox_root=self._sandbox_root,
            process_registry=self._process_registry,
            trace_recorder=self._recorder,
            janitor=self._janitor,
        )
        
        # Create executor with SessionResources (阶段一 Step 2: 强制使用 SessionResources)
        self._executor = Executor(
            tools=self._tools,
            session_resources=self._session_resources,  # 使用 SessionResources
            validator=self._validator,
            policy=policy,
            config=ExecutorConfig()
        )
        
        # Run context - convert sandbox to relative path if absolute
        # Use POSIX format (forward slashes) for cross-platform compatibility
        sandbox_rel = None
        if sandbox:
            sandbox_path = Path(sandbox)
            if sandbox_path.is_absolute():
                try:
                    sandbox_rel = sandbox_path.relative_to(Path.cwd()).as_posix()
                except ValueError:
                    sandbox_rel = Path(sandbox).as_posix()
            else:
                sandbox_rel = Path(sandbox).as_posix()
        
        self._ctx = RunContext(
            run_id=self._run_id,
            sandbox_root=sandbox_rel,
            tags=tags or {}
        )
        
        # Step counter (for generating step_id)
        self._step_counter = 0
        
        # Create invoker (unified tool execution interface)
        # This is the entry point for all adapters
        self.invoker = ToolInvoker(self._executor, self._ctx)
    
    def register(
        self,
        name: str,
        fn: Callable[..., Any],
        metadata: Optional[ToolMetadata] = None,
        description: str = "",
        auto_assemble: bool = True,
    ) -> None:
        """
        Register a tool with optional metadata
        
        Args:
            name: Tool name
            fn: Tool function (callable)
            metadata: Optional tool metadata (risk, side effect, policy)
            description: Optional tool description
            auto_assemble: Auto-assemble validation rules from metadata
        
        Example:
            >>> # Simple registration
            >>> session.register("divide", lambda a, b: a / b)
            
            >>> # With metadata
            >>> from failcore.core.tools.metadata import ToolMetadata, RiskLevel, SideEffect, DefaultAction
            >>> session.register(
            ...     "write_file",
            ...     write_file_fn,
            ...     metadata=ToolMetadata(
            ...         risk_level=RiskLevel.HIGH,
            ...         side_effect=SideEffect.FS,
            ...         default_action=DefaultAction.BLOCK,
            ...     )
            ... )
        """
        if metadata is not None:
            # Register with full metadata support
            spec = ToolSpec(
                name=name,
                fn=fn,
                description=description,
                tool_metadata=metadata,
            )
            self._tools.register_tool(spec, auto_assemble=auto_assemble)
            
            # Sync validators to ValidatorRegistry for execution
            preconditions = self._tools.get_preconditions(name)
            postconditions = self._tools.get_postconditions(name)
            for precond in preconditions:
                self._validator.register_precondition(name, precond)
            for postcond in postconditions:
                self._validator.register_postcondition(name, postcond)
        else:
            # Simple registration (backward compatible)
            self._tools.register(name, fn)
    
    def bind_rules(self, tool_name: str, rules: ValidationRuleSet) -> None:
        """
        Bind validation rules to a tool
        
        Args:
            tool_name: Tool name
            rules: ValidationRuleSet with preconditions/postconditions
        
        Example:
            >>> from failcore.core.validate.rules import RuleAssembler
            >>> assembler = RuleAssembler(sandbox_root="/workspace")
            >>> rules = assembler.assemble(...)
            >>> session.bind_rules("write_file", rules)
        """
        # Register in ToolRegistry (for tracking)
        for precond in rules.preconditions:
            self._tools.register_precondition(tool_name, precond)
        for postcond in rules.postconditions:
            self._tools.register_postcondition(tool_name, postcond)
        
        # Also register in ValidatorRegistry (for execution)
        for precond in rules.preconditions:
            self._validator.register_precondition(tool_name, precond)
        for postcond in rules.postconditions:
            self._validator.register_postcondition(tool_name, postcond)
    
    def tool(self, fn: Callable[..., Any]) -> Callable[..., Any]:
        """
        Decorator-style tool registration (uses function name as tool name)
        
        Args:
            fn: Tool function
        
        Returns:
            Original function (unmodified)
        
        Example:
            >>> @session.tool
            ... def add(a: int, b: int) -> int:
            ...     return a + b
        """
        self._tools.register(fn.__name__, fn)
        return fn
    
    def call(self, tool: str, **params: Any) -> StepResult:
        """
        Call a tool
        
        Args:
            tool: Tool name
            **params: Tool parameters
        
        Returns:
            StepResult: Execution result (ok/fail + output/error)
        
        Example:
            >>> result = session.call("divide", a=6, b=2)
            >>> if result.status == "ok":
            ...     print(result.output.value)
        """
        # Generate step_id
        self._step_counter += 1
        step_id = f"s{self._step_counter:04d}"
        
        # Create step
        step = Step(
            id=step_id,
            tool=tool,
            params=params
        )
        
        # Execute
        result = self._executor.execute(step, self._ctx)
        
        return result
    
    def close(self) -> None:
        """
        Close session and cleanup resources
        
        If auto_ingest=True, automatically ingests trace to database.
        
        Example:
            >>> session = Session(trace="trace.jsonl")
            >>> try:
            ...     session.call("divide", a=6, b=2)
            ... finally:
            ...     session.close()
        """
        # Close recorder first to flush trace
        if hasattr(self._recorder, 'close'):
            try:
                self._recorder.close()
            except Exception:
                pass
        
        # Auto-ingest trace to database
        if self._auto_ingest and self._trace_path:
            self._ingest_trace()
    
    def _ingest_trace(self) -> None:
        """
        Internal method: Ingest trace to database.
        
        This is called automatically if auto_ingest=True.
        Failures are silently logged to avoid breaking session cleanup.
        """
        try:
            from ..infra.storage import SQLiteStore, TraceIngestor
            
            # Check if trace file exists and has content
            if not Path(self._trace_path).exists():
                return
            
            file_size = Path(self._trace_path).stat().st_size
            if file_size == 0:
                return
            
            # Default database path (uses project root detection)
            db_path = str(get_database_path())
            
            # Ensure directory exists
            Path(db_path).parent.mkdir(parents=True, exist_ok=True)
            
            # Ingest trace
            with SQLiteStore(db_path) as store:
                store.init_schema()
                ingestor = TraceIngestor(store)
                stats = ingestor.ingest_file(self._trace_path, skip_if_exists=True)
                
                # Silently succeed - trace ingested
        
        except ImportError:
            # Storage module not available - skip silently
            pass
        except Exception as e:
            # Don't fail session close due to ingest errors
            # Users can manually ingest later if needed
            import sys
            if hasattr(sys, 'stderr'):
                print(f"Warning: Failed to auto-ingest trace: {e}", file=sys.stderr)
    
    def __enter__(self) -> Session:
        """
        Enter session context - cleanup stale resources and register session
        
        阶段一 Step 3: Session 生命周期管理
        - 清理历史孤儿资源
        - 注册当前 session
        """
        # Step 3.1: Cleanup stale sessions from previous runs
        try:
            cleanup_results = self._janitor.cleanup_stale_sessions(
                max_age_hours=24.0,
                force=False
            )
            if cleanup_results:
                import logging
                logger = logging.getLogger(__name__)
                logger.info(f"Cleaned up {len(cleanup_results)} stale sessions on startup")
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.warning(f"Failed to cleanup stale sessions: {e}")
        
        # Step 3.2: Register current session
        try:
            from failcore.infra.lifecycle.janitor import SessionManifest
            import time
            
            self._session_manifest = SessionManifest(
                session_id=self._run_id,
                sandbox_root=str(self._sandbox_root),
                created_at=time.time(),
                pgid=self._process_registry.get_process_group(),
                pids=list(self._process_registry.get_owned_pids()),
            )
            
            self._janitor.register_session(self._session_manifest)
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.warning(f"Failed to register session: {e}")
        
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """
        Exit session context - cleanup resources and unregister session
        
        阶段一 Step 3: Session 生命周期管理
        - 清理所有拥有的进程
        - 注销 session
        - 关闭 trace
        """
        try:
            # Step 3.3: Cleanup owned processes
            import logging
            logger = logging.getLogger(__name__)
            
            if self._process_registry:
                try:
                    cleanup_results = self._process_registry.cleanup(
                        timeout=10.0,
                        force=True,
                        use_process_group=True
                    )
                    
                    if cleanup_results:
                        failed = [pid for pid, ok in cleanup_results.items() if not ok]
                        if failed:
                            logger.warning(f"Failed to cleanup PIDs: {failed}")
                        else:
                            logger.debug(f"Successfully cleaned up {len(cleanup_results)} processes")
                except Exception as e:
                    logger.error(f"Error during process cleanup: {e}", exc_info=True)
            
            # Step 3.4: Unregister session
            if self._janitor and self._run_id:
                try:
                    self._janitor.unregister_session(self._run_id)
                except Exception as e:
                    logger.warning(f"Failed to unregister session: {e}")
        
        finally:
            # Always call close to flush trace and ingest
            self.close()
    
    @property
    def run_id(self) -> str:
        """Get current session's run_id"""
        return self._ctx.run_id
    
    @property
    def tools(self) -> ToolRegistry:
        """Get tool registry (advanced usage)"""
        return self._tools
