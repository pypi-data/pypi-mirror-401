# failcore/core/step/step.py
from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Mapping, Optional, Union
from datetime import datetime, timezone
import uuid


# ---------------------------
# Helpers
# ---------------------------

def utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def generate_run_id(prefix: str = "run") -> str:
    return f"{prefix}_{uuid.uuid4().hex[:12]}"

def generate_step_id(prefix: str = "s") -> str:
    # s_0001 style ids can be generated by planner; runtime can accept any string.
    return f"{prefix}_{uuid.uuid4().hex[:8]}"


# ---------------------------
# Core Contract Types
# ---------------------------

class StepStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    OK = "ok"
    FAIL = "fail"
    BLOCKED = "blocked"  # v0.1.2: security/policy prevention
    SKIPPED = "skipped"  # reserved (v0.1 typically won't use)
    TIMEOUT = "timeout"  # 阶段四：Step execution exceeded timeout


class OutputKind(str, Enum):
    """
    A lightweight hint for downstream handling / trace summarization.
    Do NOT overfit this early; keep it as a hint.
    """
    TEXT = "text"
    JSON = "json"
    ARTIFACTS = "artifacts"
    BYTES = "bytes"
    UNKNOWN = "unknown"


@dataclass(frozen=True)
class ArtifactRef:
    """
    Reference to an artifact produced/consumed during execution.
    Keep it generic: could be a file path, url, key in blob store, etc.
    """
    uri: str                       # e.g. "file:///abs/path/a.txt" or "sandbox:/a.txt"
    kind: str = "file"             # e.g. "file", "image", "table", ...
    name: Optional[str] = None     # display name
    media_type: Optional[str] = None  # "text/plain", "application/pdf", etc.
    size_bytes: Optional[int] = None
    sha256: Optional[str] = None   # optional integrity


@dataclass(frozen=True)
class Step:
    """
    Step = execution contract emitted by planner and consumed by executor.

    v0.1 principles:
    - literal params only (no variables), BUT we keep a slot for bindings for v0.2+
    - depends_on is allowed but optional
    """
    id: str
    tool: str
    params: Dict[str, Any] = field(default_factory=dict)
    depends_on: List[str] = field(default_factory=list)

    # Optional: planner may attach hints; runtime should treat as non-authoritative.
    meta: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        if not isinstance(self.id, str) or not self.id.strip():
            raise ValueError("Step.id must be a non-empty string")
        if not isinstance(self.tool, str) or not self.tool.strip():
            raise ValueError("Step.tool must be a non-empty string")
        if not isinstance(self.params, dict):
            raise ValueError("Step.params must be a dict")
        if not isinstance(self.depends_on, list):
            raise ValueError("Step.depends_on must be a list")


@dataclass(frozen=True)
class RunContext:
    """
    RunContext = runtime-provided context (not controlled by planner).
    Think of it as the "execution envelope".

    NOTE:
    - We intentionally keep it simple for v0.1
    - It can grow later: user_id, tenant_id, correlation_id, locale, etc.
    """
    run_id: str = field(default_factory=generate_run_id)
    created_at: str = field(default_factory=utc_now_iso)

    # Sandbox / security boundary
    sandbox_root: Optional[str] = None   # e.g. "D:/Sandbox/failcore/run_xxx"
    cwd: Optional[str] = None            # for relative operations, if allowed

    # Toggle knobs (strictness, trace, etc.)—executor/config may override
    flags: Dict[str, Any] = field(default_factory=dict)

    # Arbitrary tags for trace filtering
    tags: Dict[str, str] = field(default_factory=dict)

    def __post_init__(self) -> None:
        if not isinstance(self.run_id, str) or not self.run_id.strip():
            raise ValueError("RunContext.run_id must be a non-empty string")
        if not isinstance(self.flags, dict):
            raise ValueError("RunContext.flags must be a dict")
        if not isinstance(self.tags, dict):
            raise ValueError("RunContext.tags must be a dict")


@dataclass(frozen=True)
class StepError:
    """
    Failure must always be mapped to a stable error_code.
    """
    error_code: str
    message: str
    detail: Optional[Dict[str, Any]] = None

    def __post_init__(self) -> None:
        if not isinstance(self.error_code, str) or not self.error_code.strip():
            raise ValueError("StepError.error_code must be a non-empty string")
        if not isinstance(self.message, str) or not self.message.strip():
            raise ValueError("StepError.message must be a non-empty string")
        if self.detail is not None and not isinstance(self.detail, dict):
            raise ValueError("StepError.detail must be a dict if provided")


@dataclass(frozen=True)
class StepOutput:
    """
    Normalized output wrapper.
    Keep 'value' flexible; use 'kind' as a hint.
    """
    kind: OutputKind = OutputKind.UNKNOWN
    value: Any = None
    artifacts: List[ArtifactRef] = field(default_factory=list)

    def __post_init__(self) -> None:
        if not isinstance(self.artifacts, list):
            raise ValueError("StepOutput.artifacts must be a list")


@dataclass(frozen=True)
class StepResult:
    """
    Result of executing a single step.

    Design goals:
    - explicit ok/fail status
    - explicit error_code on failure
    - allow attaching artifacts for trace/replay
    """
    step_id: str
    tool: str
    status: StepStatus

    started_at: str
    finished_at: str
    duration_ms: int

    output: Optional[StepOutput] = None
    error: Optional[StepError] = None

    # optional: execution metadata for debugging
    meta: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        if not isinstance(self.step_id, str) or not self.step_id.strip():
            raise ValueError("StepResult.step_id must be a non-empty string")
        if not isinstance(self.tool, str) or not self.tool.strip():
            raise ValueError("StepResult.tool must be a non-empty string")
        if self.status in (StepStatus.OK,) and self.error is not None:
            raise ValueError("StepResult.error must be None when status is OK")
        if self.status in (StepStatus.FAIL,) and self.error is None:
            raise ValueError("StepResult.error must be provided when status is FAIL")
        if self.duration_ms < 0:
            raise ValueError("StepResult.duration_ms must be >= 0")
        if not isinstance(self.meta, dict):
            raise ValueError("StepResult.meta must be a dict")


# ---------------------------
# Serialization helpers (optional but handy)
# ---------------------------

JSONLike = Union[None, bool, int, float, str, List["JSONLike"], Dict[str, "JSONLike"]]

def _to_jsonable(x: Any) -> JSONLike:
    """
    Best-effort conversion. Keep it conservative for trace:
    - primitives pass through
    - dataclasses -> dict
    - other objects -> str()
    """
    if x is None or isinstance(x, (bool, int, float, str)):
        return x
    if isinstance(x, Enum):
        return x.value
    if isinstance(x, list):
        return [_to_jsonable(i) for i in x]
    if isinstance(x, dict):
        return {str(k): _to_jsonable(v) for k, v in x.items()}
    if hasattr(x, "__dataclass_fields__"):
        # dataclass
        d = {}
        for f in x.__dataclass_fields__.keys():  # type: ignore[attr-defined]
            d[f] = _to_jsonable(getattr(x, f))
        return d
    return str(x)

def step_to_dict(step: Step) -> Dict[str, JSONLike]:
    return {
        "id": step.id,
        "tool": step.tool,
        "params": _to_jsonable(step.params),
        "depends_on": _to_jsonable(step.depends_on),
        "meta": _to_jsonable(step.meta),
    }

def ctx_to_dict(ctx: RunContext) -> Dict[str, JSONLike]:
    return {
        "run_id": ctx.run_id,
        "created_at": ctx.created_at,
        "sandbox_root": ctx.sandbox_root,
        "cwd": ctx.cwd,
        "flags": _to_jsonable(ctx.flags),
        "tags": _to_jsonable(ctx.tags),
    }

def result_to_dict(r: StepResult) -> Dict[str, JSONLike]:
    return {
        "step_id": r.step_id,
        "tool": r.tool,
        "status": r.status.value,
        "started_at": r.started_at,
        "finished_at": r.finished_at,
        "duration_ms": r.duration_ms,
        "output": _to_jsonable(r.output) if r.output is not None else None,
        "error": _to_jsonable(r.error) if r.error is not None else None,
        "meta": _to_jsonable(r.meta),
    }
