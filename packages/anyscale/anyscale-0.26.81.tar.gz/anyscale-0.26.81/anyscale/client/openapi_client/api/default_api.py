# coding: utf-8

"""
    Managed Ray API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.1.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_cloud_resource_api_v2_clouds_cloud_id_add_resource_put(self, cloud_id, cloud_deployment, **kwargs):  # noqa: E501
        """Add Cloud Resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_cloud_resource_api_v2_clouds_cloud_id_add_resource_put(cloud_id, cloud_deployment, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudDeployment cloud_deployment: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClouddeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_cloud_resource_api_v2_clouds_cloud_id_add_resource_put_with_http_info(cloud_id, cloud_deployment, **kwargs)  # noqa: E501

    def add_cloud_resource_api_v2_clouds_cloud_id_add_resource_put_with_http_info(self, cloud_id, cloud_deployment, **kwargs):  # noqa: E501
        """Add Cloud Resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_cloud_resource_api_v2_clouds_cloud_id_add_resource_put_with_http_info(cloud_id, cloud_deployment, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudDeployment cloud_deployment: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClouddeploymentResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_deployment'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_cloud_resource_api_v2_clouds_cloud_id_add_resource_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `add_cloud_resource_api_v2_clouds_cloud_id_add_resource_put`")  # noqa: E501
        # verify the required parameter 'cloud_deployment' is set
        if self.api_client.client_side_validation and ('cloud_deployment' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_deployment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_deployment` when calling `add_cloud_resource_api_v2_clouds_cloud_id_add_resource_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_deployment' in local_var_params:
            body_params = local_var_params['cloud_deployment']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/add_resource', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClouddeploymentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_to_waitlist_api_v2_aioa_cloud_waitlist_post(self, create_aioa_cloud_waitlist, **kwargs):  # noqa: E501
        """Add To Waitlist  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_to_waitlist_api_v2_aioa_cloud_waitlist_post(create_aioa_cloud_waitlist, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAioaCloudWaitlist create_aioa_cloud_waitlist: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AioacloudwaitlistrecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_to_waitlist_api_v2_aioa_cloud_waitlist_post_with_http_info(create_aioa_cloud_waitlist, **kwargs)  # noqa: E501

    def add_to_waitlist_api_v2_aioa_cloud_waitlist_post_with_http_info(self, create_aioa_cloud_waitlist, **kwargs):  # noqa: E501
        """Add To Waitlist  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_to_waitlist_api_v2_aioa_cloud_waitlist_post_with_http_info(create_aioa_cloud_waitlist, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAioaCloudWaitlist create_aioa_cloud_waitlist: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AioacloudwaitlistrecordResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_aioa_cloud_waitlist'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_to_waitlist_api_v2_aioa_cloud_waitlist_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_aioa_cloud_waitlist' is set
        if self.api_client.client_side_validation and ('create_aioa_cloud_waitlist' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_aioa_cloud_waitlist'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_aioa_cloud_waitlist` when calling `add_to_waitlist_api_v2_aioa_cloud_waitlist_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_aioa_cloud_waitlist' in local_var_params:
            body_params = local_var_params['create_aioa_cloud_waitlist']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aioa_cloud_waitlist/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AioacloudwaitlistrecordResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admin_batch_create_users_api_v2_users_admin_batch_create_post(self, admin_create_user, **kwargs):  # noqa: E501
        """Admin Batch Create Users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_batch_create_users_api_v2_users_admin_batch_create_post(admin_create_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[AdminCreateUser] admin_create_user: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AdmincreateduserListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.admin_batch_create_users_api_v2_users_admin_batch_create_post_with_http_info(admin_create_user, **kwargs)  # noqa: E501

    def admin_batch_create_users_api_v2_users_admin_batch_create_post_with_http_info(self, admin_create_user, **kwargs):  # noqa: E501
        """Admin Batch Create Users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admin_batch_create_users_api_v2_users_admin_batch_create_post_with_http_info(admin_create_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[AdminCreateUser] admin_create_user: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AdmincreateduserListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'admin_create_user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_batch_create_users_api_v2_users_admin_batch_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'admin_create_user' is set
        if self.api_client.client_side_validation and ('admin_create_user' not in local_var_params or  # noqa: E501
                                                        local_var_params['admin_create_user'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `admin_create_user` when calling `admin_batch_create_users_api_v2_users_admin_batch_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'admin_create_user' in local_var_params:
            body_params = local_var_params['admin_create_user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/admin_batch_create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdmincreateduserListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def admission_api_v2_kubernetes_manager_admission_cloud_resource_id_post(self, cloud_resource_id, **kwargs):  # noqa: E501
        """Admission  # noqa: E501

        Admission Webhook for Kubernetes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admission_api_v2_kubernetes_manager_admission_cloud_resource_id_post(cloud_resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_resource_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.admission_api_v2_kubernetes_manager_admission_cloud_resource_id_post_with_http_info(cloud_resource_id, **kwargs)  # noqa: E501

    def admission_api_v2_kubernetes_manager_admission_cloud_resource_id_post_with_http_info(self, cloud_resource_id, **kwargs):  # noqa: E501
        """Admission  # noqa: E501

        Admission Webhook for Kubernetes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.admission_api_v2_kubernetes_manager_admission_cloud_resource_id_post_with_http_info(cloud_resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_resource_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_resource_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admission_api_v2_kubernetes_manager_admission_cloud_resource_id_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_resource_id' is set
        if self.api_client.client_side_validation and ('cloud_resource_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_resource_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_resource_id` when calling `admission_api_v2_kubernetes_manager_admission_cloud_resource_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_resource_id' in local_var_params:
            path_params['cloud_resource_id'] = local_var_params['cloud_resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/kubernetes_manager/admission/{cloud_resource_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put(self, cloud_id, identity_id, update_cloud_collaborator, **kwargs):  # noqa: E501
        """Alter Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put(cloud_id, identity_id, update_cloud_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str identity_id: (required)
        :param UpdateCloudCollaborator update_cloud_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put_with_http_info(cloud_id, identity_id, update_cloud_collaborator, **kwargs)  # noqa: E501

    def alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put_with_http_info(self, cloud_id, identity_id, update_cloud_collaborator, **kwargs):  # noqa: E501
        """Alter Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put_with_http_info(cloud_id, identity_id, update_cloud_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str identity_id: (required)
        :param UpdateCloudCollaborator update_cloud_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'identity_id',
            'update_cloud_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put`")  # noqa: E501
        # verify the required parameter 'identity_id' is set
        if self.api_client.client_side_validation and ('identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identity_id` when calling `alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put`")  # noqa: E501
        # verify the required parameter 'update_cloud_collaborator' is set
        if self.api_client.client_side_validation and ('update_cloud_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_cloud_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_cloud_collaborator` when calling `alter_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_identity_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501
        if 'identity_id' in local_var_params:
            path_params['identity_id'] = local_var_params['identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_cloud_collaborator' in local_var_params:
            body_params = local_var_params['update_cloud_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/collaborators/users/{identity_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put(self, identity_id, update_organization_collaborator, **kwargs):  # noqa: E501
        """Alter Organization Collaborator  # noqa: E501

        Updates a collaborator's permission level  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put(identity_id, update_organization_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str identity_id: (required)
        :param UpdateOrganizationCollaborator update_organization_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put_with_http_info(identity_id, update_organization_collaborator, **kwargs)  # noqa: E501

    def alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put_with_http_info(self, identity_id, update_organization_collaborator, **kwargs):  # noqa: E501
        """Alter Organization Collaborator  # noqa: E501

        Updates a collaborator's permission level  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put_with_http_info(identity_id, update_organization_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str identity_id: (required)
        :param UpdateOrganizationCollaborator update_organization_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'identity_id',
            'update_organization_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'identity_id' is set
        if self.api_client.client_side_validation and ('identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identity_id` when calling `alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put`")  # noqa: E501
        # verify the required parameter 'update_organization_collaborator' is set
        if self.api_client.client_side_validation and ('update_organization_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_organization_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_organization_collaborator` when calling `alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identity_id' in local_var_params:
            path_params['identity_id'] = local_var_params['identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_organization_collaborator' in local_var_params:
            body_params = local_var_params['update_organization_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/{identity_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put(self, project_id, role_or_identity_id, update_project_collaborator, **kwargs):  # noqa: E501
        """Alter Project Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put(project_id, role_or_identity_id, update_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str role_or_identity_id: (required)
        :param UpdateProjectCollaborator update_project_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put_with_http_info(project_id, role_or_identity_id, update_project_collaborator, **kwargs)  # noqa: E501

    def alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put_with_http_info(self, project_id, role_or_identity_id, update_project_collaborator, **kwargs):  # noqa: E501
        """Alter Project Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put_with_http_info(project_id, role_or_identity_id, update_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str role_or_identity_id: (required)
        :param UpdateProjectCollaborator update_project_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'role_or_identity_id',
            'update_project_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put`")  # noqa: E501
        # verify the required parameter 'role_or_identity_id' is set
        if self.api_client.client_side_validation and ('role_or_identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_or_identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_or_identity_id` when calling `alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put`")  # noqa: E501
        # verify the required parameter 'update_project_collaborator' is set
        if self.api_client.client_side_validation and ('update_project_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_project_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_project_collaborator` when calling `alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501
        if 'role_or_identity_id' in local_var_params:
            path_params['role_or_identity_id'] = local_var_params['role_or_identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_project_collaborator' in local_var_params:
            body_params = local_var_params['update_project_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/{role_or_identity_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def apply_autoscaling_config_update_api_v2_services_v2_service_id_apply_autoscaling_config_update_put(self, service_id, apply_autoscaling_config_update_model, **kwargs):  # noqa: E501
        """Apply Autoscaling Config Update  # noqa: E501

        Apply an autoscaling config update  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_autoscaling_config_update_api_v2_services_v2_service_id_apply_autoscaling_config_update_put(service_id, apply_autoscaling_config_update_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param ApplyAutoscalingConfigUpdateModel apply_autoscaling_config_update_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.apply_autoscaling_config_update_api_v2_services_v2_service_id_apply_autoscaling_config_update_put_with_http_info(service_id, apply_autoscaling_config_update_model, **kwargs)  # noqa: E501

    def apply_autoscaling_config_update_api_v2_services_v2_service_id_apply_autoscaling_config_update_put_with_http_info(self, service_id, apply_autoscaling_config_update_model, **kwargs):  # noqa: E501
        """Apply Autoscaling Config Update  # noqa: E501

        Apply an autoscaling config update  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_autoscaling_config_update_api_v2_services_v2_service_id_apply_autoscaling_config_update_put_with_http_info(service_id, apply_autoscaling_config_update_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param ApplyAutoscalingConfigUpdateModel apply_autoscaling_config_update_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'apply_autoscaling_config_update_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_autoscaling_config_update_api_v2_services_v2_service_id_apply_autoscaling_config_update_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `apply_autoscaling_config_update_api_v2_services_v2_service_id_apply_autoscaling_config_update_put`")  # noqa: E501
        # verify the required parameter 'apply_autoscaling_config_update_model' is set
        if self.api_client.client_side_validation and ('apply_autoscaling_config_update_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['apply_autoscaling_config_update_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `apply_autoscaling_config_update_model` when calling `apply_autoscaling_config_update_api_v2_services_v2_service_id_apply_autoscaling_config_update_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'apply_autoscaling_config_update_model' in local_var_params:
            body_params = local_var_params['apply_autoscaling_config_update_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/apply_autoscaling_config_update', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def apply_service_api_v2_services_v2_apply_put(self, apply_production_service_v2_model, **kwargs):  # noqa: E501
        """Apply Service  # noqa: E501

        Apply a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_service_api_v2_services_v2_apply_put(apply_production_service_v2_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplyProductionServiceV2Model apply_production_service_v2_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.apply_service_api_v2_services_v2_apply_put_with_http_info(apply_production_service_v2_model, **kwargs)  # noqa: E501

    def apply_service_api_v2_services_v2_apply_put_with_http_info(self, apply_production_service_v2_model, **kwargs):  # noqa: E501
        """Apply Service  # noqa: E501

        Apply a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_service_api_v2_services_v2_apply_put_with_http_info(apply_production_service_v2_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplyProductionServiceV2Model apply_production_service_v2_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'apply_production_service_v2_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_service_api_v2_services_v2_apply_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'apply_production_service_v2_model' is set
        if self.api_client.client_side_validation and ('apply_production_service_v2_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['apply_production_service_v2_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `apply_production_service_v2_model` when calling `apply_service_api_v2_services_v2_apply_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'apply_production_service_v2_model' in local_var_params:
            body_params = local_var_params['apply_production_service_v2_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/apply', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def apply_service_multi_version_api_v2_services_v2_apply_multi_version_put(self, apply_production_service_multi_version_v2_model, **kwargs):  # noqa: E501
        """Apply Service Multi Version  # noqa: E501

        Apply a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_service_multi_version_api_v2_services_v2_apply_multi_version_put(apply_production_service_multi_version_v2_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplyProductionServiceMultiVersionV2Model apply_production_service_multi_version_v2_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.apply_service_multi_version_api_v2_services_v2_apply_multi_version_put_with_http_info(apply_production_service_multi_version_v2_model, **kwargs)  # noqa: E501

    def apply_service_multi_version_api_v2_services_v2_apply_multi_version_put_with_http_info(self, apply_production_service_multi_version_v2_model, **kwargs):  # noqa: E501
        """Apply Service Multi Version  # noqa: E501

        Apply a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_service_multi_version_api_v2_services_v2_apply_multi_version_put_with_http_info(apply_production_service_multi_version_v2_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplyProductionServiceMultiVersionV2Model apply_production_service_multi_version_v2_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'apply_production_service_multi_version_v2_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_service_multi_version_api_v2_services_v2_apply_multi_version_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'apply_production_service_multi_version_v2_model' is set
        if self.api_client.client_side_validation and ('apply_production_service_multi_version_v2_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['apply_production_service_multi_version_v2_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `apply_production_service_multi_version_v2_model` when calling `apply_service_multi_version_api_v2_services_v2_apply_multi_version_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'apply_production_service_multi_version_v2_model' in local_var_params:
            body_params = local_var_params['apply_production_service_multi_version_v2_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/apply_multi_version', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post(self, application_template_id, **kwargs):  # noqa: E501
        """Archive Cluster Environment  # noqa: E501

        Archives a cluster environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post_with_http_info(application_template_id, **kwargs)  # noqa: E501

    def archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post_with_http_info(self, application_template_id, **kwargs):  # noqa: E501
        """Archive Cluster Environment  # noqa: E501

        Archives a cluster environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post_with_http_info(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'application_template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_template_id' is set
        if self.api_client.client_side_validation and ('application_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_template_id` when calling `archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_template_id' in local_var_params:
            path_params['application_template_id'] = local_var_params['application_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/{application_template_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post(self, compute_template_id, **kwargs):  # noqa: E501
        """Archive Compute Template  # noqa: E501

        Archives a compute template and all of its versions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post(compute_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str compute_template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post_with_http_info(compute_template_id, **kwargs)  # noqa: E501

    def archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post_with_http_info(self, compute_template_id, **kwargs):  # noqa: E501
        """Archive Compute Template  # noqa: E501

        Archives a compute template and all of its versions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post_with_http_info(compute_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str compute_template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'compute_template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'compute_template_id' is set
        if self.api_client.client_side_validation and ('compute_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['compute_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `compute_template_id` when calling `archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'compute_template_id' in local_var_params:
            path_params['compute_template_id'] = local_var_params['compute_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/{compute_template_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post(self, production_job_id, **kwargs):  # noqa: E501
        """Archive Job  # noqa: E501

        Archives the Job/Service. It is a no-op if the cluster is already archived.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post_with_http_info(production_job_id, **kwargs)  # noqa: E501

    def archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post_with_http_info(self, production_job_id, **kwargs):  # noqa: E501
        """Archive Job  # noqa: E501

        Archives the Job/Service. It is a no-op if the cluster is already archived.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post_with_http_info(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_job_queue_api_v2_job_queues_job_queue_id_archive_post(self, job_queue_id, **kwargs):  # noqa: E501
        """Archive Job Queue  # noqa: E501

        Archive a job queue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_job_queue_api_v2_job_queues_job_queue_id_archive_post(job_queue_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_queue_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_job_queue_api_v2_job_queues_job_queue_id_archive_post_with_http_info(job_queue_id, **kwargs)  # noqa: E501

    def archive_job_queue_api_v2_job_queues_job_queue_id_archive_post_with_http_info(self, job_queue_id, **kwargs):  # noqa: E501
        """Archive Job Queue  # noqa: E501

        Archive a job queue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_job_queue_api_v2_job_queues_job_queue_id_archive_post_with_http_info(job_queue_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_queue_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_queue_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_job_queue_api_v2_job_queues_job_queue_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_queue_id' is set
        if self.api_client.client_side_validation and ('job_queue_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_queue_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_queue_id` when calling `archive_job_queue_api_v2_job_queues_job_queue_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_queue_id' in local_var_params:
            path_params['job_queue_id'] = local_var_params['job_queue_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/job_queues/{job_queue_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_service_api_v2_services_v2_service_id_archive_post(self, service_id, **kwargs):  # noqa: E501
        """Archive Service  # noqa: E501

        Archives a Service. It is a no-op if already archived.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_service_api_v2_services_v2_service_id_archive_post(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_service_api_v2_services_v2_service_id_archive_post_with_http_info(service_id, **kwargs)  # noqa: E501

    def archive_service_api_v2_services_v2_service_id_archive_post_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Archive Service  # noqa: E501

        Archives a Service. It is a no-op if already archived.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_service_api_v2_services_v2_service_id_archive_post_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_service_api_v2_services_v2_service_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `archive_service_api_v2_services_v2_service_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post(self, attach_machine_pool_to_cloud_request, **kwargs):  # noqa: E501
        """Attach Machine Pool To Cloud  # noqa: E501

        Attach a machine pool to a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post(attach_machine_pool_to_cloud_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AttachMachinePoolToCloudRequest attach_machine_pool_to_cloud_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachmachinepooltocloudresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post_with_http_info(attach_machine_pool_to_cloud_request, **kwargs)  # noqa: E501

    def attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post_with_http_info(self, attach_machine_pool_to_cloud_request, **kwargs):  # noqa: E501
        """Attach Machine Pool To Cloud  # noqa: E501

        Attach a machine pool to a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post_with_http_info(attach_machine_pool_to_cloud_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AttachMachinePoolToCloudRequest attach_machine_pool_to_cloud_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachmachinepooltocloudresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'attach_machine_pool_to_cloud_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'attach_machine_pool_to_cloud_request' is set
        if self.api_client.client_side_validation and ('attach_machine_pool_to_cloud_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['attach_machine_pool_to_cloud_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `attach_machine_pool_to_cloud_request` when calling `attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'attach_machine_pool_to_cloud_request' in local_var_params:
            body_params = local_var_params['attach_machine_pool_to_cloud_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/attach', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachmachinepooltocloudresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def aws_marketplace_registration_api_v2_organization_billing_aws_marketplace_registration_post(self, x_amzn_marketplace_token, **kwargs):  # noqa: E501
        """Aws Marketplace Registration  # noqa: E501

        Registers a user signup from AWS Marketplace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.aws_marketplace_registration_api_v2_organization_billing_aws_marketplace_registration_post(x_amzn_marketplace_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str x_amzn_marketplace_token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.aws_marketplace_registration_api_v2_organization_billing_aws_marketplace_registration_post_with_http_info(x_amzn_marketplace_token, **kwargs)  # noqa: E501

    def aws_marketplace_registration_api_v2_organization_billing_aws_marketplace_registration_post_with_http_info(self, x_amzn_marketplace_token, **kwargs):  # noqa: E501
        """Aws Marketplace Registration  # noqa: E501

        Registers a user signup from AWS Marketplace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.aws_marketplace_registration_api_v2_organization_billing_aws_marketplace_registration_post_with_http_info(x_amzn_marketplace_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str x_amzn_marketplace_token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'x_amzn_marketplace_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aws_marketplace_registration_api_v2_organization_billing_aws_marketplace_registration_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'x_amzn_marketplace_token' is set
        if self.api_client.client_side_validation and ('x_amzn_marketplace_token' not in local_var_params or  # noqa: E501
                                                        local_var_params['x_amzn_marketplace_token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `x_amzn_marketplace_token` when calling `aws_marketplace_registration_api_v2_organization_billing_aws_marketplace_registration_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'x_amzn_marketplace_token' in local_var_params:
            form_params.append(('x-amzn-marketplace-token', local_var_params['x_amzn_marketplace_token']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/aws_marketplace_registration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batch_create_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_batch_create_post(self, cloud_id, create_cloud_collaborator, **kwargs):  # noqa: E501
        """Batch Create Cloud Collaborators  # noqa: E501

        Give users in the same organization as auth context who previously did not have any individual permissions for this cloud the designated permissions.  An error will be raised if any of the users already has permissions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_create_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_batch_create_post(cloud_id, create_cloud_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param list[CreateCloudCollaborator] create_cloud_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.batch_create_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_batch_create_post_with_http_info(cloud_id, create_cloud_collaborator, **kwargs)  # noqa: E501

    def batch_create_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_batch_create_post_with_http_info(self, cloud_id, create_cloud_collaborator, **kwargs):  # noqa: E501
        """Batch Create Cloud Collaborators  # noqa: E501

        Give users in the same organization as auth context who previously did not have any individual permissions for this cloud the designated permissions.  An error will be raised if any of the users already has permissions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_create_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_batch_create_post_with_http_info(cloud_id, create_cloud_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param list[CreateCloudCollaborator] create_cloud_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'create_cloud_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_create_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_batch_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `batch_create_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_batch_create_post`")  # noqa: E501
        # verify the required parameter 'create_cloud_collaborator' is set
        if self.api_client.client_side_validation and ('create_cloud_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_cloud_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_cloud_collaborator` when calling `batch_create_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_batch_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_cloud_collaborator' in local_var_params:
            body_params = local_var_params['create_cloud_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/collaborators/users/batch_create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batch_create_invitations_api_v2_organization_invitations_batch_create_post(self, create_organization_invitation, **kwargs):  # noqa: E501
        """Batch Create Invitations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_create_invitations_api_v2_organization_invitations_batch_create_post(create_organization_invitation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[CreateOrganizationInvitation] create_organization_invitation: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BatchResponseBatchedResultOrganizationInvitationBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.batch_create_invitations_api_v2_organization_invitations_batch_create_post_with_http_info(create_organization_invitation, **kwargs)  # noqa: E501

    def batch_create_invitations_api_v2_organization_invitations_batch_create_post_with_http_info(self, create_organization_invitation, **kwargs):  # noqa: E501
        """Batch Create Invitations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_create_invitations_api_v2_organization_invitations_batch_create_post_with_http_info(create_organization_invitation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[CreateOrganizationInvitation] create_organization_invitation: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BatchResponseBatchedResultOrganizationInvitationBase, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_organization_invitation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_create_invitations_api_v2_organization_invitations_batch_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_organization_invitation' is set
        if self.api_client.client_side_validation and ('create_organization_invitation' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_organization_invitation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_organization_invitation` when calling `batch_create_invitations_api_v2_organization_invitations_batch_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_organization_invitation' in local_var_params:
            body_params = local_var_params['create_organization_invitation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/batch_create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BatchResponseBatchedResultOrganizationInvitationBase',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batch_create_project_collaborators_api_v2_projects_project_id_collaborators_users_batch_create_post(self, project_id, create_user_project_collaborator, **kwargs):  # noqa: E501
        """Batch Create Project Collaborators  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_create_project_collaborators_api_v2_projects_project_id_collaborators_users_batch_create_post(project_id, create_user_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param list[CreateUserProjectCollaborator] create_user_project_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.batch_create_project_collaborators_api_v2_projects_project_id_collaborators_users_batch_create_post_with_http_info(project_id, create_user_project_collaborator, **kwargs)  # noqa: E501

    def batch_create_project_collaborators_api_v2_projects_project_id_collaborators_users_batch_create_post_with_http_info(self, project_id, create_user_project_collaborator, **kwargs):  # noqa: E501
        """Batch Create Project Collaborators  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_create_project_collaborators_api_v2_projects_project_id_collaborators_users_batch_create_post_with_http_info(project_id, create_user_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param list[CreateUserProjectCollaborator] create_user_project_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'create_user_project_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_create_project_collaborators_api_v2_projects_project_id_collaborators_users_batch_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `batch_create_project_collaborators_api_v2_projects_project_id_collaborators_users_batch_create_post`")  # noqa: E501
        # verify the required parameter 'create_user_project_collaborator' is set
        if self.api_client.client_side_validation and ('create_user_project_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_user_project_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_user_project_collaborator` when calling `batch_create_project_collaborators_api_v2_projects_project_id_collaborators_users_batch_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_user_project_collaborator' in local_var_params:
            body_params = local_var_params['create_user_project_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/users/batch_create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batch_get_job_api_v2_decorated_ha_jobs_batch_get_post(self, request_body, **kwargs):  # noqa: E501
        """Batch Get Job  # noqa: E501

        Batch get HA Jobs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_get_job_api_v2_decorated_ha_jobs_batch_get_post(request_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] request_body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedproductionjobListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.batch_get_job_api_v2_decorated_ha_jobs_batch_get_post_with_http_info(request_body, **kwargs)  # noqa: E501

    def batch_get_job_api_v2_decorated_ha_jobs_batch_get_post_with_http_info(self, request_body, **kwargs):  # noqa: E501
        """Batch Get Job  # noqa: E501

        Batch get HA Jobs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_get_job_api_v2_decorated_ha_jobs_batch_get_post_with_http_info(request_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] request_body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedproductionjobListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_get_job_api_v2_decorated_ha_jobs_batch_get_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_body' is set
        if self.api_client.client_side_validation and ('request_body' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_body` when calling `batch_get_job_api_v2_decorated_ha_jobs_batch_get_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_body' in local_var_params:
            body_params = local_var_params['request_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/batch_get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedproductionjobListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_password_api_v2_users_change_password_post(self, change_password_params, **kwargs):  # noqa: E501
        """Change Password  # noqa: E501

        Changes user's password if they provide their current password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_password_api_v2_users_change_password_post(change_password_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ChangePasswordParams change_password_params: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.change_password_api_v2_users_change_password_post_with_http_info(change_password_params, **kwargs)  # noqa: E501

    def change_password_api_v2_users_change_password_post_with_http_info(self, change_password_params, **kwargs):  # noqa: E501
        """Change Password  # noqa: E501

        Changes user's password if they provide their current password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_password_api_v2_users_change_password_post_with_http_info(change_password_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ChangePasswordParams change_password_params: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'change_password_params'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_password_api_v2_users_change_password_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'change_password_params' is set
        if self.api_client.client_side_validation and ('change_password_params' not in local_var_params or  # noqa: E501
                                                        local_var_params['change_password_params'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `change_password_params` when calling `change_password_api_v2_users_change_password_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_password_params' in local_var_params:
            body_params = local_var_params['change_password_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/change_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get(self, flag_key, **kwargs):  # noqa: E501
        """Check Is Feature Flag On  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get(flag_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str flag_key: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FeatureflagresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get_with_http_info(flag_key, **kwargs)  # noqa: E501

    def check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get_with_http_info(self, flag_key, **kwargs):  # noqa: E501
        """Check Is Feature Flag On  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get_with_http_info(flag_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str flag_key: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FeatureflagresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'flag_key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'flag_key' is set
        if self.api_client.client_side_validation and ('flag_key' not in local_var_params or  # noqa: E501
                                                        local_var_params['flag_key'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `flag_key` when calling `check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'flag_key' in local_var_params and local_var_params['flag_key'] is not None:  # noqa: E501
            query_params.append(('flag_key', local_var_params['flag_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/userinfo/check_is_feature_flag_on', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeatureflagresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_one_time_password_api_v2_users_request_otp_token_otp_get(self, otp, **kwargs):  # noqa: E501
        """Check One Time Password  # noqa: E501

        Check if a one time password is valid. Consume it if valid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_one_time_password_api_v2_users_request_otp_token_otp_get(otp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RequestotpreturnapimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_one_time_password_api_v2_users_request_otp_token_otp_get_with_http_info(otp, **kwargs)  # noqa: E501

    def check_one_time_password_api_v2_users_request_otp_token_otp_get_with_http_info(self, otp, **kwargs):  # noqa: E501
        """Check One Time Password  # noqa: E501

        Check if a one time password is valid. Consume it if valid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_one_time_password_api_v2_users_request_otp_token_otp_get_with_http_info(otp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RequestotpreturnapimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'otp'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_one_time_password_api_v2_users_request_otp_token_otp_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'otp' is set
        if self.api_client.client_side_validation and ('otp' not in local_var_params or  # noqa: E501
                                                        local_var_params['otp'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `otp` when calling `check_one_time_password_api_v2_users_request_otp_token_otp_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'otp' in local_var_params:
            path_params['otp'] = local_var_params['otp']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/request_otp_token/{otp}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RequestotpreturnapimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_permission_api_v2_authorization_check_post(self, permission_check_request, **kwargs):  # noqa: E501
        """Check Permission  # noqa: E501

        Check permissions on a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_permission_api_v2_authorization_check_post(permission_check_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param PermissionCheckRequest permission_check_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PermissioncheckresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_permission_api_v2_authorization_check_post_with_http_info(permission_check_request, **kwargs)  # noqa: E501

    def check_permission_api_v2_authorization_check_post_with_http_info(self, permission_check_request, **kwargs):  # noqa: E501
        """Check Permission  # noqa: E501

        Check permissions on a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_permission_api_v2_authorization_check_post_with_http_info(permission_check_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param PermissionCheckRequest permission_check_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PermissioncheckresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'permission_check_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_permission_api_v2_authorization_check_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'permission_check_request' is set
        if self.api_client.client_side_validation and ('permission_check_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['permission_check_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `permission_check_request` when calling `check_permission_api_v2_authorization_check_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'permission_check_request' in local_var_params:
            body_params = local_var_params['permission_check_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authorization/check', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PermissioncheckresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_waitlist_status_api_v2_aioa_cloud_waitlist_check_status_get(self, **kwargs):  # noqa: E501
        """Check Waitlist Status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_waitlist_status_api_v2_aioa_cloud_waitlist_check_status_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaitliststatusresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_waitlist_status_api_v2_aioa_cloud_waitlist_check_status_get_with_http_info(**kwargs)  # noqa: E501

    def check_waitlist_status_api_v2_aioa_cloud_waitlist_check_status_get_with_http_info(self, **kwargs):  # noqa: E501
        """Check Waitlist Status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_waitlist_status_api_v2_aioa_cloud_waitlist_check_status_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaitliststatusresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_waitlist_status_api_v2_aioa_cloud_waitlist_check_status_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aioa_cloud_waitlist/check_status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaitliststatusresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clean_grafana_dashboards_api_v2_clouds_cloud_id_clean_grafana_dashboards_post(self, cloud_id, **kwargs):  # noqa: E501
        """Clean Grafana Dashboards  # noqa: E501

        Cleans up grafana dashboards that are not associated to running services, jobs, or workspaces.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clean_grafana_dashboards_api_v2_clouds_cloud_id_clean_grafana_dashboards_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool dry_run:
        :param int limit:
        :param int page:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CleanupleakedgrafanadashboardresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.clean_grafana_dashboards_api_v2_clouds_cloud_id_clean_grafana_dashboards_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def clean_grafana_dashboards_api_v2_clouds_cloud_id_clean_grafana_dashboards_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Clean Grafana Dashboards  # noqa: E501

        Cleans up grafana dashboards that are not associated to running services, jobs, or workspaces.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clean_grafana_dashboards_api_v2_clouds_cloud_id_clean_grafana_dashboards_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool dry_run:
        :param int limit:
        :param int page:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CleanupleakedgrafanadashboardresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'dry_run',
            'limit',
            'page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clean_grafana_dashboards_api_v2_clouds_cloud_id_clean_grafana_dashboards_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `clean_grafana_dashboards_api_v2_clouds_cloud_id_clean_grafana_dashboards_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'dry_run' in local_var_params and local_var_params['dry_run'] is not None:  # noqa: E501
            query_params.append(('dry_run', local_var_params['dry_run']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/clean-grafana-dashboards', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CleanupleakedgrafanadashboardresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cli_api_v2_machines_cli_get(self, **kwargs):  # noqa: E501
        """Cli  # noqa: E501

        Redirects to a URL that can be used to download and install the 'anyscalemachine' CLI.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cli_api_v2_machines_cli_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.cli_api_v2_machines_cli_get_with_http_info(**kwargs)  # noqa: E501

    def cli_api_v2_machines_cli_get_with_http_info(self, **kwargs):  # noqa: E501
        """Cli  # noqa: E501

        Redirects to a URL that can be used to download and install the 'anyscalemachine' CLI.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cli_api_v2_machines_cli_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cli_api_v2_machines_cli_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/cli', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clone_workspace_api_v2_experimental_workspaces_from_workspace_post(self, clone_experimental_workspace, **kwargs):  # noqa: E501
        """Clone Workspace  # noqa: E501

        Clone a workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_workspace_api_v2_experimental_workspaces_from_workspace_post(clone_experimental_workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CloneExperimentalWorkspace clone_experimental_workspace: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.clone_workspace_api_v2_experimental_workspaces_from_workspace_post_with_http_info(clone_experimental_workspace, **kwargs)  # noqa: E501

    def clone_workspace_api_v2_experimental_workspaces_from_workspace_post_with_http_info(self, clone_experimental_workspace, **kwargs):  # noqa: E501
        """Clone Workspace  # noqa: E501

        Clone a workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_workspace_api_v2_experimental_workspaces_from_workspace_post_with_http_info(clone_experimental_workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CloneExperimentalWorkspace clone_experimental_workspace: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'clone_experimental_workspace'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clone_workspace_api_v2_experimental_workspaces_from_workspace_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'clone_experimental_workspace' is set
        if self.api_client.client_side_validation and ('clone_experimental_workspace' not in local_var_params or  # noqa: E501
                                                        local_var_params['clone_experimental_workspace'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `clone_experimental_workspace` when calling `clone_workspace_api_v2_experimental_workspaces_from_workspace_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'clone_experimental_workspace' in local_var_params:
            body_params = local_var_params['clone_experimental_workspace']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/from_workspace', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_api_key_api_v2_users_create_api_key_post(self, api_key_parameters, **kwargs):  # noqa: E501
        """Create Api Key  # noqa: E501

        Create an API Key for use outside of a web context.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_api_key_api_v2_users_create_api_key_post(api_key_parameters, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApiKeyParameters api_key_parameters: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ServersessiontokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_api_key_api_v2_users_create_api_key_post_with_http_info(api_key_parameters, **kwargs)  # noqa: E501

    def create_api_key_api_v2_users_create_api_key_post_with_http_info(self, api_key_parameters, **kwargs):  # noqa: E501
        """Create Api Key  # noqa: E501

        Create an API Key for use outside of a web context.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_api_key_api_v2_users_create_api_key_post_with_http_info(api_key_parameters, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApiKeyParameters api_key_parameters: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ServersessiontokenResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'api_key_parameters'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_api_key_api_v2_users_create_api_key_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key_parameters' is set
        if self.api_client.client_side_validation and ('api_key_parameters' not in local_var_params or  # noqa: E501
                                                        local_var_params['api_key_parameters'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_parameters` when calling `create_api_key_api_v2_users_create_api_key_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'api_key_parameters' in local_var_params:
            body_params = local_var_params['api_key_parameters']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/create_api_key', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServersessiontokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_application_template_api_v2_application_templates_post(self, create_app_config, **kwargs):  # noqa: E501
        """Create Application Template  # noqa: E501

        Creates a Cluster Environment. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_template_api_v2_application_templates_post(create_app_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAppConfig create_app_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AppconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_application_template_api_v2_application_templates_post_with_http_info(create_app_config, **kwargs)  # noqa: E501

    def create_application_template_api_v2_application_templates_post_with_http_info(self, create_app_config, **kwargs):  # noqa: E501
        """Create Application Template  # noqa: E501

        Creates a Cluster Environment. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_template_api_v2_application_templates_post_with_http_info(create_app_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAppConfig create_app_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AppconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_app_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_application_template_api_v2_application_templates_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_app_config' is set
        if self.api_client.client_side_validation and ('create_app_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_app_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_app_config` when calling `create_application_template_api_v2_application_templates_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_app_config' in local_var_params:
            body_params = local_var_params['create_app_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bug_report_api_v2_machines_create_bug_report_post(self, body, **kwargs):  # noqa: E501
        """Create Bug Report  # noqa: E501

        Create a machine bug report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bug_report_api_v2_machines_create_bug_report_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param object body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatebugreportresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_bug_report_api_v2_machines_create_bug_report_post_with_http_info(body, **kwargs)  # noqa: E501

    def create_bug_report_api_v2_machines_create_bug_report_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Bug Report  # noqa: E501

        Create a machine bug report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bug_report_api_v2_machines_create_bug_report_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param object body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatebugreportresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bug_report_api_v2_machines_create_bug_report_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_bug_report_api_v2_machines_create_bug_report_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/create_bug_report', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatebugreportresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_build_api_v2_builds_post(self, create_build, **kwargs):  # noqa: E501
        """Create Build  # noqa: E501

        Creates and starts a Build. This is a long running operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_build_api_v2_builds_post(create_build, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBuild create_build: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_build_api_v2_builds_post_with_http_info(create_build, **kwargs)  # noqa: E501

    def create_build_api_v2_builds_post_with_http_info(self, create_build, **kwargs):  # noqa: E501
        """Create Build  # noqa: E501

        Creates and starts a Build. This is a long running operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_build_api_v2_builds_post_with_http_info(create_build, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBuild create_build: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_build'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_build_api_v2_builds_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_build' is set
        if self.api_client.client_side_validation and ('create_build' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_build'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_build` when calling `create_build_api_v2_builds_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_build' in local_var_params:
            body_params = local_var_params['create_build']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_byod_build_api_v2_builds_byod_post(self, create_byod_build, **kwargs):  # noqa: E501
        """Create Byod Build  # noqa: E501

        Creates a BYOD Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_byod_build_api_v2_builds_byod_post(create_byod_build, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBYODBuild create_byod_build: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_byod_build_api_v2_builds_byod_post_with_http_info(create_byod_build, **kwargs)  # noqa: E501

    def create_byod_build_api_v2_builds_byod_post_with_http_info(self, create_byod_build, **kwargs):  # noqa: E501
        """Create Byod Build  # noqa: E501

        Creates a BYOD Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_byod_build_api_v2_builds_byod_post_with_http_info(create_byod_build, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBYODBuild create_byod_build: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_byod_build'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_byod_build_api_v2_builds_byod_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_byod_build' is set
        if self.api_client.client_side_validation and ('create_byod_build' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_byod_build'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_byod_build` when calling `create_byod_build_api_v2_builds_byod_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_byod_build' in local_var_params:
            body_params = local_var_params['create_byod_build']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/byod', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_byod_cluster_environment_api_v2_application_templates_byod_post(self, create_byod_app_config, **kwargs):  # noqa: E501
        """Create Byod Cluster Environment  # noqa: E501

        Creates a BYOD Cluster Environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_byod_cluster_environment_api_v2_application_templates_byod_post(create_byod_app_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBYODAppConfig create_byod_app_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AppconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_byod_cluster_environment_api_v2_application_templates_byod_post_with_http_info(create_byod_app_config, **kwargs)  # noqa: E501

    def create_byod_cluster_environment_api_v2_application_templates_byod_post_with_http_info(self, create_byod_app_config, **kwargs):  # noqa: E501
        """Create Byod Cluster Environment  # noqa: E501

        Creates a BYOD Cluster Environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_byod_cluster_environment_api_v2_application_templates_byod_post_with_http_info(create_byod_app_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBYODAppConfig create_byod_app_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AppconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_byod_app_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_byod_cluster_environment_api_v2_application_templates_byod_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_byod_app_config' is set
        if self.api_client.client_side_validation and ('create_byod_app_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_byod_app_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_byod_app_config` when calling `create_byod_cluster_environment_api_v2_application_templates_byod_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_byod_app_config' in local_var_params:
            body_params = local_var_params['create_byod_app_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/byod', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cloud_api_v2_clouds_post(self, write_cloud, **kwargs):  # noqa: E501
        """Create Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_api_v2_clouds_post(write_cloud, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteCloud write_cloud: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_cloud_api_v2_clouds_post_with_http_info(write_cloud, **kwargs)  # noqa: E501

    def create_cloud_api_v2_clouds_post_with_http_info(self, write_cloud, **kwargs):  # noqa: E501
        """Create Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_api_v2_clouds_post_with_http_info(write_cloud, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteCloud write_cloud: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'write_cloud'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cloud_api_v2_clouds_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'write_cloud' is set
        if self.api_client.client_side_validation and ('write_cloud' not in local_var_params or  # noqa: E501
                                                        local_var_params['write_cloud'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `write_cloud` when calling `create_cloud_api_v2_clouds_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'write_cloud' in local_var_params:
            body_params = local_var_params['write_cloud']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post(self, cloud_id, create_cloud_collaborator, **kwargs):  # noqa: E501
        """Create Cloud Collaborator  # noqa: E501

        Give a user in the same organization as auth context who previously did not have any individual permissions for this cloud the designated permissions.  An error will be raised if the user already has permissions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post(cloud_id, create_cloud_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CreateCloudCollaborator create_cloud_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post_with_http_info(cloud_id, create_cloud_collaborator, **kwargs)  # noqa: E501

    def create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post_with_http_info(self, cloud_id, create_cloud_collaborator, **kwargs):  # noqa: E501
        """Create Cloud Collaborator  # noqa: E501

        Give a user in the same organization as auth context who previously did not have any individual permissions for this cloud the designated permissions.  An error will be raised if the user already has permissions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post_with_http_info(cloud_id, create_cloud_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CreateCloudCollaborator create_cloud_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'create_cloud_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post`")  # noqa: E501
        # verify the required parameter 'create_cloud_collaborator' is set
        if self.api_client.client_side_validation and ('create_cloud_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_cloud_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_cloud_collaborator` when calling `create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_cloud_collaborator' in local_var_params:
            body_params = local_var_params['create_cloud_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/collaborators/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post(self, project_id, **kwargs):  # noqa: E501
        """Create Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post_with_http_info(project_id, **kwargs)  # noqa: E501

    def create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Create Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/cloud', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_compute_template_api_v2_compute_templates_post(self, create_compute_template, **kwargs):  # noqa: E501
        """Create Compute Template  # noqa: E501

        Creates a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_compute_template_api_v2_compute_templates_post(create_compute_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateComputeTemplate create_compute_template: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComputetemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_compute_template_api_v2_compute_templates_post_with_http_info(create_compute_template, **kwargs)  # noqa: E501

    def create_compute_template_api_v2_compute_templates_post_with_http_info(self, create_compute_template, **kwargs):  # noqa: E501
        """Create Compute Template  # noqa: E501

        Creates a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_compute_template_api_v2_compute_templates_post_with_http_info(create_compute_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateComputeTemplate create_compute_template: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComputetemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_compute_template'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_compute_template_api_v2_compute_templates_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_compute_template' is set
        if self.api_client.client_side_validation and ('create_compute_template' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_compute_template'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_compute_template` when calling `create_compute_template_api_v2_compute_templates_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_compute_template' in local_var_params:
            body_params = local_var_params['create_compute_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputetemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_configuration_api_v2_organization_configurations_post(self, create_organization_configuration, **kwargs):  # noqa: E501
        """Create Configuration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_configuration_api_v2_organization_configurations_post(create_organization_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateOrganizationConfiguration create_organization_configuration: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationconfigurationresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_configuration_api_v2_organization_configurations_post_with_http_info(create_organization_configuration, **kwargs)  # noqa: E501

    def create_configuration_api_v2_organization_configurations_post_with_http_info(self, create_organization_configuration, **kwargs):  # noqa: E501
        """Create Configuration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_configuration_api_v2_organization_configurations_post_with_http_info(create_organization_configuration, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateOrganizationConfiguration create_organization_configuration: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationconfigurationresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_organization_configuration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_configuration_api_v2_organization_configurations_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_organization_configuration' is set
        if self.api_client.client_side_validation and ('create_organization_configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_organization_configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_organization_configuration` when calling `create_configuration_api_v2_organization_configurations_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_organization_configuration' in local_var_params:
            body_params = local_var_params['create_organization_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_configurations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationconfigurationresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_configuration_script_api_v2_organization_configurations_create_helper_get(self, customer_billing_type, **kwargs):  # noqa: E501
        """Create Configuration Script  # noqa: E501

        Returns an HTML with javacript that calls the create_configuration API with the provided configuration parameters as query parameters.  It then displays the registration URL and invite code in the HTML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_configuration_script_api_v2_organization_configurations_create_helper_get(customer_billing_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str customer_billing_type: (required)
        :param str invite_code:
        :param datetime expires_at:
        :param str description:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_configuration_script_api_v2_organization_configurations_create_helper_get_with_http_info(customer_billing_type, **kwargs)  # noqa: E501

    def create_configuration_script_api_v2_organization_configurations_create_helper_get_with_http_info(self, customer_billing_type, **kwargs):  # noqa: E501
        """Create Configuration Script  # noqa: E501

        Returns an HTML with javacript that calls the create_configuration API with the provided configuration parameters as query parameters.  It then displays the registration URL and invite code in the HTML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_configuration_script_api_v2_organization_configurations_create_helper_get_with_http_info(customer_billing_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str customer_billing_type: (required)
        :param str invite_code:
        :param datetime expires_at:
        :param str description:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'customer_billing_type',
            'invite_code',
            'expires_at',
            'description'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_configuration_script_api_v2_organization_configurations_create_helper_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'customer_billing_type' is set
        if self.api_client.client_side_validation and ('customer_billing_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['customer_billing_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `customer_billing_type` when calling `create_configuration_script_api_v2_organization_configurations_create_helper_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'customer_billing_type' in local_var_params and local_var_params['customer_billing_type'] is not None:  # noqa: E501
            query_params.append(('customer_billing_type', local_var_params['customer_billing_type']))  # noqa: E501
        if 'invite_code' in local_var_params and local_var_params['invite_code'] is not None:  # noqa: E501
            query_params.append(('invite_code', local_var_params['invite_code']))  # noqa: E501
        if 'expires_at' in local_var_params and local_var_params['expires_at'] is not None:  # noqa: E501
            query_params.append(('expires_at', local_var_params['expires_at']))  # noqa: E501
        if 'description' in local_var_params and local_var_params['description'] is not None:  # noqa: E501
            query_params.append(('description', local_var_params['description']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_configurations/create_helper', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dataset_upload_api_v2_datasets_upload_post(self, create_dataset, **kwargs):  # noqa: E501
        """Create Dataset Upload  # noqa: E501

        Returns an upload object with a short-lived URL that can be used to upload a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dataset_upload_api_v2_datasets_upload_post(create_dataset, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateDataset create_dataset: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetuploadResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_dataset_upload_api_v2_datasets_upload_post_with_http_info(create_dataset, **kwargs)  # noqa: E501

    def create_dataset_upload_api_v2_datasets_upload_post_with_http_info(self, create_dataset, **kwargs):  # noqa: E501
        """Create Dataset Upload  # noqa: E501

        Returns an upload object with a short-lived URL that can be used to upload a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_dataset_upload_api_v2_datasets_upload_post_with_http_info(create_dataset, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateDataset create_dataset: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetuploadResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_dataset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dataset_upload_api_v2_datasets_upload_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_dataset' is set
        if self.api_client.client_side_validation and ('create_dataset' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_dataset'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_dataset` when calling `create_dataset_upload_api_v2_datasets_upload_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_dataset' in local_var_params:
            body_params = local_var_params['create_dataset']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/datasets/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetuploadResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_instance_usage_budget_api_v2_instance_usage_budgets_post(self, create_instance_usage_budget, **kwargs):  # noqa: E501
        """Create Instance Usage Budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_instance_usage_budget_api_v2_instance_usage_budgets_post(create_instance_usage_budget, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateInstanceUsageBudget create_instance_usage_budget: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InstanceusagebudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_instance_usage_budget_api_v2_instance_usage_budgets_post_with_http_info(create_instance_usage_budget, **kwargs)  # noqa: E501

    def create_instance_usage_budget_api_v2_instance_usage_budgets_post_with_http_info(self, create_instance_usage_budget, **kwargs):  # noqa: E501
        """Create Instance Usage Budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_instance_usage_budget_api_v2_instance_usage_budgets_post_with_http_info(create_instance_usage_budget, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateInstanceUsageBudget create_instance_usage_budget: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InstanceusagebudgetResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_instance_usage_budget'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_instance_usage_budget_api_v2_instance_usage_budgets_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_instance_usage_budget' is set
        if self.api_client.client_side_validation and ('create_instance_usage_budget' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_instance_usage_budget'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_instance_usage_budget` when calling `create_instance_usage_budget_api_v2_instance_usage_budgets_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_instance_usage_budget' in local_var_params:
            body_params = local_var_params['create_instance_usage_budget']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/instance_usage_budgets/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceusagebudgetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_invitation_api_v2_organization_invitations_post(self, create_organization_invitation, **kwargs):  # noqa: E501
        """Create Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invitation_api_v2_organization_invitations_post(create_organization_invitation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateOrganizationInvitation create_organization_invitation: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationinvitationbaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_invitation_api_v2_organization_invitations_post_with_http_info(create_organization_invitation, **kwargs)  # noqa: E501

    def create_invitation_api_v2_organization_invitations_post_with_http_info(self, create_organization_invitation, **kwargs):  # noqa: E501
        """Create Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invitation_api_v2_organization_invitations_post_with_http_info(create_organization_invitation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateOrganizationInvitation create_organization_invitation: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationinvitationbaseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_organization_invitation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invitation_api_v2_organization_invitations_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_organization_invitation' is set
        if self.api_client.client_side_validation and ('create_organization_invitation' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_organization_invitation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_organization_invitation` when calling `create_invitation_api_v2_organization_invitations_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_organization_invitation' in local_var_params:
            body_params = local_var_params['create_organization_invitation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationinvitationbaseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_job_api_v2_decorated_ha_jobs_create_post(self, create_internal_production_job, **kwargs):  # noqa: E501
        """Create Job  # noqa: E501

        Create an HA job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_api_v2_decorated_ha_jobs_create_post(create_internal_production_job, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateInternalProductionJob create_internal_production_job: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InternalproductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_job_api_v2_decorated_ha_jobs_create_post_with_http_info(create_internal_production_job, **kwargs)  # noqa: E501

    def create_job_api_v2_decorated_ha_jobs_create_post_with_http_info(self, create_internal_production_job, **kwargs):  # noqa: E501
        """Create Job  # noqa: E501

        Create an HA job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_api_v2_decorated_ha_jobs_create_post_with_http_info(create_internal_production_job, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateInternalProductionJob create_internal_production_job: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InternalproductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_internal_production_job'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_job_api_v2_decorated_ha_jobs_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_internal_production_job' is set
        if self.api_client.client_side_validation and ('create_internal_production_job' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_internal_production_job'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_internal_production_job` when calling `create_job_api_v2_decorated_ha_jobs_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_internal_production_job' in local_var_params:
            body_params = local_var_params['create_internal_production_job']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InternalproductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_job_queue_api_v2_job_queues_create_post(self, create_job_queue_requests, **kwargs):  # noqa: E501
        """Create Job Queue  # noqa: E501

        Create a job queue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_queue_api_v2_job_queues_create_post(create_job_queue_requests, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateJobQueueRequests create_job_queue_requests: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobqueueResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_job_queue_api_v2_job_queues_create_post_with_http_info(create_job_queue_requests, **kwargs)  # noqa: E501

    def create_job_queue_api_v2_job_queues_create_post_with_http_info(self, create_job_queue_requests, **kwargs):  # noqa: E501
        """Create Job Queue  # noqa: E501

        Create a job queue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_queue_api_v2_job_queues_create_post_with_http_info(create_job_queue_requests, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateJobQueueRequests create_job_queue_requests: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobqueueResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_job_queue_requests'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_job_queue_api_v2_job_queues_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_job_queue_requests' is set
        if self.api_client.client_side_validation and ('create_job_queue_requests' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_job_queue_requests'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_job_queue_requests` when calling `create_job_queue_api_v2_job_queues_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_job_queue_requests' in local_var_params:
            body_params = local_var_params['create_job_queue_requests']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/job_queues/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobqueueResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_machine_api_v2_machines_create_post(self, create_machine_request, **kwargs):  # noqa: E501
        """Create Machine  # noqa: E501

        Create a machine to add it to a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_machine_api_v2_machines_create_post(create_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachineRequest create_machine_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatemachineresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_machine_api_v2_machines_create_post_with_http_info(create_machine_request, **kwargs)  # noqa: E501

    def create_machine_api_v2_machines_create_post_with_http_info(self, create_machine_request, **kwargs):  # noqa: E501
        """Create Machine  # noqa: E501

        Create a machine to add it to a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_machine_api_v2_machines_create_post_with_http_info(create_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachineRequest create_machine_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatemachineresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_machine_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_machine_api_v2_machines_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_machine_request' is set
        if self.api_client.client_side_validation and ('create_machine_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_machine_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_machine_request` when calling `create_machine_api_v2_machines_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_machine_request' in local_var_params:
            body_params = local_var_params['create_machine_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatemachineresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_machine_pool_api_v2_machine_pools_create_post(self, create_machine_pool_request, **kwargs):  # noqa: E501
        """Create Machine Pool  # noqa: E501

        Creates a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_machine_pool_api_v2_machine_pools_create_post(create_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachinePoolRequest create_machine_pool_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatemachinepoolresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_machine_pool_api_v2_machine_pools_create_post_with_http_info(create_machine_pool_request, **kwargs)  # noqa: E501

    def create_machine_pool_api_v2_machine_pools_create_post_with_http_info(self, create_machine_pool_request, **kwargs):  # noqa: E501
        """Create Machine Pool  # noqa: E501

        Creates a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_machine_pool_api_v2_machine_pools_create_post_with_http_info(create_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachinePoolRequest create_machine_pool_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatemachinepoolresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_machine_pool_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_machine_pool_api_v2_machine_pools_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_machine_pool_request' is set
        if self.api_client.client_side_validation and ('create_machine_pool_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_machine_pool_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_machine_pool_request` when calling `create_machine_pool_api_v2_machine_pools_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_machine_pool_request' in local_var_params:
            body_params = local_var_params['create_machine_pool_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatemachinepoolresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_one_time_password_api_v2_users_create_otp_token_get(self, **kwargs):  # noqa: E501
        """Create One Time Password  # noqa: E501

        Create a one time password token and return URL  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_one_time_password_api_v2_users_create_otp_token_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int duration_seconds:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreateotpreturnapimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_one_time_password_api_v2_users_create_otp_token_get_with_http_info(**kwargs)  # noqa: E501

    def create_one_time_password_api_v2_users_create_otp_token_get_with_http_info(self, **kwargs):  # noqa: E501
        """Create One Time Password  # noqa: E501

        Create a one time password token and return URL  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_one_time_password_api_v2_users_create_otp_token_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int duration_seconds:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreateotpreturnapimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'duration_seconds'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_one_time_password_api_v2_users_create_otp_token_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'duration_seconds' in local_var_params and local_var_params['duration_seconds'] is not None:  # noqa: E501
            query_params.append(('duration_seconds', local_var_params['duration_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/create_otp_token', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateotpreturnapimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_job_api_v2_experimental_cron_jobs_put(self, create_schedule, **kwargs):  # noqa: E501
        """Create Or Update Job  # noqa: E501

        Create or update a CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_job_api_v2_experimental_cron_jobs_put(create_schedule, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateSchedule create_schedule: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedscheduleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_or_update_job_api_v2_experimental_cron_jobs_put_with_http_info(create_schedule, **kwargs)  # noqa: E501

    def create_or_update_job_api_v2_experimental_cron_jobs_put_with_http_info(self, create_schedule, **kwargs):  # noqa: E501
        """Create Or Update Job  # noqa: E501

        Create or update a CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_job_api_v2_experimental_cron_jobs_put_with_http_info(create_schedule, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateSchedule create_schedule: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedscheduleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_schedule'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_job_api_v2_experimental_cron_jobs_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_schedule' is set
        if self.api_client.client_side_validation and ('create_schedule' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_schedule'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_schedule` when calling `create_or_update_job_api_v2_experimental_cron_jobs_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_schedule' in local_var_params:
            body_params = local_var_params['create_schedule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedscheduleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_metronome_customer_info_api_v2_metronome_customer_info_post(self, metronome_customer_info_model, **kwargs):  # noqa: E501
        """Create Or Update Metronome Customer Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_metronome_customer_info_api_v2_metronome_customer_info_post(metronome_customer_info_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param MetronomeCustomerInfoModel metronome_customer_info_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MetronomecustomerinfomodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_or_update_metronome_customer_info_api_v2_metronome_customer_info_post_with_http_info(metronome_customer_info_model, **kwargs)  # noqa: E501

    def create_or_update_metronome_customer_info_api_v2_metronome_customer_info_post_with_http_info(self, metronome_customer_info_model, **kwargs):  # noqa: E501
        """Create Or Update Metronome Customer Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_metronome_customer_info_api_v2_metronome_customer_info_post_with_http_info(metronome_customer_info_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param MetronomeCustomerInfoModel metronome_customer_info_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MetronomecustomerinfomodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'metronome_customer_info_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_metronome_customer_info_api_v2_metronome_customer_info_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'metronome_customer_info_model' is set
        if self.api_client.client_side_validation and ('metronome_customer_info_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['metronome_customer_info_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `metronome_customer_info_model` when calling `create_or_update_metronome_customer_info_api_v2_metronome_customer_info_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'metronome_customer_info_model' in local_var_params:
            body_params = local_var_params['metronome_customer_info_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/metronome_customer_info/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetronomecustomerinfomodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project_api_v2_projects_post(self, write_project, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_api_v2_projects_post(write_project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteProject write_project: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectbaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_project_api_v2_projects_post_with_http_info(write_project, **kwargs)  # noqa: E501

    def create_project_api_v2_projects_post_with_http_info(self, write_project, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_api_v2_projects_post_with_http_info(write_project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteProject write_project: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectbaseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'write_project'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_api_v2_projects_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'write_project' is set
        if self.api_client.client_side_validation and ('write_project' not in local_var_params or  # noqa: E501
                                                        local_var_params['write_project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `write_project` when calling `create_project_api_v2_projects_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'write_project' in local_var_params:
            body_params = local_var_params['write_project']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectbaseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project_collaborator_api_v2_projects_project_id_collaborators_users_post(self, project_id, create_user_project_collaborator, **kwargs):  # noqa: E501
        """Create Project Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_collaborator_api_v2_projects_project_id_collaborators_users_post(project_id, create_user_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param CreateUserProjectCollaborator create_user_project_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_project_collaborator_api_v2_projects_project_id_collaborators_users_post_with_http_info(project_id, create_user_project_collaborator, **kwargs)  # noqa: E501

    def create_project_collaborator_api_v2_projects_project_id_collaborators_users_post_with_http_info(self, project_id, create_user_project_collaborator, **kwargs):  # noqa: E501
        """Create Project Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_collaborator_api_v2_projects_project_id_collaborators_users_post_with_http_info(project_id, create_user_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param CreateUserProjectCollaborator create_user_project_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'create_user_project_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_collaborator_api_v2_projects_project_id_collaborators_users_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `create_project_collaborator_api_v2_projects_project_id_collaborators_users_post`")  # noqa: E501
        # verify the required parameter 'create_user_project_collaborator' is set
        if self.api_client.client_side_validation and ('create_user_project_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_user_project_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_user_project_collaborator` when calling `create_project_collaborator_api_v2_projects_project_id_collaborators_users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_user_project_collaborator' in local_var_params:
            body_params = local_var_params['create_user_project_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_resource_notification_api_v2_resource_notifications_post(self, create_resource_notification, **kwargs):  # noqa: E501
        """Create Resource Notification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_resource_notification_api_v2_resource_notifications_post(create_resource_notification, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateResourceNotification create_resource_notification: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcenotificationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_resource_notification_api_v2_resource_notifications_post_with_http_info(create_resource_notification, **kwargs)  # noqa: E501

    def create_resource_notification_api_v2_resource_notifications_post_with_http_info(self, create_resource_notification, **kwargs):  # noqa: E501
        """Create Resource Notification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_resource_notification_api_v2_resource_notifications_post_with_http_info(create_resource_notification, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateResourceNotification create_resource_notification: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcenotificationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_resource_notification'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_resource_notification_api_v2_resource_notifications_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_resource_notification' is set
        if self.api_client.client_side_validation and ('create_resource_notification' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_resource_notification'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_resource_notification` when calling `create_resource_notification_api_v2_resource_notifications_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_resource_notification' in local_var_params:
            body_params = local_var_params['create_resource_notification']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_notifications/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcenotificationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_resource_quota_api_v2_resource_quotas_post(self, create_resource_quota, **kwargs):  # noqa: E501
        """Create Resource Quota  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_resource_quota_api_v2_resource_quotas_post(create_resource_quota, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateResourceQuota create_resource_quota: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcequotaResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_resource_quota_api_v2_resource_quotas_post_with_http_info(create_resource_quota, **kwargs)  # noqa: E501

    def create_resource_quota_api_v2_resource_quotas_post_with_http_info(self, create_resource_quota, **kwargs):  # noqa: E501
        """Create Resource Quota  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_resource_quota_api_v2_resource_quotas_post_with_http_info(create_resource_quota, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateResourceQuota create_resource_quota: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcequotaResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_resource_quota'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_resource_quota_api_v2_resource_quotas_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_resource_quota' is set
        if self.api_client.client_side_validation and ('create_resource_quota' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_resource_quota'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_resource_quota` when calling `create_resource_quota_api_v2_resource_quotas_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_resource_quota' in local_var_params:
            body_params = local_var_params['create_resource_quota']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_quotas/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcequotaResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_service_account_api_v2_users_service_accounts_post(self, name, **kwargs):  # noqa: E501
        """Create Service Account  # noqa: E501

        Create a service account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_service_account_api_v2_users_service_accounts_post(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaleserviceaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_service_account_api_v2_users_service_accounts_post_with_http_info(name, **kwargs)  # noqa: E501

    def create_service_account_api_v2_users_service_accounts_post_with_http_info(self, name, **kwargs):  # noqa: E501
        """Create Service Account  # noqa: E501

        Create a service account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_service_account_api_v2_users_service_accounts_post_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaleserviceaccountResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_service_account_api_v2_users_service_accounts_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in local_var_params or  # noqa: E501
                                                        local_var_params['name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `create_service_account_api_v2_users_service_accounts_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/service_accounts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaleserviceaccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_session_command_api_v2_sessions_session_id_create_session_command_post(self, session_id, external_terminal_command, **kwargs):  # noqa: E501
        """Create Session Command  # noqa: E501

        Create a shell command entry. This command was executed by external source such as the webterminal  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_session_command_api_v2_sessions_session_id_create_session_command_post(session_id, external_terminal_command, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExternalTerminalCommand external_terminal_command: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessioncommandidResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_session_command_api_v2_sessions_session_id_create_session_command_post_with_http_info(session_id, external_terminal_command, **kwargs)  # noqa: E501

    def create_session_command_api_v2_sessions_session_id_create_session_command_post_with_http_info(self, session_id, external_terminal_command, **kwargs):  # noqa: E501
        """Create Session Command  # noqa: E501

        Create a shell command entry. This command was executed by external source such as the webterminal  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_session_command_api_v2_sessions_session_id_create_session_command_post_with_http_info(session_id, external_terminal_command, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExternalTerminalCommand external_terminal_command: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessioncommandidResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'external_terminal_command'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_session_command_api_v2_sessions_session_id_create_session_command_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `create_session_command_api_v2_sessions_session_id_create_session_command_post`")  # noqa: E501
        # verify the required parameter 'external_terminal_command' is set
        if self.api_client.client_side_validation and ('external_terminal_command' not in local_var_params or  # noqa: E501
                                                        local_var_params['external_terminal_command'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `external_terminal_command` when calling `create_session_command_api_v2_sessions_session_id_create_session_command_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'external_terminal_command' in local_var_params:
            body_params = local_var_params['external_terminal_command']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/create_session_command', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessioncommandidResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_template_api_v2_workspace_templates_post(self, create_workspace_template, **kwargs):  # noqa: E501
        """Create Template  # noqa: E501

        Create a new workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_template_api_v2_workspace_templates_post(create_workspace_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateWorkspaceTemplate create_workspace_template: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_template_api_v2_workspace_templates_post_with_http_info(create_workspace_template, **kwargs)  # noqa: E501

    def create_template_api_v2_workspace_templates_post_with_http_info(self, create_workspace_template, **kwargs):  # noqa: E501
        """Create Template  # noqa: E501

        Create a new workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_template_api_v2_workspace_templates_post_with_http_info(create_workspace_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateWorkspaceTemplate create_workspace_template: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_workspace_template'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_template_api_v2_workspace_templates_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_workspace_template' is set
        if self.api_client.client_side_validation and ('create_workspace_template' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_workspace_template'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_workspace_template` when calling `create_template_api_v2_workspace_templates_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_workspace_template' in local_var_params:
            body_params = local_var_params['create_workspace_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_version_api_v2_workspace_templates_template_id_versions_post(self, template_id, create_workspace_template_version, **kwargs):  # noqa: E501
        """Create Version  # noqa: E501

        Create a new version for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_version_api_v2_workspace_templates_template_id_versions_post(template_id, create_workspace_template_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param CreateWorkspaceTemplateVersion create_workspace_template_version: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_version_api_v2_workspace_templates_template_id_versions_post_with_http_info(template_id, create_workspace_template_version, **kwargs)  # noqa: E501

    def create_version_api_v2_workspace_templates_template_id_versions_post_with_http_info(self, template_id, create_workspace_template_version, **kwargs):  # noqa: E501
        """Create Version  # noqa: E501

        Create a new version for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_version_api_v2_workspace_templates_template_id_versions_post_with_http_info(template_id, create_workspace_template_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param CreateWorkspaceTemplateVersion create_workspace_template_version: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id',
            'create_workspace_template_version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_version_api_v2_workspace_templates_template_id_versions_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `create_version_api_v2_workspace_templates_template_id_versions_post`")  # noqa: E501
        # verify the required parameter 'create_workspace_template_version' is set
        if self.api_client.client_side_validation and ('create_workspace_template_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_workspace_template_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_workspace_template_version` when calling `create_version_api_v2_workspace_templates_template_id_versions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_workspace_template_version' in local_var_params:
            body_params = local_var_params['create_workspace_template_version']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/{template_id}/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_workspace_api_v2_experimental_workspaces_post(self, create_experimental_workspace, **kwargs):  # noqa: E501
        """Create Workspace  # noqa: E501

        Creates a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_api_v2_experimental_workspaces_post(create_experimental_workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateExperimentalWorkspace create_experimental_workspace: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_workspace_api_v2_experimental_workspaces_post_with_http_info(create_experimental_workspace, **kwargs)  # noqa: E501

    def create_workspace_api_v2_experimental_workspaces_post_with_http_info(self, create_experimental_workspace, **kwargs):  # noqa: E501
        """Create Workspace  # noqa: E501

        Creates a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_api_v2_experimental_workspaces_post_with_http_info(create_experimental_workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateExperimentalWorkspace create_experimental_workspace: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_experimental_workspace'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workspace_api_v2_experimental_workspaces_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_experimental_workspace' is set
        if self.api_client.client_side_validation and ('create_experimental_workspace' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_experimental_workspace'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_experimental_workspace` when calling `create_workspace_api_v2_experimental_workspaces_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_experimental_workspace' in local_var_params:
            body_params = local_var_params['create_experimental_workspace']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_workspace_from_template_api_v2_experimental_workspaces_from_template_post(self, create_workspace_from_template, **kwargs):  # noqa: E501
        """Create Workspace From Template  # noqa: E501

        Create workspace from template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_from_template_api_v2_experimental_workspaces_from_template_post(create_workspace_from_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateWorkspaceFromTemplate create_workspace_from_template: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_workspace_from_template_api_v2_experimental_workspaces_from_template_post_with_http_info(create_workspace_from_template, **kwargs)  # noqa: E501

    def create_workspace_from_template_api_v2_experimental_workspaces_from_template_post_with_http_info(self, create_workspace_from_template, **kwargs):  # noqa: E501
        """Create Workspace From Template  # noqa: E501

        Create workspace from template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_from_template_api_v2_experimental_workspaces_from_template_post_with_http_info(create_workspace_from_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateWorkspaceFromTemplate create_workspace_from_template: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_workspace_from_template'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workspace_from_template_api_v2_experimental_workspaces_from_template_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_workspace_from_template' is set
        if self.api_client.client_side_validation and ('create_workspace_from_template' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_workspace_from_template'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_workspace_from_template` when calling `create_workspace_from_template_api_v2_experimental_workspaces_from_template_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_workspace_from_template' in local_var_params:
            body_params = local_var_params['create_workspace_from_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/from_template', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cloud_api_v2_clouds_cloud_id_delete(self, cloud_id, **kwargs):  # noqa: E501
        """Delete Cloud  # noqa: E501

        Deletes a Cloud. Will delete all clusters that are using this cloud. If the cloud has a system cluster, it will be terminated before the cloud is deleted.If any of those clusters are not terminated, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cloud_api_v2_clouds_cloud_id_delete(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_cloud_api_v2_clouds_cloud_id_delete_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def delete_cloud_api_v2_clouds_cloud_id_delete_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Delete Cloud  # noqa: E501

        Deletes a Cloud. Will delete all clusters that are using this cloud. If the cloud has a system cluster, it will be terminated before the cloud is deleted.If any of those clusters are not terminated, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cloud_api_v2_clouds_cloud_id_delete_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cloud_api_v2_clouds_cloud_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `delete_cloud_api_v2_clouds_cloud_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete(self, cloud_id, identity_id, **kwargs):  # noqa: E501
        """Delete Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete(cloud_id, identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str identity_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete_with_http_info(cloud_id, identity_id, **kwargs)  # noqa: E501

    def delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete_with_http_info(self, cloud_id, identity_id, **kwargs):  # noqa: E501
        """Delete Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete_with_http_info(cloud_id, identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str identity_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'identity_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete`")  # noqa: E501
        # verify the required parameter 'identity_id' is set
        if self.api_client.client_side_validation and ('identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identity_id` when calling `delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501
        if 'identity_id' in local_var_params:
            path_params['identity_id'] = local_var_params['identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/collaborators/{identity_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_databricks_connection_api_v2_integrations_connections_databricks_connection_id_delete(self, connection_id, **kwargs):  # noqa: E501
        """Delete Databricks Connection  # noqa: E501

        Delete a Databricks connection by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_databricks_connection_api_v2_integrations_connections_databricks_connection_id_delete(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatabricksconnectionresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_databricks_connection_api_v2_integrations_connections_databricks_connection_id_delete_with_http_info(connection_id, **kwargs)  # noqa: E501

    def delete_databricks_connection_api_v2_integrations_connections_databricks_connection_id_delete_with_http_info(self, connection_id, **kwargs):  # noqa: E501
        """Delete Databricks Connection  # noqa: E501

        Delete a Databricks connection by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_databricks_connection_api_v2_integrations_connections_databricks_connection_id_delete_with_http_info(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatabricksconnectionresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connection_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_databricks_connection_api_v2_integrations_connections_databricks_connection_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and ('connection_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connection_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `delete_databricks_connection_api_v2_integrations_connections_databricks_connection_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connection_id'] = local_var_params['connection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/connections/databricks/{connection_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatabricksconnectionresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete(self, cloud_id, **kwargs):  # noqa: E501
        """Delete Hosted Cloud  # noqa: E501

        Deletes a hosted cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Delete Hosted Cloud  # noqa: E501

        Deletes a hosted cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/hosted/{cloud_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_delete(self, instance_usage_budget_id, **kwargs):  # noqa: E501
        """Delete Instance Usage Budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_delete(instance_usage_budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str instance_usage_budget_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_delete_with_http_info(instance_usage_budget_id, **kwargs)  # noqa: E501

    def delete_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_delete_with_http_info(self, instance_usage_budget_id, **kwargs):  # noqa: E501
        """Delete Instance Usage Budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_delete_with_http_info(instance_usage_budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str instance_usage_budget_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'instance_usage_budget_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'instance_usage_budget_id' is set
        if self.api_client.client_side_validation and ('instance_usage_budget_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['instance_usage_budget_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `instance_usage_budget_id` when calling `delete_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_usage_budget_id' in local_var_params:
            path_params['instance_usage_budget_id'] = local_var_params['instance_usage_budget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/instance_usage_budgets/{instance_usage_budget_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_machine_api_v2_machines_delete_post(self, delete_machine_request, **kwargs):  # noqa: E501
        """Delete Machine  # noqa: E501

        Delete a machine from a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_machine_api_v2_machines_delete_post(delete_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteMachineRequest delete_machine_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatemachineresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_machine_api_v2_machines_delete_post_with_http_info(delete_machine_request, **kwargs)  # noqa: E501

    def delete_machine_api_v2_machines_delete_post_with_http_info(self, delete_machine_request, **kwargs):  # noqa: E501
        """Delete Machine  # noqa: E501

        Delete a machine from a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_machine_api_v2_machines_delete_post_with_http_info(delete_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteMachineRequest delete_machine_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatemachineresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'delete_machine_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_machine_api_v2_machines_delete_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'delete_machine_request' is set
        if self.api_client.client_side_validation and ('delete_machine_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['delete_machine_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `delete_machine_request` when calling `delete_machine_api_v2_machines_delete_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_machine_request' in local_var_params:
            body_params = local_var_params['delete_machine_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatemachineresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_machine_pool_api_v2_machine_pools_delete_post(self, delete_machine_pool_request, **kwargs):  # noqa: E501
        """Delete Machine Pool  # noqa: E501

        Deletes a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_machine_pool_api_v2_machine_pools_delete_post(delete_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteMachinePoolRequest delete_machine_pool_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeletemachinepoolresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_machine_pool_api_v2_machine_pools_delete_post_with_http_info(delete_machine_pool_request, **kwargs)  # noqa: E501

    def delete_machine_pool_api_v2_machine_pools_delete_post_with_http_info(self, delete_machine_pool_request, **kwargs):  # noqa: E501
        """Delete Machine Pool  # noqa: E501

        Deletes a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_machine_pool_api_v2_machine_pools_delete_post_with_http_info(delete_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteMachinePoolRequest delete_machine_pool_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeletemachinepoolresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'delete_machine_pool_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_machine_pool_api_v2_machine_pools_delete_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'delete_machine_pool_request' is set
        if self.api_client.client_side_validation and ('delete_machine_pool_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['delete_machine_pool_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `delete_machine_pool_request` when calling `delete_machine_pool_api_v2_machine_pools_delete_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_machine_pool_request' in local_var_params:
            body_params = local_var_params['delete_machine_pool_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletemachinepoolresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_api_v2_llm_models_model_id_delete(self, model_id, **kwargs):  # noqa: E501
        """Delete Model  # noqa: E501

        Deletes a model from the model registry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_api_v2_llm_models_model_id_delete(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeletedplatformfinetunedmodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_model_api_v2_llm_models_model_id_delete_with_http_info(model_id, **kwargs)  # noqa: E501

    def delete_model_api_v2_llm_models_model_id_delete_with_http_info(self, model_id, **kwargs):  # noqa: E501
        """Delete Model  # noqa: E501

        Deletes a model from the model registry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_api_v2_llm_models_model_id_delete_with_http_info(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeletedplatformfinetunedmodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'model_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_api_v2_llm_models_model_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_id' is set
        if self.api_client.client_side_validation and ('model_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['model_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_id` when calling `delete_model_api_v2_llm_models_model_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in local_var_params:
            path_params['model_id'] = local_var_params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/llm/models/{model_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedplatformfinetunedmodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_project_api_v2_projects_project_id_delete(self, project_id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_api_v2_projects_project_id_delete(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_project_api_v2_projects_project_id_delete_with_http_info(project_id, **kwargs)  # noqa: E501

    def delete_project_api_v2_projects_project_id_delete_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_api_v2_projects_project_id_delete_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project_api_v2_projects_project_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `delete_project_api_v2_projects_project_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete(self, project_id, role_or_identity_id, **kwargs):  # noqa: E501
        """Delete Project Collaborator  # noqa: E501

        Delete a collaborator from a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete(project_id, role_or_identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str role_or_identity_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete_with_http_info(project_id, role_or_identity_id, **kwargs)  # noqa: E501

    def delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete_with_http_info(self, project_id, role_or_identity_id, **kwargs):  # noqa: E501
        """Delete Project Collaborator  # noqa: E501

        Delete a collaborator from a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete_with_http_info(project_id, role_or_identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str role_or_identity_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'role_or_identity_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete`")  # noqa: E501
        # verify the required parameter 'role_or_identity_id' is set
        if self.api_client.client_side_validation and ('role_or_identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_or_identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_or_identity_id` when calling `delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501
        if 'role_or_identity_id' in local_var_params:
            path_params['role_or_identity_id'] = local_var_params['role_or_identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/{role_or_identity_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_notification_api_v2_resource_notifications_resource_notification_id_delete(self, resource_notification_id, **kwargs):  # noqa: E501
        """Delete Resource Notification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_notification_api_v2_resource_notifications_resource_notification_id_delete(resource_notification_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_notification_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_resource_notification_api_v2_resource_notifications_resource_notification_id_delete_with_http_info(resource_notification_id, **kwargs)  # noqa: E501

    def delete_resource_notification_api_v2_resource_notifications_resource_notification_id_delete_with_http_info(self, resource_notification_id, **kwargs):  # noqa: E501
        """Delete Resource Notification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_notification_api_v2_resource_notifications_resource_notification_id_delete_with_http_info(resource_notification_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_notification_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_notification_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_notification_api_v2_resource_notifications_resource_notification_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_notification_id' is set
        if self.api_client.client_side_validation and ('resource_notification_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_notification_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_notification_id` when calling `delete_resource_notification_api_v2_resource_notifications_resource_notification_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_notification_id' in local_var_params:
            path_params['resource_notification_id'] = local_var_params['resource_notification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_notifications/{resource_notification_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_quota_api_v2_resource_quotas_resource_quota_id_delete(self, resource_quota_id, **kwargs):  # noqa: E501
        """Delete Resource Quota  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_quota_api_v2_resource_quotas_resource_quota_id_delete(resource_quota_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_quota_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_resource_quota_api_v2_resource_quotas_resource_quota_id_delete_with_http_info(resource_quota_id, **kwargs)  # noqa: E501

    def delete_resource_quota_api_v2_resource_quotas_resource_quota_id_delete_with_http_info(self, resource_quota_id, **kwargs):  # noqa: E501
        """Delete Resource Quota  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_quota_api_v2_resource_quotas_resource_quota_id_delete_with_http_info(resource_quota_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_quota_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_quota_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_quota_api_v2_resource_quotas_resource_quota_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_quota_id' is set
        if self.api_client.client_side_validation and ('resource_quota_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_quota_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_quota_id` when calling `delete_resource_quota_api_v2_resource_quotas_resource_quota_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_quota_id' in local_var_params:
            path_params['resource_quota_id'] = local_var_params['resource_quota_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_quotas/{resource_quota_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_tags_api_v2_tags_resource_delete(self, delete_resource_tags_request, **kwargs):  # noqa: E501
        """Delete Resource Tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_tags_api_v2_tags_resource_delete(delete_resource_tags_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteResourceTagsRequest delete_resource_tags_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeletedcountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_resource_tags_api_v2_tags_resource_delete_with_http_info(delete_resource_tags_request, **kwargs)  # noqa: E501

    def delete_resource_tags_api_v2_tags_resource_delete_with_http_info(self, delete_resource_tags_request, **kwargs):  # noqa: E501
        """Delete Resource Tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_tags_api_v2_tags_resource_delete_with_http_info(delete_resource_tags_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteResourceTagsRequest delete_resource_tags_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeletedcountResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'delete_resource_tags_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_tags_api_v2_tags_resource_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'delete_resource_tags_request' is set
        if self.api_client.client_side_validation and ('delete_resource_tags_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['delete_resource_tags_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `delete_resource_tags_request` when calling `delete_resource_tags_api_v2_tags_resource_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_resource_tags_request' in local_var_params:
            body_params = local_var_params['delete_resource_tags_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tags/resource', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedcountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_api_v2_services_v2_service_id_delete(self, service_id, **kwargs):  # noqa: E501
        """Delete Service  # noqa: E501

        Deletes a Service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_api_v2_services_v2_service_id_delete(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_service_api_v2_services_v2_service_id_delete_with_http_info(service_id, **kwargs)  # noqa: E501

    def delete_service_api_v2_services_v2_service_id_delete_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Delete Service  # noqa: E501

        Deletes a Service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_service_api_v2_services_v2_service_id_delete_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_api_v2_services_v2_service_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `delete_service_api_v2_services_v2_service_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_template_api_v2_workspace_templates_template_id_delete(self, template_id, **kwargs):  # noqa: E501
        """Delete Template  # noqa: E501

        Delete a workspace template and all its versions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_template_api_v2_workspace_templates_template_id_delete(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: ID of the template to delete (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_template_api_v2_workspace_templates_template_id_delete_with_http_info(template_id, **kwargs)  # noqa: E501

    def delete_template_api_v2_workspace_templates_template_id_delete_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Delete Template  # noqa: E501

        Delete a workspace template and all its versions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_template_api_v2_workspace_templates_template_id_delete_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: ID of the template to delete (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_template_api_v2_workspace_templates_template_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `delete_template_api_v2_workspace_templates_template_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/{template_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_workspace_api_v2_experimental_workspaces_workspace_id_delete(self, workspace_id, **kwargs):  # noqa: E501
        """Delete Workspace  # noqa: E501

        Deletes a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_workspace_api_v2_experimental_workspaces_workspace_id_delete(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to delete. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_workspace_api_v2_experimental_workspaces_workspace_id_delete_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def delete_workspace_api_v2_experimental_workspaces_workspace_id_delete_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Delete Workspace  # noqa: E501

        Deletes a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_workspace_api_v2_experimental_workspaces_workspace_id_delete_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to delete. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workspace_api_v2_experimental_workspaces_workspace_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `delete_workspace_api_v2_experimental_workspaces_workspace_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def describe_machine_pool_api_v2_machine_pools_describe_post(self, describe_machine_pool_request, **kwargs):  # noqa: E501
        """Describe Machine Pool  # noqa: E501

        Describe the current state of a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_machine_pool_api_v2_machine_pools_describe_post(describe_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DescribeMachinePoolRequest describe_machine_pool_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DescribemachinepoolresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.describe_machine_pool_api_v2_machine_pools_describe_post_with_http_info(describe_machine_pool_request, **kwargs)  # noqa: E501

    def describe_machine_pool_api_v2_machine_pools_describe_post_with_http_info(self, describe_machine_pool_request, **kwargs):  # noqa: E501
        """Describe Machine Pool  # noqa: E501

        Describe the current state of a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_machine_pool_api_v2_machine_pools_describe_post_with_http_info(describe_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DescribeMachinePoolRequest describe_machine_pool_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DescribemachinepoolresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'describe_machine_pool_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method describe_machine_pool_api_v2_machine_pools_describe_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'describe_machine_pool_request' is set
        if self.api_client.client_side_validation and ('describe_machine_pool_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['describe_machine_pool_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `describe_machine_pool_request` when calling `describe_machine_pool_api_v2_machine_pools_describe_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'describe_machine_pool_request' in local_var_params:
            body_params = local_var_params['describe_machine_pool_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/describe', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DescribemachinepoolresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post(self, describe_machine_pool_machines_request, **kwargs):  # noqa: E501
        """Describe Machine Pool Machines  # noqa: E501

        Describe the current state of the machines in a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post(describe_machine_pool_machines_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DescribeMachinePoolMachinesRequest describe_machine_pool_machines_request: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MachinestateinfoListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post_with_http_info(describe_machine_pool_machines_request, **kwargs)  # noqa: E501

    def describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post_with_http_info(self, describe_machine_pool_machines_request, **kwargs):  # noqa: E501
        """Describe Machine Pool Machines  # noqa: E501

        Describe the current state of the machines in a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post_with_http_info(describe_machine_pool_machines_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DescribeMachinePoolMachinesRequest describe_machine_pool_machines_request: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MachinestateinfoListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'describe_machine_pool_machines_request',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'describe_machine_pool_machines_request' is set
        if self.api_client.client_side_validation and ('describe_machine_pool_machines_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['describe_machine_pool_machines_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `describe_machine_pool_machines_request` when calling `describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `describe_machine_pool_machines_api_v2_machine_pools_describe_machines_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'describe_machine_pool_machines_request' in local_var_params:
            body_params = local_var_params['describe_machine_pool_machines_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/describe_machines', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MachinestateinfoListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post(self, describe_machine_pool_requests_request, **kwargs):  # noqa: E501
        """Describe Machine Pool Requests  # noqa: E501

        Describe the current state of the requests in a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post(describe_machine_pool_requests_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DescribeMachinePoolRequestsRequest describe_machine_pool_requests_request: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RequeststateinfoListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post_with_http_info(describe_machine_pool_requests_request, **kwargs)  # noqa: E501

    def describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post_with_http_info(self, describe_machine_pool_requests_request, **kwargs):  # noqa: E501
        """Describe Machine Pool Requests  # noqa: E501

        Describe the current state of the requests in a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post_with_http_info(describe_machine_pool_requests_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DescribeMachinePoolRequestsRequest describe_machine_pool_requests_request: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RequeststateinfoListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'describe_machine_pool_requests_request',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'describe_machine_pool_requests_request' is set
        if self.api_client.client_side_validation and ('describe_machine_pool_requests_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['describe_machine_pool_requests_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `describe_machine_pool_requests_request` when calling `describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `describe_machine_pool_requests_api_v2_machine_pools_describe_requests_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'describe_machine_pool_requests_request' in local_var_params:
            body_params = local_var_params['describe_machine_pool_requests_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/describe_requests', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RequeststateinfoListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post(self, describe_machine_pool_workloads_request, **kwargs):  # noqa: E501
        """Describe Machine Pool Workloads  # noqa: E501

        Describe the currently allocated workloads in a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post(describe_machine_pool_workloads_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DescribeMachinePoolWorkloadsRequest describe_machine_pool_workloads_request: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkloadstateinfoListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post_with_http_info(describe_machine_pool_workloads_request, **kwargs)  # noqa: E501

    def describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post_with_http_info(self, describe_machine_pool_workloads_request, **kwargs):  # noqa: E501
        """Describe Machine Pool Workloads  # noqa: E501

        Describe the currently allocated workloads in a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post_with_http_info(describe_machine_pool_workloads_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DescribeMachinePoolWorkloadsRequest describe_machine_pool_workloads_request: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkloadstateinfoListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'describe_machine_pool_workloads_request',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'describe_machine_pool_workloads_request' is set
        if self.api_client.client_side_validation and ('describe_machine_pool_workloads_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['describe_machine_pool_workloads_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `describe_machine_pool_workloads_request` when calling `describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `describe_machine_pool_workloads_api_v2_machine_pools_describe_workloads_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'describe_machine_pool_workloads_request' in local_var_params:
            body_params = local_var_params['describe_machine_pool_workloads_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/describe_workloads', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkloadstateinfoListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def describe_system_workload_api_v2_system_workload_cloud_id_describe_post(self, cloud_id, workload_name, **kwargs):  # noqa: E501
        """Describe System Workload  # noqa: E501

        Get details of system workload cluster and optionally start cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_system_workload_api_v2_system_workload_cloud_id_describe_post(cloud_id, workload_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param SystemWorkloadName workload_name: (required)
        :param str cloud_resource_id:
        :param bool start_cluster:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DescribesystemworkloadresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.describe_system_workload_api_v2_system_workload_cloud_id_describe_post_with_http_info(cloud_id, workload_name, **kwargs)  # noqa: E501

    def describe_system_workload_api_v2_system_workload_cloud_id_describe_post_with_http_info(self, cloud_id, workload_name, **kwargs):  # noqa: E501
        """Describe System Workload  # noqa: E501

        Get details of system workload cluster and optionally start cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_system_workload_api_v2_system_workload_cloud_id_describe_post_with_http_info(cloud_id, workload_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param SystemWorkloadName workload_name: (required)
        :param str cloud_resource_id:
        :param bool start_cluster:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DescribesystemworkloadresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'workload_name',
            'cloud_resource_id',
            'start_cluster'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method describe_system_workload_api_v2_system_workload_cloud_id_describe_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `describe_system_workload_api_v2_system_workload_cloud_id_describe_post`")  # noqa: E501
        # verify the required parameter 'workload_name' is set
        if self.api_client.client_side_validation and ('workload_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['workload_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workload_name` when calling `describe_system_workload_api_v2_system_workload_cloud_id_describe_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'workload_name' in local_var_params and local_var_params['workload_name'] is not None:  # noqa: E501
            query_params.append(('workload_name', local_var_params['workload_name']))  # noqa: E501
        if 'cloud_resource_id' in local_var_params and local_var_params['cloud_resource_id'] is not None:  # noqa: E501
            query_params.append(('cloud_resource_id', local_var_params['cloud_resource_id']))  # noqa: E501
        if 'start_cluster' in local_var_params and local_var_params['start_cluster'] is not None:  # noqa: E501
            query_params.append(('start_cluster', local_var_params['start_cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/system_workload/{cloud_id}/describe', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DescribesystemworkloadresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post(self, detach_machine_pool_from_cloud_request, **kwargs):  # noqa: E501
        """Detach Machine Pool From Cloud  # noqa: E501

        Detach a machine pool from a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post(detach_machine_pool_from_cloud_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DetachMachinePoolFromCloudRequest detach_machine_pool_from_cloud_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DetachmachinepoolfromcloudresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post_with_http_info(detach_machine_pool_from_cloud_request, **kwargs)  # noqa: E501

    def detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post_with_http_info(self, detach_machine_pool_from_cloud_request, **kwargs):  # noqa: E501
        """Detach Machine Pool From Cloud  # noqa: E501

        Detach a machine pool from a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post_with_http_info(detach_machine_pool_from_cloud_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DetachMachinePoolFromCloudRequest detach_machine_pool_from_cloud_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DetachmachinepoolfromcloudresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'detach_machine_pool_from_cloud_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'detach_machine_pool_from_cloud_request' is set
        if self.api_client.client_side_validation and ('detach_machine_pool_from_cloud_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['detach_machine_pool_from_cloud_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `detach_machine_pool_from_cloud_request` when calling `detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'detach_machine_pool_from_cloud_request' in local_var_params:
            body_params = local_var_params['detach_machine_pool_from_cloud_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/detach', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DetachmachinepoolfromcloudresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_auto_add_users_api_v2_organizations_disable_auto_add_users_put(self, **kwargs):  # noqa: E501
        """Disable Auto Add Users  # noqa: E501

        Disable auto-add users for all clouds in the organization.  This is useful when preparing to enable directory sync, which requires auto-add users to be disabled on all clouds.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_auto_add_users_api_v2_organizations_disable_auto_add_users_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.disable_auto_add_users_api_v2_organizations_disable_auto_add_users_put_with_http_info(**kwargs)  # noqa: E501

    def disable_auto_add_users_api_v2_organizations_disable_auto_add_users_put_with_http_info(self, **kwargs):  # noqa: E501
        """Disable Auto Add Users  # noqa: E501

        Disable auto-add users for all clouds in the organization.  This is useful when preparing to enable directory sync, which requires auto-add users to be disabled on all clouds.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_auto_add_users_api_v2_organizations_disable_auto_add_users_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_auto_add_users_api_v2_organizations_disable_auto_add_users_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/disable_auto_add_users', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_aggregated_instance_usage_csv_api_v2_aggregated_instance_usage_download_csv_get(self, start_date, end_date, **kwargs):  # noqa: E501
        """Download Aggregated Instance Usage Csv  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_aggregated_instance_usage_csv_api_v2_aggregated_instance_usage_download_csv_get(start_date, end_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param str cloud_id:
        :param str project_id:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.download_aggregated_instance_usage_csv_api_v2_aggregated_instance_usage_download_csv_get_with_http_info(start_date, end_date, **kwargs)  # noqa: E501

    def download_aggregated_instance_usage_csv_api_v2_aggregated_instance_usage_download_csv_get_with_http_info(self, start_date, end_date, **kwargs):  # noqa: E501
        """Download Aggregated Instance Usage Csv  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_aggregated_instance_usage_csv_api_v2_aggregated_instance_usage_download_csv_get_with_http_info(start_date, end_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param str cloud_id:
        :param str project_id:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date',
            'cloud_id',
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_aggregated_instance_usage_csv_api_v2_aggregated_instance_usage_download_csv_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `download_aggregated_instance_usage_csv_api_v2_aggregated_instance_usage_download_csv_get`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `download_aggregated_instance_usage_csv_api_v2_aggregated_instance_usage_download_csv_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/download_csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get(self, start_date, end_date, organization_id, **kwargs):  # noqa: E501
        """Download Aggregated Instance Usage Csv Internal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get(start_date, end_date, organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param str organization_id: (required)
        :param str cloud_id:
        :param str project_id:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get_with_http_info(start_date, end_date, organization_id, **kwargs)  # noqa: E501

    def download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get_with_http_info(self, start_date, end_date, organization_id, **kwargs):  # noqa: E501
        """Download Aggregated Instance Usage Csv Internal  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get_with_http_info(start_date, end_date, organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param str organization_id: (required)
        :param str cloud_id:
        :param str project_id:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date',
            'organization_id',
            'cloud_id',
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get`")  # noqa: E501
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `download_aggregated_instance_usage_csv_internal_api_v2_aggregated_instance_usage_download_csv_internal_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501
        if 'organization_id' in local_var_params and local_var_params['organization_id'] is not None:  # noqa: E501
            query_params.append(('organization_id', local_var_params['organization_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/download_csv_internal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def echo_ip_api_v2_health_echo_ip_get(self, **kwargs):  # noqa: E501
        """Echo Ip  # noqa: E501

        Check that the product can correctly identify source IP at the router layer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.echo_ip_api_v2_health_echo_ip_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.echo_ip_api_v2_health_echo_ip_get_with_http_info(**kwargs)  # noqa: E501

    def echo_ip_api_v2_health_echo_ip_get_with_http_info(self, **kwargs):  # noqa: E501
        """Echo Ip  # noqa: E501

        Check that the product can correctly identify source IP at the router layer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.echo_ip_api_v2_health_echo_ip_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method echo_ip_api_v2_health_echo_ip_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/health/echo_ip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch(self, cloud_id, editable_cloud_resource_gcp, **kwargs):  # noqa: E501
        """Edit Cloud Resource  # noqa: E501

        Edit Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch(cloud_id, editable_cloud_resource_gcp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param EditableCloudResourceGCP editable_cloud_resource_gcp: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudresourcegcpResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch_with_http_info(cloud_id, editable_cloud_resource_gcp, **kwargs)  # noqa: E501

    def edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch_with_http_info(self, cloud_id, editable_cloud_resource_gcp, **kwargs):  # noqa: E501
        """Edit Cloud Resource  # noqa: E501

        Edit Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch_with_http_info(cloud_id, editable_cloud_resource_gcp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param EditableCloudResourceGCP editable_cloud_resource_gcp: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudresourcegcpResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'editable_cloud_resource_gcp'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch`")  # noqa: E501
        # verify the required parameter 'editable_cloud_resource_gcp' is set
        if self.api_client.client_side_validation and ('editable_cloud_resource_gcp' not in local_var_params or  # noqa: E501
                                                        local_var_params['editable_cloud_resource_gcp'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `editable_cloud_resource_gcp` when calling `edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'editable_cloud_resource_gcp' in local_var_params:
            body_params = local_var_params['editable_cloud_resource_gcp']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_gcp_router/{cloud_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudresourcegcpResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch(self, cloud_id, editable_cloud_resource, **kwargs):  # noqa: E501
        """Edit Cloud Resource  # noqa: E501

        Edit Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch(cloud_id, editable_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param EditableCloudResource editable_cloud_resource: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch_with_http_info(cloud_id, editable_cloud_resource, **kwargs)  # noqa: E501

    def edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch_with_http_info(self, cloud_id, editable_cloud_resource, **kwargs):  # noqa: E501
        """Edit Cloud Resource  # noqa: E501

        Edit Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch_with_http_info(cloud_id, editable_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param EditableCloudResource editable_cloud_resource: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'editable_cloud_resource'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch`")  # noqa: E501
        # verify the required parameter 'editable_cloud_resource' is set
        if self.api_client.client_side_validation and ('editable_cloud_resource' not in local_var_params or  # noqa: E501
                                                        local_var_params['editable_cloud_resource'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `editable_cloud_resource` when calling `edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'editable_cloud_resource' in local_var_params:
            body_params = local_var_params['editable_cloud_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_router/{cloud_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post(self, session_id, execute_interactive_command_options, **kwargs):  # noqa: E501
        """Execute Interactive Command  # noqa: E501

        Execute an interative command on a session.  This endpoint differs with other execute_* since it doesn't actually execute the command. It will just create the command and return auxiliary information for user to ssh into the head node and run their command.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post(session_id, execute_interactive_command_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExecuteInteractiveCommandOptions execute_interactive_command_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExecutecommandresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post_with_http_info(session_id, execute_interactive_command_options, **kwargs)  # noqa: E501

    def execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post_with_http_info(self, session_id, execute_interactive_command_options, **kwargs):  # noqa: E501
        """Execute Interactive Command  # noqa: E501

        Execute an interative command on a session.  This endpoint differs with other execute_* since it doesn't actually execute the command. It will just create the command and return auxiliary information for user to ssh into the head node and run their command.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post_with_http_info(session_id, execute_interactive_command_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExecuteInteractiveCommandOptions execute_interactive_command_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExecutecommandresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'execute_interactive_command_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post`")  # noqa: E501
        # verify the required parameter 'execute_interactive_command_options' is set
        if self.api_client.client_side_validation and ('execute_interactive_command_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['execute_interactive_command_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `execute_interactive_command_options` when calling `execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'execute_interactive_command_options' in local_var_params:
            body_params = local_var_params['execute_interactive_command_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/execute_interactive_command', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExecutecommandresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsagebycloudListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post_with_http_info(aggregated_usage_query, **kwargs)  # noqa: E501

    def fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post_with_http_info(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post_with_http_info(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsagebycloudListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'aggregated_usage_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'aggregated_usage_query' is set
        if self.api_client.client_side_validation and ('aggregated_usage_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['aggregated_usage_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `aggregated_usage_query` when calling `fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_cloud_api_v2_aggregated_instance_usage_cloud_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'aggregated_usage_query' in local_var_params:
            body_params = local_var_params['aggregated_usage_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/cloud', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsagebycloudListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsagebyclusterListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post_with_http_info(aggregated_usage_query, **kwargs)  # noqa: E501

    def fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post_with_http_info(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post_with_http_info(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsagebyclusterListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'aggregated_usage_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'aggregated_usage_query' is set
        if self.api_client.client_side_validation and ('aggregated_usage_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['aggregated_usage_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `aggregated_usage_query` when calling `fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_cluster_api_v2_aggregated_instance_usage_cluster_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'aggregated_usage_query' in local_var_params:
            body_params = local_var_params['aggregated_usage_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/cluster', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsagebyclusterListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Cluster Type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsagebyclustertypeListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post_with_http_info(aggregated_usage_query, **kwargs)  # noqa: E501

    def fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post_with_http_info(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Cluster Type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post_with_http_info(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsagebyclustertypeListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'aggregated_usage_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'aggregated_usage_query' is set
        if self.api_client.client_side_validation and ('aggregated_usage_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['aggregated_usage_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `aggregated_usage_query` when calling `fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_cluster_type_api_v2_aggregated_instance_usage_cluster_type_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'aggregated_usage_query' in local_var_params:
            body_params = local_var_params['aggregated_usage_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/cluster_type', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsagebyclustertypeListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Instance Type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsagebyinstancetypeListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post_with_http_info(aggregated_usage_query, **kwargs)  # noqa: E501

    def fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post_with_http_info(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Instance Type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post_with_http_info(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsagebyinstancetypeListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'aggregated_usage_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'aggregated_usage_query' is set
        if self.api_client.client_side_validation and ('aggregated_usage_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['aggregated_usage_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `aggregated_usage_query` when calling `fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_instance_type_api_v2_aggregated_instance_usage_instance_type_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'aggregated_usage_query' in local_var_params:
            body_params = local_var_params['aggregated_usage_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/instance_type', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsagebyinstancetypeListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsagebyprojectListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post_with_http_info(aggregated_usage_query, **kwargs)  # noqa: E501

    def fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post_with_http_info(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post_with_http_info(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsagebyprojectListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'aggregated_usage_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'aggregated_usage_query' is set
        if self.api_client.client_side_validation and ('aggregated_usage_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['aggregated_usage_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `aggregated_usage_query` when calling `fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_project_api_v2_aggregated_instance_usage_project_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'aggregated_usage_query' in local_var_params:
            body_params = local_var_params['aggregated_usage_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/project', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsagebyprojectListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsagebyuserListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post_with_http_info(aggregated_usage_query, **kwargs)  # noqa: E501

    def fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post_with_http_info(self, aggregated_usage_query, **kwargs):  # noqa: E501
        """Fetch Usage Group By User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post_with_http_info(aggregated_usage_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AggregatedUsageQuery aggregated_usage_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsagebyuserListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'aggregated_usage_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'aggregated_usage_query' is set
        if self.api_client.client_side_validation and ('aggregated_usage_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['aggregated_usage_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `aggregated_usage_query` when calling `fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `fetch_usage_group_by_user_api_v2_aggregated_instance_usage_user_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'aggregated_usage_query' in local_var_params:
            body_params = local_var_params['aggregated_usage_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/user', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsagebyuserListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_cloud_by_name_api_v2_clouds_find_by_name_post(self, cloud_name_options, **kwargs):  # noqa: E501
        """Find Cloud By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_cloud_by_name_api_v2_clouds_find_by_name_post(cloud_name_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CloudNameOptions cloud_name_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_cloud_by_name_api_v2_clouds_find_by_name_post_with_http_info(cloud_name_options, **kwargs)  # noqa: E501

    def find_cloud_by_name_api_v2_clouds_find_by_name_post_with_http_info(self, cloud_name_options, **kwargs):  # noqa: E501
        """Find Cloud By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_cloud_by_name_api_v2_clouds_find_by_name_post_with_http_info(cloud_name_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CloudNameOptions cloud_name_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_name_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_cloud_by_name_api_v2_clouds_find_by_name_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_name_options' is set
        if self.api_client.client_side_validation and ('cloud_name_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_name_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_name_options` when calling `find_cloud_by_name_api_v2_clouds_find_by_name_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_name_options' in local_var_params:
            body_params = local_var_params['cloud_name_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/find_by_name', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_cloud_resource_by_name_api_v2_clouds_cloud_id_find_cloud_resource_by_name_post(self, cloud_id, cloud_resource_name, **kwargs):  # noqa: E501
        """Find Cloud Resource By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_cloud_resource_by_name_api_v2_clouds_cloud_id_find_cloud_resource_by_name_post(cloud_id, cloud_resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_resource_name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_cloud_resource_by_name_api_v2_clouds_cloud_id_find_cloud_resource_by_name_post_with_http_info(cloud_id, cloud_resource_name, **kwargs)  # noqa: E501

    def find_cloud_resource_by_name_api_v2_clouds_cloud_id_find_cloud_resource_by_name_post_with_http_info(self, cloud_id, cloud_resource_name, **kwargs):  # noqa: E501
        """Find Cloud Resource By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_cloud_resource_by_name_api_v2_clouds_cloud_id_find_cloud_resource_by_name_post_with_http_info(cloud_id, cloud_resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_resource_name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_resource_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_cloud_resource_by_name_api_v2_clouds_cloud_id_find_cloud_resource_by_name_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `find_cloud_resource_by_name_api_v2_clouds_cloud_id_find_cloud_resource_by_name_post`")  # noqa: E501
        # verify the required parameter 'cloud_resource_name' is set
        if self.api_client.client_side_validation and ('cloud_resource_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_resource_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_resource_name` when calling `find_cloud_resource_by_name_api_v2_clouds_cloud_id_find_cloud_resource_by_name_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'cloud_resource_name' in local_var_params and local_var_params['cloud_resource_name'] is not None:  # noqa: E501
            query_params.append(('cloud_resource_name', local_var_params['cloud_resource_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/find_cloud_resource_by_name', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_dataset_api_v2_datasets_find_get(self, name, **kwargs):  # noqa: E501
        """Find Dataset  # noqa: E501

        Finds a Dataset object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_dataset_api_v2_datasets_find_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Name of the dataset. (required)
        :param int version: Version of the dataset. If a negative integer is provided, the dataset returned is this many versions back of the latest version. Default: Latest version
        :param str project_id: ID of the Anyscale project that the dataset belongs to. If not provided, searches all projects for the dataset.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_dataset_api_v2_datasets_find_get_with_http_info(name, **kwargs)  # noqa: E501

    def find_dataset_api_v2_datasets_find_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Find Dataset  # noqa: E501

        Finds a Dataset object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_dataset_api_v2_datasets_find_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Name of the dataset. (required)
        :param int version: Version of the dataset. If a negative integer is provided, the dataset returned is this many versions back of the latest version. Default: Latest version
        :param str project_id: ID of the Anyscale project that the dataset belongs to. If not provided, searches all projects for the dataset.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'version',
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_dataset_api_v2_datasets_find_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in local_var_params or  # noqa: E501
                                                        local_var_params['name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `find_dataset_api_v2_datasets_find_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/datasets/find', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_project_by_project_name_api_v2_projects_find_by_name_get(self, name, **kwargs):  # noqa: E501
        """Find Project By Project Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_project_by_project_name_api_v2_projects_find_by_name_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: (required)
        :param str owner:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_project_by_project_name_api_v2_projects_find_by_name_get_with_http_info(name, **kwargs)  # noqa: E501

    def find_project_by_project_name_api_v2_projects_find_by_name_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Find Project By Project Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_project_by_project_name_api_v2_projects_find_by_name_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: (required)
        :param str owner:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'owner',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_project_by_project_name_api_v2_projects_find_by_name_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in local_var_params or  # noqa: E501
                                                        local_var_params['name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `find_project_by_project_name_api_v2_projects_find_by_name_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `find_project_by_project_name_api_v2_projects_find_by_name_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `find_project_by_project_name_api_v2_projects_find_by_name_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'owner' in local_var_params and local_var_params['owner'] is not None:  # noqa: E501
            query_params.append(('owner', local_var_params['owner']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/find_by_name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def finish_session_command_api_v2_session_commands_session_command_id_finish_post(self, session_command_id, session_command_finish_options, **kwargs):  # noqa: E501
        """Finish Session Command  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.finish_session_command_api_v2_session_commands_session_command_id_finish_post(session_command_id, session_command_finish_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param SessionCommandFinishOptions session_command_finish_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.finish_session_command_api_v2_session_commands_session_command_id_finish_post_with_http_info(session_command_id, session_command_finish_options, **kwargs)  # noqa: E501

    def finish_session_command_api_v2_session_commands_session_command_id_finish_post_with_http_info(self, session_command_id, session_command_finish_options, **kwargs):  # noqa: E501
        """Finish Session Command  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.finish_session_command_api_v2_session_commands_session_command_id_finish_post_with_http_info(session_command_id, session_command_finish_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param SessionCommandFinishOptions session_command_finish_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_command_id',
            'session_command_finish_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method finish_session_command_api_v2_session_commands_session_command_id_finish_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `finish_session_command_api_v2_session_commands_session_command_id_finish_post`")  # noqa: E501
        # verify the required parameter 'session_command_finish_options' is set
        if self.api_client.client_side_validation and ('session_command_finish_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_finish_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_finish_options` when calling `finish_session_command_api_v2_session_commands_session_command_id_finish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'session_command_finish_options' in local_var_params:
            body_params = local_var_params['session_command_finish_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/{session_command_id}/finish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post(self, cloud_id, cloud_data_bucket_presigned_upload_request, **kwargs):  # noqa: E501
        """Generate Cloud Data Bucket Presigned Upload Url  # noqa: E501

        DEPRECATED. Please use /{cloud_id}/generate_cloud_data_bucket_presigned_url instead.  This method generates and returns a presigned upload URL for the provided file type & name. All files scoped to a cloud should be nested underneath {organization_id}/{cloud_id}, so the path that is generated will follow the pattern:     {organization_id}/{cloud_id}/{file_type}/{file_name}  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post(cloud_id, cloud_data_bucket_presigned_upload_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudDataBucketPresignedUploadRequest cloud_data_bucket_presigned_upload_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClouddatabucketpresigneduploadinfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post_with_http_info(cloud_id, cloud_data_bucket_presigned_upload_request, **kwargs)  # noqa: E501

    def generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post_with_http_info(self, cloud_id, cloud_data_bucket_presigned_upload_request, **kwargs):  # noqa: E501
        """Generate Cloud Data Bucket Presigned Upload Url  # noqa: E501

        DEPRECATED. Please use /{cloud_id}/generate_cloud_data_bucket_presigned_url instead.  This method generates and returns a presigned upload URL for the provided file type & name. All files scoped to a cloud should be nested underneath {organization_id}/{cloud_id}, so the path that is generated will follow the pattern:     {organization_id}/{cloud_id}/{file_type}/{file_name}  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post_with_http_info(cloud_id, cloud_data_bucket_presigned_upload_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudDataBucketPresignedUploadRequest cloud_data_bucket_presigned_upload_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClouddatabucketpresigneduploadinfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_data_bucket_presigned_upload_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post`")  # noqa: E501
        # verify the required parameter 'cloud_data_bucket_presigned_upload_request' is set
        if self.api_client.client_side_validation and ('cloud_data_bucket_presigned_upload_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_data_bucket_presigned_upload_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_data_bucket_presigned_upload_request` when calling `generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_data_bucket_presigned_upload_request' in local_var_params:
            body_params = local_var_params['cloud_data_bucket_presigned_upload_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/generate_cloud_data_bucket_presigned_upload_url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClouddatabucketpresigneduploadinfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_cloud_data_bucket_presigned_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_url_post(self, cloud_id, cloud_data_bucket_presigned_url_request, **kwargs):  # noqa: E501
        """Generate Cloud Data Bucket Presigned Url  # noqa: E501

        This method generates and returns a presigned upload URL for the provided file type & name. All files scoped to a cloud should be nested underneath {organization_id}/{cloud_id}, so the path that is generated will follow the pattern:      {organization_id}/{cloud_id}/{file_type}/{file_name}  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_cloud_data_bucket_presigned_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_url_post(cloud_id, cloud_data_bucket_presigned_url_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudDataBucketPresignedUrlRequest cloud_data_bucket_presigned_url_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClouddatabucketpresignedurlresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.generate_cloud_data_bucket_presigned_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_url_post_with_http_info(cloud_id, cloud_data_bucket_presigned_url_request, **kwargs)  # noqa: E501

    def generate_cloud_data_bucket_presigned_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_url_post_with_http_info(self, cloud_id, cloud_data_bucket_presigned_url_request, **kwargs):  # noqa: E501
        """Generate Cloud Data Bucket Presigned Url  # noqa: E501

        This method generates and returns a presigned upload URL for the provided file type & name. All files scoped to a cloud should be nested underneath {organization_id}/{cloud_id}, so the path that is generated will follow the pattern:      {organization_id}/{cloud_id}/{file_type}/{file_name}  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_cloud_data_bucket_presigned_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_url_post_with_http_info(cloud_id, cloud_data_bucket_presigned_url_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudDataBucketPresignedUrlRequest cloud_data_bucket_presigned_url_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClouddatabucketpresignedurlresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_data_bucket_presigned_url_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_cloud_data_bucket_presigned_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_url_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `generate_cloud_data_bucket_presigned_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_url_post`")  # noqa: E501
        # verify the required parameter 'cloud_data_bucket_presigned_url_request' is set
        if self.api_client.client_side_validation and ('cloud_data_bucket_presigned_url_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_data_bucket_presigned_url_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_data_bucket_presigned_url_request` when calling `generate_cloud_data_bucket_presigned_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_url_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_data_bucket_presigned_url_request' in local_var_params:
            body_params = local_var_params['cloud_data_bucket_presigned_url_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/generate_cloud_data_bucket_presigned_url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClouddatabucketpresignedurlresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_active_billing_version_api_v2_organization_billing_active_billing_version_get(self, **kwargs):  # noqa: E501
        """Get Active Billing Version  # noqa: E501

        Returns the active billing version code for the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_active_billing_version_api_v2_organization_billing_active_billing_version_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BillingVersionCode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_active_billing_version_api_v2_organization_billing_active_billing_version_get_with_http_info(**kwargs)  # noqa: E501

    def get_active_billing_version_api_v2_organization_billing_active_billing_version_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Active Billing Version  # noqa: E501

        Returns the active billing version code for the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_active_billing_version_api_v2_organization_billing_active_billing_version_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BillingVersionCode, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_active_billing_version_api_v2_organization_billing_active_billing_version_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/active_billing_version', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingVersionCode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_actor_exit_detail_aggregates_api_v2_actors_dashboard_exit_detail_aggregates_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Actor Exit Detail Aggregates  # noqa: E501

        Get aggregated actor metrics grouped by exit details (errors).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_exit_detail_aggregates_api_v2_actors_dashboard_exit_detail_aggregates_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ActorExitDetailGroupAggregateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_actor_exit_detail_aggregates_api_v2_actors_dashboard_exit_detail_aggregates_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_actor_exit_detail_aggregates_api_v2_actors_dashboard_exit_detail_aggregates_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Actor Exit Detail Aggregates  # noqa: E501

        Get aggregated actor metrics grouped by exit details (errors).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_exit_detail_aggregates_api_v2_actors_dashboard_exit_detail_aggregates_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ActorExitDetailGroupAggregateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_actor_exit_detail_aggregates_api_v2_actors_dashboard_exit_detail_aggregates_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_actor_exit_detail_aggregates_api_v2_actors_dashboard_exit_detail_aggregates_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/actors_dashboard/exit_detail_aggregates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActorExitDetailGroupAggregateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_actor_job_aggregates_api_v2_actors_dashboard_job_aggregates_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Actor Job Aggregates  # noqa: E501

        Get aggregated actor metrics grouped by job ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_job_aggregates_api_v2_actors_dashboard_job_aggregates_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ActorJobGroupAggregateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_actor_job_aggregates_api_v2_actors_dashboard_job_aggregates_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_actor_job_aggregates_api_v2_actors_dashboard_job_aggregates_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Actor Job Aggregates  # noqa: E501

        Get aggregated actor metrics grouped by job ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_job_aggregates_api_v2_actors_dashboard_job_aggregates_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ActorJobGroupAggregateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_actor_job_aggregates_api_v2_actors_dashboard_job_aggregates_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_actor_job_aggregates_api_v2_actors_dashboard_job_aggregates_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/actors_dashboard/job_aggregates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActorJobGroupAggregateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_actor_name_aggregates_api_v2_actors_dashboard_name_aggregates_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Actor Name Aggregates  # noqa: E501

        Get aggregated actor metrics grouped by name and class name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_name_aggregates_api_v2_actors_dashboard_name_aggregates_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ActorNameGroupAggregateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_actor_name_aggregates_api_v2_actors_dashboard_name_aggregates_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_actor_name_aggregates_api_v2_actors_dashboard_name_aggregates_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Actor Name Aggregates  # noqa: E501

        Get aggregated actor metrics grouped by name and class name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_name_aggregates_api_v2_actors_dashboard_name_aggregates_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ActorNameGroupAggregateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_actor_name_aggregates_api_v2_actors_dashboard_name_aggregates_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_actor_name_aggregates_api_v2_actors_dashboard_name_aggregates_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/actors_dashboard/name_aggregates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActorNameGroupAggregateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_actor_summary_api_v2_actors_dashboard_summary_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Actor Summary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_summary_api_v2_actors_dashboard_summary_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ActorsummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_actor_summary_api_v2_actors_dashboard_summary_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_actor_summary_api_v2_actors_dashboard_summary_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Actor Summary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_summary_api_v2_actors_dashboard_summary_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ActorsummaryResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_actor_summary_api_v2_actors_dashboard_summary_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_actor_summary_api_v2_actors_dashboard_summary_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/actors_dashboard/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActorsummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_actor_table_api_v2_actors_dashboard_table_get(self, cluster_id, actor_table_config, **kwargs):  # noqa: E501
        """Get Actor Table  # noqa: E501

        Paging tokens are integers that represent the page number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_table_api_v2_actors_dashboard_table_get(cluster_id, actor_table_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param ActorTableConfig actor_table_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ActorTableResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_actor_table_api_v2_actors_dashboard_table_get_with_http_info(cluster_id, actor_table_config, **kwargs)  # noqa: E501

    def get_actor_table_api_v2_actors_dashboard_table_get_with_http_info(self, cluster_id, actor_table_config, **kwargs):  # noqa: E501
        """Get Actor Table  # noqa: E501

        Paging tokens are integers that represent the page number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_actor_table_api_v2_actors_dashboard_table_get_with_http_info(cluster_id, actor_table_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param ActorTableConfig actor_table_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ActorTableResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'actor_table_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_actor_table_api_v2_actors_dashboard_table_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_actor_table_api_v2_actors_dashboard_table_get`")  # noqa: E501
        # verify the required parameter 'actor_table_config' is set
        if self.api_client.client_side_validation and ('actor_table_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['actor_table_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `actor_table_config` when calling `get_actor_table_api_v2_actors_dashboard_table_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'actor_table_config' in local_var_params:
            body_params = local_var_params['actor_table_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/actors_dashboard/table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActorTableResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get(self, **kwargs):  # noqa: E501
        """Get Anyscale Aws Account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaleawsaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get_with_http_info(**kwargs)  # noqa: E501

    def get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Anyscale Aws Account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaleawsaccountResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/anyscale/aws_account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaleawsaccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_template_api_v2_application_templates_application_template_id_get(self, application_template_id, **kwargs):  # noqa: E501
        """Get Application Template  # noqa: E501

        Retrieves a Cluster Environment. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_template_api_v2_application_templates_application_template_id_get(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedapplicationtemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_template_api_v2_application_templates_application_template_id_get_with_http_info(application_template_id, **kwargs)  # noqa: E501

    def get_application_template_api_v2_application_templates_application_template_id_get_with_http_info(self, application_template_id, **kwargs):  # noqa: E501
        """Get Application Template  # noqa: E501

        Retrieves a Cluster Environment. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_template_api_v2_application_templates_application_template_id_get_with_http_info(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedapplicationtemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'application_template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_template_api_v2_application_templates_application_template_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_template_id' is set
        if self.api_client.client_side_validation and ('application_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_template_id` when calling `get_application_template_api_v2_application_templates_application_template_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_template_id' in local_var_params:
            path_params['application_template_id'] = local_var_params['application_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/{application_template_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedapplicationtemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_azure_operator_audience_api_v2_clouds_anyscale_azure_operator_audience_get(self, **kwargs):  # noqa: E501
        """Get Azure Operator Audience  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_azure_operator_audience_api_v2_clouds_anyscale_azure_operator_audience_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AzureoperatoraudienceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_azure_operator_audience_api_v2_clouds_anyscale_azure_operator_audience_get_with_http_info(**kwargs)  # noqa: E501

    def get_azure_operator_audience_api_v2_clouds_anyscale_azure_operator_audience_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Azure Operator Audience  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_azure_operator_audience_api_v2_clouds_anyscale_azure_operator_audience_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AzureoperatoraudienceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_azure_operator_audience_api_v2_clouds_anyscale_azure_operator_audience_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/anyscale/azure_operator_audience', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AzureoperatoraudienceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get(self, organization_id, **kwargs):  # noqa: E501
        """Get Billing Versions By Organization  # noqa: E501

        Returns the list of billing versions for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReadbillingversionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Get Billing Versions By Organization  # noqa: E501

        Returns the list of billing versions for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReadbillingversionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_id' in local_var_params and local_var_params['organization_id'] is not None:  # noqa: E501
            query_params.append(('organization_id', local_var_params['organization_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/billing_versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReadbillingversionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_build_api_v2_builds_build_id_get(self, build_id, **kwargs):  # noqa: E501
        """Get Build  # noqa: E501

        Retrieves a Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_build_api_v2_builds_build_id_get(build_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str build_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedbuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_build_api_v2_builds_build_id_get_with_http_info(build_id, **kwargs)  # noqa: E501

    def get_build_api_v2_builds_build_id_get_with_http_info(self, build_id, **kwargs):  # noqa: E501
        """Get Build  # noqa: E501

        Retrieves a Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_build_api_v2_builds_build_id_get_with_http_info(build_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str build_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedbuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'build_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_build_api_v2_builds_build_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'build_id' is set
        if self.api_client.client_side_validation and ('build_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['build_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `build_id` when calling `get_build_api_v2_builds_build_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'build_id' in local_var_params:
            path_params['build_id'] = local_var_params['build_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/{build_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedbuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_build_logs_api_v2_builds_build_id_logs_get(self, build_id, **kwargs):  # noqa: E501
        """Get Build Logs  # noqa: E501

        Retrieves logs for a Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_build_logs_api_v2_builds_build_id_logs_get(build_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str build_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BuildlogresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_build_logs_api_v2_builds_build_id_logs_get_with_http_info(build_id, **kwargs)  # noqa: E501

    def get_build_logs_api_v2_builds_build_id_logs_get_with_http_info(self, build_id, **kwargs):  # noqa: E501
        """Get Build Logs  # noqa: E501

        Retrieves logs for a Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_build_logs_api_v2_builds_build_id_logs_get_with_http_info(build_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str build_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BuildlogresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'build_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_build_logs_api_v2_builds_build_id_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'build_id' is set
        if self.api_client.client_side_validation and ('build_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['build_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `build_id` when calling `get_build_logs_api_v2_builds_build_id_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'build_id' in local_var_params:
            path_params['build_id'] = local_var_params['build_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/{build_id}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BuildlogresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_additional_instance_types_api_v2_clouds_cloud_id_additional_instance_types_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud Additional Instance Types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_additional_instance_types_api_v2_clouds_cloud_id_additional_instance_types_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudresourceadditionalinstancetypesListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_additional_instance_types_api_v2_clouds_cloud_id_additional_instance_types_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_additional_instance_types_api_v2_clouds_cloud_id_additional_instance_types_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud Additional Instance Types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_additional_instance_types_api_v2_clouds_cloud_id_additional_instance_types_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudresourceadditionalinstancetypesListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_additional_instance_types_api_v2_clouds_cloud_id_additional_instance_types_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_additional_instance_types_api_v2_clouds_cloud_id_additional_instance_types_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/additional_instance_types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudresourceadditionalinstancetypesListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_api_v2_clouds_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_api_v2_clouds_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_api_v2_clouds_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_api_v2_clouds_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_api_v2_clouds_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_api_v2_clouds_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_api_v2_clouds_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_get(self, cloud_id, cloud_deployment_id, **kwargs):  # noqa: E501
        """Get Cloud Deployment Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_get(cloud_id, cloud_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_deployment_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClouddeploymentconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_get_with_http_info(cloud_id, cloud_deployment_id, **kwargs)  # noqa: E501

    def get_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_get_with_http_info(self, cloud_id, cloud_deployment_id, **kwargs):  # noqa: E501
        """Get Cloud Deployment Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_get_with_http_info(cloud_id, cloud_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_deployment_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClouddeploymentconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_deployment_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_get`")  # noqa: E501
        # verify the required parameter 'cloud_deployment_id' is set
        if self.api_client.client_side_validation and ('cloud_deployment_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_deployment_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_deployment_id` when calling `get_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501
        if 'cloud_deployment_id' in local_var_params:
            path_params['cloud_deployment_id'] = local_var_params['cloud_deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/deployment/{cloud_deployment_id}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClouddeploymentconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_deployments_api_v2_clouds_cloud_id_deployments_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud Deployments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_deployments_api_v2_clouds_cloud_id_deployments_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcloudresourceListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_deployments_api_v2_clouds_cloud_id_deployments_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_deployments_api_v2_clouds_cloud_id_deployments_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud Deployments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_deployments_api_v2_clouds_cloud_id_deployments_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcloudresourceListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_deployments_api_v2_clouds_cloud_id_deployments_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_deployments_api_v2_clouds_cloud_id_deployments_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/deployments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcloudresourceListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_overview_dashboard_api_v2_clouds_cloud_id_cloud_overview_dashboard_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud Overview Dashboard  # noqa: E501

        Gets the cloud overview dashboard embed url. Installs or upgrades the Cloud overview dashboard if needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_overview_dashboard_api_v2_clouds_cloud_id_cloud_overview_dashboard_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudoverviewdashboardResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_overview_dashboard_api_v2_clouds_cloud_id_cloud_overview_dashboard_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_overview_dashboard_api_v2_clouds_cloud_id_cloud_overview_dashboard_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud Overview Dashboard  # noqa: E501

        Gets the cloud overview dashboard embed url. Installs or upgrades the Cloud overview dashboard if needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_overview_dashboard_api_v2_clouds_cloud_id_cloud_overview_dashboard_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudoverviewdashboardResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_overview_dashboard_api_v2_clouds_cloud_id_cloud_overview_dashboard_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_overview_dashboard_api_v2_clouds_cloud_id_cloud_overview_dashboard_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/cloud-overview-dashboard', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudoverviewdashboardResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get(self, project_id, **kwargs):  # noqa: E501
        """Get Cloud Project Collaborator  # noqa: E501

        Get cloud that has permission for a given project if that project is public in the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudProjectCollaborator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get Cloud Project Collaborator  # noqa: E501

        Get cloud that has permission for a given project if that project is public in the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudProjectCollaborator, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/clouds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudProjectCollaborator',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_resource_api_v2_clouds_cloud_id_resource_get(self, cloud_id, cloud_resource_id, **kwargs):  # noqa: E501
        """Get Cloud Resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_resource_api_v2_clouds_cloud_id_resource_get(cloud_id, cloud_resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_resource_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_resource_api_v2_clouds_cloud_id_resource_get_with_http_info(cloud_id, cloud_resource_id, **kwargs)  # noqa: E501

    def get_cloud_resource_api_v2_clouds_cloud_id_resource_get_with_http_info(self, cloud_id, cloud_resource_id, **kwargs):  # noqa: E501
        """Get Cloud Resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_resource_api_v2_clouds_cloud_id_resource_get_with_http_info(cloud_id, cloud_resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_resource_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_resource_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_resource_api_v2_clouds_cloud_id_resource_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_resource_api_v2_clouds_cloud_id_resource_get`")  # noqa: E501
        # verify the required parameter 'cloud_resource_id' is set
        if self.api_client.client_side_validation and ('cloud_resource_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_resource_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_resource_id` when calling `get_cloud_resource_api_v2_clouds_cloud_id_resource_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'cloud_resource_id' in local_var_params and local_var_params['cloud_resource_id'] is not None:  # noqa: E501
            query_params.append(('cloud_resource_id', local_var_params['cloud_resource_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/resource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_resources_api_v2_clouds_cloud_id_resources_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud Resources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_resources_api_v2_clouds_cloud_id_resources_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcloudresourceListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_resources_api_v2_clouds_cloud_id_resources_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_resources_api_v2_clouds_cloud_id_resources_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud Resources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_resources_api_v2_clouds_cloud_id_resources_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcloudresourceListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_resources_api_v2_clouds_cloud_id_resources_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_resources_api_v2_clouds_cloud_id_resources_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcloudresourceListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud With Cloud Resource  # noqa: E501

        Retrieves a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourcegcpResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud With Cloud Resource  # noqa: E501

        Retrieves a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourcegcpResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_gcp_router/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourcegcpResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud With Cloud Resource  # noqa: E501

        Retrieves a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud With Cloud Resource  # noqa: E501

        Retrieves a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_router/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_access_token_api_v2_authentication_cluster_id_cluster_access_token_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Cluster Access Token  # noqa: E501

        If the browser already has a valid authentication cookie for the given cluster, return the token. If not, this helps a browser set an authentication cookie for a given cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_access_token_api_v2_authentication_cluster_id_cluster_access_token_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cluster_access_token_api_v2_authentication_cluster_id_cluster_access_token_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_cluster_access_token_api_v2_authentication_cluster_id_cluster_access_token_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Cluster Access Token  # noqa: E501

        If the browser already has a valid authentication cookie for the given cluster, return the token. If not, this helps a browser set an authentication cookie for a given cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_access_token_api_v2_authentication_cluster_id_cluster_access_token_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_access_token_api_v2_authentication_cluster_id_cluster_access_token_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_cluster_access_token_api_v2_authentication_cluster_id_cluster_access_token_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authentication/{cluster_id}/cluster_access_token', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_events_api_v2_sessions_session_id_cluster_events_get(self, session_id, **kwargs):  # noqa: E501
        """Get Cluster Events  # noqa: E501

        Return events for this cluster.  There are multiple endpoints to return events. This endpoint is for the UI to fetch events. This should power general observability event views shared by different workload types. Like the task view or the Train dashboard view.  The /events endpoint is used by the dataplane to fetch events and has cluster auth requirements.  Finally, there are events endpoints for each workload type (workspaces, jobs, services). Those endpoints have some additional logic to stitch together cluster events with workload-specific events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_events_api_v2_sessions_session_id_cluster_events_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param datetime start_time: Filter for events that have occurred since this value
        :param datetime end_time: Filter for events that have occurred before this value
        :param list[ClusterEventSource] sources: Filter for events from these sources
        :param list[str] autoscaler_resource_bundles: Filter for autoscaler events relevant to specific resource bundles.Each string should be a JSON-encoded resource bundle. We accept a string here because query params do not support dictionaries. Ex: ['{\"CPU\": 1, \"GPU\": 1}', '{\"GPU\": 1}']
        :param str instance_id: Filter for events from this instance. This is a string that is the instance id of the instance.
        :param str instance_node_ip: Filter for events from this instance. This is a string that is the node ip of the instance.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param int count: Max number of events to fetch.
        :param list[EventLevel] level: Filter by level of event. If level is not set, query will return all level values
        :param str message: Filter by message of event. If message is not set, query will not filter for message
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClustereventListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cluster_events_api_v2_sessions_session_id_cluster_events_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_cluster_events_api_v2_sessions_session_id_cluster_events_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Cluster Events  # noqa: E501

        Return events for this cluster.  There are multiple endpoints to return events. This endpoint is for the UI to fetch events. This should power general observability event views shared by different workload types. Like the task view or the Train dashboard view.  The /events endpoint is used by the dataplane to fetch events and has cluster auth requirements.  Finally, there are events endpoints for each workload type (workspaces, jobs, services). Those endpoints have some additional logic to stitch together cluster events with workload-specific events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_events_api_v2_sessions_session_id_cluster_events_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param datetime start_time: Filter for events that have occurred since this value
        :param datetime end_time: Filter for events that have occurred before this value
        :param list[ClusterEventSource] sources: Filter for events from these sources
        :param list[str] autoscaler_resource_bundles: Filter for autoscaler events relevant to specific resource bundles.Each string should be a JSON-encoded resource bundle. We accept a string here because query params do not support dictionaries. Ex: ['{\"CPU\": 1, \"GPU\": 1}', '{\"GPU\": 1}']
        :param str instance_id: Filter for events from this instance. This is a string that is the instance id of the instance.
        :param str instance_node_ip: Filter for events from this instance. This is a string that is the node ip of the instance.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param int count: Max number of events to fetch.
        :param list[EventLevel] level: Filter by level of event. If level is not set, query will return all level values
        :param str message: Filter by message of event. If message is not set, query will not filter for message
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClustereventListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_time',
            'end_time',
            'sources',
            'autoscaler_resource_bundles',
            'instance_id',
            'instance_node_ip',
            'ascending_order',
            'count',
            'level',
            'message'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_events_api_v2_sessions_session_id_cluster_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_cluster_events_api_v2_sessions_session_id_cluster_events_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'sources' in local_var_params and local_var_params['sources'] is not None:  # noqa: E501
            query_params.append(('sources', local_var_params['sources']))  # noqa: E501
            collection_formats['sources'] = 'multi'  # noqa: E501
        if 'autoscaler_resource_bundles' in local_var_params and local_var_params['autoscaler_resource_bundles'] is not None:  # noqa: E501
            query_params.append(('autoscaler_resource_bundles', local_var_params['autoscaler_resource_bundles']))  # noqa: E501
            collection_formats['autoscaler_resource_bundles'] = 'multi'  # noqa: E501
        if 'instance_id' in local_var_params and local_var_params['instance_id'] is not None:  # noqa: E501
            query_params.append(('instance_id', local_var_params['instance_id']))  # noqa: E501
        if 'instance_node_ip' in local_var_params and local_var_params['instance_node_ip'] is not None:  # noqa: E501
            query_params.append(('instance_node_ip', local_var_params['instance_node_ip']))  # noqa: E501
        if 'ascending_order' in local_var_params and local_var_params['ascending_order'] is not None:  # noqa: E501
            query_params.append(('ascending_order', local_var_params['ascending_order']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501
        if 'level' in local_var_params and local_var_params['level'] is not None:  # noqa: E501
            query_params.append(('level', local_var_params['level']))  # noqa: E501
            collection_formats['level'] = 'multi'  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/cluster_events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClustereventListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_compute_template_api_v2_compute_templates_template_id_get(self, template_id, **kwargs):  # noqa: E501
        """Get Compute Template  # noqa: E501

        Retrieves a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compute_template_api_v2_compute_templates_template_id_get(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcomputetemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_compute_template_api_v2_compute_templates_template_id_get_with_http_info(template_id, **kwargs)  # noqa: E501

    def get_compute_template_api_v2_compute_templates_template_id_get_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get Compute Template  # noqa: E501

        Retrieves a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compute_template_api_v2_compute_templates_template_id_get_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcomputetemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_template_api_v2_compute_templates_template_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_compute_template_api_v2_compute_templates_template_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/{template_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcomputetemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credits_v2_api_v2_organization_billing_credits_v2_get(self, **kwargs):  # noqa: E501
        """Get Credits V2  # noqa: E501

        Returns the credits v2 data for this user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credits_v2_api_v2_organization_billing_credits_v2_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreditsV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credits_v2_api_v2_organization_billing_credits_v2_get_with_http_info(**kwargs)  # noqa: E501

    def get_credits_v2_api_v2_organization_billing_credits_v2_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Credits V2  # noqa: E501

        Returns the credits v2 data for this user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credits_v2_api_v2_organization_billing_credits_v2_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreditsV2, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credits_v2_api_v2_organization_billing_credits_v2_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/credits_v2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreditsV2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credits_v2_by_organization_api_v2_organization_billing_credits_v2_organization_id_get(self, organization_id, **kwargs):  # noqa: E501
        """Get Credits V2 By Organization  # noqa: E501

        Returns the credits v2 data for a given organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credits_v2_by_organization_api_v2_organization_billing_credits_v2_organization_id_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreditsV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credits_v2_by_organization_api_v2_organization_billing_credits_v2_organization_id_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def get_credits_v2_by_organization_api_v2_organization_billing_credits_v2_organization_id_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Get Credits V2 By Organization  # noqa: E501

        Returns the credits v2 data for a given organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credits_v2_by_organization_api_v2_organization_billing_credits_v2_organization_id_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreditsV2, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credits_v2_by_organization_api_v2_organization_billing_credits_v2_organization_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `get_credits_v2_by_organization_api_v2_organization_billing_credits_v2_organization_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/credits_v2/{organization_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreditsV2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get(self, cron_job_id, **kwargs):  # noqa: E501
        """Get Cron Job  # noqa: E501

        Get CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get(cron_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedscheduleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get_with_http_info(cron_job_id, **kwargs)  # noqa: E501

    def get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get_with_http_info(self, cron_job_id, **kwargs):  # noqa: E501
        """Get Cron Job  # noqa: E501

        Get CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get_with_http_info(cron_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedscheduleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cron_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cron_job_id' is set
        if self.api_client.client_side_validation and ('cron_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cron_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cron_job_id` when calling `get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cron_job_id' in local_var_params:
            path_params['cron_job_id'] = local_var_params['cron_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/{cron_job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedscheduleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dags_api_v2_dataset_runs_dags_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Dags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dags_api_v2_dataset_runs_dags_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetDagResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dags_api_v2_dataset_runs_dags_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_dags_api_v2_dataset_runs_dags_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Dags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dags_api_v2_dataset_runs_dags_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetDagResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dags_api_v2_dataset_runs_dags_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_dags_api_v2_dataset_runs_dags_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dataset_runs/dags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetDagResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_metadata_api_v2_dataset_runs_metadata_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Dashboard Metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_metadata_api_v2_dataset_runs_metadata_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetMetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dashboard_metadata_api_v2_dataset_runs_metadata_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_dashboard_metadata_api_v2_dataset_runs_metadata_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Dashboard Metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_metadata_api_v2_dataset_runs_metadata_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetMetadataResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_metadata_api_v2_dataset_runs_metadata_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_dashboard_metadata_api_v2_dataset_runs_metadata_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dataset_runs/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetMetadataResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_metrics_api_v2_dataset_runs_metrics_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Dashboard Metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_metrics_api_v2_dataset_runs_metrics_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetMetricsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dashboard_metrics_api_v2_dataset_runs_metrics_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_dashboard_metrics_api_v2_dataset_runs_metrics_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Dashboard Metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_metrics_api_v2_dataset_runs_metrics_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetMetricsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_metrics_api_v2_dataset_runs_metrics_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_dashboard_metrics_api_v2_dataset_runs_metrics_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dataset_runs/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetMetricsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_databricks_connection_api_v2_integrations_connections_databricks_connection_id_get(self, connection_id, **kwargs):  # noqa: E501
        """Get Databricks Connection  # noqa: E501

        Get a specific Databricks connection by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_databricks_connection_api_v2_integrations_connections_databricks_connection_id_get(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatabricksconnectioninfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_databricks_connection_api_v2_integrations_connections_databricks_connection_id_get_with_http_info(connection_id, **kwargs)  # noqa: E501

    def get_databricks_connection_api_v2_integrations_connections_databricks_connection_id_get_with_http_info(self, connection_id, **kwargs):  # noqa: E501
        """Get Databricks Connection  # noqa: E501

        Get a specific Databricks connection by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_databricks_connection_api_v2_integrations_connections_databricks_connection_id_get_with_http_info(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatabricksconnectioninfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connection_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_databricks_connection_api_v2_integrations_connections_databricks_connection_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and ('connection_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connection_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `get_databricks_connection_api_v2_integrations_connections_databricks_connection_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connection_id'] = local_var_params['connection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/connections/databricks/{connection_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatabricksconnectioninfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset_api_v2_datasets_dataset_id_get(self, dataset_id, **kwargs):  # noqa: E501
        """Get Dataset  # noqa: E501

        Retrieves a Dataset object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_api_v2_datasets_dataset_id_get(dataset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str dataset_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dataset_api_v2_datasets_dataset_id_get_with_http_info(dataset_id, **kwargs)  # noqa: E501

    def get_dataset_api_v2_datasets_dataset_id_get_with_http_info(self, dataset_id, **kwargs):  # noqa: E501
        """Get Dataset  # noqa: E501

        Retrieves a Dataset object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_api_v2_datasets_dataset_id_get_with_http_info(dataset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str dataset_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'dataset_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_api_v2_datasets_dataset_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and ('dataset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `get_dataset_api_v2_datasets_dataset_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_id' in local_var_params:
            path_params['dataset_id'] = local_var_params['dataset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/datasets/{dataset_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset_download_info_api_v2_datasets_download_info_get(self, name, **kwargs):  # noqa: E501
        """Get Dataset Download Info  # noqa: E501

        Returns download info for a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_download_info_api_v2_datasets_download_info_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Name of the dataset to download. (required)
        :param int version: Version of the dataset to download. If a negative integer is provided, the dataset returned is this many versions back of the latest version. Default: Latest version
        :param str project_id: ID of the Anyscale project that the dataset belongs to.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClouddatabucketpresignedurlresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dataset_download_info_api_v2_datasets_download_info_get_with_http_info(name, **kwargs)  # noqa: E501

    def get_dataset_download_info_api_v2_datasets_download_info_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get Dataset Download Info  # noqa: E501

        Returns download info for a dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_download_info_api_v2_datasets_download_info_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Name of the dataset to download. (required)
        :param int version: Version of the dataset to download. If a negative integer is provided, the dataset returned is this many versions back of the latest version. Default: Latest version
        :param str project_id: ID of the Anyscale project that the dataset belongs to.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClouddatabucketpresignedurlresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'version',
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_download_info_api_v2_datasets_download_info_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in local_var_params or  # noqa: E501
                                                        local_var_params['name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `get_dataset_download_info_api_v2_datasets_download_info_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/datasets/download_info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClouddatabucketpresignedurlresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset_download_url_api_v2_datasets_download_get(self, name, **kwargs):  # noqa: E501
        """Get Dataset Download Url  # noqa: E501

        Returns a short-lived URL that can be visited to download the dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_download_url_api_v2_datasets_download_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Name of the dataset to download. (required)
        :param int version: Version of the dataset to download. If a negative integer is provided, the dataset returned is this many versions back of the latest version. Default: Latest version
        :param str project_id: ID of the Anyscale project that the dataset belongs to.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dataset_download_url_api_v2_datasets_download_get_with_http_info(name, **kwargs)  # noqa: E501

    def get_dataset_download_url_api_v2_datasets_download_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get Dataset Download Url  # noqa: E501

        Returns a short-lived URL that can be visited to download the dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_download_url_api_v2_datasets_download_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Name of the dataset to download. (required)
        :param int version: Version of the dataset to download. If a negative integer is provided, the dataset returned is this many versions back of the latest version. Default: Latest version
        :param str project_id: ID of the Anyscale project that the dataset belongs to.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'version',
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_download_url_api_v2_datasets_download_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in local_var_params or  # noqa: E501
                                                        local_var_params['name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `get_dataset_download_url_api_v2_datasets_download_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/datasets/download', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get(self, cluster_id, session_name, dataset_id, **kwargs):  # noqa: E501
        """Get Dataset Logs Download  # noqa: E501

        Fetches logs of the dataset. The logs will be fetched from the streaming logs s3 bucket.  If a pagination token is provided, we use the streaming logs or downloaded logs bucket depending on the format of the pagination token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get(cluster_id, session_name, dataset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str session_name: (required)
        :param str dataset_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get_with_http_info(cluster_id, session_name, dataset_id, **kwargs)  # noqa: E501

    def get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get_with_http_info(self, cluster_id, session_name, dataset_id, **kwargs):  # noqa: E501
        """Get Dataset Logs Download  # noqa: E501

        Fetches logs of the dataset. The logs will be fetched from the streaming logs s3 bucket.  If a pagination token is provided, we use the streaming logs or downloaded logs bucket depending on the format of the pagination token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get_with_http_info(cluster_id, session_name, dataset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str session_name: (required)
        :param str dataset_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'session_name',
            'dataset_id',
            'page_size',
            'next_page_token',
            'previous_page_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get`")  # noqa: E501
        # verify the required parameter 'session_name' is set
        if self.api_client.client_side_validation and ('session_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_name` when calling `get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get`")  # noqa: E501
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and ('dataset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'page_size' in local_var_params and local_var_params['page_size'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `page_size` when calling `get_dataset_logs_download_api_v2_dataset_runs_dataset_logs_get`, must be a value less than or equal to `1000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'session_name' in local_var_params and local_var_params['session_name'] is not None:  # noqa: E501
            query_params.append(('session_name', local_var_params['session_name']))  # noqa: E501
        if 'dataset_id' in local_var_params and local_var_params['dataset_id'] is not None:  # noqa: E501
            query_params.append(('dataset_id', local_var_params['dataset_id']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'next_page_token' in local_var_params and local_var_params['next_page_token'] is not None:  # noqa: E501
            query_params.append(('next_page_token', local_var_params['next_page_token']))  # noqa: E501
        if 'previous_page_token' in local_var_params and local_var_params['previous_page_token'] is not None:  # noqa: E501
            query_params.append(('previous_page_token', local_var_params['previous_page_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dataset_runs/dataset_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Decorated Cluster  # noqa: E501

        Get a single cluster by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedsessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Decorated Cluster  # noqa: E501

        Get a single cluster by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedsessionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_sessions/{cluster_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedsessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get(self, interactive_session_id, **kwargs):  # noqa: E501
        """Get Decorated Interactive Session  # noqa: E501

        Get one specific decorated job by it's db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get(interactive_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str interactive_session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedinteractivesessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get_with_http_info(interactive_session_id, **kwargs)  # noqa: E501

    def get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get_with_http_info(self, interactive_session_id, **kwargs):  # noqa: E501
        """Get Decorated Interactive Session  # noqa: E501

        Get one specific decorated job by it's db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get_with_http_info(interactive_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str interactive_session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedinteractivesessionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'interactive_session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'interactive_session_id' is set
        if self.api_client.client_side_validation and ('interactive_session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['interactive_session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `interactive_session_id` when calling `get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interactive_session_id' in local_var_params:
            path_params['interactive_session_id'] = local_var_params['interactive_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_interactive_sessions/{interactive_session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedinteractivesessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_job_api_v2_decorated_jobs_job_id_get(self, job_id, **kwargs):  # noqa: E501
        """Get Decorated Job  # noqa: E501

        Get one specific decorated job by it's db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_api_v2_decorated_jobs_job_id_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_job_api_v2_decorated_jobs_job_id_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_decorated_job_api_v2_decorated_jobs_job_id_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Decorated Job  # noqa: E501

        Get one specific decorated job by it's db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_api_v2_decorated_jobs_job_id_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_job_api_v2_decorated_jobs_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_decorated_job_api_v2_decorated_jobs_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_jobs/{job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get(self, serve_deloyment_id, **kwargs):  # noqa: E501
        """Get Decorated Serve Deployment  # noqa: E501

        Get a decorated serve deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get(serve_deloyment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str serve_deloyment_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedservedeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get_with_http_info(serve_deloyment_id, **kwargs)  # noqa: E501

    def get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get_with_http_info(self, serve_deloyment_id, **kwargs):  # noqa: E501
        """Get Decorated Serve Deployment  # noqa: E501

        Get a decorated serve deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get_with_http_info(serve_deloyment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str serve_deloyment_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedservedeploymentResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'serve_deloyment_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'serve_deloyment_id' is set
        if self.api_client.client_side_validation and ('serve_deloyment_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['serve_deloyment_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `serve_deloyment_id` when calling `get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'serve_deloyment_id' in local_var_params:
            path_params['serve_deloyment_id'] = local_var_params['serve_deloyment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_serve_deployments/{serve_deloyment_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedservedeploymentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_support_request_for_user_organization_api_v2_support_requests_get(self, **kwargs):  # noqa: E501
        """Get Decorated Support Request For User Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_support_request_for_user_organization_api_v2_support_requests_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedsupportrequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_support_request_for_user_organization_api_v2_support_requests_get_with_http_info(**kwargs)  # noqa: E501

    def get_decorated_support_request_for_user_organization_api_v2_support_requests_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Decorated Support Request For User Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_support_request_for_user_organization_api_v2_support_requests_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedsupportrequestResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_support_request_for_user_organization_api_v2_support_requests_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/support_requests/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedsupportrequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get(self, py_version, ray_version, **kwargs):  # noqa: E501
        """Get Default Cluster Env Build  # noqa: E501

        Retrieves default build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get(py_version, ray_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str py_version: (required)
        :param str ray_version: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedbuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get_with_http_info(py_version, ray_version, **kwargs)  # noqa: E501

    def get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get_with_http_info(self, py_version, ray_version, **kwargs):  # noqa: E501
        """Get Default Cluster Env Build  # noqa: E501

        Retrieves default build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get_with_http_info(py_version, ray_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str py_version: (required)
        :param str ray_version: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedbuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'py_version',
            'ray_version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'py_version' is set
        if self.api_client.client_side_validation and ('py_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['py_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `py_version` when calling `get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get`")  # noqa: E501
        # verify the required parameter 'ray_version' is set
        if self.api_client.client_side_validation and ('ray_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['ray_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ray_version` when calling `get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'py_version' in local_var_params:
            path_params['py_version'] = local_var_params['py_version']  # noqa: E501
        if 'ray_version' in local_var_params:
            path_params['ray_version'] = local_var_params['ray_version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/default/{py_version}/{ray_version}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedbuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_compute_config_api_v2_compute_templates_default_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Default Compute Config  # noqa: E501

        Return a default compute configuration for this cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_compute_config_api_v2_compute_templates_default_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_resource_id:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComputetemplateconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_default_compute_config_api_v2_compute_templates_default_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_default_compute_config_api_v2_compute_templates_default_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Default Compute Config  # noqa: E501

        Return a default compute configuration for this cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_compute_config_api_v2_compute_templates_default_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_resource_id:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComputetemplateconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_resource_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_compute_config_api_v2_compute_templates_default_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_default_compute_config_api_v2_compute_templates_default_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'cloud_resource_id' in local_var_params and local_var_params['cloud_resource_id'] is not None:  # noqa: E501
            query_params.append(('cloud_resource_id', local_var_params['cloud_resource_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/default/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputetemplateconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_project_api_v2_projects_default_project_get(self, **kwargs):  # noqa: E501
        """Get Default Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_project_api_v2_projects_default_project_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str parent_cloud_id: Cloud to fetch this default project for. This is only required if cloud isolation is enabled.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_default_project_api_v2_projects_default_project_get_with_http_info(**kwargs)  # noqa: E501

    def get_default_project_api_v2_projects_default_project_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Default Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_project_api_v2_projects_default_project_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str parent_cloud_id: Cloud to fetch this default project for. This is only required if cloud isolation is enabled.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'parent_cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_project_api_v2_projects_default_project_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'parent_cloud_id' in local_var_params and local_var_params['parent_cloud_id'] is not None:  # noqa: E501
            query_params.append(('parent_cloud_id', local_var_params['parent_cloud_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/default_project', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_deployment_infra_api_v2_workos_deployment_infra_get(self, **kwargs):  # noqa: E501
        """Get Deployment Infra  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_deployment_infra_api_v2_workos_deployment_infra_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeploymentinfraresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_deployment_infra_api_v2_workos_deployment_infra_get_with_http_info(**kwargs)  # noqa: E501

    def get_deployment_infra_api_v2_workos_deployment_infra_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Deployment Infra  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_deployment_infra_api_v2_workos_deployment_infra_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeploymentinfraresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_deployment_infra_api_v2_workos_deployment_infra_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workos/deployment_infra', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeploymentinfraresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_directory_sync_readiness_api_v2_organizations_directory_sync_readiness_get(self, **kwargs):  # noqa: E501
        """Get Directory Sync Readiness  # noqa: E501

        Check if the organization is ready for directory sync.  Returns readiness status and reasons if not ready. Currently checks: - No clouds in the organization have auto-add users enabled  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_directory_sync_readiness_api_v2_organizations_directory_sync_readiness_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DirectorysyncreadinessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_directory_sync_readiness_api_v2_organizations_directory_sync_readiness_get_with_http_info(**kwargs)  # noqa: E501

    def get_directory_sync_readiness_api_v2_organizations_directory_sync_readiness_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Directory Sync Readiness  # noqa: E501

        Check if the organization is ready for directory sync.  Returns readiness status and reasons if not ready. Currently checks: - No clouds in the organization have auto-add users enabled  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_directory_sync_readiness_api_v2_organizations_directory_sync_readiness_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DirectorysyncreadinessResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_directory_sync_readiness_api_v2_organizations_directory_sync_readiness_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/directory_sync_readiness', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DirectorysyncreadinessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_events_api_v2_sessions_session_id_events_get(self, session_id, start_index, end_index, **kwargs):  # noqa: E501
        """Get Events  # noqa: E501

        Return events for this cluster.  There are multiple endpoints to return events.  This endpoint is for the dataplane to fetch events to power the oss ray dashboard.  The /cluster_events endpoint is used by the UI to fetch events to power general debugging UI features like train dashboard.  Finally, there are events endpoints for each workload type (workspaces, jobs, services). Those endpoints have some additional logic to stitch together cluster events with workload-specific events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_api_v2_sessions_session_id_events_get(session_id, start_index, end_index, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_index: (required)
        :param int end_index: (required)
        :param datetime start_time:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClustereventsoutputResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_events_api_v2_sessions_session_id_events_get_with_http_info(session_id, start_index, end_index, **kwargs)  # noqa: E501

    def get_events_api_v2_sessions_session_id_events_get_with_http_info(self, session_id, start_index, end_index, **kwargs):  # noqa: E501
        """Get Events  # noqa: E501

        Return events for this cluster.  There are multiple endpoints to return events.  This endpoint is for the dataplane to fetch events to power the oss ray dashboard.  The /cluster_events endpoint is used by the UI to fetch events to power general debugging UI features like train dashboard.  Finally, there are events endpoints for each workload type (workspaces, jobs, services). Those endpoints have some additional logic to stitch together cluster events with workload-specific events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_api_v2_sessions_session_id_events_get_with_http_info(session_id, start_index, end_index, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_index: (required)
        :param int end_index: (required)
        :param datetime start_time:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClustereventsoutputResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_index',
            'end_index',
            'start_time'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_events_api_v2_sessions_session_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_events_api_v2_sessions_session_id_events_get`")  # noqa: E501
        # verify the required parameter 'start_index' is set
        if self.api_client.client_side_validation and ('start_index' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_index'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_index` when calling `get_events_api_v2_sessions_session_id_events_get`")  # noqa: E501
        # verify the required parameter 'end_index' is set
        if self.api_client.client_side_validation and ('end_index' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_index'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_index` when calling `get_events_api_v2_sessions_session_id_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'start_index' in local_var_params and local_var_params['start_index'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `start_index` when calling `get_events_api_v2_sessions_session_id_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'start_index' in local_var_params and local_var_params['start_index'] is not None:  # noqa: E501
            query_params.append(('start_index', local_var_params['start_index']))  # noqa: E501
        if 'end_index' in local_var_params and local_var_params['end_index'] is not None:  # noqa: E501
            query_params.append(('end_index', local_var_params['end_index']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClustereventsoutputResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_get(self, instance_usage_budget_id, **kwargs):  # noqa: E501
        """Get Instance Usage Budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_get(instance_usage_budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str instance_usage_budget_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InstanceusagebudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_get_with_http_info(instance_usage_budget_id, **kwargs)  # noqa: E501

    def get_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_get_with_http_info(self, instance_usage_budget_id, **kwargs):  # noqa: E501
        """Get Instance Usage Budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_get_with_http_info(instance_usage_budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str instance_usage_budget_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InstanceusagebudgetResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'instance_usage_budget_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'instance_usage_budget_id' is set
        if self.api_client.client_side_validation and ('instance_usage_budget_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['instance_usage_budget_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `instance_usage_budget_id` when calling `get_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_usage_budget_id' in local_var_params:
            path_params['instance_usage_budget_id'] = local_var_params['instance_usage_budget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/instance_usage_budgets/{instance_usage_budget_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceusagebudgetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invitation_api_v2_organization_invitations_invitation_id_get(self, invitation_id, **kwargs):  # noqa: E501
        """Get Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invitation_api_v2_organization_invitations_invitation_id_get(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationinvitationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invitation_api_v2_organization_invitations_invitation_id_get_with_http_info(invitation_id, **kwargs)  # noqa: E501

    def get_invitation_api_v2_organization_invitations_invitation_id_get_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Get Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invitation_api_v2_organization_invitations_invitation_id_get_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationinvitationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'invitation_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invitation_api_v2_organization_invitations_invitation_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if self.api_client.client_side_validation and ('invitation_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['invitation_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `invitation_id` when calling `get_invitation_api_v2_organization_invitations_invitation_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in local_var_params:
            path_params['invitation_id'] = local_var_params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/{invitation_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationinvitationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_api_v2_decorated_ha_jobs_production_job_id_get(self, production_job_id, **kwargs):  # noqa: E501
        """Get Job  # noqa: E501

        Get an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_api_v2_decorated_ha_jobs_production_job_id_get(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedproductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_api_v2_decorated_ha_jobs_production_job_id_get_with_http_info(production_job_id, **kwargs)  # noqa: E501

    def get_job_api_v2_decorated_ha_jobs_production_job_id_get_with_http_info(self, production_job_id, **kwargs):  # noqa: E501
        """Get Job  # noqa: E501

        Get an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_api_v2_decorated_ha_jobs_production_job_id_get_with_http_info(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedproductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_api_v2_decorated_ha_jobs_production_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `get_job_api_v2_decorated_ha_jobs_production_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedproductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get(self, production_job_id, **kwargs):  # noqa: E501
        """Get Job Events  # noqa: E501

        Get Production Job events  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: ID of the production job to fetch logs for. Note: This API doesn't support offset based pagination and the time filter should instead be used. (required)
        :param list[ProductionJobEventScopeFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param list[EventLevel] level: Filter by level of event
        :param str message: Filter by message of event
        :param datetime start_time: The start time for the query. If  start_time is not set, the query will use beginning of time. Non-inclusive.
        :param datetime end_time: The end time for the query. If end_time is not set, the query will use the time now. Non-inclusive.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProductionjobeventListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get_with_http_info(production_job_id, **kwargs)  # noqa: E501

    def get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get_with_http_info(self, production_job_id, **kwargs):  # noqa: E501
        """Get Job Events  # noqa: E501

        Get Production Job events  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get_with_http_info(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: ID of the production job to fetch logs for. Note: This API doesn't support offset based pagination and the time filter should instead be used. (required)
        :param list[ProductionJobEventScopeFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param list[EventLevel] level: Filter by level of event
        :param str message: Filter by message of event
        :param datetime start_time: The start time for the query. If  start_time is not set, the query will use beginning of time. Non-inclusive.
        :param datetime end_time: The end time for the query. If end_time is not set, the query will use the time now. Non-inclusive.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProductionjobeventListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id',
            'origin',
            'level',
            'message',
            'start_time',
            'end_time',
            'ascending_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_job_events_api_v2_decorated_ha_jobs_production_job_id_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []
        if 'origin' in local_var_params and local_var_params['origin'] is not None:  # noqa: E501
            query_params.append(('origin', local_var_params['origin']))  # noqa: E501
            collection_formats['origin'] = 'multi'  # noqa: E501
        if 'level' in local_var_params and local_var_params['level'] is not None:  # noqa: E501
            query_params.append(('level', local_var_params['level']))  # noqa: E501
            collection_formats['level'] = 'multi'  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'ascending_order' in local_var_params and local_var_params['ascending_order'] is not None:  # noqa: E501
            query_params.append(('ascending_order', local_var_params['ascending_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProductionjobeventListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get(self, job_id, **kwargs):  # noqa: E501
        """Get Job Logs Download V2  # noqa: E501

        Fetches the job logs of a single job run. This is a single API that supports job logs no matter if the job is still running or not.  If the job is still running, the logs will be fetched from the streaming logs s3 path. If the job is not running, the logs will be fetched from downloaded logs s3 path. If a pagination token is provided, we use the streaming logs or downloaded logs path depending on the format of the pagination token.  TODO(aguo): Implement job alive or dead detection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Job Logs Download V2  # noqa: E501

        Fetches the job logs of a single job run. This is a single API that supports job logs no matter if the job is still running or not.  If the job is still running, the logs will be fetched from the streaming logs s3 path. If the job is not running, the logs will be fetched from downloaded logs s3 path. If a pagination token is provided, we use the streaming logs or downloaded logs path depending on the format of the pagination token.  TODO(aguo): Implement job alive or dead detection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id',
            'page_size',
            'next_page_token',
            'previous_page_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'page_size' in local_var_params and local_var_params['page_size'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `page_size` when calling `get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get`, must be a value less than or equal to `1000`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'next_page_token' in local_var_params and local_var_params['next_page_token'] is not None:  # noqa: E501
            query_params.append(('next_page_token', local_var_params['next_page_token']))  # noqa: E501
        if 'previous_page_token' in local_var_params and local_var_params['previous_page_token'] is not None:  # noqa: E501
            query_params.append(('previous_page_token', local_var_params['previous_page_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/job_logs_download_v2/{job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_queue_api_v2_job_queues_job_queue_id_get(self, job_queue_id, **kwargs):  # noqa: E501
        """Get Job Queue  # noqa: E501

        Retrieves a job queue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_queue_api_v2_job_queues_job_queue_id_get(job_queue_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_queue_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedjobqueueResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_queue_api_v2_job_queues_job_queue_id_get_with_http_info(job_queue_id, **kwargs)  # noqa: E501

    def get_job_queue_api_v2_job_queues_job_queue_id_get_with_http_info(self, job_queue_id, **kwargs):  # noqa: E501
        """Get Job Queue  # noqa: E501

        Retrieves a job queue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_queue_api_v2_job_queues_job_queue_id_get_with_http_info(job_queue_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_queue_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedjobqueueResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_queue_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_queue_api_v2_job_queues_job_queue_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_queue_id' is set
        if self.api_client.client_side_validation and ('job_queue_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_queue_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_queue_id` when calling `get_job_queue_api_v2_job_queues_job_queue_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_queue_id' in local_var_params:
            path_params['job_queue_id'] = local_var_params['job_queue_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/job_queues/{job_queue_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedjobqueueResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_jobs_api_v2_dataset_runs_jobs_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs_api_v2_dataset_runs_jobs_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetJobs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_jobs_api_v2_dataset_runs_jobs_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_jobs_api_v2_dataset_runs_jobs_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs_api_v2_dataset_runs_jobs_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetJobs, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs_api_v2_dataset_runs_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_jobs_api_v2_dataset_runs_jobs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dataset_runs/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetJobs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_latest_cloud_resource_api_v2_sessions_cluster_id_latest_cloud_resource_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Latest Cloud Resource  # noqa: E501

        Fetches the last-used cloud resource for a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_latest_cloud_resource_api_v2_sessions_cluster_id_latest_cloud_resource_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_latest_cloud_resource_api_v2_sessions_cluster_id_latest_cloud_resource_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_latest_cloud_resource_api_v2_sessions_cluster_id_latest_cloud_resource_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Latest Cloud Resource  # noqa: E501

        Fetches the last-used cloud resource for a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_latest_cloud_resource_api_v2_sessions_cluster_id_latest_cloud_resource_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_latest_cloud_resource_api_v2_sessions_cluster_id_latest_cloud_resource_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_latest_cloud_resource_api_v2_sessions_cluster_id_latest_cloud_resource_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{cluster_id}/latest_cloud_resource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lb_resource_api_v2_clouds_cloud_id_get_lb_resource_post(self, cloud_id, **kwargs):  # noqa: E501
        """Get Lb Resource  # noqa: E501

        Get lb resources for the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lb_resource_api_v2_clouds_cloud_id_get_lb_resource_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LbresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_lb_resource_api_v2_clouds_cloud_id_get_lb_resource_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_lb_resource_api_v2_clouds_cloud_id_get_lb_resource_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Lb Resource  # noqa: E501

        Get lb resources for the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lb_resource_api_v2_clouds_cloud_id_get_lb_resource_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LbresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lb_resource_api_v2_clouds_cloud_id_get_lb_resource_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_lb_resource_api_v2_clouds_cloud_id_get_lb_resource_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/get_lb_resource', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post(self, cloud_id, **kwargs):  # noqa: E501
        """Get Lb Resource  # noqa: E501

        DEPRECATED. Get lb resources for the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LbresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Lb Resource  # noqa: E501

        DEPRECATED. Get lb resources for the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LbresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_gcp_router/{cloud_id}/get_lb_resource', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lb_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_lb_resource_post(self, cloud_id, **kwargs):  # noqa: E501
        """Get Lb Resource  # noqa: E501

        DEPRECATED. Get lb resources for the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lb_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_lb_resource_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LbresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_lb_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_lb_resource_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_lb_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_lb_resource_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Lb Resource  # noqa: E501

        DEPRECATED. Get lb resources for the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lb_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_lb_resource_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LbresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lb_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_lb_resource_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_lb_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_lb_resource_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_router/{cloud_id}/get_lb_resource', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lineage_api_v2_lineage_get(self, node_id, node_type, direction, **kwargs):  # noqa: E501
        """Get Lineage  # noqa: E501

        Get lineage graph for a node (1-level deep only).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lineage_api_v2_lineage_get(node_id, node_type, direction, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str node_id: ID of the lineage node (required)
        :param LineageNodeType node_type: Type of node (ARTIFACT, WORKLOAD) (required)
        :param LineageDirection direction: Lineage direction (IN, OUT, BIDIR) (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LineagegraphResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_lineage_api_v2_lineage_get_with_http_info(node_id, node_type, direction, **kwargs)  # noqa: E501

    def get_lineage_api_v2_lineage_get_with_http_info(self, node_id, node_type, direction, **kwargs):  # noqa: E501
        """Get Lineage  # noqa: E501

        Get lineage graph for a node (1-level deep only).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lineage_api_v2_lineage_get_with_http_info(node_id, node_type, direction, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str node_id: ID of the lineage node (required)
        :param LineageNodeType node_type: Type of node (ARTIFACT, WORKLOAD) (required)
        :param LineageDirection direction: Lineage direction (IN, OUT, BIDIR) (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LineagegraphResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'node_id',
            'node_type',
            'direction'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lineage_api_v2_lineage_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'node_id' is set
        if self.api_client.client_side_validation and ('node_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['node_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_id` when calling `get_lineage_api_v2_lineage_get`")  # noqa: E501
        # verify the required parameter 'node_type' is set
        if self.api_client.client_side_validation and ('node_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['node_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_type` when calling `get_lineage_api_v2_lineage_get`")  # noqa: E501
        # verify the required parameter 'direction' is set
        if self.api_client.client_side_validation and ('direction' not in local_var_params or  # noqa: E501
                                                        local_var_params['direction'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `direction` when calling `get_lineage_api_v2_lineage_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'node_id' in local_var_params and local_var_params['node_id'] is not None:  # noqa: E501
            query_params.append(('node_id', local_var_params['node_id']))  # noqa: E501
        if 'node_type' in local_var_params and local_var_params['node_type'] is not None:  # noqa: E501
            query_params.append(('node_type', local_var_params['node_type']))  # noqa: E501
        if 'direction' in local_var_params and local_var_params['direction'] is not None:  # noqa: E501
            query_params.append(('direction', local_var_params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lineage/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LineagegraphResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lineage_artifact_api_v2_lineage_artifacts_artifact_id_get(self, artifact_id, **kwargs):  # noqa: E501
        """Get Lineage Artifact  # noqa: E501

        Get details of an Anyscale tracked artifact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lineage_artifact_api_v2_lineage_artifacts_artifact_id_get(artifact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str artifact_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LineageartifactResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_lineage_artifact_api_v2_lineage_artifacts_artifact_id_get_with_http_info(artifact_id, **kwargs)  # noqa: E501

    def get_lineage_artifact_api_v2_lineage_artifacts_artifact_id_get_with_http_info(self, artifact_id, **kwargs):  # noqa: E501
        """Get Lineage Artifact  # noqa: E501

        Get details of an Anyscale tracked artifact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lineage_artifact_api_v2_lineage_artifacts_artifact_id_get_with_http_info(artifact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str artifact_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LineageartifactResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'artifact_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lineage_artifact_api_v2_lineage_artifacts_artifact_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'artifact_id' is set
        if self.api_client.client_side_validation and ('artifact_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['artifact_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `artifact_id` when calling `get_lineage_artifact_api_v2_lineage_artifacts_artifact_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'artifact_id' in local_var_params:
            path_params['artifact_id'] = local_var_params['artifact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lineage/artifacts/{artifact_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LineageartifactResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lineage_workload_api_v2_lineage_workloads_workload_id_get(self, workload_id, **kwargs):  # noqa: E501
        """Get Lineage Workload  # noqa: E501

        Get details of an Anyscale tracked workload.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lineage_workload_api_v2_lineage_workloads_workload_id_get(workload_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workload_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LineageworkloadResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_lineage_workload_api_v2_lineage_workloads_workload_id_get_with_http_info(workload_id, **kwargs)  # noqa: E501

    def get_lineage_workload_api_v2_lineage_workloads_workload_id_get_with_http_info(self, workload_id, **kwargs):  # noqa: E501
        """Get Lineage Workload  # noqa: E501

        Get details of an Anyscale tracked workload.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lineage_workload_api_v2_lineage_workloads_workload_id_get_with_http_info(workload_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workload_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LineageworkloadResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workload_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lineage_workload_api_v2_lineage_workloads_workload_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workload_id' is set
        if self.api_client.client_side_validation and ('workload_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workload_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workload_id` when calling `get_lineage_workload_api_v2_lineage_workloads_workload_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workload_id' in local_var_params:
            path_params['workload_id'] = local_var_params['workload_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lineage/workloads/{workload_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LineageworkloadResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_files_api_v2_logs_get_log_files_post(self, **kwargs):  # noqa: E501
        """Get Log Files  # noqa: E501

        API for downloading logs of a session.   This is a paginated api, which means that a single call to this will result in one page of results (log files).  The page size and next page token (in LogDownloadRequest) can be used to list all log files, either iteratively or in a single go.   Parameters  ---------- log_download_request: LogDownloadRequest      Parameters to filter logs and control download. This is read from the request body.   Returns  -------  Response[LogDownloadResult]      List of logs files, with their presigned URL and next page token if there are more results.   Raises  ------  HTTPException(400)      If the user is using a cloud provider (currently non-AWS) that does not support this feature.   HTTPException(403)      If the user does not have access to the session.   HTTPException(404)      If the session or cloud could not be found in the DB.   HTTPException(500)      If there are any other errors while downloading logs.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_files_api_v2_logs_get_log_files_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LogDownloadRequest log_download_request:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_log_files_api_v2_logs_get_log_files_post_with_http_info(**kwargs)  # noqa: E501

    def get_log_files_api_v2_logs_get_log_files_post_with_http_info(self, **kwargs):  # noqa: E501
        """Get Log Files  # noqa: E501

        API for downloading logs of a session.   This is a paginated api, which means that a single call to this will result in one page of results (log files).  The page size and next page token (in LogDownloadRequest) can be used to list all log files, either iteratively or in a single go.   Parameters  ---------- log_download_request: LogDownloadRequest      Parameters to filter logs and control download. This is read from the request body.   Returns  -------  Response[LogDownloadResult]      List of logs files, with their presigned URL and next page token if there are more results.   Raises  ------  HTTPException(400)      If the user is using a cloud provider (currently non-AWS) that does not support this feature.   HTTPException(403)      If the user does not have access to the session.   HTTPException(404)      If the session or cloud could not be found in the DB.   HTTPException(500)      If there are any other errors while downloading logs.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_files_api_v2_logs_get_log_files_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LogDownloadRequest log_download_request:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'log_download_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_files_api_v2_logs_get_log_files_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_download_request' in local_var_params:
            body_params = local_var_params['log_download_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/get_log_files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get(self, **kwargs):  # noqa: E501
        """Get Manage Billing Url  # noqa: E501

        Returns URL to manage/edit billing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get_with_http_info(**kwargs)  # noqa: E501

    def get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Manage Billing Url  # noqa: E501

        Returns URL to manage/edit billing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/manage_billing_url', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metric_names_api_v2_metrics_names_get(self, **kwargs):  # noqa: E501
        """Get Metric Names  # noqa: E501

        Return all available metric names for the specified resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metric_names_api_v2_metrics_names_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: The cluster id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param float start: Optional start timestamp (Unix). If provided, filters metric names to those present in [start, end].
        :param float end: Optional end timestamp (Unix). If provided with start, filters metric names present in [start, end].
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MetricsqueryresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_metric_names_api_v2_metrics_names_get_with_http_info(**kwargs)  # noqa: E501

    def get_metric_names_api_v2_metrics_names_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Metric Names  # noqa: E501

        Return all available metric names for the specified resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metric_names_api_v2_metrics_names_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: The cluster id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param float start: Optional start timestamp (Unix). If provided, filters metric names to those present in [start, end].
        :param float end: Optional end timestamp (Unix). If provided with start, filters metric names present in [start, end].
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MetricsqueryresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'workspace_id',
            'ha_job_id',
            'service_id',
            'start',
            'end'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metric_names_api_v2_metrics_names_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'service_id' in local_var_params and local_var_params['service_id'] is not None:  # noqa: E501
            query_params.append(('service_id', local_var_params['service_id']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/metrics/names', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetricsqueryresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metrics_for_nodes_api_v2_cluster_dashboard_metrics_get(self, cluster_id, node_ids, **kwargs):  # noqa: E501
        """Get Metrics For Nodes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metrics_for_nodes_api_v2_cluster_dashboard_metrics_get(cluster_id, node_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: The ID of the cluster to fetch metrics for. (required)
        :param list[str] node_ids: The IDs of the nodes to fetch metrics for. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NodemetricsresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_metrics_for_nodes_api_v2_cluster_dashboard_metrics_get_with_http_info(cluster_id, node_ids, **kwargs)  # noqa: E501

    def get_metrics_for_nodes_api_v2_cluster_dashboard_metrics_get_with_http_info(self, cluster_id, node_ids, **kwargs):  # noqa: E501
        """Get Metrics For Nodes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metrics_for_nodes_api_v2_cluster_dashboard_metrics_get_with_http_info(cluster_id, node_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: The ID of the cluster to fetch metrics for. (required)
        :param list[str] node_ids: The IDs of the nodes to fetch metrics for. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NodemetricsresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'node_ids'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metrics_for_nodes_api_v2_cluster_dashboard_metrics_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_metrics_for_nodes_api_v2_cluster_dashboard_metrics_get`")  # noqa: E501
        # verify the required parameter 'node_ids' is set
        if self.api_client.client_side_validation and ('node_ids' not in local_var_params or  # noqa: E501
                                                        local_var_params['node_ids'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_ids` when calling `get_metrics_for_nodes_api_v2_cluster_dashboard_metrics_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'node_ids' in local_var_params and local_var_params['node_ids'] is not None:  # noqa: E501
            query_params.append(('node_ids', local_var_params['node_ids']))  # noqa: E501
            collection_formats['node_ids'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cluster_dashboard/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodemetricsresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metronome_customer_info_api_v2_metronome_customer_info_organization_id_get(self, organization_id, **kwargs):  # noqa: E501
        """Get Metronome Customer Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_customer_info_api_v2_metronome_customer_info_organization_id_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MetronomecustomerinfomodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_metronome_customer_info_api_v2_metronome_customer_info_organization_id_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def get_metronome_customer_info_api_v2_metronome_customer_info_organization_id_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Get Metronome Customer Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_customer_info_api_v2_metronome_customer_info_organization_id_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MetronomecustomerinfomodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metronome_customer_info_api_v2_metronome_customer_info_organization_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `get_metronome_customer_info_api_v2_metronome_customer_info_organization_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/metronome_customer_info/{organization_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetronomecustomerinfomodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get(self, dashboard_type, **kwargs):  # noqa: E501
        """Get Metronome Embedded Usage Dashboard  # noqa: E501

        Returns the url to the Metronome embedded invoices dashboard if it exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get(dashboard_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param MetronomeDashboardType dashboard_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(dashboard_type, **kwargs)  # noqa: E501

    def get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(self, dashboard_type, **kwargs):  # noqa: E501
        """Get Metronome Embedded Usage Dashboard  # noqa: E501

        Returns the url to the Metronome embedded invoices dashboard if it exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(dashboard_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param MetronomeDashboardType dashboard_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'dashboard_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_type' is set
        if self.api_client.client_side_validation and ('dashboard_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['dashboard_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_type` when calling `get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_type' in local_var_params:
            path_params['dashboard_type'] = local_var_params['dashboard_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/metronome_embedded_dashboard_url/{dashboard_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get(self, organization_id, dashboard_type, **kwargs):  # noqa: E501
        """Get Metronome Embedded Usage Dashboard By Organization  # noqa: E501

        Returns the url to the Metronome embedded invoices dashboard if it exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get(organization_id, dashboard_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param MetronomeDashboardType dashboard_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(organization_id, dashboard_type, **kwargs)  # noqa: E501

    def get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(self, organization_id, dashboard_type, **kwargs):  # noqa: E501
        """Get Metronome Embedded Usage Dashboard By Organization  # noqa: E501

        Returns the url to the Metronome embedded invoices dashboard if it exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(organization_id, dashboard_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param MetronomeDashboardType dashboard_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id',
            'dashboard_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get`")  # noqa: E501
        # verify the required parameter 'dashboard_type' is set
        if self.api_client.client_side_validation and ('dashboard_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['dashboard_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_type` when calling `get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501
        if 'dashboard_type' in local_var_params:
            path_params['dashboard_type'] = local_var_params['dashboard_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/{organization_id}/metronome_embedded_dashboard_url/{dashboard_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_api_v2_llm_models_model_id_get(self, model_id, **kwargs):  # noqa: E501
        """Get Model  # noqa: E501

        Retrieves a model from the model registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_api_v2_llm_models_model_id_get(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FinetunedmodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_model_api_v2_llm_models_model_id_get_with_http_info(model_id, **kwargs)  # noqa: E501

    def get_model_api_v2_llm_models_model_id_get_with_http_info(self, model_id, **kwargs):  # noqa: E501
        """Get Model  # noqa: E501

        Retrieves a model from the model registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_api_v2_llm_models_model_id_get_with_http_info(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FinetunedmodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'model_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_api_v2_llm_models_model_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_id' is set
        if self.api_client.client_side_validation and ('model_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['model_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_id` when calling `get_model_api_v2_llm_models_model_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_id' in local_var_params:
            path_params['model_id'] = local_var_params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/llm/models/{model_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FinetunedmodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_by_job_id_api_v2_llm_models_get_by_job_id_job_id_get(self, job_id, **kwargs):  # noqa: E501
        """Get Model By Job Id  # noqa: E501

        Retrieves a model from the model registry by job id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_by_job_id_api_v2_llm_models_get_by_job_id_job_id_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FinetunedmodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_model_by_job_id_api_v2_llm_models_get_by_job_id_job_id_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_model_by_job_id_api_v2_llm_models_get_by_job_id_job_id_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Model By Job Id  # noqa: E501

        Retrieves a model from the model registry by job id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_by_job_id_api_v2_llm_models_get_by_job_id_job_id_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FinetunedmodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_by_job_id_api_v2_llm_models_get_by_job_id_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_model_by_job_id_api_v2_llm_models_get_by_job_id_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/llm/models/get_by_job_id/{job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FinetunedmodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_api_v2_cluster_dashboard_node_id_get(self, node_id, cluster_id, **kwargs):  # noqa: E501
        """Get Node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_api_v2_cluster_dashboard_node_id_get(node_id, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str node_id: (required)
        :param str cluster_id: (required)
        :param str session_name: The name of the session to the node belongs to.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterdashboardnodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_node_api_v2_cluster_dashboard_node_id_get_with_http_info(node_id, cluster_id, **kwargs)  # noqa: E501

    def get_node_api_v2_cluster_dashboard_node_id_get_with_http_info(self, node_id, cluster_id, **kwargs):  # noqa: E501
        """Get Node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_api_v2_cluster_dashboard_node_id_get_with_http_info(node_id, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str node_id: (required)
        :param str cluster_id: (required)
        :param str session_name: The name of the session to the node belongs to.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterdashboardnodeResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'node_id',
            'cluster_id',
            'session_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_api_v2_cluster_dashboard_node_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'node_id' is set
        if self.api_client.client_side_validation and ('node_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['node_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_id` when calling `get_node_api_v2_cluster_dashboard_node_id_get`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_node_api_v2_cluster_dashboard_node_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in local_var_params:
            path_params['node_id'] = local_var_params['node_id']  # noqa: E501

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'session_name' in local_var_params and local_var_params['session_name'] is not None:  # noqa: E501
            query_params.append(('session_name', local_var_params['session_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cluster_dashboard/{node_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterdashboardnodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nodes_api_v2_cluster_dashboard_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Nodes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nodes_api_v2_cluster_dashboard_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str session_name: The name of the session to fetch nodes for.
        :param str text_filter: The text to filter the nodes by. Search for case-insensitive substring match in node id, name, node_ip, labels, or resources.
        :param list[NodeStatus] states_filter: The states to filter the nodes by.
        :param int page: The page number to fetch.
        :param int page_size: The number of nodes to fetch per page.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterdashboardnodeListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_nodes_api_v2_cluster_dashboard_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_nodes_api_v2_cluster_dashboard_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Nodes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nodes_api_v2_cluster_dashboard_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str session_name: The name of the session to fetch nodes for.
        :param str text_filter: The text to filter the nodes by. Search for case-insensitive substring match in node id, name, node_ip, labels, or resources.
        :param list[NodeStatus] states_filter: The states to filter the nodes by.
        :param int page: The page number to fetch.
        :param int page_size: The number of nodes to fetch per page.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterdashboardnodeListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'session_name',
            'text_filter',
            'states_filter',
            'page',
            'page_size'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nodes_api_v2_cluster_dashboard_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_nodes_api_v2_cluster_dashboard_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'session_name' in local_var_params and local_var_params['session_name'] is not None:  # noqa: E501
            query_params.append(('session_name', local_var_params['session_name']))  # noqa: E501
        if 'text_filter' in local_var_params and local_var_params['text_filter'] is not None:  # noqa: E501
            query_params.append(('text_filter', local_var_params['text_filter']))  # noqa: E501
        if 'states_filter' in local_var_params and local_var_params['states_filter'] is not None:  # noqa: E501
            query_params.append(('states_filter', local_var_params['states_filter']))  # noqa: E501
            collection_formats['states_filter'] = 'multi'  # noqa: E501
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cluster_dashboard/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterdashboardnodeListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_oauth_login_url_api_v2_integrations_oauth_login_get(self, integration_id, **kwargs):  # noqa: E501
        """Get Oauth Login Url  # noqa: E501

        Generate OAuth authorization URL with PKCE for third party integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oauth_login_url_api_v2_integrations_oauth_login_get(integration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str integration_id: ID of the registered third party integration connection (required)
        :param bool validation: Whether this is a validation flow for the connection
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OauthAuthUrlResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_oauth_login_url_api_v2_integrations_oauth_login_get_with_http_info(integration_id, **kwargs)  # noqa: E501

    def get_oauth_login_url_api_v2_integrations_oauth_login_get_with_http_info(self, integration_id, **kwargs):  # noqa: E501
        """Get Oauth Login Url  # noqa: E501

        Generate OAuth authorization URL with PKCE for third party integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oauth_login_url_api_v2_integrations_oauth_login_get_with_http_info(integration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str integration_id: ID of the registered third party integration connection (required)
        :param bool validation: Whether this is a validation flow for the connection
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OauthAuthUrlResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'integration_id',
            'validation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_oauth_login_url_api_v2_integrations_oauth_login_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'integration_id' is set
        if self.api_client.client_side_validation and ('integration_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['integration_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `integration_id` when calling `get_oauth_login_url_api_v2_integrations_oauth_login_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'integration_id' in local_var_params and local_var_params['integration_id'] is not None:  # noqa: E501
            query_params.append(('integration_id', local_var_params['integration_id']))  # noqa: E501
        if 'validation' in local_var_params and local_var_params['validation'] is not None:  # noqa: E501
            query_params.append(('validation', local_var_params['validation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/oauth/login', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OauthAuthUrlResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_operator_events_api_v2_dataset_runs_operator_events_get(self, cluster_id, session_name, dataset_id, operator_id, **kwargs):  # noqa: E501
        """Get Operator Events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_operator_events_api_v2_dataset_runs_operator_events_get(cluster_id, session_name, dataset_id, operator_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str session_name: (required)
        :param str dataset_id: (required)
        :param str operator_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OperatorEventResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_operator_events_api_v2_dataset_runs_operator_events_get_with_http_info(cluster_id, session_name, dataset_id, operator_id, **kwargs)  # noqa: E501

    def get_operator_events_api_v2_dataset_runs_operator_events_get_with_http_info(self, cluster_id, session_name, dataset_id, operator_id, **kwargs):  # noqa: E501
        """Get Operator Events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_operator_events_api_v2_dataset_runs_operator_events_get_with_http_info(cluster_id, session_name, dataset_id, operator_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str session_name: (required)
        :param str dataset_id: (required)
        :param str operator_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OperatorEventResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'session_name',
            'dataset_id',
            'operator_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_operator_events_api_v2_dataset_runs_operator_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_operator_events_api_v2_dataset_runs_operator_events_get`")  # noqa: E501
        # verify the required parameter 'session_name' is set
        if self.api_client.client_side_validation and ('session_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_name` when calling `get_operator_events_api_v2_dataset_runs_operator_events_get`")  # noqa: E501
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and ('dataset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `get_operator_events_api_v2_dataset_runs_operator_events_get`")  # noqa: E501
        # verify the required parameter 'operator_id' is set
        if self.api_client.client_side_validation and ('operator_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['operator_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `operator_id` when calling `get_operator_events_api_v2_dataset_runs_operator_events_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'session_name' in local_var_params and local_var_params['session_name'] is not None:  # noqa: E501
            query_params.append(('session_name', local_var_params['session_name']))  # noqa: E501
        if 'dataset_id' in local_var_params and local_var_params['dataset_id'] is not None:  # noqa: E501
            query_params.append(('dataset_id', local_var_params['dataset_id']))  # noqa: E501
        if 'operator_id' in local_var_params and local_var_params['operator_id'] is not None:  # noqa: E501
            query_params.append(('operator_id', local_var_params['operator_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dataset_runs/operator_events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OperatorEventResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_operator_metrics_api_v2_dataset_runs_operator_get(self, cluster_id, session_name, dataset_id, operator_id, dataset_start_time, dataset_end_time, **kwargs):  # noqa: E501
        """Get Operator Metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_operator_metrics_api_v2_dataset_runs_operator_get(cluster_id, session_name, dataset_id, operator_id, dataset_start_time, dataset_end_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str session_name: (required)
        :param str dataset_id: (required)
        :param str operator_id: (required)
        :param float dataset_start_time: (required)
        :param float dataset_end_time: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OperatorMetrics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_operator_metrics_api_v2_dataset_runs_operator_get_with_http_info(cluster_id, session_name, dataset_id, operator_id, dataset_start_time, dataset_end_time, **kwargs)  # noqa: E501

    def get_operator_metrics_api_v2_dataset_runs_operator_get_with_http_info(self, cluster_id, session_name, dataset_id, operator_id, dataset_start_time, dataset_end_time, **kwargs):  # noqa: E501
        """Get Operator Metrics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_operator_metrics_api_v2_dataset_runs_operator_get_with_http_info(cluster_id, session_name, dataset_id, operator_id, dataset_start_time, dataset_end_time, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str session_name: (required)
        :param str dataset_id: (required)
        :param str operator_id: (required)
        :param float dataset_start_time: (required)
        :param float dataset_end_time: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OperatorMetrics, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'session_name',
            'dataset_id',
            'operator_id',
            'dataset_start_time',
            'dataset_end_time'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_operator_metrics_api_v2_dataset_runs_operator_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_operator_metrics_api_v2_dataset_runs_operator_get`")  # noqa: E501
        # verify the required parameter 'session_name' is set
        if self.api_client.client_side_validation and ('session_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_name` when calling `get_operator_metrics_api_v2_dataset_runs_operator_get`")  # noqa: E501
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and ('dataset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `get_operator_metrics_api_v2_dataset_runs_operator_get`")  # noqa: E501
        # verify the required parameter 'operator_id' is set
        if self.api_client.client_side_validation and ('operator_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['operator_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `operator_id` when calling `get_operator_metrics_api_v2_dataset_runs_operator_get`")  # noqa: E501
        # verify the required parameter 'dataset_start_time' is set
        if self.api_client.client_side_validation and ('dataset_start_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_start_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_start_time` when calling `get_operator_metrics_api_v2_dataset_runs_operator_get`")  # noqa: E501
        # verify the required parameter 'dataset_end_time' is set
        if self.api_client.client_side_validation and ('dataset_end_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_end_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_end_time` when calling `get_operator_metrics_api_v2_dataset_runs_operator_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'session_name' in local_var_params and local_var_params['session_name'] is not None:  # noqa: E501
            query_params.append(('session_name', local_var_params['session_name']))  # noqa: E501
        if 'dataset_id' in local_var_params and local_var_params['dataset_id'] is not None:  # noqa: E501
            query_params.append(('dataset_id', local_var_params['dataset_id']))  # noqa: E501
        if 'operator_id' in local_var_params and local_var_params['operator_id'] is not None:  # noqa: E501
            query_params.append(('operator_id', local_var_params['operator_id']))  # noqa: E501
        if 'dataset_start_time' in local_var_params and local_var_params['dataset_start_time'] is not None:  # noqa: E501
            query_params.append(('dataset_start_time', local_var_params['dataset_start_time']))  # noqa: E501
        if 'dataset_end_time' in local_var_params and local_var_params['dataset_end_time'] is not None:  # noqa: E501
            query_params.append(('dataset_end_time', local_var_params['dataset_end_time']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dataset_runs/operator', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OperatorMetrics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_or_create_build_from_image_uri_api_v2_builds_get_or_create_build_from_image_uri_post(self, get_or_create_build_from_image_uri_request, **kwargs):  # noqa: E501
        """Get Or Create Build From Image Uri  # noqa: E501

        Gets or creates a build from an image uri.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_or_create_build_from_image_uri_api_v2_builds_get_or_create_build_from_image_uri_post(get_or_create_build_from_image_uri_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param GetOrCreateBuildFromImageUriRequest get_or_create_build_from_image_uri_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedbuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_or_create_build_from_image_uri_api_v2_builds_get_or_create_build_from_image_uri_post_with_http_info(get_or_create_build_from_image_uri_request, **kwargs)  # noqa: E501

    def get_or_create_build_from_image_uri_api_v2_builds_get_or_create_build_from_image_uri_post_with_http_info(self, get_or_create_build_from_image_uri_request, **kwargs):  # noqa: E501
        """Get Or Create Build From Image Uri  # noqa: E501

        Gets or creates a build from an image uri.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_or_create_build_from_image_uri_api_v2_builds_get_or_create_build_from_image_uri_post_with_http_info(get_or_create_build_from_image_uri_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param GetOrCreateBuildFromImageUriRequest get_or_create_build_from_image_uri_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedbuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'get_or_create_build_from_image_uri_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_or_create_build_from_image_uri_api_v2_builds_get_or_create_build_from_image_uri_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'get_or_create_build_from_image_uri_request' is set
        if self.api_client.client_side_validation and ('get_or_create_build_from_image_uri_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['get_or_create_build_from_image_uri_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `get_or_create_build_from_image_uri_request` when calling `get_or_create_build_from_image_uri_api_v2_builds_get_or_create_build_from_image_uri_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_or_create_build_from_image_uri_request' in local_var_params:
            body_params = local_var_params['get_or_create_build_from_image_uri_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/get_or_create_build_from_image_uri', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedbuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get(self, **kwargs):  # noqa: E501
        """Get Organization Metronome Usage Alerts  # noqa: E501

        Return the current status of alerts regarding organization's usage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationusagealertListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get_with_http_info(**kwargs)  # noqa: E501

    def get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Organization Metronome Usage Alerts  # noqa: E501

        Return the current status of alerts regarding organization's usage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationusagealertListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationusagealertListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_plan_status_api_v2_organization_billing_plan_status_get(self, **kwargs):  # noqa: E501
        """Get Plan Status  # noqa: E501

        Returns the plan status for this user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_plan_status_api_v2_organization_billing_plan_status_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PlanStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_plan_status_api_v2_organization_billing_plan_status_get_with_http_info(**kwargs)  # noqa: E501

    def get_plan_status_api_v2_organization_billing_plan_status_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Plan Status  # noqa: E501

        Returns the plan status for this user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_plan_status_api_v2_organization_billing_plan_status_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PlanStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_plan_status_api_v2_organization_billing_plan_status_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/plan_status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlanStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_api_v2_projects_project_id_get(self, project_id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_api_v2_projects_project_id_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_api_v2_projects_project_id_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_project_api_v2_projects_project_id_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_api_v2_projects_project_id_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_api_v2_projects_project_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_project_api_v2_projects_project_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_default_session_name_api_v2_projects_project_id_default_session_name_get(self, project_id, **kwargs):  # noqa: E501
        """Get Project Default Session Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_default_session_name_api_v2_projects_project_id_default_session_name_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectdefaultsessionnameResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_default_session_name_api_v2_projects_project_id_default_session_name_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_project_default_session_name_api_v2_projects_project_id_default_session_name_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get Project Default Session Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_default_session_name_api_v2_projects_project_id_default_session_name_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectdefaultsessionnameResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_default_session_name_api_v2_projects_project_id_default_session_name_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_project_default_session_name_api_v2_projects_project_id_default_session_name_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/default_session_name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectdefaultsessionnameResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get(self, **kwargs):  # noqa: E501
        """Get Recent Cluster Compute Configs  # noqa: E501

        Retrieves recently used cluster compute configs for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MinicomputetemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get_with_http_info(**kwargs)  # noqa: E501

    def get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Recent Cluster Compute Configs  # noqa: E501

        Retrieves recently used cluster compute configs for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MinicomputetemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/recent_activity/cluster_compute_configs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MinicomputetemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get(self, **kwargs):  # noqa: E501
        """Get Recent Cluster Environments  # noqa: E501

        Retrieves recently used cluster environment for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MinibuildListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get_with_http_info(**kwargs)  # noqa: E501

    def get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Recent Cluster Environments  # noqa: E501

        Retrieves recently used cluster environment for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MinibuildListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/recent_activity/cluster_environment_builds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MinibuildListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_regions_and_zones_api_v2_aws_info_regions_and_zones_get(self, **kwargs):  # noqa: E501
        """Get Regions And Zones  # noqa: E501

        Retrieve the available regions and availability zones for AWS  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_regions_and_zones_api_v2_aws_info_regions_and_zones_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AwsregionandzonesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_regions_and_zones_api_v2_aws_info_regions_and_zones_get_with_http_info(**kwargs)  # noqa: E501

    def get_regions_and_zones_api_v2_aws_info_regions_and_zones_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Regions And Zones  # noqa: E501

        Retrieve the available regions and availability zones for AWS  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_regions_and_zones_api_v2_aws_info_regions_and_zones_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AwsregionandzonesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_regions_and_zones_api_v2_aws_info_regions_and_zones_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aws_info/regions_and_zones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AwsregionandzonesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get(self, **kwargs):  # noqa: E501
        """Get Regions And Zones  # noqa: E501

        Retrieve the available regions and availability zones for GCP  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudregionandzonesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get_with_http_info(**kwargs)  # noqa: E501

    def get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Regions And Zones  # noqa: E501

        Retrieve the available regions and availability zones for GCP  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudregionandzonesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/gcp/regions_and_zones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudregionandzonesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_notification_api_v2_resource_notifications_resource_notification_id_get(self, resource_notification_id, **kwargs):  # noqa: E501
        """Get Resource Notification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_notification_api_v2_resource_notifications_resource_notification_id_get(resource_notification_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_notification_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcenotificationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_notification_api_v2_resource_notifications_resource_notification_id_get_with_http_info(resource_notification_id, **kwargs)  # noqa: E501

    def get_resource_notification_api_v2_resource_notifications_resource_notification_id_get_with_http_info(self, resource_notification_id, **kwargs):  # noqa: E501
        """Get Resource Notification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_notification_api_v2_resource_notifications_resource_notification_id_get_with_http_info(resource_notification_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_notification_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcenotificationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_notification_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_notification_api_v2_resource_notifications_resource_notification_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_notification_id' is set
        if self.api_client.client_side_validation and ('resource_notification_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_notification_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_notification_id` when calling `get_resource_notification_api_v2_resource_notifications_resource_notification_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_notification_id' in local_var_params:
            path_params['resource_notification_id'] = local_var_params['resource_notification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_notifications/{resource_notification_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcenotificationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_policy_api_v2_policy_resource_type_resource_id_get(self, resource_type, resource_id, **kwargs):  # noqa: E501
        """Get Resource Policy  # noqa: E501

        Get user group permission policy for a specific resource.  Parameters: - **resource_type**: Resource type (cloud, project, organization) - **resource_id**: Resource ID (e.g. cld_abc123, prj_xyz789).   For organization type, this parameter is ignored - your own organization is used.  Returns: ``` {     \"result\": {         \"bindings\": [             {\"role_name\": \"write\", \"principals\": [\"ug_abc123\"]},             {\"role_name\": \"readonly\", \"principals\": [\"ug_def456\", \"ug_ghi789\"]}         ]     } } ```  Permission requirements: - Caller must have read access to the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_policy_api_v2_policy_resource_type_resource_id_get(resource_type, resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResourceType resource_type: (required)
        :param str resource_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PolicyresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_policy_api_v2_policy_resource_type_resource_id_get_with_http_info(resource_type, resource_id, **kwargs)  # noqa: E501

    def get_resource_policy_api_v2_policy_resource_type_resource_id_get_with_http_info(self, resource_type, resource_id, **kwargs):  # noqa: E501
        """Get Resource Policy  # noqa: E501

        Get user group permission policy for a specific resource.  Parameters: - **resource_type**: Resource type (cloud, project, organization) - **resource_id**: Resource ID (e.g. cld_abc123, prj_xyz789).   For organization type, this parameter is ignored - your own organization is used.  Returns: ``` {     \"result\": {         \"bindings\": [             {\"role_name\": \"write\", \"principals\": [\"ug_abc123\"]},             {\"role_name\": \"readonly\", \"principals\": [\"ug_def456\", \"ug_ghi789\"]}         ]     } } ```  Permission requirements: - Caller must have read access to the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_policy_api_v2_policy_resource_type_resource_id_get_with_http_info(resource_type, resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResourceType resource_type: (required)
        :param str resource_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PolicyresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_type',
            'resource_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_policy_api_v2_policy_resource_type_resource_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_type' is set
        if self.api_client.client_side_validation and ('resource_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_type` when calling `get_resource_policy_api_v2_policy_resource_type_resource_id_get`")  # noqa: E501
        # verify the required parameter 'resource_id' is set
        if self.api_client.client_side_validation and ('resource_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_id` when calling `get_resource_policy_api_v2_policy_resource_type_resource_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_type' in local_var_params:
            path_params['resource_type'] = local_var_params['resource_type']  # noqa: E501
        if 'resource_id' in local_var_params:
            path_params['resource_id'] = local_var_params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/policy/{resource_type}/{resource_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PolicyresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_quota_api_v2_resource_quotas_resource_quota_id_get(self, resource_quota_id, **kwargs):  # noqa: E501
        """Get Resource Quota  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_quota_api_v2_resource_quotas_resource_quota_id_get(resource_quota_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_quota_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcequotaResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_quota_api_v2_resource_quotas_resource_quota_id_get_with_http_info(resource_quota_id, **kwargs)  # noqa: E501

    def get_resource_quota_api_v2_resource_quotas_resource_quota_id_get_with_http_info(self, resource_quota_id, **kwargs):  # noqa: E501
        """Get Resource Quota  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_quota_api_v2_resource_quotas_resource_quota_id_get_with_http_info(resource_quota_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_quota_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcequotaResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_quota_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_quota_api_v2_resource_quotas_resource_quota_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_quota_id' is set
        if self.api_client.client_side_validation and ('resource_quota_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_quota_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_quota_id` when calling `get_resource_quota_api_v2_resource_quotas_resource_quota_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_quota_id' in local_var_params:
            path_params['resource_quota_id'] = local_var_params['resource_quota_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_quotas/{resource_quota_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcequotaResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_root_cause_for_job_api_v2_iknow_get(self, ha_job_id, **kwargs):  # noqa: E501
        """Get Root Cause For Job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_root_cause_for_job_api_v2_iknow_get(ha_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ha_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: IKnowResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_root_cause_for_job_api_v2_iknow_get_with_http_info(ha_job_id, **kwargs)  # noqa: E501

    def get_root_cause_for_job_api_v2_iknow_get_with_http_info(self, ha_job_id, **kwargs):  # noqa: E501
        """Get Root Cause For Job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_root_cause_for_job_api_v2_iknow_get_with_http_info(ha_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ha_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(IKnowResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'ha_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_root_cause_for_job_api_v2_iknow_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ha_job_id' is set
        if self.api_client.client_side_validation and ('ha_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ha_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ha_job_id` when calling `get_root_cause_for_job_api_v2_iknow_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/iknow/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IKnowResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sensitive_message_presigned_url_api_v2_decorated_ha_jobs_production_job_id_events_ha_job_event_id_sensitive_message_presigned_url_get(self, production_job_id, ha_job_event_id, **kwargs):  # noqa: E501
        """Get Sensitive Message Presigned Url  # noqa: E501

        Get the presigned url for the sensitive message details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sensitive_message_presigned_url_api_v2_decorated_ha_jobs_production_job_id_events_ha_job_event_id_sensitive_message_presigned_url_get(production_job_id, ha_job_event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param str ha_job_event_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PresignedUrlResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_sensitive_message_presigned_url_api_v2_decorated_ha_jobs_production_job_id_events_ha_job_event_id_sensitive_message_presigned_url_get_with_http_info(production_job_id, ha_job_event_id, **kwargs)  # noqa: E501

    def get_sensitive_message_presigned_url_api_v2_decorated_ha_jobs_production_job_id_events_ha_job_event_id_sensitive_message_presigned_url_get_with_http_info(self, production_job_id, ha_job_event_id, **kwargs):  # noqa: E501
        """Get Sensitive Message Presigned Url  # noqa: E501

        Get the presigned url for the sensitive message details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sensitive_message_presigned_url_api_v2_decorated_ha_jobs_production_job_id_events_ha_job_event_id_sensitive_message_presigned_url_get_with_http_info(production_job_id, ha_job_event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param str ha_job_event_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PresignedUrlResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id',
            'ha_job_event_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sensitive_message_presigned_url_api_v2_decorated_ha_jobs_production_job_id_events_ha_job_event_id_sensitive_message_presigned_url_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `get_sensitive_message_presigned_url_api_v2_decorated_ha_jobs_production_job_id_events_ha_job_event_id_sensitive_message_presigned_url_get`")  # noqa: E501
        # verify the required parameter 'ha_job_event_id' is set
        if self.api_client.client_side_validation and ('ha_job_event_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ha_job_event_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ha_job_event_id` when calling `get_sensitive_message_presigned_url_api_v2_decorated_ha_jobs_production_job_id_events_ha_job_event_id_sensitive_message_presigned_url_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501
        if 'ha_job_event_id' in local_var_params:
            path_params['ha_job_event_id'] = local_var_params['ha_job_event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}/events/{ha_job_event_id}/sensitive_message_presigned_url', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PresignedUrlResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Serve Logs Download  # noqa: E501

        Fetches the serve controller logs of the cluster. The logs will be fetched from the streaming logs s3 bucket.  If a pagination token is provided, we use the streaming logs or downloaded logs bucket depending on the format of the pagination token.  TODO(aguo): Implement job alive or dead detection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Serve Logs Download  # noqa: E501

        Fetches the serve controller logs of the cluster. The logs will be fetched from the streaming logs s3 bucket.  If a pagination token is provided, we use the streaming logs or downloaded logs bucket depending on the format of the pagination token.  TODO(aguo): Implement job alive or dead detection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'page_size',
            'next_page_token',
            'previous_page_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'page_size' in local_var_params and local_var_params['page_size'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `page_size` when calling `get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get`, must be a value less than or equal to `1000`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'next_page_token' in local_var_params and local_var_params['next_page_token'] is not None:  # noqa: E501
            query_params.append(('next_page_token', local_var_params['next_page_token']))  # noqa: E501
        if 'previous_page_token' in local_var_params and local_var_params['previous_page_token'] is not None:  # noqa: E501
            query_params.append(('previous_page_token', local_var_params['previous_page_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/serve_logs_download/{cluster_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_api_v2_services_v2_service_id_get(self, service_id, **kwargs):  # noqa: E501
        """Get Service  # noqa: E501

        Get a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_api_v2_services_v2_service_id_get(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_api_v2_services_v2_service_id_get_with_http_info(service_id, **kwargs)  # noqa: E501

    def get_service_api_v2_services_v2_service_id_get_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get Service  # noqa: E501

        Get a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_api_v2_services_v2_service_id_get_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_api_v2_services_v2_service_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_service_api_v2_services_v2_service_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get(self, event_id, origin, **kwargs):  # noqa: E501
        """Get Service Event Verbose Message  # noqa: E501

        Get verbose message details of a service event.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get(event_id, origin, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event_id: (required)
        :param ServiceEventScope origin: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ServiceeventverbosemessagemodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get_with_http_info(event_id, origin, **kwargs)  # noqa: E501

    def get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get_with_http_info(self, event_id, origin, **kwargs):  # noqa: E501
        """Get Service Event Verbose Message  # noqa: E501

        Get verbose message details of a service event.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get_with_http_info(event_id, origin, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event_id: (required)
        :param ServiceEventScope origin: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ServiceeventverbosemessagemodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'event_id',
            'origin'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'event_id' is set
        if self.api_client.client_side_validation and ('event_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['event_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `event_id` when calling `get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get`")  # noqa: E501
        # verify the required parameter 'origin' is set
        if self.api_client.client_side_validation and ('origin' not in local_var_params or  # noqa: E501
                                                        local_var_params['origin'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `origin` when calling `get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in local_var_params:
            path_params['event_id'] = local_var_params['event_id']  # noqa: E501

        query_params = []
        if 'origin' in local_var_params and local_var_params['origin'] is not None:  # noqa: E501
            query_params.append(('origin', local_var_params['origin']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/events/{event_id}/verbose_message', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceeventverbosemessagemodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_events_api_v2_services_v2_service_id_events_get(self, service_id, **kwargs):  # noqa: E501
        """Get Service Events  # noqa: E501

        Get Service events (DEPRECATED: Use /api/v2/events/service/{service_id}/events instead)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_events_api_v2_services_v2_service_id_events_get(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param list[ServiceEventScopeFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param list[EventLevel] level: Filter by level of event
        :param str message: Filter by message of event
        :param datetime start_time: The start time for the query. Non-inclusive. If start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. Non-inclusive. If end_time is not set, the query will use the time now.
        :param bool include_verbose_events: Show all verbose service events without truncation if set to True.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedserviceeventapimodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_events_api_v2_services_v2_service_id_events_get_with_http_info(service_id, **kwargs)  # noqa: E501

    def get_service_events_api_v2_services_v2_service_id_events_get_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get Service Events  # noqa: E501

        Get Service events (DEPRECATED: Use /api/v2/events/service/{service_id}/events instead)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_events_api_v2_services_v2_service_id_events_get_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param list[ServiceEventScopeFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param list[EventLevel] level: Filter by level of event
        :param str message: Filter by message of event
        :param datetime start_time: The start time for the query. Non-inclusive. If start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. Non-inclusive. If end_time is not set, the query will use the time now.
        :param bool include_verbose_events: Show all verbose service events without truncation if set to True.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedserviceeventapimodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'origin',
            'level',
            'message',
            'start_time',
            'end_time',
            'include_verbose_events',
            'ascending_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_events_api_v2_services_v2_service_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_service_events_api_v2_services_v2_service_id_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_service_events_api_v2_services_v2_service_id_events_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_service_events_api_v2_services_v2_service_id_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []
        if 'origin' in local_var_params and local_var_params['origin'] is not None:  # noqa: E501
            query_params.append(('origin', local_var_params['origin']))  # noqa: E501
            collection_formats['origin'] = 'multi'  # noqa: E501
        if 'level' in local_var_params and local_var_params['level'] is not None:  # noqa: E501
            query_params.append(('level', local_var_params['level']))  # noqa: E501
            collection_formats['level'] = 'multi'  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'include_verbose_events' in local_var_params and local_var_params['include_verbose_events'] is not None:  # noqa: E501
            query_params.append(('include_verbose_events', local_var_params['include_verbose_events']))  # noqa: E501
        if 'ascending_order' in local_var_params and local_var_params['ascending_order'] is not None:  # noqa: E501
            query_params.append(('ascending_order', local_var_params['ascending_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedserviceeventapimodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_version_api_v2_services_v2_service_id_versions_service_version_name_get(self, service_id, service_version_name, **kwargs):  # noqa: E501
        """Get Service Version  # noqa: E501

        Get a Service Version by name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_version_api_v2_services_v2_service_id_versions_service_version_name_get(service_id, service_version_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param str service_version_name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2VersionapimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_version_api_v2_services_v2_service_id_versions_service_version_name_get_with_http_info(service_id, service_version_name, **kwargs)  # noqa: E501

    def get_service_version_api_v2_services_v2_service_id_versions_service_version_name_get_with_http_info(self, service_id, service_version_name, **kwargs):  # noqa: E501
        """Get Service Version  # noqa: E501

        Get a Service Version by name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_version_api_v2_services_v2_service_id_versions_service_version_name_get_with_http_info(service_id, service_version_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param str service_version_name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2VersionapimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'service_version_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_version_api_v2_services_v2_service_id_versions_service_version_name_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_service_version_api_v2_services_v2_service_id_versions_service_version_name_get`")  # noqa: E501
        # verify the required parameter 'service_version_name' is set
        if self.api_client.client_side_validation and ('service_version_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_version_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_version_name` when calling `get_service_version_api_v2_services_v2_service_id_versions_service_version_name_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501
        if 'service_version_name' in local_var_params:
            path_params['service_version_name'] = local_var_params['service_version_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/versions/{service_version_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2VersionapimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_versions_api_v2_services_v2_service_id_versions_get(self, service_id, **kwargs):  # noqa: E501
        """Get Service Versions  # noqa: E501

        Returns up to 100 (most recent) versions for the given Service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_versions_api_v2_services_v2_service_id_versions_get(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param list[ServiceVersionState] state_filter: Filter by one or more states of version. Can specify multiple states.
        :param int count: Number of versions to return
        :param str paging_token: Token for pagination
        :param ServiceVersionSortField sort_field: Field to sort by. If absent, the default sorting order is: 1. state (non-terminated first), 2. created_at (desc).
        :param SortOrder sort_order: Sort order. If sort_field is absent, this field is ignored. Defaults to descending.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2VersionapimodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_versions_api_v2_services_v2_service_id_versions_get_with_http_info(service_id, **kwargs)  # noqa: E501

    def get_service_versions_api_v2_services_v2_service_id_versions_get_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get Service Versions  # noqa: E501

        Returns up to 100 (most recent) versions for the given Service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_versions_api_v2_services_v2_service_id_versions_get_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param list[ServiceVersionState] state_filter: Filter by one or more states of version. Can specify multiple states.
        :param int count: Number of versions to return
        :param str paging_token: Token for pagination
        :param ServiceVersionSortField sort_field: Field to sort by. If absent, the default sorting order is: 1. state (non-terminated first), 2. created_at (desc).
        :param SortOrder sort_order: Sort order. If sort_field is absent, this field is ignored. Defaults to descending.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2VersionapimodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'state_filter',
            'count',
            'paging_token',
            'sort_field',
            'sort_order'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_versions_api_v2_services_v2_service_id_versions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_service_versions_api_v2_services_v2_service_id_versions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2VersionapimodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_api_v2_sessions_session_id_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_api_v2_sessions_session_id_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_api_v2_sessions_session_id_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_api_v2_sessions_session_id_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_api_v2_sessions_session_id_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_api_v2_sessions_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_api_v2_sessions_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get(self, session_id, session_command_id, **kwargs):  # noqa: E501
        """Get Session Command Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get(session_id, session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str session_command_id: (required)
        :param bool use_bearer_token: Whether to use the more performant bearer-token based log downloading for GCP. Defaults to false for backwards compatibility.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get_with_http_info(session_id, session_command_id, **kwargs)  # noqa: E501

    def get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get_with_http_info(self, session_id, session_command_id, **kwargs):  # noqa: E501
        """Get Session Command Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get_with_http_info(session_id, session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str session_command_id: (required)
        :param bool use_bearer_token: Whether to use the more performant bearer-token based log downloading for GCP. Defaults to false for backwards compatibility.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'session_command_id',
            'use_bearer_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get`")  # noqa: E501
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []
        if 'use_bearer_token' in local_var_params and local_var_params['use_bearer_token'] is not None:  # noqa: E501
            query_params.append(('use_bearer_token', local_var_params['use_bearer_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/session_command_logs/{session_id}/{session_command_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_commands_history_api_v2_session_commands_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Commands History  # noqa: E501

        List all commands that have been run on a session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_commands_history_api_v2_session_commands_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str shell_command: shell command to filter by
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessioncommandListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_commands_history_api_v2_session_commands_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_commands_history_api_v2_session_commands_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Commands History  # noqa: E501

        List all commands that have been run on a session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_commands_history_api_v2_session_commands_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str shell_command: shell command to filter by
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessioncommandListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'shell_command',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_commands_history_api_v2_session_commands_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_commands_history_api_v2_session_commands_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_session_commands_history_api_v2_session_commands_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_session_commands_history_api_v2_session_commands_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'session_id' in local_var_params and local_var_params['session_id'] is not None:  # noqa: E501
            query_params.append(('session_id', local_var_params['session_id']))  # noqa: E501
        if 'shell_command' in local_var_params and local_var_params['shell_command'] is not None:  # noqa: E501
            query_params.append(('shell_command', local_var_params['shell_command']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessioncommandListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_head_ip_api_v2_sessions_session_id_head_ip_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Head Ip  # noqa: E501

        Fetches the ip of the head node of the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_head_ip_api_v2_sessions_session_id_head_ip_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HeadipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_head_ip_api_v2_sessions_session_id_head_ip_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_head_ip_api_v2_sessions_session_id_head_ip_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Head Ip  # noqa: E501

        Fetches the ip of the head node of the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_head_ip_api_v2_sessions_session_id_head_ip_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HeadipResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_head_ip_api_v2_sessions_session_id_head_ip_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_head_ip_api_v2_sessions_session_id_head_ip_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/head_ip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HeadipResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Ssh Key  # noqa: E501

        Download SSH needed to log into a given session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessionsshkeyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Ssh Key  # noqa: E501

        Download SSH needed to log into a given session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessionsshkeyResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/ssh_key', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionsshkeyResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_startup_logs_api_v2_sessions_session_id_startup_logs_get(self, session_id, start_line, end_line, **kwargs):  # noqa: E501
        """Get Startup Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_startup_logs_api_v2_sessions_session_id_startup_logs_get(session_id, start_line, end_line, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_line: (required)
        :param int end_line: (required)
        :param str extension:
        :param datetime start_time:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogsoutputResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_startup_logs_api_v2_sessions_session_id_startup_logs_get_with_http_info(session_id, start_line, end_line, **kwargs)  # noqa: E501

    def get_startup_logs_api_v2_sessions_session_id_startup_logs_get_with_http_info(self, session_id, start_line, end_line, **kwargs):  # noqa: E501
        """Get Startup Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_startup_logs_api_v2_sessions_session_id_startup_logs_get_with_http_info(session_id, start_line, end_line, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_line: (required)
        :param int end_line: (required)
        :param str extension:
        :param datetime start_time:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogsoutputResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_line',
            'end_line',
            'extension',
            'start_time'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_startup_logs_api_v2_sessions_session_id_startup_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_startup_logs_api_v2_sessions_session_id_startup_logs_get`")  # noqa: E501
        # verify the required parameter 'start_line' is set
        if self.api_client.client_side_validation and ('start_line' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_line'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_line` when calling `get_startup_logs_api_v2_sessions_session_id_startup_logs_get`")  # noqa: E501
        # verify the required parameter 'end_line' is set
        if self.api_client.client_side_validation and ('end_line' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_line'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_line` when calling `get_startup_logs_api_v2_sessions_session_id_startup_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'start_line' in local_var_params and local_var_params['start_line'] is not None:  # noqa: E501
            query_params.append(('start_line', local_var_params['start_line']))  # noqa: E501
        if 'end_line' in local_var_params and local_var_params['end_line'] is not None:  # noqa: E501
            query_params.append(('end_line', local_var_params['end_line']))  # noqa: E501
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/startup_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogsoutputResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get(self, connection_id, catalog_id, schema_id, table_id, **kwargs):  # noqa: E501
        """Get Table Metadata  # noqa: E501

        Gets detailed metadata for a specific table including columns, properties, and statistics  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get(connection_id, catalog_id, schema_id, table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param str schema_id: ID of the schema (required)
        :param str table_id: ID of the table (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BackendServerApiProductModelsCatalogClientModelsTableMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get_with_http_info(connection_id, catalog_id, schema_id, table_id, **kwargs)  # noqa: E501

    def get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get_with_http_info(self, connection_id, catalog_id, schema_id, table_id, **kwargs):  # noqa: E501
        """Get Table Metadata  # noqa: E501

        Gets detailed metadata for a specific table including columns, properties, and statistics  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get_with_http_info(connection_id, catalog_id, schema_id, table_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param str schema_id: ID of the schema (required)
        :param str table_id: ID of the table (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BackendServerApiProductModelsCatalogClientModelsTableMetadata, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'catalog_id',
            'schema_id',
            'table_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and ('connection_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connection_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if self.api_client.client_side_validation and ('catalog_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['catalog_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `catalog_id` when calling `get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get`")  # noqa: E501
        # verify the required parameter 'schema_id' is set
        if self.api_client.client_side_validation and ('schema_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schema_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schema_id` when calling `get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get`")  # noqa: E501
        # verify the required parameter 'table_id' is set
        if self.api_client.client_side_validation and ('table_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['table_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `table_id` when calling `get_table_metadata_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_metadata_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connection_id'] = local_var_params['connection_id']  # noqa: E501
        if 'catalog_id' in local_var_params:
            path_params['catalog_id'] = local_var_params['catalog_id']  # noqa: E501
        if 'schema_id' in local_var_params:
            path_params['schema_id'] = local_var_params['schema_id']  # noqa: E501
        if 'table_id' in local_var_params:
            path_params['table_id'] = local_var_params['table_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/data_catalogs/connections/{connection_id}/catalogs/{catalog_id}/schemas/{schema_id}/tables/{table_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BackendServerApiProductModelsCatalogClientModelsTableMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get(self, connection_id, catalog_id, schema_id, table_id, allow_warehouse_start, **kwargs):  # noqa: E501
        """Get Table Preview  # noqa: E501

        Gets a preview of data for a specific table with sample rows. Note: Requires a running SQL warehouse. If no warehouse is running, allow_warehouse_start must be true to proceed (will incur compute costs).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get(connection_id, catalog_id, schema_id, table_id, allow_warehouse_start, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param str schema_id: ID of the schema (required)
        :param str table_id: ID of the table (required)
        :param bool allow_warehouse_start: Whether to allow starting a stopped SQL warehouse. Starting a warehouse incurs compute costs. If false and no warehouse is running, the request will fail with an error. See: https://www.databricks.com/product/pricing/databricks-sql (required)
        :param str version: Version of the table to retrieve
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TableDataPreview
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get_with_http_info(connection_id, catalog_id, schema_id, table_id, allow_warehouse_start, **kwargs)  # noqa: E501

    def get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get_with_http_info(self, connection_id, catalog_id, schema_id, table_id, allow_warehouse_start, **kwargs):  # noqa: E501
        """Get Table Preview  # noqa: E501

        Gets a preview of data for a specific table with sample rows. Note: Requires a running SQL warehouse. If no warehouse is running, allow_warehouse_start must be true to proceed (will incur compute costs).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get_with_http_info(connection_id, catalog_id, schema_id, table_id, allow_warehouse_start, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param str schema_id: ID of the schema (required)
        :param str table_id: ID of the table (required)
        :param bool allow_warehouse_start: Whether to allow starting a stopped SQL warehouse. Starting a warehouse incurs compute costs. If false and no warehouse is running, the request will fail with an error. See: https://www.databricks.com/product/pricing/databricks-sql (required)
        :param str version: Version of the table to retrieve
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TableDataPreview, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'catalog_id',
            'schema_id',
            'table_id',
            'allow_warehouse_start',
            'version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and ('connection_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connection_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if self.api_client.client_side_validation and ('catalog_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['catalog_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `catalog_id` when calling `get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get`")  # noqa: E501
        # verify the required parameter 'schema_id' is set
        if self.api_client.client_side_validation and ('schema_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schema_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schema_id` when calling `get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get`")  # noqa: E501
        # verify the required parameter 'table_id' is set
        if self.api_client.client_side_validation and ('table_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['table_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `table_id` when calling `get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get`")  # noqa: E501
        # verify the required parameter 'allow_warehouse_start' is set
        if self.api_client.client_side_validation and ('allow_warehouse_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['allow_warehouse_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `allow_warehouse_start` when calling `get_table_preview_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_table_id_preview_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connection_id'] = local_var_params['connection_id']  # noqa: E501
        if 'catalog_id' in local_var_params:
            path_params['catalog_id'] = local_var_params['catalog_id']  # noqa: E501
        if 'schema_id' in local_var_params:
            path_params['schema_id'] = local_var_params['schema_id']  # noqa: E501
        if 'table_id' in local_var_params:
            path_params['table_id'] = local_var_params['table_id']  # noqa: E501

        query_params = []
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
        if 'allow_warehouse_start' in local_var_params and local_var_params['allow_warehouse_start'] is not None:  # noqa: E501
            query_params.append(('allow_warehouse_start', local_var_params['allow_warehouse_start']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/data_catalogs/connections/{connection_id}/catalogs/{catalog_id}/schemas/{schema_id}/tables/{table_id}/preview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TableDataPreview',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tags_for_resource_api_v2_tags_resource_get(self, resource_type, resource_id, **kwargs):  # noqa: E501
        """Get Tags For Resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_for_resource_api_v2_tags_resource_get(resource_type, resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResourceTagResourceType resource_type: (required)
        :param str resource_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcetagslistResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tags_for_resource_api_v2_tags_resource_get_with_http_info(resource_type, resource_id, **kwargs)  # noqa: E501

    def get_tags_for_resource_api_v2_tags_resource_get_with_http_info(self, resource_type, resource_id, **kwargs):  # noqa: E501
        """Get Tags For Resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_for_resource_api_v2_tags_resource_get_with_http_info(resource_type, resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResourceTagResourceType resource_type: (required)
        :param str resource_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcetagslistResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_type',
            'resource_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tags_for_resource_api_v2_tags_resource_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_type' is set
        if self.api_client.client_side_validation and ('resource_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_type` when calling `get_tags_for_resource_api_v2_tags_resource_get`")  # noqa: E501
        # verify the required parameter 'resource_id' is set
        if self.api_client.client_side_validation and ('resource_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_id` when calling `get_tags_for_resource_api_v2_tags_resource_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'resource_type' in local_var_params and local_var_params['resource_type'] is not None:  # noqa: E501
            query_params.append(('resource_type', local_var_params['resource_type']))  # noqa: E501
        if 'resource_id' in local_var_params and local_var_params['resource_id'] is not None:  # noqa: E501
            query_params.append(('resource_id', local_var_params['resource_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tags/resource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcetagslistResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_exception_aggregates_api_v2_tasks_dashboard_aggregate_by_exception_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Task Exception Aggregates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_exception_aggregates_api_v2_tasks_dashboard_aggregate_by_exception_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TaskExceptionGroupAggregateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_exception_aggregates_api_v2_tasks_dashboard_aggregate_by_exception_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_task_exception_aggregates_api_v2_tasks_dashboard_aggregate_by_exception_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Task Exception Aggregates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_exception_aggregates_api_v2_tasks_dashboard_aggregate_by_exception_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TaskExceptionGroupAggregateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_exception_aggregates_api_v2_tasks_dashboard_aggregate_by_exception_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_task_exception_aggregates_api_v2_tasks_dashboard_aggregate_by_exception_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tasks_dashboard/aggregate_by_exception', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskExceptionGroupAggregateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_function_aggregates_api_v2_tasks_dashboard_aggregate_by_function_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Task Function Aggregates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_function_aggregates_api_v2_tasks_dashboard_aggregate_by_function_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TaskFunctionNameGroupAggregateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_function_aggregates_api_v2_tasks_dashboard_aggregate_by_function_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_task_function_aggregates_api_v2_tasks_dashboard_aggregate_by_function_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Task Function Aggregates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_function_aggregates_api_v2_tasks_dashboard_aggregate_by_function_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TaskFunctionNameGroupAggregateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_function_aggregates_api_v2_tasks_dashboard_aggregate_by_function_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_task_function_aggregates_api_v2_tasks_dashboard_aggregate_by_function_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tasks_dashboard/aggregate_by_function', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskFunctionNameGroupAggregateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_job_aggregates_api_v2_tasks_dashboard_aggregate_by_job_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Task Job Aggregates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_job_aggregates_api_v2_tasks_dashboard_aggregate_by_job_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TaskJobGroupAggregateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_job_aggregates_api_v2_tasks_dashboard_aggregate_by_job_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_task_job_aggregates_api_v2_tasks_dashboard_aggregate_by_job_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Task Job Aggregates  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_job_aggregates_api_v2_tasks_dashboard_aggregate_by_job_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TaskJobGroupAggregateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_job_aggregates_api_v2_tasks_dashboard_aggregate_by_job_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_task_job_aggregates_api_v2_tasks_dashboard_aggregate_by_job_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tasks_dashboard/aggregate_by_job', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskJobGroupAggregateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_summary_api_v2_tasks_dashboard_summary_get(self, cluster_id, task_summary_config, **kwargs):  # noqa: E501
        """Get Task Summary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_summary_api_v2_tasks_dashboard_summary_get(cluster_id, task_summary_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param TaskSummaryConfig task_summary_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TasksummaryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_summary_api_v2_tasks_dashboard_summary_get_with_http_info(cluster_id, task_summary_config, **kwargs)  # noqa: E501

    def get_task_summary_api_v2_tasks_dashboard_summary_get_with_http_info(self, cluster_id, task_summary_config, **kwargs):  # noqa: E501
        """Get Task Summary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_summary_api_v2_tasks_dashboard_summary_get_with_http_info(cluster_id, task_summary_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param TaskSummaryConfig task_summary_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TasksummaryResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'task_summary_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_summary_api_v2_tasks_dashboard_summary_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_task_summary_api_v2_tasks_dashboard_summary_get`")  # noqa: E501
        # verify the required parameter 'task_summary_config' is set
        if self.api_client.client_side_validation and ('task_summary_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_summary_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_summary_config` when calling `get_task_summary_api_v2_tasks_dashboard_summary_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task_summary_config' in local_var_params:
            body_params = local_var_params['task_summary_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tasks_dashboard/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TasksummaryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_table_api_v2_tasks_dashboard_table_get(self, cluster_id, task_table_config, **kwargs):  # noqa: E501
        """Get Task Table  # noqa: E501

        Paging tokens are integers that represent the page number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_table_api_v2_tasks_dashboard_table_get(cluster_id, task_table_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param TaskTableConfig task_table_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TaskTableResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_table_api_v2_tasks_dashboard_table_get_with_http_info(cluster_id, task_table_config, **kwargs)  # noqa: E501

    def get_task_table_api_v2_tasks_dashboard_table_get_with_http_info(self, cluster_id, task_table_config, **kwargs):  # noqa: E501
        """Get Task Table  # noqa: E501

        Paging tokens are integers that represent the page number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_table_api_v2_tasks_dashboard_table_get_with_http_info(cluster_id, task_table_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param TaskTableConfig task_table_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TaskTableResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'task_table_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_table_api_v2_tasks_dashboard_table_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_task_table_api_v2_tasks_dashboard_table_get`")  # noqa: E501
        # verify the required parameter 'task_table_config' is set
        if self.api_client.client_side_validation and ('task_table_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_table_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_table_config` when calling `get_task_table_api_v2_tasks_dashboard_table_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task_table_config' in local_var_params:
            body_params = local_var_params['task_table_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tasks_dashboard/table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskTableResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_template_api_v2_workspace_templates_template_id_get(self, template_id, **kwargs):  # noqa: E501
        """Get Template  # noqa: E501

        Get workspace template details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_api_v2_workspace_templates_template_id_get(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: ID of the template to retrieve (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_template_api_v2_workspace_templates_template_id_get_with_http_info(template_id, **kwargs)  # noqa: E501

    def get_template_api_v2_workspace_templates_template_id_get_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get Template  # noqa: E501

        Get workspace template details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_api_v2_workspace_templates_template_id_get_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: ID of the template to retrieve (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_template_api_v2_workspace_templates_template_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_template_api_v2_workspace_templates_template_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/{template_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get(self, template_id, **kwargs):  # noqa: E501
        """Get Template Readme  # noqa: E501

        Retrieves a template's README.md file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: ID of the template. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplatereadmeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get_with_http_info(template_id, **kwargs)  # noqa: E501

    def get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get Template Readme  # noqa: E501

        Retrieves a template's README.md file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: ID of the template. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplatereadmeResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/template/readme/{template_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplatereadmeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_total_usage_api_v2_aggregated_instance_usage_get(self, start_date, end_date, **kwargs):  # noqa: E501
        """Get Total Usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_total_usage_api_v2_aggregated_instance_usage_get(start_date, end_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AggregatedusageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_total_usage_api_v2_aggregated_instance_usage_get_with_http_info(start_date, end_date, **kwargs)  # noqa: E501

    def get_total_usage_api_v2_aggregated_instance_usage_get_with_http_info(self, start_date, end_date, **kwargs):  # noqa: E501
        """Get Total Usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_total_usage_api_v2_aggregated_instance_usage_get_with_http_info(start_date, end_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AggregatedusageResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_total_usage_api_v2_aggregated_instance_usage_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `get_total_usage_api_v2_aggregated_instance_usage_get`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `get_total_usage_api_v2_aggregated_instance_usage_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aggregated_instance_usage/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AggregatedusageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_train_logs_download_api_v2_train_runs_logs_get(self, cluster_id, log_id, **kwargs):  # noqa: E501
        """Get Train Logs Download  # noqa: E501

        Fetches the serve controller logs of the cluster. The logs will be fetched from the streaming logs s3 bucket.  If a pagination token is provided, we use the streaming logs or downloaded logs bucket depending on the format of the pagination token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_train_logs_download_api_v2_train_runs_logs_get(cluster_id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str log_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_train_logs_download_api_v2_train_runs_logs_get_with_http_info(cluster_id, log_id, **kwargs)  # noqa: E501

    def get_train_logs_download_api_v2_train_runs_logs_get_with_http_info(self, cluster_id, log_id, **kwargs):  # noqa: E501
        """Get Train Logs Download  # noqa: E501

        Fetches the serve controller logs of the cluster. The logs will be fetched from the streaming logs s3 bucket.  If a pagination token is provided, we use the streaming logs or downloaded logs bucket depending on the format of the pagination token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_train_logs_download_api_v2_train_runs_logs_get_with_http_info(cluster_id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str log_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'log_id',
            'page_size',
            'next_page_token',
            'previous_page_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_train_logs_download_api_v2_train_runs_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_train_logs_download_api_v2_train_runs_logs_get`")  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and ('log_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['log_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `log_id` when calling `get_train_logs_download_api_v2_train_runs_logs_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'page_size' in local_var_params and local_var_params['page_size'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `page_size` when calling `get_train_logs_download_api_v2_train_runs_logs_get`, must be a value less than or equal to `1000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'log_id' in local_var_params and local_var_params['log_id'] is not None:  # noqa: E501
            query_params.append(('log_id', local_var_params['log_id']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'next_page_token' in local_var_params and local_var_params['next_page_token'] is not None:  # noqa: E501
            query_params.append(('next_page_token', local_var_params['next_page_token']))  # noqa: E501
        if 'previous_page_token' in local_var_params and local_var_params['previous_page_token'] is not None:  # noqa: E501
            query_params.append(('previous_page_token', local_var_params['previous_page_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/train_runs/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_train_runs_api_v2_train_runs_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Train Runs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_train_runs_api_v2_train_runs_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param bool skip_job_details: Skip decorating job details, which can be an expensive operation.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TrainrunListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_train_runs_api_v2_train_runs_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_train_runs_api_v2_train_runs_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Train Runs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_train_runs_api_v2_train_runs_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param bool skip_job_details: Skip decorating job details, which can be an expensive operation.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TrainrunListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'skip_job_details'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_train_runs_api_v2_train_runs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_train_runs_api_v2_train_runs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'skip_job_details' in local_var_params and local_var_params['skip_job_details'] is not None:  # noqa: E501
            query_params.append(('skip_job_details', local_var_params['skip_job_details']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/train_runs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrainrunListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unified_events_api_v2_events_entity_type_entity_id_events_get(self, entity_type, entity_id, **kwargs):  # noqa: E501
        """Get Unified Events  # noqa: E501

        Get events for any entity type (production jobs, workspaces, or services)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unified_events_api_v2_events_entity_type_entity_id_events_get(entity_type, entity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param EntityType entity_type: The type of entity (required)
        :param str entity_id: The ID of the entity (required)
        :param list[UnifiedOriginFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.  Available origins by entity type:  Jobs: JOB, CLUSTER  Workspaces: WORKSPACE, CLUSTER  Services: SERVICE, SERVICE_VERSION, ALB, SERVE_DEPLOYMENT, CLUSTER  Clusters: AUTOSCALER, CLUSTER_LIFECYCLE, IDLE_TERMINATION, JOBS, WORKSPACE_SNAPSHOT, OS, CLUSTER
        :param list[EventLevel] level: Filter by level of event
        :param str message: Filter by message of event
        :param datetime start_time: The start time for the query. Non-inclusive. If start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. Non-inclusive. If end_time is not set, the query will use the time now.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param bool include_verbose_events: Show all verbose service events without truncation if set to True. Only applicable to service events.
        :param str instance_id: Filter for events from this instance. This is a string that is the instance id of the instance.
        :param list[str] autoscaler_resource_bundles: Filter for autoscaler events relevant to specific resource bundles.Each string should be a JSON-encoded resource bundle. We accept a string here because query params do not support dictionaries. Ex: ['{\"CPU\": 1, \"GPU\": 1}', '{\"GPU\": 1}']
        :param str instance_node_ip: Filter for events from this instance. This is a string that is the node ip of the instance.
        :param int count:
        :param str paging_token:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UnifiedeventListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_unified_events_api_v2_events_entity_type_entity_id_events_get_with_http_info(entity_type, entity_id, **kwargs)  # noqa: E501

    def get_unified_events_api_v2_events_entity_type_entity_id_events_get_with_http_info(self, entity_type, entity_id, **kwargs):  # noqa: E501
        """Get Unified Events  # noqa: E501

        Get events for any entity type (production jobs, workspaces, or services)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unified_events_api_v2_events_entity_type_entity_id_events_get_with_http_info(entity_type, entity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param EntityType entity_type: The type of entity (required)
        :param str entity_id: The ID of the entity (required)
        :param list[UnifiedOriginFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.  Available origins by entity type:  Jobs: JOB, CLUSTER  Workspaces: WORKSPACE, CLUSTER  Services: SERVICE, SERVICE_VERSION, ALB, SERVE_DEPLOYMENT, CLUSTER  Clusters: AUTOSCALER, CLUSTER_LIFECYCLE, IDLE_TERMINATION, JOBS, WORKSPACE_SNAPSHOT, OS, CLUSTER
        :param list[EventLevel] level: Filter by level of event
        :param str message: Filter by message of event
        :param datetime start_time: The start time for the query. Non-inclusive. If start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. Non-inclusive. If end_time is not set, the query will use the time now.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param bool include_verbose_events: Show all verbose service events without truncation if set to True. Only applicable to service events.
        :param str instance_id: Filter for events from this instance. This is a string that is the instance id of the instance.
        :param list[str] autoscaler_resource_bundles: Filter for autoscaler events relevant to specific resource bundles.Each string should be a JSON-encoded resource bundle. We accept a string here because query params do not support dictionaries. Ex: ['{\"CPU\": 1, \"GPU\": 1}', '{\"GPU\": 1}']
        :param str instance_node_ip: Filter for events from this instance. This is a string that is the node ip of the instance.
        :param int count:
        :param str paging_token:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UnifiedeventListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'entity_type',
            'entity_id',
            'origin',
            'level',
            'message',
            'start_time',
            'end_time',
            'ascending_order',
            'include_verbose_events',
            'instance_id',
            'autoscaler_resource_bundles',
            'instance_node_ip',
            'count',
            'paging_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unified_events_api_v2_events_entity_type_entity_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'entity_type' is set
        if self.api_client.client_side_validation and ('entity_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['entity_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `entity_type` when calling `get_unified_events_api_v2_events_entity_type_entity_id_events_get`")  # noqa: E501
        # verify the required parameter 'entity_id' is set
        if self.api_client.client_side_validation and ('entity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['entity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `entity_id` when calling `get_unified_events_api_v2_events_entity_type_entity_id_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_unified_events_api_v2_events_entity_type_entity_id_events_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_unified_events_api_v2_events_entity_type_entity_id_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'entity_type' in local_var_params:
            path_params['entity_type'] = local_var_params['entity_type']  # noqa: E501
        if 'entity_id' in local_var_params:
            path_params['entity_id'] = local_var_params['entity_id']  # noqa: E501

        query_params = []
        if 'origin' in local_var_params and local_var_params['origin'] is not None:  # noqa: E501
            query_params.append(('origin', local_var_params['origin']))  # noqa: E501
            collection_formats['origin'] = 'multi'  # noqa: E501
        if 'level' in local_var_params and local_var_params['level'] is not None:  # noqa: E501
            query_params.append(('level', local_var_params['level']))  # noqa: E501
            collection_formats['level'] = 'multi'  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'ascending_order' in local_var_params and local_var_params['ascending_order'] is not None:  # noqa: E501
            query_params.append(('ascending_order', local_var_params['ascending_order']))  # noqa: E501
        if 'include_verbose_events' in local_var_params and local_var_params['include_verbose_events'] is not None:  # noqa: E501
            query_params.append(('include_verbose_events', local_var_params['include_verbose_events']))  # noqa: E501
        if 'instance_id' in local_var_params and local_var_params['instance_id'] is not None:  # noqa: E501
            query_params.append(('instance_id', local_var_params['instance_id']))  # noqa: E501
        if 'autoscaler_resource_bundles' in local_var_params and local_var_params['autoscaler_resource_bundles'] is not None:  # noqa: E501
            query_params.append(('autoscaler_resource_bundles', local_var_params['autoscaler_resource_bundles']))  # noqa: E501
            collection_formats['autoscaler_resource_bundles'] = 'multi'  # noqa: E501
        if 'instance_node_ip' in local_var_params and local_var_params['instance_node_ip'] is not None:  # noqa: E501
            query_params.append(('instance_node_ip', local_var_params['instance_node_ip']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/events/{entity_type}/{entity_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UnifiedeventListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_group_api_v2_user_groups_group_id_get(self, group_id, **kwargs):  # noqa: E501
        """Get User Group  # noqa: E501

        Get a specific user group by ID.  Returns details for a single user group if it exists in the authenticated user's organization.  Path Parameters: - **group_id**: The ID of the user group to retrieve  Returns: - User group with id and name  Permission requirements: - Caller must be an organization admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_group_api_v2_user_groups_group_id_get(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str group_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsergroupResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_group_api_v2_user_groups_group_id_get_with_http_info(group_id, **kwargs)  # noqa: E501

    def get_user_group_api_v2_user_groups_group_id_get_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Get User Group  # noqa: E501

        Get a specific user group by ID.  Returns details for a single user group if it exists in the authenticated user's organization.  Path Parameters: - **group_id**: The ID of the user group to retrieve  Returns: - User group with id and name  Permission requirements: - Caller must be an organization admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_group_api_v2_user_groups_group_id_get_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str group_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsergroupResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'group_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_group_api_v2_user_groups_group_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['group_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `group_id` when calling `get_user_group_api_v2_user_groups_group_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in local_var_params:
            path_params['group_id'] = local_var_params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user_groups/{group_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsergroupResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_info_api_v2_userinfo_get(self, **kwargs):  # noqa: E501
        """Get User Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_info_api_v2_userinfo_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UserinfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_info_api_v2_userinfo_get_with_http_info(**kwargs)  # noqa: E501

    def get_user_info_api_v2_userinfo_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get User Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_info_api_v2_userinfo_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UserinfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_info_api_v2_userinfo_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/userinfo/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserinfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_version_api_v2_workspace_templates_template_id_versions_version_id_get(self, template_id, version_id, **kwargs):  # noqa: E501
        """Get Version  # noqa: E501

        Get a specific version of a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version_api_v2_workspace_templates_template_id_versions_version_id_get(template_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param str version_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateversionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_version_api_v2_workspace_templates_template_id_versions_version_id_get_with_http_info(template_id, version_id, **kwargs)  # noqa: E501

    def get_version_api_v2_workspace_templates_template_id_versions_version_id_get_with_http_info(self, template_id, version_id, **kwargs):  # noqa: E501
        """Get Version  # noqa: E501

        Get a specific version of a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version_api_v2_workspace_templates_template_id_versions_version_id_get_with_http_info(template_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param str version_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateversionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id',
            'version_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version_api_v2_workspace_templates_template_id_versions_version_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_version_api_v2_workspace_templates_template_id_versions_version_id_get`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if self.api_client.client_side_validation and ('version_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['version_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `version_id` when calling `get_version_api_v2_workspace_templates_template_id_versions_version_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501
        if 'version_id' in local_var_params:
            path_params['version_id'] = local_var_params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/{template_id}/versions/{version_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateversionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workos_authorize_url_api_v2_workos_authorize_get(self, **kwargs):  # noqa: E501
        """Get Workos Authorize Url  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workos_authorize_url_api_v2_workos_authorize_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email_address:
        :param str provider:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkosauthorizeurlresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workos_authorize_url_api_v2_workos_authorize_get_with_http_info(**kwargs)  # noqa: E501

    def get_workos_authorize_url_api_v2_workos_authorize_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Workos Authorize Url  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workos_authorize_url_api_v2_workos_authorize_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email_address:
        :param str provider:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkosauthorizeurlresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email_address',
            'provider'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workos_authorize_url_api_v2_workos_authorize_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email_address' in local_var_params and local_var_params['email_address'] is not None:  # noqa: E501
            query_params.append(('email_address', local_var_params['email_address']))  # noqa: E501
        if 'provider' in local_var_params and local_var_params['provider'] is not None:  # noqa: E501
            query_params.append(('provider', local_var_params['provider']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workos/authorize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkosauthorizeurlresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_api_v2_experimental_workspaces_workspace_id_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace  # noqa: E501

        Retrieves a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_api_v2_experimental_workspaces_workspace_id_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retreive. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_api_v2_experimental_workspaces_workspace_id_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_api_v2_experimental_workspaces_workspace_id_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace  # noqa: E501

        Retrieves a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_api_v2_experimental_workspaces_workspace_id_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retreive. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_api_v2_experimental_workspaces_workspace_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_api_v2_experimental_workspaces_workspace_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Dataplane Artifacts  # noqa: E501

        Retrieve workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param CloudDataBucketAccessMode access_mode: Access mode for the workspace artifacts.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacedataplaneartifactsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Dataplane Artifacts  # noqa: E501

        Retrieve workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param CloudDataBucketAccessMode access_mode: Access mode for the workspace artifacts.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacedataplaneartifactsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'access_mode'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []
        if 'access_mode' in local_var_params and local_var_params['access_mode'] is not None:  # noqa: E501
            query_params.append(('access_mode', local_var_params['access_mode']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/dataplane_artifacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacedataplaneartifactsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Events  # noqa: E501

        Retrieves events for a Workspace. (DEPRECATED: Use /api/v2/events/workspace/{workspace_id}/events instead)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retreive. (required)
        :param list[WorkspaceEventSourceFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param list[EventLevel] level: Filter by level of event
        :param str message: Filter by message of event. If message is not set, query will not filter for message
        :param datetime start_time: The start time for the query. Non-inclusive. If  start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. Non-inclusive. If end_time is not set, the query will use the time now.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspaceeventListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Events  # noqa: E501

        Retrieves events for a Workspace. (DEPRECATED: Use /api/v2/events/workspace/{workspace_id}/events instead)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retreive. (required)
        :param list[WorkspaceEventSourceFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param list[EventLevel] level: Filter by level of event
        :param str message: Filter by message of event. If message is not set, query will not filter for message
        :param datetime start_time: The start time for the query. Non-inclusive. If  start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. Non-inclusive. If end_time is not set, the query will use the time now.
        :param bool ascending_order: Fetch events in ascending order of time. Default is descending order.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspaceeventListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'origin',
            'level',
            'message',
            'start_time',
            'end_time',
            'ascending_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []
        if 'origin' in local_var_params and local_var_params['origin'] is not None:  # noqa: E501
            query_params.append(('origin', local_var_params['origin']))  # noqa: E501
            collection_formats['origin'] = 'multi'  # noqa: E501
        if 'level' in local_var_params and local_var_params['level'] is not None:  # noqa: E501
            query_params.append(('level', local_var_params['level']))  # noqa: E501
            collection_formats['level'] = 'multi'  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'ascending_order' in local_var_params and local_var_params['ascending_order'] is not None:  # noqa: E501
            query_params.append(('ascending_order', local_var_params['ascending_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspaceeventListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Proxied Dataplane Artifacts  # noqa: E501

        Retrieve workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacedataplaneproxiedartifactsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Proxied Dataplane Artifacts  # noqa: E501

        Retrieve workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacedataplaneproxiedartifactsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/proxied_dataplane_artifacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacedataplaneproxiedartifactsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Readme  # noqa: E501

        Retrieves a Workspace's README.md file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacereadmeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Readme  # noqa: E501

        Retrieves a Workspace's README.md file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacereadmeResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/readme', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacereadmeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get(self, template_id, **kwargs):  # noqa: E501
        """Get Workspace Template Cluster Environment  # noqa: E501

        Get the default cluster environment for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateclusterenvironmentmetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get_with_http_info(template_id, **kwargs)  # noqa: E501

    def get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get Workspace Template Cluster Environment  # noqa: E501

        Get the default cluster environment for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateclusterenvironmentmetadataResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/template/{template_id}/cluster_environment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateclusterenvironmentmetadataResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get(self, template_id, cloud_id, **kwargs):  # noqa: E501
        """Get Workspace Template Compute Config  # noqa: E501

        Get the default compute config for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get(template_id, cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatecomputetemplateconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get_with_http_info(template_id, cloud_id, **kwargs)  # noqa: E501

    def get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get_with_http_info(self, template_id, cloud_id, **kwargs):  # noqa: E501
        """Get Workspace Template Compute Config  # noqa: E501

        Get the default compute config for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get_with_http_info(template_id, cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatecomputetemplateconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id',
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get`")  # noqa: E501
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/template/{template_id}/compute_config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatecomputetemplateconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get(self, cloud_id, **kwargs):  # noqa: E501
        """Handle Cloud Metrics Auth  # noqa: E501

        Helps a browser set an authentication cookie for a given session.  This returns an HTML page that POSTS the token to the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool via_edge_proxy:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterauthresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Handle Cloud Metrics Auth  # noqa: E501

        Helps a browser set an authentication cookie for a given session.  This returns an HTML page that POSTS the token to the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool via_edge_proxy:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterauthresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'via_edge_proxy'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'via_edge_proxy' in local_var_params and local_var_params['via_edge_proxy'] is not None:  # noqa: E501
            query_params.append(('via_edge_proxy', local_var_params['via_edge_proxy']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authentication/{cloud_id}/cloud_persistent_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterauthresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get(self, cluster_id, **kwargs):  # noqa: E501
        """Handle Cluster Auth  # noqa: E501

        Helps a browser set an authentication cookie for a given session.  This returns an HTML page that POSTS the token to the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str original_href:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterauthresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Handle Cluster Auth  # noqa: E501

        Helps a browser set an authentication cookie for a given session.  This returns an HTML page that POSTS the token to the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str original_href:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterauthresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'original_href'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []
        if 'original_href' in local_var_params and local_var_params['original_href'] is not None:  # noqa: E501
            query_params.append(('original_href', local_var_params['original_href']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authentication/{cluster_id}/cluster', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterauthresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def handle_webhook_api_v2_metronome_webhooks_handle_webhook_post(self, create_metronome_webhook_notification, **kwargs):  # noqa: E501
        """Handle Webhook  # noqa: E501

        Records a Metronome webhook notification and immediately returns.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_webhook_api_v2_metronome_webhooks_handle_webhook_post(create_metronome_webhook_notification, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMetronomeWebhookNotification create_metronome_webhook_notification: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.handle_webhook_api_v2_metronome_webhooks_handle_webhook_post_with_http_info(create_metronome_webhook_notification, **kwargs)  # noqa: E501

    def handle_webhook_api_v2_metronome_webhooks_handle_webhook_post_with_http_info(self, create_metronome_webhook_notification, **kwargs):  # noqa: E501
        """Handle Webhook  # noqa: E501

        Records a Metronome webhook notification and immediately returns.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_webhook_api_v2_metronome_webhooks_handle_webhook_post_with_http_info(create_metronome_webhook_notification, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMetronomeWebhookNotification create_metronome_webhook_notification: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_metronome_webhook_notification'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method handle_webhook_api_v2_metronome_webhooks_handle_webhook_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_metronome_webhook_notification' is set
        if self.api_client.client_side_validation and ('create_metronome_webhook_notification' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_metronome_webhook_notification'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_metronome_webhook_notification` when calling `handle_webhook_api_v2_metronome_webhooks_handle_webhook_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_metronome_webhook_notification' in local_var_params:
            body_params = local_var_params['create_metronome_webhook_notification']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/metronome_webhooks/handle_webhook', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def health_check_api_v2_health_get(self, **kwargs):  # noqa: E501
        """Health Check  # noqa: E501

        Health check router used to make sure the pod is ready to serve traffic.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_check_api_v2_health_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.health_check_api_v2_health_get_with_http_info(**kwargs)  # noqa: E501

    def health_check_api_v2_health_get_with_http_info(self, **kwargs):  # noqa: E501
        """Health Check  # noqa: E501

        Health check router used to make sure the pod is ready to serve traffic.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_check_api_v2_health_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method health_check_api_v2_health_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/health/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_cluster_environment_api_v2_application_templates_import_post(self, import_cluster_environment, **kwargs):  # noqa: E501
        """Import Cluster Environment  # noqa: E501

        Imports a Cluster Environment from an existing image.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_cluster_environment_api_v2_application_templates_import_post(import_cluster_environment, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ImportClusterEnvironment import_cluster_environment: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AppconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.import_cluster_environment_api_v2_application_templates_import_post_with_http_info(import_cluster_environment, **kwargs)  # noqa: E501

    def import_cluster_environment_api_v2_application_templates_import_post_with_http_info(self, import_cluster_environment, **kwargs):  # noqa: E501
        """Import Cluster Environment  # noqa: E501

        Imports a Cluster Environment from an existing image.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_cluster_environment_api_v2_application_templates_import_post_with_http_info(import_cluster_environment, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ImportClusterEnvironment import_cluster_environment: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AppconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'import_cluster_environment'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_cluster_environment_api_v2_application_templates_import_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'import_cluster_environment' is set
        if self.api_client.client_side_validation and ('import_cluster_environment' not in local_var_params or  # noqa: E501
                                                        local_var_params['import_cluster_environment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `import_cluster_environment` when calling `import_cluster_environment_api_v2_application_templates_import_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'import_cluster_environment' in local_var_params:
            body_params = local_var_params['import_cluster_environment']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post(self, invitation_id, **kwargs):  # noqa: E501
        """Invalidate Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationinvitationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post_with_http_info(invitation_id, **kwargs)  # noqa: E501

    def invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Invalidate Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationinvitationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'invitation_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if self.api_client.client_side_validation and ('invitation_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['invitation_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `invitation_id` when calling `invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in local_var_params:
            path_params['invitation_id'] = local_var_params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/{invitation_id}/invalidate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationinvitationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_valid_api_v2_authentication_hex_token_id_is_valid_post(self, hex_token_id, **kwargs):  # noqa: E501
        """Is Valid  # noqa: E501

        Checks if a given token (specified by the Token ID) is valid.  NOTE: This is a POST method to prevent caching.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_valid_api_v2_authentication_hex_token_id_is_valid_post(hex_token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str hex_token_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.is_valid_api_v2_authentication_hex_token_id_is_valid_post_with_http_info(hex_token_id, **kwargs)  # noqa: E501

    def is_valid_api_v2_authentication_hex_token_id_is_valid_post_with_http_info(self, hex_token_id, **kwargs):  # noqa: E501
        """Is Valid  # noqa: E501

        Checks if a given token (specified by the Token ID) is valid.  NOTE: This is a POST method to prevent caching.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_valid_api_v2_authentication_hex_token_id_is_valid_post_with_http_info(hex_token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str hex_token_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'hex_token_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_valid_api_v2_authentication_hex_token_id_is_valid_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'hex_token_id' is set
        if self.api_client.client_side_validation and ('hex_token_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['hex_token_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `hex_token_id` when calling `is_valid_api_v2_authentication_hex_token_id_is_valid_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hex_token_id' in local_var_params:
            path_params['hex_token_id'] = local_var_params['hex_token_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authentication/{hex_token_id}/is_valid', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_api_keys_api_v2_users_api_keys_get(self, **kwargs):  # noqa: E501
        """List Api Keys  # noqa: E501

        List current user's own API keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_api_keys_api_v2_users_api_keys_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApikeyinfoListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_api_keys_api_v2_users_api_keys_get_with_http_info(**kwargs)  # noqa: E501

    def list_api_keys_api_v2_users_api_keys_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Api Keys  # noqa: E501

        List current user's own API keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_api_keys_api_v2_users_api_keys_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApikeyinfoListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_api_keys_api_v2_users_api_keys_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_api_keys_api_v2_users_api_keys_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_api_keys_api_v2_users_api_keys_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/api_keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApikeyinfoListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_api_keys_for_admin_api_v2_users_admin_api_keys_get(self, **kwargs):  # noqa: E501
        """List Api Keys For Admin  # noqa: E501

        Retrieve all API keys within the organization, only used by the admin.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_api_keys_for_admin_api_v2_users_admin_api_keys_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str created_by:
        :param str user_id:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApikeyinfoListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_api_keys_for_admin_api_v2_users_admin_api_keys_get_with_http_info(**kwargs)  # noqa: E501

    def list_api_keys_for_admin_api_v2_users_admin_api_keys_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Api Keys For Admin  # noqa: E501

        Retrieve all API keys within the organization, only used by the admin.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_api_keys_for_admin_api_v2_users_admin_api_keys_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str created_by:
        :param str user_id:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApikeyinfoListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'created_by',
            'user_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_api_keys_for_admin_api_v2_users_admin_api_keys_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_api_keys_for_admin_api_v2_users_admin_api_keys_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_api_keys_for_admin_api_v2_users_admin_api_keys_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'created_by' in local_var_params and local_var_params['created_by'] is not None:  # noqa: E501
            query_params.append(('created_by', local_var_params['created_by']))  # noqa: E501
        if 'user_id' in local_var_params and local_var_params['user_id'] is not None:  # noqa: E501
            query_params.append(('user_id', local_var_params['user_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/admin/api_keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApikeyinfoListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_application_templates_api_v2_application_templates_get(self, **kwargs):  # noqa: E501
        """List Application Templates  # noqa: E501

        Lists all Cluster Environments belonging to a Project. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_templates_api_v2_application_templates_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id:
        :param str creator_id:
        :param str name_contains:
        :param str image_name_contains:
        :param bool include_archived: Whether to include archived cluster environments in the response.
        :param bool defaults_first: If True, we always return default cluster envs before user created cluster envs. If False, we always return default cluster envs after user created cluster envs. If absent, default to True. Note that we never intersperse default cluster envs with user created cluster envs.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedapplicationtemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_application_templates_api_v2_application_templates_get_with_http_info(**kwargs)  # noqa: E501

    def list_application_templates_api_v2_application_templates_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Application Templates  # noqa: E501

        Lists all Cluster Environments belonging to a Project. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_templates_api_v2_application_templates_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id:
        :param str creator_id:
        :param str name_contains:
        :param str image_name_contains:
        :param bool include_archived: Whether to include archived cluster environments in the response.
        :param bool defaults_first: If True, we always return default cluster envs before user created cluster envs. If False, we always return default cluster envs after user created cluster envs. If absent, default to True. Note that we never intersperse default cluster envs with user created cluster envs.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedapplicationtemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'creator_id',
            'name_contains',
            'image_name_contains',
            'include_archived',
            'defaults_first',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_application_templates_api_v2_application_templates_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_application_templates_api_v2_application_templates_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_application_templates_api_v2_application_templates_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'image_name_contains' in local_var_params and local_var_params['image_name_contains'] is not None:  # noqa: E501
            query_params.append(('image_name_contains', local_var_params['image_name_contains']))  # noqa: E501
        if 'include_archived' in local_var_params and local_var_params['include_archived'] is not None:  # noqa: E501
            query_params.append(('include_archived', local_var_params['include_archived']))  # noqa: E501
        if 'defaults_first' in local_var_params and local_var_params['defaults_first'] is not None:  # noqa: E501
            query_params.append(('defaults_first', local_var_params['defaults_first']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedapplicationtemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_builds_api_v2_builds_get(self, application_template_id, **kwargs):  # noqa: E501
        """List Builds  # noqa: E501

        Lists all Builds belonging to an App Config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_builds_api_v2_builds_get(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedbuildListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_builds_api_v2_builds_get_with_http_info(application_template_id, **kwargs)  # noqa: E501

    def list_builds_api_v2_builds_get_with_http_info(self, application_template_id, **kwargs):  # noqa: E501
        """List Builds  # noqa: E501

        Lists all Builds belonging to an App Config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_builds_api_v2_builds_get_with_http_info(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedbuildListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'application_template_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_builds_api_v2_builds_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_template_id' is set
        if self.api_client.client_side_validation and ('application_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_template_id` when calling `list_builds_api_v2_builds_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_builds_api_v2_builds_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_builds_api_v2_builds_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_template_id' in local_var_params and local_var_params['application_template_id'] is not None:  # noqa: E501
            query_params.append(('application_template_id', local_var_params['application_template_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedbuildListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_catalogs_in_connection_api_v2_data_catalogs_connections_connection_id_catalogs_get(self, connection_id, **kwargs):  # noqa: E501
        """List Catalogs In Connection  # noqa: E501

        Lists all catalogs within a specific provider connection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_catalogs_in_connection_api_v2_data_catalogs_connections_connection_id_catalogs_get(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatacatalogListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_catalogs_in_connection_api_v2_data_catalogs_connections_connection_id_catalogs_get_with_http_info(connection_id, **kwargs)  # noqa: E501

    def list_catalogs_in_connection_api_v2_data_catalogs_connections_connection_id_catalogs_get_with_http_info(self, connection_id, **kwargs):  # noqa: E501
        """List Catalogs In Connection  # noqa: E501

        Lists all catalogs within a specific provider connection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_catalogs_in_connection_api_v2_data_catalogs_connections_connection_id_catalogs_get_with_http_info(connection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatacatalogListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connection_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_catalogs_in_connection_api_v2_data_catalogs_connections_connection_id_catalogs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and ('connection_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connection_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `list_catalogs_in_connection_api_v2_data_catalogs_connections_connection_id_catalogs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connection_id'] = local_var_params['connection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/data_catalogs/connections/{connection_id}/catalogs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatacatalogListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_clouds_api_v2_clouds_get(self, **kwargs):  # noqa: E501
        """List Clouds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_clouds_api_v2_clouds_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_clouds_api_v2_clouds_get_with_http_info(**kwargs)  # noqa: E501

    def list_clouds_api_v2_clouds_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Clouds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_clouds_api_v2_clouds_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_clouds_api_v2_clouds_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_clouds_api_v2_clouds_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_clouds_api_v2_clouds_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_configurations_api_v2_organization_configurations_get(self, **kwargs):  # noqa: E501
        """List Configurations  # noqa: E501

        List all organization configurations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_configurations_api_v2_organization_configurations_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationconfigurationListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_configurations_api_v2_organization_configurations_get_with_http_info(**kwargs)  # noqa: E501

    def list_configurations_api_v2_organization_configurations_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Configurations  # noqa: E501

        List all organization configurations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_configurations_api_v2_organization_configurations_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationconfigurationListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_configurations_api_v2_organization_configurations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_configurations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationconfigurationListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_cron_jobs_api_v2_experimental_cron_jobs_get(self, **kwargs):  # noqa: E501
        """List Cron Jobs  # noqa: E501

        List CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_cron_jobs_api_v2_experimental_cron_jobs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str cloud_id: cloud_id to filter by
        :param str name: name to filter by
        :param str creator_id: filter by creator id
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedscheduleListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_cron_jobs_api_v2_experimental_cron_jobs_get_with_http_info(**kwargs)  # noqa: E501

    def list_cron_jobs_api_v2_experimental_cron_jobs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Cron Jobs  # noqa: E501

        List CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_cron_jobs_api_v2_experimental_cron_jobs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str cloud_id: cloud_id to filter by
        :param str name: name to filter by
        :param str creator_id: filter by creator id
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedscheduleListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'cloud_id',
            'name',
            'creator_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cron_jobs_api_v2_experimental_cron_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_cron_jobs_api_v2_experimental_cron_jobs_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_cron_jobs_api_v2_experimental_cron_jobs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedscheduleListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_data_catalog_connections_api_v2_data_catalogs_connections_get(self, **kwargs):  # noqa: E501
        """List Data Catalog Connections  # noqa: E501

        Lists all data catalog provider connections.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_data_catalog_connections_api_v2_data_catalogs_connections_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatacatalogconnectionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_data_catalog_connections_api_v2_data_catalogs_connections_get_with_http_info(**kwargs)  # noqa: E501

    def list_data_catalog_connections_api_v2_data_catalogs_connections_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Data Catalog Connections  # noqa: E501

        Lists all data catalog provider connections.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_data_catalog_connections_api_v2_data_catalogs_connections_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatacatalogconnectionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_data_catalog_connections_api_v2_data_catalogs_connections_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/data_catalogs/connections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatacatalogconnectionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_databricks_connections_api_v2_integrations_connections_databricks_get(self, **kwargs):  # noqa: E501
        """List Databricks Connections  # noqa: E501

        List all registered Databricks connections  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_databricks_connections_api_v2_integrations_connections_databricks_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ValidationStatus validation_status:
        :param ConnectionType connection_type:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListDatabricksConnections
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_databricks_connections_api_v2_integrations_connections_databricks_get_with_http_info(**kwargs)  # noqa: E501

    def list_databricks_connections_api_v2_integrations_connections_databricks_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Databricks Connections  # noqa: E501

        List all registered Databricks connections  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_databricks_connections_api_v2_integrations_connections_databricks_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ValidationStatus validation_status:
        :param ConnectionType connection_type:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListDatabricksConnections, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'validation_status',
            'connection_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_databricks_connections_api_v2_integrations_connections_databricks_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'validation_status' in local_var_params and local_var_params['validation_status'] is not None:  # noqa: E501
            query_params.append(('validation_status', local_var_params['validation_status']))  # noqa: E501
        if 'connection_type' in local_var_params and local_var_params['connection_type'] is not None:  # noqa: E501
            query_params.append(('connection_type', local_var_params['connection_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/connections/databricks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListDatabricksConnections',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dataset_versions_api_v2_datasets_versions_get(self, dataset_id, **kwargs):  # noqa: E501
        """List Dataset Versions  # noqa: E501

        Lists versions of the Dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dataset_versions_api_v2_datasets_versions_get(dataset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str dataset_id: (required)
        :param int limit: Number of elements to return
        :param int after: Version number to start listing after (eg. the last element returned in the previous page)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_dataset_versions_api_v2_datasets_versions_get_with_http_info(dataset_id, **kwargs)  # noqa: E501

    def list_dataset_versions_api_v2_datasets_versions_get_with_http_info(self, dataset_id, **kwargs):  # noqa: E501
        """List Dataset Versions  # noqa: E501

        Lists versions of the Dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_dataset_versions_api_v2_datasets_versions_get_with_http_info(dataset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str dataset_id: (required)
        :param int limit: Number of elements to return
        :param int after: Version number to start listing after (eg. the last element returned in the previous page)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'dataset_id',
            'limit',
            'after'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dataset_versions_api_v2_datasets_versions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and ('dataset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dataset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `list_dataset_versions_api_v2_datasets_versions_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `list_dataset_versions_api_v2_datasets_versions_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `list_dataset_versions_api_v2_datasets_versions_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dataset_id' in local_var_params and local_var_params['dataset_id'] is not None:  # noqa: E501
            query_params.append(('dataset_id', local_var_params['dataset_id']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/datasets/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_datasets_api_v2_datasets_get(self, **kwargs):  # noqa: E501
        """List Datasets  # noqa: E501

        Lists all Dataset objects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_datasets_api_v2_datasets_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: ID of the Anyscale cloud to search in.
        :param str project_id: ID of the Anyscale project to search in.
        :param str name_contains: Search records with `name` containing this string (case-insensitive).
        :param str creator_id: ID of the user who created the dataset.
        :param int limit: Number of elements to return
        :param str after: ID of the element to start listing after (eg. the last element returned in the previous page)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatasetListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_datasets_api_v2_datasets_get_with_http_info(**kwargs)  # noqa: E501

    def list_datasets_api_v2_datasets_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Datasets  # noqa: E501

        Lists all Dataset objects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_datasets_api_v2_datasets_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: ID of the Anyscale cloud to search in.
        :param str project_id: ID of the Anyscale project to search in.
        :param str name_contains: Search records with `name` containing this string (case-insensitive).
        :param str creator_id: ID of the user who created the dataset.
        :param int limit: Number of elements to return
        :param str after: ID of the element to start listing after (eg. the last element returned in the previous page)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatasetListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'project_id',
            'name_contains',
            'creator_id',
            'limit',
            'after'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_datasets_api_v2_datasets_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `list_datasets_api_v2_datasets_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `list_datasets_api_v2_datasets_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/datasets/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatasetListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_clusters_api_v2_decorated_sessions_get(self, **kwargs):  # noqa: E501
        """List Decorated Clusters  # noqa: E501

        List all sessions for a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_clusters_api_v2_decorated_sessions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str cloud_id: cloud_id to filter by
        :param str name_match: a wildcard match for session names. This endpoint will raise an error if both name and name_match is provided.
        :param str creator_id: creator_id to filter by
        :param list[SessionState] state_filter: A list of session states to filter by
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param SessionsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedsessionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_clusters_api_v2_decorated_sessions_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_clusters_api_v2_decorated_sessions_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Clusters  # noqa: E501

        List all sessions for a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_clusters_api_v2_decorated_sessions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str cloud_id: cloud_id to filter by
        :param str name_match: a wildcard match for session names. This endpoint will raise an error if both name and name_match is provided.
        :param str creator_id: creator_id to filter by
        :param list[SessionState] state_filter: A list of session states to filter by
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param SessionsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedsessionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'cloud_id',
            'name_match',
            'creator_id',
            'state_filter',
            'archive_status',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_clusters_api_v2_decorated_sessions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_clusters_api_v2_decorated_sessions_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_clusters_api_v2_decorated_sessions_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'name_match' in local_var_params and local_var_params['name_match'] is not None:  # noqa: E501
            query_params.append(('name_match', local_var_params['name_match']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'archive_status' in local_var_params and local_var_params['archive_status'] is not None:  # noqa: E501
            query_params.append(('archive_status', local_var_params['archive_status']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_sessions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedsessionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get(self, **kwargs):  # noqa: E501
        """List Decorated Interactive Sessions  # noqa: E501

        Optionally filter by project and runtime_env_id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str runtime_env_id: runtime_env_id to filter by
        :param str cluster_id: cluster_id to filter by
        :param str creator_id: creator_id to filter by
        :param str name: name to filter by
        :param str ha_job_id: ha_job_id to filter by
        :param bool show_ray_client_runs_only: DEPRECATED: Shows only ray client runs. Orthogonaol to passing ha_job_id
        :param list[JobRunType] type_filter: Filter Jobs by their type. Their type is determined by their usage within the product e.g. Interactive sessions, job runs
        :param list[BaseJobStatus] state_filter: A list of session states to filter by
        :param str order: 'asc' for ascending, 'desc' for descending. Entirely ignored.
        :param JobsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedinteractivesessionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Interactive Sessions  # noqa: E501

        Optionally filter by project and runtime_env_id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str runtime_env_id: runtime_env_id to filter by
        :param str cluster_id: cluster_id to filter by
        :param str creator_id: creator_id to filter by
        :param str name: name to filter by
        :param str ha_job_id: ha_job_id to filter by
        :param bool show_ray_client_runs_only: DEPRECATED: Shows only ray client runs. Orthogonaol to passing ha_job_id
        :param list[JobRunType] type_filter: Filter Jobs by their type. Their type is determined by their usage within the product e.g. Interactive sessions, job runs
        :param list[BaseJobStatus] state_filter: A list of session states to filter by
        :param str order: 'asc' for ascending, 'desc' for descending. Entirely ignored.
        :param JobsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedinteractivesessionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'runtime_env_id',
            'cluster_id',
            'creator_id',
            'name',
            'ha_job_id',
            'show_ray_client_runs_only',
            'type_filter',
            'state_filter',
            'order',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'runtime_env_id' in local_var_params and local_var_params['runtime_env_id'] is not None:  # noqa: E501
            query_params.append(('runtime_env_id', local_var_params['runtime_env_id']))  # noqa: E501
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'show_ray_client_runs_only' in local_var_params and local_var_params['show_ray_client_runs_only'] is not None:  # noqa: E501
            query_params.append(('show_ray_client_runs_only', local_var_params['show_ray_client_runs_only']))  # noqa: E501
        if 'type_filter' in local_var_params and local_var_params['type_filter'] is not None:  # noqa: E501
            query_params.append(('type_filter', local_var_params['type_filter']))  # noqa: E501
            collection_formats['type_filter'] = 'multi'  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'order' in local_var_params and local_var_params['order'] is not None:  # noqa: E501
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_interactive_sessions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedinteractivesessionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_jobs_api_v2_decorated_ha_jobs_get(self, **kwargs):  # noqa: E501
        """List Decorated Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_jobs_api_v2_decorated_ha_jobs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str workspace_id: workspace_id to filter by
        :param str name: name to filter by
        :param list[HaJobStates] state_filter: A list of session states to filter by
        :param HaJobType type_filter: The job type to filter by
        :param str creator_id: filter by creator id
        :param str source_cron_job_id: filter by cron_job_id id
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param str cloud_id: cloud_id to filter by
        :param list[str] tag_filter: Repeatable filter of tags in the form key:value. Can be specified multiple times. Values with the same key are ORed; keys are ANDed.
        :param HaJobsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedproductionjobListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_jobs_api_v2_decorated_ha_jobs_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_jobs_api_v2_decorated_ha_jobs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_jobs_api_v2_decorated_ha_jobs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str workspace_id: workspace_id to filter by
        :param str name: name to filter by
        :param list[HaJobStates] state_filter: A list of session states to filter by
        :param HaJobType type_filter: The job type to filter by
        :param str creator_id: filter by creator id
        :param str source_cron_job_id: filter by cron_job_id id
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param str cloud_id: cloud_id to filter by
        :param list[str] tag_filter: Repeatable filter of tags in the form key:value. Can be specified multiple times. Values with the same key are ORed; keys are ANDed.
        :param HaJobsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedproductionjobListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'workspace_id',
            'name',
            'state_filter',
            'type_filter',
            'creator_id',
            'source_cron_job_id',
            'archive_status',
            'cloud_id',
            'tag_filter',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_jobs_api_v2_decorated_ha_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_jobs_api_v2_decorated_ha_jobs_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_jobs_api_v2_decorated_ha_jobs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'type_filter' in local_var_params and local_var_params['type_filter'] is not None:  # noqa: E501
            query_params.append(('type_filter', local_var_params['type_filter']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'source_cron_job_id' in local_var_params and local_var_params['source_cron_job_id'] is not None:  # noqa: E501
            query_params.append(('source_cron_job_id', local_var_params['source_cron_job_id']))  # noqa: E501
        if 'archive_status' in local_var_params and local_var_params['archive_status'] is not None:  # noqa: E501
            query_params.append(('archive_status', local_var_params['archive_status']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'tag_filter' in local_var_params and local_var_params['tag_filter'] is not None:  # noqa: E501
            query_params.append(('tag_filter', local_var_params['tag_filter']))  # noqa: E501
            collection_formats['tag_filter'] = 'multi'  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedproductionjobListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get(self, **kwargs):  # noqa: E501
        """List Decorated Serve Deployments  # noqa: E501

        List decorated serve deployments. Filter by cluster   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: A cluster id to filter by
        :param str application_name: An application name to filter by
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedservedeploymentListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Serve Deployments  # noqa: E501

        List decorated serve deployments. Filter by cluster   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: A cluster id to filter by
        :param str application_name: An application name to filter by
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedservedeploymentListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'application_name',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'application_name' in local_var_params and local_var_params['application_name'] is not None:  # noqa: E501
            query_params.append(('application_name', local_var_params['application_name']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_serve_deployments/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedservedeploymentListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_instance_usage_budgets_api_v2_instance_usage_budgets_get(self, **kwargs):  # noqa: E501
        """List Instance Usage Budgets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_instance_usage_budgets_api_v2_instance_usage_budgets_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str creator_id:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InstanceusagebudgetListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_instance_usage_budgets_api_v2_instance_usage_budgets_get_with_http_info(**kwargs)  # noqa: E501

    def list_instance_usage_budgets_api_v2_instance_usage_budgets_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Instance Usage Budgets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_instance_usage_budgets_api_v2_instance_usage_budgets_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str creator_id:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InstanceusagebudgetListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'creator_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_instance_usage_budgets_api_v2_instance_usage_budgets_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_instance_usage_budgets_api_v2_instance_usage_budgets_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_instance_usage_budgets_api_v2_instance_usage_budgets_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/instance_usage_budgets/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceusagebudgetListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_invitations_api_v2_organization_invitations_get(self, **kwargs):  # noqa: E501
        """List Invitations  # noqa: E501

        Fetches active, unaccepted organization invitations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_invitations_api_v2_organization_invitations_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationinvitationListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_invitations_api_v2_organization_invitations_get_with_http_info(**kwargs)  # noqa: E501

    def list_invitations_api_v2_organization_invitations_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Invitations  # noqa: E501

        Fetches active, unaccepted organization invitations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_invitations_api_v2_organization_invitations_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationinvitationListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_invitations_api_v2_organization_invitations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_invitations_api_v2_organization_invitations_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_invitations_api_v2_organization_invitations_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email' in local_var_params and local_var_params['email'] is not None:  # noqa: E501
            query_params.append(('email', local_var_params['email']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationinvitationListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_job_queues_api_v2_job_queues_post(self, job_queues_query, **kwargs):  # noqa: E501
        """List Job Queues  # noqa: E501

        Lists job queues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_job_queues_api_v2_job_queues_post(job_queues_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param JobQueuesQuery job_queues_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedjobqueueListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_job_queues_api_v2_job_queues_post_with_http_info(job_queues_query, **kwargs)  # noqa: E501

    def list_job_queues_api_v2_job_queues_post_with_http_info(self, job_queues_query, **kwargs):  # noqa: E501
        """List Job Queues  # noqa: E501

        Lists job queues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_job_queues_api_v2_job_queues_post_with_http_info(job_queues_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param JobQueuesQuery job_queues_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedjobqueueListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_queues_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_job_queues_api_v2_job_queues_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_queues_query' is set
        if self.api_client.client_side_validation and ('job_queues_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_queues_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_queues_query` when calling `list_job_queues_api_v2_job_queues_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'job_queues_query' in local_var_params:
            body_params = local_var_params['job_queues_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/job_queues/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedjobqueueListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_job_reports_api_v2_job_reports_get(self, cloud_id, **kwargs):  # noqa: E501
        """List Job Reports  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_job_reports_api_v2_job_reports_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param datetime start_time:
        :param datetime end_time:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobwithreportListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_job_reports_api_v2_job_reports_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def list_job_reports_api_v2_job_reports_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """List Job Reports  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_job_reports_api_v2_job_reports_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param datetime start_time:
        :param datetime end_time:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobwithreportListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'start_time',
            'end_time',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_job_reports_api_v2_job_reports_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `list_job_reports_api_v2_job_reports_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_job_reports_api_v2_job_reports_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_job_reports_api_v2_job_reports_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/job_reports/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobwithreportListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_job_states_api_v2_decorated_ha_job_states_get(self, ha_job_id, **kwargs):  # noqa: E501
        """List Job States  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_job_states_api_v2_decorated_ha_job_states_get(ha_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ha_job_id: The production job to fetch state transitions for (required)
        :param list[JobStateLogLevelTypes] log_filter: Log level to filter state transitions by
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedproductionjobstatetransitionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_job_states_api_v2_decorated_ha_job_states_get_with_http_info(ha_job_id, **kwargs)  # noqa: E501

    def list_job_states_api_v2_decorated_ha_job_states_get_with_http_info(self, ha_job_id, **kwargs):  # noqa: E501
        """List Job States  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_job_states_api_v2_decorated_ha_job_states_get_with_http_info(ha_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ha_job_id: The production job to fetch state transitions for (required)
        :param list[JobStateLogLevelTypes] log_filter: Log level to filter state transitions by
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedproductionjobstatetransitionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'ha_job_id',
            'log_filter',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_job_states_api_v2_decorated_ha_job_states_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ha_job_id' is set
        if self.api_client.client_side_validation and ('ha_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ha_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ha_job_id` when calling `list_job_states_api_v2_decorated_ha_job_states_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_job_states_api_v2_decorated_ha_job_states_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_job_states_api_v2_decorated_ha_job_states_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'log_filter' in local_var_params and local_var_params['log_filter'] is not None:  # noqa: E501
            query_params.append(('log_filter', local_var_params['log_filter']))  # noqa: E501
            collection_formats['log_filter'] = 'multi'  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_job_states/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedproductionjobstatetransitionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_jobs_api_v2_decorated_unified_jobs_get(self, **kwargs):  # noqa: E501
        """List Jobs  # noqa: E501

        List all Jobs the user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_jobs_api_v2_decorated_unified_jobs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_contains: Name that contains the provided value, to filter by. If absent, no filtering is done.
        :param list[UnifiedJobStatus] status: Statuses to filter by. If absent, no filtering is done.
        :param str creator_id: User to filter by. If absent, no filtering is done.
        :param ArchiveStatus archive_status: Archive status to filter by. If absent, archived jobs are excluded.
        :param str project_id: Project to filter by. If absent, no filtering is done.
        :param str workspace_id: Workspace to filter by. If absent, no filtering is done.
        :param str cloud_id: Search for job with cloud_id
        :param str job_queue_id: Job queue to filter by. If absent, no filtering is done.
        :param UnifiedJobSortField sort_field: If absent, jobs will be ordered by status (active first). See order declared in `UnifiedJobSortField`
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If sort_order is absent, this field defaults to descending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedunifiedjobListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_jobs_api_v2_decorated_unified_jobs_get_with_http_info(**kwargs)  # noqa: E501

    def list_jobs_api_v2_decorated_unified_jobs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Jobs  # noqa: E501

        List all Jobs the user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_jobs_api_v2_decorated_unified_jobs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_contains: Name that contains the provided value, to filter by. If absent, no filtering is done.
        :param list[UnifiedJobStatus] status: Statuses to filter by. If absent, no filtering is done.
        :param str creator_id: User to filter by. If absent, no filtering is done.
        :param ArchiveStatus archive_status: Archive status to filter by. If absent, archived jobs are excluded.
        :param str project_id: Project to filter by. If absent, no filtering is done.
        :param str workspace_id: Workspace to filter by. If absent, no filtering is done.
        :param str cloud_id: Search for job with cloud_id
        :param str job_queue_id: Job queue to filter by. If absent, no filtering is done.
        :param UnifiedJobSortField sort_field: If absent, jobs will be ordered by status (active first). See order declared in `UnifiedJobSortField`
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If sort_order is absent, this field defaults to descending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedunifiedjobListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name_contains',
            'status',
            'creator_id',
            'archive_status',
            'project_id',
            'workspace_id',
            'cloud_id',
            'job_queue_id',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_jobs_api_v2_decorated_unified_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_jobs_api_v2_decorated_unified_jobs_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_jobs_api_v2_decorated_unified_jobs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
            collection_formats['status'] = 'multi'  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'archive_status' in local_var_params and local_var_params['archive_status'] is not None:  # noqa: E501
            query_params.append(('archive_status', local_var_params['archive_status']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'job_queue_id' in local_var_params and local_var_params['job_queue_id'] is not None:  # noqa: E501
            query_params.append(('job_queue_id', local_var_params['job_queue_id']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_unified_jobs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedunifiedjobListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_keys_api_v2_tags_keys_get(self, **kwargs):  # noqa: E501
        """List Keys  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_keys_api_v2_tags_keys_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResourceTagResourceType resource_type:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TagkeyListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_keys_api_v2_tags_keys_get_with_http_info(**kwargs)  # noqa: E501

    def list_keys_api_v2_tags_keys_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Keys  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_keys_api_v2_tags_keys_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResourceTagResourceType resource_type:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TagkeyListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_type',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_keys_api_v2_tags_keys_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_keys_api_v2_tags_keys_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_keys_api_v2_tags_keys_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'resource_type' in local_var_params and local_var_params['resource_type'] is not None:  # noqa: E501
            query_params.append(('resource_type', local_var_params['resource_type']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tags/keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagkeyListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_lineage_artifacts_api_v2_lineage_artifacts_get(self, artifact_type, **kwargs):  # noqa: E501
        """List Lineage Artifacts  # noqa: E501

        List all Anyscale tracked artifacts with filters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lineage_artifacts_api_v2_lineage_artifacts_get(artifact_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LineageArtifactType artifact_type: Lineage artifact type. (required)
        :param str cloud_id: Filter by cloud ID.
        :param str project_id: Filter by project ID.
        :param str creator_id: Filter artifacts created by a given user ID.
        :param str name_or_uri_contains: Filter artifacts with name or URI containing this value (case-insensitive).
        :param LineageArtifactSortField sort_field: Sort field. Defaults to created_at.
        :param SortOrder sort_order: Sort order. Defaults to descending.
        :param str paging_token: Pagination token
        :param int count: Page size
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LineageartifactListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_lineage_artifacts_api_v2_lineage_artifacts_get_with_http_info(artifact_type, **kwargs)  # noqa: E501

    def list_lineage_artifacts_api_v2_lineage_artifacts_get_with_http_info(self, artifact_type, **kwargs):  # noqa: E501
        """List Lineage Artifacts  # noqa: E501

        List all Anyscale tracked artifacts with filters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lineage_artifacts_api_v2_lineage_artifacts_get_with_http_info(artifact_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LineageArtifactType artifact_type: Lineage artifact type. (required)
        :param str cloud_id: Filter by cloud ID.
        :param str project_id: Filter by project ID.
        :param str creator_id: Filter artifacts created by a given user ID.
        :param str name_or_uri_contains: Filter artifacts with name or URI containing this value (case-insensitive).
        :param LineageArtifactSortField sort_field: Sort field. Defaults to created_at.
        :param SortOrder sort_order: Sort order. Defaults to descending.
        :param str paging_token: Pagination token
        :param int count: Page size
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LineageartifactListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'artifact_type',
            'cloud_id',
            'project_id',
            'creator_id',
            'name_or_uri_contains',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_lineage_artifacts_api_v2_lineage_artifacts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'artifact_type' is set
        if self.api_client.client_side_validation and ('artifact_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['artifact_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `artifact_type` when calling `list_lineage_artifacts_api_v2_lineage_artifacts_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_lineage_artifacts_api_v2_lineage_artifacts_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_lineage_artifacts_api_v2_lineage_artifacts_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'artifact_type' in local_var_params and local_var_params['artifact_type'] is not None:  # noqa: E501
            query_params.append(('artifact_type', local_var_params['artifact_type']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'name_or_uri_contains' in local_var_params and local_var_params['name_or_uri_contains'] is not None:  # noqa: E501
            query_params.append(('name_or_uri_contains', local_var_params['name_or_uri_contains']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lineage/artifacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LineageartifactListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_lineage_workloads_api_v2_lineage_workloads_get(self, workload_type, **kwargs):  # noqa: E501
        """List Lineage Workloads  # noqa: E501

        List all Anyscale tracked workloads with filters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lineage_workloads_api_v2_lineage_workloads_get(workload_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LineageWorkloadType workload_type: Lineage workload type. (required)
        :param str anyscale_workload_id: Filter by Anyscale workload ID. This takes precedence over project_id and cloud_id filters.
        :param str project_id: Filter by project ID. This takes precedence over cloud_id filter.
        :param str cloud_id: Filter by cloud ID.
        :param LineageWorkloadSortField sort_field: Sort field. Defaults to created_at.
        :param SortOrder sort_order: Sort order. Defaults to descending.
        :param str paging_token: Pagination token
        :param int count: Page size
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LineageworkloadListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_lineage_workloads_api_v2_lineage_workloads_get_with_http_info(workload_type, **kwargs)  # noqa: E501

    def list_lineage_workloads_api_v2_lineage_workloads_get_with_http_info(self, workload_type, **kwargs):  # noqa: E501
        """List Lineage Workloads  # noqa: E501

        List all Anyscale tracked workloads with filters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_lineage_workloads_api_v2_lineage_workloads_get_with_http_info(workload_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LineageWorkloadType workload_type: Lineage workload type. (required)
        :param str anyscale_workload_id: Filter by Anyscale workload ID. This takes precedence over project_id and cloud_id filters.
        :param str project_id: Filter by project ID. This takes precedence over cloud_id filter.
        :param str cloud_id: Filter by cloud ID.
        :param LineageWorkloadSortField sort_field: Sort field. Defaults to created_at.
        :param SortOrder sort_order: Sort order. Defaults to descending.
        :param str paging_token: Pagination token
        :param int count: Page size
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LineageworkloadListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workload_type',
            'anyscale_workload_id',
            'project_id',
            'cloud_id',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_lineage_workloads_api_v2_lineage_workloads_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workload_type' is set
        if self.api_client.client_side_validation and ('workload_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['workload_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workload_type` when calling `list_lineage_workloads_api_v2_lineage_workloads_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_lineage_workloads_api_v2_lineage_workloads_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_lineage_workloads_api_v2_lineage_workloads_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'workload_type' in local_var_params and local_var_params['workload_type'] is not None:  # noqa: E501
            query_params.append(('workload_type', local_var_params['workload_type']))  # noqa: E501
        if 'anyscale_workload_id' in local_var_params and local_var_params['anyscale_workload_id'] is not None:  # noqa: E501
            query_params.append(('anyscale_workload_id', local_var_params['anyscale_workload_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lineage/workloads', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LineageworkloadListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_long_running_workloads_api_v2_decorated_sessions_long_running_workloads_get(self, **kwargs):  # noqa: E501
        """List Long Running Workloads  # noqa: E501

        Lists long running workloads within a cloud or organization, sorted by duration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_long_running_workloads_api_v2_decorated_sessions_long_running_workloads_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: The cloud ID to filter by.
        :param str project_id: The project ID to filter by.
        :param bool jobs_only: Whether to only include jobs.
        :param bool workspaces_only: Whether to only include workspaces.
        :param int duration_s: The duration in seconds to filter by. Defaults to 24 hours.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LongrunningworkloadListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_long_running_workloads_api_v2_decorated_sessions_long_running_workloads_get_with_http_info(**kwargs)  # noqa: E501

    def list_long_running_workloads_api_v2_decorated_sessions_long_running_workloads_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Long Running Workloads  # noqa: E501

        Lists long running workloads within a cloud or organization, sorted by duration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_long_running_workloads_api_v2_decorated_sessions_long_running_workloads_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: The cloud ID to filter by.
        :param str project_id: The project ID to filter by.
        :param bool jobs_only: Whether to only include jobs.
        :param bool workspaces_only: Whether to only include workspaces.
        :param int duration_s: The duration in seconds to filter by. Defaults to 24 hours.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LongrunningworkloadListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'project_id',
            'jobs_only',
            'workspaces_only',
            'duration_s'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_long_running_workloads_api_v2_decorated_sessions_long_running_workloads_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'jobs_only' in local_var_params and local_var_params['jobs_only'] is not None:  # noqa: E501
            query_params.append(('jobs_only', local_var_params['jobs_only']))  # noqa: E501
        if 'workspaces_only' in local_var_params and local_var_params['workspaces_only'] is not None:  # noqa: E501
            query_params.append(('workspaces_only', local_var_params['workspaces_only']))  # noqa: E501
        if 'duration_s' in local_var_params and local_var_params['duration_s'] is not None:  # noqa: E501
            query_params.append(('duration_s', local_var_params['duration_s']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_sessions/long-running-workloads', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LongrunningworkloadListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_machine_pools_api_v2_machine_pools_get(self, **kwargs):  # noqa: E501
        """List Machine Pools  # noqa: E501

        Lists machine pools.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_machine_pools_api_v2_machine_pools_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListmachinepoolsresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_machine_pools_api_v2_machine_pools_get_with_http_info(**kwargs)  # noqa: E501

    def list_machine_pools_api_v2_machine_pools_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Machine Pools  # noqa: E501

        Lists machine pools.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_machine_pools_api_v2_machine_pools_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListmachinepoolsresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_machine_pools_api_v2_machine_pools_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListmachinepoolsresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_machines_api_v2_machines_get(self, **kwargs):  # noqa: E501
        """List Machines  # noqa: E501

        List machines registered to the corresponding Anyscale Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_machines_api_v2_machines_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: DEPRECATED: Machines are organization-scoped, so this field is no longer relevant.
        :param str machine_pool_name:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListmachinesresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_machines_api_v2_machines_get_with_http_info(**kwargs)  # noqa: E501

    def list_machines_api_v2_machines_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Machines  # noqa: E501

        List machines registered to the corresponding Anyscale Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_machines_api_v2_machines_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: DEPRECATED: Machines are organization-scoped, so this field is no longer relevant.
        :param str machine_pool_name:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListmachinesresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'machine_pool_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_machines_api_v2_machines_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'machine_pool_name' in local_var_params and local_var_params['machine_pool_name'] is not None:  # noqa: E501
            query_params.append(('machine_pool_name', local_var_params['machine_pool_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListmachinesresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_metronome_customer_info_api_v2_metronome_customer_info_get(self, **kwargs):  # noqa: E501
        """List Metronome Customer Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_metronome_customer_info_api_v2_metronome_customer_info_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MetronomecustomerinfomodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_metronome_customer_info_api_v2_metronome_customer_info_get_with_http_info(**kwargs)  # noqa: E501

    def list_metronome_customer_info_api_v2_metronome_customer_info_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Metronome Customer Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_metronome_customer_info_api_v2_metronome_customer_info_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MetronomecustomerinfomodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_metronome_customer_info_api_v2_metronome_customer_info_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/metronome_customer_info/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetronomecustomerinfomodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_models_api_v2_llm_models_get(self, **kwargs):  # noqa: E501
        """List Models  # noqa: E501

        Lists models visible to the user in the model registry, optionally filtered by cloud id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_models_api_v2_llm_models_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id:
        :param str project_id:
        :param str workspace_id:
        :param str name_contains:
        :param str creator_id:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FinetunedmodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_models_api_v2_llm_models_get_with_http_info(**kwargs)  # noqa: E501

    def list_models_api_v2_llm_models_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Models  # noqa: E501

        Lists models visible to the user in the model registry, optionally filtered by cloud id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_models_api_v2_llm_models_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id:
        :param str project_id:
        :param str workspace_id:
        :param str name_contains:
        :param str creator_id:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FinetunedmodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'project_id',
            'workspace_id',
            'name_contains',
            'creator_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_models_api_v2_llm_models_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_models_api_v2_llm_models_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_models_api_v2_llm_models_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/llm/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FinetunedmodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_organization_collaborators_api_v2_organization_collaborators_get(self, **kwargs):  # noqa: E501
        """List Organization Collaborators  # noqa: E501

        Retrieves collaborators belonging to the logged in user's organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_organization_collaborators_api_v2_organization_collaborators_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email:
        :param str name:
        :param CollaboratorType collaborator_type:
        :param bool is_service_account:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationcollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_organization_collaborators_api_v2_organization_collaborators_get_with_http_info(**kwargs)  # noqa: E501

    def list_organization_collaborators_api_v2_organization_collaborators_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Organization Collaborators  # noqa: E501

        Retrieves collaborators belonging to the logged in user's organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_organization_collaborators_api_v2_organization_collaborators_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email:
        :param str name:
        :param CollaboratorType collaborator_type:
        :param bool is_service_account:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationcollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'name',
            'collaborator_type',
            'is_service_account',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_organization_collaborators_api_v2_organization_collaborators_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_organization_collaborators_api_v2_organization_collaborators_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_organization_collaborators_api_v2_organization_collaborators_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email' in local_var_params and local_var_params['email'] is not None:  # noqa: E501
            query_params.append(('email', local_var_params['email']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'collaborator_type' in local_var_params and local_var_params['collaborator_type'] is not None:  # noqa: E501
            query_params.append(('collaborator_type', local_var_params['collaborator_type']))  # noqa: E501
        if 'is_service_account' in local_var_params and local_var_params['is_service_account'] is not None:  # noqa: E501
            query_params.append(('is_service_account', local_var_params['is_service_account']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationcollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_project_collaborators_api_v2_projects_project_id_collaborators_users_get(self, project_id, **kwargs):  # noqa: E501
        """List Project Collaborators  # noqa: E501

        Get a list of all collaborators for a given project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_project_collaborators_api_v2_projects_project_id_collaborators_users_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectcollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_project_collaborators_api_v2_projects_project_id_collaborators_users_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def list_project_collaborators_api_v2_projects_project_id_collaborators_users_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """List Project Collaborators  # noqa: E501

        Get a list of all collaborators for a given project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_project_collaborators_api_v2_projects_project_id_collaborators_users_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectcollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_project_collaborators_api_v2_projects_project_id_collaborators_users_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `list_project_collaborators_api_v2_projects_project_id_collaborators_users_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_project_collaborators_api_v2_projects_project_id_collaborators_users_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_project_collaborators_api_v2_projects_project_id_collaborators_users_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectcollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_projects_api_v2_projects_get(self, **kwargs):  # noqa: E501
        """List Projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects_api_v2_projects_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_contains: filter by name of project
        :param str creator_id: filter by creator id
        :param str parent_cloud_id: filter by cloud this project is associated with
        :param bool include_defaults: include default projects
        :param ProjectsSortField sort_field: If absent, the sort order will be determined according to the entity type.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_projects_api_v2_projects_get_with_http_info(**kwargs)  # noqa: E501

    def list_projects_api_v2_projects_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects_api_v2_projects_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_contains: filter by name of project
        :param str creator_id: filter by creator id
        :param str parent_cloud_id: filter by cloud this project is associated with
        :param bool include_defaults: include default projects
        :param ProjectsSortField sort_field: If absent, the sort order will be determined according to the entity type.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name_contains',
            'creator_id',
            'parent_cloud_id',
            'include_defaults',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_projects_api_v2_projects_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_projects_api_v2_projects_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_projects_api_v2_projects_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'parent_cloud_id' in local_var_params and local_var_params['parent_cloud_id'] is not None:  # noqa: E501
            query_params.append(('parent_cloud_id', local_var_params['parent_cloud_id']))  # noqa: E501
        if 'include_defaults' in local_var_params and local_var_params['include_defaults'] is not None:  # noqa: E501
            query_params.append(('include_defaults', local_var_params['include_defaults']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ray_sessions_api_v2_tasks_dashboard_list_ray_sessions_get(self, cluster_id, **kwargs):  # noqa: E501
        """List Ray Sessions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_ray_sessions_api_v2_tasks_dashboard_list_ray_sessions_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListraysessionsresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_ray_sessions_api_v2_tasks_dashboard_list_ray_sessions_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def list_ray_sessions_api_v2_tasks_dashboard_list_ray_sessions_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """List Ray Sessions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_ray_sessions_api_v2_tasks_dashboard_list_ray_sessions_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListraysessionsresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ray_sessions_api_v2_tasks_dashboard_list_ray_sessions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `list_ray_sessions_api_v2_tasks_dashboard_list_ray_sessions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tasks_dashboard/list_ray_sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListraysessionsresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_recommended_workspace_templates_api_v2_experimental_workspaces_templates_recommended_get(self, **kwargs):  # noqa: E501
        """List Recommended Workspace Templates  # noqa: E501

        Lists all workspace templates ranked by user's organization marketing questions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_recommended_workspace_templates_api_v2_experimental_workspaces_templates_recommended_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: Maximum number of templates to return
        :param list[str] oa_group_names: Search for templates that belong to the provided group name
        :param bool for_gallery: Filters the list to show the ones expected for gallery section
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GlobalworkspacetemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_recommended_workspace_templates_api_v2_experimental_workspaces_templates_recommended_get_with_http_info(**kwargs)  # noqa: E501

    def list_recommended_workspace_templates_api_v2_experimental_workspaces_templates_recommended_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Recommended Workspace Templates  # noqa: E501

        Lists all workspace templates ranked by user's organization marketing questions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_recommended_workspace_templates_api_v2_experimental_workspaces_templates_recommended_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: Maximum number of templates to return
        :param list[str] oa_group_names: Search for templates that belong to the provided group name
        :param bool for_gallery: Filters the list to show the ones expected for gallery section
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GlobalworkspacetemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'count',
            'oa_group_names',
            'for_gallery'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_recommended_workspace_templates_api_v2_experimental_workspaces_templates_recommended_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501
        if 'oa_group_names' in local_var_params and local_var_params['oa_group_names'] is not None:  # noqa: E501
            query_params.append(('oa_group_names', local_var_params['oa_group_names']))  # noqa: E501
            collection_formats['oa_group_names'] = 'multi'  # noqa: E501
        if 'for_gallery' in local_var_params and local_var_params['for_gallery'] is not None:  # noqa: E501
            query_params.append(('for_gallery', local_var_params['for_gallery']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/templates/recommended', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GlobalworkspacetemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_resource_policies_api_v2_policy_resource_type_get(self, resource_type, **kwargs):  # noqa: E501
        """List Resource Policies  # noqa: E501

        List permission policies for all resources of a specific type in the current organization.  Parameters: - **resource_type**: Resource type to list policies for. Must be 'clouds' or 'projects'.  Returns: ``` {     \"results\": [         {             \"resource_id\": \"cld_abc123\",             \"resource_type\": \"cloud\",             \"bindings\": [                 {\"role_name\": \"write\", \"principals\": [\"ug_abc123\"]},                 {\"role_name\": \"readonly\", \"principals\": [\"ug_def456\"]}             ]         }     ],     \"metadata\": {         \"count\": 1     } } ```  Permission requirements: - Caller must be an admin of the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_resource_policies_api_v2_policy_resource_type_get(resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcepolicyitemListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_resource_policies_api_v2_policy_resource_type_get_with_http_info(resource_type, **kwargs)  # noqa: E501

    def list_resource_policies_api_v2_policy_resource_type_get_with_http_info(self, resource_type, **kwargs):  # noqa: E501
        """List Resource Policies  # noqa: E501

        List permission policies for all resources of a specific type in the current organization.  Parameters: - **resource_type**: Resource type to list policies for. Must be 'clouds' or 'projects'.  Returns: ``` {     \"results\": [         {             \"resource_id\": \"cld_abc123\",             \"resource_type\": \"cloud\",             \"bindings\": [                 {\"role_name\": \"write\", \"principals\": [\"ug_abc123\"]},                 {\"role_name\": \"readonly\", \"principals\": [\"ug_def456\"]}             ]         }     ],     \"metadata\": {         \"count\": 1     } } ```  Permission requirements: - Caller must be an admin of the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_resource_policies_api_v2_policy_resource_type_get_with_http_info(resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcepolicyitemListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_resource_policies_api_v2_policy_resource_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_type' is set
        if self.api_client.client_side_validation and ('resource_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_type` when calling `list_resource_policies_api_v2_policy_resource_type_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_type' in local_var_params:
            path_params['resource_type'] = local_var_params['resource_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/policy/{resource_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcepolicyitemListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_schemas_in_catalog_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_get(self, connection_id, catalog_id, **kwargs):  # noqa: E501
        """List Schemas In Catalog  # noqa: E501

        Lists all schemas within a specific catalog  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_schemas_in_catalog_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_get(connection_id, catalog_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatacatalogschemaListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_schemas_in_catalog_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_get_with_http_info(connection_id, catalog_id, **kwargs)  # noqa: E501

    def list_schemas_in_catalog_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_get_with_http_info(self, connection_id, catalog_id, **kwargs):  # noqa: E501
        """List Schemas In Catalog  # noqa: E501

        Lists all schemas within a specific catalog  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_schemas_in_catalog_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_get_with_http_info(connection_id, catalog_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatacatalogschemaListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'catalog_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_schemas_in_catalog_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and ('connection_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connection_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `list_schemas_in_catalog_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_get`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if self.api_client.client_side_validation and ('catalog_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['catalog_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `catalog_id` when calling `list_schemas_in_catalog_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connection_id'] = local_var_params['connection_id']  # noqa: E501
        if 'catalog_id' in local_var_params:
            path_params['catalog_id'] = local_var_params['catalog_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/data_catalogs/connections/{connection_id}/catalogs/{catalog_id}/schemas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatacatalogschemaListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_scim_user_permissions_api_v2_scim_list_user_permissions_get(self, **kwargs):  # noqa: E501
        """List Scim User Permissions  # noqa: E501

        List users and their effective cloud permissions, plus org owners.  This endpoint is intended to help customers verify access configuration while migrating to SCIM. The response does not include user-group details.  Args:     user_id: Optional user ID to filter. If provided, only that user's permissions              are returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_scim_user_permissions_api_v2_scim_list_user_permissions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScimlistuserpermissionsresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_scim_user_permissions_api_v2_scim_list_user_permissions_get_with_http_info(**kwargs)  # noqa: E501

    def list_scim_user_permissions_api_v2_scim_list_user_permissions_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Scim User Permissions  # noqa: E501

        List users and their effective cloud permissions, plus org owners.  This endpoint is intended to help customers verify access configuration while migrating to SCIM. The response does not include user-group details.  Args:     user_id: Optional user ID to filter. If provided, only that user's permissions              are returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_scim_user_permissions_api_v2_scim_list_user_permissions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScimlistuserpermissionsresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_scim_user_permissions_api_v2_scim_list_user_permissions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in local_var_params and local_var_params['user_id'] is not None:  # noqa: E501
            query_params.append(('user_id', local_var_params['user_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/scim/list-user-permissions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScimlistuserpermissionsresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_services_api_v2_services_v2_get(self, **kwargs):  # noqa: E501
        """List Services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_services_api_v2_services_v2_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str name: name to filter by
        :param list[ServiceEventCurrentState] state_filter: A list of Service states to filter by
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param str creator_id: creator_id to filter by
        :param str cloud_id: cloud_id to filter by
        :param list[ApplicationType] application_type: Application type to filter by
        :param list[str] tag_filter: Repeatable filter of tags in the form key:value. Can be specified multiple times. Values with the same key are ORed; keys are ANDed.
        :param ServiceSortField sort_field: If absent, the default sorting order is 1. status (active first).2. Last updated at (desc). 3. Name (asc).
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedlistserviceapimodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_services_api_v2_services_v2_get_with_http_info(**kwargs)  # noqa: E501

    def list_services_api_v2_services_v2_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_services_api_v2_services_v2_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str name: name to filter by
        :param list[ServiceEventCurrentState] state_filter: A list of Service states to filter by
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param str creator_id: creator_id to filter by
        :param str cloud_id: cloud_id to filter by
        :param list[ApplicationType] application_type: Application type to filter by
        :param list[str] tag_filter: Repeatable filter of tags in the form key:value. Can be specified multiple times. Values with the same key are ORed; keys are ANDed.
        :param ServiceSortField sort_field: If absent, the default sorting order is 1. status (active first).2. Last updated at (desc). 3. Name (asc).
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedlistserviceapimodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'name',
            'state_filter',
            'archive_status',
            'creator_id',
            'cloud_id',
            'application_type',
            'tag_filter',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_services_api_v2_services_v2_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_services_api_v2_services_v2_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_services_api_v2_services_v2_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'archive_status' in local_var_params and local_var_params['archive_status'] is not None:  # noqa: E501
            query_params.append(('archive_status', local_var_params['archive_status']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'application_type' in local_var_params and local_var_params['application_type'] is not None:  # noqa: E501
            query_params.append(('application_type', local_var_params['application_type']))  # noqa: E501
            collection_formats['application_type'] = 'multi'  # noqa: E501
        if 'tag_filter' in local_var_params and local_var_params['tag_filter'] is not None:  # noqa: E501
            query_params.append(('tag_filter', local_var_params['tag_filter']))  # noqa: E501
            collection_formats['tag_filter'] = 'multi'  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedlistserviceapimodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_sessions_api_v2_sessions_get(self, project_id, **kwargs):  # noqa: E501
        """List Sessions  # noqa: E501

        DEPRECATED: Use list_decorated_sessions in decorated_sessions_router instead.  List all sessions for a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sessions_api_v2_sessions_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str name:
        :param str name_match: a wildcard match for session names. This endpoint will raise an error if both name and name_match is provided.
        :param bool active_only: DEPRECATED. Use state_filter instead.
        :param list[SessionState] state_filter:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_sessions_api_v2_sessions_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def list_sessions_api_v2_sessions_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """List Sessions  # noqa: E501

        DEPRECATED: Use list_decorated_sessions in decorated_sessions_router instead.  List all sessions for a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sessions_api_v2_sessions_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str name:
        :param str name_match: a wildcard match for session names. This endpoint will raise an error if both name and name_match is provided.
        :param bool active_only: DEPRECATED. Use state_filter instead.
        :param list[SessionState] state_filter:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'name',
            'name_match',
            'active_only',
            'state_filter',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_sessions_api_v2_sessions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `list_sessions_api_v2_sessions_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_sessions_api_v2_sessions_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_sessions_api_v2_sessions_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name_match' in local_var_params and local_var_params['name_match'] is not None:  # noqa: E501
            query_params.append(('name_match', local_var_params['name_match']))  # noqa: E501
        if 'active_only' in local_var_params and local_var_params['active_only'] is not None:  # noqa: E501
            query_params.append(('active_only', local_var_params['active_only']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get(self, connection_id, catalog_id, schema_id, **kwargs):  # noqa: E501
        """List Tables In Schema  # noqa: E501

        Lists all tables within a specific schema  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get(connection_id, catalog_id, schema_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param str schema_id: ID of the schema (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatacatalogtableListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get_with_http_info(connection_id, catalog_id, schema_id, **kwargs)  # noqa: E501

    def list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get_with_http_info(self, connection_id, catalog_id, schema_id, **kwargs):  # noqa: E501
        """List Tables In Schema  # noqa: E501

        Lists all tables within a specific schema  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get_with_http_info(connection_id, catalog_id, schema_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param str schema_id: ID of the schema (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatacatalogtableListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'catalog_id',
            'schema_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and ('connection_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connection_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if self.api_client.client_side_validation and ('catalog_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['catalog_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `catalog_id` when calling `list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get`")  # noqa: E501
        # verify the required parameter 'schema_id' is set
        if self.api_client.client_side_validation and ('schema_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schema_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schema_id` when calling `list_tables_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_tables_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connection_id'] = local_var_params['connection_id']  # noqa: E501
        if 'catalog_id' in local_var_params:
            path_params['catalog_id'] = local_var_params['catalog_id']  # noqa: E501
        if 'schema_id' in local_var_params:
            path_params['schema_id'] = local_var_params['schema_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/data_catalogs/connections/{connection_id}/catalogs/{catalog_id}/schemas/{schema_id}/tables', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatacatalogtableListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_template_versions_api_v2_workspace_templates_template_id_versions_get(self, template_id, **kwargs):  # noqa: E501
        """List Template Versions  # noqa: E501

        List versions for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_template_versions_api_v2_workspace_templates_template_id_versions_get(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateversionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_template_versions_api_v2_workspace_templates_template_id_versions_get_with_http_info(template_id, **kwargs)  # noqa: E501

    def list_template_versions_api_v2_workspace_templates_template_id_versions_get_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """List Template Versions  # noqa: E501

        List versions for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_template_versions_api_v2_workspace_templates_template_id_versions_get_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateversionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_template_versions_api_v2_workspace_templates_template_id_versions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `list_template_versions_api_v2_workspace_templates_template_id_versions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/{template_id}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateversionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_templates_api_v2_workspace_templates_get(self, **kwargs):  # noqa: E501
        """List Templates  # noqa: E501

        List user's workspace templates with pagination, filtering, and search  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_templates_api_v2_workspace_templates_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Filter by template name (partial match)
        :param str text_contains: Filter by template name, description, or labels (partial match)
        :param WorkspaceTemplateComplexity complexity: Filter by complexity level
        :param WorkspaceTemplateCategory category: Filter by category
        :param str labels: Comma-separated list of labels to filter by
        :param str cloud_id: Filter by cloud ID
        :param bool is_global: Filter by global templates
        :param str creator_id: Filter by creator user ID
        :param PublishedFilter published: Filter by published templates
        :param str paging_token:
        :param int count:
        :param WorkspaceTemplatesSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_templates_api_v2_workspace_templates_get_with_http_info(**kwargs)  # noqa: E501

    def list_templates_api_v2_workspace_templates_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Templates  # noqa: E501

        List user's workspace templates with pagination, filtering, and search  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_templates_api_v2_workspace_templates_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Filter by template name (partial match)
        :param str text_contains: Filter by template name, description, or labels (partial match)
        :param WorkspaceTemplateComplexity complexity: Filter by complexity level
        :param WorkspaceTemplateCategory category: Filter by category
        :param str labels: Comma-separated list of labels to filter by
        :param str cloud_id: Filter by cloud ID
        :param bool is_global: Filter by global templates
        :param str creator_id: Filter by creator user ID
        :param PublishedFilter published: Filter by published templates
        :param str paging_token:
        :param int count:
        :param WorkspaceTemplatesSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'text_contains',
            'complexity',
            'category',
            'labels',
            'cloud_id',
            'is_global',
            'creator_id',
            'published',
            'paging_token',
            'count',
            'sort_field',
            'sort_order'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_templates_api_v2_workspace_templates_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_templates_api_v2_workspace_templates_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_templates_api_v2_workspace_templates_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'text_contains' in local_var_params and local_var_params['text_contains'] is not None:  # noqa: E501
            query_params.append(('text_contains', local_var_params['text_contains']))  # noqa: E501
        if 'complexity' in local_var_params and local_var_params['complexity'] is not None:  # noqa: E501
            query_params.append(('complexity', local_var_params['complexity']))  # noqa: E501
        if 'category' in local_var_params and local_var_params['category'] is not None:  # noqa: E501
            query_params.append(('category', local_var_params['category']))  # noqa: E501
        if 'labels' in local_var_params and local_var_params['labels'] is not None:  # noqa: E501
            query_params.append(('labels', local_var_params['labels']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'is_global' in local_var_params and local_var_params['is_global'] is not None:  # noqa: E501
            query_params.append(('is_global', local_var_params['is_global']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'published' in local_var_params and local_var_params['published'] is not None:  # noqa: E501
            query_params.append(('published', local_var_params['published']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_user_group_memberships_api_v2_user_groups_memberships_list_get(self, **kwargs):  # noqa: E501
        """List User Group Memberships  # noqa: E501

        List all user groups with their members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_group_memberships_api_v2_user_groups_memberships_list_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListusergroupmembershipsresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_user_group_memberships_api_v2_user_groups_memberships_list_get_with_http_info(**kwargs)  # noqa: E501

    def list_user_group_memberships_api_v2_user_groups_memberships_list_get_with_http_info(self, **kwargs):  # noqa: E501
        """List User Group Memberships  # noqa: E501

        List all user groups with their members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_group_memberships_api_v2_user_groups_memberships_list_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListusergroupmembershipsresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_group_memberships_api_v2_user_groups_memberships_list_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user_groups/memberships/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListusergroupmembershipsresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_user_groups_api_v2_user_groups_get(self, **kwargs):  # noqa: E501
        """List User Groups  # noqa: E501

        List all user groups in the user's organization.  This endpoint returns all user groups that belong to the authenticated user's organization. User groups are used for managing permissions on resources.  Query Parameters: - **count**: Number of results per page (required) - **paging_token**: Token for pagination (optional)  Returns: - List of user groups with id and name - Pagination metadata  Permission requirements: - Caller must be an organization admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_groups_api_v2_user_groups_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UsergroupListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_user_groups_api_v2_user_groups_get_with_http_info(**kwargs)  # noqa: E501

    def list_user_groups_api_v2_user_groups_get_with_http_info(self, **kwargs):  # noqa: E501
        """List User Groups  # noqa: E501

        List all user groups in the user's organization.  This endpoint returns all user groups that belong to the authenticated user's organization. User groups are used for managing permissions on resources.  Query Parameters: - **count**: Number of results per page (required) - **paging_token**: Token for pagination (optional)  Returns: - List of user groups with id and name - Pagination metadata  Permission requirements: - Caller must be an organization admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_groups_api_v2_user_groups_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UsergroupListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_groups_api_v2_user_groups_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_user_groups_api_v2_user_groups_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_user_groups_api_v2_user_groups_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user_groups/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsergroupListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_values_api_v2_tags_values_get(self, key, **kwargs):  # noqa: E501
        """List Values  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_values_api_v2_tags_values_get(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str key: (required)
        :param ResourceTagResourceType resource_type:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TagvalueListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_values_api_v2_tags_values_get_with_http_info(key, **kwargs)  # noqa: E501

    def list_values_api_v2_tags_values_get_with_http_info(self, key, **kwargs):  # noqa: E501
        """List Values  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_values_api_v2_tags_values_get_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str key: (required)
        :param ResourceTagResourceType resource_type:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TagvalueListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'key',
            'resource_type',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_values_api_v2_tags_values_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in local_var_params or  # noqa: E501
                                                        local_var_params['key'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `key` when calling `list_values_api_v2_tags_values_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_values_api_v2_tags_values_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_values_api_v2_tags_values_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'key' in local_var_params and local_var_params['key'] is not None:  # noqa: E501
            query_params.append(('key', local_var_params['key']))  # noqa: E501
        if 'resource_type' in local_var_params and local_var_params['resource_type'] is not None:  # noqa: E501
            query_params.append(('resource_type', local_var_params['resource_type']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tags/values', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagvalueListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get(self, connection_id, catalog_id, schema_id, **kwargs):  # noqa: E501
        """List Volumes In Schema  # noqa: E501

        Lists all volumes within a specific schema  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get(connection_id, catalog_id, schema_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param str schema_id: ID of the schema (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatacatalogvolumeListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get_with_http_info(connection_id, catalog_id, schema_id, **kwargs)  # noqa: E501

    def list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get_with_http_info(self, connection_id, catalog_id, schema_id, **kwargs):  # noqa: E501
        """List Volumes In Schema  # noqa: E501

        Lists all volumes within a specific schema  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get_with_http_info(connection_id, catalog_id, schema_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connection_id: ID of the provider connection (required)
        :param str catalog_id: ID of the catalog (required)
        :param str schema_id: ID of the schema (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatacatalogvolumeListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'catalog_id',
            'schema_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and ('connection_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connection_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get`")  # noqa: E501
        # verify the required parameter 'catalog_id' is set
        if self.api_client.client_side_validation and ('catalog_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['catalog_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `catalog_id` when calling `list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get`")  # noqa: E501
        # verify the required parameter 'schema_id' is set
        if self.api_client.client_side_validation and ('schema_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schema_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schema_id` when calling `list_volumes_in_schema_api_v2_data_catalogs_connections_connection_id_catalogs_catalog_id_schemas_schema_id_volumes_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connection_id'] = local_var_params['connection_id']  # noqa: E501
        if 'catalog_id' in local_var_params:
            path_params['catalog_id'] = local_var_params['catalog_id']  # noqa: E501
        if 'schema_id' in local_var_params:
            path_params['schema_id'] = local_var_params['schema_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/data_catalogs/connections/{connection_id}/catalogs/{catalog_id}/schemas/{schema_id}/volumes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatacatalogvolumeListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_workspace_templates_api_v2_experimental_workspaces_templates_get(self, **kwargs):  # noqa: E501
        """List Workspace Templates  # noqa: E501

        Lists all workspace templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workspace_templates_api_v2_experimental_workspaces_templates_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] oa_group_names: Search for workspaces that belong to the provided group name
        :param bool for_private_endpoints_homepage: Filters the list to be ones expected for private endpoints home page
        :param bool for_fine_tuning: Filters the list to be ones expected for fine tuning tutorial section
        :param bool for_ai_apps_section: Filters the list to show the ones expected for ai apps section
        :param bool for_gallery: Filters the list to show the ones expected for gallery section
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GlobalworkspacetemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_workspace_templates_api_v2_experimental_workspaces_templates_get_with_http_info(**kwargs)  # noqa: E501

    def list_workspace_templates_api_v2_experimental_workspaces_templates_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Workspace Templates  # noqa: E501

        Lists all workspace templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workspace_templates_api_v2_experimental_workspaces_templates_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] oa_group_names: Search for workspaces that belong to the provided group name
        :param bool for_private_endpoints_homepage: Filters the list to be ones expected for private endpoints home page
        :param bool for_fine_tuning: Filters the list to be ones expected for fine tuning tutorial section
        :param bool for_ai_apps_section: Filters the list to show the ones expected for ai apps section
        :param bool for_gallery: Filters the list to show the ones expected for gallery section
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GlobalworkspacetemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'oa_group_names',
            'for_private_endpoints_homepage',
            'for_fine_tuning',
            'for_ai_apps_section',
            'for_gallery'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_workspace_templates_api_v2_experimental_workspaces_templates_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'oa_group_names' in local_var_params and local_var_params['oa_group_names'] is not None:  # noqa: E501
            query_params.append(('oa_group_names', local_var_params['oa_group_names']))  # noqa: E501
            collection_formats['oa_group_names'] = 'multi'  # noqa: E501
        if 'for_private_endpoints_homepage' in local_var_params and local_var_params['for_private_endpoints_homepage'] is not None:  # noqa: E501
            query_params.append(('for_private_endpoints_homepage', local_var_params['for_private_endpoints_homepage']))  # noqa: E501
        if 'for_fine_tuning' in local_var_params and local_var_params['for_fine_tuning'] is not None:  # noqa: E501
            query_params.append(('for_fine_tuning', local_var_params['for_fine_tuning']))  # noqa: E501
        if 'for_ai_apps_section' in local_var_params and local_var_params['for_ai_apps_section'] is not None:  # noqa: E501
            query_params.append(('for_ai_apps_section', local_var_params['for_ai_apps_section']))  # noqa: E501
        if 'for_gallery' in local_var_params and local_var_params['for_gallery'] is not None:  # noqa: E501
            query_params.append(('for_gallery', local_var_params['for_gallery']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GlobalworkspacetemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_workspaces_api_v2_experimental_workspaces_get(self, **kwargs):  # noqa: E501
        """List Workspaces  # noqa: E501

        Lists all Workspace the user has access to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workspaces_api_v2_experimental_workspaces_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Search for workspace with a name that equals the provided value
        :param str name_contains: Search for workspace with a name that contains the provided value
        :param str creator_id: List workspaces created by a given user
        :param str project_id: Search for workspace with project_id
        :param str cloud_id: Search for workspace with cloud_id
        :param list[SessionState] state_filter: A list of session states to filter by
        :param list[str] tag_filter: Repeatable filter of tags in the form key:value. Can be specified multiple times. Values with the same key are ORed; keys are ANDed.
        :param ExperimentalWorkspacesSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_workspaces_api_v2_experimental_workspaces_get_with_http_info(**kwargs)  # noqa: E501

    def list_workspaces_api_v2_experimental_workspaces_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Workspaces  # noqa: E501

        Lists all Workspace the user has access to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workspaces_api_v2_experimental_workspaces_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Search for workspace with a name that equals the provided value
        :param str name_contains: Search for workspace with a name that contains the provided value
        :param str creator_id: List workspaces created by a given user
        :param str project_id: Search for workspace with project_id
        :param str cloud_id: Search for workspace with cloud_id
        :param list[SessionState] state_filter: A list of session states to filter by
        :param list[str] tag_filter: Repeatable filter of tags in the form key:value. Can be specified multiple times. Values with the same key are ORed; keys are ANDed.
        :param ExperimentalWorkspacesSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name_contains',
            'creator_id',
            'project_id',
            'cloud_id',
            'state_filter',
            'tag_filter',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_workspaces_api_v2_experimental_workspaces_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_workspaces_api_v2_experimental_workspaces_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_workspaces_api_v2_experimental_workspaces_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'tag_filter' in local_var_params and local_var_params['tag_filter'] is not None:  # noqa: E501
            query_params.append(('tag_filter', local_var_params['tag_filter']))  # noqa: E501
            collection_formats['tag_filter'] = 'multi'  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def login_user_api_v2_users_login_post(self, login_user_params, **kwargs):  # noqa: E501
        """Login User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_user_api_v2_users_login_post(login_user_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LoginUserParams login_user_params: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.login_user_api_v2_users_login_post_with_http_info(login_user_params, **kwargs)  # noqa: E501

    def login_user_api_v2_users_login_post_with_http_info(self, login_user_params, **kwargs):  # noqa: E501
        """Login User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_user_api_v2_users_login_post_with_http_info(login_user_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LoginUserParams login_user_params: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'login_user_params'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login_user_api_v2_users_login_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'login_user_params' is set
        if self.api_client.client_side_validation and ('login_user_params' not in local_var_params or  # noqa: E501
                                                        local_var_params['login_user_params'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `login_user_params` when calling `login_user_api_v2_users_login_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'login_user_params' in local_var_params:
            body_params = local_var_params['login_user_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logout_user_api_v2_users_logout_post(self, **kwargs):  # noqa: E501
        """Logout User  # noqa: E501

        Log a user out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_user_api_v2_users_logout_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.logout_user_api_v2_users_logout_post_with_http_info(**kwargs)  # noqa: E501

    def logout_user_api_v2_users_logout_post_with_http_info(self, **kwargs):  # noqa: E501
        """Logout User  # noqa: E501

        Log a user out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_user_api_v2_users_logout_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout_user_api_v2_users_logout_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/logout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def migrate_scim_permissions_api_v2_scim_migrate_permissions_post(self, **kwargs):  # noqa: E501
        """Migrate Scim Permissions  # noqa: E501

        Migrate organization permissions to SCIM-based user group permissions.  This endpoint removes individual user permissions after SCIM is enabled, so that users only have permissions through their user groups.  **IMPORTANT**: This is a destructive operation that cannot be undone. Only call this after SCIM is fully configured: 1. User groups are created and synced from your IdP 2. User group permissions are assigned to resources 3. Users are added to their respective user groups  The migration process for each user: 1. Remove all direct cloud access grants. 2. Remove all direct project access grants. 3. Remove all explicit \"read-only override\" grants. 4. Demote org owner to org collaborator (keep collaborator permission; do not delete it).  **Note**: Users will retain their organization collaborator permission as this is a minimum requirement for organization membership.  By default, `dry_run=true` (safe mode). Pass `dry_run=false` to actually apply changes.  Permission requirements: - Caller must be an organization admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.migrate_scim_permissions_api_v2_scim_migrate_permissions_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param bool dry_run:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScimmigrationresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.migrate_scim_permissions_api_v2_scim_migrate_permissions_post_with_http_info(**kwargs)  # noqa: E501

    def migrate_scim_permissions_api_v2_scim_migrate_permissions_post_with_http_info(self, **kwargs):  # noqa: E501
        """Migrate Scim Permissions  # noqa: E501

        Migrate organization permissions to SCIM-based user group permissions.  This endpoint removes individual user permissions after SCIM is enabled, so that users only have permissions through their user groups.  **IMPORTANT**: This is a destructive operation that cannot be undone. Only call this after SCIM is fully configured: 1. User groups are created and synced from your IdP 2. User group permissions are assigned to resources 3. Users are added to their respective user groups  The migration process for each user: 1. Remove all direct cloud access grants. 2. Remove all direct project access grants. 3. Remove all explicit \"read-only override\" grants. 4. Demote org owner to org collaborator (keep collaborator permission; do not delete it).  **Note**: Users will retain their organization collaborator permission as this is a minimum requirement for organization membership.  By default, `dry_run=true` (safe mode). Pass `dry_run=false` to actually apply changes.  Permission requirements: - Caller must be an organization admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.migrate_scim_permissions_api_v2_scim_migrate_permissions_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param bool dry_run:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScimmigrationresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'dry_run'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method migrate_scim_permissions_api_v2_scim_migrate_permissions_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dry_run' in local_var_params and local_var_params['dry_run'] is not None:  # noqa: E501
            query_params.append(('dry_run', local_var_params['dry_run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/scim/migrate-permissions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScimmigrationresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def oauth_callback_api_v2_integrations_oauth_callback_get(self, code, state, **kwargs):  # noqa: E501
        """Oauth Callback  # noqa: E501

        Handle OAuth callback from third party integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.oauth_callback_api_v2_integrations_oauth_callback_get(code, state, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str code: Authorization code from third party integration (required)
        :param str state: State parameter for security (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.oauth_callback_api_v2_integrations_oauth_callback_get_with_http_info(code, state, **kwargs)  # noqa: E501

    def oauth_callback_api_v2_integrations_oauth_callback_get_with_http_info(self, code, state, **kwargs):  # noqa: E501
        """Oauth Callback  # noqa: E501

        Handle OAuth callback from third party integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.oauth_callback_api_v2_integrations_oauth_callback_get_with_http_info(code, state, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str code: Authorization code from third party integration (required)
        :param str state: State parameter for security (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'code',
            'state'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method oauth_callback_api_v2_integrations_oauth_callback_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'code' is set
        if self.api_client.client_side_validation and ('code' not in local_var_params or  # noqa: E501
                                                        local_var_params['code'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `code` when calling `oauth_callback_api_v2_integrations_oauth_callback_get`")  # noqa: E501
        # verify the required parameter 'state' is set
        if self.api_client.client_side_validation and ('state' not in local_var_params or  # noqa: E501
                                                        local_var_params['state'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `state` when calling `oauth_callback_api_v2_integrations_oauth_callback_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'code' in local_var_params and local_var_params['code'] is not None:  # noqa: E501
            query_params.append(('code', local_var_params['code']))  # noqa: E501
        if 'state' in local_var_params and local_var_params['state'] is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/oauth/callback', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_workspace_api_v2_experimental_workspaces_workspace_id_patch(self, workspace_id, json_patch_operation, **kwargs):  # noqa: E501
        """Patch Workspace  # noqa: E501

        Updates a workspace.  TODO: We may need to update fields of the underlying cluster as well in case the fields are duplicated between workspaces and clusters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_workspace_api_v2_experimental_workspaces_workspace_id_patch(workspace_id, json_patch_operation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: (required)
        :param list[JsonPatchOperation] json_patch_operation: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_workspace_api_v2_experimental_workspaces_workspace_id_patch_with_http_info(workspace_id, json_patch_operation, **kwargs)  # noqa: E501

    def patch_workspace_api_v2_experimental_workspaces_workspace_id_patch_with_http_info(self, workspace_id, json_patch_operation, **kwargs):  # noqa: E501
        """Patch Workspace  # noqa: E501

        Updates a workspace.  TODO: We may need to update fields of the underlying cluster as well in case the fields are duplicated between workspaces and clusters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_workspace_api_v2_experimental_workspaces_workspace_id_patch_with_http_info(workspace_id, json_patch_operation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: (required)
        :param list[JsonPatchOperation] json_patch_operation: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'json_patch_operation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_workspace_api_v2_experimental_workspaces_workspace_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `patch_workspace_api_v2_experimental_workspaces_workspace_id_patch`")  # noqa: E501
        # verify the required parameter 'json_patch_operation' is set
        if self.api_client.client_side_validation and ('json_patch_operation' not in local_var_params or  # noqa: E501
                                                        local_var_params['json_patch_operation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `json_patch_operation` when calling `patch_workspace_api_v2_experimental_workspaces_workspace_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'json_patch_operation' in local_var_params:
            body_params = local_var_params['json_patch_operation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post(self, cron_job_id, pause_schedule, **kwargs):  # noqa: E501
        """Pause Cron Job  # noqa: E501

        Pause a Cron Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post(cron_job_id, pause_schedule, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param PauseSchedule pause_schedule: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedscheduleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post_with_http_info(cron_job_id, pause_schedule, **kwargs)  # noqa: E501

    def pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post_with_http_info(self, cron_job_id, pause_schedule, **kwargs):  # noqa: E501
        """Pause Cron Job  # noqa: E501

        Pause a Cron Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post_with_http_info(cron_job_id, pause_schedule, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param PauseSchedule pause_schedule: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedscheduleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cron_job_id',
            'pause_schedule'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cron_job_id' is set
        if self.api_client.client_side_validation and ('cron_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cron_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cron_job_id` when calling `pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post`")  # noqa: E501
        # verify the required parameter 'pause_schedule' is set
        if self.api_client.client_side_validation and ('pause_schedule' not in local_var_params or  # noqa: E501
                                                        local_var_params['pause_schedule'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `pause_schedule` when calling `pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cron_job_id' in local_var_params:
            path_params['cron_job_id'] = local_var_params['cron_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pause_schedule' in local_var_params:
            body_params = local_var_params['pause_schedule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/{cron_job_id}/pause', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedscheduleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def produce_analytics_event_api_v2_analytics_post(self, create_analytics_event, **kwargs):  # noqa: E501
        """Produce Analytics Event  # noqa: E501

        Logs CLI events for analysis.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.produce_analytics_event_api_v2_analytics_post(create_analytics_event, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAnalyticsEvent create_analytics_event: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.produce_analytics_event_api_v2_analytics_post_with_http_info(create_analytics_event, **kwargs)  # noqa: E501

    def produce_analytics_event_api_v2_analytics_post_with_http_info(self, create_analytics_event, **kwargs):  # noqa: E501
        """Produce Analytics Event  # noqa: E501

        Logs CLI events for analysis.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.produce_analytics_event_api_v2_analytics_post_with_http_info(create_analytics_event, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAnalyticsEvent create_analytics_event: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_analytics_event'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method produce_analytics_event_api_v2_analytics_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_analytics_event' is set
        if self.api_client.client_side_validation and ('create_analytics_event' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_analytics_event'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_analytics_event` when calling `produce_analytics_event_api_v2_analytics_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_analytics_event' in local_var_params:
            body_params = local_var_params['create_analytics_event']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/analytics/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_api_v2_streams_publish_post(self, stream_publish_request, **kwargs):  # noqa: E501
        """Publish  # noqa: E501

        This endpoint is no longer used (this gets routed to the infra-api instead), but the openapi client/models are.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_api_v2_streams_publish_post(stream_publish_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param StreamPublishRequest stream_publish_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.publish_api_v2_streams_publish_post_with_http_info(stream_publish_request, **kwargs)  # noqa: E501

    def publish_api_v2_streams_publish_post_with_http_info(self, stream_publish_request, **kwargs):  # noqa: E501
        """Publish  # noqa: E501

        This endpoint is no longer used (this gets routed to the infra-api instead), but the openapi client/models are.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_api_v2_streams_publish_post_with_http_info(stream_publish_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param StreamPublishRequest stream_publish_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'stream_publish_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_api_v2_streams_publish_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stream_publish_request' is set
        if self.api_client.client_side_validation and ('stream_publish_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream_publish_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream_publish_request` when calling `publish_api_v2_streams_publish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stream_publish_request' in local_var_params:
            body_params = local_var_params['stream_publish_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/streams/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_version_api_v2_workspace_templates_template_id_versions_version_id_publish_post(self, template_id, version_id, **kwargs):  # noqa: E501
        """Publish Version  # noqa: E501

        Publish a version as the active version for a template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_version_api_v2_workspace_templates_template_id_versions_version_id_publish_post(template_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param str version_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.publish_version_api_v2_workspace_templates_template_id_versions_version_id_publish_post_with_http_info(template_id, version_id, **kwargs)  # noqa: E501

    def publish_version_api_v2_workspace_templates_template_id_versions_version_id_publish_post_with_http_info(self, template_id, version_id, **kwargs):  # noqa: E501
        """Publish Version  # noqa: E501

        Publish a version as the active version for a template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_version_api_v2_workspace_templates_template_id_versions_version_id_publish_post_with_http_info(template_id, version_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param str version_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id',
            'version_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_version_api_v2_workspace_templates_template_id_versions_version_id_publish_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `publish_version_api_v2_workspace_templates_template_id_versions_version_id_publish_post`")  # noqa: E501
        # verify the required parameter 'version_id' is set
        if self.api_client.client_side_validation and ('version_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['version_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `version_id` when calling `publish_version_api_v2_workspace_templates_template_id_versions_version_id_publish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501
        if 'version_id' in local_var_params:
            path_params['version_id'] = local_var_params['version_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/{template_id}/versions/{version_id}/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def push_cloud_overview_dashboard_api_v2_clouds_cloud_id_push_cloud_overview_dashboard_post(self, cloud_id, **kwargs):  # noqa: E501
        """Push Cloud Overview Dashboard  # noqa: E501

        Push the latest version of the cloud-overview dashboard to the cloud grafana instance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.push_cloud_overview_dashboard_api_v2_clouds_cloud_id_push_cloud_overview_dashboard_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.push_cloud_overview_dashboard_api_v2_clouds_cloud_id_push_cloud_overview_dashboard_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def push_cloud_overview_dashboard_api_v2_clouds_cloud_id_push_cloud_overview_dashboard_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Push Cloud Overview Dashboard  # noqa: E501

        Push the latest version of the cloud-overview dashboard to the cloud grafana instance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.push_cloud_overview_dashboard_api_v2_clouds_cloud_id_push_cloud_overview_dashboard_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method push_cloud_overview_dashboard_api_v2_clouds_cloud_id_push_cloud_overview_dashboard_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `push_cloud_overview_dashboard_api_v2_clouds_cloud_id_push_cloud_overview_dashboard_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/push-cloud-overview-dashboard', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put(self, job_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Job Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put(job_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put_with_http_info(job_id, wand_b_run_details, **kwargs)  # noqa: E501

    def put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put_with_http_info(self, job_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Job Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put_with_http_info(job_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id',
            'wand_b_run_details'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put`")  # noqa: E501
        # verify the required parameter 'wand_b_run_details' is set
        if self.api_client.client_side_validation and ('wand_b_run_details' not in local_var_params or  # noqa: E501
                                                        local_var_params['wand_b_run_details'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wand_b_run_details` when calling `put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wand_b_run_details' in local_var_params:
            body_params = local_var_params['wand_b_run_details']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/job_wandb_run_details/{job_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put(self, production_job_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Production Job Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put(production_job_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put_with_http_info(production_job_id, wand_b_run_details, **kwargs)  # noqa: E501

    def put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put_with_http_info(self, production_job_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Production Job Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put_with_http_info(production_job_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id',
            'wand_b_run_details'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put`")  # noqa: E501
        # verify the required parameter 'wand_b_run_details' is set
        if self.api_client.client_side_validation and ('wand_b_run_details' not in local_var_params or  # noqa: E501
                                                        local_var_params['wand_b_run_details'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wand_b_run_details` when calling `put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wand_b_run_details' in local_var_params:
            body_params = local_var_params['wand_b_run_details']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/production_job_wandb_run_details/{production_job_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put(self, session_id, **kwargs):  # noqa: E501
        """Put Session Cluster Config With Session Idle Timeout  # noqa: E501

        Updates the cluster config and session idle timeout of a running session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str build_id:
        :param str compute_template_id:
        :param int idle_timeout:
        :param bool allow_public_internet_traffic:
        :param WriteClusterConfig write_cluster_config:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put_with_http_info(session_id, **kwargs)  # noqa: E501

    def put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Put Session Cluster Config With Session Idle Timeout  # noqa: E501

        Updates the cluster config and session idle timeout of a running session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str build_id:
        :param str compute_template_id:
        :param int idle_timeout:
        :param bool allow_public_internet_traffic:
        :param WriteClusterConfig write_cluster_config:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'build_id',
            'compute_template_id',
            'idle_timeout',
            'allow_public_internet_traffic',
            'write_cluster_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'build_id' in local_var_params and local_var_params['build_id'] is not None:  # noqa: E501
            query_params.append(('build_id', local_var_params['build_id']))  # noqa: E501
        if 'compute_template_id' in local_var_params and local_var_params['compute_template_id'] is not None:  # noqa: E501
            query_params.append(('compute_template_id', local_var_params['compute_template_id']))  # noqa: E501
        if 'idle_timeout' in local_var_params and local_var_params['idle_timeout'] is not None:  # noqa: E501
            query_params.append(('idle_timeout', local_var_params['idle_timeout']))  # noqa: E501
        if 'allow_public_internet_traffic' in local_var_params and local_var_params['allow_public_internet_traffic'] is not None:  # noqa: E501
            query_params.append(('allow_public_internet_traffic', local_var_params['allow_public_internet_traffic']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'write_cluster_config' in local_var_params:
            body_params = local_var_params['write_cluster_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/cluster_config_with_session_idle_timeout', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put(self, workspace_id, workspace_dataplane_proxied_artifacts, **kwargs):  # noqa: E501
        """Put Workspace Proxied Dataplane Artifacts  # noqa: E501

        Update workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put(workspace_id, workspace_dataplane_proxied_artifacts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to update. (required)
        :param WorkspaceDataplaneProxiedArtifacts workspace_dataplane_proxied_artifacts: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put_with_http_info(workspace_id, workspace_dataplane_proxied_artifacts, **kwargs)  # noqa: E501

    def put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put_with_http_info(self, workspace_id, workspace_dataplane_proxied_artifacts, **kwargs):  # noqa: E501
        """Put Workspace Proxied Dataplane Artifacts  # noqa: E501

        Update workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put_with_http_info(workspace_id, workspace_dataplane_proxied_artifacts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to update. (required)
        :param WorkspaceDataplaneProxiedArtifacts workspace_dataplane_proxied_artifacts: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'workspace_dataplane_proxied_artifacts'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put`")  # noqa: E501
        # verify the required parameter 'workspace_dataplane_proxied_artifacts' is set
        if self.api_client.client_side_validation and ('workspace_dataplane_proxied_artifacts' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_dataplane_proxied_artifacts'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_dataplane_proxied_artifacts` when calling `put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_dataplane_proxied_artifacts' in local_var_params:
            body_params = local_var_params['workspace_dataplane_proxied_artifacts']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/proxied_dataplane_artifacts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put(self, workspace_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Workspace Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put(workspace_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put_with_http_info(workspace_id, wand_b_run_details, **kwargs)  # noqa: E501

    def put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put_with_http_info(self, workspace_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Workspace Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put_with_http_info(workspace_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'wand_b_run_details'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put`")  # noqa: E501
        # verify the required parameter 'wand_b_run_details' is set
        if self.api_client.client_side_validation and ('wand_b_run_details' not in local_var_params or  # noqa: E501
                                                        local_var_params['wand_b_run_details'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wand_b_run_details` when calling `put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wand_b_run_details' in local_var_params:
            body_params = local_var_params['wand_b_run_details']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/workspace_wandb_run_details/{workspace_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_aggregated_logs_api_v2_logs_query_aggregated_logs_get(self, **kwargs):  # noqa: E501
        """Query Aggregated Logs  # noqa: E501

        Fetching logs for customer aggregated logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_aggregated_logs_api_v2_logs_query_aggregated_logs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: The cluster id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, ray_job_submission_id, ray_job_id, or service_id must be set.
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param int start_time: The start time for the query as a nanosecond Unix epoch. If not set, the query will use the time one hour ago.
        :param int end_time: The end time for the query as a nanosecond Unix epoch. If not set, the query will use the time now.
        :param str positive_search_filter: Positive search terms to filter in the logs. Defaults to no filter. This can be a regex and the search is case insensitive.
        :param str negative_search_filter: Negative search terms to filter out the logs. Defaults to no filter. This can be a regex and the search is case insensitive.
        :param str search_query: Advanced search query with syntax supporting NOT, AND, OR operators. Cannot be used together with positive_search_filter or negative_search_filter.
        :param str source: The source file (worker, raylet, dashboard, controller, proxy, replica, AUTOSCALER..) to filter the logs. Default to no filter.
        :param str filter_tags: The tags to filter the logs. Default to no filter. The format of this field is expected to be in json. The filer will apply to match each key of the object and do exact match on the value.
        :param bool reverse_sort: Whether the result should be sorted by descending timestamp. Also determines the query direction. When false, it will start to query from the start_time and return results until it reaches the page_size or the end_time. When true, it will start to query from the end_time and return results until it reaches the page_size or the start_time. Default to false.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogitembatchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_aggregated_logs_api_v2_logs_query_aggregated_logs_get_with_http_info(**kwargs)  # noqa: E501

    def query_aggregated_logs_api_v2_logs_query_aggregated_logs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Query Aggregated Logs  # noqa: E501

        Fetching logs for customer aggregated logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_aggregated_logs_api_v2_logs_query_aggregated_logs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: The cluster id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, ray_job_submission_id, ray_job_id, or service_id must be set.
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param int start_time: The start time for the query as a nanosecond Unix epoch. If not set, the query will use the time one hour ago.
        :param int end_time: The end time for the query as a nanosecond Unix epoch. If not set, the query will use the time now.
        :param str positive_search_filter: Positive search terms to filter in the logs. Defaults to no filter. This can be a regex and the search is case insensitive.
        :param str negative_search_filter: Negative search terms to filter out the logs. Defaults to no filter. This can be a regex and the search is case insensitive.
        :param str search_query: Advanced search query with syntax supporting NOT, AND, OR operators. Cannot be used together with positive_search_filter or negative_search_filter.
        :param str source: The source file (worker, raylet, dashboard, controller, proxy, replica, AUTOSCALER..) to filter the logs. Default to no filter.
        :param str filter_tags: The tags to filter the logs. Default to no filter. The format of this field is expected to be in json. The filer will apply to match each key of the object and do exact match on the value.
        :param bool reverse_sort: Whether the result should be sorted by descending timestamp. Also determines the query direction. When false, it will start to query from the start_time and return results until it reaches the page_size or the end_time. When true, it will start to query from the end_time and return results until it reaches the page_size or the start_time. Default to false.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogitembatchResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'workspace_id',
            'ha_job_id',
            'service_id',
            'page_size',
            'start_time',
            'end_time',
            'positive_search_filter',
            'negative_search_filter',
            'search_query',
            'source',
            'filter_tags',
            'reverse_sort'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_aggregated_logs_api_v2_logs_query_aggregated_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'page_size' in local_var_params and local_var_params['page_size'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `page_size` when calling `query_aggregated_logs_api_v2_logs_query_aggregated_logs_get`, must be a value less than or equal to `1000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'service_id' in local_var_params and local_var_params['service_id'] is not None:  # noqa: E501
            query_params.append(('service_id', local_var_params['service_id']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'positive_search_filter' in local_var_params and local_var_params['positive_search_filter'] is not None:  # noqa: E501
            query_params.append(('positive_search_filter', local_var_params['positive_search_filter']))  # noqa: E501
        if 'negative_search_filter' in local_var_params and local_var_params['negative_search_filter'] is not None:  # noqa: E501
            query_params.append(('negative_search_filter', local_var_params['negative_search_filter']))  # noqa: E501
        if 'search_query' in local_var_params and local_var_params['search_query'] is not None:  # noqa: E501
            query_params.append(('search_query', local_var_params['search_query']))  # noqa: E501
        if 'source' in local_var_params and local_var_params['source'] is not None:  # noqa: E501
            query_params.append(('source', local_var_params['source']))  # noqa: E501
        if 'filter_tags' in local_var_params and local_var_params['filter_tags'] is not None:  # noqa: E501
            query_params.append(('filter_tags', local_var_params['filter_tags']))  # noqa: E501
        if 'reverse_sort' in local_var_params and local_var_params['reverse_sort'] is not None:  # noqa: E501
            query_params.append(('reverse_sort', local_var_params['reverse_sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/query_aggregated_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogitembatchResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_api_v2_metrics_query_get(self, promql_query, **kwargs):  # noqa: E501
        """Query  # noqa: E501

        Query metrics using PromQL query for various resource types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_api_v2_metrics_query_get(promql_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str promql_query: PromQL query string to execute. This should be a valid Prometheus Query Language expression. (required)
        :param str cluster_id: The cluster id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param float time: Unix timestamp for the query time. If not provided, uses current time.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MetricsqueryresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_api_v2_metrics_query_get_with_http_info(promql_query, **kwargs)  # noqa: E501

    def query_api_v2_metrics_query_get_with_http_info(self, promql_query, **kwargs):  # noqa: E501
        """Query  # noqa: E501

        Query metrics using PromQL query for various resource types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_api_v2_metrics_query_get_with_http_info(promql_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str promql_query: PromQL query string to execute. This should be a valid Prometheus Query Language expression. (required)
        :param str cluster_id: The cluster id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param float time: Unix timestamp for the query time. If not provided, uses current time.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MetricsqueryresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'promql_query',
            'cluster_id',
            'workspace_id',
            'ha_job_id',
            'service_id',
            'time'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_api_v2_metrics_query_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'promql_query' is set
        if self.api_client.client_side_validation and ('promql_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['promql_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `promql_query` when calling `query_api_v2_metrics_query_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'promql_query' in local_var_params and local_var_params['promql_query'] is not None:  # noqa: E501
            query_params.append(('promql_query', local_var_params['promql_query']))  # noqa: E501
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'service_id' in local_var_params and local_var_params['service_id'] is not None:  # noqa: E501
            query_params.append(('service_id', local_var_params['service_id']))  # noqa: E501
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/metrics/query', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetricsqueryresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_range_api_v2_metrics_query_range_get(self, promql_query, start, end, **kwargs):  # noqa: E501
        """Query Range  # noqa: E501

        Query metrics using PromQL range query for various resource types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_range_api_v2_metrics_query_range_get(promql_query, start, end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str promql_query: PromQL query string to execute. This should be a valid Prometheus Query Language expression. (required)
        :param float start: Start timestamp (Unix timestamp) for the range query. (required)
        :param float end: End timestamp (Unix timestamp) for the range query. (required)
        :param str cluster_id: The cluster id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str step: Query resolution step width in seconds (e.g., '15s', '1m', '5m').
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MetricsqueryresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_range_api_v2_metrics_query_range_get_with_http_info(promql_query, start, end, **kwargs)  # noqa: E501

    def query_range_api_v2_metrics_query_range_get_with_http_info(self, promql_query, start, end, **kwargs):  # noqa: E501
        """Query Range  # noqa: E501

        Query metrics using PromQL range query for various resource types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_range_api_v2_metrics_query_range_get_with_http_info(promql_query, start, end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str promql_query: PromQL query string to execute. This should be a valid Prometheus Query Language expression. (required)
        :param float start: Start timestamp (Unix timestamp) for the range query. (required)
        :param float end: End timestamp (Unix timestamp) for the range query. (required)
        :param str cluster_id: The cluster id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to query metrics. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str step: Query resolution step width in seconds (e.g., '15s', '1m', '5m').
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MetricsqueryresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'promql_query',
            'start',
            'end',
            'cluster_id',
            'workspace_id',
            'ha_job_id',
            'service_id',
            'step'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_range_api_v2_metrics_query_range_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'promql_query' is set
        if self.api_client.client_side_validation and ('promql_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['promql_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `promql_query` when calling `query_range_api_v2_metrics_query_range_get`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `query_range_api_v2_metrics_query_range_get`")  # noqa: E501
        # verify the required parameter 'end' is set
        if self.api_client.client_side_validation and ('end' not in local_var_params or  # noqa: E501
                                                        local_var_params['end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end` when calling `query_range_api_v2_metrics_query_range_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'promql_query' in local_var_params and local_var_params['promql_query'] is not None:  # noqa: E501
            query_params.append(('promql_query', local_var_params['promql_query']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'service_id' in local_var_params and local_var_params['service_id'] is not None:  # noqa: E501
            query_params.append(('service_id', local_var_params['service_id']))  # noqa: E501
        if 'step' in local_var_params and local_var_params['step'] is not None:  # noqa: E501
            query_params.append(('step', local_var_params['step']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/metrics/query_range', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetricsqueryresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def receive_cli_usage_api_v2_cli_usage_post(self, cli_usage_payload, **kwargs):  # noqa: E501
        """Receive Cli Usage  # noqa: E501

        Record CLI usage metrics for observability and analytics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_cli_usage_api_v2_cli_usage_post(cli_usage_payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CLIUsagePayload cli_usage_payload: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.receive_cli_usage_api_v2_cli_usage_post_with_http_info(cli_usage_payload, **kwargs)  # noqa: E501

    def receive_cli_usage_api_v2_cli_usage_post_with_http_info(self, cli_usage_payload, **kwargs):  # noqa: E501
        """Receive Cli Usage  # noqa: E501

        Record CLI usage metrics for observability and analytics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_cli_usage_api_v2_cli_usage_post_with_http_info(cli_usage_payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CLIUsagePayload cli_usage_payload: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cli_usage_payload'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method receive_cli_usage_api_v2_cli_usage_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cli_usage_payload' is set
        if self.api_client.client_side_validation and ('cli_usage_payload' not in local_var_params or  # noqa: E501
                                                        local_var_params['cli_usage_payload'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cli_usage_payload` when calling `receive_cli_usage_api_v2_cli_usage_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cli_usage_payload' in local_var_params:
            body_params = local_var_params['cli_usage_payload']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cli_usage/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def redirect_to_service_api_v2_sessions_cluster_id_services_get(self, cluster_id, redirect_to, **kwargs):  # noqa: E501
        """Redirect To Service  # noqa: E501

        Redirects to a cluster's dataplane services. Requires a user to be logged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redirect_to_service_api_v2_sessions_cluster_id_services_get(cluster_id, redirect_to, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param DataplaneServices redirect_to: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.redirect_to_service_api_v2_sessions_cluster_id_services_get_with_http_info(cluster_id, redirect_to, **kwargs)  # noqa: E501

    def redirect_to_service_api_v2_sessions_cluster_id_services_get_with_http_info(self, cluster_id, redirect_to, **kwargs):  # noqa: E501
        """Redirect To Service  # noqa: E501

        Redirects to a cluster's dataplane services. Requires a user to be logged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redirect_to_service_api_v2_sessions_cluster_id_services_get_with_http_info(cluster_id, redirect_to, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param DataplaneServices redirect_to: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'redirect_to'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redirect_to_service_api_v2_sessions_cluster_id_services_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `redirect_to_service_api_v2_sessions_cluster_id_services_get`")  # noqa: E501
        # verify the required parameter 'redirect_to' is set
        if self.api_client.client_side_validation and ('redirect_to' not in local_var_params or  # noqa: E501
                                                        local_var_params['redirect_to'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `redirect_to` when calling `redirect_to_service_api_v2_sessions_cluster_id_services_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []
        if 'redirect_to' in local_var_params and local_var_params['redirect_to'] is not None:  # noqa: E501
            query_params.append(('redirect_to', local_var_params['redirect_to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{cluster_id}/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def redirect_to_tools_api_v2_services_v2_service_id_tools_get(self, service_id, tool, **kwargs):  # noqa: E501
        """Redirect To Tools  # noqa: E501

        Redirects to a service's tool with proper authentication. Requires a user to be logged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redirect_to_tools_api_v2_services_v2_service_id_tools_get(service_id, tool, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param Tool tool: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.redirect_to_tools_api_v2_services_v2_service_id_tools_get_with_http_info(service_id, tool, **kwargs)  # noqa: E501

    def redirect_to_tools_api_v2_services_v2_service_id_tools_get_with_http_info(self, service_id, tool, **kwargs):  # noqa: E501
        """Redirect To Tools  # noqa: E501

        Redirects to a service's tool with proper authentication. Requires a user to be logged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redirect_to_tools_api_v2_services_v2_service_id_tools_get_with_http_info(service_id, tool, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param Tool tool: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'tool'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redirect_to_tools_api_v2_services_v2_service_id_tools_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `redirect_to_tools_api_v2_services_v2_service_id_tools_get`")  # noqa: E501
        # verify the required parameter 'tool' is set
        if self.api_client.client_side_validation and ('tool' not in local_var_params or  # noqa: E501
                                                        local_var_params['tool'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `tool` when calling `redirect_to_tools_api_v2_services_v2_service_id_tools_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []
        if 'tool' in local_var_params and local_var_params['tool'] is not None:  # noqa: E501
            query_params.append(('tool', local_var_params['tool']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/tools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_api_v2_kubernetes_manager_register_post(self, kubernetes_manager_registration_request, **kwargs):  # noqa: E501
        """Register  # noqa: E501

        Register a kubernetes manager to receive the token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_api_v2_kubernetes_manager_register_post(kubernetes_manager_registration_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param KubernetesManagerRegistrationRequest kubernetes_manager_registration_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: KubernetesmanagerregistrationresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_api_v2_kubernetes_manager_register_post_with_http_info(kubernetes_manager_registration_request, **kwargs)  # noqa: E501

    def register_api_v2_kubernetes_manager_register_post_with_http_info(self, kubernetes_manager_registration_request, **kwargs):  # noqa: E501
        """Register  # noqa: E501

        Register a kubernetes manager to receive the token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_api_v2_kubernetes_manager_register_post_with_http_info(kubernetes_manager_registration_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param KubernetesManagerRegistrationRequest kubernetes_manager_registration_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(KubernetesmanagerregistrationresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'kubernetes_manager_registration_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_api_v2_kubernetes_manager_register_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'kubernetes_manager_registration_request' is set
        if self.api_client.client_side_validation and ('kubernetes_manager_registration_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['kubernetes_manager_registration_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `kubernetes_manager_registration_request` when calling `register_api_v2_kubernetes_manager_register_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'kubernetes_manager_registration_request' in local_var_params:
            body_params = local_var_params['kubernetes_manager_registration_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/kubernetes_manager/register', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KubernetesmanagerregistrationresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_build_api_v2_anyscaled_register_build_post(self, build_registration, **kwargs):  # noqa: E501
        """Register Build  # noqa: E501

        Register a node to receive a per-build token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_build_api_v2_anyscaled_register_build_post(build_registration, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BuildRegistration build_registration: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaledcredentialresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_build_api_v2_anyscaled_register_build_post_with_http_info(build_registration, **kwargs)  # noqa: E501

    def register_build_api_v2_anyscaled_register_build_post_with_http_info(self, build_registration, **kwargs):  # noqa: E501
        """Register Build  # noqa: E501

        Register a node to receive a per-build token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_build_api_v2_anyscaled_register_build_post_with_http_info(build_registration, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BuildRegistration build_registration: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaledcredentialresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'build_registration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_build_api_v2_anyscaled_register_build_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'build_registration' is set
        if self.api_client.client_side_validation and ('build_registration' not in local_var_params or  # noqa: E501
                                                        local_var_params['build_registration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `build_registration` when calling `register_build_api_v2_anyscaled_register_build_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'build_registration' in local_var_params:
            body_params = local_var_params['build_registration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/anyscaled/register_build', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaledcredentialresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_databricks_connection_api_v2_integrations_connections_databricks_post(self, databricks_register_request, **kwargs):  # noqa: E501
        """Register Databricks Connection  # noqa: E501

        Register Databricks connection configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_databricks_connection_api_v2_integrations_connections_databricks_post(databricks_register_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DatabricksRegisterRequest databricks_register_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DatabricksconnectionresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_databricks_connection_api_v2_integrations_connections_databricks_post_with_http_info(databricks_register_request, **kwargs)  # noqa: E501

    def register_databricks_connection_api_v2_integrations_connections_databricks_post_with_http_info(self, databricks_register_request, **kwargs):  # noqa: E501
        """Register Databricks Connection  # noqa: E501

        Register Databricks connection configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_databricks_connection_api_v2_integrations_connections_databricks_post_with_http_info(databricks_register_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DatabricksRegisterRequest databricks_register_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DatabricksconnectionresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'databricks_register_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_databricks_connection_api_v2_integrations_connections_databricks_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'databricks_register_request' is set
        if self.api_client.client_side_validation and ('databricks_register_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['databricks_register_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `databricks_register_request` when calling `register_databricks_connection_api_v2_integrations_connections_databricks_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'databricks_register_request' in local_var_params:
            body_params = local_var_params['databricks_register_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/connections/databricks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DatabricksconnectionresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_machine_api_v2_anyscaled_register_machine_post(self, create_machine_request, **kwargs):  # noqa: E501
        """Register Machine  # noqa: E501

        Register an Anyscale-managed machine to receive a per-machine token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_machine_api_v2_anyscaled_register_machine_post(create_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachineRequest create_machine_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatemachineresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_machine_api_v2_anyscaled_register_machine_post_with_http_info(create_machine_request, **kwargs)  # noqa: E501

    def register_machine_api_v2_anyscaled_register_machine_post_with_http_info(self, create_machine_request, **kwargs):  # noqa: E501
        """Register Machine  # noqa: E501

        Register an Anyscale-managed machine to receive a per-machine token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_machine_api_v2_anyscaled_register_machine_post_with_http_info(create_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachineRequest create_machine_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatemachineresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_machine_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_machine_api_v2_anyscaled_register_machine_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_machine_request' is set
        if self.api_client.client_side_validation and ('create_machine_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_machine_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_machine_request` when calling `register_machine_api_v2_anyscaled_register_machine_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_machine_request' in local_var_params:
            body_params = local_var_params['create_machine_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/anyscaled/register_machine', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatemachineresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_user_api_v2_users_post(self, create_user, **kwargs):  # noqa: E501
        """Register User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_user_api_v2_users_post(create_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateUser create_user: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_user_api_v2_users_post_with_http_info(create_user, **kwargs)  # noqa: E501

    def register_user_api_v2_users_post_with_http_info(self, create_user, **kwargs):  # noqa: E501
        """Register User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_user_api_v2_users_post_with_http_info(create_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateUser create_user: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_user_api_v2_users_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_user' is set
        if self.api_client.client_side_validation and ('create_user' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_user'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_user` when calling `register_user_api_v2_users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_user' in local_var_params:
            body_params = local_var_params['create_user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_v2_api_v2_anyscaled_register_v2_post(self, node_registration_v2, **kwargs):  # noqa: E501
        """Register V2  # noqa: E501

        Register a node to receive a per-cluster token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_v2_api_v2_anyscaled_register_v2_post(node_registration_v2, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NodeRegistrationV2 node_registration_v2: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaledcredentialresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_v2_api_v2_anyscaled_register_v2_post_with_http_info(node_registration_v2, **kwargs)  # noqa: E501

    def register_v2_api_v2_anyscaled_register_v2_post_with_http_info(self, node_registration_v2, **kwargs):  # noqa: E501
        """Register V2  # noqa: E501

        Register a node to receive a per-cluster token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_v2_api_v2_anyscaled_register_v2_post_with_http_info(node_registration_v2, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NodeRegistrationV2 node_registration_v2: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaledcredentialresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'node_registration_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_v2_api_v2_anyscaled_register_v2_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'node_registration_v2' is set
        if self.api_client.client_side_validation and ('node_registration_v2' not in local_var_params or  # noqa: E501
                                                        local_var_params['node_registration_v2'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_registration_v2` when calling `register_v2_api_v2_anyscaled_register_v2_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_registration_v2' in local_var_params:
            body_params = local_var_params['node_registration_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/anyscaled/register_v2', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaledcredentialresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_cloud_resource_api_v2_clouds_cloud_id_remove_resource_delete(self, cloud_id, cloud_resource_name, **kwargs):  # noqa: E501
        """Remove Cloud Resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_cloud_resource_api_v2_clouds_cloud_id_remove_resource_delete(cloud_id, cloud_resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_resource_name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_cloud_resource_api_v2_clouds_cloud_id_remove_resource_delete_with_http_info(cloud_id, cloud_resource_name, **kwargs)  # noqa: E501

    def remove_cloud_resource_api_v2_clouds_cloud_id_remove_resource_delete_with_http_info(self, cloud_id, cloud_resource_name, **kwargs):  # noqa: E501
        """Remove Cloud Resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_cloud_resource_api_v2_clouds_cloud_id_remove_resource_delete_with_http_info(cloud_id, cloud_resource_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_resource_name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_resource_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_cloud_resource_api_v2_clouds_cloud_id_remove_resource_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `remove_cloud_resource_api_v2_clouds_cloud_id_remove_resource_delete`")  # noqa: E501
        # verify the required parameter 'cloud_resource_name' is set
        if self.api_client.client_side_validation and ('cloud_resource_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_resource_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_resource_name` when calling `remove_cloud_resource_api_v2_clouds_cloud_id_remove_resource_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'cloud_resource_name' in local_var_params and local_var_params['cloud_resource_name'] is not None:  # noqa: E501
            query_params.append(('cloud_resource_name', local_var_params['cloud_resource_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/remove_resource', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete(self, identity_id, **kwargs):  # noqa: E501
        """Remove Organization Collaborator  # noqa: E501

        Removes a collaborator from the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str identity_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    def remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete_with_http_info(self, identity_id, **kwargs):  # noqa: E501
        """Remove Organization Collaborator  # noqa: E501

        Removes a collaborator from the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str identity_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'identity_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'identity_id' is set
        if self.api_client.client_side_validation and ('identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identity_id` when calling `remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identity_id' in local_var_params:
            path_params['identity_id'] = local_var_params['identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/{identity_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_email_magic_link_api_v2_users_email_magic_link_post(self, email_address, **kwargs):  # noqa: E501
        """Request Email Magic Link  # noqa: E501

        Request a magic link to be sent to an email.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_email_magic_link_api_v2_users_email_magic_link_post(email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email_address: (required)
        :param str redirect_to: A path within Anyscale console to redirect to after the user logs in. This only supports paths and not full urls.
        :param bool no_sso: If true, do not use SSO to log in.
        :param bool force_send: If true, we always send a magic link. Even if there is only one org the user belongs to.
        :param str invite_code:
        :param UtmFields utm_fields:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RequestemailmagiclinkresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.request_email_magic_link_api_v2_users_email_magic_link_post_with_http_info(email_address, **kwargs)  # noqa: E501

    def request_email_magic_link_api_v2_users_email_magic_link_post_with_http_info(self, email_address, **kwargs):  # noqa: E501
        """Request Email Magic Link  # noqa: E501

        Request a magic link to be sent to an email.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_email_magic_link_api_v2_users_email_magic_link_post_with_http_info(email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email_address: (required)
        :param str redirect_to: A path within Anyscale console to redirect to after the user logs in. This only supports paths and not full urls.
        :param bool no_sso: If true, do not use SSO to log in.
        :param bool force_send: If true, we always send a magic link. Even if there is only one org the user belongs to.
        :param str invite_code:
        :param UtmFields utm_fields:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RequestemailmagiclinkresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email_address',
            'redirect_to',
            'no_sso',
            'force_send',
            'invite_code',
            'utm_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_email_magic_link_api_v2_users_email_magic_link_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_address' is set
        if self.api_client.client_side_validation and ('email_address' not in local_var_params or  # noqa: E501
                                                        local_var_params['email_address'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email_address` when calling `request_email_magic_link_api_v2_users_email_magic_link_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email_address' in local_var_params and local_var_params['email_address'] is not None:  # noqa: E501
            query_params.append(('email_address', local_var_params['email_address']))  # noqa: E501
        if 'redirect_to' in local_var_params and local_var_params['redirect_to'] is not None:  # noqa: E501
            query_params.append(('redirect_to', local_var_params['redirect_to']))  # noqa: E501
        if 'no_sso' in local_var_params and local_var_params['no_sso'] is not None:  # noqa: E501
            query_params.append(('no_sso', local_var_params['no_sso']))  # noqa: E501
        if 'force_send' in local_var_params and local_var_params['force_send'] is not None:  # noqa: E501
            query_params.append(('force_send', local_var_params['force_send']))  # noqa: E501
        if 'invite_code' in local_var_params and local_var_params['invite_code'] is not None:  # noqa: E501
            query_params.append(('invite_code', local_var_params['invite_code']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'utm_fields' in local_var_params:
            body_params = local_var_params['utm_fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/email_magic_link', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RequestemailmagiclinkresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_password_reset_api_v2_users_request_password_reset_post(self, request_password_reset_params, **kwargs):  # noqa: E501
        """Request Password Reset  # noqa: E501

        Send the user an email with a reset link for a forgotten password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_password_reset_api_v2_users_request_password_reset_post(request_password_reset_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param RequestPasswordResetParams request_password_reset_params: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.request_password_reset_api_v2_users_request_password_reset_post_with_http_info(request_password_reset_params, **kwargs)  # noqa: E501

    def request_password_reset_api_v2_users_request_password_reset_post_with_http_info(self, request_password_reset_params, **kwargs):  # noqa: E501
        """Request Password Reset  # noqa: E501

        Send the user an email with a reset link for a forgotten password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_password_reset_api_v2_users_request_password_reset_post_with_http_info(request_password_reset_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param RequestPasswordResetParams request_password_reset_params: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_password_reset_params'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_password_reset_api_v2_users_request_password_reset_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_password_reset_params' is set
        if self.api_client.client_side_validation and ('request_password_reset_params' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_password_reset_params'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_password_reset_params` when calling `request_password_reset_api_v2_users_request_password_reset_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_password_reset_params' in local_var_params:
            body_params = local_var_params['request_password_reset_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/request_password_reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_password_api_v2_users_reset_password_post(self, reset_password_params, **kwargs):  # noqa: E501
        """Reset Password  # noqa: E501

        Change the user's password to the new password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_api_v2_users_reset_password_post(reset_password_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResetPasswordParams reset_password_params: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.reset_password_api_v2_users_reset_password_post_with_http_info(reset_password_params, **kwargs)  # noqa: E501

    def reset_password_api_v2_users_reset_password_post_with_http_info(self, reset_password_params, **kwargs):  # noqa: E501
        """Reset Password  # noqa: E501

        Change the user's password to the new password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_api_v2_users_reset_password_post_with_http_info(reset_password_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResetPasswordParams reset_password_params: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'reset_password_params'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password_api_v2_users_reset_password_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'reset_password_params' is set
        if self.api_client.client_side_validation and ('reset_password_params' not in local_var_params or  # noqa: E501
                                                        local_var_params['reset_password_params'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `reset_password_params` when calling `reset_password_api_v2_users_reset_password_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reset_password_params' in local_var_params:
            body_params = local_var_params['reset_password_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/reset_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restart_service_api_v2_services_v2_service_id_restart_post(self, service_id, **kwargs):  # noqa: E501
        """Restart Service  # noqa: E501

        Restart an existing service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_service_api_v2_services_v2_service_id_restart_post(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param str service_version_id: Service Version ID to restart Service
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.restart_service_api_v2_services_v2_service_id_restart_post_with_http_info(service_id, **kwargs)  # noqa: E501

    def restart_service_api_v2_services_v2_service_id_restart_post_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Restart Service  # noqa: E501

        Restart an existing service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_service_api_v2_services_v2_service_id_restart_post_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param str service_version_id: Service Version ID to restart Service
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'service_version_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restart_service_api_v2_services_v2_service_id_restart_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `restart_service_api_v2_services_v2_service_id_restart_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []
        if 'service_version_id' in local_var_params and local_var_params['service_version_id'] is not None:  # noqa: E501
            query_params.append(('service_version_id', local_var_params['service_version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_api_key_api_v2_users_api_keys_api_key_id_delete(self, api_key_id, **kwargs):  # noqa: E501
        """Revoke Api Key  # noqa: E501

        Revoke current user's own API key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_api_key_api_v2_users_api_keys_api_key_id_delete(api_key_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str api_key_id: ID of the API key to revoke (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revoke_api_key_api_v2_users_api_keys_api_key_id_delete_with_http_info(api_key_id, **kwargs)  # noqa: E501

    def revoke_api_key_api_v2_users_api_keys_api_key_id_delete_with_http_info(self, api_key_id, **kwargs):  # noqa: E501
        """Revoke Api Key  # noqa: E501

        Revoke current user's own API key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_api_key_api_v2_users_api_keys_api_key_id_delete_with_http_info(api_key_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str api_key_id: ID of the API key to revoke (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'api_key_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_api_key_api_v2_users_api_keys_api_key_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key_id' is set
        if self.api_client.client_side_validation and ('api_key_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['api_key_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_id` when calling `revoke_api_key_api_v2_users_api_keys_api_key_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key_id' in local_var_params:
            path_params['api_key_id'] = local_var_params['api_key_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/api_keys/{api_key_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_api_key_for_admin_api_v2_users_admin_api_keys_api_key_id_delete(self, api_key_id, **kwargs):  # noqa: E501
        """Revoke Api Key For Admin  # noqa: E501

        Revoke any API key within the organization, only used by the admin.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_api_key_for_admin_api_v2_users_admin_api_keys_api_key_id_delete(api_key_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str api_key_id: ID of the API key to revoke (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revoke_api_key_for_admin_api_v2_users_admin_api_keys_api_key_id_delete_with_http_info(api_key_id, **kwargs)  # noqa: E501

    def revoke_api_key_for_admin_api_v2_users_admin_api_keys_api_key_id_delete_with_http_info(self, api_key_id, **kwargs):  # noqa: E501
        """Revoke Api Key For Admin  # noqa: E501

        Revoke any API key within the organization, only used by the admin.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_api_key_for_admin_api_v2_users_admin_api_keys_api_key_id_delete_with_http_info(api_key_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str api_key_id: ID of the API key to revoke (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'api_key_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_api_key_for_admin_api_v2_users_admin_api_keys_api_key_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key_id' is set
        if self.api_client.client_side_validation and ('api_key_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['api_key_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_id` when calling `revoke_api_key_for_admin_api_v2_users_admin_api_keys_api_key_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key_id' in local_var_params:
            path_params['api_key_id'] = local_var_params['api_key_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/admin/api_keys/{api_key_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_api_keys_api_v2_users_api_keys_revoke_post(self, revoke_api_keys_request, **kwargs):  # noqa: E501
        """Revoke Api Keys  # noqa: E501

        Revoke multiple API keys belonging to the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_api_keys_api_v2_users_api_keys_revoke_post(revoke_api_keys_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param RevokeApiKeysRequest revoke_api_keys_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevokeapikeysresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revoke_api_keys_api_v2_users_api_keys_revoke_post_with_http_info(revoke_api_keys_request, **kwargs)  # noqa: E501

    def revoke_api_keys_api_v2_users_api_keys_revoke_post_with_http_info(self, revoke_api_keys_request, **kwargs):  # noqa: E501
        """Revoke Api Keys  # noqa: E501

        Revoke multiple API keys belonging to the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_api_keys_api_v2_users_api_keys_revoke_post_with_http_info(revoke_api_keys_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param RevokeApiKeysRequest revoke_api_keys_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevokeapikeysresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revoke_api_keys_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_api_keys_api_v2_users_api_keys_revoke_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revoke_api_keys_request' is set
        if self.api_client.client_side_validation and ('revoke_api_keys_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['revoke_api_keys_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revoke_api_keys_request` when calling `revoke_api_keys_api_v2_users_api_keys_revoke_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'revoke_api_keys_request' in local_var_params:
            body_params = local_var_params['revoke_api_keys_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/api_keys/revoke', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevokeapikeysresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_api_keys_for_admin_api_v2_users_admin_api_keys_revoke_post(self, revoke_api_keys_request, **kwargs):  # noqa: E501
        """Revoke Api Keys For Admin  # noqa: E501

        Revoke multiple API keys within the organization, only used by the admin.  Security: - Requires organization admin permissions (checked by router dependencies) - Can revoke any API key within the organization - All validation and organization checks handled by service layer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_api_keys_for_admin_api_v2_users_admin_api_keys_revoke_post(revoke_api_keys_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param RevokeApiKeysRequest revoke_api_keys_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevokeapikeysresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revoke_api_keys_for_admin_api_v2_users_admin_api_keys_revoke_post_with_http_info(revoke_api_keys_request, **kwargs)  # noqa: E501

    def revoke_api_keys_for_admin_api_v2_users_admin_api_keys_revoke_post_with_http_info(self, revoke_api_keys_request, **kwargs):  # noqa: E501
        """Revoke Api Keys For Admin  # noqa: E501

        Revoke multiple API keys within the organization, only used by the admin.  Security: - Requires organization admin permissions (checked by router dependencies) - Can revoke any API key within the organization - All validation and organization checks handled by service layer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_api_keys_for_admin_api_v2_users_admin_api_keys_revoke_post_with_http_info(revoke_api_keys_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param RevokeApiKeysRequest revoke_api_keys_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevokeapikeysresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revoke_api_keys_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_api_keys_for_admin_api_v2_users_admin_api_keys_revoke_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revoke_api_keys_request' is set
        if self.api_client.client_side_validation and ('revoke_api_keys_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['revoke_api_keys_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revoke_api_keys_request` when calling `revoke_api_keys_for_admin_api_v2_users_admin_api_keys_revoke_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'revoke_api_keys_request' in local_var_params:
            body_params = local_var_params['revoke_api_keys_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/admin/api_keys/revoke', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevokeapikeysresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rollback_service_api_v2_services_v2_service_id_rollback_post(self, service_id, **kwargs):  # noqa: E501
        """Rollback Service  # noqa: E501

        Rollback a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rollback_service_api_v2_services_v2_service_id_rollback_post(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param RollbackServiceModel rollback_service_model:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.rollback_service_api_v2_services_v2_service_id_rollback_post_with_http_info(service_id, **kwargs)  # noqa: E501

    def rollback_service_api_v2_services_v2_service_id_rollback_post_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Rollback Service  # noqa: E501

        Rollback a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rollback_service_api_v2_services_v2_service_id_rollback_post_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param RollbackServiceModel rollback_service_model:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'rollback_service_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rollback_service_api_v2_services_v2_service_id_rollback_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `rollback_service_api_v2_services_v2_service_id_rollback_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'rollback_service_model' in local_var_params:
            body_params = local_var_params['rollback_service_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/rollback', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rotate_api_key_api_v2_users_rotate_api_key_get(self, **kwargs):  # noqa: E501
        """Rotate Api Key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_api_v2_users_rotate_api_key_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ServersessiontokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.rotate_api_key_api_v2_users_rotate_api_key_get_with_http_info(**kwargs)  # noqa: E501

    def rotate_api_key_api_v2_users_rotate_api_key_get_with_http_info(self, **kwargs):  # noqa: E501
        """Rotate Api Key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_api_v2_users_rotate_api_key_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ServersessiontokenResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rotate_api_key_api_v2_users_rotate_api_key_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/rotate_api_key', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServersessiontokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post(self, user_id, **kwargs):  # noqa: E501
        """Rotate Api Key For User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post_with_http_info(user_id, **kwargs)  # noqa: E501

    def rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Rotate Api Key For User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['user_id'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/rotate_api_key_for_user/{user_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def saml_acs_api_v2_organizations_organization_id_saml_acs_post(self, organization_id, **kwargs):  # noqa: E501
        """Saml Acs  # noqa: E501

        Authenticate the user for Single Sign On (SSO) using the SAML2 protocol. If successful, log the user in by setting the session cookie. Then redirect to the RelayState parameter if it's under the Anyscale domain, or otherwise just to the Anyscale landing page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.saml_acs_api_v2_organizations_organization_id_saml_acs_post(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.saml_acs_api_v2_organizations_organization_id_saml_acs_post_with_http_info(organization_id, **kwargs)  # noqa: E501

    def saml_acs_api_v2_organizations_organization_id_saml_acs_post_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Saml Acs  # noqa: E501

        Authenticate the user for Single Sign On (SSO) using the SAML2 protocol. If successful, log the user in by setting the session cookie. Then redirect to the RelayState parameter if it's under the Anyscale domain, or otherwise just to the Anyscale landing page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.saml_acs_api_v2_organizations_organization_id_saml_acs_post_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method saml_acs_api_v2_organizations_organization_id_saml_acs_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `saml_acs_api_v2_organizations_organization_id_saml_acs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/{organization_id}/saml_acs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post(self, cloud_id, cloud_collaborators_query, **kwargs):  # noqa: E501
        """Search Cloud Collaborators  # noqa: E501

        Create a search of collaborators for a given cloud  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post(cloud_id, cloud_collaborators_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudCollaboratorsQuery cloud_collaborators_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudcollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post_with_http_info(cloud_id, cloud_collaborators_query, **kwargs)  # noqa: E501

    def search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post_with_http_info(self, cloud_id, cloud_collaborators_query, **kwargs):  # noqa: E501
        """Search Cloud Collaborators  # noqa: E501

        Create a search of collaborators for a given cloud  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post_with_http_info(cloud_id, cloud_collaborators_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudCollaboratorsQuery cloud_collaborators_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudcollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_collaborators_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post`")  # noqa: E501
        # verify the required parameter 'cloud_collaborators_query' is set
        if self.api_client.client_side_validation and ('cloud_collaborators_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_collaborators_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_collaborators_query` when calling `search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_collaborators_query' in local_var_params:
            body_params = local_var_params['cloud_collaborators_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/collaborators/users/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudcollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_cluster_environments_api_v2_application_templates_search_post(self, cluster_environments_query, **kwargs):  # noqa: E501
        """Search Cluster Environments  # noqa: E501

        Lists all Cluster Environments that the logged in user has permissions to access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cluster_environments_api_v2_application_templates_search_post(cluster_environments_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ClusterEnvironmentsQuery cluster_environments_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AppconfigListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_cluster_environments_api_v2_application_templates_search_post_with_http_info(cluster_environments_query, **kwargs)  # noqa: E501

    def search_cluster_environments_api_v2_application_templates_search_post_with_http_info(self, cluster_environments_query, **kwargs):  # noqa: E501
        """Search Cluster Environments  # noqa: E501

        Lists all Cluster Environments that the logged in user has permissions to access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cluster_environments_api_v2_application_templates_search_post_with_http_info(cluster_environments_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ClusterEnvironmentsQuery cluster_environments_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AppconfigListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_environments_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_cluster_environments_api_v2_application_templates_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_environments_query' is set
        if self.api_client.client_side_validation and ('cluster_environments_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_environments_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_environments_query` when calling `search_cluster_environments_api_v2_application_templates_search_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_environments_query' in local_var_params:
            body_params = local_var_params['cluster_environments_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppconfigListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_compute_templates_api_v2_compute_templates_search_post(self, compute_template_query, **kwargs):  # noqa: E501
        """Search Compute Templates  # noqa: E501

        List all compute templates matching the search parameters. If no parameters are specified, lists all templates created by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_compute_templates_api_v2_compute_templates_search_post(compute_template_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComputeTemplateQuery compute_template_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcomputetemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_compute_templates_api_v2_compute_templates_search_post_with_http_info(compute_template_query, **kwargs)  # noqa: E501

    def search_compute_templates_api_v2_compute_templates_search_post_with_http_info(self, compute_template_query, **kwargs):  # noqa: E501
        """Search Compute Templates  # noqa: E501

        List all compute templates matching the search parameters. If no parameters are specified, lists all templates created by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_compute_templates_api_v2_compute_templates_search_post_with_http_info(compute_template_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComputeTemplateQuery compute_template_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcomputetemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'compute_template_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_compute_templates_api_v2_compute_templates_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'compute_template_query' is set
        if self.api_client.client_side_validation and ('compute_template_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['compute_template_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `compute_template_query` when calling `search_compute_templates_api_v2_compute_templates_search_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_compute_templates_api_v2_compute_templates_search_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_compute_templates_api_v2_compute_templates_search_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'compute_template_query' in local_var_params:
            body_params = local_var_params['compute_template_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcomputetemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_machine_pools_api_v2_machine_pools_search_post(self, **kwargs):  # noqa: E501
        """Search Machine Pools  # noqa: E501

        Search machine pools.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_machine_pools_api_v2_machine_pools_search_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param MachinePoolSearchQuery machine_pool_search_query:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MachinepoolsearchresultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_machine_pools_api_v2_machine_pools_search_post_with_http_info(**kwargs)  # noqa: E501

    def search_machine_pools_api_v2_machine_pools_search_post_with_http_info(self, **kwargs):  # noqa: E501
        """Search Machine Pools  # noqa: E501

        Search machine pools.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_machine_pools_api_v2_machine_pools_search_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param MachinePoolSearchQuery machine_pool_search_query:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MachinepoolsearchresultListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'paging_token',
            'count',
            'machine_pool_search_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_machine_pools_api_v2_machine_pools_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_machine_pools_api_v2_machine_pools_search_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_machine_pools_api_v2_machine_pools_search_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'machine_pool_search_query' in local_var_params:
            body_params = local_var_params['machine_pool_search_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MachinepoolsearchresultListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_organization_collaborators_api_v2_organization_collaborators_search_post(self, organization_collaborators_query, **kwargs):  # noqa: E501
        """Search Organization Collaborators  # noqa: E501

        Search organization collaborators by name or email  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_organization_collaborators_api_v2_organization_collaborators_search_post(organization_collaborators_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganizationCollaboratorsQuery organization_collaborators_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationcollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_organization_collaborators_api_v2_organization_collaborators_search_post_with_http_info(organization_collaborators_query, **kwargs)  # noqa: E501

    def search_organization_collaborators_api_v2_organization_collaborators_search_post_with_http_info(self, organization_collaborators_query, **kwargs):  # noqa: E501
        """Search Organization Collaborators  # noqa: E501

        Search organization collaborators by name or email  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_organization_collaborators_api_v2_organization_collaborators_search_post_with_http_info(organization_collaborators_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganizationCollaboratorsQuery organization_collaborators_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationcollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_collaborators_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_organization_collaborators_api_v2_organization_collaborators_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_collaborators_query' is set
        if self.api_client.client_side_validation and ('organization_collaborators_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_collaborators_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_collaborators_query` when calling `search_organization_collaborators_api_v2_organization_collaborators_search_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_organization_collaborators_api_v2_organization_collaborators_search_post`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_organization_collaborators_api_v2_organization_collaborators_search_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_collaborators_query' in local_var_params:
            body_params = local_var_params['organization_collaborators_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationcollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post(self, organization_user_groups_collaborators_query, **kwargs):  # noqa: E501
        """Search Organization User Groups Collaborators  # noqa: E501

        Search organization user groups by name with member details and org role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post(organization_user_groups_collaborators_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganizationUserGroupsCollaboratorsQuery organization_user_groups_collaborators_query: (required)
        :param int member_limit: Maximum number of members to return per group
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationusergroupscollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post_with_http_info(organization_user_groups_collaborators_query, **kwargs)  # noqa: E501

    def search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post_with_http_info(self, organization_user_groups_collaborators_query, **kwargs):  # noqa: E501
        """Search Organization User Groups Collaborators  # noqa: E501

        Search organization user groups by name with member details and org role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post_with_http_info(organization_user_groups_collaborators_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganizationUserGroupsCollaboratorsQuery organization_user_groups_collaborators_query: (required)
        :param int member_limit: Maximum number of members to return per group
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationusergroupscollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_user_groups_collaborators_query',
            'member_limit',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_user_groups_collaborators_query' is set
        if self.api_client.client_side_validation and ('organization_user_groups_collaborators_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_user_groups_collaborators_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_user_groups_collaborators_query` when calling `search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'member_limit' in local_var_params and local_var_params['member_limit'] > 100:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `member_limit` when calling `search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post`, must be a value less than or equal to `100`")  # noqa: E501
        if self.api_client.client_side_validation and 'member_limit' in local_var_params and local_var_params['member_limit'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `member_limit` when calling `search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_organization_user_groups_collaborators_api_v2_organization_user_groups_collaborators_search_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'member_limit' in local_var_params and local_var_params['member_limit'] is not None:  # noqa: E501
            query_params.append(('member_limit', local_var_params['member_limit']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_user_groups_collaborators_query' in local_var_params:
            body_params = local_var_params['organization_user_groups_collaborators_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_user_groups_collaborators/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationusergroupscollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_resource_notifications_api_v2_resource_notifications_search_post(self, list_resource_notifications_query, **kwargs):  # noqa: E501
        """Search Resource Notifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_resource_notifications_api_v2_resource_notifications_search_post(list_resource_notifications_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ListResourceNotificationsQuery list_resource_notifications_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcenotificationListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_resource_notifications_api_v2_resource_notifications_search_post_with_http_info(list_resource_notifications_query, **kwargs)  # noqa: E501

    def search_resource_notifications_api_v2_resource_notifications_search_post_with_http_info(self, list_resource_notifications_query, **kwargs):  # noqa: E501
        """Search Resource Notifications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_resource_notifications_api_v2_resource_notifications_search_post_with_http_info(list_resource_notifications_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ListResourceNotificationsQuery list_resource_notifications_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcenotificationListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'list_resource_notifications_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_resource_notifications_api_v2_resource_notifications_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'list_resource_notifications_query' is set
        if self.api_client.client_side_validation and ('list_resource_notifications_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_resource_notifications_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_resource_notifications_query` when calling `search_resource_notifications_api_v2_resource_notifications_search_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'list_resource_notifications_query' in local_var_params:
            body_params = local_var_params['list_resource_notifications_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_notifications/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcenotificationListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_resource_quotas_api_v2_resource_quotas_search_post(self, list_resource_quotas_query, **kwargs):  # noqa: E501
        """Search Resource Quotas  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_resource_quotas_api_v2_resource_quotas_search_post(list_resource_quotas_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ListResourceQuotasQuery list_resource_quotas_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcequotaListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_resource_quotas_api_v2_resource_quotas_search_post_with_http_info(list_resource_quotas_query, **kwargs)  # noqa: E501

    def search_resource_quotas_api_v2_resource_quotas_search_post_with_http_info(self, list_resource_quotas_query, **kwargs):  # noqa: E501
        """Search Resource Quotas  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_resource_quotas_api_v2_resource_quotas_search_post_with_http_info(list_resource_quotas_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ListResourceQuotasQuery list_resource_quotas_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcequotaListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'list_resource_quotas_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_resource_quotas_api_v2_resource_quotas_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'list_resource_quotas_query' is set
        if self.api_client.client_side_validation and ('list_resource_quotas_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_resource_quotas_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_resource_quotas_query` when calling `search_resource_quotas_api_v2_resource_quotas_search_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'list_resource_quotas_query' in local_var_params:
            body_params = local_var_params['list_resource_quotas_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_quotas/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcequotaListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_support_requests_api_v2_support_requests_search_post(self, support_requests_query, **kwargs):  # noqa: E501
        """Search Support Requests  # noqa: E501

        List all decorated support requests matching the search parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_support_requests_api_v2_support_requests_search_post(support_requests_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param SupportRequestsQuery support_requests_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedsupportrequestListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_support_requests_api_v2_support_requests_search_post_with_http_info(support_requests_query, **kwargs)  # noqa: E501

    def search_support_requests_api_v2_support_requests_search_post_with_http_info(self, support_requests_query, **kwargs):  # noqa: E501
        """Search Support Requests  # noqa: E501

        List all decorated support requests matching the search parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_support_requests_api_v2_support_requests_search_post_with_http_info(support_requests_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param SupportRequestsQuery support_requests_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedsupportrequestListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'support_requests_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_support_requests_api_v2_support_requests_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'support_requests_query' is set
        if self.api_client.client_side_validation and ('support_requests_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['support_requests_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `support_requests_query` when calling `search_support_requests_api_v2_support_requests_search_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'support_requests_query' in local_var_params:
            body_params = local_var_params['support_requests_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/support_requests/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedsupportrequestListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_tags_api_v2_tags_get(self, **kwargs):  # noqa: E501
        """Search Tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_tags_api_v2_tags_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str substring:
        :param TagSearchIn search_in:
        :param ResourceTagResourceType resource_type:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TagkeyvalueListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_tags_api_v2_tags_get_with_http_info(**kwargs)  # noqa: E501

    def search_tags_api_v2_tags_get_with_http_info(self, **kwargs):  # noqa: E501
        """Search Tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_tags_api_v2_tags_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str substring:
        :param TagSearchIn search_in:
        :param ResourceTagResourceType resource_type:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TagkeyvalueListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'substring',
            'search_in',
            'resource_type',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_tags_api_v2_tags_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_tags_api_v2_tags_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_tags_api_v2_tags_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'substring' in local_var_params and local_var_params['substring'] is not None:  # noqa: E501
            query_params.append(('substring', local_var_params['substring']))  # noqa: E501
        if 'search_in' in local_var_params and local_var_params['search_in'] is not None:  # noqa: E501
            query_params.append(('search_in', local_var_params['search_in']))  # noqa: E501
        if 'resource_type' in local_var_params and local_var_params['resource_type'] is not None:  # noqa: E501
            query_params.append(('resource_type', local_var_params['resource_type']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tags/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagkeyvalueListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_resource_quota_status_api_v2_resource_quotas_resource_quota_id_status_patch(self, resource_quota_id, resource_quota_status, **kwargs):  # noqa: E501
        """Set Resource Quota Status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_resource_quota_status_api_v2_resource_quotas_resource_quota_id_status_patch(resource_quota_id, resource_quota_status, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_quota_id: (required)
        :param ResourceQuotaStatus resource_quota_status: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcequotaResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_resource_quota_status_api_v2_resource_quotas_resource_quota_id_status_patch_with_http_info(resource_quota_id, resource_quota_status, **kwargs)  # noqa: E501

    def set_resource_quota_status_api_v2_resource_quotas_resource_quota_id_status_patch_with_http_info(self, resource_quota_id, resource_quota_status, **kwargs):  # noqa: E501
        """Set Resource Quota Status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_resource_quota_status_api_v2_resource_quotas_resource_quota_id_status_patch_with_http_info(resource_quota_id, resource_quota_status, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_quota_id: (required)
        :param ResourceQuotaStatus resource_quota_status: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcequotaResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_quota_id',
            'resource_quota_status'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_resource_quota_status_api_v2_resource_quotas_resource_quota_id_status_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_quota_id' is set
        if self.api_client.client_side_validation and ('resource_quota_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_quota_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_quota_id` when calling `set_resource_quota_status_api_v2_resource_quotas_resource_quota_id_status_patch`")  # noqa: E501
        # verify the required parameter 'resource_quota_status' is set
        if self.api_client.client_side_validation and ('resource_quota_status' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_quota_status'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_quota_status` when calling `set_resource_quota_status_api_v2_resource_quotas_resource_quota_id_status_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_quota_id' in local_var_params:
            path_params['resource_quota_id'] = local_var_params['resource_quota_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resource_quota_status' in local_var_params:
            body_params = local_var_params['resource_quota_status']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_quotas/{resource_quota_id}/status', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcequotaResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_roles_api_v2_organization_collaborators_user_id_roles_put(self, user_id, set_organization_roles, **kwargs):  # noqa: E501
        """Set Roles  # noqa: E501

        Set a user's RBAC roles for the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_roles_api_v2_organization_collaborators_user_id_roles_put(user_id, set_organization_roles, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: (required)
        :param SetOrganizationRoles set_organization_roles: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_roles_api_v2_organization_collaborators_user_id_roles_put_with_http_info(user_id, set_organization_roles, **kwargs)  # noqa: E501

    def set_roles_api_v2_organization_collaborators_user_id_roles_put_with_http_info(self, user_id, set_organization_roles, **kwargs):  # noqa: E501
        """Set Roles  # noqa: E501

        Set a user's RBAC roles for the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_roles_api_v2_organization_collaborators_user_id_roles_put_with_http_info(user_id, set_organization_roles, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: (required)
        :param SetOrganizationRoles set_organization_roles: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'set_organization_roles'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_roles_api_v2_organization_collaborators_user_id_roles_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `set_roles_api_v2_organization_collaborators_user_id_roles_put`")  # noqa: E501
        # verify the required parameter 'set_organization_roles' is set
        if self.api_client.client_side_validation and ('set_organization_roles' not in local_var_params or  # noqa: E501
                                                        local_var_params['set_organization_roles'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `set_organization_roles` when calling `set_roles_api_v2_organization_collaborators_user_id_roles_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['user_id'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_organization_roles' in local_var_params:
            body_params = local_var_params['set_organization_roles']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/{user_id}/roles', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_one_time_password_source_api_v2_users_show_otp_source_post(self, otp, **kwargs):  # noqa: E501
        """Show One Time Password Source  # noqa: E501

        Show the source of the one time password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_one_time_password_source_api_v2_users_show_otp_source_post(otp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ShowotpsourcereturnapimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.show_one_time_password_source_api_v2_users_show_otp_source_post_with_http_info(otp, **kwargs)  # noqa: E501

    def show_one_time_password_source_api_v2_users_show_otp_source_post_with_http_info(self, otp, **kwargs):  # noqa: E501
        """Show One Time Password Source  # noqa: E501

        Show the source of the one time password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_one_time_password_source_api_v2_users_show_otp_source_post_with_http_info(otp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ShowotpsourcereturnapimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'otp'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_one_time_password_source_api_v2_users_show_otp_source_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'otp' is set
        if self.api_client.client_side_validation and ('otp' not in local_var_params or  # noqa: E501
                                                        local_var_params['otp'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `otp` when calling `show_one_time_password_source_api_v2_users_show_otp_source_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'otp' in local_var_params and local_var_params['otp'] is not None:  # noqa: E501
            query_params.append(('otp', local_var_params['otp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/show_otp_source', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ShowotpsourcereturnapimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sso_admin_link_api_v2_organizations_organization_id_sso_admin_link_get(self, organization_id, **kwargs):  # noqa: E501
        """Sso Admin Link  # noqa: E501

        Get the admin link for the organization's SSO configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_admin_link_api_v2_organizations_organization_id_sso_admin_link_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SsoconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.sso_admin_link_api_v2_organizations_organization_id_sso_admin_link_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def sso_admin_link_api_v2_organizations_organization_id_sso_admin_link_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Sso Admin Link  # noqa: E501

        Get the admin link for the organization's SSO configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_admin_link_api_v2_organizations_organization_id_sso_admin_link_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SsoconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sso_admin_link_api_v2_organizations_organization_id_sso_admin_link_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `sso_admin_link_api_v2_organizations_organization_id_sso_admin_link_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/{organization_id}/sso_admin_link', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SsoconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sso_login_info_api_v2_users_sso_login_info_get(self, organization_id, **kwargs):  # noqa: E501
        """Sso Login Info  # noqa: E501

        Get the url for initiating SAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_login_info_api_v2_users_sso_login_info_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param str magic_token:
        :param str return_to:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SsologininfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.sso_login_info_api_v2_users_sso_login_info_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def sso_login_info_api_v2_users_sso_login_info_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Sso Login Info  # noqa: E501

        Get the url for initiating SAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_login_info_api_v2_users_sso_login_info_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param str magic_token:
        :param str return_to:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SsologininfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id',
            'magic_token',
            'return_to'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sso_login_info_api_v2_users_sso_login_info_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `sso_login_info_api_v2_users_sso_login_info_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_id' in local_var_params and local_var_params['organization_id'] is not None:  # noqa: E501
            query_params.append(('organization_id', local_var_params['organization_id']))  # noqa: E501
        if 'magic_token' in local_var_params and local_var_params['magic_token'] is not None:  # noqa: E501
            query_params.append(('magic_token', local_var_params['magic_token']))  # noqa: E501
        if 'return_to' in local_var_params and local_var_params['return_to'] is not None:  # noqa: E501
            query_params.append(('return_to', local_var_params['return_to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/sso_login_info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SsologininfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sso_login_test_api_v2_users_sso_login_test_get(self, organization_id, **kwargs):  # noqa: E501
        """Sso Login Test  # noqa: E501

        Redirect to the url for testing SAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_login_test_api_v2_users_sso_login_test_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param str return_to:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.sso_login_test_api_v2_users_sso_login_test_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def sso_login_test_api_v2_users_sso_login_test_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Sso Login Test  # noqa: E501

        Redirect to the url for testing SAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_login_test_api_v2_users_sso_login_test_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param str return_to:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id',
            'return_to'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sso_login_test_api_v2_users_sso_login_test_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `sso_login_test_api_v2_users_sso_login_test_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_id' in local_var_params and local_var_params['organization_id'] is not None:  # noqa: E501
            query_params.append(('organization_id', local_var_params['organization_id']))  # noqa: E501
        if 'return_to' in local_var_params and local_var_params['return_to'] is not None:  # noqa: E501
            query_params.append(('return_to', local_var_params['return_to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/sso_login_test', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_session_api_v2_sessions_session_id_start_post(self, session_id, start_session_options, **kwargs):  # noqa: E501
        """Start Session  # noqa: E501

        Start a (previously stopped) session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_session_api_v2_sessions_session_id_start_post(session_id, start_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param StartSessionOptions start_session_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.start_session_api_v2_sessions_session_id_start_post_with_http_info(session_id, start_session_options, **kwargs)  # noqa: E501

    def start_session_api_v2_sessions_session_id_start_post_with_http_info(self, session_id, start_session_options, **kwargs):  # noqa: E501
        """Start Session  # noqa: E501

        Start a (previously stopped) session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_session_api_v2_sessions_session_id_start_post_with_http_info(session_id, start_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param StartSessionOptions start_session_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_session_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_session_api_v2_sessions_session_id_start_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `start_session_api_v2_sessions_session_id_start_post`")  # noqa: E501
        # verify the required parameter 'start_session_options' is set
        if self.api_client.client_side_validation and ('start_session_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_session_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_session_options` when calling `start_session_api_v2_sessions_session_id_start_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'start_session_options' in local_var_params:
            body_params = local_var_params['start_session_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_session_api_v2_sessions_session_id_stop_post(self, session_id, stop_session_options, **kwargs):  # noqa: E501
        """Stop Session  # noqa: E501

        Terminate an active session of a project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_session_api_v2_sessions_session_id_stop_post(session_id, stop_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param StopSessionOptions stop_session_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.stop_session_api_v2_sessions_session_id_stop_post_with_http_info(session_id, stop_session_options, **kwargs)  # noqa: E501

    def stop_session_api_v2_sessions_session_id_stop_post_with_http_info(self, session_id, stop_session_options, **kwargs):  # noqa: E501
        """Stop Session  # noqa: E501

        Terminate an active session of a project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_session_api_v2_sessions_session_id_stop_post_with_http_info(session_id, stop_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param StopSessionOptions stop_session_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'stop_session_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_session_api_v2_sessions_session_id_stop_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `stop_session_api_v2_sessions_session_id_stop_post`")  # noqa: E501
        # verify the required parameter 'stop_session_options' is set
        if self.api_client.client_side_validation and ('stop_session_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['stop_session_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stop_session_options` when calling `stop_session_api_v2_sessions_session_id_stop_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stop_session_options' in local_var_params:
            body_params = local_var_params['stop_session_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stripe_success_webhook_api_v2_organization_billing_stripe_success_webhook_post(self, **kwargs):  # noqa: E501
        """Stripe Success Webhook  # noqa: E501

        Adds payment info for the first time or updates existing payment info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stripe_success_webhook_api_v2_organization_billing_stripe_success_webhook_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.stripe_success_webhook_api_v2_organization_billing_stripe_success_webhook_post_with_http_info(**kwargs)  # noqa: E501

    def stripe_success_webhook_api_v2_organization_billing_stripe_success_webhook_post_with_http_info(self, **kwargs):  # noqa: E501
        """Stripe Success Webhook  # noqa: E501

        Adds payment info for the first time or updates existing payment info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stripe_success_webhook_api_v2_organization_billing_stripe_success_webhook_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stripe_success_webhook_api_v2_organization_billing_stripe_success_webhook_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/stripe_success_webhook', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def summarize_machine_pool_api_v2_machine_pools_summary_post(self, summarize_machine_pool_request, **kwargs):  # noqa: E501
        """Summarize Machine Pool  # noqa: E501

        Summarize the current state of a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summarize_machine_pool_api_v2_machine_pools_summary_post(summarize_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param SummarizeMachinePoolRequest summarize_machine_pool_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SummarizemachinepoolresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.summarize_machine_pool_api_v2_machine_pools_summary_post_with_http_info(summarize_machine_pool_request, **kwargs)  # noqa: E501

    def summarize_machine_pool_api_v2_machine_pools_summary_post_with_http_info(self, summarize_machine_pool_request, **kwargs):  # noqa: E501
        """Summarize Machine Pool  # noqa: E501

        Summarize the current state of a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summarize_machine_pool_api_v2_machine_pools_summary_post_with_http_info(summarize_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param SummarizeMachinePoolRequest summarize_machine_pool_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SummarizemachinepoolresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'summarize_machine_pool_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method summarize_machine_pool_api_v2_machine_pools_summary_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'summarize_machine_pool_request' is set
        if self.api_client.client_side_validation and ('summarize_machine_pool_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['summarize_machine_pool_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `summarize_machine_pool_request` when calling `summarize_machine_pool_api_v2_machine_pools_summary_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'summarize_machine_pool_request' in local_var_params:
            body_params = local_var_params['summarize_machine_pool_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/summary', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SummarizemachinepoolresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sync_organization_with_metronome_api_v2_organization_billing_organization_id_sync_with_metronome_post(self, organization_id, **kwargs):  # noqa: E501
        """Sync Organization With Metronome  # noqa: E501

        Refreshes the status of all (recorded) Metronome alerts. If reset_alerts is True, the alerts will be reset before being fetched.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sync_organization_with_metronome_api_v2_organization_billing_organization_id_sync_with_metronome_post(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param bool reset_alerts:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.sync_organization_with_metronome_api_v2_organization_billing_organization_id_sync_with_metronome_post_with_http_info(organization_id, **kwargs)  # noqa: E501

    def sync_organization_with_metronome_api_v2_organization_billing_organization_id_sync_with_metronome_post_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Sync Organization With Metronome  # noqa: E501

        Refreshes the status of all (recorded) Metronome alerts. If reset_alerts is True, the alerts will be reset before being fetched.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sync_organization_with_metronome_api_v2_organization_billing_organization_id_sync_with_metronome_post_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param bool reset_alerts:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id',
            'reset_alerts'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sync_organization_with_metronome_api_v2_organization_billing_organization_id_sync_with_metronome_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `sync_organization_with_metronome_api_v2_organization_billing_organization_id_sync_with_metronome_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []
        if 'reset_alerts' in local_var_params and local_var_params['reset_alerts'] is not None:  # noqa: E501
            query_params.append(('reset_alerts', local_var_params['reset_alerts']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/{organization_id}/sync_with_metronome', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post(self, production_job_id, **kwargs):  # noqa: E501
        """Terminate Job  # noqa: E501

        Terminate an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InternalproductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post_with_http_info(production_job_id, **kwargs)  # noqa: E501

    def terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post_with_http_info(self, production_job_id, **kwargs):  # noqa: E501
        """Terminate Job  # noqa: E501

        Terminate an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post_with_http_info(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InternalproductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InternalproductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def terminate_job_queue_api_v2_job_queues_job_queue_id_terminate_post(self, job_queue_id, **kwargs):  # noqa: E501
        """Terminate Job Queue  # noqa: E501

        Terminate all jobs in a job queue and then the cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_job_queue_api_v2_job_queues_job_queue_id_terminate_post(job_queue_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_queue_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobqueueterminationresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.terminate_job_queue_api_v2_job_queues_job_queue_id_terminate_post_with_http_info(job_queue_id, **kwargs)  # noqa: E501

    def terminate_job_queue_api_v2_job_queues_job_queue_id_terminate_post_with_http_info(self, job_queue_id, **kwargs):  # noqa: E501
        """Terminate Job Queue  # noqa: E501

        Terminate all jobs in a job queue and then the cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_job_queue_api_v2_job_queues_job_queue_id_terminate_post_with_http_info(job_queue_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_queue_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobqueueterminationresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_queue_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_job_queue_api_v2_job_queues_job_queue_id_terminate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_queue_id' is set
        if self.api_client.client_side_validation and ('job_queue_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_queue_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_queue_id` when calling `terminate_job_queue_api_v2_job_queues_job_queue_id_terminate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_queue_id' in local_var_params:
            path_params['job_queue_id'] = local_var_params['job_queue_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/job_queues/{job_queue_id}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobqueueterminationresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def terminate_service_api_v2_services_v2_service_id_terminate_post(self, service_id, **kwargs):  # noqa: E501
        """Terminate Service  # noqa: E501

        Terminate a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_service_api_v2_services_v2_service_id_terminate_post(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.terminate_service_api_v2_services_v2_service_id_terminate_post_with_http_info(service_id, **kwargs)  # noqa: E501

    def terminate_service_api_v2_services_v2_service_id_terminate_post_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Terminate Service  # noqa: E501

        Terminate a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_service_api_v2_services_v2_service_id_terminate_post_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_service_api_v2_services_v2_service_id_terminate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `terminate_service_api_v2_services_v2_service_id_terminate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def terminate_system_cluster_api_v2_system_workload_cloud_id_terminate_post(self, cloud_id, **kwargs):  # noqa: E501
        """Terminate System Cluster  # noqa: E501

        Initializes workflow to transition the System Cluster of a given cloud into the Terminated state. This is a long running operation. Clients will need to poll the operation's status to determine completion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_system_cluster_api_v2_system_workload_cloud_id_terminate_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: ID of the Cloud to terminate the System Cluster in. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusteroperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.terminate_system_cluster_api_v2_system_workload_cloud_id_terminate_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def terminate_system_cluster_api_v2_system_workload_cloud_id_terminate_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Terminate System Cluster  # noqa: E501

        Initializes workflow to transition the System Cluster of a given cloud into the Terminated state. This is a long running operation. Clients will need to poll the operation's status to determine completion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_system_cluster_api_v2_system_workload_cloud_id_terminate_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: ID of the Cloud to terminate the System Cluster in. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusteroperationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_system_cluster_api_v2_system_workload_cloud_id_terminate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `terminate_system_cluster_api_v2_system_workload_cloud_id_terminate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/system_workload/{cloud_id}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusteroperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post(self, organization_id, **kwargs):  # noqa: E501
        """Test Saml Acs  # noqa: E501

        Use this organization's Single Sign On (SSO) test config with the SAML2 protocol as a test. This will return a 2xx status code if authentication was successful, or a 4xx or 5xx code if not. Either way, we will not create an authenticated session and the caller will not be logged in.  Use this endpoint to test out a new sso_config without setting it as the only way to log into your organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post_with_http_info(organization_id, **kwargs)  # noqa: E501

    def test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Test Saml Acs  # noqa: E501

        Use this organization's Single Sign On (SSO) test config with the SAML2 protocol as a test. This will return a 2xx status code if authentication was successful, or a 4xx or 5xx code if not. Either way, we will not create an authenticated session and the caller will not be logged in.  Use this endpoint to test out a new sso_config without setting it as the only way to log into your organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/{organization_id}/test_saml_acs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def toggle_instance_usage_budget_is_enabled_api_v2_instance_usage_budgets_instance_usage_budget_id_toggle_is_enabled_post(self, instance_usage_budget_id, is_enabled, **kwargs):  # noqa: E501
        """Toggle Instance Usage Budget Is Enabled  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toggle_instance_usage_budget_is_enabled_api_v2_instance_usage_budgets_instance_usage_budget_id_toggle_is_enabled_post(instance_usage_budget_id, is_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str instance_usage_budget_id: (required)
        :param bool is_enabled: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InstanceusagebudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.toggle_instance_usage_budget_is_enabled_api_v2_instance_usage_budgets_instance_usage_budget_id_toggle_is_enabled_post_with_http_info(instance_usage_budget_id, is_enabled, **kwargs)  # noqa: E501

    def toggle_instance_usage_budget_is_enabled_api_v2_instance_usage_budgets_instance_usage_budget_id_toggle_is_enabled_post_with_http_info(self, instance_usage_budget_id, is_enabled, **kwargs):  # noqa: E501
        """Toggle Instance Usage Budget Is Enabled  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toggle_instance_usage_budget_is_enabled_api_v2_instance_usage_budgets_instance_usage_budget_id_toggle_is_enabled_post_with_http_info(instance_usage_budget_id, is_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str instance_usage_budget_id: (required)
        :param bool is_enabled: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InstanceusagebudgetResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'instance_usage_budget_id',
            'is_enabled'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method toggle_instance_usage_budget_is_enabled_api_v2_instance_usage_budgets_instance_usage_budget_id_toggle_is_enabled_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'instance_usage_budget_id' is set
        if self.api_client.client_side_validation and ('instance_usage_budget_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['instance_usage_budget_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `instance_usage_budget_id` when calling `toggle_instance_usage_budget_is_enabled_api_v2_instance_usage_budgets_instance_usage_budget_id_toggle_is_enabled_post`")  # noqa: E501
        # verify the required parameter 'is_enabled' is set
        if self.api_client.client_side_validation and ('is_enabled' not in local_var_params or  # noqa: E501
                                                        local_var_params['is_enabled'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `is_enabled` when calling `toggle_instance_usage_budget_is_enabled_api_v2_instance_usage_budgets_instance_usage_budget_id_toggle_is_enabled_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_usage_budget_id' in local_var_params:
            path_params['instance_usage_budget_id'] = local_var_params['instance_usage_budget_id']  # noqa: E501

        query_params = []
        if 'is_enabled' in local_var_params and local_var_params['is_enabled'] is not None:  # noqa: E501
            query_params.append(('is_enabled', local_var_params['is_enabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/instance_usage_budgets/{instance_usage_budget_id}/toggle_is_enabled', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceusagebudgetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post(self, cron_job_id, **kwargs):  # noqa: E501
        """Trigger Cron Job  # noqa: E501

        Trigger CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post(cron_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post_with_http_info(cron_job_id, **kwargs)  # noqa: E501

    def trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post_with_http_info(self, cron_job_id, **kwargs):  # noqa: E501
        """Trigger Cron Job  # noqa: E501

        Trigger CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post_with_http_info(cron_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cron_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cron_job_id' is set
        if self.api_client.client_side_validation and ('cron_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cron_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cron_job_id` when calling `trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cron_job_id' in local_var_params:
            path_params['cron_job_id'] = local_var_params['cron_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/{cron_job_id}/trigger', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def try_claim_cloud_api_v2_aioa_cloud_waitlist_claim_cloud_post(self, **kwargs):  # noqa: E501
        """Try Claim Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.try_claim_cloud_api_v2_aioa_cloud_waitlist_claim_cloud_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WaitliststatusresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.try_claim_cloud_api_v2_aioa_cloud_waitlist_claim_cloud_post_with_http_info(**kwargs)  # noqa: E501

    def try_claim_cloud_api_v2_aioa_cloud_waitlist_claim_cloud_post_with_http_info(self, **kwargs):  # noqa: E501
        """Try Claim Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.try_claim_cloud_api_v2_aioa_cloud_waitlist_claim_cloud_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WaitliststatusresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method try_claim_cloud_api_v2_aioa_cloud_waitlist_claim_cloud_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aioa_cloud_waitlist/claim_cloud', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WaitliststatusresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def try_login_api_v2_users_try_login_post(self, otp_token, **kwargs):  # noqa: E501
        """Try Login  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.try_login_api_v2_users_try_login_post(otp_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp_token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TryloginemailresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.try_login_api_v2_users_try_login_post_with_http_info(otp_token, **kwargs)  # noqa: E501

    def try_login_api_v2_users_try_login_post_with_http_info(self, otp_token, **kwargs):  # noqa: E501
        """Try Login  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.try_login_api_v2_users_try_login_post_with_http_info(otp_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp_token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TryloginemailresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'otp_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method try_login_api_v2_users_try_login_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'otp_token' is set
        if self.api_client.client_side_validation and ('otp_token' not in local_var_params or  # noqa: E501
                                                        local_var_params['otp_token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `otp_token` when calling `try_login_api_v2_users_try_login_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'otp_token' in local_var_params and local_var_params['otp_token'] is not None:  # noqa: E501
            query_params.append(('otp_token', local_var_params['otp_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/try-login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TryloginemailresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def try_login_workos_api_v2_users_try_login_auth_code_post(self, otp_token, auth_code, **kwargs):  # noqa: E501
        """Try Login Workos  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.try_login_workos_api_v2_users_try_login_auth_code_post(otp_token, auth_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp_token: (required)
        :param str auth_code: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TryloginworkosresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.try_login_workos_api_v2_users_try_login_auth_code_post_with_http_info(otp_token, auth_code, **kwargs)  # noqa: E501

    def try_login_workos_api_v2_users_try_login_auth_code_post_with_http_info(self, otp_token, auth_code, **kwargs):  # noqa: E501
        """Try Login Workos  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.try_login_workos_api_v2_users_try_login_auth_code_post_with_http_info(otp_token, auth_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp_token: (required)
        :param str auth_code: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TryloginworkosresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'otp_token',
            'auth_code'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method try_login_workos_api_v2_users_try_login_auth_code_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'otp_token' is set
        if self.api_client.client_side_validation and ('otp_token' not in local_var_params or  # noqa: E501
                                                        local_var_params['otp_token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `otp_token` when calling `try_login_workos_api_v2_users_try_login_auth_code_post`")  # noqa: E501
        # verify the required parameter 'auth_code' is set
        if self.api_client.client_side_validation and ('auth_code' not in local_var_params or  # noqa: E501
                                                        local_var_params['auth_code'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `auth_code` when calling `try_login_workos_api_v2_users_try_login_auth_code_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'otp_token' in local_var_params and local_var_params['otp_token'] is not None:  # noqa: E501
            query_params.append(('otp_token', local_var_params['otp_token']))  # noqa: E501
        if 'auth_code' in local_var_params and local_var_params['auth_code'] is not None:  # noqa: E501
            query_params.append(('auth_code', local_var_params['auth_code']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/try-login-auth-code', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TryloginworkosresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unpublish_template_api_v2_workspace_templates_template_id_unpublish_post(self, template_id, **kwargs):  # noqa: E501
        """Unpublish Template  # noqa: E501

        Unpublish a template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unpublish_template_api_v2_workspace_templates_template_id_unpublish_post(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.unpublish_template_api_v2_workspace_templates_template_id_unpublish_post_with_http_info(template_id, **kwargs)  # noqa: E501

    def unpublish_template_api_v2_workspace_templates_template_id_unpublish_post_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Unpublish Template  # noqa: E501

        Unpublish a template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unpublish_template_api_v2_workspace_templates_template_id_unpublish_post_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unpublish_template_api_v2_workspace_templates_template_id_unpublish_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `unpublish_template_api_v2_workspace_templates_template_id_unpublish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/{template_id}/unpublish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put(self, cloud_id, auto_add_user, **kwargs):  # noqa: E501
        """Update Cloud Auto Add User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put(cloud_id, auto_add_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool auto_add_user: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put_with_http_info(cloud_id, auto_add_user, **kwargs)  # noqa: E501

    def update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put_with_http_info(self, cloud_id, auto_add_user, **kwargs):  # noqa: E501
        """Update Cloud Auto Add User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put_with_http_info(cloud_id, auto_add_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool auto_add_user: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'auto_add_user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put`")  # noqa: E501
        # verify the required parameter 'auto_add_user' is set
        if self.api_client.client_side_validation and ('auto_add_user' not in local_var_params or  # noqa: E501
                                                        local_var_params['auto_add_user'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `auto_add_user` when calling `update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'auto_add_user' in local_var_params and local_var_params['auto_add_user'] is not None:  # noqa: E501
            query_params.append(('auto_add_user', local_var_params['auto_add_user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/auto_add_user', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put(self, cloud_id, cloud_deployment_id, cloud_deployment_config, **kwargs):  # noqa: E501
        """Update Cloud Deployment Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put(cloud_id, cloud_deployment_id, cloud_deployment_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_deployment_id: (required)
        :param CloudDeploymentConfig cloud_deployment_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClouddeploymentconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put_with_http_info(cloud_id, cloud_deployment_id, cloud_deployment_config, **kwargs)  # noqa: E501

    def update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put_with_http_info(self, cloud_id, cloud_deployment_id, cloud_deployment_config, **kwargs):  # noqa: E501
        """Update Cloud Deployment Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put_with_http_info(cloud_id, cloud_deployment_id, cloud_deployment_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str cloud_deployment_id: (required)
        :param CloudDeploymentConfig cloud_deployment_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClouddeploymentconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_deployment_id',
            'cloud_deployment_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put`")  # noqa: E501
        # verify the required parameter 'cloud_deployment_id' is set
        if self.api_client.client_side_validation and ('cloud_deployment_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_deployment_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_deployment_id` when calling `update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put`")  # noqa: E501
        # verify the required parameter 'cloud_deployment_config' is set
        if self.api_client.client_side_validation and ('cloud_deployment_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_deployment_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_deployment_config` when calling `update_cloud_deployment_config_api_v2_clouds_cloud_id_deployment_cloud_deployment_id_config_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501
        if 'cloud_deployment_id' in local_var_params:
            path_params['cloud_deployment_id'] = local_var_params['cloud_deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_deployment_config' in local_var_params:
            body_params = local_var_params['cloud_deployment_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/deployment/{cloud_deployment_id}/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClouddeploymentconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_lineage_tracking_enabled_api_v2_clouds_cloud_id_lineage_tracking_enabled_put(self, cloud_id, lineage_tracking_enabled, **kwargs):  # noqa: E501
        """Update Cloud Lineage Tracking Enabled  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_lineage_tracking_enabled_api_v2_clouds_cloud_id_lineage_tracking_enabled_put(cloud_id, lineage_tracking_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool lineage_tracking_enabled: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_lineage_tracking_enabled_api_v2_clouds_cloud_id_lineage_tracking_enabled_put_with_http_info(cloud_id, lineage_tracking_enabled, **kwargs)  # noqa: E501

    def update_cloud_lineage_tracking_enabled_api_v2_clouds_cloud_id_lineage_tracking_enabled_put_with_http_info(self, cloud_id, lineage_tracking_enabled, **kwargs):  # noqa: E501
        """Update Cloud Lineage Tracking Enabled  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_lineage_tracking_enabled_api_v2_clouds_cloud_id_lineage_tracking_enabled_put_with_http_info(cloud_id, lineage_tracking_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool lineage_tracking_enabled: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'lineage_tracking_enabled'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_lineage_tracking_enabled_api_v2_clouds_cloud_id_lineage_tracking_enabled_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_lineage_tracking_enabled_api_v2_clouds_cloud_id_lineage_tracking_enabled_put`")  # noqa: E501
        # verify the required parameter 'lineage_tracking_enabled' is set
        if self.api_client.client_side_validation and ('lineage_tracking_enabled' not in local_var_params or  # noqa: E501
                                                        local_var_params['lineage_tracking_enabled'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `lineage_tracking_enabled` when calling `update_cloud_lineage_tracking_enabled_api_v2_clouds_cloud_id_lineage_tracking_enabled_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'lineage_tracking_enabled' in local_var_params and local_var_params['lineage_tracking_enabled'] is not None:  # noqa: E501
            query_params.append(('lineage_tracking_enabled', local_var_params['lineage_tracking_enabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/lineage_tracking_enabled', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_resources_api_v2_clouds_cloud_id_resources_put(self, cloud_id, cloud_deployment, **kwargs):  # noqa: E501
        """Update Cloud Resources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_resources_api_v2_clouds_cloud_id_resources_put(cloud_id, cloud_deployment, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param list[CloudDeployment] cloud_deployment: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_resources_api_v2_clouds_cloud_id_resources_put_with_http_info(cloud_id, cloud_deployment, **kwargs)  # noqa: E501

    def update_cloud_resources_api_v2_clouds_cloud_id_resources_put_with_http_info(self, cloud_id, cloud_deployment, **kwargs):  # noqa: E501
        """Update Cloud Resources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_resources_api_v2_clouds_cloud_id_resources_put_with_http_info(cloud_id, cloud_deployment, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param list[CloudDeployment] cloud_deployment: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_deployment'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_resources_api_v2_clouds_cloud_id_resources_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_resources_api_v2_clouds_cloud_id_resources_put`")  # noqa: E501
        # verify the required parameter 'cloud_deployment' is set
        if self.api_client.client_side_validation and ('cloud_deployment' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_deployment'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_deployment` when calling `update_cloud_resources_api_v2_clouds_cloud_id_resources_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_deployment' in local_var_params:
            body_params = local_var_params['cloud_deployment']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/resources', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_state_api_v2_clouds_cloud_id_state_put(self, cloud_id, state, **kwargs):  # noqa: E501
        """Update Cloud State  # noqa: E501

        Update the state of a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_state_api_v2_clouds_cloud_id_state_put(cloud_id, state, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudState state: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_state_api_v2_clouds_cloud_id_state_put_with_http_info(cloud_id, state, **kwargs)  # noqa: E501

    def update_cloud_state_api_v2_clouds_cloud_id_state_put_with_http_info(self, cloud_id, state, **kwargs):  # noqa: E501
        """Update Cloud State  # noqa: E501

        Update the state of a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_state_api_v2_clouds_cloud_id_state_put_with_http_info(cloud_id, state, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudState state: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'state'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_state_api_v2_clouds_cloud_id_state_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_state_api_v2_clouds_cloud_id_state_put`")  # noqa: E501
        # verify the required parameter 'state' is set
        if self.api_client.client_side_validation and ('state' not in local_var_params or  # noqa: E501
                                                        local_var_params['state'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `state` when calling `update_cloud_state_api_v2_clouds_cloud_id_state_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'state' in local_var_params and local_var_params['state'] is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/state', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put(self, cloud_id, update_cloud_with_cloud_resource_gcp, **kwargs):  # noqa: E501
        """Update Cloud With Cloud Resource  # noqa: E501

        Updates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put(cloud_id, update_cloud_with_cloud_resource_gcp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param UpdateCloudWithCloudResourceGCP update_cloud_with_cloud_resource_gcp: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourcegcpResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put_with_http_info(cloud_id, update_cloud_with_cloud_resource_gcp, **kwargs)  # noqa: E501

    def update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put_with_http_info(self, cloud_id, update_cloud_with_cloud_resource_gcp, **kwargs):  # noqa: E501
        """Update Cloud With Cloud Resource  # noqa: E501

        Updates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put_with_http_info(cloud_id, update_cloud_with_cloud_resource_gcp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param UpdateCloudWithCloudResourceGCP update_cloud_with_cloud_resource_gcp: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourcegcpResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'update_cloud_with_cloud_resource_gcp'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put`")  # noqa: E501
        # verify the required parameter 'update_cloud_with_cloud_resource_gcp' is set
        if self.api_client.client_side_validation and ('update_cloud_with_cloud_resource_gcp' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_cloud_with_cloud_resource_gcp'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_cloud_with_cloud_resource_gcp` when calling `update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_cloud_with_cloud_resource_gcp' in local_var_params:
            body_params = local_var_params['update_cloud_with_cloud_resource_gcp']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_gcp_router/{cloud_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourcegcpResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put(self, cloud_id, update_cloud_with_cloud_resource, **kwargs):  # noqa: E501
        """Update Cloud With Cloud Resource  # noqa: E501

        Updates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put(cloud_id, update_cloud_with_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param UpdateCloudWithCloudResource update_cloud_with_cloud_resource: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put_with_http_info(cloud_id, update_cloud_with_cloud_resource, **kwargs)  # noqa: E501

    def update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put_with_http_info(self, cloud_id, update_cloud_with_cloud_resource, **kwargs):  # noqa: E501
        """Update Cloud With Cloud Resource  # noqa: E501

        Updates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put_with_http_info(cloud_id, update_cloud_with_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param UpdateCloudWithCloudResource update_cloud_with_cloud_resource: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'update_cloud_with_cloud_resource'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put`")  # noqa: E501
        # verify the required parameter 'update_cloud_with_cloud_resource' is set
        if self.api_client.client_side_validation and ('update_cloud_with_cloud_resource' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_cloud_with_cloud_resource'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_cloud_with_cloud_resource` when calling `update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_cloud_with_cloud_resource' in local_var_params:
            body_params = local_var_params['update_cloud_with_cloud_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_router/{cloud_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put(self, cloud_id, is_enabled, **kwargs):  # noqa: E501
        """Update Customer Aggregated Logs Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put(cloud_id, is_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool is_enabled: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put_with_http_info(cloud_id, is_enabled, **kwargs)  # noqa: E501

    def update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put_with_http_info(self, cloud_id, is_enabled, **kwargs):  # noqa: E501
        """Update Customer Aggregated Logs Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put_with_http_info(cloud_id, is_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool is_enabled: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'is_enabled'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put`")  # noqa: E501
        # verify the required parameter 'is_enabled' is set
        if self.api_client.client_side_validation and ('is_enabled' not in local_var_params or  # noqa: E501
                                                        local_var_params['is_enabled'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `is_enabled` when calling `update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'is_enabled' in local_var_params and local_var_params['is_enabled'] is not None:  # noqa: E501
            query_params.append(('is_enabled', local_var_params['is_enabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/update_customer_aggregated_logs_config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_default_cloud_api_v2_organizations_update_default_cloud_post(self, cloud_id, **kwargs):  # noqa: E501
        """Update Default Cloud  # noqa: E501

        Updates the default cloud for the request user's organization. Checks that the user is owner of organization and that the cloud has organization level permissions.  ** Note: If cloud isolation is enabled, the cloud doesn't have to be accessible to all members of the organization. The organization admin can choose to set a default cloud that not all collaborators have access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_cloud_api_v2_organizations_update_default_cloud_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_default_cloud_api_v2_organizations_update_default_cloud_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def update_default_cloud_api_v2_organizations_update_default_cloud_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Update Default Cloud  # noqa: E501

        Updates the default cloud for the request user's organization. Checks that the user is owner of organization and that the cloud has organization level permissions.  ** Note: If cloud isolation is enabled, the cloud doesn't have to be accessible to all members of the organization. The organization admin can choose to set a default cloud that not all collaborators have access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_cloud_api_v2_organizations_update_default_cloud_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_default_cloud_api_v2_organizations_update_default_cloud_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_default_cloud_api_v2_organizations_update_default_cloud_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/update_default_cloud', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dns_api_v2_dns_post(self, update_cluster_dns, **kwargs):  # noqa: E501
        """Update Dns  # noqa: E501

        Update head node ip in the database and dns.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dns_api_v2_dns_post(update_cluster_dns, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpdateClusterDns update_cluster_dns: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_dns_api_v2_dns_post_with_http_info(update_cluster_dns, **kwargs)  # noqa: E501

    def update_dns_api_v2_dns_post_with_http_info(self, update_cluster_dns, **kwargs):  # noqa: E501
        """Update Dns  # noqa: E501

        Update head node ip in the database and dns.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dns_api_v2_dns_post_with_http_info(update_cluster_dns, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpdateClusterDns update_cluster_dns: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'update_cluster_dns'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dns_api_v2_dns_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'update_cluster_dns' is set
        if self.api_client.client_side_validation and ('update_cluster_dns' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_cluster_dns'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_cluster_dns` when calling `update_dns_api_v2_dns_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_cluster_dns' in local_var_params:
            body_params = local_var_params['update_cluster_dns']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dns/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_processing_status_api_v2_workos_events_event_id_status_put(self, event_id, status, **kwargs):  # noqa: E501
        """Update Event Processing Status  # noqa: E501

        Update the status of a WorkOS event.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_processing_status_api_v2_workos_events_event_id_status_put(event_id, status, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event_id: (required)
        :param WorkOSEventStatus status: Processing status to set (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_event_processing_status_api_v2_workos_events_event_id_status_put_with_http_info(event_id, status, **kwargs)  # noqa: E501

    def update_event_processing_status_api_v2_workos_events_event_id_status_put_with_http_info(self, event_id, status, **kwargs):  # noqa: E501
        """Update Event Processing Status  # noqa: E501

        Update the status of a WorkOS event.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_processing_status_api_v2_workos_events_event_id_status_put_with_http_info(event_id, status, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event_id: (required)
        :param WorkOSEventStatus status: Processing status to set (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'event_id',
            'status'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_processing_status_api_v2_workos_events_event_id_status_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'event_id' is set
        if self.api_client.client_side_validation and ('event_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['event_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `event_id` when calling `update_event_processing_status_api_v2_workos_events_event_id_status_put`")  # noqa: E501
        # verify the required parameter 'status' is set
        if self.api_client.client_side_validation and ('status' not in local_var_params or  # noqa: E501
                                                        local_var_params['status'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `status` when calling `update_event_processing_status_api_v2_workos_events_event_id_status_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in local_var_params:
            path_params['event_id'] = local_var_params['event_id']  # noqa: E501

        query_params = []
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workos/events/{event_id}/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_put(self, instance_usage_budget_id, **kwargs):  # noqa: E501
        """Update Instance Usage Budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_put(instance_usage_budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str instance_usage_budget_id: (required)
        :param float budget_amount:
        :param InstanceUsageBudgetEvaluationPeriod evaluation_period:
        :param InstanceUsageBudgetUnit budget_unit:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InstanceusagebudgetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_put_with_http_info(instance_usage_budget_id, **kwargs)  # noqa: E501

    def update_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_put_with_http_info(self, instance_usage_budget_id, **kwargs):  # noqa: E501
        """Update Instance Usage Budget  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_put_with_http_info(instance_usage_budget_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str instance_usage_budget_id: (required)
        :param float budget_amount:
        :param InstanceUsageBudgetEvaluationPeriod evaluation_period:
        :param InstanceUsageBudgetUnit budget_unit:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InstanceusagebudgetResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'instance_usage_budget_id',
            'budget_amount',
            'evaluation_period',
            'budget_unit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'instance_usage_budget_id' is set
        if self.api_client.client_side_validation and ('instance_usage_budget_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['instance_usage_budget_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `instance_usage_budget_id` when calling `update_instance_usage_budget_api_v2_instance_usage_budgets_instance_usage_budget_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_usage_budget_id' in local_var_params:
            path_params['instance_usage_budget_id'] = local_var_params['instance_usage_budget_id']  # noqa: E501

        query_params = []
        if 'budget_amount' in local_var_params and local_var_params['budget_amount'] is not None:  # noqa: E501
            query_params.append(('budget_amount', local_var_params['budget_amount']))  # noqa: E501
        if 'evaluation_period' in local_var_params and local_var_params['evaluation_period'] is not None:  # noqa: E501
            query_params.append(('evaluation_period', local_var_params['evaluation_period']))  # noqa: E501
        if 'budget_unit' in local_var_params and local_var_params['budget_unit'] is not None:  # noqa: E501
            query_params.append(('budget_unit', local_var_params['budget_unit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/instance_usage_budgets/{instance_usage_budget_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InstanceusagebudgetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_job_queue_api_v2_job_queues_job_queue_id_put(self, job_queue_id, update_job_queue_request, **kwargs):  # noqa: E501
        """Update Job Queue  # noqa: E501

        Update a job queue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_job_queue_api_v2_job_queues_job_queue_id_put(job_queue_id, update_job_queue_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_queue_id: (required)
        :param UpdateJobQueueRequest update_job_queue_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedjobqueueResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_job_queue_api_v2_job_queues_job_queue_id_put_with_http_info(job_queue_id, update_job_queue_request, **kwargs)  # noqa: E501

    def update_job_queue_api_v2_job_queues_job_queue_id_put_with_http_info(self, job_queue_id, update_job_queue_request, **kwargs):  # noqa: E501
        """Update Job Queue  # noqa: E501

        Update a job queue.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_job_queue_api_v2_job_queues_job_queue_id_put_with_http_info(job_queue_id, update_job_queue_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_queue_id: (required)
        :param UpdateJobQueueRequest update_job_queue_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedjobqueueResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_queue_id',
            'update_job_queue_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_job_queue_api_v2_job_queues_job_queue_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_queue_id' is set
        if self.api_client.client_side_validation and ('job_queue_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_queue_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_queue_id` when calling `update_job_queue_api_v2_job_queues_job_queue_id_put`")  # noqa: E501
        # verify the required parameter 'update_job_queue_request' is set
        if self.api_client.client_side_validation and ('update_job_queue_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_job_queue_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_job_queue_request` when calling `update_job_queue_api_v2_job_queues_job_queue_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_queue_id' in local_var_params:
            path_params['job_queue_id'] = local_var_params['job_queue_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_job_queue_request' in local_var_params:
            body_params = local_var_params['update_job_queue_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/job_queues/{job_queue_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedjobqueueResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_job_queue_config_api_v2_decorated_ha_jobs_production_job_id_update_job_queue_config_put(self, production_job_id, job_queue_config, **kwargs):  # noqa: E501
        """Update Job Queue Config  # noqa: E501

        Update the job queue config of an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_job_queue_config_api_v2_decorated_ha_jobs_production_job_id_update_job_queue_config_put(production_job_id, job_queue_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param JobQueueConfig job_queue_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InternalproductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_job_queue_config_api_v2_decorated_ha_jobs_production_job_id_update_job_queue_config_put_with_http_info(production_job_id, job_queue_config, **kwargs)  # noqa: E501

    def update_job_queue_config_api_v2_decorated_ha_jobs_production_job_id_update_job_queue_config_put_with_http_info(self, production_job_id, job_queue_config, **kwargs):  # noqa: E501
        """Update Job Queue Config  # noqa: E501

        Update the job queue config of an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_job_queue_config_api_v2_decorated_ha_jobs_production_job_id_update_job_queue_config_put_with_http_info(production_job_id, job_queue_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param JobQueueConfig job_queue_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InternalproductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id',
            'job_queue_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_job_queue_config_api_v2_decorated_ha_jobs_production_job_id_update_job_queue_config_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `update_job_queue_config_api_v2_decorated_ha_jobs_production_job_id_update_job_queue_config_put`")  # noqa: E501
        # verify the required parameter 'job_queue_config' is set
        if self.api_client.client_side_validation and ('job_queue_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_queue_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_queue_config` when calling `update_job_queue_config_api_v2_decorated_ha_jobs_production_job_id_update_job_queue_config_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'job_queue_config' in local_var_params:
            body_params = local_var_params['job_queue_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}/update_job_queue_config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InternalproductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_machine_pool_api_v2_machine_pools_update_post(self, update_machine_pool_request, **kwargs):  # noqa: E501
        """Update Machine Pool  # noqa: E501

        Updates a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_machine_pool_api_v2_machine_pools_update_post(update_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpdateMachinePoolRequest update_machine_pool_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UpdatemachinepoolresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_machine_pool_api_v2_machine_pools_update_post_with_http_info(update_machine_pool_request, **kwargs)  # noqa: E501

    def update_machine_pool_api_v2_machine_pools_update_post_with_http_info(self, update_machine_pool_request, **kwargs):  # noqa: E501
        """Update Machine Pool  # noqa: E501

        Updates a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_machine_pool_api_v2_machine_pools_update_post_with_http_info(update_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpdateMachinePoolRequest update_machine_pool_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UpdatemachinepoolresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'update_machine_pool_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_machine_pool_api_v2_machine_pools_update_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'update_machine_pool_request' is set
        if self.api_client.client_side_validation and ('update_machine_pool_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_machine_pool_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_machine_pool_request` when calling `update_machine_pool_api_v2_machine_pools_update_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_machine_pool_request' in local_var_params:
            body_params = local_var_params['update_machine_pool_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdatemachinepoolresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_payment_info_api_v2_organization_billing_update_payment_info_post(self, **kwargs):  # noqa: E501
        """Update Payment Info  # noqa: E501

        Adds payment info for the first time or updates existing payment info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_payment_info_api_v2_organization_billing_update_payment_info_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UpdatePaymentInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_payment_info_api_v2_organization_billing_update_payment_info_post_with_http_info(**kwargs)  # noqa: E501

    def update_payment_info_api_v2_organization_billing_update_payment_info_post_with_http_info(self, **kwargs):  # noqa: E501
        """Update Payment Info  # noqa: E501

        Adds payment info for the first time or updates existing payment info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_payment_info_api_v2_organization_billing_update_payment_info_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UpdatePaymentInfo, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_payment_info_api_v2_organization_billing_update_payment_info_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/update_payment_info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdatePaymentInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_resource_notification_api_v2_resource_notifications_resource_notification_id_put(self, resource_notification_id, create_resource_notification, **kwargs):  # noqa: E501
        """Update Resource Notification  # noqa: E501

        Full update of the resource notification. This will replace the resource notification with the new data. For example, if None is passed as one of the fields, we will clear out that field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_resource_notification_api_v2_resource_notifications_resource_notification_id_put(resource_notification_id, create_resource_notification, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_notification_id: (required)
        :param CreateResourceNotification create_resource_notification: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcenotificationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_resource_notification_api_v2_resource_notifications_resource_notification_id_put_with_http_info(resource_notification_id, create_resource_notification, **kwargs)  # noqa: E501

    def update_resource_notification_api_v2_resource_notifications_resource_notification_id_put_with_http_info(self, resource_notification_id, create_resource_notification, **kwargs):  # noqa: E501
        """Update Resource Notification  # noqa: E501

        Full update of the resource notification. This will replace the resource notification with the new data. For example, if None is passed as one of the fields, we will clear out that field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_resource_notification_api_v2_resource_notifications_resource_notification_id_put_with_http_info(resource_notification_id, create_resource_notification, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_notification_id: (required)
        :param CreateResourceNotification create_resource_notification: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcenotificationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_notification_id',
            'create_resource_notification'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_resource_notification_api_v2_resource_notifications_resource_notification_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_notification_id' is set
        if self.api_client.client_side_validation and ('resource_notification_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_notification_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_notification_id` when calling `update_resource_notification_api_v2_resource_notifications_resource_notification_id_put`")  # noqa: E501
        # verify the required parameter 'create_resource_notification' is set
        if self.api_client.client_side_validation and ('create_resource_notification' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_resource_notification'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_resource_notification` when calling `update_resource_notification_api_v2_resource_notifications_resource_notification_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_notification_id' in local_var_params:
            path_params['resource_notification_id'] = local_var_params['resource_notification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_resource_notification' in local_var_params:
            body_params = local_var_params['create_resource_notification']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_notifications/{resource_notification_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcenotificationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_resource_policy_api_v2_policy_resource_type_resource_id_put(self, resource_type, resource_id, update_policy_request, **kwargs):  # noqa: E501
        """Update Resource Policy  # noqa: E501

        Set user group permission policy for a specific resource.  Parameters: - **resource_type**: Resource type (cloud, project, organization) - **resource_id**: Resource ID (e.g. cld_abc123, prj_xyz789).   For organization type, your own organization is used automatically. - **policy**: Policy configuration with role bindings  Valid role_name values by resource type:  **Cloud**: - `write`: Read/write access (create, read, update, delete) - `readonly`: Read-only access  **Project**: - `write`: Read/write access (create, read, update) - `readonly`: Read-only access  **Organization**: - `owner`: Full control (write + collaborator management) - `collaborator`: Read/write access to organization resources  Example: ``` PUT /policy/cloud/cld_abc123 Body: {     \"bindings\": [         {\"role_name\": \"write\", \"principals\": [\"ug_abc123\"]},         {\"role_name\": \"readonly\", \"principals\": [\"ug_def456\", \"ug_ghi789\"]}     ] } ```  Permission requirements: - Caller must be an organization admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_resource_policy_api_v2_policy_resource_type_resource_id_put(resource_type, resource_id, update_policy_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResourceType resource_type: (required)
        :param str resource_id: (required)
        :param UpdatePolicyRequest update_policy_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_resource_policy_api_v2_policy_resource_type_resource_id_put_with_http_info(resource_type, resource_id, update_policy_request, **kwargs)  # noqa: E501

    def update_resource_policy_api_v2_policy_resource_type_resource_id_put_with_http_info(self, resource_type, resource_id, update_policy_request, **kwargs):  # noqa: E501
        """Update Resource Policy  # noqa: E501

        Set user group permission policy for a specific resource.  Parameters: - **resource_type**: Resource type (cloud, project, organization) - **resource_id**: Resource ID (e.g. cld_abc123, prj_xyz789).   For organization type, your own organization is used automatically. - **policy**: Policy configuration with role bindings  Valid role_name values by resource type:  **Cloud**: - `write`: Read/write access (create, read, update, delete) - `readonly`: Read-only access  **Project**: - `write`: Read/write access (create, read, update) - `readonly`: Read-only access  **Organization**: - `owner`: Full control (write + collaborator management) - `collaborator`: Read/write access to organization resources  Example: ``` PUT /policy/cloud/cld_abc123 Body: {     \"bindings\": [         {\"role_name\": \"write\", \"principals\": [\"ug_abc123\"]},         {\"role_name\": \"readonly\", \"principals\": [\"ug_def456\", \"ug_ghi789\"]}     ] } ```  Permission requirements: - Caller must be an organization admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_resource_policy_api_v2_policy_resource_type_resource_id_put_with_http_info(resource_type, resource_id, update_policy_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResourceType resource_type: (required)
        :param str resource_id: (required)
        :param UpdatePolicyRequest update_policy_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_type',
            'resource_id',
            'update_policy_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_resource_policy_api_v2_policy_resource_type_resource_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_type' is set
        if self.api_client.client_side_validation and ('resource_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_type` when calling `update_resource_policy_api_v2_policy_resource_type_resource_id_put`")  # noqa: E501
        # verify the required parameter 'resource_id' is set
        if self.api_client.client_side_validation and ('resource_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_id` when calling `update_resource_policy_api_v2_policy_resource_type_resource_id_put`")  # noqa: E501
        # verify the required parameter 'update_policy_request' is set
        if self.api_client.client_side_validation and ('update_policy_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_policy_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_policy_request` when calling `update_resource_policy_api_v2_policy_resource_type_resource_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_type' in local_var_params:
            path_params['resource_type'] = local_var_params['resource_type']  # noqa: E501
        if 'resource_id' in local_var_params:
            path_params['resource_id'] = local_var_params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_policy_request' in local_var_params:
            body_params = local_var_params['update_policy_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/policy/{resource_type}/{resource_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_resource_quota_api_v2_resource_quotas_resource_quota_id_patch(self, resource_quota_id, update_resource_quota, **kwargs):  # noqa: E501
        """Update Resource Quota  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_resource_quota_api_v2_resource_quotas_resource_quota_id_patch(resource_quota_id, update_resource_quota, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_quota_id: (required)
        :param UpdateResourceQuota update_resource_quota: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourcequotaResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_resource_quota_api_v2_resource_quotas_resource_quota_id_patch_with_http_info(resource_quota_id, update_resource_quota, **kwargs)  # noqa: E501

    def update_resource_quota_api_v2_resource_quotas_resource_quota_id_patch_with_http_info(self, resource_quota_id, update_resource_quota, **kwargs):  # noqa: E501
        """Update Resource Quota  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_resource_quota_api_v2_resource_quotas_resource_quota_id_patch_with_http_info(resource_quota_id, update_resource_quota, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_quota_id: (required)
        :param UpdateResourceQuota update_resource_quota: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourcequotaResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resource_quota_id',
            'update_resource_quota'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_resource_quota_api_v2_resource_quotas_resource_quota_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_quota_id' is set
        if self.api_client.client_side_validation and ('resource_quota_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['resource_quota_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_quota_id` when calling `update_resource_quota_api_v2_resource_quotas_resource_quota_id_patch`")  # noqa: E501
        # verify the required parameter 'update_resource_quota' is set
        if self.api_client.client_side_validation and ('update_resource_quota' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_resource_quota'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_resource_quota` when calling `update_resource_quota_api_v2_resource_quotas_resource_quota_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_quota_id' in local_var_params:
            path_params['resource_quota_id'] = local_var_params['resource_quota_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_resource_quota' in local_var_params:
            body_params = local_var_params['update_resource_quota']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/resource_quotas/{resource_quota_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourcequotaResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_system_cluster_config_api_v2_clouds_cloud_id_update_system_cluster_config_put(self, cloud_id, **kwargs):  # noqa: E501
        """Update System Cluster Config  # noqa: E501

        Update system cluster configuration for a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_system_cluster_config_api_v2_clouds_cloud_id_update_system_cluster_config_put(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool is_enabled:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_system_cluster_config_api_v2_clouds_cloud_id_update_system_cluster_config_put_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def update_system_cluster_config_api_v2_clouds_cloud_id_update_system_cluster_config_put_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Update System Cluster Config  # noqa: E501

        Update system cluster configuration for a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_system_cluster_config_api_v2_clouds_cloud_id_update_system_cluster_config_put_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool is_enabled:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'is_enabled'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_system_cluster_config_api_v2_clouds_cloud_id_update_system_cluster_config_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_system_cluster_config_api_v2_clouds_cloud_id_update_system_cluster_config_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'is_enabled' in local_var_params and local_var_params['is_enabled'] is not None:  # noqa: E501
            query_params.append(('is_enabled', local_var_params['is_enabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/update_system_cluster_config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_template_api_v2_workspace_templates_template_id_put(self, template_id, update_workspace_template, **kwargs):  # noqa: E501
        """Update Template  # noqa: E501

        Update a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_template_api_v2_workspace_templates_template_id_put(template_id, update_workspace_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param UpdateWorkspaceTemplate update_workspace_template: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_template_api_v2_workspace_templates_template_id_put_with_http_info(template_id, update_workspace_template, **kwargs)  # noqa: E501

    def update_template_api_v2_workspace_templates_template_id_put_with_http_info(self, template_id, update_workspace_template, **kwargs):  # noqa: E501
        """Update Template  # noqa: E501

        Update a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_template_api_v2_workspace_templates_template_id_put_with_http_info(template_id, update_workspace_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param UpdateWorkspaceTemplate update_workspace_template: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id',
            'update_workspace_template'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_template_api_v2_workspace_templates_template_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `update_template_api_v2_workspace_templates_template_id_put`")  # noqa: E501
        # verify the required parameter 'update_workspace_template' is set
        if self.api_client.client_side_validation and ('update_workspace_template' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_workspace_template'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_workspace_template` when calling `update_template_api_v2_workspace_templates_template_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_workspace_template' in local_var_params:
            body_params = local_var_params['update_workspace_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workspace_templates/{template_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upgrade_multi_version_weights_api_v2_services_v2_service_id_update_weights_put(self, service_id, apply_multi_version_update_weights_update_model, **kwargs):  # noqa: E501
        """Upgrade Multi Version Weights  # noqa: E501

        Upgrade the weights of multiple service versions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_multi_version_weights_api_v2_services_v2_service_id_update_weights_put(service_id, apply_multi_version_update_weights_update_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param ApplyMultiVersionUpdateWeightsUpdateModel apply_multi_version_update_weights_update_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upgrade_multi_version_weights_api_v2_services_v2_service_id_update_weights_put_with_http_info(service_id, apply_multi_version_update_weights_update_model, **kwargs)  # noqa: E501

    def upgrade_multi_version_weights_api_v2_services_v2_service_id_update_weights_put_with_http_info(self, service_id, apply_multi_version_update_weights_update_model, **kwargs):  # noqa: E501
        """Upgrade Multi Version Weights  # noqa: E501

        Upgrade the weights of multiple service versions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upgrade_multi_version_weights_api_v2_services_v2_service_id_update_weights_put_with_http_info(service_id, apply_multi_version_update_weights_update_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param ApplyMultiVersionUpdateWeightsUpdateModel apply_multi_version_update_weights_update_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'apply_multi_version_update_weights_update_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upgrade_multi_version_weights_api_v2_services_v2_service_id_update_weights_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `upgrade_multi_version_weights_api_v2_services_v2_service_id_update_weights_put`")  # noqa: E501
        # verify the required parameter 'apply_multi_version_update_weights_update_model' is set
        if self.api_client.client_side_validation and ('apply_multi_version_update_weights_update_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['apply_multi_version_update_weights_update_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `apply_multi_version_update_weights_update_model` when calling `upgrade_multi_version_weights_api_v2_services_v2_service_id_update_weights_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'apply_multi_version_update_weights_update_model' in local_var_params:
            body_params = local_var_params['apply_multi_version_update_weights_update_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/update_weights', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post(self, session_command_id, **kwargs):  # noqa: E501
        """Upload Session Command Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post(session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadsessioncommandlogslocationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post_with_http_info(session_command_id, **kwargs)  # noqa: E501

    def upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post_with_http_info(self, session_command_id, **kwargs):  # noqa: E501
        """Upload Session Command Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post_with_http_info(session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadsessioncommandlogslocationsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_command_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/{session_command_id}/upload_logs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadsessioncommandlogslocationsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_billing_version_api_v2_organization_billing_billing_versions_put(self, create_billing_version, **kwargs):  # noqa: E501
        """Upsert Billing Version  # noqa: E501

        Upsert a billing version record for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_billing_version_api_v2_organization_billing_billing_versions_put(create_billing_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBillingVersion create_billing_version: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upsert_billing_version_api_v2_organization_billing_billing_versions_put_with_http_info(create_billing_version, **kwargs)  # noqa: E501

    def upsert_billing_version_api_v2_organization_billing_billing_versions_put_with_http_info(self, create_billing_version, **kwargs):  # noqa: E501
        """Upsert Billing Version  # noqa: E501

        Upsert a billing version record for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_billing_version_api_v2_organization_billing_billing_versions_put_with_http_info(create_billing_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBillingVersion create_billing_version: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_billing_version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_billing_version_api_v2_organization_billing_billing_versions_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_billing_version' is set
        if self.api_client.client_side_validation and ('create_billing_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_billing_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_billing_version` when calling `upsert_billing_version_api_v2_organization_billing_billing_versions_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_billing_version' in local_var_params:
            body_params = local_var_params['create_billing_version']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/billing_versions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_resource_tags_api_v2_tags_resource_put(self, upsert_resource_tags_request, **kwargs):  # noqa: E501
        """Upsert Resource Tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_resource_tags_api_v2_tags_resource_put(upsert_resource_tags_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpsertResourceTagsRequest upsert_resource_tags_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upsert_resource_tags_api_v2_tags_resource_put_with_http_info(upsert_resource_tags_request, **kwargs)  # noqa: E501

    def upsert_resource_tags_api_v2_tags_resource_put_with_http_info(self, upsert_resource_tags_request, **kwargs):  # noqa: E501
        """Upsert Resource Tags  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_resource_tags_api_v2_tags_resource_put_with_http_info(upsert_resource_tags_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpsertResourceTagsRequest upsert_resource_tags_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'upsert_resource_tags_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_resource_tags_api_v2_tags_resource_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'upsert_resource_tags_request' is set
        if self.api_client.client_side_validation and ('upsert_resource_tags_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['upsert_resource_tags_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `upsert_resource_tags_request` when calling `upsert_resource_tags_api_v2_tags_resource_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'upsert_resource_tags_request' in local_var_params:
            body_params = local_var_params['upsert_resource_tags_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/tags/resource', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put(self, write_support_request, **kwargs):  # noqa: E501
        """Upsert Support Request For User Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put(write_support_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteSupportRequest write_support_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put_with_http_info(write_support_request, **kwargs)  # noqa: E501

    def upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put_with_http_info(self, write_support_request, **kwargs):  # noqa: E501
        """Upsert Support Request For User Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put_with_http_info(write_support_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteSupportRequest write_support_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'write_support_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'write_support_request' is set
        if self.api_client.client_side_validation and ('write_support_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['write_support_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `write_support_request` when calling `upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'write_support_request' in local_var_params:
            body_params = local_var_params['write_support_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/support_requests/support_request', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def use_workos_api_v2_workos_use_workos_get(self, **kwargs):  # noqa: E501
        """Use Workos  # noqa: E501

        Determine whether to use WorkOS based on the user's IP address. This endpoint evaluates the WorkOS feature flag server-side using the client's IP address for targeting. This allows for IP-based rollouts and geographic targeting of the WorkOS authentication flow. Returns:     UseWorkOSResponse: Contains boolean indicating whether WorkOS should be enabled  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.use_workos_api_v2_workos_use_workos_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UseworkosresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.use_workos_api_v2_workos_use_workos_get_with_http_info(**kwargs)  # noqa: E501

    def use_workos_api_v2_workos_use_workos_get_with_http_info(self, **kwargs):  # noqa: E501
        """Use Workos  # noqa: E501

        Determine whether to use WorkOS based on the user's IP address. This endpoint evaluates the WorkOS feature flag server-side using the client's IP address for targeting. This allows for IP-based rollouts and geographic targeting of the WorkOS authentication flow. Returns:     UseWorkOSResponse: Contains boolean indicating whether WorkOS should be enabled  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.use_workos_api_v2_workos_use_workos_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UseworkosresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method use_workos_api_v2_workos_use_workos_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workos/use_workos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UseworkosresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_resend_email_api_v2_users_resend_email_post(self, user_resend_email_options, **kwargs):  # noqa: E501
        """User Resend Email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_resend_email_api_v2_users_resend_email_post(user_resend_email_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UserResendEmailOptions user_resend_email_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.user_resend_email_api_v2_users_resend_email_post_with_http_info(user_resend_email_options, **kwargs)  # noqa: E501

    def user_resend_email_api_v2_users_resend_email_post_with_http_info(self, user_resend_email_options, **kwargs):  # noqa: E501
        """User Resend Email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_resend_email_api_v2_users_resend_email_post_with_http_info(user_resend_email_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UserResendEmailOptions user_resend_email_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_resend_email_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_resend_email_api_v2_users_resend_email_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_resend_email_options' is set
        if self.api_client.client_side_validation and ('user_resend_email_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_resend_email_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_resend_email_options` when calling `user_resend_email_api_v2_users_resend_email_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_resend_email_options' in local_var_params:
            body_params = local_var_params['user_resend_email_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/resend_email', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_verify_api_v2_users_verify_token_get(self, token, **kwargs):  # noqa: E501
        """User Verify  # noqa: E501

        Endpoint for verifying user emails.  This API response will contain appropriate cookies to log in the user if the user was previously unverified (first time logging in). Note: This endpoint is not meant to replace the login endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_verify_api_v2_users_verify_token_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.user_verify_api_v2_users_verify_token_get_with_http_info(token, **kwargs)  # noqa: E501

    def user_verify_api_v2_users_verify_token_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """User Verify  # noqa: E501

        Endpoint for verifying user emails.  This API response will contain appropriate cookies to log in the user if the user was previously unverified (first time logging in). Note: This endpoint is not meant to replace the login endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_verify_api_v2_users_verify_token_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_verify_api_v2_users_verify_token_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `user_verify_api_v2_users_verify_token_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/verify/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_api_v2_authentication_validate_post(self, raw_token, **kwargs):  # noqa: E501
        """Validate  # noqa: E501

        For a cluster access token 1. Check if the token is valid (not expired, not revoked) 2. Check if the user has permissions to access the cluster 3. Audit log the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_api_v2_authentication_validate_post(raw_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str raw_token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_api_v2_authentication_validate_post_with_http_info(raw_token, **kwargs)  # noqa: E501

    def validate_api_v2_authentication_validate_post_with_http_info(self, raw_token, **kwargs):  # noqa: E501
        """Validate  # noqa: E501

        For a cluster access token 1. Check if the token is valid (not expired, not revoked) 2. Check if the user has permissions to access the cluster 3. Audit log the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_api_v2_authentication_validate_post_with_http_info(raw_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str raw_token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'raw_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_api_v2_authentication_validate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'raw_token' is set
        if self.api_client.client_side_validation and ('raw_token' not in local_var_params or  # noqa: E501
                                                        local_var_params['raw_token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `raw_token` when calling `validate_api_v2_authentication_validate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'raw_token' in local_var_params and local_var_params['raw_token'] is not None:  # noqa: E501
            query_params.append(('raw_token', local_var_params['raw_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authentication/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_invite_code_api_v2_users_validate_invite_code_invite_code_post(self, invite_code, **kwargs):  # noqa: E501
        """Validate Invite Code  # noqa: E501

        Endpoint for verifying user invite codes. Successful if the invite code is valid or if invite codes are not required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_invite_code_api_v2_users_validate_invite_code_invite_code_post(invite_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invite_code: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_invite_code_api_v2_users_validate_invite_code_invite_code_post_with_http_info(invite_code, **kwargs)  # noqa: E501

    def validate_invite_code_api_v2_users_validate_invite_code_invite_code_post_with_http_info(self, invite_code, **kwargs):  # noqa: E501
        """Validate Invite Code  # noqa: E501

        Endpoint for verifying user invite codes. Successful if the invite code is valid or if invite codes are not required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_invite_code_api_v2_users_validate_invite_code_invite_code_post_with_http_info(invite_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invite_code: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'invite_code'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_invite_code_api_v2_users_validate_invite_code_invite_code_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invite_code' is set
        if self.api_client.client_side_validation and ('invite_code' not in local_var_params or  # noqa: E501
                                                        local_var_params['invite_code'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `invite_code` when calling `validate_invite_code_api_v2_users_validate_invite_code_invite_code_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invite_code' in local_var_params:
            path_params['invite_code'] = local_var_params['invite_code']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/validate_invite_code/{invite_code}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_one_time_password_api_v2_users_validate_otp_token_post(self, validate_otp_params_api_model, **kwargs):  # noqa: E501
        """Validate One Time Password  # noqa: E501

        Validate the one-time password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_one_time_password_api_v2_users_validate_otp_token_post(validate_otp_params_api_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ValidateOTPParamsApiModel validate_otp_params_api_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_one_time_password_api_v2_users_validate_otp_token_post_with_http_info(validate_otp_params_api_model, **kwargs)  # noqa: E501

    def validate_one_time_password_api_v2_users_validate_otp_token_post_with_http_info(self, validate_otp_params_api_model, **kwargs):  # noqa: E501
        """Validate One Time Password  # noqa: E501

        Validate the one-time password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_one_time_password_api_v2_users_validate_otp_token_post_with_http_info(validate_otp_params_api_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ValidateOTPParamsApiModel validate_otp_params_api_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'validate_otp_params_api_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_one_time_password_api_v2_users_validate_otp_token_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'validate_otp_params_api_model' is set
        if self.api_client.client_side_validation and ('validate_otp_params_api_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['validate_otp_params_api_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `validate_otp_params_api_model` when calling `validate_one_time_password_api_v2_users_validate_otp_token_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'validate_otp_params_api_model' in local_var_params:
            body_params = local_var_params['validate_otp_params_api_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/validate_otp_token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_access_api_v2_cloudsverify_access_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Verify Access  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_access_api_v2_cloudsverify_access_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_access_api_v2_cloudsverify_access_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def verify_access_api_v2_cloudsverify_access_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Verify Access  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_access_api_v2_cloudsverify_access_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_access_api_v2_cloudsverify_access_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `verify_access_api_v2_cloudsverify_access_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cloudsverify_access/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_reset_password_token_api_v2_users_reset_password_token_get(self, token, **kwargs):  # noqa: E501
        """Verify Reset Password Token  # noqa: E501

        Verifies that the specified token is a valid, non-expired password reset token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_reset_password_token_api_v2_users_reset_password_token_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_reset_password_token_api_v2_users_reset_password_token_get_with_http_info(token, **kwargs)  # noqa: E501

    def verify_reset_password_token_api_v2_users_reset_password_token_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """Verify Reset Password Token  # noqa: E501

        Verifies that the specified token is a valid, non-expired password reset token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_reset_password_token_api_v2_users_reset_password_token_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_reset_password_token_api_v2_users_reset_password_token_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `verify_reset_password_token_api_v2_users_reset_password_token_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/reset_password/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def workos_callback_api_v2_workos_callback_get(self, code, **kwargs):  # noqa: E501
        """Workos Callback  # noqa: E501

        Callback for WorkOS authentication. WorkOS will call this endpoint with a code after the user authenticates with WorkOS.  We use the code to get the user's information from WorkOS and then authenticate the user with Anyscale.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.workos_callback_api_v2_workos_callback_get(code, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str code: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.workos_callback_api_v2_workos_callback_get_with_http_info(code, **kwargs)  # noqa: E501

    def workos_callback_api_v2_workos_callback_get_with_http_info(self, code, **kwargs):  # noqa: E501
        """Workos Callback  # noqa: E501

        Callback for WorkOS authentication. WorkOS will call this endpoint with a code after the user authenticates with WorkOS.  We use the code to get the user's information from WorkOS and then authenticate the user with Anyscale.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.workos_callback_api_v2_workos_callback_get_with_http_info(code, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str code: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'code'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workos_callback_api_v2_workos_callback_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'code' is set
        if self.api_client.client_side_validation and ('code' not in local_var_params or  # noqa: E501
                                                        local_var_params['code'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `code` when calling `workos_callback_api_v2_workos_callback_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'code' in local_var_params and local_var_params['code'] is not None:  # noqa: E501
            query_params.append(('code', local_var_params['code']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workos/callback', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def workos_verify_email_code_api_v2_workos_email_verification_verify_post(self, email_verification_request, **kwargs):  # noqa: E501
        """Workos Verify Email Code  # noqa: E501

        Verify email with a 6-digit code sent by WorkOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.workos_verify_email_code_api_v2_workos_email_verification_verify_post(email_verification_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param EmailVerificationRequest email_verification_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmailverificationresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.workos_verify_email_code_api_v2_workos_email_verification_verify_post_with_http_info(email_verification_request, **kwargs)  # noqa: E501

    def workos_verify_email_code_api_v2_workos_email_verification_verify_post_with_http_info(self, email_verification_request, **kwargs):  # noqa: E501
        """Workos Verify Email Code  # noqa: E501

        Verify email with a 6-digit code sent by WorkOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.workos_verify_email_code_api_v2_workos_email_verification_verify_post_with_http_info(email_verification_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param EmailVerificationRequest email_verification_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmailverificationresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email_verification_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workos_verify_email_code_api_v2_workos_email_verification_verify_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_verification_request' is set
        if self.api_client.client_side_validation and ('email_verification_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['email_verification_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email_verification_request` when calling `workos_verify_email_code_api_v2_workos_email_verification_verify_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'email_verification_request' in local_var_params:
            body_params = local_var_params['email_verification_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/workos/email_verification/verify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmailverificationresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
