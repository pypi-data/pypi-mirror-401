# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.bad_request import BadRequest
from ..types.forbidden import Forbidden
from ..types.include_total_count import IncludeTotalCount
from ..types.not_found import NotFound
from ..types.request_after_opaque_cursor import RequestAfterOpaqueCursor
from ..types.request_page_size import RequestPageSize
from ..types.too_many_requests import TooManyRequests
from ..types.unauthorized import Unauthorized
from ..types.update_user_roles_params_data import UpdateUserRolesParamsData
from ..types.update_user_roles_response import UpdateUserRolesResponse
from ..types.user_role import UserRole
from ..types.user_roles_response import UserRolesResponse
from ..types.uuid_ import Uuid

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawProjectPermissionsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def index(
        self,
        account_id: Uuid,
        project_id: Uuid,
        *,
        include_deactivated: typing.Optional[bool] = None,
        after: typing.Optional[RequestAfterOpaqueCursor] = None,
        page_size: typing.Optional[RequestPageSize] = None,
        include_total_count: typing.Optional[IncludeTotalCount] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[UserRole, UserRolesResponse]:
        """
        List user roles for a given project. <br>Rate Limits: 100 calls per 1.00 minute(s) per account_user

        Parameters
        ----------
        account_id : Uuid


        project_id : Uuid


        include_deactivated : typing.Optional[bool]
            Supports including deactivated users in the response. Default is false.

        after : typing.Optional[RequestAfterOpaqueCursor]
            Opaque Cursor query param for requests returning paginated results.
            <br/>
            NOTE: this value is auto-generated and included as part of links from a previous response. It is not intended to be human readable.

        page_size : typing.Optional[RequestPageSize]


        include_total_count : typing.Optional[IncludeTotalCount]


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[UserRole, UserRolesResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v4/accounts/{jsonable_encoder(account_id)}/projects/{jsonable_encoder(project_id)}/users",
            method="GET",
            params={
                "include_deactivated": include_deactivated,
                "after": after,
                "page_size": page_size,
                "include_total_count": include_total_count,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    UserRolesResponse,
                    construct_type(
                        type_=UserRolesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.data
                _has_next = False
                _get_next = None
                if _parsed_response.links is not None:
                    _parsed_next = _parsed_response.links.next
                    _has_next = _parsed_next is not None and _parsed_next != ""
                    _get_next = lambda: self.index(
                        account_id,
                        project_id,
                        include_deactivated=include_deactivated,
                        after=_parsed_next,
                        page_size=page_size,
                        include_total_count=include_total_count,
                        request_options=request_options,
                    )
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next, response=_parsed_response)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Unauthorized,
                        construct_type(
                            type_=Unauthorized,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Forbidden,
                        construct_type(
                            type_=Forbidden,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFound,
                        construct_type(
                            type_=NotFound,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        TooManyRequests,
                        construct_type(
                            type_=TooManyRequests,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        account_id: Uuid,
        project_id: Uuid,
        user_id: Uuid,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Remove a user from a given project. <br>Rate Limits: 60 calls per 1.00 minute(s) per account_user

        Parameters
        ----------
        account_id : Uuid


        project_id : Uuid


        user_id : Uuid


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v4/accounts/{jsonable_encoder(account_id)}/projects/{jsonable_encoder(project_id)}/users/{jsonable_encoder(user_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Unauthorized,
                        construct_type(
                            type_=Unauthorized,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Forbidden,
                        construct_type(
                            type_=Forbidden,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFound,
                        construct_type(
                            type_=NotFound,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        TooManyRequests,
                        construct_type(
                            type_=TooManyRequests,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def project_user_roles_update(
        self,
        account_id: Uuid,
        project_id: Uuid,
        user_id: Uuid,
        *,
        data: UpdateUserRolesParamsData,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateUserRolesResponse]:
        """
        Update user roles for the given project if the user is already added to the project. If the user is
            not added to the project, the user will be added with the given role. <br>Rate Limits: 10 calls per 1.00 minute(s) per account_user

        Parameters
        ----------
        account_id : Uuid


        project_id : Uuid


        user_id : Uuid


        data : UpdateUserRolesParamsData

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateUserRolesResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v4/accounts/{jsonable_encoder(account_id)}/projects/{jsonable_encoder(project_id)}/users/{jsonable_encoder(user_id)}",
            method="PATCH",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=UpdateUserRolesParamsData, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateUserRolesResponse,
                    construct_type(
                        type_=UpdateUserRolesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Unauthorized,
                        construct_type(
                            type_=Unauthorized,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Forbidden,
                        construct_type(
                            type_=Forbidden,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFound,
                        construct_type(
                            type_=NotFound,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        TooManyRequests,
                        construct_type(
                            type_=TooManyRequests,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawProjectPermissionsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def index(
        self,
        account_id: Uuid,
        project_id: Uuid,
        *,
        include_deactivated: typing.Optional[bool] = None,
        after: typing.Optional[RequestAfterOpaqueCursor] = None,
        page_size: typing.Optional[RequestPageSize] = None,
        include_total_count: typing.Optional[IncludeTotalCount] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[UserRole, UserRolesResponse]:
        """
        List user roles for a given project. <br>Rate Limits: 100 calls per 1.00 minute(s) per account_user

        Parameters
        ----------
        account_id : Uuid


        project_id : Uuid


        include_deactivated : typing.Optional[bool]
            Supports including deactivated users in the response. Default is false.

        after : typing.Optional[RequestAfterOpaqueCursor]
            Opaque Cursor query param for requests returning paginated results.
            <br/>
            NOTE: this value is auto-generated and included as part of links from a previous response. It is not intended to be human readable.

        page_size : typing.Optional[RequestPageSize]


        include_total_count : typing.Optional[IncludeTotalCount]


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[UserRole, UserRolesResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v4/accounts/{jsonable_encoder(account_id)}/projects/{jsonable_encoder(project_id)}/users",
            method="GET",
            params={
                "include_deactivated": include_deactivated,
                "after": after,
                "page_size": page_size,
                "include_total_count": include_total_count,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    UserRolesResponse,
                    construct_type(
                        type_=UserRolesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.data
                _has_next = False
                _get_next = None
                if _parsed_response.links is not None:
                    _parsed_next = _parsed_response.links.next
                    _has_next = _parsed_next is not None and _parsed_next != ""

                    async def _get_next():
                        return await self.index(
                            account_id,
                            project_id,
                            include_deactivated=include_deactivated,
                            after=_parsed_next,
                            page_size=page_size,
                            include_total_count=include_total_count,
                            request_options=request_options,
                        )

                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next, response=_parsed_response)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Unauthorized,
                        construct_type(
                            type_=Unauthorized,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Forbidden,
                        construct_type(
                            type_=Forbidden,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFound,
                        construct_type(
                            type_=NotFound,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        TooManyRequests,
                        construct_type(
                            type_=TooManyRequests,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        account_id: Uuid,
        project_id: Uuid,
        user_id: Uuid,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Remove a user from a given project. <br>Rate Limits: 60 calls per 1.00 minute(s) per account_user

        Parameters
        ----------
        account_id : Uuid


        project_id : Uuid


        user_id : Uuid


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v4/accounts/{jsonable_encoder(account_id)}/projects/{jsonable_encoder(project_id)}/users/{jsonable_encoder(user_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Unauthorized,
                        construct_type(
                            type_=Unauthorized,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Forbidden,
                        construct_type(
                            type_=Forbidden,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFound,
                        construct_type(
                            type_=NotFound,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        TooManyRequests,
                        construct_type(
                            type_=TooManyRequests,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def project_user_roles_update(
        self,
        account_id: Uuid,
        project_id: Uuid,
        user_id: Uuid,
        *,
        data: UpdateUserRolesParamsData,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateUserRolesResponse]:
        """
        Update user roles for the given project if the user is already added to the project. If the user is
            not added to the project, the user will be added with the given role. <br>Rate Limits: 10 calls per 1.00 minute(s) per account_user

        Parameters
        ----------
        account_id : Uuid


        project_id : Uuid


        user_id : Uuid


        data : UpdateUserRolesParamsData

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateUserRolesResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v4/accounts/{jsonable_encoder(account_id)}/projects/{jsonable_encoder(project_id)}/users/{jsonable_encoder(user_id)}",
            method="PATCH",
            json={
                "data": convert_and_respect_annotation_metadata(
                    object_=data, annotation=UpdateUserRolesParamsData, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateUserRolesResponse,
                    construct_type(
                        type_=UpdateUserRolesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        BadRequest,
                        construct_type(
                            type_=BadRequest,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Unauthorized,
                        construct_type(
                            type_=Unauthorized,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Forbidden,
                        construct_type(
                            type_=Forbidden,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        NotFound,
                        construct_type(
                            type_=NotFound,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        TooManyRequests,
                        construct_type(
                            type_=TooManyRequests,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
