"""Common encryption and decryption operations

This module provides cryptographic functions for hashing, symmetric encryption,
and decryption using various algorithms including AES, DES, 3DES, and RC4.

Examples:
    >>> from exploit_utils.crypto import md5, aes, aes_d, AESMode
    >>> # Hash functions
    >>> md5("hello")
    '5d41402abc4b2a76b9719d911017c592'
    >>> # AES encryption/decryption
    >>> key = b'0123456789abcdef'
    >>> iv = b'1234567890abcdef'
    >>> encrypted = aes("Hello World!", key, AESMode.CBC, iv)
    >>> decrypted = aes_d(encrypted, key, AESMode.CBC, iv)
    >>> decrypted.decode()
    'Hello World!'
    >>> # DES encryption
    >>> from exploit_utils.crypto import des, des_d, DESMode
    >>> des_key = b'8bytekey'
    >>> des_iv = b'8byteiv!'
    >>> encrypted = des("Secret", des_key, DESMode.CBC, des_iv)
    >>> decrypted = des_d(encrypted, des_key, DESMode.CBC, des_iv)
    >>> decrypted.decode()
    'Secret'
"""

import hashlib
from typing import Union

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.decrepit.ciphers.algorithms import ARC4, TripleDES
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

__all__ = [
    "aes",
    "aes_d",
    "des",
    "des_d",
    "des3",
    "des3_d",
    "AESMode",
    "DESMode",
    "md5",
    "sha1",
    "sha256",
    "sha512",
    "rc4",
    "rc4_d",
]


class AESMode:
    """AES encryption modes

    Examples:
        >>> AESMode.ECB
        'ECB'
        >>> AESMode.CBC
        'CBC'
        >>> AESMode.GCM
        'GCM'
    """

    ECB = "ECB"
    CBC = "CBC"
    CFB = "CFB"
    OFB = "OFB"
    CTR = "CTR"
    GCM = "GCM"


class DESMode:
    """DES encryption modes

    Examples:
        >>> DESMode.ECB
        'ECB'
        >>> DESMode.CBC
        'CBC'
        >>> DESMode.CTR
        'CTR'
    """

    ECB = "ECB"
    CBC = "CBC"
    CFB = "CFB"
    OFB = "OFB"
    CTR = "CTR"


def md5(message: str, encoding: str = "utf-8") -> str:
    """MD5 hash

    Args:
        message: String to hash
        encoding: String encoding

    Returns:
        MD5 hash as hexadecimal string

    Examples:
        >>> md5("hello")
        '5d41402abc4b2a76b9719d911017c592'
        >>> md5("test")
        '098f6bcd4621d373cade4e832627b4f6'
        >>> md5("")
        'd41d8cd98f00b204e9800998ecf8427e'
    """
    return hashlib.md5(message.encode(encoding)).hexdigest()


def sha1(message: str, encoding: str = "utf-8") -> str:
    """SHA1 hash

    Args:
        message: String to hash
        encoding: String encoding

    Returns:
        SHA1 hash as hexadecimal string

    Examples:
        >>> sha1("hello")
        'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d'
        >>> sha1("test")
        'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3'
        >>> sha1("")
        'da39a3ee5e6b4b0d3255bfef95601890afd80709'
    """
    return hashlib.sha1(message.encode(encoding)).hexdigest()


def sha256(message: str, encoding: str = "utf-8") -> str:
    """SHA256 hash

    Args:
        message: String to hash
        encoding: String encoding

    Returns:
        SHA256 hash as hexadecimal string

    Examples:
        >>> sha256("hello")
        '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824'
        >>> sha256("test")
        '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08'
        >>> sha256("")
        'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
    """
    return hashlib.sha256(message.encode(encoding)).hexdigest()


def sha512(message: str, encoding: str = "utf-8") -> str:
    """SHA512 hash

    Args:
        message: String to hash
        encoding: String encoding

    Returns:
        SHA512 hash as hexadecimal string

    Examples:
        >>> sha512("hello")
        '9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043'
        >>> sha512("test")
        'ee26b0dd4af7e749aa1a8ee3c10ae9923f618980772e473f8819a5d4940e0db27ac185f8a0e1d5f84f88bc887fd67b143732c304cc5fa9ad8e6f57f50028a8ff'
        >>> sha512("")
        'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'
    """
    return hashlib.sha512(message.encode(encoding)).hexdigest()


def _get_cipher_mode(mode_name: str, iv: bytes | None = None):
    """Get cryptography mode object from mode name"""
    if mode_name == AESMode.ECB or mode_name == DESMode.ECB:
        return modes.ECB()
    elif mode_name == AESMode.CBC or mode_name == DESMode.CBC:
        if not iv:
            raise ValueError("IV required for CBC mode")
        return modes.CBC(iv)
    elif mode_name == AESMode.CFB or mode_name == DESMode.CFB:
        if not iv:
            raise ValueError("IV required for CFB mode")
        return modes.CFB(iv)
    elif mode_name == AESMode.OFB or mode_name == DESMode.OFB:
        if not iv:
            raise ValueError("IV required for OFB mode")
        return modes.OFB(iv)
    elif mode_name == AESMode.CTR or mode_name == DESMode.CTR:
        if not iv:
            raise ValueError("Nonce required for CTR mode")
        return modes.CTR(iv)
    elif mode_name == AESMode.GCM:
        if not iv:
            raise ValueError("IV required for GCM mode")
        return modes.GCM(iv)
    else:
        raise ValueError(f"Unsupported mode: {mode_name}")


def _apply_padding(data: bytes, block_size: int, mode_name: str) -> bytes:
    """Apply padding to data if needed"""
    # ECB and CBC modes require padding
    if mode_name in [AESMode.ECB, AESMode.CBC, DESMode.ECB, DESMode.CBC]:
        padder = padding.PKCS7(block_size * 8).padder()
        return padder.update(data) + padder.finalize()
    return data


def _remove_padding(data: bytes, block_size: int, mode_name: str) -> bytes:
    """Remove padding from data if needed"""
    # ECB and CBC modes have padding
    if mode_name in [AESMode.ECB, AESMode.CBC, DESMode.ECB, DESMode.CBC]:
        unpadder = padding.PKCS7(block_size * 8).unpadder()
        return unpadder.update(data) + unpadder.finalize()
    return data


def aes(
    data: Union[str, bytes],
    key: Union[str, bytes],
    mode: str = AESMode.CBC,
    iv: bytes | None = None,
    encoding: str = "utf-8",
) -> bytes:
    """
    AES encryption

    Args:
        data: Data to encrypt (string or bytes)
        key: Encryption key (string or bytes)
        mode: Encryption mode (from AESMode class)
        iv: Initialization vector (required for some modes)
        encoding: String encoding (used if data/key are strings)

    Returns:
        Encrypted bytes

    Examples:
        >>> key = b'0123456789abcdef'  # 16 bytes
        >>> iv = b'1234567890abcdef'   # 16 bytes
        >>> encrypted = aes("Hello AES!", key, AESMode.CBC, iv)
        >>> len(encrypted) == 16  # Padded to block size
        True

        >>> # AES ECB mode (no IV needed)
        >>> encrypted_ecb = aes("test", key, AESMode.ECB)
        >>> len(encrypted_ecb) == 16
        True

        >>> # String key and data
        >>> encrypted_str = aes("secret", "0123456789abcdef", AESMode.CBC, iv)
        >>> len(encrypted_str) == 16
        True

        >>> # Error handling - invalid key length
        >>> try:
        ...     aes("test", b'short', AESMode.CBC, iv)
        ... except ValueError as e:
        ...     print(str(e))
        AES key must be 16, 24, or 32 bytes long

        >>> # Error handling - missing IV for CBC
        >>> try:
        ...     aes("test", key, AESMode.CBC)
        ... except ValueError as e:
        ...     print(str(e))
        IV required for CBC mode
    """
    # Convert inputs to bytes if needed
    if isinstance(data, str):
        data = data.encode(encoding)
    if isinstance(key, str):
        key = key.encode(encoding)

    # Validate key length
    if len(key) not in [16, 24, 32]:
        raise ValueError("AES key must be 16, 24, or 32 bytes long")

    # Get mode object
    mode_obj = _get_cipher_mode(mode, iv)

    # Apply padding if needed
    padded_data = _apply_padding(data, 16, mode)

    # Create cipher and encrypt
    cipher = Cipher(algorithms.AES(key), mode_obj, backend=default_backend())
    encryptor = cipher.encryptor()
    return encryptor.update(padded_data) + encryptor.finalize()


def aes_d(
    data: bytes,
    key: Union[str, bytes],
    mode: str = AESMode.CBC,
    iv: bytes | None = None,
    encoding: str = "utf-8",
) -> bytes:
    """
    AES decryption

    Args:
        data: Data to decrypt (bytes)
        key: Decryption key (string or bytes)
        mode: Encryption mode (from AESMode class)
        iv: Initialization vector (required for some modes)
        encoding: String encoding (used if key is string)

    Returns:
        Decrypted bytes

    Examples:
        >>> key = b'0123456789abcdef'
        >>> iv = b'1234567890abcdef'
        >>> original = "Hello AES!"
        >>> encrypted = aes(original, key, AESMode.CBC, iv)
        >>> decrypted = aes_d(encrypted, key, AESMode.CBC, iv)
        >>> decrypted.decode() == original
        True

        >>> # AES ECB mode
        >>> encrypted_ecb = aes("test data", key, AESMode.ECB)
        >>> decrypted_ecb = aes_d(encrypted_ecb, key, AESMode.ECB)
        >>> decrypted_ecb.decode() == "test data"
        True

        >>> # String key
        >>> encrypted = aes("secret", "0123456789abcdef", AESMode.CBC, iv)
        >>> decrypted = aes_d(encrypted, "0123456789abcdef", AESMode.CBC, iv)
        >>> decrypted.decode() == "secret"
        True

        >>> # Different key sizes
        >>> key_256 = b'0123456789abcdef0123456789abcdef'  # 32 bytes
        >>> encrypted = aes("AES-256 test", key_256, AESMode.CBC, iv)
        >>> decrypted = aes_d(encrypted, key_256, AESMode.CBC, iv)
        >>> decrypted.decode() == "AES-256 test"
        True
    """
    # Convert key to bytes if needed
    if isinstance(key, str):
        key = key.encode(encoding)

    # Validate key length
    if len(key) not in [16, 24, 32]:
        raise ValueError("AES key must be 16, 24, or 32 bytes long")

    # Get mode object
    mode_obj = _get_cipher_mode(mode, iv)

    # Create cipher and decrypt
    cipher = Cipher(algorithms.AES(key), mode_obj, backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted = decryptor.update(data) + decryptor.finalize()

    # Remove padding if needed
    return _remove_padding(decrypted, 16, mode)


def des(
    data: Union[str, bytes],
    key: Union[str, bytes],
    mode: str = DESMode.CBC,
    iv: bytes | None = None,
    encoding: str = "utf-8",
) -> bytes:
    """
    DES encryption

    Args:
        data: Data to encrypt (string or bytes)
        key: Encryption key (string or bytes, must be 8 bytes)
        mode: Encryption mode (from DESMode class)
        iv: Initialization vector (required for some modes)
        encoding: String encoding (used if data/key are strings)

    Returns:
        Encrypted bytes

    Examples:
        >>> key = b'8bytekey'  # 8 bytes
        >>> iv = b'8byteiv!'   # 8 bytes
        >>> encrypted = des("Hello DES!", key, DESMode.CBC, iv)
        >>> len(encrypted) == 16  # Padded to block size
        True

        >>> # DES ECB mode
        >>> encrypted_ecb = des("test", key, DESMode.ECB)
        >>> len(encrypted_ecb) == 8
        True

        >>> # String key
        >>> encrypted = des("secret", "8bytekey", DESMode.CBC, iv)
        >>> len(encrypted) == 8
        True

        >>> # Error handling - invalid key length
        >>> try:
        ...     des("test", b'short', DESMode.CBC, iv)
        ... except ValueError as e:
        ...     print(str(e))
        DES key must be 8 bytes long

        >>> try:
        ...     des("test", b'waytoolongkey', DESMode.CBC, iv)
        ... except ValueError as e:
        ...     print(str(e))
        DES key must be 8 bytes long
    """
    # Convert inputs to bytes if needed
    if isinstance(data, str):
        data = data.encode(encoding)
    if isinstance(key, str):
        key = key.encode(encoding)

    # Validate key length
    if len(key) != 8:
        raise ValueError("DES key must be 8 bytes long")

    # Get mode object
    mode_obj = _get_cipher_mode(mode, iv)

    # Apply padding if needed
    padded_data = _apply_padding(data, 8, mode)

    # Create cipher and encrypt
    # TripleDES with 8-byte key effectively works as single DES
    cipher = Cipher(TripleDES(key), mode_obj, backend=default_backend())
    encryptor = cipher.encryptor()
    return encryptor.update(padded_data) + encryptor.finalize()


def des_d(
    data: bytes,
    key: Union[str, bytes],
    mode: str = DESMode.CBC,
    iv: bytes | None = None,
    encoding: str = "utf-8",
) -> bytes:
    """
    DES decryption

    Args:
        data: Data to decrypt (bytes)
        key: Decryption key (string or bytes, must be 8 bytes)
        mode: Encryption mode (from DESMode class)
        iv: Initialization vector (required for some modes)
        encoding: String encoding (used if key is string)

    Returns:
        Decrypted bytes

    Examples:
        >>> key = b'8bytekey'
        >>> iv = b'8byteiv!'
        >>> original = "Hello DES!"
        >>> encrypted = des(original, key, DESMode.CBC, iv)
        >>> decrypted = des_d(encrypted, key, DESMode.CBC, iv)
        >>> decrypted.decode() == original
        True

        >>> # DES ECB mode
        >>> encrypted_ecb = des("test data", key, DESMode.ECB)
        >>> decrypted_ecb = des_d(encrypted_ecb, key, DESMode.ECB)
        >>> decrypted_ecb.decode() == "test data"
        True

        >>> # String key
        >>> encrypted = des("secret", "8bytekey", DESMode.CBC, iv)
        >>> decrypted = des_d(encrypted, "8bytekey", DESMode.CBC, iv)
        >>> decrypted.decode() == "secret"
        True
    """
    # Convert key to bytes if needed
    if isinstance(key, str):
        key = key.encode(encoding)

    # Validate key length
    if len(key) != 8:
        raise ValueError("DES key must be 8 bytes long")

    # Get mode object
    mode_obj = _get_cipher_mode(mode, iv)

    # Create cipher and decrypt
    # TripleDES with 8-byte key effectively works as single DES
    cipher = Cipher(TripleDES(key), mode_obj, backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted = decryptor.update(data) + decryptor.finalize()

    # Remove padding if needed
    return _remove_padding(decrypted, 8, mode)


def des3(
    data: Union[str, bytes],
    key: Union[str, bytes],
    mode: str = DESMode.CBC,
    iv: bytes | None = None,
    encoding: str = "utf-8",
) -> bytes:
    """
    3DES (Triple DES) encryption

    Args:
        data: Data to encrypt (string or bytes)
        key: Encryption key (string or bytes, must be 8, 16, or 24 bytes)
        mode: Encryption mode (from DESMode class)
        iv: Initialization vector (required for some modes)
        encoding: String encoding (used if data/key are strings)

    Returns:
        Encrypted bytes

    Examples:
        >>> key_8 = b'8bytekey'  # 8 bytes
        >>> key_16 = b'16bytekeyfor3des'  # 16 bytes
        >>> key_24 = b'24bytekeyfortripledes123'  # 24 bytes
        >>> iv = b'8byteiv!'  # 8 bytes

        >>> # 8-byte key (effectively single DES)
        >>> encrypted = des3("Hello 3DES!", key_8, DESMode.CBC, iv)
        >>> len(encrypted) == 16
        True

        >>> # 16-byte key
        >>> encrypted = des3("test", key_16, DESMode.CBC, iv)
        >>> len(encrypted) == 8
        True

        >>> # 24-byte key
        >>> encrypted = des3("secret", key_24, DESMode.CBC, iv)
        >>> len(encrypted) == 8
        True

        >>> # String key
        >>> encrypted = des3("data", "8bytekey", DESMode.CBC, iv)
        >>> len(encrypted) == 8
        True

        >>> # Error handling - invalid key length
        >>> try:
        ...     des3("test", b'badlength', DESMode.CBC, iv)
        ... except ValueError as e:
        ...     print(str(e))
        3DES key must be 8, 16, or 24 bytes long
    """
    # Convert inputs to bytes if needed
    if isinstance(data, str):
        data = data.encode(encoding)
    if isinstance(key, str):
        key = key.encode(encoding)

    # Validate key length
    if len(key) not in [8, 16, 24]:
        raise ValueError("3DES key must be 8, 16, or 24 bytes long")

    # Get mode object
    mode_obj = _get_cipher_mode(mode, iv)

    # Apply padding if needed
    padded_data = _apply_padding(data, 8, mode)

    # Create cipher and encrypt
    cipher = Cipher(TripleDES(key), mode_obj, backend=default_backend())
    encryptor = cipher.encryptor()
    return encryptor.update(padded_data) + encryptor.finalize()


def des3_d(
    data: bytes,
    key: Union[str, bytes],
    mode: str = DESMode.CBC,
    iv: bytes | None = None,
    encoding: str = "utf-8",
) -> bytes:
    """
    3DES (Triple DES) decryption

    Args:
        data: Data to decrypt (bytes)
        key: Decryption key (string or bytes, must be 8, 16, or 24 bytes)
        mode: Encryption mode (from DESMode class)
        iv: Initialization vector (required for some modes)
        encoding: String encoding (used if key is string)

    Returns:
        Decrypted bytes

    Examples:
        >>> key_8 = b'8bytekey'
        >>> key_16 = b'16bytekeyfor3des'
        >>> key_24 = b'24bytekeyfortripledes123'
        >>> iv = b'8byteiv!'

        >>> # 8-byte key
        >>> original = "Hello 3DES!"
        >>> encrypted = des3(original, key_8, DESMode.CBC, iv)
        >>> decrypted = des3_d(encrypted, key_8, DESMode.CBC, iv)
        >>> decrypted.decode() == original
        True

        >>> # 16-byte key
        >>> encrypted = des3("test data", key_16, DESMode.CBC, iv)
        >>> decrypted = des3_d(encrypted, key_16, DESMode.CBC, iv)
        >>> decrypted.decode() == "test data"
        True

        >>> # 24-byte key
        >>> encrypted = des3("secret message", key_24, DESMode.CBC, iv)
        >>> decrypted = des3_d(encrypted, key_24, DESMode.CBC, iv)
        >>> decrypted.decode() == "secret message"
        True

        >>> # String key
        >>> encrypted = des3("data", "8bytekey", DESMode.CBC, iv)
        >>> decrypted = des3_d(encrypted, "8bytekey", DESMode.CBC, iv)
        >>> decrypted.decode() == "data"
        True
    """
    # Convert key to bytes if needed
    if isinstance(key, str):
        key = key.encode(encoding)

    # Validate key length
    if len(key) not in [8, 16, 24]:
        raise ValueError("3DES key must be 8, 16, or 24 bytes long")

    # Get mode object
    mode_obj = _get_cipher_mode(mode, iv)

    # Create cipher and decrypt
    cipher = Cipher(TripleDES(key), mode_obj, backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted = decryptor.update(data) + decryptor.finalize()

    # Remove padding if needed
    return _remove_padding(decrypted, 8, mode)


def rc4(
    message: Union[str, bytes], key: Union[str, bytes], encoding: str = "utf-8"
) -> bytes:
    """
    RC4 encryption

    Args:
        message: Message to encrypt (string or bytes)
        key: Encryption key (string or bytes)
        encoding: String encoding (used if message/key are strings)

    Returns:
        Encrypted bytes

    Examples:
        >>> key = b'8bytekey'  # 8 bytes (valid for RC4)
        >>> encrypted = rc4("Hello RC4!", key)
        >>> len(encrypted) == len("Hello RC4!")
        True

        >>> # String key and message
        >>> encrypted = rc4("secret", "8bytekey")
        >>> len(encrypted) == len("secret")
        True

        >>> # Bytes input
        >>> encrypted = rc4(b"binary data", key)
        >>> len(encrypted) == len(b"binary data")
        True

        >>> # Note: RC4 has key size limitations in cryptography library
        >>> # Valid key sizes are typically 5-16 bytes
        >>> try:
        ...     rc4("test", b'tiny')  # 4 bytes
        ... except ValueError as e:
        ...     "Invalid key size" in str(e)
        True
    """
    # Convert inputs to bytes if needed
    if isinstance(message, str):
        message = message.encode(encoding)
    if isinstance(key, str):
        key = key.encode(encoding)

    # Create cipher and encrypt
    algorithm = ARC4(key)
    cipher = Cipher(algorithm, mode=None, backend=default_backend())
    encryptor = cipher.encryptor()
    return encryptor.update(message) + encryptor.finalize()


def rc4_d(message: bytes, key: Union[str, bytes], encoding: str = "utf-8") -> bytes:
    """
    RC4 decryption (same as encryption for RC4)

    Args:
        message: Message to decrypt (bytes)
        key: Decryption key (string or bytes)
        encoding: String encoding (used if key is string)

    Returns:
        Decrypted bytes

    Examples:
        >>> key = b'8bytekey'
        >>> original = "Hello RC4!"
        >>> encrypted = rc4(original, key)
        >>> decrypted = rc4_d(encrypted, key)
        >>> decrypted.decode() == original
        True

        >>> # String key
        >>> encrypted = rc4("secret message", "8bytekey")
        >>> decrypted = rc4_d(encrypted, "8bytekey")
        >>> decrypted.decode() == "secret message"
        True

        >>> # RC4 is symmetric - encryption and decryption are the same
        >>> data = b"test data"
        >>> encrypted = rc4(data, key)
        >>> decrypted = rc4_d(encrypted, key)
        >>> decrypted == data
        True

        >>> # Multiple encryption/decryption cycles
        >>> data = "Important data"
        >>> encrypted = rc4(data, key)
        >>> decrypted = rc4_d(encrypted, key)
        >>> decrypted.decode() == data
        True
    """
    # Convert key to bytes if needed
    if isinstance(key, str):
        key = key.encode(encoding)

    # Create cipher and decrypt (RC4 is symmetric)
    algorithm = ARC4(key)
    cipher = Cipher(algorithm, mode=None, backend=default_backend())
    decryptor = cipher.decryptor()
    return decryptor.update(message) + decryptor.finalize()


if __name__ == "__main__":
    import doctest

    doctest.testmod(verbose=True)
