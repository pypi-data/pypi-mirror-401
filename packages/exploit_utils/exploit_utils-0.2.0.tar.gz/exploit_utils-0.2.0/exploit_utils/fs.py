"""File system operations wrapper"""

import io
import json
import os
import sys
import tempfile
import threading
from contextlib import contextmanager
from http.server import SimpleHTTPRequestHandler, ThreadingHTTPServer
from pathlib import Path
from typing import Any, Callable, Iterator

from .log import Logger, get_logger

__all__ = [
    "ExpHTTPRequestHandler",
    "FileServer",
    "get_root_path",
    "get_user_path",
    "parse_lines",
    "parse_lines_iter",
    "parse_json",
    "load_config",
    "temp_dir",
]


logger = get_logger()
__user_path = Path(os.path.abspath(os.getcwd()))


class ExpHTTPRequestHandler(SimpleHTTPRequestHandler):
    """HTTP request handler integrated with logging"""

    def __init__(
        self,
        request,
        client_address,
        server,
        *,
        dir: str | Path = ".",
        logger: Logger | None = None,
        allow_list_dir: bool = False,
    ) -> None:
        self._logger = logger
        self.allow_list_dir = allow_list_dir
        super().__init__(request, client_address, server, directory=dir)

    @staticmethod
    def factory(
        dir: str | Path = ".", logger: Logger | None = None
    ) -> Callable[..., "ExpHTTPRequestHandler"]:
        return lambda *args, **kwargs: ExpHTTPRequestHandler(
            dir=dir, logger=logger, *args, **kwargs
        )

    def log_message(self, format, *args) -> None:
        if self._logger:
            self._logger.debug(f"{self.address_string()} => {format % args}")

    def list_directory(self, path) -> io.BytesIO | None:
        if self.allow_list_dir:
            return super().list_directory(path)
        self.send_error(
            403,
            '<!doctype html><html><head><meta charset="UTF-8"/><title>Forbidden</title>'
            "<style>html,body{width:100%;height:100%;margin:0;}*{box-sizing:border-box;}"
            "#app{padding:1rem;background:black;display:flex;height:100%;justify-content:center;align-items:center;"
            "color:#54fe55;font-size:6rem;flex-direction:column;}"
            "#app .txt{font-size:1.8rem;}</style>"
            '</head><body><div id="app"><div>403</div><div class="txt">Forbidden</div></div></body></html>',
        )


class FileServer:
    """
    File server integrated with logging

    Manual lifecycle control:
    ```
    f = FileServer(dir="files")
    f.run()
    ...
    f.close()
    ```
    Using with statement for lifecycle control:
    ```
    with FileServer(dir="files"):
        ...
    ```
    """

    def __init__(
        self,
        host: str = "0.0.0.0",
        port: int = 8080,
        dir: str | Path = ".",
        logger: Logger = logger,
    ) -> None:
        self._host = host
        self._port = port
        self._is_runing: bool = False
        self._logger = logger
        self._server = ThreadingHTTPServer(
            (host, port), ExpHTTPRequestHandler.factory(dir, logger)
        )

    @property
    def is_running(self) -> bool:
        return self._is_runing

    def _run(self) -> None:
        with self._server:
            self._server.serve_forever()

    def run(self) -> None:
        """Start the file server"""
        if self._is_runing:
            raise Exception("file server is running")
        self._is_runing = True
        self._logger.info(f"file server running on {self._host}:{self._port} ...")
        threading.Thread(target=self._run).start()

    def close(self) -> None:
        """Stop the file server"""
        if self._is_runing:
            self._server.shutdown()
            self._logger.info("file server stopped")
            self._is_runing = False

    def __enter__(self):
        self.run()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


def get_root_path() -> Path:
    """Get the directory of the entry file"""
    if p := sys.modules["__main__"].__file__:
        return Path(os.path.dirname(os.path.abspath(p)))
    raise Exception()


def get_user_path() -> Path:
    """Get the user's working directory when the script was executed"""
    return __user_path


def rget(filepath: Path | str) -> Path:
    """Get the full file path using the entry file directory as root"""
    return get_root_path() / filepath


def uget(filepath: Path | str) -> Path:
    """Get the full file path using the user's working directory as root"""
    return get_user_path() / filepath


def parse_lines(
    filepath: Path, encoding: str = "utf-8", parser: Callable[[str], Any] = str
) -> list:
    """Parse file data line by line, discarding empty lines and trailing newlines"""
    with open(filepath, "r", encoding=encoding) as file:
        return [parser(i.rstrip("\r\n")) for i in file if i.rstrip("\r\n")]


def parse_lines_iter(
    filepath: Path, encoding: str = "utf-8", parser: Callable[[str], Any] = str
) -> Iterator[Any]:
    """Parse file data line by line, discarding empty lines and trailing newlines;
    This function is lazy and suitable for large files"""
    with open(filepath, "r", encoding=encoding) as file:
        for i in file:
            if i.rstrip("\r\n"):
                yield parser(i.rstrip("\r\n"))


def parse_json(filepath: Path, encoding: str = "utf-8") -> Any:
    """Parse JSON file and return the parsed Python object"""
    with open(filepath, "r", encoding=encoding) as file:
        return json.load(file)


def load_config(name: Path | str, encoding: str = "utf-8") -> Any:
    """Load configuration file"""
    return parse_json(rget(name), encoding=encoding)


@contextmanager
def temp_dir(
    suffix: str | None = None,
    prefix: str | None = None,
    dir: str | Path | None = None,
    ignore_cleanup_errors: bool = False,
    *,
    delete: bool = True,
) -> Iterator[Path]:
    """Create temporary directory context"""
    with tempfile.TemporaryDirectory(
        suffix, prefix, dir, ignore_cleanup_errors, delete=delete
    ) as temp_dir:
        yield Path(temp_dir)
