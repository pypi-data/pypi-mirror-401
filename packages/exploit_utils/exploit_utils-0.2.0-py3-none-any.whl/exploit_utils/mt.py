"""Multi-threading related functionality wrapper"""

import functools
import queue
import threading
from concurrent.futures import Future, as_completed, wait
from concurrent.futures import ThreadPoolExecutor as ThreadPool
from types import MappingProxyType
from typing import Any, Callable, Collection, Iterable, Mapping

import tqdm

from .misc import TqdmThemes

__all__ = [
    "ThreadPool",
    "wait",
    "STOP",
    "ThreadGroup",
    "create_threads",
    "consumer",
    "handle_fs",
]


STOP = object()
"""Consumer stop signal"""


class ThreadGroup:
    """A group of threads"""

    def __init__(self, threads: list[threading.Thread]):
        self._threads = threads

    def run(self) -> "ThreadGroup":
        """Start all threads"""
        for t in self._threads:
            t.start()
        return self

    def join(self) -> None:
        """Wait for all threads"""
        for t in self._threads:
            t.join()

    def __add__(self, other: "ThreadGroup") -> "ThreadGroup":
        if not isinstance(other, ThreadGroup):
            raise TypeError(
                f"unsupported operand type(s) for +: 'ThreadGroup' and '{type(other).__name__}'"
            )
        return ThreadGroup(self._threads + other._threads)


def create_threads(
    target: Callable,
    args: Iterable[Any] = (),
    kwargs: Mapping[str, Any] | None = None,
    n: int = 1,
) -> ThreadGroup:
    """Create threads in batch"""
    threads: list[threading.Thread] = []

    for _ in range(n):
        t = threading.Thread(target=target, args=args, kwargs=kwargs)
        threads.append(t)

    return ThreadGroup(threads)


def consumer(func: Callable) -> Callable:
    """
    Decorator for quickly implementing consumers. There are three conventions for this functionality:

    1. The "first positional argument" of the decorated function is a `queue.Queue`,
       which will be used to fetch tasks at runtime
    2. The "first positional argument" of the decorated function receives the fetched task
    3. Only `exploit_utils.mt.STOP` can be used as the stop signal

    Example:
    ```
    task_queue = queue.Queue()
    @consumer
    # The first parameter 'url' of the attack function receives queue.Queue.get()
    def attack(url: str, debug: bool) -> None:
        ...
    # task_queue must be the first element in args
    threading.Thread(target=attack, args=(task_queue,), kwargs={"debug": False})
    threading.Thread(target=attack, args=(task_queue, False))
    ```
    """

    @functools.wraps(func)
    def wrap(*args, **kwargs) -> None:
        q: queue.Queue = args[0]
        while True:
            item = q.get()
            if item == STOP:
                q.put(STOP)
                break
            func(item, *args, **kwargs)

    return wrap


def handle_fs(
    fs: Collection[Future],
    func: Callable[[Future], bool] | None = None,
    theme: dict[str, Any] | MappingProxyType[str, Any] = TqdmThemes.classic,
) -> None:
    """
    Wrapper for processing methods of future collections

    Adds a progress bar for future completion status
    Processes completed futures using the provided `func` parameter
    """
    success = 0

    def when_func(f: Future) -> None:
        nonlocal success
        if func(f):  # type: ignore
            success += 1

    def when_not_func(f: Future[bool]) -> None:
        nonlocal success
        if f.result():
            success += 1

    handle_logic = when_func if func else when_not_func
    for f in (pbar := tqdm.tqdm(as_completed(fs), total=len(fs), **theme)):
        handle_logic(f)
        pbar.set_postfix_str(f"success:{success}")
