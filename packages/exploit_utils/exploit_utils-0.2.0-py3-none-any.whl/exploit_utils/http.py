"""Network request related functionality"""

import re
from contextlib import contextmanager
from dataclasses import dataclass
from enum import StrEnum
from http.client import HTTPConnection, HTTPResponse, HTTPSConnection
from pathlib import Path
from typing import IO, Any, Generator

import requests
import urllib3
from requests.adapters import HTTPAdapter

from .log import get_logger
from .rand import ua

__all__ = [
    "ContentType",
    "UploadFile",
    "URL",
    "ExpAdapter",
    "no_warn",
    "get_session",
    "save",
    "raw_request",
]

type FileContent = IO[str] | str | bytes
URL_PATTERN = r"^(https?)://((.*@)?([^/:?#\r\n]+)(:\d+)?)(/[^?#\r\n]*)?(\?.*?)?(#.*?)?$"

logger = get_logger()


class ContentType(StrEnum):
    """Common Content-Type options can be found here"""

    plain = "text/plain"
    html = "text/html"
    xml = "text/xml"
    form = "application/x-www-form-urlencoded"
    json = "application/json"
    octet_stream = "application/octet-stream"
    multipart = "multipart/form-data"
    jpg = "image/jpeg"
    png = "image/png"
    gif = "image/gif"


@dataclass
class UploadFile:
    name: str
    content: FileContent
    type: ContentType | str

    def to_tuple(self) -> tuple[str, FileContent, str]:
        return (self.name, self.content, str(self.type))


class URL:
    """
    A URL parsing and manipulation class.

    Examples:
        >>> url = URL("https://example.com/path/to/resource")
        >>> url.scheme
        'https'
        >>> url.host
        'example.com'
        >>> url.port
        443
        >>> url.netloc
        'example.com'
        >>> url.path
        '/path/to/resource'
        >>> url.url
        'https://example.com/path/to/resource'
        >>> str(url)
        'https://example.com/path/to/resource'

        >>> # URL with port
        >>> url2 = URL("http://localhost:8080/api/v1/users")
        >>> url2.scheme
        'http'
        >>> url2.host
        'localhost'
        >>> url2.port
        8080
        >>> url2.netloc
        'localhost:8080'
        >>> url2.path
        '/api/v1/users'

        >>> # Root URL property
        >>> url.root.url
        'https://example.com/'
        >>> url2.root.url
        'http://localhost:8080/'

        >>> # Path concatenation using division operator
        >>> url3 = URL("https://example.com/api")
        >>> url4 = url3 / "v1" / "users"
        >>> url4.url
        'https://example.com/api/v1/users'
        >>> url5 = url4 / "123" / "profile"
        >>> url5.url
        'https://example.com/api/v1/users/123/profile'

        >>> # Equality comparison
        >>> URL("https://example.com/test") == URL("https://example.com/test")
        True
        >>> URL("https://example.com/test") == URL("http://example.com/test")
        False

        >>> # Convert to file path
        >>> url.as_path()
        'https_example.com_path_to_resource'
        >>> URL("http://localhost:3000/api/data").as_path()
        'http_localhost_3000_api_data'
    """

    def __init__(self, url: str) -> None:
        m = re.match(URL_PATTERN, url)
        if not m:
            raise ValueError(f"{url} is not a valid URL")
        self._scheme: str = m.group(1)
        self._netloc: str = m.group(2)
        self._evidence: str = m.group(3)[:-1] if m.group(3) else ""
        self._host: str = m.group(4)
        if m.group(5):
            self._port = int(m.group(5)[1:])
        else:
            self._port = 443 if self._scheme == "https" else 80
        assert 0 < self._port < 65536, f"{url} is not a valid URL"
        self._path: Path = Path("/") / (m.group(6) or "")
        self._query = m.group(7)[1:] if m.group(7) else ""
        self._fragment = m.group(8)[1:] if m.group(8) else ""

    @property
    def scheme(self) -> str:
        """Scheme"""
        return self._scheme

    @property
    def netloc(self) -> str:
        """Netloc"""
        return self._netloc

    @property
    def evidence(self) -> str:
        """Evidence"""
        return self._evidence

    @property
    def port(self) -> int:
        """Port"""
        return self._port

    @property
    def host(self) -> str:
        """Host"""
        return self._host

    @property
    def path(self) -> str:
        """Path"""
        return self._path.as_posix()

    @property
    def query(self) -> str:
        """Query"""
        return self._query

    @property
    def fragment(self) -> str:
        """Fragment"""
        return self._fragment

    @property
    def root(self) -> "URL":
        """Root path"""
        return URL(self._add_subfix(f"{self.scheme}://{self.netloc}"))

    @property
    def url(self) -> str:
        """Full URL"""
        full_url = f"{self.scheme}://{self.netloc}{self.path}"
        return self._add_subfix(full_url)

    def __str__(self) -> str:
        return self.url

    def __repr__(self) -> str:
        return (
            f"URL(scheme={self.scheme}, evidence={self.evidence}, host={self.host}, port={self.port}, "
            f"path={self.path}, query={self.query}, fragment={self.fragment})"
        )

    def __truediv__(self, other: str) -> "URL":
        """
        Path concatenation using division operator.

        Examples:
            >>> url = URL("https://example.com/api")
            >>> (url / "v1" / "users").url
            'https://example.com/api/v1/users'
            >>> (url / "data.json").url
            'https://example.com/api/data.json'
        """
        if not isinstance(other, str):
            raise TypeError()
        new_url = f"{self.scheme}://{self.netloc}{(self._path / other).as_posix()}"
        return URL(url=self._add_subfix(new_url))

    def __eq__(self, value: Any) -> bool:
        """
        Equality comparison.

        Examples:
            >>> URL("https://example.com") == URL("https://example.com")
            True
            >>> URL("https://example.com") == URL("http://example.com")
            False
            >>> URL("https://example.com/path") == URL("https://example.com/path")
            True
            >>> URL("https://example.com:443") == URL("https://example.com")
            True  # Default port for https is 443
        """
        return isinstance(value, URL) and self.url == value.url

    def as_path(self, with_subfix: bool = True) -> str:
        """
        Convert URL to filesystem-safe path.

        Examples:
            >>> URL("https://example.com/api/v1").as_path()
            'https_example.com_api_v1'
            >>> URL("http://localhost:8080/data.json").as_path()
            'http_localhost_8080_data.json'
        """
        url = self.url if with_subfix else self.remove_subfix().url
        return url.replace("://", "_").replace(":", "_").replace("/", "_")

    def _add_subfix(self, url: str) -> str:
        if self.query:
            url += f"?{self.query}"
        if self.fragment:
            url += f"#{self.fragment}"
        return url

    def remove_subfix(self) -> "URL":
        return URL(url=f"{self.scheme}://{self.netloc}{self.path}")


class ExpAdapter(HTTPAdapter):
    """
    HTTP adapter specifically designed for writing exploits

    Random User-Agent header, 5s timeout, SSL certificate verification disabled
    """

    def __init__(
        self,
        pool_size: int = 20,
        max_retries: int = 0,
        pool_block: bool = False,
        timeout: float = 5.0,
    ) -> None:
        self.timeout = timeout
        super().__init__(
            pool_connections=pool_size,
            pool_maxsize=pool_size,
            max_retries=max_retries,
            pool_block=pool_block,
        )

    def send(self, request: requests.PreparedRequest, **kwargs) -> requests.Response:  # type: ignore
        """Send a PreparedRequest with exploit-specific configurations"""
        request.headers.setdefault("User-Agent", ua.random)
        if kwargs.get("timeout") is None:
            kwargs["timeout"] = self.timeout
        return super().send(request, **kwargs)


def no_warn() -> None:
    """Disable all HTTP warnings"""
    urllib3.disable_warnings(urllib3.exceptions.HTTPWarning)


def get_session(pool_size: int = 20, timeout: float = 5.0) -> requests.Session:
    """Get a specially configured session object"""
    adapter = ExpAdapter(pool_size=pool_size, timeout=timeout)

    session = requests.Session()
    session.verify = False
    session.mount("http://", adapter)
    session.mount("https://", adapter)

    return session


def save(
    resp: requests.Response,
    save_path: Path | str,
    ok_msg: str = "",
    err_msg: str = "",
) -> bool:
    """Save response to specified location, can be used for downloading files,
    automatically handles streaming, note: not thread-safe"""
    try:
        with open(save_path, "wb") as file:
            for chunk in resp.iter_content(chunk_size=1024):
                file.write(chunk)
        logger.ok(
            ok_msg.format({"url": resp.url, "save_path": save_path})
            or f"{resp.url} saved to {save_path}"
        )
        return True
    except Exception as e:
        logger.error(
            err_msg.format({"url": resp.url, "err": e})
            or f"{resp.url} download fail, error: {e}"
        )
        return False


@contextmanager
def raw_request(
    method: str,
    url: URL,
    params: dict[str, str] | None = None,
    headers: dict[str, str] | None = None,
    body: str | None = None,
    timeout: float = 5.0,
) -> Generator[HTTPResponse, None, None]:
    """Does not URL-encode the message content, all encoding operations must be done by you"""
    if headers is None:
        headers = {}

    config = {
        "host": url.host,
        "port": url.port,
        "timeout": timeout,
    }
    conn = (
        HTTPSConnection(**config) if url.scheme == "https" else HTTPConnection(**config)
    )

    path = url.path
    path += f"?{url.query}" if url.query else ""
    path += (
        f"{'&' if url.query else '?'}{'&'.join(f'{k}={v}' for k, v in params.items())}"
        if params
        else ""
    )
    path += f"#{url.fragment}" if url.fragment else ""

    headers.setdefault("User-Agent", ua.random)

    try:
        conn.request(method, path, body, headers)
        yield conn.getresponse()
    finally:
        conn.close()
