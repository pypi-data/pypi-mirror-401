"""System command execution related functionality wrapper"""

import re
import subprocess

__all__ = ["BadReturnCode", "StdErr", "BadOutput", "Command", "run"]


class BadReturnCode(ValueError):
    def __init__(self, rc: int, *args) -> None:
        super().__init__(rc, *args)
        self.rc = rc


class StdErr(ValueError):
    def __init__(self, err: str | bytes, *args) -> None:
        super().__init__(err[:50], *args)
        self.err = err


class BadOutput(ValueError):
    def __init__(self, text: str, *args) -> None:
        super().__init__(text, *args)
        self.text = text


class Command:
    def __init__(self):
        self._rc: int = -1
        self._stdout: str | bytes = ""
        self._stderr: str | bytes = ""

    @property
    def rc(self) -> int:
        """Exit code"""
        return self._rc

    @property
    def stdout(self) -> str | bytes:
        """Standard output"""
        return self._stdout

    @property
    def stderr(self) -> str | bytes:
        """Standard error"""
        return self._stderr

    def run(self, args: list[str], **options) -> "Command":
        """Execute system command locally, captures text output by default"""
        options.setdefault("capture_output", True)
        options.setdefault("text", True)

        result = subprocess.run(args, **options)

        self._rc = result.returncode
        self._stdout = result.stdout
        self._stderr = result.stderr

        return self

    def raise_rc(self, *rc: int) -> "Command":
        """Capture specific exit codes, raises `BadReturnCode` exception"""
        if self._rc in rc:
            raise BadReturnCode(self._rc)
        return self

    def raise_err(self) -> "Command":
        """Raises `StdErr` exception when there is error output"""
        if self._stderr:
            raise StdErr(self._stderr)
        return self

    def raise_match(self, pattern: str, encoding: str = "utf-8") -> "Command":
        """Capture specific patterns in standard output and error output,
        raises `BadOutput` exception"""
        stdout = (
            self._stdout
            if isinstance(self._stdout, str)
            else self._stdout.decode(encoding)
        )
        if m := re.search(pattern, stdout):
            raise BadOutput(m.group(0))

        stderr = (
            self._stderr
            if isinstance(self._stderr, str)
            else self._stderr.decode(encoding)
        )
        if m := re.search(pattern, stderr):
            raise BadOutput(m.group(0))

        return self


def run(cmd: list[str], **options) -> Command:
    """Execute system command locally, captures text output by default"""
    return Command().run(cmd, **options)
