"""Miscellaneous utilities"""

import socket
import threading
from types import MappingProxyType

from .log import Logger, get_logger

__all__ = ["TqdmThemes", "NetCat", "show_banner"]


logger = get_logger()


class TqdmThemes:
    """tqdm themes"""

    classic = MappingProxyType(
        {
            "bar_format": "[{bar:20}] {percentage:3.0f}% {n_fmt}/{total_fmt} {rate_fmt}{postfix}",
            "ascii": " #",
        }
    )


class NetCat:
    """
    A simple netcat implementation, can be used to receive reverse shell

    Attention: cannot be reused
    """

    def __init__(self, port: int, logger: Logger = logger) -> None:
        self._port = port
        self.logger = logger
        self._running: bool = False
        self._socket = socket.socket()
        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._socket.bind(("0.0.0.0", port))
        self._socket.listen(1)

    def run(self) -> None:
        """Start netcat, will block the parent thread"""
        if self._running:
            raise Exception("netcat is already running")
        if self._socket._closed:
            raise Exception("netcat has ended")
        self._running = True

        try:
            self.logger.info(f"NetCat: Listening on port {self._port}")
            conn, addr = self._socket.accept()
        except KeyboardInterrupt:
            self.logger.info("NetCat: Input interrupted")
            self._exit()
            return

        logger.info(f"NetCat: Connection from {addr}")

        try:
            t1 = threading.Thread(target=self._input_thread, args=(conn,), daemon=True)
            t1.start()
            t2 = threading.Thread(target=self._recv_thread, args=(conn,), daemon=True)
            t2.start()
            while t1.is_alive() and t2.is_alive():
                t1.join(0.1)
                t2.join(0.1)
        except KeyboardInterrupt:
            self.logger.info("NetCat: Shutting down...")
        finally:
            conn.close()
            self._exit()

    def _exit(self) -> None:
        self._socket.close()
        self._running = False
        self.logger.info("NetCat: Exit")

    def _input_thread(self, conn: socket.socket) -> None:
        """Receive user input, send socket messages"""
        while self._running:
            try:
                cmd = input()
                if not self._running:
                    break
                conn.send((cmd + "\n").encode())
            except (BrokenPipeError, ConnectionError):
                print()
                self.logger.info("NetCat: Connection broken")
                self._running = False
                break
            except KeyboardInterrupt:
                print()
                self.logger.info("NetCat: Input interrupted")
                self._running = False
                break

    def _recv_thread(self, conn: socket.socket) -> None:
        """Receive socket messages"""
        while self._running:
            try:
                conn.settimeout(0.5)
                data = conn.recv(1024)
                if not data:
                    self._running = False
                    break
                print(data.decode("utf-8", errors="replace"), end="", flush=True)
            except socket.timeout:
                continue
            except (ConnectionError, OSError):
                self._running = False
                break


def show_banner(banner: str, front: int = 0, back: int = 1) -> None:
    """
    Print banner

    `front` is the number of leading empty lines, `back` is the number of trailing empty lines
    """
    banner = banner.strip("\r\n")
    print(f"{'\n' * front}{banner}{'\n' * back}")
