# SPDX-License-Identifier: Apache-2.0 AND MIT
# Copyright (c) Zulip
# Modifications Copyright (c) Stewitch 2026

"""
Async Zulip client built on httpx, mirroring the public surface of the sync `zulip.Client` where practical.
Generated by AI.

Raw file: https://github.com/zulip/python-zulip-api/blob/main/zulip/zulip/__init__.py

Usage example:

    from async_client import AsyncClient
    import asyncio

    async def main():
        client = AsyncClient()
        reg = await client.register(["message"])
        print(reg)
        await client.aclose()

    asyncio.run(main())
"""

from __future__ import annotations

import argparse
import asyncio
import json
import logging
import optparse
import os
import platform
import random
import sys
import time
import traceback
import types
import urllib.parse
from configparser import ConfigParser
from typing import (
    IO,
    Any,
    Awaitable,
    Callable,
    Dict,
    Iterable,
    List,
    Mapping,
    Optional,
    Sequence,
    Tuple,
    Union,
)

import distro
import httpx
from typing_extensions import Literal

from .models import (
    Event,
    EventsResponse,
    PrivateMessageRequest,
    RegisterResponse,
    SendMessageResponse,
    StreamMessageRequest,
    UserProfileResponse,
    UpdatePresenceRequest,
    SubscriptionsResponse,
    ChannelResponse,
    GetUserGroupsResponse,
    GetUserGroupsRequest,
)

__version__ = "0.9.1-async"

logger = logging.getLogger(__name__)

API_VERSTRING = "v1/"

EditPropagateMode = Literal["change_one", "change_all", "change_later"]
EmojiType = Literal["realm_emoji", "unicode_emoji", "zulip_extra_emoji"]
ModifiableMessageFlag = Literal["read", "starred", "collapsed"]
MessageFlag = Literal[
    ModifiableMessageFlag,
    "mentioned",
    "wildcard_mentioned",
    "has_alert_word",
    "historical",
]


class CountingBackoff:
    def __init__(
        self,
        maximum_retries: int = 10,
        timeout_success_equivalent: Optional[float] = None,
        delay_cap: float = 90.0,
    ) -> None:
        self.number_of_retries = 0
        self.maximum_retries = maximum_retries
        self.timeout_success_equivalent = timeout_success_equivalent
        self.last_attempt_time = 0.0
        self.delay_cap = delay_cap

    def keep_going(self) -> bool:
        self._check_success_timeout()
        return self.number_of_retries < self.maximum_retries

    def succeed(self) -> None:
        self.number_of_retries = 0
        self.last_attempt_time = time.time()

    def fail(self) -> None:
        self._check_success_timeout()
        self.number_of_retries = min(self.number_of_retries + 1, self.maximum_retries)
        self.last_attempt_time = time.time()

    def _check_success_timeout(self) -> None:
        if (
            self.timeout_success_equivalent is not None
            and self.last_attempt_time != 0
            and time.time() - self.last_attempt_time > self.timeout_success_equivalent
        ):
            self.number_of_retries = 0


class RandomExponentialBackoff(CountingBackoff):
    def fail(self) -> None:  # type: ignore[override]
        super().fail()
        delay_scale = int(2 ** (self.number_of_retries / 2.0 - 1)) + 1
        delay = min(delay_scale + random.randint(1, delay_scale), self.delay_cap)
        message = f"Sleeping for {delay}s [max {delay_scale * 2}] before retrying."
        try:
            logger.warning(message)
        except NameError:
            print(message)
        time.sleep(delay)


def _default_client() -> str:
    return "ZulipPythonAsync/" + __version__


def add_default_arguments(
    parser: argparse.ArgumentParser,
    patch_error_handling: bool = True,
    allow_provisioning: bool = False,
) -> argparse.ArgumentParser:
    if patch_error_handling:

        def custom_error_handling(self: argparse.ArgumentParser, message: str) -> None:
            self.print_help(sys.stderr)
            self.exit(2, f"{self.prog}: error: {message}\n")

        parser.error = types.MethodType(custom_error_handling, parser)  # type: ignore[method-assign]

    if allow_provisioning:
        parser.add_argument(
            "--provision",
            action="store_true",
            dest="provision",
            help="install dependencies for this script (found in requirements.txt)",
        )

    group = parser.add_argument_group("Zulip API configuration")
    group.add_argument("--site", dest="zulip_site", help="Zulip server URI", default=None)
    group.add_argument("--api-key", dest="zulip_api_key", action="store")
    group.add_argument("--user", dest="zulip_email", help="Email address of the calling bot or user.")
    group.add_argument(
        "--config-file",
        action="store",
        dest="zulip_config_file",
        help="""Location of an ini file containing the above
                            information. (default ~/.zuliprc)""",
    )
    group.add_argument("-v", "--verbose", action="store_true", help="Provide detailed output.")
    group.add_argument(
        "--client", action="store", default=None, dest="zulip_client", help=argparse.SUPPRESS
    )
    group.add_argument(
        "--insecure",
        action="store_true",
        dest="insecure",
        help="""Do not verify the server certificate.
                            The https connection will not be secure.""",
    )
    group.add_argument(
        "--cert-bundle",
        action="store",
        dest="cert_bundle",
        help="""Specify a file containing either the
                            server certificate, or a set of trusted
                            CA certificates. This will be used to
                            verify the server's identity. All
                            certificates should be PEM encoded.""",
    )
    group.add_argument(
        "--client-cert",
        action="store",
        dest="client_cert",
        help="""Specify a file containing a client
                            certificate (not needed for most deployments).""",
    )
    group.add_argument(
        "--client-cert-key",
        action="store",
        dest="client_cert_key",
        help="""Specify a file containing the client
                            certificate's key (if it is in a separate
                            file).""",
    )
    return parser


def generate_option_group(parser: optparse.OptionParser, prefix: str = "") -> optparse.OptionGroup:
    logging.warning(
        """zulip.generate_option_group is based on optparse, which
                    is now deprecated. We recommend migrating to argparse and
                    using zulip.add_default_arguments instead."""
    )

    group = optparse.OptionGroup(parser, "Zulip API configuration")
    group.add_option(f"--{prefix}site", dest="zulip_site", help="Zulip server URI", default=None)
    group.add_option(f"--{prefix}api-key", dest="zulip_api_key", action="store")
    group.add_option(f"--{prefix}user", dest="zulip_email", help="Email address of the calling bot or user.")
    group.add_option(
        f"--{prefix}config-file",
        action="store",
        dest="zulip_config_file",
        help="Location of an ini file containing the\nabove information. (default ~/.zuliprc)",
    )
    group.add_option("-v", "--verbose", action="store_true", help="Provide detailed output.")
    group.add_option(
        f"--{prefix}client",
        action="store",
        default=None,
        dest="zulip_client",
        help=optparse.SUPPRESS_HELP,
    )
    group.add_option(
        "--insecure",
        action="store_true",
        dest="insecure",
        help="""Do not verify the server certificate.
                          The https connection will not be secure.""",
    )
    group.add_option(
        "--cert-bundle",
        action="store",
        dest="cert_bundle",
        help="""Specify a file containing either the
                          server certificate, or a set of trusted
                          CA certificates. This will be used to
                          verify the server's identity. All
                          certificates should be PEM encoded.""",
    )
    group.add_option(
        "--client-cert",
        action="store",
        dest="client_cert",
        help="""Specify a file containing a client
                          certificate (not needed for most deployments).""",
    )
    group.add_option(
        "--client-cert-key",
        action="store",
        dest="client_cert_key",
        help="""Specify a file containing the client
                          certificate's key (if it is in a separate
                          file).""",
    )
    return group


def validate_boolean_field(field: Optional[str]) -> Union[bool, None]:
    if not isinstance(field, str):
        return None

    field = field.lower()

    if field == "true":
        return True
    if field == "false":
        return False
    return None


class ZulipError(Exception):
    pass


class ConfigNotFoundError(ZulipError):
    pass


class MissingURLError(ZulipError):
    pass


class UnrecoverableNetworkError(ZulipError):
    pass


def get_default_config_filename() -> Optional[str]:
    if os.environ.get("HOME") is None:
        return None

    config_file = os.path.join(os.environ["HOME"], ".zuliprc")
    if not os.path.exists(config_file) and os.path.exists(os.path.join(os.environ["HOME"], ".humbugrc")):
        raise ZulipError(
            "The Zulip API configuration file is now ~/.zuliprc; please run:\n\n"
            "  mv ~/.humbugrc ~/.zuliprc\n"
        )
    return config_file


class AsyncClient:
    def __init__(
        self,
        email: Optional[str] = None,
        api_key: Optional[str] = None,
        config_file: Optional[str] = None,
        verbose: bool = False,
        retry_on_errors: bool = True,
        site: Optional[str] = None,
        client: Optional[str] = None,
        cert_bundle: Optional[str] = None,
        insecure: Optional[bool] = None,
        client_cert: Optional[str] = None,
        client_cert_key: Optional[str] = None,
    ) -> None:
        if client is None:
            client = _default_client()

        if config_file is not None:
            config_file = os.path.abspath(os.path.expanduser(config_file))
        if config_file is None:
            config_file = os.environ.get("ZULIP_CONFIG")
        if api_key is None:
            api_key = os.environ.get("ZULIP_API_KEY")
        if email is None:
            email = os.environ.get("ZULIP_EMAIL")
        if site is None:
            site = os.environ.get("ZULIP_SITE")
        if client_cert is None:
            client_cert = os.environ.get("ZULIP_CERT")
        if client_cert_key is None:
            client_cert_key = os.environ.get("ZULIP_CERT_KEY")
        if cert_bundle is None:
            cert_bundle = os.environ.get("ZULIP_CERT_BUNDLE")
        if insecure is None:
            insecure_setting = os.environ.get("ZULIP_ALLOW_INSECURE")
            if insecure_setting is not None:
                insecure = validate_boolean_field(insecure_setting)
                if insecure is None:
                    raise ZulipError(
                        "The ZULIP_ALLOW_INSECURE environment "
                        f"variable is set to '{insecure_setting}', it must be "
                        "'true' or 'false'"
                    )
        if config_file is None:
            config_file = get_default_config_filename()

        if config_file is not None and os.path.exists(config_file):
            config = ConfigParser()
            with open(config_file) as f:
                config.read_file(f, config_file)
            if api_key is None:
                api_key = config.get("api", "key")
            if email is None:
                email = config.get("api", "email")
            if site is None and config.has_option("api", "site"):
                site = config.get("api", "site")
            if client_cert is None and config.has_option("api", "client_cert"):
                client_cert = config.get("api", "client_cert")
            if client_cert_key is None and config.has_option("api", "client_cert_key"):
                client_cert_key = config.get("api", "client_cert_key")
            if cert_bundle is None and config.has_option("api", "cert_bundle"):
                cert_bundle = config.get("api", "cert_bundle")
            if insecure is None and config.has_option("api", "insecure"):
                insecure_setting = config.get("api", "insecure")
                insecure = validate_boolean_field(insecure_setting)
                if insecure is None:
                    raise ZulipError(
                        f"insecure is set to '{insecure_setting}', it must be "
                        f"'true' or 'false' if it is used in {config_file}"
                    )
        elif None in (api_key, email):
            raise ConfigNotFoundError(
                f"api_key or email not specified and file {config_file} does not exist"
            )

        assert api_key is not None and email is not None
        self.api_key = api_key
        self.email = email
        self.verbose = verbose
        if site is not None:
            if site.startswith("localhost"):
                site = "http://" + site
            elif not site.startswith("http"):
                site = "https://" + site
            site = site.rstrip("/")
            self.base_url = site
        else:
            raise MissingURLError("Missing Zulip server URL; specify via --site or ~/.zuliprc.")

        if not self.base_url.endswith("/api"):
            self.base_url += "/api"
        self.base_url += "/"
        self.retry_on_errors = retry_on_errors
        self.client_name = client

        if insecure:
            logger.warning(
                "Insecure mode enabled. The server's SSL/TLS "
                "certificate will not be validated, making the "
                "HTTPS connection potentially insecure"
            )
            self.tls_verification: Union[bool, str] = False
        elif cert_bundle is not None:
            if not os.path.isfile(cert_bundle):
                raise ConfigNotFoundError(f"tls bundle '{cert_bundle}' does not exist")
            self.tls_verification = cert_bundle
        else:
            self.tls_verification = True

        if client_cert is None:
            if client_cert_key is not None:
                raise ConfigNotFoundError(
                    f"client cert key '{client_cert_key}' specified, but no client cert public part provided"
                )
        else:
            if not os.path.isfile(client_cert):
                raise ConfigNotFoundError(f"client cert '{client_cert}' does not exist")
            if client_cert_key is not None and not os.path.isfile(client_cert_key):
                raise ConfigNotFoundError(f"client cert key '{client_cert_key}' does not exist")
        self.client_cert = client_cert
        self.client_cert_key = client_cert_key

        self.session: Optional[httpx.AsyncClient] = None
        self.has_connected = False

    async def ensure_session(self) -> None:
        if self.session:
            return

        if self.client_cert_key is not None:
            assert self.client_cert is not None
            client_cert: Union[None, str, Tuple[str, str]] = (
                self.client_cert,
                self.client_cert_key,
            )
        else:
            client_cert = self.client_cert

        headers = {"User-agent": self.get_user_agent()}
        self.session = httpx.AsyncClient(
            auth=(self.email, self.api_key),
            verify=self.tls_verification,
            cert=client_cert,
            headers=headers,
            base_url=self.base_url,
        )

    def get_user_agent(self) -> str:
        vendor = ""
        vendor_version = ""
        try:
            vendor = platform.system()
            vendor_version = platform.release()
        except OSError:
            pass

        if vendor == "Linux":
            vendor = distro.name()
            vendor_version = distro.version()
        elif vendor == "Windows":
            vendor_version = platform.win32_ver()[1]
        elif vendor == "Darwin":
            vendor_version = platform.mac_ver()[0]

        return f"{self.client_name} ({vendor}; {vendor_version})"

    async def do_api_query(
        self,
        orig_request: Mapping[str, Any],
        url: str,
        method: str = "POST",
        longpolling: bool = False,
        files: Optional[List[IO[Any]]] = None,
        timeout: Optional[float] = None,
    ) -> Dict[str, Any]:
        if files is None:
            files = []

        request_timeout = 90.0 if longpolling else timeout or 15.0

        request = {key: val if isinstance(val, str) else json.dumps(val) for key, val in orig_request.items()}
        req_files = [(f.name, f) for f in files]

        await self.ensure_session()
        assert self.session is not None

        query_state: Dict[str, Any] = {
            "had_error_retry": False,
            "request": request,
            "failures": 0,
        }

        def error_retry(error_string: str) -> bool:
            if not self.retry_on_errors or query_state["failures"] >= 10:
                return False
            if self.verbose:
                if not query_state["had_error_retry"]:
                    sys.stdout.write(
                        "zulip API({}): connection error{} -- retrying.".format(
                            url.split(API_VERSTRING, 2)[0],
                            error_string,
                        )
                    )
                    query_state["had_error_retry"] = True
                else:
                    sys.stdout.write(".")
                sys.stdout.flush()
            query_state["request"]["dont_block"] = json.dumps(True)
            query_state["failures"] += 1
            return True

        def end_error_retry(succeeded: bool) -> None:
            if query_state["had_error_retry"] and self.verbose:
                if succeeded:
                    print("Success!")
                else:
                    print("Failed!")

        while True:
            try:
                kwarg = "params" if method == "GET" else "data"
                kwargs = {kwarg: query_state["request"]}
                if files:
                    kwargs["files"] = req_files

                res = await self.session.request(
                    method,
                    urllib.parse.urljoin(self.base_url, url),
                    timeout=request_timeout,
                    **kwargs,
                )

                self.has_connected = True

                if str(res.status_code).startswith("5") and error_retry(f" (server {res.status_code})"):
                    await asyncio.sleep(1)
                    continue

            except (httpx.ReadTimeout, httpx.ConnectTimeout) as e:
                if longpolling:
                    continue
                end_error_retry(False)
                raise e
            except httpx.ConnectError as e:
                if not self.has_connected:
                    raise UnrecoverableNetworkError("cannot connect to server " + self.base_url) from e
                if error_retry(""):
                    await asyncio.sleep(1)
                    continue
                end_error_retry(False)
                raise
            except Exception:
                raise

            try:
                json_result = res.json()
            except Exception:
                end_error_retry(False)
                return {
                    "msg": "Unexpected error from the server",
                    "result": "http-error",
                    "status_code": res.status_code,
                }

            end_error_retry(True)
            return json_result

    @staticmethod
    def _dump_request(request: Optional[Dict[str, Any] | Any]) -> Dict[str, Any]:
        if request is None:
            return {}
        if hasattr(request, "model_dump"):
            return request.model_dump(exclude_none=True)
        return {k: v for k, v in request.items() if v is not None}

    async def call_endpoint(
        self,
        url: Optional[str] = None,
        method: str = "POST",
        request: Optional[Dict[str, Any] | Any] = None,
        longpolling: bool = False,
        files: Optional[List[IO[Any]]] = None,
        timeout: Optional[float] = None,
    ) -> Dict[str, Any]:
        marshalled_request = self._dump_request(request)
        versioned_url = API_VERSTRING + (url if url is not None else "")
        return await self.do_api_query(
            marshalled_request,
            versioned_url,
            method=method,
            longpolling=longpolling,
            files=files,
            timeout=timeout,
        )

    async def call_on_each_event(
        self,
        callback: Callable[[Event], Awaitable[None]] | Callable[[Event], None],
        event_types: Optional[List[str]] = None,
        narrow: Optional[List[List[str]]] = None,
        stop_event: Optional[asyncio.Event] = None,
        **kwargs: object,
    ) -> None:
        if narrow is None:
            narrow = []

        async def do_register() -> Tuple[str, int]:
            while True:
                if event_types is None:
                    res = await self.register(None, None, **kwargs)
                else:
                    res = await self.register(event_types, narrow, **kwargs)
                if res.result != "success":
                    if self.verbose:
                        print(f"Server returned error:\n{res.msg}")
                    await asyncio.sleep(1)
                else:
                    return (res.queue_id, res.last_event_id)

        queue_id: Optional[str] = None
        while True:
            if stop_event and stop_event.is_set():
                return
            if queue_id is None:
                queue_id, last_event_id = await do_register()

            try:
                res = await self.get_events(queue_id=queue_id, last_event_id=last_event_id)
            except (httpx.TimeoutException, httpx.ConnectError, httpx.RemoteProtocolError):
                if self.verbose:
                    print(f"Connection error fetching events:\n{traceback.format_exc()}")
                # RemoteProtocolError often indicates dropped long-poll; re-register next loop
                queue_id = None
                await asyncio.sleep(1)
                continue
            except Exception:
                print(f"Unexpected error:\n{traceback.format_exc()}")
                await asyncio.sleep(1)
                continue

            if res.result != "success":
                if res.result == "http-error":
                    if self.verbose:
                        print("HTTP error fetching events -- probably a server restart")
                else:
                    if self.verbose:
                        print(f"Server returned error:\n{res.msg}")
                    if res.model_extra.get("code") == "BAD_EVENT_QUEUE_ID" or res.msg.startswith(
                        "Bad event queue id:"
                    ):
                        queue_id = None
                await asyncio.sleep(1)
                continue

            for event in res.events:
                last_event_id = max(last_event_id, int(event.id))
                if event.type == "heartbeat":
                    continue
                result = callback(event)
                if asyncio.iscoroutine(result):
                    await result

    async def call_on_each_message(
        self,
        callback: Callable[[Dict[str, Any]], Awaitable[None]] | Callable[[Dict[str, Any]], None],
        **kwargs: object,
    ) -> None:
        async def event_callback(event: Event) -> None:
            if event.type == "message" and event.message is not None:
                result = callback(event.message)
                if asyncio.iscoroutine(result):
                    await result

        await self.call_on_each_event(event_callback, ["message"], None, **kwargs)

    async def register(
        self,
        event_types: Optional[Iterable[str]] = None,
        narrow: Optional[List[List[str]]] = None,
        **kwargs: object,
    ) -> RegisterResponse:
        if narrow is None:
            narrow = []
        request = dict(event_types=event_types, narrow=narrow, **kwargs)
        return RegisterResponse.model_validate(await self.call_endpoint(url="register", request=request))

    async def get_events(self, **request: Any) -> EventsResponse:
        return EventsResponse.model_validate(
            await self.call_endpoint(url="events", method="GET", longpolling=True, request=request)
        )

    async def deregister(self, queue_id: str, timeout: Optional[float] = None) -> Dict[str, Any]:
        request = dict(queue_id=queue_id)
        return await self.call_endpoint(url="events", method="DELETE", request=request, timeout=timeout)

    async def get_messages(self, message_filters: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(url="messages", method="GET", request=message_filters)

    async def check_messages_match_narrow(self, **request: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(url="messages/matches_narrow", method="GET", request=request)

    async def get_raw_message(self, message_id: int) -> Dict[str, str]:
        return await self.call_endpoint(url=f"messages/{message_id}", method="GET")

    async def send_message(self, message_data: Dict[str, Any] | StreamMessageRequest | PrivateMessageRequest) -> SendMessageResponse:
        payload = message_data
        if hasattr(message_data, "model_dump"):
            payload = message_data.model_dump(exclude_none=True)
        return SendMessageResponse.model_validate(await self.call_endpoint(url="messages", request=payload))

    async def upload_file(self, file: IO[Any]) -> Dict[str, Any]:
        return await self.call_endpoint(url="user_uploads", files=[file])

    async def get_attachments(self) -> Dict[str, Any]:
        return await self.call_endpoint(url="attachments", method="GET")

    async def update_message(self, message_data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="messages/%d" % (message_data["message_id"],),
            method="PATCH",
            request=message_data,
        )

    async def delete_message(self, message_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"messages/{message_id}", method="DELETE")

    async def update_message_flags(self, update_data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(url="messages/flags", method="POST", request=update_data)

    async def mark_all_as_read(self) -> Dict[str, Any]:
        return await self.call_endpoint(url="mark_all_as_read", method="POST")

    async def mark_stream_as_read(self, stream_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url="mark_stream_as_read", method="POST", request={"stream_id": stream_id})

    async def mark_topic_as_read(self, stream_id: int, topic_name: str) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="mark_topic_as_read",
            method="POST",
            request={"stream_id": stream_id, "topic_name": topic_name},
        )

    async def get_message_history(self, message_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"messages/{message_id}/history", method="GET")

    async def add_reaction(self, reaction_data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="messages/{}/reactions".format(reaction_data["message_id"]),
            method="POST",
            request=reaction_data,
        )

    async def remove_reaction(self, reaction_data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="messages/{}/reactions".format(reaction_data["message_id"]),
            method="DELETE",
            request=reaction_data,
        )

    async def get_realm_emoji(self) -> Dict[str, Any]:
        return await self.call_endpoint(url="realm/emoji", method="GET")

    async def upload_custom_emoji(self, emoji_name: str, file_obj: IO[Any]) -> Dict[str, Any]:
        return await self.call_endpoint(f"realm/emoji/{emoji_name}", method="POST", files=[file_obj])

    async def delete_custom_emoji(self, emoji_name: str) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"realm/emoji/{emoji_name}", method="DELETE")

    async def get_realm_linkifiers(self) -> Dict[str, Any]:
        return await self.call_endpoint(url="realm/linkifiers", method="GET")

    async def add_realm_filter(self, pattern: str, url_template: str) -> Dict[str, Any]:
        data = {"pattern": pattern}
        # Feature level not known in async client; keep both keys for compatibility.
        data["url_template"] = url_template
        data["url_format_string"] = url_template
        return await self.call_endpoint(url="realm/filters", method="POST", request=data)

    async def remove_realm_filter(self, filter_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"realm/filters/{filter_id}", method="DELETE")

    async def get_realm_profile_fields(self) -> Dict[str, Any]:
        return await self.call_endpoint(url="realm/profile_fields", method="GET")

    async def create_realm_profile_field(self, **request: Any) -> Dict[str, Any]:
        return await self.call_endpoint(url="realm/profile_fields", method="POST", request=request)

    async def remove_realm_profile_field(self, field_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"realm/profile_fields/{field_id}", method="DELETE")

    async def reorder_realm_profile_fields(self, **request: Any) -> Dict[str, Any]:
        return await self.call_endpoint(url="realm/profile_fields", method="PATCH", request=request)

    async def update_realm_profile_field(self, field_id: int, **request: Any) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"realm/profile_fields/{field_id}", method="PATCH", request=request)

    async def get_server_settings(self) -> Dict[str, Any]:
        return await self.call_endpoint(url="server_settings", method="GET")

    async def get_profile(self, request: Optional[Dict[str, Any]] = None) -> UserProfileResponse:
        return UserProfileResponse.model_validate(
            await self.call_endpoint(url="users/me", method="GET", request=request)
        )

    async def get_user_presence(self, email: str) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"users/{email}/presence", method="GET")

    async def get_realm_presence(self) -> Dict[str, Any]:
        return await self.call_endpoint(url="realm/presence", method="GET")

    async def update_presence(self, request: Dict[str, Any] | UpdatePresenceRequest) -> Dict[str, Any]:
        if hasattr(request, "model_dump"):
            request = request.model_dump(exclude_none=True)
        return await self.call_endpoint(url="users/me/presence", method="POST", request=request)

    async def get_streams(self, **request: Any) -> Dict[str, Any]:
        return await self.call_endpoint(url="streams", method="GET", request=request)

    async def update_stream(self, stream_data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="streams/{}".format(stream_data["stream_id"]),
            method="PATCH",
            request=stream_data,
        )

    async def delete_stream(self, stream_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"streams/{stream_id}", method="DELETE")

    async def add_default_stream(self, stream_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url="default_streams", method="POST", request={"stream_id": stream_id})

    async def get_user_by_id(self, user_id: int, **request: Any) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"users/{user_id}", method="GET", request=request)

    async def deactivate_user_by_id(self, user_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"users/{user_id}", method="DELETE")

    async def reactivate_user_by_id(self, user_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"users/{user_id}/reactivate", method="POST")

    async def update_user_by_id(self, user_id: int, **request: Any) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"users/{user_id}", method="PATCH", request=request)

    async def get_users(self, request: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        return await self.call_endpoint(url="users", method="GET", request=request)

    async def get_members(self, request: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        return await self.get_users(request=request)

    async def get_alert_words(self) -> Dict[str, Any]:
        return await self.call_endpoint(url="users/me/alert_words", method="GET")

    async def add_alert_words(self, alert_words: List[str]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="users/me/alert_words", method="POST", request={"alert_words": alert_words}
        )

    async def remove_alert_words(self, alert_words: List[str]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="users/me/alert_words", method="DELETE", request={"alert_words": alert_words}
        )

    async def get_subscriptions(self, request: Optional[Dict[str, Any]] = None) -> SubscriptionsResponse:
        return SubscriptionsResponse.model_validate(
            await self.call_endpoint(url="users/me/subscriptions", method="GET", request=request)
        )

    async def list_subscriptions(self, request: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        logger.warning("list_subscriptions() is deprecated. Please use get_subscriptions() instead.")
        return await self.get_subscriptions(request)

    async def add_subscriptions(self, streams: Iterable[Dict[str, Any]], **kwargs: Any) -> Dict[str, Any]:
        request = dict(subscriptions=streams, **kwargs)
        return await self.call_endpoint(url="users/me/subscriptions", request=request)

    async def remove_subscriptions(
        self,
        streams: Iterable[str],
        principals: Optional[Union[Sequence[str], Sequence[int]]] = None,
    ) -> Dict[str, Any]:
        request: Dict[str, object] = dict(subscriptions=streams)
        if principals is not None:
            request["principals"] = principals
        return await self.call_endpoint(url="users/me/subscriptions", method="DELETE", request=request)

    async def get_subscription_status(self, user_id: int, stream_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"users/{user_id}/subscriptions/{stream_id}", method="GET")

    async def mute_topic(self, request: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(url="users/me/subscriptions/muted_topics", method="PATCH", request=request)

    async def update_subscription_settings(self, subscription_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="users/me/subscriptions/properties",
            method="POST",
            request={"subscription_data": subscription_data},
        )

    async def update_notification_settings(self, notification_settings: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="settings/notifications",
            method="PATCH",
            request=notification_settings,
        )

    async def get_stream_id(self, stream: str) -> Dict[str, Any]:
        stream_encoded = urllib.parse.quote(stream, safe="")
        url = f"get_stream_id?stream={stream_encoded}"
        return await self.call_endpoint(url=url, method="GET", request=None)

    async def get_stream(self, stream_id: int) -> ChannelResponse:
        return ChannelResponse.model_validate(
            await self.call_endpoint(url=f"streams/{stream_id}", method="GET")
        )

    async def get_stream_topics(self, stream_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"users/me/{stream_id}/topics", method="GET")

    async def get_stream_email_address(self, stream_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"streams/{stream_id}/email_address", method="GET")

    async def get_user_groups(self, request: Optional[Dict[str, Any] | GetUserGroupsRequest] = None) -> GetUserGroupsResponse:
        payload = {}
        if request is not None:
            if hasattr(request, "model_dump"):
                payload = request.model_dump(exclude_none=True)
            else:
                payload = {k: v for k, v in request.items() if v is not None}
        
        return GetUserGroupsResponse.model_validate(
            await self.call_endpoint(url="user_groups", method="GET", request=payload)
        )

    async def create_user_group(self, group_data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(url="user_groups/create", method="POST", request=group_data)

    async def update_user_group(self, group_data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url="user_groups/{}".format(group_data["group_id"]),
            method="PATCH",
            request=group_data,
        )

    async def remove_user_group(self, group_id: int) -> Dict[str, Any]:
        return await self.call_endpoint(url=f"user_groups/{group_id}", method="DELETE")

    async def update_user_group_members(self, user_group_id: int, group_data: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(
            url=f"user_groups/{user_group_id}/members",
            method="POST",
            request=group_data,
        )

    async def get_subscribers(self, **request: Any) -> Dict[str, Any]:
        response = await self.get_stream_id(request["stream"])
        if response.get("result") == "error":
            return response
        stream_id = response["stream_id"]
        url = "streams/%d/members" % (stream_id,)
        return await self.call_endpoint(url=url, method="GET", request=request)

    async def render_message(self, request: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        return await self.call_endpoint(url="messages/render", method="POST", request=request)

    async def create_user(self, request: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        return await self.call_endpoint(method="POST", url="users", request=request)

    async def update_storage(self, request: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(url="bot_storage", method="PUT", request=request)

    async def get_storage(self, request: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        return await self.call_endpoint(url="bot_storage", method="GET", request=request)

    async def set_typing_status(self, request: Dict[str, Any]) -> Dict[str, Any]:
        return await self.call_endpoint(url="typing", method="POST", request=request)

    async def move_topic(
        self,
        stream: str,
        new_stream: str,
        topic: str,
        new_topic: Optional[str] = None,
        message_id: Optional[int] = None,
        propagate_mode: EditPropagateMode = "change_all",
        notify_old_topic: bool = True,
        notify_new_topic: bool = True,
    ) -> Dict[str, Any]:
        result = await self.get_stream_id(stream)
        if result.get("result") != "success":
            return result
        stream_id = result["stream_id"]

        result = await self.get_stream_id(new_stream)
        if result.get("result") != "success":
            return result
        new_stream_id = result["stream_id"]

        if message_id is None:
            if propagate_mode != "change_all":
                raise AttributeError('A message_id must be provided if propagate_mode is not "change_all"')
            result = await self.get_messages(
                {
                    "anchor": "newest",
                    "narrow": [
                        {"operator": "stream", "operand": stream_id},
                        {"operator": "topic", "operand": topic},
                    ],
                    "num_before": 1,
                    "num_after": 0,
                }
            )
            if result.get("result") != "success":
                return result
            if len(result.get("messages", [])) <= 0:
                return {"result": "error", "msg": f'No messages found in topic: "{topic}"'}
            message_id = result["messages"][0]["id"]

        request = {
            "stream_id": new_stream_id,
            "propagate_mode": propagate_mode,
            "topic": new_topic,
            "send_notification_to_old_thread": notify_old_topic,
            "send_notification_to_new_thread": notify_new_topic,
        }
        return await self.call_endpoint(url=f"messages/{message_id}", method="PATCH", request=request)

    async def aclose(self) -> None:
        if self.session:
            await self.session.aclose()
            self.session = None


class ZulipStream:
    def __init__(self, type: str, to: str, subject: str, **kwargs: Any) -> None:
        self.client = AsyncClient(**kwargs)
        self.type = type
        self.to = to
        self.subject = subject

    async def write(self, content: str) -> None:
        message = {"type": self.type, "to": self.to, "subject": self.subject, "content": content}
        await self.client.send_message(message)

    async def flush(self) -> None:
        pass


def hash_util_decode(string: str) -> str:
    return urllib.parse.unquote(string.replace(".", "%"))
