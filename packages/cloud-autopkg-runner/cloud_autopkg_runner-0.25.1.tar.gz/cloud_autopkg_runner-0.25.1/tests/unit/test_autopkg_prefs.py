"""Pytest unit tests for the AutoPkgPrefs class.

This module provides comprehensive tests for the AutoPkgPrefs class,
covering initialization, preference access (get/set and properties),
serialization to JSON, temporary file management, and error handling.
Hypothesis is utilized to generate diverse inputs for increased test
robustness, especially for type conversions and general preference
storage.
"""

import json
import math
import plistlib
from decimal import Decimal
from pathlib import Path
from typing import Any
from unittest.mock import Mock, patch

import pytest
from hypothesis import given
from hypothesis import strategies as st

from cloud_autopkg_runner import AutoPkgPrefs
from cloud_autopkg_runner.exceptions import (
    InvalidFileContents,
    PreferenceFileNotFoundError,
)


def exclude_nans(value: Any) -> bool:
    """Filters out NaN values from Hypothesis-generated data.

    This includes float NaNs, Decimal NaNs, and complex numbers where
    either the real or imaginary part is NaN.

    Args:
        value: The value to check for NaN.

    Returns:
        bool: True if the value does not contain NaN, False otherwise.
    """
    if isinstance(value, float):
        return not math.isnan(value)
    if isinstance(value, Decimal):
        return not value.is_nan()
    if isinstance(value, complex):
        # Check both the real and imaginary parts of the complex number
        return not (math.isnan(value.real) or math.isnan(value.imag))
    return True  # Keep other types that don't have NaN components


@pytest.fixture(autouse=True)
def mock_logging() -> Mock:
    """Fixture to mock the logger used by AutoPkgPrefs.

    Ensures that log messages generated by the AutoPkgPrefs class during tests
    do not pollute the console and can be inspected if necessary.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.logging_config.get_logger"
    ) as mock_get_logger:
        mock_logger = Mock()
        mock_get_logger.return_value = mock_logger
        yield mock_logger


# __init__


def test_init_with_default_file_not_found() -> None:
    """Test initialization when the default preference file does not exist.

    Verifies that AutoPkgPrefs initializes with only default preferences
    when the default path is not found, without raising an error.
    """
    with (
        patch(
            "pathlib.Path.read_bytes",
            side_effect=PreferenceFileNotFoundError(
                AutoPkgPrefs._DEFAULT_PREF_FILE_PATH
            ),
        ) as mock_read_bytes,
    ):
        with pytest.raises(PreferenceFileNotFoundError):
            _ = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)

        mock_read_bytes.assert_called_once_with()


def test_init_with_specified_file_not_found_raises_error() -> None:
    """Test initialization when a specified preference file does not exist.

    Verifies that a `PreferenceFileNotFoundError` is raised if a file
    explicitly provided to the constructor does not exist.
    """
    non_existent_path = Path("/tmp/non_existent_prefs.plist")
    with pytest.raises(PreferenceFileNotFoundError):
        AutoPkgPrefs(non_existent_path)


def test_init_with_valid_json_file(tmp_path: Path) -> None:
    """Test initialization with a valid JSON preference file.

    Verifies that preferences are correctly loaded and override defaults
    when provided in JSON format.
    """
    test_json_file = tmp_path / "test_prefs.json"
    test_json_content = json.dumps(
        {"GITHUB_TOKEN": "abc12345", "CACHE_DIR": "/tmp/test_cache"}
    )
    test_json_file.write_text(test_json_content, encoding="utf-8")

    prefs = AutoPkgPrefs(test_json_file)
    assert prefs.github_token == "abc12345"  # noqa: S105
    assert prefs.cache_dir == Path("/tmp/test_cache")
    # Ensure default prefs are still present if not overridden
    assert prefs.recipe_search_dirs == AutoPkgPrefs._convert_to_list_of_paths(
        AutoPkgPrefs._get_default_preferences()["RECIPE_SEARCH_DIRS"]
    )


def test_init_with_valid_plist_file(tmp_path: Path) -> None:
    """Test initialization with a valid Plist preference file.

    Verifies that preferences are correctly loaded and override defaults
    when provided in macOS plist format.
    """
    test_plist_file = tmp_path / "test_prefs.plist"
    test_plist_content = plistlib.dumps(
        {"MUNKI_REPO": "/Users/Shared/MunkiRepo", "SMB_USERNAME": "testuser"}
    )
    test_plist_file.write_bytes(test_plist_content)

    prefs = AutoPkgPrefs(test_plist_file)
    assert prefs.munki_repo == Path("/Users/Shared/MunkiRepo")
    assert prefs.smb_username == "testuser"
    # Ensure default prefs are still present if not overridden
    assert prefs.cache_dir == Path("~/Library/AutoPkg/Cache").expanduser()


def test_init_with_json_and_plist_like_keys(tmp_path: Path) -> None:
    """Test init with JSON and keys that look like plist.

    Ensures JSON parsing takes precedence if successful.
    """
    test_json_file = tmp_path / "test_prefs.json"
    # This content is valid JSON, but 'False' would be '0' in plist context
    test_json_content = json.dumps({"CLOUD_DP": False})
    test_json_file.write_text(test_json_content, encoding="utf-8")

    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(test_json_file)
    assert prefs.cloud_dp is False


def test_init_with_invalid_file_contents_raises_error(tmp_path: Path) -> None:
    """Test initialization with a file that is neither JSON nor Plist.

    Verifies that an `InvalidFileContents` error is raised when the
    preference file cannot be parsed.
    """
    invalid_file = tmp_path / "invalid_prefs.txt"
    invalid_file.write_text("This is not valid JSON or Plist.", encoding="utf-8")

    with pytest.raises(InvalidFileContents):
        AutoPkgPrefs(invalid_file)


# get() and set()


@given(
    key=st.text(
        min_size=1, alphabet=st.characters(exclude_categories=("Cs",))
    ),  # Avoid emojis, etc.
    value=st.from_type(object).filter(exclude_nans),
)
def test_get_set_arbitrary_preferences(key: str, value: Any) -> None:
    """Test setting and getting arbitrary preferences with various types.

    Uses Hypothesis to generate diverse keys and values to ensure the
    basic `get()` and `set()` methods are robust.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs()

    # Test setting a value
    prefs.set(key, value)
    assert prefs.get(key) == value

    # Test default value if key is not found
    non_existent_key = f"NON_EXISTENT_{key}"
    assert prefs.get(non_existent_key, "default_value") == "default_value"
    assert prefs.get(non_existent_key) is None  # Default is None

    # Ensure setting None works
    prefs.set(key, None)
    assert prefs.get(key) is None

    # Test setting a list
    list_val = [1, "two", True]
    prefs.set(key, list_val)
    assert prefs.get(key) == list_val

    # Test setting a dict
    dict_val = {"a": 1, "b": "two"}
    prefs.set(key, dict_val)
    assert prefs.get(key) == dict_val


# Property Getters/Setters (Path-related)


@given(
    path_input=st.one_of(
        st.text(min_size=1).map(lambda s: f"~/test_dir/{s}"),
        st.builds(Path, st.text(min_size=1)).map(
            lambda p: Path(f"~/test_path_obj/{p}")
        ),
    )
)
def test_cache_dir_property(path_input: str | Path) -> None:
    """Test `cache_dir` getter and setter with string and Path inputs.

    Uses Hypothesis to generate various path-like strings and Path objects
    to ensure robust type conversion and expansion.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs()

    prefs.cache_dir = path_input
    expected_path = Path(path_input).expanduser()
    assert prefs.cache_dir == expected_path
    assert type(prefs.get("CACHE_DIR")) is str


@given(
    paths_input=st.one_of(
        # Strategy 1: Single path as a string
        st.text(min_size=1).map(lambda path_str: f"~/single_recipe/{path_str}"),
        # Strategy 2: Single path as a Path object
        st.builds(Path, st.text(min_size=1)).map(
            lambda path_obj: Path(f"~/single_recipe_path/{path_obj}")
        ),
        # Strategy 3: List of paths as strings
        st.lists(st.text(min_size=1)).map(
            lambda list_of_path_strs: [f"~/list_recipe/{s}" for s in list_of_path_strs]
        ),
        # Strategy 4: List of paths as Path objects
        st.lists(st.builds(Path, st.text(min_size=1))).map(
            lambda list_of_path_objs: [
                Path(f"~/list_recipe_path/{p}") for p in list_of_path_objs
            ]
        ),
    )
)
def test_recipe_search_dirs_property(paths_input: Any) -> None:
    """Test `recipe_search_dirs` getter and setter.

    Uses Hypothesis to generate single paths or lists of paths in various
    forms (strings, Path objects) to ensure correct conversion and storage.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)

    prefs.recipe_search_dirs = paths_input
    expected_paths = AutoPkgPrefs._convert_to_list_of_paths(paths_input)
    assert prefs.recipe_search_dirs == expected_paths
    # Verify underlying storage is a list of strings
    assert prefs.get("RECIPE_SEARCH_DIRS") == [str(p) for p in expected_paths]

    # Test setting to an empty list
    prefs.recipe_search_dirs = []
    assert prefs.recipe_search_dirs == []
    assert prefs.get("RECIPE_SEARCH_DIRS") == []


@given(
    paths_input=st.one_of(
        # Strategy 1: Generates a single override path as a string.
        st.text(min_size=1).map(
            lambda override_str: f"~/single_override/{override_str}"
        ),
        # Strategy 2: Generates a single override path as a Path object.
        st.builds(Path, st.text(min_size=1)).map(
            lambda override_path_obj: Path(
                f"~/single_override_path/{override_path_obj}"
            )
        ),
        # Strategy 3: Generates a list of override paths as strings.
        st.lists(st.text(min_size=1)).map(
            lambda list_of_override_strs: [
                f"~/list_override/{s}" for s in list_of_override_strs
            ]
        ),
        # Strategy 4: Generates a list of override paths as Path objects.
        st.lists(st.builds(Path, st.text(min_size=1))).map(
            lambda list_of_override_objs: [
                Path(f"~/list_override_path/{p}") for p in list_of_override_objs
            ]
        ),
    )
)
def test_recipe_override_dirs_property(paths_input: Any) -> None:
    """Test `recipe_override_dirs` getter and setter."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)

    prefs.recipe_override_dirs = paths_input
    expected_paths = AutoPkgPrefs._convert_to_list_of_paths(paths_input)
    assert prefs.recipe_override_dirs == expected_paths
    assert prefs.get("RECIPE_OVERRIDE_DIRS") == [str(p) for p in expected_paths]

    # Test setting to an empty list
    prefs.recipe_override_dirs = []
    assert prefs.recipe_override_dirs == []
    assert prefs.get("RECIPE_OVERRIDE_DIRS") == []


@given(
    path_input=st.one_of(
        st.none(),
        st.text(min_size=1).map(lambda s: f"/Volumes/Munki/{s}"),
        st.builds(Path, st.text(min_size=1)).map(lambda p: Path(f"/MunkiRepo/{p}")),
    )
)
def test_munki_repo_property(path_input: str | Path | None) -> None:
    """Test `munki_repo` getter and setter including None.

    Uses Hypothesis to generate `None`, string paths, and Path objects.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs()

    # Initially, it should be None, as it's not a default preference
    assert prefs.munki_repo is None

    prefs.munki_repo = path_input
    if path_input is None:
        assert prefs.munki_repo is None
        assert prefs.get("MUNKI_REPO") is None
    else:
        expected_path = Path(path_input).expanduser()
        assert prefs.munki_repo == expected_path
        assert type(prefs.get("MUNKI_REPO")) is str


# Property Getters/Setters (string-related)


@pytest.mark.parametrize(
    ("prop_name", "key_name"),
    [
        ("github_token", "GITHUB_TOKEN"),
        ("smb_url", "SMB_URL"),
        ("smb_username", "SMB_USERNAME"),
        ("smb_password", "SMB_PASSWORD"),
        ("patch_url", "PATCH_URL"),
        ("patch_token", "PATCH_TOKEN"),
        ("title_url", "TITLE_URL"),
        ("title_user", "TITLE_USER"),
        ("title_pass", "TITLE_PASS"),
        ("jc_api", "JC_API"),
        ("jc_org", "JC_ORG"),
        ("fw_server_host", "FW_SERVER_HOST"),
        ("fw_server_port", "FW_SERVER_PORT"),
        ("fw_admin_user", "FW_ADMIN_USER"),
        ("fw_admin_password", "FW_ADMIN_PASSWORD"),
        ("bes_root_server", "BES_ROOT_SERVER"),
        ("bes_username", "BES_USERNAME"),
        ("bes_password", "BES_PASSWORD"),
        ("client_id", "CLIENT_ID"),
        ("client_secret", "CLIENT_SECRET"),
        ("tenant_id", "TENANT_ID"),
        ("virustotal_api_key", "VIRUSTOTAL_API_KEY"),
        ("fleet_api_base", "FLEET_API_BASE"),
        ("fleet_api_token", "FLEET_API_TOKEN"),
        ("fleet_team_id", "FLEET_TEAM_ID"),
        ("aws_s3_bucket", "AWS_S3_BUCKET"),
        ("aws_cloudfront_domain", "AWS_CLOUDFRONT_DOMAIN"),
        ("aws_access_key_id", "AWS_ACCESS_KEY_ID"),
        ("aws_secret_access_key", "AWS_SECRET_ACCESS_KEY"),
        ("aws_default_region", "AWS_DEFAULT_REGION"),
        ("fleet_gitops_repo_url", "FLEET_GITOPS_REPO_URL"),
        ("fleet_gitops_github_token", "FLEET_GITOPS_GITHUB_TOKEN"),
        ("fleet_gitops_software_dir", "FLEET_GITOPS_SOFTWARE_DIR"),
        ("fleet_gitops_team_yaml_path", "FLEET_GITOPS_TEAM_YAML_PATH"),
    ],
)
@given(value=st.one_of(st.none(), st.text()))
def test_string_properties(prop_name: str, key_name: str, value: str | None) -> None:
    """Test common string properties for getters/setters.

    Uses pytest.mark.parametrize and Hypothesis to test all string-based
    properties with varying string values and None.
    """
    # Create a new AutoPkgPrefs instance for each Hypothesis example
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    # Initial state should be None
    assert getattr(prefs, prop_name) is None
    assert prefs.get(key_name) is None

    setattr(prefs, prop_name, value)
    assert getattr(prefs, prop_name) == value
    assert prefs.get(key_name) == value


# Property Getters/Setters (Complex structures)


@given(
    shares=st.one_of(
        st.none(),
        st.lists(
            st.dictionaries(
                keys=st.text(min_size=1),
                values=st.text(),
                min_size=1,
                max_size=5,
            ),
            min_size=0,
            max_size=3,
        ),
    )
)
def test_smb_shares_property(shares: list[dict[str, str]] | None) -> None:
    """Test `smb_shares` getter and setter.

    Uses Hypothesis to generate various lists of dictionaries or None
    to ensure complex data structures are handled correctly.
    A new AutoPkgPrefs instance is created for each Hypothesis example.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)

    assert prefs.smb_shares is None  # Not a default pref

    prefs.smb_shares = shares
    assert prefs.smb_shares == shares
    assert prefs.get("SMB_SHARES") == shares

    # Test a specific structure
    specific_shares = [
        {"name": "Share1", "path": "/path/to/share1"},
        {"name": "Share2", "url": "smb://server/share2"},
    ]
    prefs.smb_shares = specific_shares
    assert prefs.smb_shares == specific_shares
    assert prefs.get("SMB_SHARES") == specific_shares


# Property Getters/Setters (Booleans)


@pytest.mark.parametrize(
    ("prop_name", "key_name", "default_value"),
    [
        (
            "fail_recipes_without_trust_info",
            "FAIL_RECIPES_WITHOUT_TRUST_INFO",
            False,
        ),
        ("stop_if_no_jss_upload", "STOP_IF_NO_JSS_UPLOAD", False),
        ("cloud_dp", "CLOUD_DP", False),
        ("gitops_mode", "GITOPS_MODE", False),
    ],
)
@given(
    value=st.one_of(
        st.booleans(),  # Direct boolean input
        st.text().filter(
            lambda s: s.lower()
            in {"1", "true", "yes", "0", "false", "no", "anything else"}
        ),  # String inputs
        st.integers(),  # Integer inputs
        st.floats(
            allow_nan=False, allow_infinity=False
        ),  # Float inputs (excluding NaN/infinity)
    )
)
def test_boolean_properties_robustness(
    prop_name: str,
    key_name: str,
    default_value: bool,
    value: Any,
) -> None:
    """Test boolean properties with various types of input values.

    Uses pytest.mark.parametrize and Hypothesis to exhaustively test
    how the `_get_bool_pref` helper interprets different types and
    string representations for boolean properties.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)

    # Test setter with actual boolean
    setattr(prefs, prop_name, True)
    assert getattr(prefs, prop_name) is True
    setattr(prefs, prop_name, False)
    assert getattr(prefs, prop_name) is False

    # Test getter with various values from raw preferences
    prefs.set(key_name, value)

    expected_true_strings = {"1", "true", "yes"}

    if isinstance(value, bool):
        expected = value
    elif isinstance(value, str):
        expected = value.lower() in expected_true_strings
    else:  # int, float, or other
        expected = bool(value)

    assert getattr(prefs, prop_name) == expected

    # Test default value if key is not present
    prefs._prefs.pop(key_name, None)  # Remove the key
    assert getattr(prefs, prop_name) == default_value


# to_json and to_json_file


@given(
    prefs_data=st.dictionaries(
        keys=st.text(min_size=1, max_size=10),
        values=st.recursive(
            st.none() | st.booleans() | st.integers() | st.text(max_size=20),
            lambda children: st.lists(children, min_size=0, max_size=5)
            | st.dictionaries(
                st.text(min_size=1, max_size=10), children, min_size=0, max_size=5
            ),
        ),
        min_size=0,
        max_size=5,
    )
)
def test_to_json(prefs_data: dict[str, Any]) -> None:
    """Test serialization of preferences to a JSON string.

    Uses Hypothesis to generate diverse dictionary structures to ensure
    `to_json` handles various data types correctly.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs()

    # Start with an empty prefs object and populate it
    prefs._prefs.update(prefs_data)  # Add generated data

    # Add some known defaults that should always be there
    default_prefs = prefs._get_default_preferences()
    # Ensure that values that are Path objects are converted
    # to strings for JSON serialization.
    for key, value in default_prefs.items():
        if isinstance(value, Path):
            prefs._prefs.setdefault(key, str(value))
        elif isinstance(value, list) and all(isinstance(v, Path) for v in value):
            prefs._prefs.setdefault(key, [str(v) for v in value])
        else:
            prefs._prefs.setdefault(key, value)

    json_str = prefs.to_json(indent=None)  # Test compact output
    loaded_json = json.loads(json_str)

    # Ensure all items (generated and default) are present and correctly serialized
    for (
        key,
        value,
    ) in prefs._prefs.items():  # Iterate over the actual internal _prefs
        assert loaded_json[key] == value

    json_str_indented = prefs.to_json(indent=2)
    assert "\n" in json_str_indented  # Check for indentation


@pytest.mark.asyncio
async def test_to_json_file() -> None:
    """Test serialization to a temporary JSON file.

    Verifies file creation, content, and the cleanup mechanism.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs()
    prefs.github_token = "file_token_123"  # noqa: S105
    prefs.set("ANOTHER_KEY", ["item1", "item2"])
    prefs.munki_repo = Path("/tmp/munki")

    # Use the context manager to ensure cleanup
    with prefs:
        temp_file_path = await prefs.to_json_file(indent=2)
        assert prefs._temp_json_file_path is not None
        assert temp_file_path.exists()
        assert temp_file_path.is_file()
        assert temp_file_path == prefs._temp_json_file_path

        content = temp_file_path.read_text(encoding="utf-8")
        loaded_json = json.loads(content)
        assert loaded_json["GITHUB_TOKEN"] == "file_token_123"  # noqa: S105
        assert loaded_json["ANOTHER_KEY"] == ["item1", "item2"]
        assert loaded_json["MUNKI_REPO"] == "/tmp/munki"
        # Ensure default prefs are also included
        assert "CACHE_DIR" in loaded_json
        assert isinstance(loaded_json["CACHE_DIR"], str)

    # After exiting context, file should be gone
    assert not temp_file_path.exists()
    assert prefs._temp_json_file_path is None


@pytest.mark.asyncio
async def test_to_json_file_multiple_calls_cleans_up_old() -> None:
    """Test that calling `to_json_file` multiple times cleans up previous files.

    Verifies that only the most recent temporary file persists until
    cleanup or context exit.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs()
    prefs.github_token = "first_token"  # noqa: S105

    temp_file_path1 = await prefs.to_json_file()
    assert temp_file_path1.exists()

    prefs.github_token = "second_token"  # noqa: S105
    temp_file_path2 = await prefs.to_json_file()

    assert not temp_file_path1.exists()  # Old file should be gone
    assert temp_file_path2.exists()
    assert temp_file_path1 != temp_file_path2  # Should be a new file

    content = temp_file_path2.read_text(encoding="utf-8")
    loaded_json = json.loads(content)
    assert loaded_json["GITHUB_TOKEN"] == "second_token"  # noqa: S105

    prefs.cleanup_temp_file()  # Manual cleanup after test
    assert not temp_file_path2.exists()
    assert prefs._temp_json_file_path is None


# __enter__, __exit__, and cleanup_temp_file()


@pytest.mark.asyncio
async def test_context_manager_cleanup() -> None:
    """Test that the context manager automatically cleans up temporary files.

    Ensures that `__exit__` logic properly removes the created file.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs()
    temp_file_path: Path | None = None

    with prefs:
        prefs.github_token = "context_token"  # noqa: S105
        temp_file_path = await prefs.to_json_file()
        assert temp_file_path.exists()
        assert prefs._temp_json_file_path == temp_file_path

    # File should be deleted after exiting the 'with' block
    assert not temp_file_path.exists()
    assert prefs._temp_json_file_path is None


def test_cleanup_temp_file_no_file() -> None:
    """Test `cleanup_temp_file` when no temporary file exists.

    Ensures it runs without error and leaves state clean.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)

    # Ensure _temp_json_file_path is truly None, in case fixture setup changes it
    prefs._temp_json_file_path = None
    assert prefs._temp_json_file_path is None
    prefs.cleanup_temp_file()
    assert prefs._temp_json_file_path is None


def test_cleanup_temp_file_error(mock_logging: Mock, tmp_path: Path) -> None:
    """Test `cleanup_temp_file` handles errors during file deletion.

    Verifies that `OSError` during unlink is caught and logged, and
    the internal path is still reset.
    """
    # Create a sample temporary file path for the test
    sample_temp_path = tmp_path / "sample_temp_prefs.json"
    sample_temp_path.touch()  # Create a physical file

    # Manually set the internal _temp_json_file_path for the instance
    # We need a new instance for isolated testing.
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    prefs._temp_json_file_path = sample_temp_path

    # Mock Path.unlink to raise an OSError
    with patch.object(Path, "unlink", side_effect=OSError("Permission denied")):
        prefs.cleanup_temp_file()
        # Verify that unlink was called and a warning was logged
        Path.unlink.assert_called_once()  # type: ignore
        mock_logging.warning.assert_called_once()
        # Despite the error, the internal tracking path should be cleared
        assert prefs._temp_json_file_path is None
    # The physical sample file created initially should still exist due to the mock
    assert sample_temp_path.exists()
    sample_temp_path.unlink(missing_ok=True)  # Clean it up for real


# __repr__


def test_repr_redacts_sensitive_info() -> None:
    """Test that `__repr__` redacts sensitive preference values.

    Ensures that tokens and passwords are not exposed in the string
    representation.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    prefs.github_token = "secret_gh_token"  # noqa: S105
    prefs.smb_password = "super_secret_smb_pass"  # noqa: S105
    prefs.set("NON_SENSITIVE_KEY", "public_value")
    prefs.set("ANOTHER_SENSITIVE_KEY_NOT_IN_PROPERTY", "very_secret_data")
    prefs.set("ANOTHER_SECRET", "another_secret_value")

    repr_output = repr(prefs)

    assert "GITHUB_TOKEN': '<redacted>'" in repr_output
    assert "SMB_PASSWORD': '<redacted>'" in repr_output
    assert "NON_SENSITIVE_KEY': 'public_value'" in repr_output
    assert "ANOTHER_SENSITIVE_KEY_NOT_IN_PROPERTY': 'very_secret_data'" in repr_output

    assert "secret_gh_token" not in repr_output
    assert "super_secret_smb_pass" not in repr_output
    assert "another_secret_value" not in repr_output


# _convert_to_list_of_paths()


@given(
    value=st.one_of(
        # Strategy 1: Generates a single path as a string.
        st.text().map(lambda path_str: f"~/single/{path_str}"),
        # Strategy 2: Generates a single path as a Path object.
        st.builds(Path, st.text(min_size=1)).map(
            lambda path_obj: Path(f"~/single_path/{path_obj}")
        ),
        # Strategy 3: Generates a list of paths as strings.
        st.lists(st.text()).map(
            lambda list_of_path_strs: [f"~/list_str/{s}" for s in list_of_path_strs]
        ),
        # Strategy 4: Generates a list of paths as Path objects.
        st.lists(st.builds(Path, st.text())).map(
            lambda list_of_path_objs: [
                Path(f"~/list_path/{p}") for p in list_of_path_objs
            ]
        ),
        # Strategy 5: Generates an empty list of paths.
        st.lists(st.text(), min_size=0, max_size=0),
        # Strategy 6: Generates a Path object representing the user's home directory.
        st.just(Path("~")),
    )
)
def test_convert_to_list_of_paths(value: Any) -> None:
    """Test `_convert_to_list_of_paths` handles various inputs correctly.

    Uses Hypothesis to ensure robust conversion of single strings/Paths
    and lists of strings/Paths into expanded Path objects.
    """
    result = AutoPkgPrefs._convert_to_list_of_paths(value)
    assert isinstance(result, list)

    if not value:  # Empty list or other falsy input
        assert result == []
        return

    for p in result:
        assert isinstance(p, Path)
        # Check for user expansion. Note: Path("~").expanduser() could vary
        # based on OS, but typically starts with Path.home()
        assert str(p).startswith(str(Path.home()))

    # Ensure that if a single path is given, it results in a list of one Path
    if not isinstance(value, list):
        assert len(result) == 1
        assert result[0] == Path(value).expanduser()
    else:
        assert len(result) == len(value)
        for i, item in enumerate(value):
            assert result[i] == Path(item).expanduser()


# _get_bool_pref()


@pytest.mark.parametrize(
    ("pref_value", "expected_bool", "default_value"),
    [
        (True, True, False),
        (False, False, True),
        ("1", True, False),
        ("true", True, False),
        ("TRUE", True, False),
        ("yes", True, False),
        ("YES", True, False),
        ("0", False, True),
        ("false", False, True),
        ("FALSE", False, True),
        ("no", False, True),
        ("NO", False, True),
        ("anything else", False, True),
        (1, True, False),
        (0, False, True),
        (123, True, False),
        (0.0, False, True),
        (0.5, True, False),
        (None, False, True),  # When key is missing, default is used
    ],
)
def test_get_bool_pref_manual_inputs(
    pref_value: Any, expected_bool: bool, default_value: bool
) -> None:
    """Test `_get_bool_pref` with manually specified values.

    Ensures explicit handling of various truthy/falsy representations.
    """
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    key = "TEST_BOOL_KEY"

    if pref_value is not None:
        prefs._prefs[key] = pref_value
        result = prefs._get_bool_pref(key, default=default_value)
        assert result == expected_bool
    else:
        # Test when key is missing, ensuring default is applied
        if key in prefs._prefs:
            del prefs._prefs[key]
        result = prefs._get_bool_pref(key, default=default_value)
        assert result == default_value


# _get_path_pref()


def test_get_path_pref() -> None:
    """Test `_get_path_pref` returns an expanded Path."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    prefs._prefs["TEST_PATH"] = "~/Documents/test"
    assert prefs._get_path_pref("TEST_PATH") == Path("~/Documents/test").expanduser()


# _set_path_pref()


def test_set_path_pref() -> None:
    """Test `_set_path_pref` stores path as a string."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    test_path = Path("/usr/local/bin")
    prefs._set_path_pref("TEST_PATH", test_path)
    assert prefs._prefs["TEST_PATH"] == str(test_path)
    prefs._set_path_pref("TEST_PATH_STR", "/tmp/another")
    assert prefs._prefs["TEST_PATH_STR"] == "/tmp/another"


# _get_list_of_paths_pref()


def test_get_list_of_paths_pref() -> None:
    """Test `_get_list_of_paths_pref` returns a list of expanded Paths."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    prefs._prefs["TEST_PATHS"] = ["~/Downloads", "/var/log"]
    expected = [Path("~/Downloads").expanduser(), Path("/var/log").expanduser()]
    assert prefs._get_list_of_paths_pref("TEST_PATHS") == expected


# _set_list_of_paths_pref()


def test_set_list_of_paths_pref() -> None:
    """Test `_set_list_of_paths_pref` stores paths as list of strings."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    test_paths_input = [Path("~/Music"), "/opt/apps"]
    prefs._set_list_of_paths_pref("TEST_PATHS", test_paths_input)
    expected_stored = [
        str(Path("~/Music").expanduser()),
        str(Path("/opt/apps").expanduser()),
    ]
    assert prefs._prefs["TEST_PATHS"] == expected_stored


# _get_str_pref()


def test_get_str_pref() -> None:
    """Test `_get_str_pref` returns string or None."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    prefs._prefs["TEST_STR"] = "hello world"
    assert prefs._get_str_pref("TEST_STR") == "hello world"
    assert prefs._get_str_pref("NON_EXISTENT") is None


# _set_str_pref()


def test_set_str_pref() -> None:
    """Test `_set_str_pref` stores string or None."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        prefs = AutoPkgPrefs(AutoPkgPrefs._DEFAULT_PREF_FILE_PATH)
    prefs._set_str_pref("TEST_STR", "new value")
    assert prefs._prefs["TEST_STR"] == "new value"
    prefs._set_str_pref("TEST_STR", None)
    assert prefs._prefs["TEST_STR"] is None


# clone()


def test_clone(tmp_path: Path) -> None:
    """Test cloning an instance with no preferences."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        original_prefs = AutoPkgPrefs()

    original_prefs.cache_dir = tmp_path
    original_prefs.set("foo1", "bar1")

    original_prefs.set("foo2", "original")
    cloned_prefs = original_prefs.clone()
    cloned_prefs.set("foo2", "cloned")

    assert cloned_prefs is not original_prefs
    assert isinstance(cloned_prefs, AutoPkgPrefs)

    assert original_prefs.cache_dir == tmp_path
    assert cloned_prefs.cache_dir == tmp_path

    assert original_prefs.get("foo1") == "bar1"
    assert cloned_prefs.get("foo1") == "bar1"

    assert original_prefs.get("foo2") == "original"
    assert cloned_prefs.get("foo2") == "cloned"


@pytest.mark.asyncio
async def test_clone_tmp_file_none() -> None:
    """Test cloning an instance with no preferences."""
    with patch(
        "cloud_autopkg_runner.autopkg_prefs.AutoPkgPrefs._get_preference_file_contents",
        return_value={},
    ):
        original_prefs = AutoPkgPrefs()

        await original_prefs.to_json_file()
        assert original_prefs._temp_json_file_path is not None

        cloned_prefs = original_prefs.clone()
        assert cloned_prefs._temp_json_file_path is None
