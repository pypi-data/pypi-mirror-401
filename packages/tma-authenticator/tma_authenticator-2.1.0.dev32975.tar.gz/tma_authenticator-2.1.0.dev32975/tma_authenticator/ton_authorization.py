import base64
import hashlib
import time
from dataclasses import dataclass
from pytoniq_core.boc import Cell
from pytoniq_core.tlb.account import Address
from nacl.signing import VerifyKey
from nacl.exceptions import BadSignatureError
import logging


logger = logging.getLogger(__name__)


def sha256(b: bytes) -> bytes:
    return hashlib.sha256(b).digest()


def int32_be(n: int) -> bytes:
    return int(n).to_bytes(4, byteorder="big", signed=True)


def uint32_le(n: int) -> bytes:
    return int(n).to_bytes(4, byteorder="little", signed=False)


def int64_le(n: int) -> bytes:
    return int(n).to_bytes(8, byteorder="little", signed=True)


@dataclass(frozen=True)
class TonAddress:
    workchain: int
    addr_hash: bytes  # 32 bytes


def parse_raw_address(addr: str) -> TonAddress:
    a = Address(addr)
    return TonAddress(workchain=a.wc, addr_hash=a.hash_part)


def build_ton_proof_message(address: TonAddress, domain: str, timestamp: int, payload: str) -> bytes:
    prefix = b"ton-proof-item-v2/"
    domain_bytes = domain.encode("utf-8")
    payload_bytes = payload.encode("utf-8")

    # Address = workchain(int32 BE) + hash(256-bit BE -> raw 32 bytes)
    address_bytes = int32_be(address.workchain) + address.addr_hash

    # AppDomain = len(domain)(uint32 LE) + domain_bytes
    domain_part = uint32_le(len(domain_bytes)) + domain_bytes

    # Timestamp = int64 LE (seconds)
    ts_part = int64_le(timestamp)

    msg = prefix + address_bytes + domain_part + ts_part + payload_bytes
    return msg


def build_signed_hash(message: bytes) -> bytes:
    # signature is over sha256(0xffff ++ "ton-connect" ++ sha256(message))
    inner = sha256(message)
    to_sign = b"\xff\xff" + b"ton-connect" + inner
    return sha256(to_sign)


def _cell_has_wallet_data_layout(cell: Cell) -> bool:
    s = cell.begin_parse()

    # pytoniq Slice exposes bits left via one of these (version dependent)
    bits_left = getattr(s, "remaining_bits", None)
    if bits_left is None:
        bits_left = getattr(s, "bits_left", None)

    assert bits_left is not None, "Cannot determine bits left in cell"

    return bits_left >= (32 + 32 + 256)


def validate_state_init_and_public(
        pub: bytes,
        wallet_state_init_b64: str,
        address: TonAddress
):
    state_init_boc = base64.b64decode(wallet_state_init_b64)
    state_init = Cell.one_from_boc(state_init_boc)

    assert state_init.hash == address.addr_hash, "Address doesn't match stateInit"

    s = state_init.begin_parse()
    if s.load_bool():
        s.load_uint(5)
    if s.load_bool():
        s.load_bool()
        s.load_bool()

    code = s.load_ref() if s.load_bool() else None
    data = s.load_ref() if s.load_bool() else None

    assert code is not None and data is not None, "StateInit must contain both code and data"

    pubkey_found = False
    for offset in range(33):
        ds = data.begin_parse()
        if offset > 0:
            ds.load_uint(offset)
        ds.load_uint(32)
        ds.load_uint(32)

        bits_left = getattr(ds, 'remaining_bits', getattr(ds, 'bits_left', 0))
        if bits_left < 256:
            continue

        stored_pubkey = ds.load_bytes(32)
        if stored_pubkey == pub:
            pubkey_found = True
            break

    if not pubkey_found:
        data_bytes = getattr(data.bits, 'to_bytes', lambda: None)()
        if data_bytes and data_bytes.find(pub) != -1:
            pubkey_found = True

    assert pubkey_found, f"Public key {pub.hex()} not found in wallet data"


def verify_ton_proof(
        *,
        address_raw: str,
        public_key_hex: str,
        domain_value: str,
        domain_length_bytes: int,
        timestamp: int,
        payload: str,
        signature_b64: str,
        expected_payload: str,
        wallet_state_init_b64: str,
        max_skew_seconds: int = 300,  # 5 minutes
) -> None:
    # 1) Basic data format checks: address is valid, signatures is Ed25519
    address = parse_raw_address(address_raw)
    sig = base64.b64decode(signature_b64)
    pub = bytes.fromhex(public_key_hex)
    assert len(pub) == 32, f"publicKey must be 32 bytes, got {len(pub)}"
    assert len(sig) == 64, f"signature must be 64 bytes, got {len(sig)}"

    # 2) Skip domain checks, becuase it always t.me which is useless to check
    #     domain_bytes = domain_value.encode("utf-8")
    #     assert domain_length_bytes == len(domain_bytes), (
    #         f"domain.lengthBytes mismatch: got {domain_length_bytes}, expected {len(domain_bytes)}"
    #     )

    # 3) Verify expiration
    now = int(time.time())
    assert abs(now - int(timestamp)) <= max_skew_seconds, (
        f"timestamp outside window: now={now}, ts={timestamp}, skew={abs(now - int(timestamp))}s"
    )

    # 4) Check nonce was generated by us (verify payload matches expected nonce)
    assert payload == expected_payload, "payload mismatch (replay / wrong session / wrong nonce)"

    # 5) Rebuild message and hashes exactly as TON Connect does for proof generation
    msg = build_ton_proof_message(address, domain_value, int(timestamp), payload)
    msg_hash = sha256(msg)
    signed_hash = build_signed_hash(msg)
    # And this we got to verify
    # logger.debug("address.workchain:", address.workchain)
    # logger.debug("address.hash_hex:", address.addr_hash.hex())
    # logger.debug("domain:", domain_value)
    # logger.debug("timestamp:", timestamp)
    # logger.debug("payload:", payload)
    # logger.debug("message_hex:", msg.hex())
    # logger.debug("sha256(message):", msg_hash.hex())
    # logger.debug("signed_hash_hex:", signed_hash.hex())

    # 6) Verify that ton proof was generated exactly for the data it signed
    vk = VerifyKey(pub)
    try:
        vk.verify(signed_hash, sig)
    except BadSignatureError:
        raise AssertionError("BadSignatureError: ton_proof signature is invalid")

    logger.debug("âœ… ton_proof signature verified for provided publicKey")

    # 7) Check that public key matches wallet address
    validate_state_init_and_public(pub, wallet_state_init_b64, address)


# if __name__ == "__main__":
    request_items = {
        "ton_addr": {
            "address": "0:0e911c7660c80c50f9a817dc9adcf57da50ef06c92c8702e88dd792075abc8bf",
            "network": "-3",
            "publicKey": "b3e15565d224fcb30998d1ec59daff3992cd0f9d94c00b8bb4ebb7d2dda0b397",
            "walletStateInit": "te6cckECFgEAArEAAgE0AgEAUYAAAAA////+2fCqsukSflmEzGj2LO1/nMlmh87KYAXF2nXb6W7QWcugART/APSkE/S88sgLAwIBIAYEAQLyBQEeINcLH4IQc2lnbrry4Ip/DAIBSAsHAgEgCBUCASASCQIBSBEKABGyYvtRNDXCgCAC3NAg10nBIJFbj2Mg1wsfIIIQZXh0br0hghBzaW50vbCSXwPgghBleHRuuo60gCDXIQHQdNch+kAw+kT4KPpEMFi9kVvg7UTQgQFB1yH0BYMH9A5voTGRMOGAQNchcH/bPOAxINdJgQKAuZEw4HDiDQwB5o7w7aLt+yGDCNciAoMI1yMggCDXIdMf0x/TH+1E0NIA0x8g0x/T/9cKAAr5AUDM+RCaKJRfCtsx4fLAh98Cs1AHsPLQhFEluvLghVA2uvLghvgju/LQiCKS+ADeAaR/yMoAyx8BzxbJ7VQgkvgP3nDbPNgNA/btou37AvQEIW6SbCGOTAIh1zkwcJQhxwCzji0B1yggdh5DbCDXScAI8uCTINdKwALy4JMg1x0GxxLCAFIwsPLQiddM1zkwAaTobBKEB7vy4JPXSsAA8uCT7VXi0gABwACRW+Dr1ywIFCCRcJYB1ywIHBLiUhCx4w8g10oQDw4AEJNb2zHh10zQAHIw1ywIJI4tIfLgktIA7UTQ0gBRE7ry0I9UUDCRMZwBgQFA1yHXCgDy4I7iyMoAWM8Wye1Uk/LAjeIAlgH6QAH6RPgo+kQwWLry4JHtRNCBAUHXGPQFBJ1/yMoAQASDB/RT8uCLjhQDgwf0W/LgjCLXCgAhbgGzsPLQkOLIUAPPFhL0AMntVAAXsyX7UTQcdch1wsfgAgFuFBMAGa8d9qJoQBDrkOuFj8AAGa3OdqJoQCDrkOuF/8AAGb5fD2omhAgKDrkPoCziNDnV"
        },
        "ton_proof": {
            "proof": {"domain": {"lengthBytes": 4, "value": "t.me"}, "signature": "rl09mIgRTKCeasSuep8EQ3OoJhGdzIfS0c80GlagS/GgoiR1Dl1VhuDuDVx3Xd/jYXRgeZKajP9/1IHHJ4QiCA==", "payload": "4O97SQte_OMjgHl0ItCd-84AMkkZtplawLSjfUDA1A4", "timestamp": 1766499553}
        },
    }
#
#     expected_payload = "2025-12-22T14:55:08.825Z"
#
#     verify_ton_proof(
#         address_raw=request_items["ton_addr"]["address"],
#         public_key_hex=request_items["ton_addr"]["publicKey"],
#         domain_value=request_items["ton_proof"]["proof"]["domain"]["value"],
#         domain_length_bytes=request_items["ton_proof"]["proof"]["domain"]["lengthBytes"],
#         timestamp=request_items["ton_proof"]["proof"]["timestamp"],
#         payload=request_items["ton_proof"]["proof"]["payload"],
#         signature_b64=request_items["ton_proof"]["proof"]["signature"],
#         expected_payload=expected_payload,
#         wallet_state_init_b64=request_items["ton_addr"]["walletStateInit"],
#         max_skew_seconds=10000,
#     )
