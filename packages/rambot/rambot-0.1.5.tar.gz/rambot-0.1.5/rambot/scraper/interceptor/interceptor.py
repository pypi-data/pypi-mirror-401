import os
import subprocess

from typing import Optional, Callable, List
from ...types import IInterceptor, Request


class Interceptor(IInterceptor):
    """
    Concrete implementation of a request interceptor using mitmproxy.

    This class manages the lifecycle of a mitmproxy process to capture network 
    traffic generated by the scraper's browser. Traffic is logged to a temporary 
    JSONL file for post-processing.
    """

    def start(self) -> None:
        """
        Initialize and start the mitmproxy subprocess.

        - Cleans up any existing interceptor log files.
        - Configures and launches 'mitmdump' with a custom script.
        - Sets up environment variables to communicate the log path to the script.
        """
        try:
            os.remove(self._requests_path)
        except FileNotFoundError:
            pass

        script_path = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "mitmproxy_interceptor.py")
        )

        mitmproxy_command = [
            "mitmdump",
            "-s", script_path,
            "--set", f"requests_path={self._requests_path}",
            "--listen-port", str(self._scraper.proxy_port()),
            "--ssl-insecure",
            "--quiet"
        ]

        env = os.environ.copy()
        env["REQUESTS_PATH"] = self._requests_path

        subprocess.Popen(mitmproxy_command, env=env)

    def stop(self) -> None:
        """
        Stop the interception process and clean up resources.

        - Kills the mitmdump process.
        - Deletes the temporary JSONL file containing captured requests.
        """
        try:
            os.remove(self._requests_path)
        except FileNotFoundError:
            pass
        subprocess.call(["pkill", "mitmdump"])

    def requests(
        self,
        predicate: Optional[Callable[[Request], bool]] = None
    ) -> List[Request]:
        """
        Retrieve and filter captured network requests.

        Parses the temporary storage file and applies an optional filter 
        to the resulting list of Request objects.

        Args:
            predicate (Optional[Callable[[Request], bool]]): A function that returns 
                True for requests that should be included in the results.

        Returns:
            List[Request]: A list of captured and filtered Request objects.
        """
        requests_to_filter = self._requests()

        if predicate is None:
            return requests_to_filter
        
        filtered = []

        for req in requests_to_filter:
            if predicate(req):
                filtered.append(req)

        return filtered
