# Differential Evolution <Single>

import numpy as np

from typing import Optional

from ..base import AlgorithmABC, Verbose
from ..population import Population
from ..util.tournament import tourSelect


class DE(AlgorithmABC):
    """
    Differential Evolution (DE) Algorithm
    -------------------------------------
    
    References:
    [1] Storn R, Price K. Differential Evolution (1997). A Simple and Efficient Heuristic for global Optimization over Continuous Spaces[J].
        Journal of Global Optimization, 11(4):341-359. DOI:10.1023/A:1008202821328.
    """
    
    name = "DE"
    alg_type = "EA"
    
    def __init__(self, cr: float = 0.9, f: float = 0.5,
                 nPop: int = 50,
                 maxFEs: int = 50000, 
                 maxIters: int = 1000, 
                 maxTolerates: int = 1000, tolerate: float = 1e-6, 
                 verboseFlag: bool = True, verboseFreq: int = 10, logFlag: bool = False, saveFlag: bool = True):
        """
        Initialize the differential evolution with user-defined parameters.

        :param cr: Crossover probability.
        :param f: Differential weight.
        :param nPop: Population size.
        :param maxFEs: Maximum number of function evaluations.
        :param maxIterTimes: Maximum number of iterations.
        :param maxTolerateTimes: Maximum number of tolerated iterations without improvement.
        :param tolerate: Tolerance for improvement.
        :param verbose: Flag to enable verbose output.
        :param verboseFreq: Frequency of verbose output.
        :param logFlag: Flag to enable logging.
        :param saveFlag: Flag to enable saving results.
        """
        
        super().__init__(maxFEs, maxIters, maxTolerates, 
                            tolerate, verboseFlag, verboseFreq, logFlag, saveFlag)
        
        # Set user-defined parameters
        self.setParaVal('cr', cr)
        self.setParaVal('f', f)
        self.setParaVal('nPop', nPop)
        
    @Verbose.run
    def run(self, problem, seed: Optional[int] = None):
        """
        Execute the differential evolution algorithm on the specified problem.

        :param problem: An instance of a class derived from ProblemABC.
                        This object defines the optimization problem, including
                        the number of inputs (nInput), number of outputs (nOutput),
                        upper bounds (ub), lower bounds (lb), and evaluation methods.
        
        :return Result: An instance of the Result class, which contains the
                        optimization results, including the best decision variables,
                        objective values, and constraint violations encountered during
                        the optimization process.
        """
        # setup algorithm
        self.setup(problem, seed)
        
        # Parameter Setting
        cr, f = self.getParaVal('cr', 'f')
        nPop = self.getParaVal('nPop')
        
        # Population Generation
        pop = self.initPop(nPop)
        
        # Iterative process
        while self.checkTermination(pop):
            
            # Select mating pool using tournament selection
            # matingPool = self._tournamentSelection(pop, len(pop)*2, 2)
            matingIdx = tourSelect(2, len(pop)*2, pop.objs, pop.cons * -1 if pop.cons is not None else None)
            matingPool = pop[matingIdx]
            
            # Generate offspring using differential evolution operations
            offspringDecs = self._deOperator(pop.decs, matingPool.decs[:len(pop)], matingPool.decs[len(pop):], cr, f)
            offspring = Population(offspringDecs)
            
            # Evaluate the offspring
            self.evaluate(offspring)
            
            # Replace inferior individuals in the population with better offspring
            idx = offspring.objs.ravel() < pop.objs.ravel()
            pop.replace(idx, offspring[idx])
                    
        # Return the final result
        return self.result
            
    def _deOperator(self, popDecs1, popDecs2, popDecs3, cr, f):
        """
        Perform differential evolution operations to generate offspring.

        :param popDecs1: First population.
        :param popDecs2: Second population.
        :param popDecs3: Third population.
        :param cr: Crossover probability.
        :param f: Differential weight.

        :return Population: New population generated by differential evolution.
        """
        
        N, D = len(popDecs1), len(popDecs1[0])
        
        # Differential Evolution operation
        sita = np.random.random((N, D)) < cr
        offspringDecs = np.copy(popDecs1)
        offspringDecs[sita] = popDecs1[sita] + (popDecs2[sita] - popDecs3[sita]) * f
        
        np.clip(offspringDecs, self.problem.lb, self.problem.ub, out=offspringDecs)
        
        return offspringDecs
        
    def _tournamentSelection(self, pop, N, K: int=2):
        """
        K-tournament selection to choose individuals for mating.

        :param pop: Current population.
        :param N: Number of individuals to select.
        :param K: Number of individuals in each tournament.

        :return: Selected individuals for mating.
        """
        
        rankIndex = pop.argsort()
        rank = np.argsort(rankIndex, axis=0)
        tourSelection = np.random.randint(0, high=len(pop), size=(N, K))
        winner = np.min(rank[tourSelection].ravel().reshape(N, K), axis=1)
        winnerIndex = rankIndex[winner]
        
        return pop[winnerIndex]