# This file is automatically generated by componentize-py
# It is not intended for manual editing.
from dataclasses import dataclass
from enum import Enum
from types import TracebackType
from typing import Any, Self, Union

from ..imports import cloudevents, state_view_types


@dataclass
class Command:
    body: bytes | None
    content_type: str
    content_schema: str | None

@dataclass
class StateChangeMetadata:
    state_change_name: str
    state_change_version: int
    last_seen_revision: int
    command_received_at: cloudevents.Datetime
    command_headers: list[tuple[str, str]]


@dataclass
class EventAttribute_Stream:
    value: str


@dataclass
class EventAttribute_Subject:
    value: str | None


@dataclass
class EventAttribute_EventType:
    value: str


EventAttribute = Union[EventAttribute_Stream, EventAttribute_Subject, EventAttribute_EventType]
"""
Event attribute types - concrete values for use in EventSelector
"""



@dataclass
class EventAttributePrefix_Stream:
    value: str


@dataclass
class EventAttributePrefix_Subject:
    value: str


@dataclass
class EventAttributePrefix_EventType:
    value: str


EventAttributePrefix = Union[EventAttributePrefix_Stream, EventAttributePrefix_Subject, EventAttributePrefix_EventType]
"""
Prefix matching for starts-with operations
"""



@dataclass
class EventSelectorNode_Equals:
    value: EventAttribute


@dataclass
class EventSelectorNode_StartsWith:
    value: EventAttributePrefix


@dataclass
class EventSelectorNode_And:
    value: tuple[int, int]


@dataclass
class EventSelectorNode_Or:
    value: tuple[int, int]


EventSelectorNode = Union[EventSelectorNode_Equals, EventSelectorNode_StartsWith, EventSelectorNode_And, EventSelectorNode_Or]
"""
A single node in the event selector tree
"""


@dataclass
class EventSelector:
    """
    Event selector using index-based indirection to work around WIT's lack of recursive types
    The selector is represented as a list of nodes, where compound nodes (and/or)
    reference other nodes by index
    """
    nodes: list[EventSelectorNode]

@dataclass
class BatchConstraintMin:
    selector: EventSelector
    revision: int

@dataclass
class BatchConstraintMax:
    selector: EventSelector
    revision: int

@dataclass
class BatchConstraintRange:
    selector: EventSelector
    min: int
    max: int


@dataclass
class BatchConstraint_Min:
    value: BatchConstraintMin


@dataclass
class BatchConstraint_Max:
    value: BatchConstraintMax


@dataclass
class BatchConstraint_Range:
    value: BatchConstraintRange


BatchConstraint = Union[BatchConstraint_Min, BatchConstraint_Max, BatchConstraint_Range]
"""
Batch constraint types matching Protobuf domain.proto
"""



@dataclass
class StateChangeError_Validation:
    value: str


@dataclass
class StateChangeError_Conflict:
    value: str


@dataclass
class StateChangeError_NotFound:
    value: str


@dataclass
class StateChangeError_Unauthorized:
    value: str


@dataclass
class StateChangeError_Internal:
    value: str


StateChangeError = Union[StateChangeError_Validation, StateChangeError_Conflict, StateChangeError_NotFound, StateChangeError_Unauthorized, StateChangeError_Internal]
"""
Structured error types for state change execution
"""


class QueryDirection(Enum):
    """
    Query types for query-events import
    """
    FORWARD = 0
    REVERSE = 1

@dataclass
class RevisionRange:
    start_at: int | None

@dataclass
class RangeCursor:
    timestamp: cloudevents.Datetime
    revision: int

@dataclass
class EffectiveTimeRange:
    start_at: RangeCursor | None
    end_at: cloudevents.Datetime | None


@dataclass
class QueryRange_Revision:
    value: RevisionRange


@dataclass
class QueryRange_EffectiveTime:
    value: EffectiveTimeRange


QueryRange = Union[QueryRange_Revision, QueryRange_EffectiveTime]


@dataclass
class DatabaseQuery:
    selector: EventSelector
    range: QueryRange | None
    direction: QueryDirection
    limit: int | None

class SpeculativeDatabase:
    """
    ============================================================================
    speculative-database resource (mirrors SpeculativeDatabase trait)
    ============================================================================
    """

    def speculate_with_batch(self, events: list[cloudevents.Cloudevent]) -> Self:
        """
        Navigation (add more speculative events)
        """
        raise NotImplementedError
    def at_effective_timestamp(self, effective_time: cloudevents.Datetime) -> Self:
        raise NotImplementedError
    def query_events(self, query: DatabaseQuery) -> list[cloudevents.Cloudevent]:
        """
        Query methods (includes speculated events)

        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    def view_state(self, state_view: str, version: int, parameters: list[tuple[str, EventAttribute]]) -> state_view_types.RenderedStateView | None:
        """
        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    def basis(self) -> Any:
        """
        Access basis and speculated batches
        """
        raise NotImplementedError
    def speculated_event_count(self) -> int:
        raise NotImplementedError
    def name(self) -> str:
        """
        Identity/metadata
        """
        raise NotImplementedError
    def created_at(self) -> cloudevents.Datetime:
        raise NotImplementedError
    def revision(self) -> int:
        raise NotImplementedError
    def revision_timestamp(self) -> cloudevents.Datetime:
        """
        basis.revision + speculated_event_count
        """
        raise NotImplementedError
    def effective_timestamp(self) -> cloudevents.Datetime | None:
        """
        Effective timestamp (None if not scoped)
        """
        raise NotImplementedError
    def __enter__(self) -> Self:
        """Returns self"""
        return self

    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None:
        """
        Release this resource.
        """
        raise NotImplementedError


class Database:
    """
    ============================================================================
    database resource (mirrors DatabaseAtRevision + DatabaseAtRevisionAndEffectiveTimestamp)
    Has optional effective-timestamp for bi-temporal queries
    ============================================================================
    """

    def at_revision(self, revision: int) -> Self:
        """
        Navigation

        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    def at_effective_timestamp(self, effective_time: cloudevents.Datetime) -> Self:
        raise NotImplementedError
    def speculate_with_batch(self, events: list[cloudevents.Cloudevent]) -> SpeculativeDatabase:
        raise NotImplementedError
    def query_events(self, query: DatabaseQuery) -> list[cloudevents.Cloudevent]:
        """
        Query methods (effective-time applied if set)

        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    def view_state(self, state_view: str, version: int, parameters: list[tuple[str, EventAttribute]]) -> state_view_types.RenderedStateView | None:
        """
        Raises: `wit_world.types.Err(wit_world.imports.str)`
        """
        raise NotImplementedError
    def name(self) -> str:
        """
        Identity/metadata (mirrors DatabaseIdentity)
        """
        raise NotImplementedError
    def created_at(self) -> cloudevents.Datetime:
        raise NotImplementedError
    def revision(self) -> int:
        """
        Revision info
        """
        raise NotImplementedError
    def revision_timestamp(self) -> cloudevents.Datetime:
        raise NotImplementedError
    def effective_timestamp(self) -> cloudevents.Datetime | None:
        """
        Effective timestamp (None if not scoped)
        """
        raise NotImplementedError
    def __enter__(self) -> Self:
        """Returns self"""
        return self

    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None:
        """
        Release this resource.
        """
        raise NotImplementedError



