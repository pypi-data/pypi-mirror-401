#!/usr/bin/env python3
"""
Project Reconstruction Tool

This script reverse engineers a project from the output text file generated by print_project.py.
It parses the file structure and content, then recreates all files in their original locations.

By default, it automatically creates a project-named subdirectory to prevent files from being
scattered in the output directory.

Usage:
    python reconstruct_project.py <output_file.txt> [OPTIONS]

Options:
    --output-dir DIR        Base directory for reconstruction (default: current directory)
                           Project folder will be created inside this directory
    
    --no-project-dir       Recreate files directly in output-dir without creating a 
                           project-named subdirectory (flat structure)
    
    --dry-run              Show what would be created without actually creating files
    
    --overwrite            Overwrite existing files (default: skip existing files)
    
    --verbose, -v          Show detailed progress information

Examples:
    # Reconstruct to ./project_name/ (default behavior)
    python reconstruct_project.py output/myapp_project.txt
    
    # Reconstruct to ./workspace/project_name/
    python reconstruct_project.py output/myapp_project.txt --output-dir ./workspace
    
    # Reconstruct directly to ./workspace/ (no project folder)
    python reconstruct_project.py output/myapp_project.txt --output-dir ./workspace --no-project-dir
    
    # Dry run to preview changes
    python reconstruct_project.py output/myapp_project.txt --dry-run --verbose
"""

import argparse
import os
import re
import sys
from pathlib import Path


def parse_output_file(file_path):
    """
    Parse the output file and extract project structure and file contents.
    
    Args:
        file_path: Path to the output text file
        
    Returns:
        dict: Dictionary with 'metadata' and 'files' (list of {path, content})
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except UnicodeDecodeError:
        # Fallback for systems with different default encodings
        with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()
    
    # Extract metadata - Scans for keys individually for robustness
    metadata = {}
    
    project_match = re.search(r'^# Project: (.+)$', content, re.MULTILINE)
    if project_match:
        metadata['project_name'] = project_match.group(1).strip()
        
    date_match = re.search(r'^# Date: (.+)$', content, re.MULTILINE)
    if date_match:
        metadata['date'] = date_match.group(1).strip()
        
    dir_match = re.search(r'^# Directory: (.+)$', content, re.MULTILINE)
    if dir_match:
        metadata['original_directory'] = dir_match.group(1).strip()
    
    # Find the FILE CONTENTS section
    # Logic: If tree exists, content is after "FILE CONTENTS". 
    # If no tree, content starts at the first file marker.
    file_contents_start = content.find('FILE CONTENTS')
    
    if file_contents_start != -1:
        # Tree section exists, start searching after it
        file_section = content[file_contents_start:]
    else:
        # No tree section, find first file marker to ensure we skip header
        # Look for "=== something ===" followed immediately by "```"
        first_file_match = re.search(r'^=== .+ ===\n```', content, re.MULTILINE)
        if first_file_match:
            file_section = content[first_file_match.start():]
        else:
            raise ValueError("Could not find any file content blocks (=== path ===) in the output file.")
    
    # Pattern to match file blocks: === path === followed by code block
    # Capture group 1: File Path
    # Capture group 2: Content inside ``` ... ```
    file_pattern = r'=== (.+?) ===\n```\n(.*?)```'
    
    files = []
    for match in re.finditer(file_pattern, file_section, re.DOTALL):
        file_path = match.group(1).strip()
        raw_content = match.group(2)
        
        # Process lines to remove line numbers
        lines = raw_content.split('\n')
        cleaned_lines = []
        
        for line in lines:
            # Match pattern: optional spaces + number + " | " + content
            # This handles "   1 | import os" or "1023 | code"
            line_match = re.match(r'^\s*\d+\s+\|\s?(.*)$', line)
            if line_match:
                cleaned_lines.append(line_match.group(1))
            else:
                # Keep lines that don't match the numbering pattern (empty lines or raw content)
                # This ensures we don't lose data if the format is slightly off
                cleaned_lines.append(line)
        
        # Handle edge case where last line might be an artifact of split
        if cleaned_lines and cleaned_lines[-1] == "":
             # Check if the original raw content ended with a newline
             if not raw_content.endswith('\n'):
                 cleaned_lines.pop()

        file_text = '\n'.join(cleaned_lines)
        
        files.append({
            'path': file_path,
            'content': file_text
        })
    
    return {
        'metadata': metadata,
        'files': files
    }


def reconstruct_project(parsed_data, output_dir, overwrite=False, dry_run=False, verbose=False):
    """
    Reconstruct the project from parsed data.
    """
    output_path = Path(output_dir)
    
    if not dry_run:
        output_path.mkdir(parents=True, exist_ok=True)
    
    files_created = 0
    files_skipped = 0
    files_overwritten = 0
    
    if verbose or dry_run:
        print(f"\n{'DRY RUN: ' if dry_run else ''}Reconstructing project to: {output_path.resolve()}")
        print(f"Found {len(parsed_data['files'])} files to process\n")
    
    for file_info in parsed_data['files']:
        file_path = file_info['path']
        file_content = file_info['content']
        
        # Create full path
        full_path = output_path / file_path
        
        # Check if file exists
        if full_path.exists() and not overwrite:
            if verbose:
                print(f"‚è≠Ô∏è  Skipping (exists): {file_path}")
            files_skipped += 1
            continue
        
        is_overwrite = full_path.exists()
        if is_overwrite:
            files_overwritten += 1
            status_icon = "üîÑ"
            status_text = "Overwriting"
        else:
            files_created += 1
            status_icon = "üìù"
            status_text = "Creating"

        if verbose:
            print(f"{status_icon} {status_text}: {file_path}")
        
        if not dry_run:
            # Create parent directories
            full_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write file content
            try:
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(file_content)
            except Exception as e:
                print(f"‚ùå Error writing {file_path}: {e}")
    
    # Summary
    print(f"\n{'=' * 60}")
    print(f"{'DRY RUN SUMMARY' if dry_run else 'RECONSTRUCTION SUMMARY'}")
    print(f"{'=' * 60}")
    print(f"Target Directory:  {output_path.resolve()}")
    print(f"Files Processed:   {len(parsed_data['files'])}")
    print(f"Files Created:     {files_created}")
    print(f"Files Overwritten: {files_overwritten}")
    print(f"Files Skipped:     {files_skipped}")
    
    if not dry_run:
        print(f"\n‚úÖ Project successfully reconstructed!")
    else:
        print(f"\nüí° Run without --dry-run to apply changes")
    
    return {
        'created': files_created,
        'skipped': files_skipped,
        'overwritten': files_overwritten,
        'total': len(parsed_data['files'])
    }


def main():
    """Main function."""
    parser = argparse.ArgumentParser(
        description='Reverse engineer a project from print_project.py output file',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Dry run to see what would be created
  python reconstruct_project.py output.txt --dry-run
  
  # Reconstruct to project_name/ in current directory (default)
  python reconstruct_project.py output.txt
  
  # Reconstruct to specific directory (creates project_name/ inside it)
  python reconstruct_project.py output.txt --output-dir ./workspace
  
  # Reconstruct directly in output-dir (flat structure)
  python reconstruct_project.py output.txt --output-dir ./workspace --no-project-dir
        """
    )
    
    parser.add_argument(
        'input_file',
        help='Path to the output text file from print_project.py'
    )
    
    parser.add_argument(
        '--output-dir',
        default=None,
        help='Directory to reconstruct the project (default: current directory)'
    )
    
    parser.add_argument(
        '--no-project-dir',
        action='store_true',
        help='Do not create a project-named subdirectory (recreate files directly in output-dir)'
    )
    
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be created without actually creating files'
    )
    
    parser.add_argument(
        '--overwrite',
        action='store_true',
        help='Overwrite existing files (default: skip existing files)'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show detailed progress information'
    )
    
    args = parser.parse_args()
    
    # Validate input file
    if not os.path.exists(args.input_file):
        print(f"Error: Input file not found: {args.input_file}")
        return 1
    
    # Parse the output file
    try:
        if args.verbose:
            print(f"Parsing output file: {args.input_file}")
        parsed_data = parse_output_file(args.input_file)
        
        project_name = parsed_data['metadata'].get('project_name', 'Unknown')
        if args.verbose:
            print(f"Found project: {project_name}")
            print(f"Original directory: {parsed_data['metadata'].get('original_directory', 'Unknown')}")
        
    except Exception as e:
        print(f"Error parsing output file: {e}")
        return 1
    
    # Determine output directory
    base_output_dir = args.output_dir if args.output_dir is not None else os.getcwd()
    
    # Handle --no-project-dir logic
    if args.no_project_dir:
        final_output_dir = base_output_dir
    else:
        # Default behavior: Append project name to path
        if project_name and project_name != 'Unknown':
            final_output_dir = os.path.join(base_output_dir, project_name)
        else:
            # Fallback if no project name found in metadata
            print("Warning: No project name found in metadata. Using 'reconstructed_project'")
            final_output_dir = os.path.join(base_output_dir, 'reconstructed_project')

    # Reconstruct the project
    try:
        reconstruct_project(
            parsed_data,
            final_output_dir,
            overwrite=args.overwrite,
            dry_run=args.dry_run,
            verbose=args.verbose
        )
        return 0
    except Exception as e:
        print(f"Error reconstructing project: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())