
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class BufferLoopHoistingOp(_ods_ir.OpView):
  r"""
  Hoist buffer allocations ("memref.alloc" and "memref.alloca") from loops
  within the targeted op. This transform assumes that there are no buffer
  deallocation ops in the IR.
  
  This transform reads the `target` handle and modifies the payload.
  """

  OPERATION_NAME = "transform.bufferization.buffer_loop_hoisting"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def bufferization_buffer_loop_hoisting(target, *, loc=None, ip=None) -> BufferLoopHoistingOp:
  return BufferLoopHoistingOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EliminateEmptyTensorsOp(_ods_ir.OpView):
  r"""
  Try to eliminate all `tensor.empty` ops within the targeted op by replacing
  them with another destination tensor.
  
  "tensor.empty" ops cannot be bufferized. They can either be converted to
  "bufferization.alloc_tensor" or replaced with another tensor (via this
  transform). "tensor.empty" does not specify the contents of the returned
  tensor so their results can be replaced with arbitrary tensor values as long
  as the dimensions match.
  
  This transformation looks for subset ops that insert a tensor that
  originates from a "tensor.empty" (as per the reverse use-def chain). Such
  "tensor.empty" ops are replaced with the destination subset.
  
  Example:
  
  ```
  %0 = tensor.empty() : tensor<5xf32>
  %1 = linalg.fill ... outs(%0)
  %2 = tensor.insert_slice %1 into %t[1][5][1]
  ```
  
  Is rewritten with:
  ```
  %0 = tensor.extract_slice %t[1][5][1]
  %1 = linalg.fill ... outs(%0)
  %2 = tensor.insert_slice %1 into %t[1][5][1]
  ```
  
  In the above example, the subset op is "tensor.insert_slice". When tracing
  back the reverse use-def chain of a the source, we end up at a
  "tensor.empty" op.
  
  The above example can bufferize without an allocation (in the absence of
  other conflicts) because there is no longer a `tensor.empty` op.
  
  See `-eliminate-empty-tensors` for more details.
  
  #### Return modes
  
  This transform reads the target handle and modifies the payload. It does
  not produce any handle.
  """

  OPERATION_NAME = "transform.bufferization.eliminate_empty_tensors"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def bufferization_eliminate_empty_tensors(target, *, loc=None, ip=None) -> EliminateEmptyTensorsOp:
  return EliminateEmptyTensorsOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EmptyTensorToAllocTensorOp(_ods_ir.OpView):
  r"""
  Replace a tensor.empty with a bufferization.tensor_alloc.
  
  #### Return modes
  
  This operation consumes the `target` handle and produces the `transformed`
  handle. `target` is expected to be a `tensor.empty` operation. The transform
  always succeeds.
  """

  OPERATION_NAME = "transform.bufferization.empty_tensor_to_alloc_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def transformed(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bufferization_empty_tensor_to_alloc_tensor(transformed, target, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return EmptyTensorToAllocTensorOp(transformed=transformed, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OneShotBufferizeOp(_ods_ir.OpView):
  r"""
  Indicates that the given `target` op should be bufferized with One-Shot
  Bufferize. The bufferization can be configured with various attributes that
  corresponding to options in `BufferizationOptions` and the
  `one-shot-bufferize` pass. More information can be found in the pass
  documentation.
  
  The targeted ops must be modules or functions. This is because there is
  always a single, bufferized replacement op for such targets.
  
  Note: Only ops that implement `BufferizableOpInterface` are bufferized. All
  other ops are ignored if `allow_unknown_ops`. If `allow_unknown_ops` is
  unset, this transform fails when an unknown/non-bufferizable op is found.
  Many ops implement `BufferizableOpInterface` via an external model. These
  external models must be registered when applying this transform op;
  otherwise, said ops would be considered non-bufferizable.
  
  #### Return modes
  
  This operation consumes the `target` handle and produces the `transformed`
  handle.
  """

  OPERATION_NAME = "transform.bufferization.one_shot_bufferize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, function_boundary_type_conversion=None, allow_return_allocs_from_loops=None, allow_unknown_ops=None, bufferize_function_boundaries=None, dump_alias_sets=None, test_analysis_only=None, print_conflicts=None, check_parallel_regions=None, memcpy_op=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    if function_boundary_type_conversion is not None: attributes["function_boundary_type_conversion"] = (function_boundary_type_conversion if (
        isinstance(function_boundary_type_conversion, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LayoutMapOption')) else
          _ods_ir.AttrBuilder.get('LayoutMapOption')(function_boundary_type_conversion, context=_ods_context))
    if allow_return_allocs_from_loops is not None: attributes["allow_return_allocs_from_loops"] = (allow_return_allocs_from_loops if (
        isinstance(allow_return_allocs_from_loops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(allow_return_allocs_from_loops, context=_ods_context))
    if allow_unknown_ops is not None: attributes["allow_unknown_ops"] = (allow_unknown_ops if (
        isinstance(allow_unknown_ops, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(allow_unknown_ops, context=_ods_context))
    if bufferize_function_boundaries is not None: attributes["bufferize_function_boundaries"] = (bufferize_function_boundaries if (
        isinstance(bufferize_function_boundaries, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(bufferize_function_boundaries, context=_ods_context))
    if dump_alias_sets is not None: attributes["dump_alias_sets"] = (dump_alias_sets if (
        isinstance(dump_alias_sets, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(dump_alias_sets, context=_ods_context))
    if test_analysis_only is not None: attributes["test_analysis_only"] = (test_analysis_only if (
        isinstance(test_analysis_only, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(test_analysis_only, context=_ods_context))
    if print_conflicts is not None: attributes["print_conflicts"] = (print_conflicts if (
        isinstance(print_conflicts, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(print_conflicts, context=_ods_context))
    if check_parallel_regions is not None: attributes["check_parallel_regions"] = (check_parallel_regions if (
        isinstance(check_parallel_regions, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(check_parallel_regions, context=_ods_context))
    if memcpy_op is not None: attributes["memcpy_op"] = (memcpy_op if (
        isinstance(memcpy_op, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(memcpy_op, context=_ods_context))
    results = []
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def function_boundary_type_conversion(self) -> _Optional[_ods_ir.Attribute]:
    if "function_boundary_type_conversion" not in self.operation.attributes:
      return None
    return self.operation.attributes["function_boundary_type_conversion"]

  @function_boundary_type_conversion.setter
  def function_boundary_type_conversion(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["function_boundary_type_conversion"] = value
    elif "function_boundary_type_conversion" in self.operation.attributes:
      del self.operation.attributes["function_boundary_type_conversion"]

  @function_boundary_type_conversion.deleter
  def function_boundary_type_conversion(self):
    del self.operation.attributes["function_boundary_type_conversion"]

  @builtins.property
  def allow_return_allocs_from_loops(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["allow_return_allocs_from_loops"]

  @allow_return_allocs_from_loops.setter
  def allow_return_allocs_from_loops(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["allow_return_allocs_from_loops"] = value

  @builtins.property
  def allow_unknown_ops(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["allow_unknown_ops"]

  @allow_unknown_ops.setter
  def allow_unknown_ops(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["allow_unknown_ops"] = value

  @builtins.property
  def bufferize_function_boundaries(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["bufferize_function_boundaries"]

  @bufferize_function_boundaries.setter
  def bufferize_function_boundaries(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bufferize_function_boundaries"] = value

  @builtins.property
  def dump_alias_sets(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["dump_alias_sets"]

  @dump_alias_sets.setter
  def dump_alias_sets(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dump_alias_sets"] = value

  @builtins.property
  def test_analysis_only(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["test_analysis_only"]

  @test_analysis_only.setter
  def test_analysis_only(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["test_analysis_only"] = value

  @builtins.property
  def print_conflicts(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["print_conflicts"]

  @print_conflicts.setter
  def print_conflicts(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["print_conflicts"] = value

  @builtins.property
  def check_parallel_regions(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["check_parallel_regions"]

  @check_parallel_regions.setter
  def check_parallel_regions(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["check_parallel_regions"] = value

  @builtins.property
  def memcpy_op(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["memcpy_op"]

  @memcpy_op.setter
  def memcpy_op(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memcpy_op"] = value

  @builtins.property
  def transformed(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bufferization_one_shot_bufferize(transformed, target, *, function_boundary_type_conversion=None, allow_return_allocs_from_loops=None, allow_unknown_ops=None, bufferize_function_boundaries=None, dump_alias_sets=None, test_analysis_only=None, print_conflicts=None, check_parallel_regions=None, memcpy_op=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return OneShotBufferizeOp(transformed=transformed, target=target, function_boundary_type_conversion=function_boundary_type_conversion, allow_return_allocs_from_loops=allow_return_allocs_from_loops, allow_unknown_ops=allow_unknown_ops, bufferize_function_boundaries=bufferize_function_boundaries, dump_alias_sets=dump_alias_sets, test_analysis_only=test_analysis_only, print_conflicts=print_conflicts, check_parallel_regions=check_parallel_regions, memcpy_op=memcpy_op, loc=loc, ip=ip).result
