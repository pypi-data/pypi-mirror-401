/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ADJOINTLOWERINGPASS
#define GEN_PASS_DECL_CANCELINVERSESPASS
#define GEN_PASS_DECL_COPYGLOBALMEMREFPASS
#define GEN_PASS_DECL_DECOMPOSELOWERINGPASS
#define GEN_PASS_DECL_DISENTANGLECNOTPASS
#define GEN_PASS_DECL_DISENTANGLESWAPPASS
#define GEN_PASS_DECL_EMITCATALYSTPYINTERFACEPASS
#define GEN_PASS_DECL_GRIDSYNTHPASS
#define GEN_PASS_DECL_IONSDECOMPOSITIONPASS
#define GEN_PASS_DECL_LOOPBOUNDARYOPTIMIZATIONPASS
#define GEN_PASS_DECL_MERGEROTATIONSPASS
#define GEN_PASS_DECL_QUANTUMCONVERSIONPASS
#define GEN_PASS_DECL_SPLITMULTIPLETAPESPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AdjointLoweringPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADJOINTLOWERINGPASS
std::unique_ptr<::mlir::Pass> createAdjointLoweringPass();
#undef GEN_PASS_DECL_ADJOINTLOWERINGPASS
#endif // GEN_PASS_DECL_ADJOINTLOWERINGPASS
#ifdef GEN_PASS_DEF_ADJOINTLOWERINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createAdjointLoweringPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class AdjointLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AdjointLoweringPassBase;

  AdjointLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AdjointLoweringPassBase(const AdjointLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  AdjointLoweringPassBase& operator=(const AdjointLoweringPassBase &) = delete;
  AdjointLoweringPassBase(AdjointLoweringPassBase &&) = delete;
  AdjointLoweringPassBase& operator=(AdjointLoweringPassBase &&) = delete;
  ~AdjointLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("adjoint-lowering");
  }
  ::llvm::StringRef getArgument() const override { return "adjoint-lowering"; }

  ::llvm::StringRef getDescription() const override { return "Lower adjoint regions containing a single quantum operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AdjointLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "AdjointLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<catalyst::CatalystDialect>();
    registry.insert<index::IndexDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<complex::ComplexDialect>();
    registry.insert<scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AdjointLoweringPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createAdjointLoweringPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createAdjointLoweringPass() {
  return impl::createAdjointLoweringPass();
}
#undef GEN_PASS_DEF_ADJOINTLOWERINGPASS
#endif // GEN_PASS_DEF_ADJOINTLOWERINGPASS

//===----------------------------------------------------------------------===//
// CancelInversesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CANCELINVERSESPASS
std::unique_ptr<::mlir::Pass> createCancelInversesPass();
#undef GEN_PASS_DECL_CANCELINVERSESPASS
#endif // GEN_PASS_DECL_CANCELINVERSESPASS
#ifdef GEN_PASS_DEF_CANCELINVERSESPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createCancelInversesPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class CancelInversesPassBase : public ::mlir::OperationPass<> {
public:
  using Base = CancelInversesPassBase;

  CancelInversesPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CancelInversesPassBase(const CancelInversesPassBase &other) : ::mlir::OperationPass<>(other) {}
  CancelInversesPassBase& operator=(const CancelInversesPassBase &) = delete;
  CancelInversesPassBase(CancelInversesPassBase &&) = delete;
  CancelInversesPassBase& operator=(CancelInversesPassBase &&) = delete;
  ~CancelInversesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cancel-inverses");
  }
  ::llvm::StringRef getArgument() const override { return "cancel-inverses"; }

  ::llvm::StringRef getDescription() const override { return "Perform removal of chained operations that are inverses."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CancelInversesPass");
  }
  ::llvm::StringRef getName() const override { return "CancelInversesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CancelInversesPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createCancelInversesPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createCancelInversesPass() {
  return impl::createCancelInversesPass();
}
#undef GEN_PASS_DEF_CANCELINVERSESPASS
#endif // GEN_PASS_DEF_CANCELINVERSESPASS

//===----------------------------------------------------------------------===//
// CopyGlobalMemRefPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COPYGLOBALMEMREFPASS
std::unique_ptr<::mlir::Pass> createCopyGlobalMemRefPass();
#undef GEN_PASS_DECL_COPYGLOBALMEMREFPASS
#endif // GEN_PASS_DECL_COPYGLOBALMEMREFPASS
#ifdef GEN_PASS_DEF_COPYGLOBALMEMREFPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createCopyGlobalMemRefPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class CopyGlobalMemRefPassBase : public ::mlir::OperationPass<> {
public:
  using Base = CopyGlobalMemRefPassBase;

  CopyGlobalMemRefPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CopyGlobalMemRefPassBase(const CopyGlobalMemRefPassBase &other) : ::mlir::OperationPass<>(other) {}
  CopyGlobalMemRefPassBase& operator=(const CopyGlobalMemRefPassBase &) = delete;
  CopyGlobalMemRefPassBase(CopyGlobalMemRefPassBase &&) = delete;
  CopyGlobalMemRefPassBase& operator=(CopyGlobalMemRefPassBase &&) = delete;
  ~CopyGlobalMemRefPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cp-global-memref");
  }
  ::llvm::StringRef getArgument() const override { return "cp-global-memref"; }

  ::llvm::StringRef getDescription() const override { return "Copy global memrefs before returning from C interface."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyGlobalMemRefPass");
  }
  ::llvm::StringRef getName() const override { return "CopyGlobalMemRefPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyGlobalMemRefPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createCopyGlobalMemRefPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createCopyGlobalMemRefPass() {
  return impl::createCopyGlobalMemRefPass();
}
#undef GEN_PASS_DEF_COPYGLOBALMEMREFPASS
#endif // GEN_PASS_DEF_COPYGLOBALMEMREFPASS

//===----------------------------------------------------------------------===//
// DecomposeLoweringPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DECOMPOSELOWERINGPASS
std::unique_ptr<::mlir::Pass> createDecomposeLoweringPass();
#undef GEN_PASS_DECL_DECOMPOSELOWERINGPASS
#endif // GEN_PASS_DECL_DECOMPOSELOWERINGPASS
#ifdef GEN_PASS_DEF_DECOMPOSELOWERINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createDecomposeLoweringPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class DecomposeLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DecomposeLoweringPassBase;

  DecomposeLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeLoweringPassBase(const DecomposeLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  DecomposeLoweringPassBase& operator=(const DecomposeLoweringPassBase &) = delete;
  DecomposeLoweringPassBase(DecomposeLoweringPassBase &&) = delete;
  DecomposeLoweringPassBase& operator=(DecomposeLoweringPassBase &&) = delete;
  ~DecomposeLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("decompose-lowering");
  }
  ::llvm::StringRef getArgument() const override { return "decompose-lowering"; }

  ::llvm::StringRef getDescription() const override { return "Replace quantum operations with compiled decomposition rules."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeLoweringPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createDecomposeLoweringPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createDecomposeLoweringPass() {
  return impl::createDecomposeLoweringPass();
}
#undef GEN_PASS_DEF_DECOMPOSELOWERINGPASS
#endif // GEN_PASS_DEF_DECOMPOSELOWERINGPASS

//===----------------------------------------------------------------------===//
// DisentangleCNOTPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DISENTANGLECNOTPASS
struct DisentangleCNOTPassOptions {
  bool EmitFSMStateRemark = false;
};
std::unique_ptr<::mlir::Pass> createDisentangleCNOTPass();
std::unique_ptr<::mlir::Pass> createDisentangleCNOTPass(DisentangleCNOTPassOptions options);
#undef GEN_PASS_DECL_DISENTANGLECNOTPASS
#endif // GEN_PASS_DECL_DISENTANGLECNOTPASS
#ifdef GEN_PASS_DEF_DISENTANGLECNOTPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createDisentangleCNOTPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createDisentangleCNOTPass(DisentangleCNOTPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class DisentangleCNOTPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DisentangleCNOTPassBase;

  DisentangleCNOTPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DisentangleCNOTPassBase(const DisentangleCNOTPassBase &other) : ::mlir::OperationPass<>(other) {}
  DisentangleCNOTPassBase& operator=(const DisentangleCNOTPassBase &) = delete;
  DisentangleCNOTPassBase(DisentangleCNOTPassBase &&) = delete;
  DisentangleCNOTPassBase& operator=(DisentangleCNOTPassBase &&) = delete;
  ~DisentangleCNOTPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("disentangle-CNOT");
  }
  ::llvm::StringRef getArgument() const override { return "disentangle-CNOT"; }

  ::llvm::StringRef getDescription() const override { return "Replace a CNOT gate with two single qubit gates whenever possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DisentangleCNOTPass");
  }
  ::llvm::StringRef getName() const override { return "DisentangleCNOTPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DisentangleCNOTPassBase<DerivedT>)

  DisentangleCNOTPassBase(DisentangleCNOTPassOptions options) : DisentangleCNOTPassBase() {
    EmitFSMStateRemark = std::move(options.EmitFSMStateRemark);
  }
protected:
  ::mlir::Pass::Option<bool> EmitFSMStateRemark{*this, "emit-FSM-state-remark", ::llvm::cl::desc("Whether to emit the state analysis result from the simple states propagation FSM onto the gate operations."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createDisentangleCNOTPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createDisentangleCNOTPass(DisentangleCNOTPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createDisentangleCNOTPass() {
  return impl::createDisentangleCNOTPass();
}

std::unique_ptr<::mlir::Pass> createDisentangleCNOTPass(DisentangleCNOTPassOptions options) {
  return impl::createDisentangleCNOTPass(std::move(options));
}
#undef GEN_PASS_DEF_DISENTANGLECNOTPASS
#endif // GEN_PASS_DEF_DISENTANGLECNOTPASS

//===----------------------------------------------------------------------===//
// DisentangleSWAPPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DISENTANGLESWAPPASS
struct DisentangleSWAPPassOptions {
  bool EmitFSMStateRemark = false;
};
std::unique_ptr<::mlir::Pass> createDisentangleSWAPPass();
std::unique_ptr<::mlir::Pass> createDisentangleSWAPPass(DisentangleSWAPPassOptions options);
#undef GEN_PASS_DECL_DISENTANGLESWAPPASS
#endif // GEN_PASS_DECL_DISENTANGLESWAPPASS
#ifdef GEN_PASS_DEF_DISENTANGLESWAPPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createDisentangleSWAPPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createDisentangleSWAPPass(DisentangleSWAPPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class DisentangleSWAPPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DisentangleSWAPPassBase;

  DisentangleSWAPPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DisentangleSWAPPassBase(const DisentangleSWAPPassBase &other) : ::mlir::OperationPass<>(other) {}
  DisentangleSWAPPassBase& operator=(const DisentangleSWAPPassBase &) = delete;
  DisentangleSWAPPassBase(DisentangleSWAPPassBase &&) = delete;
  DisentangleSWAPPassBase& operator=(DisentangleSWAPPassBase &&) = delete;
  ~DisentangleSWAPPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("disentangle-SWAP");
  }
  ::llvm::StringRef getArgument() const override { return "disentangle-SWAP"; }

  ::llvm::StringRef getDescription() const override { return "Replace a SWAP gate with single qubit gates and a shorter SWAPZ gates whenever possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DisentangleSWAPPass");
  }
  ::llvm::StringRef getName() const override { return "DisentangleSWAPPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DisentangleSWAPPassBase<DerivedT>)

  DisentangleSWAPPassBase(DisentangleSWAPPassOptions options) : DisentangleSWAPPassBase() {
    EmitFSMStateRemark = std::move(options.EmitFSMStateRemark);
  }
protected:
  ::mlir::Pass::Option<bool> EmitFSMStateRemark{*this, "emit-FSM-state-remark", ::llvm::cl::desc("Whether to emit the state analysis result from the simple states propagation FSM onto the gate operations."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createDisentangleSWAPPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createDisentangleSWAPPass(DisentangleSWAPPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createDisentangleSWAPPass() {
  return impl::createDisentangleSWAPPass();
}

std::unique_ptr<::mlir::Pass> createDisentangleSWAPPass(DisentangleSWAPPassOptions options) {
  return impl::createDisentangleSWAPPass(std::move(options));
}
#undef GEN_PASS_DEF_DISENTANGLESWAPPASS
#endif // GEN_PASS_DEF_DISENTANGLESWAPPASS

//===----------------------------------------------------------------------===//
// EmitCatalystPyInterfacePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EMITCATALYSTPYINTERFACEPASS
std::unique_ptr<::mlir::Pass> createEmitCatalystPyInterfacePass();
#undef GEN_PASS_DECL_EMITCATALYSTPYINTERFACEPASS
#endif // GEN_PASS_DECL_EMITCATALYSTPYINTERFACEPASS
#ifdef GEN_PASS_DEF_EMITCATALYSTPYINTERFACEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createEmitCatalystPyInterfacePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class EmitCatalystPyInterfacePassBase : public ::mlir::OperationPass<> {
public:
  using Base = EmitCatalystPyInterfacePassBase;

  EmitCatalystPyInterfacePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  EmitCatalystPyInterfacePassBase(const EmitCatalystPyInterfacePassBase &other) : ::mlir::OperationPass<>(other) {}
  EmitCatalystPyInterfacePassBase& operator=(const EmitCatalystPyInterfacePassBase &) = delete;
  EmitCatalystPyInterfacePassBase(EmitCatalystPyInterfacePassBase &&) = delete;
  EmitCatalystPyInterfacePassBase& operator=(EmitCatalystPyInterfacePassBase &&) = delete;
  ~EmitCatalystPyInterfacePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("emit-catalyst-py-interface");
  }
  ::llvm::StringRef getArgument() const override { return "emit-catalyst-py-interface"; }

  ::llvm::StringRef getDescription() const override { return "Emit catalyst python's default interface."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmitCatalystPyInterfacePass");
  }
  ::llvm::StringRef getName() const override { return "EmitCatalystPyInterfacePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmitCatalystPyInterfacePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createEmitCatalystPyInterfacePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createEmitCatalystPyInterfacePass() {
  return impl::createEmitCatalystPyInterfacePass();
}
#undef GEN_PASS_DEF_EMITCATALYSTPYINTERFACEPASS
#endif // GEN_PASS_DEF_EMITCATALYSTPYINTERFACEPASS

//===----------------------------------------------------------------------===//
// GridsynthPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GRIDSYNTHPASS
struct GridsynthPassOptions {
  double epsilon = 1e-4;
  bool pprBasis = false;
};
std::unique_ptr<::mlir::Pass> createGridsynthPass();
std::unique_ptr<::mlir::Pass> createGridsynthPass(GridsynthPassOptions options);
#undef GEN_PASS_DECL_GRIDSYNTHPASS
#endif // GEN_PASS_DECL_GRIDSYNTHPASS
#ifdef GEN_PASS_DEF_GRIDSYNTHPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createGridsynthPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createGridsynthPass(GridsynthPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class GridsynthPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GridsynthPassBase;

  GridsynthPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GridsynthPassBase(const GridsynthPassBase &other) : ::mlir::OperationPass<>(other) {}
  GridsynthPassBase& operator=(const GridsynthPassBase &) = delete;
  GridsynthPassBase(GridsynthPassBase &&) = delete;
  GridsynthPassBase& operator=(GridsynthPassBase &&) = delete;
  ~GridsynthPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gridsynth");
  }
  ::llvm::StringRef getArgument() const override { return "gridsynth"; }

  ::llvm::StringRef getDescription() const override { return "Perform Ross-Selinger/Gridsynth decomposition."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GridsynthPass");
  }
  ::llvm::StringRef getName() const override { return "GridsynthPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<catalyst::qec::QECDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GridsynthPassBase<DerivedT>)

  GridsynthPassBase(GridsynthPassOptions options) : GridsynthPassBase() {
    epsilon = std::move(options.epsilon);
    pprBasis = std::move(options.pprBasis);
  }
protected:
  ::mlir::Pass::Option<double> epsilon{*this, "epsilon", ::llvm::cl::desc("Maximum error tolerance for per-gate discretization."), ::llvm::cl::init(1e-4)};
  ::mlir::Pass::Option<bool> pprBasis{*this, "ppr-basis", ::llvm::cl::desc("Whether to decompose into the PPR basis set instead of the standard Clifford+T basis set."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createGridsynthPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createGridsynthPass(GridsynthPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGridsynthPass() {
  return impl::createGridsynthPass();
}

std::unique_ptr<::mlir::Pass> createGridsynthPass(GridsynthPassOptions options) {
  return impl::createGridsynthPass(std::move(options));
}
#undef GEN_PASS_DEF_GRIDSYNTHPASS
#endif // GEN_PASS_DEF_GRIDSYNTHPASS

//===----------------------------------------------------------------------===//
// IonsDecompositionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_IONSDECOMPOSITIONPASS
std::unique_ptr<::mlir::Pass> createIonsDecompositionPass();
#undef GEN_PASS_DECL_IONSDECOMPOSITIONPASS
#endif // GEN_PASS_DECL_IONSDECOMPOSITIONPASS
#ifdef GEN_PASS_DEF_IONSDECOMPOSITIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createIonsDecompositionPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class IonsDecompositionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = IonsDecompositionPassBase;

  IonsDecompositionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  IonsDecompositionPassBase(const IonsDecompositionPassBase &other) : ::mlir::OperationPass<>(other) {}
  IonsDecompositionPassBase& operator=(const IonsDecompositionPassBase &) = delete;
  IonsDecompositionPassBase(IonsDecompositionPassBase &&) = delete;
  IonsDecompositionPassBase& operator=(IonsDecompositionPassBase &&) = delete;
  ~IonsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("ions-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "ions-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose the gates to the set {RX, RY, MS}"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("IonsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "IonsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(IonsDecompositionPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createIonsDecompositionPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createIonsDecompositionPass() {
  return impl::createIonsDecompositionPass();
}
#undef GEN_PASS_DEF_IONSDECOMPOSITIONPASS
#endif // GEN_PASS_DEF_IONSDECOMPOSITIONPASS

//===----------------------------------------------------------------------===//
// LoopBoundaryOptimizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOOPBOUNDARYOPTIMIZATIONPASS
std::unique_ptr<::mlir::Pass> createLoopBoundaryOptimizationPass();
#undef GEN_PASS_DECL_LOOPBOUNDARYOPTIMIZATIONPASS
#endif // GEN_PASS_DECL_LOOPBOUNDARYOPTIMIZATIONPASS
#ifdef GEN_PASS_DEF_LOOPBOUNDARYOPTIMIZATIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createLoopBoundaryOptimizationPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class LoopBoundaryOptimizationPassBase : public ::mlir::OperationPass<> {
public:
  using Base = LoopBoundaryOptimizationPassBase;

  LoopBoundaryOptimizationPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LoopBoundaryOptimizationPassBase(const LoopBoundaryOptimizationPassBase &other) : ::mlir::OperationPass<>(other) {}
  LoopBoundaryOptimizationPassBase& operator=(const LoopBoundaryOptimizationPassBase &) = delete;
  LoopBoundaryOptimizationPassBase(LoopBoundaryOptimizationPassBase &&) = delete;
  LoopBoundaryOptimizationPassBase& operator=(LoopBoundaryOptimizationPassBase &&) = delete;
  ~LoopBoundaryOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("loop-boundary");
  }
  ::llvm::StringRef getArgument() const override { return "loop-boundary"; }

  ::llvm::StringRef getDescription() const override { return "Perform loop boundary optimization to eliminate the redundancy of operations on loop boundary."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoopBoundaryOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "LoopBoundaryOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoopBoundaryOptimizationPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createLoopBoundaryOptimizationPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createLoopBoundaryOptimizationPass() {
  return impl::createLoopBoundaryOptimizationPass();
}
#undef GEN_PASS_DEF_LOOPBOUNDARYOPTIMIZATIONPASS
#endif // GEN_PASS_DEF_LOOPBOUNDARYOPTIMIZATIONPASS

//===----------------------------------------------------------------------===//
// MergeRotationsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MERGEROTATIONSPASS
std::unique_ptr<::mlir::Pass> createMergeRotationsPass();
#undef GEN_PASS_DECL_MERGEROTATIONSPASS
#endif // GEN_PASS_DECL_MERGEROTATIONSPASS
#ifdef GEN_PASS_DEF_MERGEROTATIONSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createMergeRotationsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class MergeRotationsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = MergeRotationsPassBase;

  MergeRotationsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  MergeRotationsPassBase(const MergeRotationsPassBase &other) : ::mlir::OperationPass<>(other) {}
  MergeRotationsPassBase& operator=(const MergeRotationsPassBase &) = delete;
  MergeRotationsPassBase(MergeRotationsPassBase &&) = delete;
  MergeRotationsPassBase& operator=(MergeRotationsPassBase &&) = delete;
  ~MergeRotationsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("merge-rotations");
  }
  ::llvm::StringRef getArgument() const override { return "merge-rotations"; }

  ::llvm::StringRef getDescription() const override { return "Perform merging of chained rotation gates about the same axis."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeRotationsPass");
  }
  ::llvm::StringRef getName() const override { return "MergeRotationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<math::MathDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeRotationsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createMergeRotationsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createMergeRotationsPass() {
  return impl::createMergeRotationsPass();
}
#undef GEN_PASS_DEF_MERGEROTATIONSPASS
#endif // GEN_PASS_DEF_MERGEROTATIONSPASS

//===----------------------------------------------------------------------===//
// QuantumConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_QUANTUMCONVERSIONPASS
struct QuantumConversionPassOptions {
  bool useArrayBackedRegisters = false;
};
std::unique_ptr<::mlir::Pass> createQuantumConversionPass();
std::unique_ptr<::mlir::Pass> createQuantumConversionPass(QuantumConversionPassOptions options);
#undef GEN_PASS_DECL_QUANTUMCONVERSIONPASS
#endif // GEN_PASS_DECL_QUANTUMCONVERSIONPASS
#ifdef GEN_PASS_DEF_QUANTUMCONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createQuantumConversionPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createQuantumConversionPass(QuantumConversionPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class QuantumConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = QuantumConversionPassBase;

  QuantumConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  QuantumConversionPassBase(const QuantumConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  QuantumConversionPassBase& operator=(const QuantumConversionPassBase &) = delete;
  QuantumConversionPassBase(QuantumConversionPassBase &&) = delete;
  QuantumConversionPassBase& operator=(QuantumConversionPassBase &&) = delete;
  ~QuantumConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-quantum-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-quantum-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Perform a dialect conversion from Quantum to LLVM (QIR)."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("QuantumConversionPass");
  }
  ::llvm::StringRef getName() const override { return "QuantumConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(QuantumConversionPassBase<DerivedT>)

  QuantumConversionPassBase(QuantumConversionPassOptions options) : QuantumConversionPassBase() {
    useArrayBackedRegisters = std::move(options.useArrayBackedRegisters);
  }
protected:
  ::mlir::Pass::Option<bool> useArrayBackedRegisters{*this, "use-array-backed-registers", ::llvm::cl::desc("Use the array-backed-registers conversion pattern for quantum.insert ops."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createQuantumConversionPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createQuantumConversionPass(QuantumConversionPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createQuantumConversionPass() {
  return impl::createQuantumConversionPass();
}

std::unique_ptr<::mlir::Pass> createQuantumConversionPass(QuantumConversionPassOptions options) {
  return impl::createQuantumConversionPass(std::move(options));
}
#undef GEN_PASS_DEF_QUANTUMCONVERSIONPASS
#endif // GEN_PASS_DEF_QUANTUMCONVERSIONPASS

//===----------------------------------------------------------------------===//
// SplitMultipleTapesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPLITMULTIPLETAPESPASS
std::unique_ptr<::mlir::Pass> createSplitMultipleTapesPass();
#undef GEN_PASS_DECL_SPLITMULTIPLETAPESPASS
#endif // GEN_PASS_DECL_SPLITMULTIPLETAPESPASS
#ifdef GEN_PASS_DEF_SPLITMULTIPLETAPESPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createSplitMultipleTapesPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class SplitMultipleTapesPassBase : public ::mlir::OperationPass<> {
public:
  using Base = SplitMultipleTapesPassBase;

  SplitMultipleTapesPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SplitMultipleTapesPassBase(const SplitMultipleTapesPassBase &other) : ::mlir::OperationPass<>(other) {}
  SplitMultipleTapesPassBase& operator=(const SplitMultipleTapesPassBase &) = delete;
  SplitMultipleTapesPassBase(SplitMultipleTapesPassBase &&) = delete;
  SplitMultipleTapesPassBase& operator=(SplitMultipleTapesPassBase &&) = delete;
  ~SplitMultipleTapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("split-multiple-tapes");
  }
  ::llvm::StringRef getArgument() const override { return "split-multiple-tapes"; }

  ::llvm::StringRef getDescription() const override { return "Given a qnode containing multiple tapes, split each tape into its own function."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitMultipleTapesPass");
  }
  ::llvm::StringRef getName() const override { return "SplitMultipleTapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitMultipleTapesPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createSplitMultipleTapesPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createSplitMultipleTapesPass() {
  return impl::createSplitMultipleTapesPass();
}
#undef GEN_PASS_DEF_SPLITMULTIPLETAPESPASS
#endif // GEN_PASS_DEF_SPLITMULTIPLETAPESPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AdjointLoweringPass Registration
//===----------------------------------------------------------------------===//

inline void registerAdjointLoweringPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAdjointLoweringPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAdjointLoweringPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAdjointLoweringPass();
  });
}

//===----------------------------------------------------------------------===//
// CancelInversesPass Registration
//===----------------------------------------------------------------------===//

inline void registerCancelInversesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCancelInversesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCancelInversesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCancelInversesPass();
  });
}

//===----------------------------------------------------------------------===//
// CopyGlobalMemRefPass Registration
//===----------------------------------------------------------------------===//

inline void registerCopyGlobalMemRefPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCopyGlobalMemRefPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCopyGlobalMemRefPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCopyGlobalMemRefPass();
  });
}

//===----------------------------------------------------------------------===//
// DecomposeLoweringPass Registration
//===----------------------------------------------------------------------===//

inline void registerDecomposeLoweringPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDecomposeLoweringPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDecomposeLoweringPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDecomposeLoweringPass();
  });
}

//===----------------------------------------------------------------------===//
// DisentangleCNOTPass Registration
//===----------------------------------------------------------------------===//

inline void registerDisentangleCNOTPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDisentangleCNOTPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDisentangleCNOTPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDisentangleCNOTPass();
  });
}

//===----------------------------------------------------------------------===//
// DisentangleSWAPPass Registration
//===----------------------------------------------------------------------===//

inline void registerDisentangleSWAPPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDisentangleSWAPPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDisentangleSWAPPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDisentangleSWAPPass();
  });
}

//===----------------------------------------------------------------------===//
// EmitCatalystPyInterfacePass Registration
//===----------------------------------------------------------------------===//

inline void registerEmitCatalystPyInterfacePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createEmitCatalystPyInterfacePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerEmitCatalystPyInterfacePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createEmitCatalystPyInterfacePass();
  });
}

//===----------------------------------------------------------------------===//
// GridsynthPass Registration
//===----------------------------------------------------------------------===//

inline void registerGridsynthPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGridsynthPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGridsynthPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGridsynthPass();
  });
}

//===----------------------------------------------------------------------===//
// IonsDecompositionPass Registration
//===----------------------------------------------------------------------===//

inline void registerIonsDecompositionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createIonsDecompositionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerIonsDecompositionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createIonsDecompositionPass();
  });
}

//===----------------------------------------------------------------------===//
// LoopBoundaryOptimizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerLoopBoundaryOptimizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLoopBoundaryOptimizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLoopBoundaryOptimizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLoopBoundaryOptimizationPass();
  });
}

//===----------------------------------------------------------------------===//
// MergeRotationsPass Registration
//===----------------------------------------------------------------------===//

inline void registerMergeRotationsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMergeRotationsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMergeRotationsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMergeRotationsPass();
  });
}

//===----------------------------------------------------------------------===//
// QuantumConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerQuantumConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createQuantumConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerQuantumConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createQuantumConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// SplitMultipleTapesPass Registration
//===----------------------------------------------------------------------===//

inline void registerSplitMultipleTapesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSplitMultipleTapesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSplitMultipleTapesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSplitMultipleTapesPass();
  });
}

//===----------------------------------------------------------------------===//
// Quantum Registration
//===----------------------------------------------------------------------===//

inline void registerQuantumPasses() {
  registerAdjointLoweringPass();
  registerCancelInversesPass();
  registerCopyGlobalMemRefPass();
  registerDecomposeLoweringPass();
  registerDisentangleCNOTPass();
  registerDisentangleSWAPPass();
  registerEmitCatalystPyInterfacePass();
  registerGridsynthPass();
  registerIonsDecompositionPass();
  registerLoopBoundaryOptimizationPass();
  registerMergeRotationsPass();
  registerQuantumConversionPass();
  registerSplitMultipleTapesPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AdjointLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AdjointLoweringPassBase;

  AdjointLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AdjointLoweringPassBase(const AdjointLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  AdjointLoweringPassBase& operator=(const AdjointLoweringPassBase &) = delete;
  AdjointLoweringPassBase(AdjointLoweringPassBase &&) = delete;
  AdjointLoweringPassBase& operator=(AdjointLoweringPassBase &&) = delete;
  ~AdjointLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("adjoint-lowering");
  }
  ::llvm::StringRef getArgument() const override { return "adjoint-lowering"; }

  ::llvm::StringRef getDescription() const override { return "Lower adjoint regions containing a single quantum operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AdjointLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "AdjointLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<catalyst::CatalystDialect>();
    registry.insert<index::IndexDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<complex::ComplexDialect>();
    registry.insert<scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AdjointLoweringPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CancelInversesPassBase : public ::mlir::OperationPass<> {
public:
  using Base = CancelInversesPassBase;

  CancelInversesPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CancelInversesPassBase(const CancelInversesPassBase &other) : ::mlir::OperationPass<>(other) {}
  CancelInversesPassBase& operator=(const CancelInversesPassBase &) = delete;
  CancelInversesPassBase(CancelInversesPassBase &&) = delete;
  CancelInversesPassBase& operator=(CancelInversesPassBase &&) = delete;
  ~CancelInversesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cancel-inverses");
  }
  ::llvm::StringRef getArgument() const override { return "cancel-inverses"; }

  ::llvm::StringRef getDescription() const override { return "Perform removal of chained operations that are inverses."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CancelInversesPass");
  }
  ::llvm::StringRef getName() const override { return "CancelInversesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CancelInversesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CopyGlobalMemRefPassBase : public ::mlir::OperationPass<> {
public:
  using Base = CopyGlobalMemRefPassBase;

  CopyGlobalMemRefPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CopyGlobalMemRefPassBase(const CopyGlobalMemRefPassBase &other) : ::mlir::OperationPass<>(other) {}
  CopyGlobalMemRefPassBase& operator=(const CopyGlobalMemRefPassBase &) = delete;
  CopyGlobalMemRefPassBase(CopyGlobalMemRefPassBase &&) = delete;
  CopyGlobalMemRefPassBase& operator=(CopyGlobalMemRefPassBase &&) = delete;
  ~CopyGlobalMemRefPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cp-global-memref");
  }
  ::llvm::StringRef getArgument() const override { return "cp-global-memref"; }

  ::llvm::StringRef getDescription() const override { return "Copy global memrefs before returning from C interface."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CopyGlobalMemRefPass");
  }
  ::llvm::StringRef getName() const override { return "CopyGlobalMemRefPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CopyGlobalMemRefPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DecomposeLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DecomposeLoweringPassBase;

  DecomposeLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DecomposeLoweringPassBase(const DecomposeLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  DecomposeLoweringPassBase& operator=(const DecomposeLoweringPassBase &) = delete;
  DecomposeLoweringPassBase(DecomposeLoweringPassBase &&) = delete;
  DecomposeLoweringPassBase& operator=(DecomposeLoweringPassBase &&) = delete;
  ~DecomposeLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("decompose-lowering");
  }
  ::llvm::StringRef getArgument() const override { return "decompose-lowering"; }

  ::llvm::StringRef getDescription() const override { return "Replace quantum operations with compiled decomposition rules."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DecomposeLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "DecomposeLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DecomposeLoweringPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DisentangleCNOTPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DisentangleCNOTPassBase;

  DisentangleCNOTPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DisentangleCNOTPassBase(const DisentangleCNOTPassBase &other) : ::mlir::OperationPass<>(other) {}
  DisentangleCNOTPassBase& operator=(const DisentangleCNOTPassBase &) = delete;
  DisentangleCNOTPassBase(DisentangleCNOTPassBase &&) = delete;
  DisentangleCNOTPassBase& operator=(DisentangleCNOTPassBase &&) = delete;
  ~DisentangleCNOTPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("disentangle-CNOT");
  }
  ::llvm::StringRef getArgument() const override { return "disentangle-CNOT"; }

  ::llvm::StringRef getDescription() const override { return "Replace a CNOT gate with two single qubit gates whenever possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DisentangleCNOTPass");
  }
  ::llvm::StringRef getName() const override { return "DisentangleCNOTPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DisentangleCNOTPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> EmitFSMStateRemark{*this, "emit-FSM-state-remark", ::llvm::cl::desc("Whether to emit the state analysis result from the simple states propagation FSM onto the gate operations."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class DisentangleSWAPPassBase : public ::mlir::OperationPass<> {
public:
  using Base = DisentangleSWAPPassBase;

  DisentangleSWAPPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  DisentangleSWAPPassBase(const DisentangleSWAPPassBase &other) : ::mlir::OperationPass<>(other) {}
  DisentangleSWAPPassBase& operator=(const DisentangleSWAPPassBase &) = delete;
  DisentangleSWAPPassBase(DisentangleSWAPPassBase &&) = delete;
  DisentangleSWAPPassBase& operator=(DisentangleSWAPPassBase &&) = delete;
  ~DisentangleSWAPPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("disentangle-SWAP");
  }
  ::llvm::StringRef getArgument() const override { return "disentangle-SWAP"; }

  ::llvm::StringRef getDescription() const override { return "Replace a SWAP gate with single qubit gates and a shorter SWAPZ gates whenever possible."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DisentangleSWAPPass");
  }
  ::llvm::StringRef getName() const override { return "DisentangleSWAPPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DisentangleSWAPPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> EmitFSMStateRemark{*this, "emit-FSM-state-remark", ::llvm::cl::desc("Whether to emit the state analysis result from the simple states propagation FSM onto the gate operations."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class EmitCatalystPyInterfacePassBase : public ::mlir::OperationPass<> {
public:
  using Base = EmitCatalystPyInterfacePassBase;

  EmitCatalystPyInterfacePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  EmitCatalystPyInterfacePassBase(const EmitCatalystPyInterfacePassBase &other) : ::mlir::OperationPass<>(other) {}
  EmitCatalystPyInterfacePassBase& operator=(const EmitCatalystPyInterfacePassBase &) = delete;
  EmitCatalystPyInterfacePassBase(EmitCatalystPyInterfacePassBase &&) = delete;
  EmitCatalystPyInterfacePassBase& operator=(EmitCatalystPyInterfacePassBase &&) = delete;
  ~EmitCatalystPyInterfacePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("emit-catalyst-py-interface");
  }
  ::llvm::StringRef getArgument() const override { return "emit-catalyst-py-interface"; }

  ::llvm::StringRef getDescription() const override { return "Emit catalyst python's default interface."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EmitCatalystPyInterfacePass");
  }
  ::llvm::StringRef getName() const override { return "EmitCatalystPyInterfacePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EmitCatalystPyInterfacePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GridsynthPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GridsynthPassBase;

  GridsynthPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GridsynthPassBase(const GridsynthPassBase &other) : ::mlir::OperationPass<>(other) {}
  GridsynthPassBase& operator=(const GridsynthPassBase &) = delete;
  GridsynthPassBase(GridsynthPassBase &&) = delete;
  GridsynthPassBase& operator=(GridsynthPassBase &&) = delete;
  ~GridsynthPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gridsynth");
  }
  ::llvm::StringRef getArgument() const override { return "gridsynth"; }

  ::llvm::StringRef getDescription() const override { return "Perform Ross-Selinger/Gridsynth decomposition."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GridsynthPass");
  }
  ::llvm::StringRef getName() const override { return "GridsynthPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<catalyst::qec::QECDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GridsynthPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<double> epsilon{*this, "epsilon", ::llvm::cl::desc("Maximum error tolerance for per-gate discretization."), ::llvm::cl::init(1e-4)};
  ::mlir::Pass::Option<bool> pprBasis{*this, "ppr-basis", ::llvm::cl::desc("Whether to decompose into the PPR basis set instead of the standard Clifford+T basis set."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class IonsDecompositionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = IonsDecompositionPassBase;

  IonsDecompositionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  IonsDecompositionPassBase(const IonsDecompositionPassBase &other) : ::mlir::OperationPass<>(other) {}
  IonsDecompositionPassBase& operator=(const IonsDecompositionPassBase &) = delete;
  IonsDecompositionPassBase(IonsDecompositionPassBase &&) = delete;
  IonsDecompositionPassBase& operator=(IonsDecompositionPassBase &&) = delete;
  ~IonsDecompositionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("ions-decomposition");
  }
  ::llvm::StringRef getArgument() const override { return "ions-decomposition"; }

  ::llvm::StringRef getDescription() const override { return "Decompose the gates to the set {RX, RY, MS}"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("IonsDecompositionPass");
  }
  ::llvm::StringRef getName() const override { return "IonsDecompositionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(IonsDecompositionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LoopBoundaryOptimizationPassBase : public ::mlir::OperationPass<> {
public:
  using Base = LoopBoundaryOptimizationPassBase;

  LoopBoundaryOptimizationPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LoopBoundaryOptimizationPassBase(const LoopBoundaryOptimizationPassBase &other) : ::mlir::OperationPass<>(other) {}
  LoopBoundaryOptimizationPassBase& operator=(const LoopBoundaryOptimizationPassBase &) = delete;
  LoopBoundaryOptimizationPassBase(LoopBoundaryOptimizationPassBase &&) = delete;
  LoopBoundaryOptimizationPassBase& operator=(LoopBoundaryOptimizationPassBase &&) = delete;
  ~LoopBoundaryOptimizationPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("loop-boundary");
  }
  ::llvm::StringRef getArgument() const override { return "loop-boundary"; }

  ::llvm::StringRef getDescription() const override { return "Perform loop boundary optimization to eliminate the redundancy of operations on loop boundary."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoopBoundaryOptimizationPass");
  }
  ::llvm::StringRef getName() const override { return "LoopBoundaryOptimizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoopBoundaryOptimizationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MergeRotationsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = MergeRotationsPassBase;

  MergeRotationsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  MergeRotationsPassBase(const MergeRotationsPassBase &other) : ::mlir::OperationPass<>(other) {}
  MergeRotationsPassBase& operator=(const MergeRotationsPassBase &) = delete;
  MergeRotationsPassBase(MergeRotationsPassBase &&) = delete;
  MergeRotationsPassBase& operator=(MergeRotationsPassBase &&) = delete;
  ~MergeRotationsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("merge-rotations");
  }
  ::llvm::StringRef getArgument() const override { return "merge-rotations"; }

  ::llvm::StringRef getDescription() const override { return "Perform merging of chained rotation gates about the same axis."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergeRotationsPass");
  }
  ::llvm::StringRef getName() const override { return "MergeRotationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<math::MathDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergeRotationsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class QuantumConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = QuantumConversionPassBase;

  QuantumConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  QuantumConversionPassBase(const QuantumConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  QuantumConversionPassBase& operator=(const QuantumConversionPassBase &) = delete;
  QuantumConversionPassBase(QuantumConversionPassBase &&) = delete;
  QuantumConversionPassBase& operator=(QuantumConversionPassBase &&) = delete;
  ~QuantumConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-quantum-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-quantum-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Perform a dialect conversion from Quantum to LLVM (QIR)."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("QuantumConversionPass");
  }
  ::llvm::StringRef getName() const override { return "QuantumConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(QuantumConversionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> useArrayBackedRegisters{*this, "use-array-backed-registers", ::llvm::cl::desc("Use the array-backed-registers conversion pattern for quantum.insert ops."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class SplitMultipleTapesPassBase : public ::mlir::OperationPass<> {
public:
  using Base = SplitMultipleTapesPassBase;

  SplitMultipleTapesPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SplitMultipleTapesPassBase(const SplitMultipleTapesPassBase &other) : ::mlir::OperationPass<>(other) {}
  SplitMultipleTapesPassBase& operator=(const SplitMultipleTapesPassBase &) = delete;
  SplitMultipleTapesPassBase(SplitMultipleTapesPassBase &&) = delete;
  SplitMultipleTapesPassBase& operator=(SplitMultipleTapesPassBase &&) = delete;
  ~SplitMultipleTapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("split-multiple-tapes");
  }
  ::llvm::StringRef getArgument() const override { return "split-multiple-tapes"; }

  ::llvm::StringRef getDescription() const override { return "Given a qnode containing multiple tapes, split each tape into its own function."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SplitMultipleTapesPass");
  }
  ::llvm::StringRef getName() const override { return "SplitMultipleTapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SplitMultipleTapesPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
