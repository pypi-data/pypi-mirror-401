
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "quantum"

@_ods_cext.register_operation(_Dialect)
class AdjointOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.adjoint"

  _ODS_REGIONS = (1, True)

  def __init__(self, out_qreg, qreg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(qreg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(out_qreg)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qreg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def out_qreg(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def adjoint(out_qreg, qreg, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AdjointOp(out_qreg=out_qreg, qreg=qreg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllocOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, qreg, *, nqubits=None, nqubits_attr=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if nqubits is not None: operands.append(nqubits)
    _ods_context = _ods_get_default_loc_context(loc)
    if nqubits_attr is not None: attributes["nqubits_attr"] = (nqubits_attr if (
        isinstance(nqubits_attr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(nqubits_attr, context=_ods_context))
    results = []
    results.append(qreg)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def nqubits(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def nqubits_attr(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "nqubits_attr" not in self.operation.attributes:
      return None
    return self.operation.attributes["nqubits_attr"]

  @nqubits_attr.setter
  def nqubits_attr(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["nqubits_attr"] = value
    elif "nqubits_attr" in self.operation.attributes:
      del self.operation.attributes["nqubits_attr"]

  @nqubits_attr.deleter
  def nqubits_attr(self):
    del self.operation.attributes["nqubits_attr"]

  @builtins.property
  def qreg(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def alloc(qreg, *, nqubits=None, nqubits_attr=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AllocOp(qreg=qreg, nqubits=nqubits, nqubits_attr=nqubits_attr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllocQubitOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.alloc_qb"

  _ODS_REGIONS = (0, True)

  def __init__(self, qubit, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(qubit)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qubit(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def alloc_qb(qubit, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AllocQubitOp(qubit=qubit, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ComputationalBasisOp(_ods_ir.OpView):
  r"""
  The `quantum.compbasis` operation defines a quantum observable to be used by other
  operations such as measurement processes. The specific observable defined here is a
  "pseudo" observable to represent measurements in the computational basis.
  The only arguments are either the list of qubits to measure, or the quantum register
  to measure. When the argument is a register, the measurement occurs on all qubits in
  the register.
  
  Example:
  
  ```mlir
  func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %r: !quantum.reg)
  {
      %obs_q = quantum.compbasis qubits %q0, %q1 : !quantum.obs
      %obs_r = quantum.compbasis qreg %r : !quantum.obs
      func.return
  }
  ```
  """

  OPERATION_NAME = "quantum.compbasis"

  _ODS_OPERAND_SEGMENTS = [-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, qubits, *, qreg=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(qubits))
    operands.append(qreg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def qreg(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def obs(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def compbasis(obs, qubits, *, qreg=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ComputationalBasisOp(obs=obs, qubits=qubits, qreg=qreg, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CountsOp(_ods_ir.OpView):
  r"""
  The `quantum.counts` operation represents the measurement process of sampling eigenvalues
  from an observable on the current quantum state and counting the frequency of each
  eigenvalue.
  The only SSA argument is an observable that must be defined by an operation in the local scope.
  from an observable on the current quantum state.
  The number of samples to draw is determined by the device shots argument in the device initialization operation in the local scope.
  
  Note that the "counts dictionary" is returned as two separate arrays of the same length, one
  array for the eigenvalues, and one for count of each eigenvalue. When operating in the
  computational basis, the "eigenvalues" are the possible bitstrings one could measure on the
  given qubits, encoded as (floating-point) integers.
  
  Example:
  
  ```mlir
  func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %shots: i64)
  {
      quantum.device shots(%shots) ["rtd_lightning.so", "lightning.qubit", "{my_attr: my_attr_value}"]
      %obs = quantum.compbasis %q0, %q1 : !quantum.obs
      %counts = quantum.counts %obs : tensor<4xf64>, tensor<4xi64>
  
      %obs2 = quantum.pauli %q0[3], %q1[1] : !quantum.obs
      %counts2 = quantum.counts %obs2 : tensor<2xf64>, tensor<2xi64>
  
      func.return
  }
  ```
  """

  OPERATION_NAME = "quantum.counts"

  _ODS_OPERAND_SEGMENTS = [1,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, eigvals, counts, obs, *, dynamic_shape=None, in_eigvals=None, in_counts=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(obs)
    operands.append(dynamic_shape)
    operands.append(in_eigvals)
    operands.append(in_counts)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    if eigvals is not None: results.append(eigvals)
    if counts is not None: results.append(counts)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dynamic_shape(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def in_eigvals(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def in_counts(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def eigvals(self) -> _ods_ir.OpResultList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.results, 0, 2, 0, 0)
    return self.operation.results[start:start + elements_per_group]

  @builtins.property
  def counts(self) -> _ods_ir.OpResultList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.results, 0, 2, 0, 1)
    return self.operation.results[start:start + elements_per_group]

def counts(eigvals, counts, obs, *, dynamic_shape=None, in_eigvals=None, in_counts=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CountsOp]:
  op = CountsOp(eigvals=eigvals, counts=counts, obs=obs, dynamic_shape=dynamic_shape, in_eigvals=in_eigvals, in_counts=in_counts, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CustomOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.custom"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, params, in_qubits, gate_name, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(params))
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["gate_name"] = (gate_name if (
    isinstance(gate_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(gate_name, context=_ods_context))
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def params(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_values(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def gate_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["gate_name"]

  @gate_name.setter
  def gate_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["gate_name"] = value

  @builtins.property
  def adjoint(self) -> bool:
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def custom(out_qubits, out_ctrl_qubits, params, in_qubits, gate_name, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CustomOp]:
  op = CustomOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, params=params, in_qubits=in_qubits, gate_name=gate_name, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class DeallocOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.dealloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, qreg, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(qreg)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qreg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def dealloc(qreg, *, loc=None, ip=None) -> DeallocOp:
  return DeallocOp(qreg=qreg, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeallocQubitOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.dealloc_qb"

  _ODS_REGIONS = (0, True)

  def __init__(self, qubit, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(qubit)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qubit(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def dealloc_qb(qubit, *, loc=None, ip=None) -> DeallocQubitOp:
  return DeallocQubitOp(qubit=qubit, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceInitOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.device"

  _ODS_REGIONS = (0, True)

  def __init__(self, lib, device_name, kwargs, *, shots=None, auto_qubit_management=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if shots is not None: operands.append(shots)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(auto_qubit_management): attributes["auto_qubit_management"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    attributes["lib"] = (lib if (
    isinstance(lib, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(lib, context=_ods_context))
    attributes["device_name"] = (device_name if (
    isinstance(device_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(device_name, context=_ods_context))
    attributes["kwargs"] = (kwargs if (
    isinstance(kwargs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(kwargs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def shots(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def auto_qubit_management(self) -> bool:
    return "auto_qubit_management" in self.operation.attributes

  @auto_qubit_management.setter
  def auto_qubit_management(self, value):
    if bool(value):
      self.operation.attributes["auto_qubit_management"] = _ods_ir.UnitAttr.get()
    elif "auto_qubit_management" in self.operation.attributes:
      del self.operation.attributes["auto_qubit_management"]

  @auto_qubit_management.deleter
  def auto_qubit_management(self):
    del self.operation.attributes["auto_qubit_management"]

  @builtins.property
  def lib(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["lib"]

  @lib.setter
  def lib(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lib"] = value

  @builtins.property
  def device_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["device_name"]

  @device_name.setter
  def device_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["device_name"] = value

  @builtins.property
  def kwargs(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["kwargs"]

  @kwargs.setter
  def kwargs(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kwargs"] = value

def device(lib, device_name, kwargs, *, shots=None, auto_qubit_management=None, loc=None, ip=None) -> DeviceInitOp:
  return DeviceInitOp(lib=lib, device_name=device_name, kwargs=kwargs, shots=shots, auto_qubit_management=auto_qubit_management, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceReleaseOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.device_release"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def device_release(*, loc=None, ip=None) -> DeviceReleaseOp:
  return DeviceReleaseOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExpvalOp(_ods_ir.OpView):
  r"""
  The `quantum.expval` operation represents the measurement process of computing the
  expectation value of an observable on the current quantum state. While this quantity can
  be computed analytically on simulators, for hardware execution or shot noise
  simulation, the shots attached to the device
  in the local scope is used.
  The only SSA argument is an observable that must be defined by an operation in the local
  scope.
  
  Example:
  
  ```mlir
  func.func @foo(%q: !quantum.bit)
  {
      %obs = quantum.namedobs %q[4] : !quantum.obs
      %expval = quantum.expval %obs : f64
  
      func.return
  }
  ```
  """

  OPERATION_NAME = "quantum.expval"

  _ODS_REGIONS = (0, True)

  def __init__(self, expval, obs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(obs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(expval)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def expval(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def expval(expval, obs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExpvalOp(expval=expval, obs=obs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtractOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.extract"

  _ODS_REGIONS = (0, True)

  def __init__(self, qubit, qreg, *, idx=None, idx_attr=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(qreg)
    if idx is not None: operands.append(idx)
    _ods_context = _ods_get_default_loc_context(loc)
    if idx_attr is not None: attributes["idx_attr"] = (idx_attr if (
        isinstance(idx_attr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(idx_attr, context=_ods_context))
    results = []
    results.append(qubit)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qreg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def idx(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def idx_attr(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "idx_attr" not in self.operation.attributes:
      return None
    return self.operation.attributes["idx_attr"]

  @idx_attr.setter
  def idx_attr(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["idx_attr"] = value
    elif "idx_attr" in self.operation.attributes:
      del self.operation.attributes["idx_attr"]

  @idx_attr.deleter
  def idx_attr(self):
    del self.operation.attributes["idx_attr"]

  @builtins.property
  def qubit(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def extract(qubit, qreg, *, idx=None, idx_attr=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtractOp(qubit=qubit, qreg=qreg, idx=idx, idx_attr=idx_attr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FinalizeOp(_ods_ir.OpView):
  r"""
  Executing this instruction concretely corresponds to executing the
  ``__catalyst__rt__finalize`` function in the runtime which is expected
  to be the very last thing executed by the library.
  """

  OPERATION_NAME = "quantum.finalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def finalize(*, loc=None, ip=None) -> FinalizeOp:
  return FinalizeOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalPhaseOp(_ods_ir.OpView):
  r"""
  Applies global phase to the current system.
  """

  OPERATION_NAME = "quantum.gphase"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_ctrl_qubits, params, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(params)
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.extend(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def params(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def in_ctrl_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_values(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def adjoint(self) -> bool:
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_ctrl_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def gphase(out_ctrl_qubits, params, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, GlobalPhaseOp]:
  op = GlobalPhaseOp(out_ctrl_qubits=out_ctrl_qubits, params=params, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class HamiltonianOp(_ods_ir.OpView):
  r"""
  The `quantum.hamiltonian` operation defines a quantum observable to be used by other
  operations such as measurement processes. The specific observable defined here represents
  the hamiltonian of observables. The arguments are a set of coefficients and a set of
  `quantum.Observable` generated by `quantum.namedobs`, `quantum.hermitian`,
  or `quantum.tensorobs`.
  
  Example:
  
  ```mlir
  func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %c: tensor<2xf64>) {
      %obs1 = quantum.namedobs %q0[4] : !quantum.obs
      %obs2 = quantum.namedobs %q1[2] : !quantum.obs
      %res = quantum.hamiltonian(%c: tensor<2xf64>) %obs1, %obs2 : !quantum.obs
      func.return
  }
  ```
  """

  OPERATION_NAME = "quantum.hamiltonian"

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, coeffs, terms, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(coeffs)
    operands.extend(_get_op_results_or_values(terms))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def coeffs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def terms(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def obs(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def hamiltonian(obs, coeffs, terms, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return HamiltonianOp(obs=obs, coeffs=coeffs, terms=terms, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HermitianOp(_ods_ir.OpView):
  r"""
  The `quantum.hermitian` operation defines a quantum observable to be used by measurement
  processes. The specific observable defined here represents the Hermitian observable on a
  set of qubits. The arguments are a set of qubits to measure as well as a row-major flatten
  matrix of complex numbers that represents a Hermitian matrix that must be of size
  2^(number of qubits) * 2^(number of qubits).
  """

  OPERATION_NAME = "quantum.hermitian"

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, matrix, qubits, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(matrix)
    operands.extend(_get_op_results_or_values(qubits))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def qubits(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def obs(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def hermitian(obs, matrix, qubits, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return HermitianOp(obs=obs, matrix=matrix, qubits=qubits, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InitializeOp(_ods_ir.OpView):
  r"""
  The execution of this operation corresponds to the execution of Catalyst's runtime function
  ``__catalyst__rt__initialize`` which is the first function that will be called for the duration
  of the whole compiled object.
  """

  OPERATION_NAME = "quantum.init"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def init(*, loc=None, ip=None) -> InitializeOp:
  return InitializeOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InsertOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.insert"

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qreg, in_qreg, qubit, *, idx=None, idx_attr=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in_qreg)
    if idx is not None: operands.append(idx)
    operands.append(qubit)
    _ods_context = _ods_get_default_loc_context(loc)
    if idx_attr is not None: attributes["idx_attr"] = (idx_attr if (
        isinstance(idx_attr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(idx_attr, context=_ods_context))
    results = []
    results.append(out_qreg)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_qreg(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def idx(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[1]

  @builtins.property
  def qubit(self) -> _ods_ir.Value:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def idx_attr(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "idx_attr" not in self.operation.attributes:
      return None
    return self.operation.attributes["idx_attr"]

  @idx_attr.setter
  def idx_attr(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["idx_attr"] = value
    elif "idx_attr" in self.operation.attributes:
      del self.operation.attributes["idx_attr"]

  @idx_attr.deleter
  def idx_attr(self):
    del self.operation.attributes["idx_attr"]

  @builtins.property
  def out_qreg(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def insert(out_qreg, in_qreg, qubit, *, idx=None, idx_attr=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InsertOp(out_qreg=out_qreg, in_qreg=in_qreg, qubit=qubit, idx=idx, idx_attr=idx_attr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MeasureOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.measure"

  _ODS_REGIONS = (0, True)

  def __init__(self, mres, out_qubit, in_qubit, *, postselect=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in_qubit)
    _ods_context = _ods_get_default_loc_context(loc)
    if postselect is not None: attributes["postselect"] = (postselect if (
        isinstance(postselect, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(postselect, context=_ods_context))
    results = []
    results.append(mres)
    results.append(out_qubit)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_qubit(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def postselect(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "postselect" not in self.operation.attributes:
      return None
    return self.operation.attributes["postselect"]

  @postselect.setter
  def postselect(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["postselect"] = value
    elif "postselect" in self.operation.attributes:
      del self.operation.attributes["postselect"]

  @postselect.deleter
  def postselect(self):
    del self.operation.attributes["postselect"]

  @builtins.property
  def mres(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def out_qubit(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def measure(mres, out_qubit, in_qubit, *, postselect=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MeasureOp(mres=mres, out_qubit=out_qubit, in_qubit=in_qubit, postselect=postselect, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MultiRZOp(_ods_ir.OpView):
  r"""
  The `quantum.multirz` operation applies an arbitrary multi Z rotation to the state-vector.
  The arguments are the rotation angle `theta` and a set of qubits the operation acts on.
  
  .. note::
      This operation is one of the few quantum operations that is not applied via
      ``quantum.custom``. The reason for this is that it needs to be handled in a special
      way during the lowering due to its C function being variadic on the number of qubits.
  """

  OPERATION_NAME = "quantum.multirz"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, theta, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(theta)
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def theta(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_values(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def adjoint(self) -> bool:
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def multirz(out_qubits, out_ctrl_qubits, theta, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, MultiRZOp]:
  op = MultiRZOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, theta=theta, in_qubits=in_qubits, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class NamedObsOp(_ods_ir.OpView):
  r"""
  The `quantum.namedobs` operation defines a quantum observable to be used by measurement
  processes. The specific observable defined here represents one of 5 named observables
  {Identity, PauliX, PauliY, PauliZ, Hadamard} on a qubit. The arguments are a qubit to
  measure as well as an encoding operator for the qubit as an integer between 0-4.
  
  Example:
  
  ```mlir
  func.func @foo(%q: !quantum.bit)
  {
      %res = quantum.namedobs %q[4] : !quantum.obs
      func.return
  }
  ```
  """

  OPERATION_NAME = "quantum.namedobs"

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, qubit, type_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(qubit)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('NamedObservableAttr')) else
      _ods_ir.AttrBuilder.get('NamedObservableAttr')(type_, context=_ods_context))
    results = []
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def qubit(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def type_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def obs(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def namedobs(obs, qubit, type_, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NamedObsOp(obs=obs, qubit=qubit, type_=type_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NumQubitsOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.num_qubits"

  _ODS_REGIONS = (0, True)

  def __init__(self, num_qubits, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(num_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def num_qubits(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def num_qubits(num_qubits, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NumQubitsOp(num_qubits=num_qubits, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PCPhaseOp(_ods_ir.OpView):
  r"""
  This gate is built from simpler gates like `PhaseShift` and `PauliX` and acts on a group
  of wires and takes a rotation angle.
  It also takes another number, an integer called `dim`, which defines a specific part
  of the quantum state. The gate then applies a positive phase shift to a portion of the
  state defined by `dim`. At the same time, it applies a negative phase shift to the rest
  of the state.
  
  .. note::
      This operation is one of the few quantum operations that is not applied via
      ``quantum.custom``. The reason for this is that it needs to be handled in a special
      way during the lowering due to its C function being variadic on the number of qubits.
  
  .. note::
      `dim` is currently captured as a float number for compatibility with
      runtime and device integration.
  
  """

  OPERATION_NAME = "quantum.pcphase"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, theta, dim, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(theta)
    operands.append(dim)
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def theta(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dim(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def in_ctrl_values(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def adjoint(self) -> bool:
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def pcphase(out_qubits, out_ctrl_qubits, theta, dim, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PCPhaseOp]:
  op = PCPhaseOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, theta=theta, dim=dim, in_qubits=in_qubits, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PauliRotOp(_ods_ir.OpView):
  r"""
  The `quantum.paulirot` operation applies a rotation around a Pauli product
  operator to the state-vector. 
  The arguments are the rotation angle `angle`, a string representing the
  Pauli product operator, and a set of qubits the operation acts on.
  Note that this operation is currently not excutable. There isn't a valid 
  lowering path to the LLVM IR.
  """

  OPERATION_NAME = "quantum.paulirot"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, angle, pauli_product, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(angle)
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pauli_product"] = (pauli_product if (
    isinstance(pauli_product, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PauliWord')) else
      _ods_ir.AttrBuilder.get('PauliWord')(pauli_product, context=_ods_context))
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def angle(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_values(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def pauli_product(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["pauli_product"]

  @pauli_product.setter
  def pauli_product(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pauli_product"] = value

  @builtins.property
  def adjoint(self) -> bool:
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def paulirot(out_qubits, out_ctrl_qubits, angle, pauli_product, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PauliRotOp]:
  op = PauliRotOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, angle=angle, pauli_product=pauli_product, in_qubits=in_qubits, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ProbsOp(_ods_ir.OpView):
  r"""
  The `quantum.probs` operation represents the measurement process of computing probabilities
  for measurement outcomes in the computational basis for a set of qubits.
  Marginal probabilities are supported, that is the provided qubits do not need to make up the
  entire statevector.
  The result array contains one element for each possible bitstring, i.e. 2^n where n is the
  number of qubits.
  
  Example:
  
  ```mlir
  func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit)
  {
      %probs = quantum.probs %q0, %q1 : tensor<4xf64>
      func.return
  }
  ```
  
  .. note::
  
      The optional operand ``state_in`` is only used after bufferization.
  """

  OPERATION_NAME = "quantum.probs"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, probabilities, obs, *, dynamic_shape=None, state_in=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(obs)
    operands.append(dynamic_shape)
    operands.append(state_in)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    if probabilities is not None: results.append(probabilities)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dynamic_shape(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def state_in(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def probabilities(self) -> _Optional[_ods_ir.OpResult]:
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def probs(probabilities, obs, *, dynamic_shape=None, state_in=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ProbsOp]:
  op = ProbsOp(probabilities=probabilities, obs=obs, dynamic_shape=dynamic_shape, state_in=state_in, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class QubitUnitaryOp(_ods_ir.OpView):
  r"""
  The `quantum.unitary` operation applies an arbitrary fixed unitary matrix to the
  state-vector. The arguments are a set of qubits and a 2-dim matrix of complex numbers
  that represents a Unitary matrix of size 2^(number of qubits) * 2^(number of qubits).
  """

  OPERATION_NAME = "quantum.unitary"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, out_ctrl_qubits, matrix, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(matrix)
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_qubits))
    operands.append(_get_op_results_or_values(in_ctrl_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(adjoint): attributes["adjoint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(out_qubits)
    results.append(out_ctrl_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_ctrl_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def in_ctrl_values(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def adjoint(self) -> bool:
    return "adjoint" in self.operation.attributes

  @adjoint.setter
  def adjoint(self, value):
    if bool(value):
      self.operation.attributes["adjoint"] = _ods_ir.UnitAttr.get()
    elif "adjoint" in self.operation.attributes:
      del self.operation.attributes["adjoint"]

  @adjoint.deleter
  def adjoint(self):
    del self.operation.attributes["adjoint"]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def out_ctrl_qubits(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def unitary(out_qubits, out_ctrl_qubits, matrix, in_qubits, in_ctrl_qubits, in_ctrl_values, *, adjoint=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, QubitUnitaryOp]:
  op = QubitUnitaryOp(out_qubits=out_qubits, out_ctrl_qubits=out_ctrl_qubits, matrix=matrix, in_qubits=in_qubits, in_ctrl_qubits=in_ctrl_qubits, in_ctrl_values=in_ctrl_values, adjoint=adjoint, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SampleOp(_ods_ir.OpView):
  r"""
  The `quantum.sample` operation represents the measurement process of sampling eigenvalues
  from an observable on the current quantum state.
  The only SSA argument is an observable that must be defined by an operation in the local scope.
  from an observable on the current quantum state.
  The number of samples to draw is determined by the device shots argument in the device initialization operation in the local scope.
  
  
  Note that the return value type depends on the type of observable provided. Computational
  basis samples are returned as a 2D array of shape (shot number, number of qubits), with all
  other observables the output is a 1D array of length equal to the shot number.
  
  Example:
  
  ```mlir
  func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %shots: i64)
  {
      quantum.device shots(%shots) ["rtd_lightning.so", "lightning.qubit", "{my_attr: my_attr_value}"]
      %obs1 = quantum.compbasis %q0, %q1 : !quantum.obs
      %samples = quantum.sample %obs1 : tensor<?xf64>
  
      %obs2 = quantum.pauli %q0[3], %q1[1] : !quantum.obs
      %samples2 = quantum.sample %obs2 : tensor<?x2xf64>
  
      func.return
  }
  ```
  
  .. note::
  
      The return value type depends on the type of observable provided. Computational
      basis samples are returned as a 2D array of shape (shot number, number of qubits), with all
      other observables the output is a 1D array of length equal to the shot number.
  
  .. note::
  
      The ``in_data`` field is needed only after bufferization. It is an implementation detail that
      transform writers are unlikely to be worried about.
  """

  OPERATION_NAME = "quantum.sample"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, samples, obs, dynamic_shape, *, in_data=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(obs)
    operands.append(_get_op_results_or_values(dynamic_shape))
    operands.append(in_data)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    if samples is not None: results.append(samples)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dynamic_shape(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def in_data(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def samples(self) -> _Optional[_ods_ir.OpResult]:
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def sample(samples, obs, dynamic_shape, *, in_data=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SampleOp]:
  op = SampleOp(samples=samples, obs=obs, dynamic_shape=dynamic_shape, in_data=in_data, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SetBasisStateOp(_ods_ir.OpView):
  r"""
  This operation is useful for simulators implementing set basis state.
  Instead of decomposing basis state into multiple operations, this
  operation shortcuts all of that into a single operation.
  This signature matches the one in pennylane-lightning which expects
  only a single integer as opposed to a binary digit.
  """

  OPERATION_NAME = "quantum.set_basis_state"

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, basis_state, in_qubits, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(basis_state)
    operands.extend(_get_op_results_or_values(in_qubits))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def basis_state(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def set_basis_state(out_qubits, basis_state, in_qubits, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SetBasisStateOp]:
  op = SetBasisStateOp(out_qubits=out_qubits, basis_state=basis_state, in_qubits=in_qubits, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SetStateOp(_ods_ir.OpView):
  r"""
  This operation is useful for simulators implementing state preparation.
  Instead of decomposing state preparation into multiple operations, this
  operation shortcuts all of that into a single operation.
  """

  OPERATION_NAME = "quantum.set_state"

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, in_state, in_qubits, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in_state)
    operands.extend(_get_op_results_or_values(in_qubits))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_state(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def set_state(out_qubits, in_state, in_qubits, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SetStateOp]:
  op = SetStateOp(out_qubits=out_qubits, in_state=in_state, in_qubits=in_qubits, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class StateOp(_ods_ir.OpView):
  r"""
  The `quantum.state` operation represents the measurement process of returning the current
  statevector in the computational basis. Typically reserved for simulator devices, although
  in principle also achievable on hardware via tomography techniques.
  While marginal states are supported, the operation is only well-defined if the provided
  qubits are not entangled with the rest of the quantum state.
  The result array contains one (complex) element for each possible bitstring, i.e. 2^n where
  n is the number of qubits.
  
  Example:
  
  ```mlir
  func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit)
  {
      %obs = quantum.compbasis qubits %q0, %q1 : !quantum.obs
      %state = quantum.state %obs : tensor<4xcomplex<f64>>
      func.return
  }
  ```
  """

  OPERATION_NAME = "quantum.state"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, state, obs, *, dynamic_shape=None, state_in=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(obs)
    operands.append(dynamic_shape)
    operands.append(state_in)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    if state is not None: results.append(state)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def dynamic_shape(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def state_in(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def state(self) -> _Optional[_ods_ir.OpResult]:
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def state(state, obs, *, dynamic_shape=None, state_in=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, StateOp]:
  op = StateOp(state=state, obs=obs, dynamic_shape=dynamic_shape, state_in=state_in, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class TensorOp(_ods_ir.OpView):
  r"""
  The `quantum.tensor` operation defines a quantum observable to be used by other
  operations such as measurement processes. The specific observable defined here represents
  the tensor product of observables on a set of qubits. The arguments are a set of
  `quantum.Observable` generated by `quantum.namedobs` and `quantum.hermitian`.
  
  Example:
  
  ```mlir
  func.func @foo(%q0: !quantum.bit, %q1: !quantum.bit, %m: tensor<2x2xcomplex<f64>>)
  {
      %obs1 = quantum.namedobs %q0[4] : !quantum.obs
      %obs2 = quantum.hermitian(%m: tensor<2x2xcomplex<f64>>) %q1 : !quantum.obs
      %res = quantum.tensorprod %obs1, %obs2 : !quantum.obs
      func.return
  }
  ```
  """

  OPERATION_NAME = "quantum.tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, obs, terms, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(terms))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(obs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def terms(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def obs(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tensor(obs, terms, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TensorOp(obs=obs, terms=terms, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VarianceOp(_ods_ir.OpView):
  r"""
  The `quantum.var` operation represents the measurement process of computing the variance of
  an observable on the current quantum state. While this quantity can be computed analytically on simulators, for hardware execution or shot noise
  simulation, the shots attached to the device
  in the local scope is used.
  The only SSA argument is an observable that must be defined by an operation in the local
  scope.
  
  Example:
  
  ```mlir
  func.func @foo(%q: !quantum.bit)
  {
      %obs = quantum.namedobs %q[4] : !quantum.obs
      %var = quantum.var %obs : f64
  
      func.return
  }
  ```
  """

  OPERATION_NAME = "quantum.var"

  _ODS_REGIONS = (0, True)

  def __init__(self, variance, obs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(obs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(variance)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def obs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def variance(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def var(variance, obs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return VarianceOp(variance=variance, obs=obs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "quantum.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, retvals, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(retvals))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def retvals(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(retvals, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(retvals=retvals, loc=loc, ip=ip)
