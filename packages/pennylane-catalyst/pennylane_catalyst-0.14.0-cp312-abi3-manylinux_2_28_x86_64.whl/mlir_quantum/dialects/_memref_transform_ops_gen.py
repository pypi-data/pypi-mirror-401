
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class ApplyAllocToAllocaOp(_ods_ir.OpView):
  r"""
  Collects patterns to rewrite scoped dynamic allocation (`alloc`/`dealloc`
  pairs) into automatic allocation (`alloca`) in the same scope, for memrefs
  of static shape.
  
  The `size_limit` attribute controls the maximum allocated memory (in bytes,
  subject to data layout) for which the pattern applies.
  """

  OPERATION_NAME = "transform.apply_patterns.memref.alloc_to_alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, size_limit=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if size_limit is not None: attributes["size_limit"] = (size_limit if (
        isinstance(size_limit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(size_limit, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size_limit(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "size_limit" not in self.operation.attributes:
      return None
    return self.operation.attributes["size_limit"]

  @size_limit.setter
  def size_limit(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["size_limit"] = value
    elif "size_limit" in self.operation.attributes:
      del self.operation.attributes["size_limit"]

  @size_limit.deleter
  def size_limit(self):
    del self.operation.attributes["size_limit"]

def apply_patterns_memref_alloc_to_alloca(*, size_limit=None, loc=None, ip=None) -> ApplyAllocToAllocaOp:
  return ApplyAllocToAllocaOp(size_limit=size_limit, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyExpandOpsPatternsOp(_ods_ir.OpView):
  r"""
  Collects patterns to rewrite ops within the memref dialect.
  
  - Converts `atomic_rmw` that cannot be lowered to a simple atomic op with
    AtomicRMWOpLowering pattern, e.g. with "minf" or "maxf" attributes, to
    `memref.generic_atomic_rmw` with the expanded code.
  - Converts `memref.reshape` that has a target shape of a statically-known
    size to `memref.reinterpret_cast`.
  """

  OPERATION_NAME = "transform.apply_patterns.memref.expand_ops"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_expand_ops(*, loc=None, ip=None) -> ApplyExpandOpsPatternsOp:
  return ApplyExpandOpsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyExpandStridedMetadataPatternsOp(_ods_ir.OpView):
  r"""
  Collects patterns for expanding memref operations that modify the metadata
  (sizes, offset, strides) of a memref into easier to analyze constructs.
  """

  OPERATION_NAME = "transform.apply_patterns.memref.expand_strided_metadata"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_expand_strided_metadata(*, loc=None, ip=None) -> ApplyExpandStridedMetadataPatternsOp:
  return ApplyExpandStridedMetadataPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyExtractAddressComputationsPatternsOp(_ods_ir.OpView):
  r"""
  Collects patterns for extracting address computations from operations
  with memory accesses such that these memory accesses use only a base
  pointer.
  
  For instance,
  ```mlir
  memref.load %base[%off0, ...]
  ```
  
  Will be rewritten in:
  ```mlir
  %new_base = memref.subview %base[%off0,...][1,...][1,...]
  memref.load %new_base[%c0,...]
  ```
  """

  OPERATION_NAME = "transform.apply_patterns.memref.extract_address_computations"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_extract_address_computations(*, loc=None, ip=None) -> ApplyExtractAddressComputationsPatternsOp:
  return ApplyExtractAddressComputationsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyFoldMemrefAliasOpsPatternsOp(_ods_ir.OpView):
  r"""
  Collects patterns for folding memref aliasing ops (memref.subview) into
  consumer load/store ops (affine.load, memref.load, nvgpu.ldmatrix,
  vector.load, vector.transfer_read, affine.store, memref.store, etc.) and
  other ops (e.g., memref.subview).
  """

  OPERATION_NAME = "transform.apply_patterns.memref.fold_memref_alias_ops"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_fold_memref_alias_ops(*, loc=None, ip=None) -> ApplyFoldMemrefAliasOpsPatternsOp:
  return ApplyFoldMemrefAliasOpsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ApplyResolveRankedShapedTypeResultDimsPatternsOp(_ods_ir.OpView):
  r"""
  Collects patterns that resolve `memref.dim` operations with values that are
  defined by operations that implement the `ReifyRankedShapedTypeOpInterface`,
  in terms of shapes of its input operands.
  """

  OPERATION_NAME = "transform.apply_patterns.memref.resolve_ranked_shaped_type_result_dims"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def apply_patterns_memref_resolve_ranked_shaped_type_result_dims(*, loc=None, ip=None) -> ApplyResolveRankedShapedTypeResultDimsPatternsOp:
  return ApplyResolveRankedShapedTypeResultDimsPatternsOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MemRefAllocaToGlobalOp(_ods_ir.OpView):
  r"""
  Inserts a new `memref.global` for each provided `memref.alloca` into the
  nearest symbol table (e.g., a `builtin.module`) and replaces it with a
  `memref.get_global`. This is useful, for example, for allocations that
  should reside in the shared memory of a GPU, which have to be declared as
  globals.
  
  #### Example
  
  Consider the following transform op:
  
  ```mlir
  %get_global, %global =
      transform.memref.alloca_to_global %alloca
        : (!transform.op<"memref.alloca">)
          -> (!transform.any_op, !transform.any_op)
  ```
  
  and the following input payload:
  
  ```mlir
  module {
    func.func @func() {
      %alloca = memref.alloca() : memref<2x32xf32>
      // usages of %alloca...
    }
  }
  ```
  
  then applying the transform op to the payload would result in the following
  output IR:
  
  ```mlir
  module {
    memref.global "private" @alloc : memref<2x32xf32>
    func.func @func() {
      %alloca = memref.get_global @alloc : memref<2x32xf32>
      // usages of %alloca...
    }
  }
  ```
  
  #### Return modes
  
  Succeeds always. The returned handles refer to the `memref.get_global` and
  `memref.global` ops that were inserted by the transformation.
  """

  OPERATION_NAME = "transform.memref.alloca_to_global"

  _ODS_REGIONS = (0, True)

  def __init__(self, getGlobal, global_, alloca, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(alloca)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(getGlobal)
    results.append(global_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def alloca(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def getGlobal(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def global_(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def memref_alloca_to_global(get_global, global_, alloca, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MemRefAllocaToGlobalOp(getGlobal=get_global, global_=global_, alloca=alloca, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class MemRefEraseDeadAllocAndStoresOp(_ods_ir.OpView):
  r"""
  This applies memory optimization on memref. In particular it does store to
  load forwarding, dead store elimination and dead alloc/alloca elimination.
  
  #### Return modes
  
  This operation applies a set of memory optimization on the whole region of
  the operand.
  
  The transformation does not consume the target handle. It modifies the
  payload. Dead allocations, loads and stores are silently dropped from all
  mappings.
  """

  OPERATION_NAME = "transform.memref.erase_dead_alloc_and_stores"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def memref_erase_dead_alloc_and_stores(target, *, loc=None, ip=None) -> MemRefEraseDeadAllocAndStoresOp:
  return MemRefEraseDeadAllocAndStoresOp(target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MemRefMakeLoopIndependentOp(_ods_ir.OpView):
  r"""
  Rewrite the targeted ops such that their index-typed operands no longer
  depend on any loop induction variable of the `num_loop` enclosing `scf.for`
  loops. I.e., compute an upper bound that is independent of any such loop IV
  for every tensor dimension. The transformed op could then be hoisted from
  the `num_loop` enclosing loops. To preserve the original semantics, place a
  `memref.subview` inside the loop.
  
  Currently supported operations are:
  - memref.alloca: Replaced with a new memref.alloca with upper bound sizes,
    followed by a memref.subview.
  
  #### Return modes
  
  This operation fails if at least one induction variable could not be
  eliminated. In case the targeted op is already independent of induction
  variables, this transform succeeds and returns the unmodified target op.
  
  Otherwise, the returned handle points to a subset of the produced ops:
  - memref.alloca: The returned handle points to the memref.subview op.
  
  This transform op consumes the target handle and produces a result handle.
  """

  OPERATION_NAME = "transform.memref.make_loop_independent"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, num_loops, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_loops"] = (num_loops if (
    isinstance(num_loops, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_loops, context=_ods_context))
    results = []
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def num_loops(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["num_loops"]

  @num_loops.setter
  def num_loops(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_loops"] = value

  @builtins.property
  def transformed(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def memref_make_loop_independent(transformed, target, num_loops, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemRefMakeLoopIndependentOp(transformed=transformed, target=target, num_loops=num_loops, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemRefMultiBufferOp(_ods_ir.OpView):
  r"""
  Transformation to do multi-buffering/array expansion to remove
  dependencies on the temporary allocation between consecutive loop
  iterations. This transform expands the size of an allocation by
  a given multiplicative factor and fixes up any users of the
  multibuffered allocation.
  If skip analysis is not set the transformation will only apply
  if it can prove that there is no data being carried across loop
  iterations.
  
  #### Return modes
  
  This operation returns the new allocation if multi-buffering
  succeeds, and failure otherwise.
  """

  OPERATION_NAME = "transform.memref.multibuffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, factor, *, skip_analysis=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["factor"] = (factor if (
    isinstance(factor, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(factor, context=_ods_context))
    if bool(skip_analysis): attributes["skip_analysis"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def factor(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["factor"]

  @factor.setter
  def factor(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["factor"] = value

  @builtins.property
  def skip_analysis(self) -> bool:
    return "skip_analysis" in self.operation.attributes

  @skip_analysis.setter
  def skip_analysis(self, value):
    if bool(value):
      self.operation.attributes["skip_analysis"] = _ods_ir.UnitAttr.get()
    elif "skip_analysis" in self.operation.attributes:
      del self.operation.attributes["skip_analysis"]

  @skip_analysis.deleter
  def skip_analysis(self):
    del self.operation.attributes["skip_analysis"]

  @builtins.property
  def transformed(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def memref_multibuffer(transformed, target, factor, *, skip_analysis=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MemRefMultiBufferOp(transformed=transformed, target=target, factor=factor, skip_analysis=skip_analysis, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemrefToLLVMTypeConverterOp(_ods_ir.OpView):
  r"""
  This operation provides an "LLVMTypeConverter" that lowers memref types to
  LLVM types.
  
  The type converter can be customized as follows:
  - `use_aligned_alloc`: Use aligned_alloc in place of malloc for heap
    allocations.
  - `index_bitwidth`: Bitwidth of the index type, "0" indicates the size of a
    machine word.
  - `use_generic_functions`: Use generic allocation and deallocation functions
    instead of the classic "malloc", "aligned_alloc" and "free" functions.
  // TODO: the following two options don't really make sense for 
  // memref_to_llvm_type_converter specifically.
  // We should have a single to_llvm_type_converter.
  - `use_bare_ptr_call_conv`: Replace FuncOp's MemRef arguments with bare 
    pointers to the MemRef element types.
  - `data-layout`: String description (LLVM format) of the data layout that is
    expected on the produced module.
  """

  OPERATION_NAME = "transform.apply_conversion_patterns.memref.memref_to_llvm_type_converter"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, use_aligned_alloc=None, index_bitwidth=None, use_generic_functions=None, use_bare_ptr_call_conv=None, data_layout=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if use_aligned_alloc is not None: attributes["use_aligned_alloc"] = (use_aligned_alloc if (
        isinstance(use_aligned_alloc, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_aligned_alloc, context=_ods_context))
    if index_bitwidth is not None: attributes["index_bitwidth"] = (index_bitwidth if (
        isinstance(index_bitwidth, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(index_bitwidth, context=_ods_context))
    if use_generic_functions is not None: attributes["use_generic_functions"] = (use_generic_functions if (
        isinstance(use_generic_functions, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_generic_functions, context=_ods_context))
    if use_bare_ptr_call_conv is not None: attributes["use_bare_ptr_call_conv"] = (use_bare_ptr_call_conv if (
        isinstance(use_bare_ptr_call_conv, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_bare_ptr_call_conv, context=_ods_context))
    if data_layout is not None: attributes["data_layout"] = (data_layout if (
        isinstance(data_layout, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(data_layout, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def use_aligned_alloc(self) -> _Optional[_ods_ir.BoolAttr]:
    if "use_aligned_alloc" not in self.operation.attributes:
      return None
    return self.operation.attributes["use_aligned_alloc"]

  @use_aligned_alloc.setter
  def use_aligned_alloc(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["use_aligned_alloc"] = value
    elif "use_aligned_alloc" in self.operation.attributes:
      del self.operation.attributes["use_aligned_alloc"]

  @use_aligned_alloc.deleter
  def use_aligned_alloc(self):
    del self.operation.attributes["use_aligned_alloc"]

  @builtins.property
  def index_bitwidth(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "index_bitwidth" not in self.operation.attributes:
      return None
    return self.operation.attributes["index_bitwidth"]

  @index_bitwidth.setter
  def index_bitwidth(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["index_bitwidth"] = value
    elif "index_bitwidth" in self.operation.attributes:
      del self.operation.attributes["index_bitwidth"]

  @index_bitwidth.deleter
  def index_bitwidth(self):
    del self.operation.attributes["index_bitwidth"]

  @builtins.property
  def use_generic_functions(self) -> _Optional[_ods_ir.BoolAttr]:
    if "use_generic_functions" not in self.operation.attributes:
      return None
    return self.operation.attributes["use_generic_functions"]

  @use_generic_functions.setter
  def use_generic_functions(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["use_generic_functions"] = value
    elif "use_generic_functions" in self.operation.attributes:
      del self.operation.attributes["use_generic_functions"]

  @use_generic_functions.deleter
  def use_generic_functions(self):
    del self.operation.attributes["use_generic_functions"]

  @builtins.property
  def use_bare_ptr_call_conv(self) -> _Optional[_ods_ir.BoolAttr]:
    if "use_bare_ptr_call_conv" not in self.operation.attributes:
      return None
    return self.operation.attributes["use_bare_ptr_call_conv"]

  @use_bare_ptr_call_conv.setter
  def use_bare_ptr_call_conv(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["use_bare_ptr_call_conv"] = value
    elif "use_bare_ptr_call_conv" in self.operation.attributes:
      del self.operation.attributes["use_bare_ptr_call_conv"]

  @use_bare_ptr_call_conv.deleter
  def use_bare_ptr_call_conv(self):
    del self.operation.attributes["use_bare_ptr_call_conv"]

  @builtins.property
  def data_layout(self) -> _Optional[_ods_ir.StringAttr]:
    if "data_layout" not in self.operation.attributes:
      return None
    return self.operation.attributes["data_layout"]

  @data_layout.setter
  def data_layout(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["data_layout"] = value
    elif "data_layout" in self.operation.attributes:
      del self.operation.attributes["data_layout"]

  @data_layout.deleter
  def data_layout(self):
    del self.operation.attributes["data_layout"]

def apply_conversion_patterns_memref_memref_to_llvm_type_converter(*, use_aligned_alloc=None, index_bitwidth=None, use_generic_functions=None, use_bare_ptr_call_conv=None, data_layout=None, loc=None, ip=None) -> MemrefToLLVMTypeConverterOp:
  return MemrefToLLVMTypeConverterOp(use_aligned_alloc=use_aligned_alloc, index_bitwidth=index_bitwidth, use_generic_functions=use_generic_functions, use_bare_ptr_call_conv=use_bare_ptr_call_conv, data_layout=data_layout, loc=loc, ip=ip)
