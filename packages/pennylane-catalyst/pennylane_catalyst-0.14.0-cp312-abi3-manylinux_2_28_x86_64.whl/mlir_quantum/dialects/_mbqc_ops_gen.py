
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "mbqc"

@_ods_cext.register_operation(_Dialect)
class GraphStatePrepOp(_ods_ir.OpView):
  r"""
  This operation allocates the resources for a new quantum *graph state* for use in MBQC
  workloads. A graph state is a highly entangled group of qubits arranged according to an
  arbitrary graph structure, where each qubit is represented by a vertex of the graph and
  where there is an edge between every interacting pair of neighbouring qubits.
  
  A graph state requires three parameters to be fully expressed:
  
  1. A graph representing the qubit connectivity.
  2. The qubit initial state. All qubits in the graph state are assumed to be initialized
     to the same state. This parameter is expressed as the name of the one-qubit gate that
     would have to be applied to the :math:`|0\rangle` state to realize the desired state.
  3. The type of entangling interaction along each edge. All interactions between
     neighbouring qubits are assumed to be the same. This parameter is expressed as the name
     of the two-qubit gate that would have to be applied to the pairs of neighbouring qubits
     to realize the desired entangled state.
  
  A *densely packed adjacency matrix* is used to represent the graph structure. This
  representations is a more compact form of the familiar adjacency matrix graph
  representation, where only the lower-triangular part of the matrix is stored (since the
  graph is undirected) and where the diagonal elements are excluded (since there are no qubit
  self-interactions). The matrix values are then packed into a flat array. For example, the
  following graph structure,
  
  .. code-block::
  
      0 -- 1 -- 2 -- 3
  
  has the adjacency matrix representation (with row and column indices shown for reference):
  
  .. code-block::
  
           0  1  2  3
  
      0    0  1  0  0
      1    1  0  1  0
      2    0  1  0  1
      3    0  0  1  0
  
  The equivalent densely packed adjacency matrix has the lower-triangular part of the above
  matrix packed into a flat array using row-major order as follows (with extra space added
  between sequences of values to indicate the rows of the matrix):
  
  .. code-block::
  
      [1,   0, 1,   0, 0, 1]
  
  In this representation, the number of vertices, :math:`N`, in the graph is related to the
  number of elements, :math:`m`, in the densely packed adjacency matrix via
  
  .. math::
  
      m = N(N - 1) / 2,
  
  or inversely,
  
  .. math::
  
      N = (1 + \sqrt{1 + 8m}) / 2.
  """

  OPERATION_NAME = "mbqc.graph_state_prep"

  _ODS_REGIONS = (0, True)

  def __init__(self, qreg, adj_matrix, init_op, entangle_op, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(adj_matrix)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["init_op"] = (init_op if (
    isinstance(init_op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(init_op, context=_ods_context))
    attributes["entangle_op"] = (entangle_op if (
    isinstance(entangle_op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(entangle_op, context=_ods_context))
    results = []
    results.append(qreg)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def adj_matrix(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def init_op(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["init_op"]

  @init_op.setter
  def init_op(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["init_op"] = value

  @builtins.property
  def entangle_op(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["entangle_op"]

  @entangle_op.setter
  def entangle_op(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entangle_op"] = value

  @builtins.property
  def qreg(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def graph_state_prep(qreg, adj_matrix, init_op, entangle_op, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GraphStatePrepOp(qreg=qreg, adj_matrix=adj_matrix, init_op=init_op, entangle_op=entangle_op, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MeasureInBasisOp(_ods_ir.OpView):
  r"""
  A parametric single-qubit projective measurement is equivalent to the `quantum.measure`
  operation except that it supports measurements in an arbitrary basis, rather than the
  computational basis only. Specifically, the measurement basis is parameterized by a plane
  along the major axes of the Bloch sphere (either XY, YZ or ZX) and a rotation angle about
  that plane.
  
  The convention we have adopted to denote the measurement plane is with a two-character
  string (one of "XY", "YZ" or "ZX"), where the first character indicates the axis along which
  the basis vector is aligned for a rotation angle of 0, and the second character indicates
  the other axis that forms the plane. For instance, the measurement basis defined by the XY
  plane with a rotation angle of 0 is the Pauli-X basis, with orthonormal basis vector |+> and
  |->, which point along the +x and -x axes of the Bloch sphere, respectively. For more
  details, see the documentation for the [`qml.ftqc.measure_arbitrary_basis()`
  ](https://docs.pennylane.ai/en/stable/code/api/pennylane.ftqc.measure_arbitrary_basis.html)
  function.
  """

  OPERATION_NAME = "mbqc.measure_in_basis"

  _ODS_REGIONS = (0, True)

  def __init__(self, mres, out_qubit, in_qubit, plane, angle, *, postselect=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in_qubit)
    operands.append(angle)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["plane"] = (plane if (
    isinstance(plane, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MeasurementPlaneAttr')) else
      _ods_ir.AttrBuilder.get('MeasurementPlaneAttr')(plane, context=_ods_context))
    if postselect is not None: attributes["postselect"] = (postselect if (
        isinstance(postselect, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(postselect, context=_ods_context))
    results = []
    results.append(mres)
    results.append(out_qubit)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_qubit(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def angle(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def plane(self) -> _ods_ir.Attribute:
    return self.operation.attributes["plane"]

  @plane.setter
  def plane(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["plane"] = value

  @builtins.property
  def postselect(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "postselect" not in self.operation.attributes:
      return None
    return self.operation.attributes["postselect"]

  @postselect.setter
  def postselect(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["postselect"] = value
    elif "postselect" in self.operation.attributes:
      del self.operation.attributes["postselect"]

  @postselect.deleter
  def postselect(self):
    del self.operation.attributes["postselect"]

  @builtins.property
  def mres(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def out_qubit(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def measure_in_basis(mres, out_qubit, in_qubit, plane, angle, *, postselect=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return MeasureInBasisOp(mres=mres, out_qubit=out_qubit, in_qubit=in_qubit, plane=plane, angle=angle, postselect=postselect, loc=loc, ip=ip).results
