
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "qec"

@_ods_cext.register_operation(_Dialect)
class FabricateOp(_ods_ir.OpView):
  r"""
  The FabricateOp represents a operation that produces/fetches auxiliary qubits from a qubit factory.
  
  FabricateOp is used to prepare states not normally available in an error correction scheme,
  such as magic states |m⟩ (magic) and |m̅⟩ (magic_conj), or |Y⟩ (plus_i), and |-Y⟩ (minus_i)
  in some instances. For states constructible within the scheme, use `PrepareStateOp` instead.
  Contrary to `PrepareStateOp`, this operation does not operate on existing qubits.
  
  Example:
  ```mlir
  %0 = qec.fabricate magic: !quantum.bit
  %1 = qec.fabricate magic_conj: !quantum.bit
  %2 = qec.fabricate plus_i: !quantum.bit
  %3 = qec.fabricate minus_i: !quantum.bit
  ```
  """

  OPERATION_NAME = "qec.fabricate"

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, init_state, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["init_state"] = (init_state if (
    isinstance(init_state, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('LogicalInit')) else
      _ods_ir.AttrBuilder.get('LogicalInit')(init_state, context=_ods_context))
    results = []
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def init_state(self) -> _ods_ir.Attribute:
    return self.operation.attributes["init_state"]

  @init_state.setter
  def init_state(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["init_state"] = value

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def fabricate(out_qubits, init_state, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, FabricateOp]:
  op = FabricateOp(out_qubits=out_qubits, init_state=init_state, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class LayerOp(_ods_ir.OpView):
  r"""
  The `qec.layer` operation represents a group of PPR/PPM operations that are
  either mutually commutative within the group or act on different qubits.
  
  `qec.layer` operates on carried variables and returns the final values after termination.
  
  The body region must contain exactly one block that terminates with `qec.yield`.
  
  Example:
  ```mlir
  func.func @layer(%arg0 : !quantum.bit, %arg1 : i1) -> i1 {
      %m, %0 = qec.layer(%q0 = %arg0, %c = %arg1) : !quantum.bit, i1 {
          %res, %q_1 = qec.ppm ["Z"](4) %q0 cond(%c): !quantum.bit
          qec.yield %res, %q_1 : i1, !quantum.bit
      }
      func.return %m : i1
  }
  ```
  """

  OPERATION_NAME = "qec.layer"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, initArgs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(initArgs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initArgs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def layer(results_, init_args, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LayerOp]:
  op = LayerOp(results_=results_, initArgs=init_args, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PPMeasurementOp(_ods_ir.OpView):
  r"""
  The PPMeasurementOp represents a Pauli product measurement operation.
  It measures a set of qubits in the basis specified by a Pauli product.
  
  The operation is characterized by:
  1. A Pauli product (e.g., ["X", "I", "Z"]) specifying the measurement basis
  2. A list of input qubits to measure
  
  The operation returns:
  1. A measurement result (1-bit classical value)
  2. The post-measurement state of the qubits
  
  Example:
  ```mlir
  %result, %q0:3 = qec.ppm ["X", "I", "Z"] %q0, %q1, %q2 : i1, !quantum.bit, !quantum.bit, !quantum.bit
  ```
  This measures the three qubits in the X⊗I⊗Z basis.
  """

  OPERATION_NAME = "qec.ppm"

  _ODS_OPERAND_SEGMENTS = [-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, mres, out_qubits, pauli_product, in_qubits, *, rotation_sign=None, condition=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pauli_product"] = (pauli_product if (
    isinstance(pauli_product, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PauliWord')) else
      _ods_ir.AttrBuilder.get('PauliWord')(pauli_product, context=_ods_context))
    if rotation_sign is not None: attributes["rotation_sign"] = (rotation_sign if (
        isinstance(rotation_sign, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I16Attr')) else
          _ods_ir.AttrBuilder.get('I16Attr')(rotation_sign, context=_ods_context))
    results = []
    results.append(mres)
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def condition(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def pauli_product(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["pauli_product"]

  @pauli_product.setter
  def pauli_product(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pauli_product"] = value

  @builtins.property
  def rotation_sign(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["rotation_sign"]

  @rotation_sign.setter
  def rotation_sign(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rotation_sign"] = value

  @builtins.property
  def mres(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def ppm(mres, out_qubits, pauli_product, in_qubits, *, rotation_sign=None, condition=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PPMeasurementOp]:
  op = PPMeasurementOp(mres=mres, out_qubits=out_qubits, pauli_product=pauli_product, in_qubits=in_qubits, rotation_sign=rotation_sign, condition=condition, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PPRotationArbitraryOp(_ods_ir.OpView):
  r"""
  The PPRotationArbitraryOp represents a Pauli product rotation operation with an arbitrary angle.
  It applies a rotation of the form exp(-iθP) to a set of qubits, where:
  - P is a Pauli product (specified by pauli_product)
  - θ is the rotation angle (specified by arbitrary_angle in radians)
  
  The operation is characterized by:
  1. A Pauli product (e.g., ["X", "I", "Z"]) specifying which Pauli operators to apply
  2. A rotation angle (specified by arbitrary_angle in radians)
  3. A list of input qubits to apply the rotation to
  4. A condition (optional) for the operation to be applied only if the condition is true.
  
  Example:
  ```mlir
  %const = arith.constant 0.14 : f64
  %result = qec.ppr.arbitrary ["X", "Z"](%const) %q0, %q1 : !quantum.bit, !quantum.bit
  ```
  This applies exp(-i0.14 * X⊗Z) to the two qubits.
  """

  OPERATION_NAME = "qec.ppr.arbitrary"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, pauli_product, arbitrary_angle, in_qubits, *, condition=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(arbitrary_angle)
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pauli_product"] = (pauli_product if (
    isinstance(pauli_product, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PauliWord')) else
      _ods_ir.AttrBuilder.get('PauliWord')(pauli_product, context=_ods_context))
    results = []
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arbitrary_angle(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def condition(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def pauli_product(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["pauli_product"]

  @pauli_product.setter
  def pauli_product(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pauli_product"] = value

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def ppr_arbitrary(out_qubits, pauli_product, arbitrary_angle, in_qubits, *, condition=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PPRotationArbitraryOp]:
  op = PPRotationArbitraryOp(out_qubits=out_qubits, pauli_product=pauli_product, arbitrary_angle=arbitrary_angle, in_qubits=in_qubits, condition=condition, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PPRotationOp(_ods_ir.OpView):
  r"""
  The PPRotationOp represents a Pauli product rotation operation on a set of qubits.
  It applies a rotation of the form exp(-iθP) where:
  - P is a Pauli product (specified by pauli_product)
  - θ is the rotation angle (specified by rotation_kind in fractions of π)
  
  The operation is characterized by:
  1. A Pauli product (e.g., ["X", "I", "Z"]) specifying which Pauli operators to apply
  2. A rotation kind (in fractions of π) specifying the angle
  3. A list of input qubits to apply the rotation to
  4. A condition (optional) for the operation to be applied only if the condition is true.
  
  The operation returns the same number of qubits as input.
  
  Example:
  ```mlir
  %c0 = arith.constant true : i1
  %Q_0:3 = qec.ppr ["X", "I", "Z"](4) %q0, %q1, %q2 : !quantum.bit, !quantum.bit, !quantum.bit
  %Q_1:3 = qec.ppr ["X", "I", "Z"](4) %Q_0[0], %Q_0[1], %Q_0[2] cond(%c0) : !quantum.bit, !quantum.bit, !quantum.bit
  ```
  This applies exp(-iπ/4 * X⊗I⊗Z) to the three qubits.
  """

  OPERATION_NAME = "qec.ppr"

  _ODS_OPERAND_SEGMENTS = [-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, pauli_product, rotation_kind, in_qubits, *, condition=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(in_qubits))
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pauli_product"] = (pauli_product if (
    isinstance(pauli_product, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PauliWord')) else
      _ods_ir.AttrBuilder.get('PauliWord')(pauli_product, context=_ods_context))
    attributes["rotation_kind"] = (rotation_kind if (
    isinstance(rotation_kind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I16Attr')) else
      _ods_ir.AttrBuilder.get('I16Attr')(rotation_kind, context=_ods_context))
    results = []
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def condition(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def pauli_product(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["pauli_product"]

  @pauli_product.setter
  def pauli_product(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pauli_product"] = value

  @builtins.property
  def rotation_kind(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["rotation_kind"]

  @rotation_kind.setter
  def rotation_kind(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rotation_kind"] = value

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def ppr(out_qubits, pauli_product, rotation_kind, in_qubits, *, condition=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PPRotationOp]:
  op = PPRotationOp(out_qubits=out_qubits, pauli_product=pauli_product, rotation_kind=rotation_kind, in_qubits=in_qubits, condition=condition, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PrepareStateOp(_ods_ir.OpView):
  r"""
  Prepares non-magic states of logical qubits in a specific initial quantum state, 
  such as |0⟩, |1⟩, |+⟩, |-⟩, |Y⟩, |-Y⟩. 
  The input state of qubits can be any state, not necessarily |0⟩.
  
  By default, when allocating a qubit using `quantum.alloc_qb` or `quantum.alloc`, 
  it is prepared in the |0⟩ state.
  
  Based on QEC scheme, |Y⟩ (plus_i) and |-Y⟩ (minus_i) can be prepared as transversal 
  operations. Otherwise, if those states are fabricated, `FabricateOp` should be used.
  
  Magic state such as |m⟩ (magic) and |m̅⟩ (magic_conj) cannot be prepared 
  by this operation, use `FabricateOp` instead.
  
  Example:
  ```mlir
  %0 = qec.prepare zero %q0 : !quantum.bit
  %1 = qec.prepare one %q1 : !quantum.bit
  %2 = qec.prepare plus %q2 : !quantum.bit
  %3 = qec.prepare minus %q3 : !quantum.bit
  %4 = qec.prepare plus_i %q4 : !quantum.bit
  ```
  These prepares the logical qubit in the |0⟩ state and the |m⟩ state respectively.
  """

  OPERATION_NAME = "qec.prepare"

  _ODS_REGIONS = (0, True)

  def __init__(self, out_qubits, init_state, in_qubits, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(in_qubits))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["init_state"] = (init_state if (
    isinstance(init_state, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('LogicalInit')) else
      _ods_ir.AttrBuilder.get('LogicalInit')(init_state, context=_ods_context))
    results = []
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def init_state(self) -> _ods_ir.Attribute:
    return self.operation.attributes["init_state"]

  @init_state.setter
  def init_state(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["init_state"] = value

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def prepare(out_qubits, init_state, in_qubits, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PrepareStateOp]:
  op = PrepareStateOp(out_qubits=out_qubits, init_state=init_state, in_qubits=in_qubits, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class SelectPPMeasurementOp(_ods_ir.OpView):
  r"""
  Based on the boolean `select_switch` (type `i1`), this op selects between two Pauli product strings:  
  - If `select_switch` is 1, applies and measures using `pauli_product_0`.  
  - If `select_switch` is 0, uses `pauli_product_1`.  
  
  The operation returns:
  - `mres`: the result of the Pauli product measurement (`i1`)
  - `out_qubits`: post-measurement qubits
  
  Example:
  ```mlir
  %m3, %3 = qec.select.ppm (%m1, ["X"], ["Z"]) %1#1 : i1, !quantum.bit
  ```
  If %m1 == 1, applies "X" to %1#1; else applies "Z". Then measures.
  """

  OPERATION_NAME = "qec.select.ppm"

  _ODS_REGIONS = (0, True)

  def __init__(self, mres, out_qubits, select_switch, pauli_product_0, pauli_product_1, in_qubits, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(select_switch)
    operands.extend(_get_op_results_or_values(in_qubits))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pauli_product_0"] = (pauli_product_0 if (
    isinstance(pauli_product_0, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PauliWord')) else
      _ods_ir.AttrBuilder.get('PauliWord')(pauli_product_0, context=_ods_context))
    attributes["pauli_product_1"] = (pauli_product_1 if (
    isinstance(pauli_product_1, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PauliWord')) else
      _ods_ir.AttrBuilder.get('PauliWord')(pauli_product_1, context=_ods_context))
    results = []
    results.append(mres)
    results.extend(out_qubits)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def select_switch(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def in_qubits(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def pauli_product_0(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["pauli_product_0"]

  @pauli_product_0.setter
  def pauli_product_0(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pauli_product_0"] = value

  @builtins.property
  def pauli_product_1(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["pauli_product_1"]

  @pauli_product_1.setter
  def pauli_product_1(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pauli_product_1"] = value

  @builtins.property
  def mres(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def out_qubits(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def select_ppm(mres, out_qubits, select_switch, pauli_product_0, pauli_product_1, in_qubits, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SelectPPMeasurementOp]:
  op = SelectPPMeasurementOp(mres=mres, out_qubits=out_qubits, select_switch=select_switch, pauli_product_0=pauli_product_0, pauli_product_1=pauli_product_1, in_qubits=in_qubits, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "qec.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(results_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(results_, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(results_=results_, loc=loc, ip=ip)
