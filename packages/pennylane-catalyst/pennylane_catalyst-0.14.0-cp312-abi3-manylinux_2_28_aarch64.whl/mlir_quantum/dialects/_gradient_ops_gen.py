
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "gradient"

@_ods_cext.register_operation(_Dialect)
class AdjointOp(_ods_ir.OpView):
  OPERATION_NAME = "gradient.adjoint"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, callee, gradSize, args, data_in, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(gradSize)
    operands.append(_get_op_results_or_values(args))
    operands.append(_get_op_results_or_values(data_in))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(callee, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def gradSize(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def data_in(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def callee(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

def adjoint(result, callee, grad_size, args, data_in, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AdjointOp]:
  op = AdjointOp(result=result, callee=callee, gradSize=grad_size, args=args, data_in=data_in, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class BackpropOp(_ods_ir.OpView):
  OPERATION_NAME = "gradient.backprop"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, vals, gradients, callee, args, diffArgShadows, calleeResults, cotangents, *, diffArgIndices=None, keepValueResults=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(args))
    operands.append(_get_op_results_or_values(diffArgShadows))
    operands.append(_get_op_results_or_values(calleeResults))
    operands.append(_get_op_results_or_values(cotangents))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(callee, context=_ods_context))
    if diffArgIndices is not None: attributes["diffArgIndices"] = (diffArgIndices if (
        isinstance(diffArgIndices, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyIntElementsAttr')) else
          _ods_ir.AttrBuilder.get('AnyIntElementsAttr')(diffArgIndices, context=_ods_context))
    if keepValueResults is not None: attributes["keepValueResults"] = (keepValueResults if (
        isinstance(keepValueResults, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepValueResults, context=_ods_context))
    results = []
    results.append(vals)
    results.append(gradients)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def diffArgShadows(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def calleeResults(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def cotangents(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def callee(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def diffArgIndices(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "diffArgIndices" not in self.operation.attributes:
      return None
    return self.operation.attributes["diffArgIndices"]

  @diffArgIndices.setter
  def diffArgIndices(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["diffArgIndices"] = value
    elif "diffArgIndices" in self.operation.attributes:
      del self.operation.attributes["diffArgIndices"]

  @diffArgIndices.deleter
  def diffArgIndices(self):
    del self.operation.attributes["diffArgIndices"]

  @builtins.property
  def keepValueResults(self) -> _Optional[_ods_ir.BoolAttr]:
    if "keepValueResults" not in self.operation.attributes:
      return None
    return self.operation.attributes["keepValueResults"]

  @keepValueResults.setter
  def keepValueResults(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["keepValueResults"] = value
    elif "keepValueResults" in self.operation.attributes:
      del self.operation.attributes["keepValueResults"]

  @keepValueResults.deleter
  def keepValueResults(self):
    del self.operation.attributes["keepValueResults"]

  @builtins.property
  def vals(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def gradients(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def backprop(vals, gradients, callee, args, diff_arg_shadows, callee_results, cotangents, *, diff_arg_indices=None, keep_value_results=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, BackpropOp]:
  op = BackpropOp(vals=vals, gradients=gradients, callee=callee, args=args, diffArgShadows=diff_arg_shadows, calleeResults=callee_results, cotangents=cotangents, diffArgIndices=diff_arg_indices, keepValueResults=keep_value_results, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CustomGradOp(_ods_ir.OpView):
  r"""
  A triple of three functions. The function itself, the forward and reverse pass.
  """

  OPERATION_NAME = "gradient.custom_grad"

  _ODS_REGIONS = (0, True)

  def __init__(self, callee, forward, reverse, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    attributes["forward"] = (forward if (
    isinstance(forward, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(forward, context=_ods_context))
    attributes["reverse"] = (reverse if (
    isinstance(reverse, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(reverse, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def forward(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["forward"]

  @forward.setter
  def forward(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["forward"] = value

  @builtins.property
  def reverse(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["reverse"]

  @reverse.setter
  def reverse(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reverse"] = value

def custom_grad(callee, forward, reverse, *, loc=None, ip=None) -> CustomGradOp:
  return CustomGradOp(callee=callee, forward=forward, reverse=reverse, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ForwardOp(_ods_ir.OpView):
  r"""
  Wrapper around the concrete function. This wrapper ensures calling convention.
  
  This function matches the expected calling convention from Enzyme.
  Enzyme's calling convention expects a shadow argument for every pointer.
  Since the callbacks all expect tensors, all of them are pointers.
  Also, since the callbacks passes out parameters, then these are also duplicated.
  
  After lowered to LLVM, this function will have the following parameters:
  
  @foo(%inp0: !llvm.ptr, %diff0: !llvm.ptr,
       ...
       %inpArgc-1: !llvm.ptr, %diffArgc-1: !llvm.ptr,
       %out0: !llvm.ptr, %cotangent0: !llvm.ptr,
       ...
       %outputResc-1: !llvm.ptr, %cotangentResc-1: !llvm.ptr)
  
  The return value of enzyme is expected to be the tape.
  Enzyme's documentation has the following to say:
  
      The return type of the augmented forward pass is a struct type containing first the tape type,
      followed by the original return type, if any.
      If the return type is a duplicated type,
      then there is a third argument which contains the shadow of the return.
  
  Let's just break this down a bit:
  
      The return type of the augmented forward pass is a struct type containing first the tape type,
  
  This means that the return type for function foo will be the following in pseudocode
  
      %tape0Type = { memref elements }
      ...
      %tapeTapec-1Type = { memref elements }
      %tape = { %tape0Type, ... %tapeTapec-1Type }
      %returnTy = { %tape, ... }
  
  Then:
  
      followed by the original return type, if any.
  
  since there is none, then:
  
      %returnTy = { %tape }
  
  Then:
  
      If the return type is a duplicated type,
      then there is a third argument which contains the shadow of the return.
  
   this one is also nothing to worry for the current implementation because there are no returns.
  
   One thing that was found experimentally and through tests in Enzyme is that the tape can also be a pointer.
   We use this in the case when there is no tape to return. Instead of returning an empty struct, we return a null
   pointer that is just never dereferenced.
  
  """

  OPERATION_NAME = "gradient.forward"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, implementation, argc, resc, tape, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_478')) else
      _ods_ir.AttrBuilder.get('anonymous_478')(function_type, context=_ods_context))
    attributes["implementation"] = (implementation if (
    isinstance(implementation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(implementation, context=_ods_context))
    attributes["argc"] = (argc if (
    isinstance(argc, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(argc, context=_ods_context))
    attributes["resc"] = (resc if (
    isinstance(resc, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(resc, context=_ods_context))
    attributes["tape"] = (tape if (
    isinstance(tape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(tape, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def implementation(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["implementation"]

  @implementation.setter
  def implementation(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implementation"] = value

  @builtins.property
  def argc(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["argc"]

  @argc.setter
  def argc(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["argc"] = value

  @builtins.property
  def resc(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["resc"]

  @resc.setter
  def resc(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resc"] = value

  @builtins.property
  def tape(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["tape"]

  @tape.setter
  def tape(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tape"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def forward(sym_name, function_type, implementation, argc, resc, tape, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> ForwardOp:
  return ForwardOp(sym_name=sym_name, function_type=function_type, implementation=implementation, argc=argc, resc=resc, tape=tape, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GradOp(_ods_ir.OpView):
  r"""
  The `gradient.grad` operation computes the gradient of a function
  using the finite difference method.
  
  This operation acts much like the `func.call` operation, taking a
  symbol reference and arguments to the original function as input.
  However, instead of the function result, the gradient of the function
  is returned.
  
  Example:
  
  ```mlir
  func.func @foo(%arg0: f64) -> f64 {
      %res = arith.mulf %arg0, %arg0 : f64
      func.return %res : f64
  }
  
  %0 = arith.constant 2.0 : f64
  %1 = gradient.grad @foo(%0) : (f64) -> f64
  ```
  """

  OPERATION_NAME = "gradient.grad"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, method, callee, operands_, *, diffArgIndices=None, finiteDiffParam=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["method"] = (method if (
    isinstance(method, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(method, context=_ods_context))
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(callee, context=_ods_context))
    if diffArgIndices is not None: attributes["diffArgIndices"] = (diffArgIndices if (
        isinstance(diffArgIndices, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyIntElementsAttr')) else
          _ods_ir.AttrBuilder.get('AnyIntElementsAttr')(diffArgIndices, context=_ods_context))
    if finiteDiffParam is not None: attributes["finiteDiffParam"] = (finiteDiffParam if (
        isinstance(finiteDiffParam, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Builtin_FloatAttr')) else
          _ods_ir.AttrBuilder.get('Builtin_FloatAttr')(finiteDiffParam, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def method(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["method"]

  @method.setter
  def method(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["method"] = value

  @builtins.property
  def callee(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def diffArgIndices(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "diffArgIndices" not in self.operation.attributes:
      return None
    return self.operation.attributes["diffArgIndices"]

  @diffArgIndices.setter
  def diffArgIndices(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["diffArgIndices"] = value
    elif "diffArgIndices" in self.operation.attributes:
      del self.operation.attributes["diffArgIndices"]

  @diffArgIndices.deleter
  def diffArgIndices(self):
    del self.operation.attributes["diffArgIndices"]

  @builtins.property
  def finiteDiffParam(self) -> _Optional[_ods_ir.FloatAttr]:
    if "finiteDiffParam" not in self.operation.attributes:
      return None
    return self.operation.attributes["finiteDiffParam"]

  @finiteDiffParam.setter
  def finiteDiffParam(self, value: _Optional[_ods_ir.FloatAttr]):
    if value is not None:
      self.operation.attributes["finiteDiffParam"] = value
    elif "finiteDiffParam" in self.operation.attributes:
      del self.operation.attributes["finiteDiffParam"]

  @finiteDiffParam.deleter
  def finiteDiffParam(self):
    del self.operation.attributes["finiteDiffParam"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

def grad(result, method, callee, operands_, *, diff_arg_indices=None, finite_diff_param=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, GradOp]:
  op = GradOp(result=result, method=method, callee=callee, operands_=operands_, diffArgIndices=diff_arg_indices, finiteDiffParam=finite_diff_param, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class JVPOp(_ods_ir.OpView):
  OPERATION_NAME = "gradient.jvp"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, calleeResults, jvps, method, callee, params, tangents, *, diffArgIndices=None, finiteDiffParam=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(params))
    operands.append(_get_op_results_or_values(tangents))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["method"] = (method if (
    isinstance(method, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(method, context=_ods_context))
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(callee, context=_ods_context))
    if diffArgIndices is not None: attributes["diffArgIndices"] = (diffArgIndices if (
        isinstance(diffArgIndices, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyIntElementsAttr')) else
          _ods_ir.AttrBuilder.get('AnyIntElementsAttr')(diffArgIndices, context=_ods_context))
    if finiteDiffParam is not None: attributes["finiteDiffParam"] = (finiteDiffParam if (
        isinstance(finiteDiffParam, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Builtin_FloatAttr')) else
          _ods_ir.AttrBuilder.get('Builtin_FloatAttr')(finiteDiffParam, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(calleeResults)
    results.extend(jvps)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def params(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def tangents(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def method(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["method"]

  @method.setter
  def method(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["method"] = value

  @builtins.property
  def callee(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def diffArgIndices(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "diffArgIndices" not in self.operation.attributes:
      return None
    return self.operation.attributes["diffArgIndices"]

  @diffArgIndices.setter
  def diffArgIndices(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["diffArgIndices"] = value
    elif "diffArgIndices" in self.operation.attributes:
      del self.operation.attributes["diffArgIndices"]

  @diffArgIndices.deleter
  def diffArgIndices(self):
    del self.operation.attributes["diffArgIndices"]

  @builtins.property
  def finiteDiffParam(self) -> _Optional[_ods_ir.FloatAttr]:
    if "finiteDiffParam" not in self.operation.attributes:
      return None
    return self.operation.attributes["finiteDiffParam"]

  @finiteDiffParam.setter
  def finiteDiffParam(self, value: _Optional[_ods_ir.FloatAttr]):
    if value is not None:
      self.operation.attributes["finiteDiffParam"] = value
    elif "finiteDiffParam" in self.operation.attributes:
      del self.operation.attributes["finiteDiffParam"]

  @finiteDiffParam.deleter
  def finiteDiffParam(self):
    del self.operation.attributes["finiteDiffParam"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def calleeResults(self) -> _ods_ir.OpResultList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.results, 0, 2, 0, 0)
    return self.operation.results[start:start + elements_per_group]

  @builtins.property
  def jvps(self) -> _ods_ir.OpResultList:
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.results, 0, 2, 0, 1)
    return self.operation.results[start:start + elements_per_group]

def jvp(callee_results, jvps, method, callee, params, tangents, *, diff_arg_indices=None, finite_diff_param=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, JVPOp]:
  op = JVPOp(calleeResults=callee_results, jvps=jvps, method=method, callee=callee, params=params, tangents=tangents, diffArgIndices=diff_arg_indices, finiteDiffParam=finite_diff_param, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "gradient.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, tape, empty, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(tape))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["empty"] = (empty if (
    isinstance(empty, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I1Attr')) else
      _ods_ir.AttrBuilder.get('I1Attr')(empty, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def tape(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def empty(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["empty"]

  @empty.setter
  def empty(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["empty"] = value

def return_(tape, empty, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(tape=tape, empty=empty, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReverseOp(_ods_ir.OpView):
  r"""
  Wrapper around the concrete function. This wrapper ensures calling convention.
  
  This matches Enzyme's calling convention. From the documentation:
  
      The final argument is a custom “tape” type that can be used to pass information from the forward to the reverse pass.
  
  Experimentally, it looks like whenever there are no return values, the type passed to this function is the following type
  which matches the return type of the forward op, but it is somewhat ambiguous with what it says in the documentation.
  
      %returnTy = { %tape }
  
  """

  OPERATION_NAME = "gradient.reverse"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, implementation, argc, resc, tape, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_478')) else
      _ods_ir.AttrBuilder.get('anonymous_478')(function_type, context=_ods_context))
    attributes["implementation"] = (implementation if (
    isinstance(implementation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(implementation, context=_ods_context))
    attributes["argc"] = (argc if (
    isinstance(argc, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(argc, context=_ods_context))
    attributes["resc"] = (resc if (
    isinstance(resc, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(resc, context=_ods_context))
    attributes["tape"] = (tape if (
    isinstance(tape, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(tape, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def implementation(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["implementation"]

  @implementation.setter
  def implementation(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implementation"] = value

  @builtins.property
  def argc(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["argc"]

  @argc.setter
  def argc(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["argc"] = value

  @builtins.property
  def resc(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["resc"]

  @resc.setter
  def resc(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resc"] = value

  @builtins.property
  def tape(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["tape"]

  @tape.setter
  def tape(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tape"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def reverse(sym_name, function_type, implementation, argc, resc, tape, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> ReverseOp:
  return ReverseOp(sym_name=sym_name, function_type=function_type, implementation=implementation, argc=argc, resc=resc, tape=tape, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class VJPOp(_ods_ir.OpView):
  OPERATION_NAME = "gradient.vjp"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, calleeResults, vjps, method, callee, params, cotangents, *, diffArgIndices=None, finiteDiffParam=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(params))
    operands.append(_get_op_results_or_values(cotangents))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["method"] = (method if (
    isinstance(method, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(method, context=_ods_context))
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(callee, context=_ods_context))
    if diffArgIndices is not None: attributes["diffArgIndices"] = (diffArgIndices if (
        isinstance(diffArgIndices, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyIntElementsAttr')) else
          _ods_ir.AttrBuilder.get('AnyIntElementsAttr')(diffArgIndices, context=_ods_context))
    if finiteDiffParam is not None: attributes["finiteDiffParam"] = (finiteDiffParam if (
        isinstance(finiteDiffParam, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Builtin_FloatAttr')) else
          _ods_ir.AttrBuilder.get('Builtin_FloatAttr')(finiteDiffParam, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.append(calleeResults)
    results.append(vjps)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def params(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def cotangents(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def method(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["method"]

  @method.setter
  def method(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["method"] = value

  @builtins.property
  def callee(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def diffArgIndices(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "diffArgIndices" not in self.operation.attributes:
      return None
    return self.operation.attributes["diffArgIndices"]

  @diffArgIndices.setter
  def diffArgIndices(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["diffArgIndices"] = value
    elif "diffArgIndices" in self.operation.attributes:
      del self.operation.attributes["diffArgIndices"]

  @diffArgIndices.deleter
  def diffArgIndices(self):
    del self.operation.attributes["diffArgIndices"]

  @builtins.property
  def finiteDiffParam(self) -> _Optional[_ods_ir.FloatAttr]:
    if "finiteDiffParam" not in self.operation.attributes:
      return None
    return self.operation.attributes["finiteDiffParam"]

  @finiteDiffParam.setter
  def finiteDiffParam(self, value: _Optional[_ods_ir.FloatAttr]):
    if value is not None:
      self.operation.attributes["finiteDiffParam"] = value
    elif "finiteDiffParam" in self.operation.attributes:
      del self.operation.attributes["finiteDiffParam"]

  @finiteDiffParam.deleter
  def finiteDiffParam(self):
    del self.operation.attributes["finiteDiffParam"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def calleeResults(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def vjps(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def vjp(callee_results, vjps, method, callee, params, cotangents, *, diff_arg_indices=None, finite_diff_param=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, VJPOp]:
  op = VJPOp(calleeResults=callee_results, vjps=vjps, method=method, callee=callee, params=params, cotangents=cotangents, diffArgIndices=diff_arg_indices, finiteDiffParam=finite_diff_param, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ValueAndGradOp(_ods_ir.OpView):
  OPERATION_NAME = "gradient.value_and_grad"

  _ODS_RESULT_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, vals, gradients, method, callee, operands_, *, diffArgIndices=None, finiteDiffParam=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["method"] = (method if (
    isinstance(method, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(method, context=_ods_context))
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(callee, context=_ods_context))
    if diffArgIndices is not None: attributes["diffArgIndices"] = (diffArgIndices if (
        isinstance(diffArgIndices, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyIntElementsAttr')) else
          _ods_ir.AttrBuilder.get('AnyIntElementsAttr')(diffArgIndices, context=_ods_context))
    if finiteDiffParam is not None: attributes["finiteDiffParam"] = (finiteDiffParam if (
        isinstance(finiteDiffParam, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Builtin_FloatAttr')) else
          _ods_ir.AttrBuilder.get('Builtin_FloatAttr')(finiteDiffParam, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.append(vals)
    results.append(gradients)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def method(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["method"]

  @method.setter
  def method(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["method"] = value

  @builtins.property
  def callee(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def diffArgIndices(self) -> _Optional[_ods_ir.DenseIntElementsAttr]:
    if "diffArgIndices" not in self.operation.attributes:
      return None
    return self.operation.attributes["diffArgIndices"]

  @diffArgIndices.setter
  def diffArgIndices(self, value: _Optional[_ods_ir.DenseIntElementsAttr]):
    if value is not None:
      self.operation.attributes["diffArgIndices"] = value
    elif "diffArgIndices" in self.operation.attributes:
      del self.operation.attributes["diffArgIndices"]

  @diffArgIndices.deleter
  def diffArgIndices(self):
    del self.operation.attributes["diffArgIndices"]

  @builtins.property
  def finiteDiffParam(self) -> _Optional[_ods_ir.FloatAttr]:
    if "finiteDiffParam" not in self.operation.attributes:
      return None
    return self.operation.attributes["finiteDiffParam"]

  @finiteDiffParam.setter
  def finiteDiffParam(self, value: _Optional[_ods_ir.FloatAttr]):
    if value is not None:
      self.operation.attributes["finiteDiffParam"] = value
    elif "finiteDiffParam" in self.operation.attributes:
      del self.operation.attributes["finiteDiffParam"]

  @finiteDiffParam.deleter
  def finiteDiffParam(self):
    del self.operation.attributes["finiteDiffParam"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def vals(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 0)
    return result_range

  @builtins.property
  def gradients(self) -> _ods_ir.OpResultList:
    result_range = _ods_segmented_accessor(
         self.operation.results,
         self.operation.attributes["resultSegmentSizes"], 1)
    return result_range

def value_and_grad(vals, gradients, method, callee, operands_, *, diff_arg_indices=None, finite_diff_param=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ValueAndGradOp]:
  op = ValueAndGradOp(vals=vals, gradients=gradients, method=method, callee=callee, operands_=operands_, diffArgIndices=diff_arg_indices, finiteDiffParam=finite_diff_param, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)
