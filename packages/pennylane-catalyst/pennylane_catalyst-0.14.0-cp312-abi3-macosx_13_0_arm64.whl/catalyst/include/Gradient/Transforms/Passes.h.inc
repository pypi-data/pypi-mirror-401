/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ANNOTATEINVALIDGRADIENTFUNCTIONSPASS
#define GEN_PASS_DECL_GRADIENTCONVERSIONPASS
#define GEN_PASS_DECL_GRADIENTLOWERINGPASS
#define GEN_PASS_DECL_GRADIENTPOSTPROCESSINGPASS
#define GEN_PASS_DECL_GRADIENTPREPROCESSINGPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AnnotateInvalidGradientFunctionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ANNOTATEINVALIDGRADIENTFUNCTIONSPASS
std::unique_ptr<::mlir::Pass> createAnnotateInvalidGradientFunctionsPass();
#undef GEN_PASS_DECL_ANNOTATEINVALIDGRADIENTFUNCTIONSPASS
#endif // GEN_PASS_DECL_ANNOTATEINVALIDGRADIENTFUNCTIONSPASS
#ifdef GEN_PASS_DEF_ANNOTATEINVALIDGRADIENTFUNCTIONSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createAnnotateInvalidGradientFunctionsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class AnnotateInvalidGradientFunctionsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AnnotateInvalidGradientFunctionsPassBase;

  AnnotateInvalidGradientFunctionsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateInvalidGradientFunctionsPassBase(const AnnotateInvalidGradientFunctionsPassBase &other) : ::mlir::OperationPass<>(other) {}
  AnnotateInvalidGradientFunctionsPassBase& operator=(const AnnotateInvalidGradientFunctionsPassBase &) = delete;
  AnnotateInvalidGradientFunctionsPassBase(AnnotateInvalidGradientFunctionsPassBase &&) = delete;
  AnnotateInvalidGradientFunctionsPassBase& operator=(AnnotateInvalidGradientFunctionsPassBase &&) = delete;
  ~AnnotateInvalidGradientFunctionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("annotate-invalid-gradient-functions");
  }
  ::llvm::StringRef getArgument() const override { return "annotate-invalid-gradient-functions"; }

  ::llvm::StringRef getDescription() const override { return "Annotate functions that contain operations invalid for automatic gradient computation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateInvalidGradientFunctionsPass");
  }
  ::llvm::StringRef getName() const override { return "AnnotateInvalidGradientFunctionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<catalyst::CatalystDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<catalyst::quantum::QuantumDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateInvalidGradientFunctionsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createAnnotateInvalidGradientFunctionsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createAnnotateInvalidGradientFunctionsPass() {
  return impl::createAnnotateInvalidGradientFunctionsPass();
}
#undef GEN_PASS_DEF_ANNOTATEINVALIDGRADIENTFUNCTIONSPASS
#endif // GEN_PASS_DEF_ANNOTATEINVALIDGRADIENTFUNCTIONSPASS

//===----------------------------------------------------------------------===//
// GradientConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GRADIENTCONVERSIONPASS
struct GradientConversionPassOptions {
  bool useGenericFunctions = true;
};
std::unique_ptr<::mlir::Pass> createGradientConversionPass();
std::unique_ptr<::mlir::Pass> createGradientConversionPass(GradientConversionPassOptions options);
#undef GEN_PASS_DECL_GRADIENTCONVERSIONPASS
#endif // GEN_PASS_DECL_GRADIENTCONVERSIONPASS
#ifdef GEN_PASS_DEF_GRADIENTCONVERSIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createGradientConversionPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createGradientConversionPass(GradientConversionPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class GradientConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GradientConversionPassBase;

  GradientConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GradientConversionPassBase(const GradientConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  GradientConversionPassBase& operator=(const GradientConversionPassBase &) = delete;
  GradientConversionPassBase(GradientConversionPassBase &&) = delete;
  GradientConversionPassBase& operator=(GradientConversionPassBase &&) = delete;
  ~GradientConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gradient-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gradient-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Perform a dialect conversion from Gradient to LLVM"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GradientConversionPass");
  }
  ::llvm::StringRef getName() const override { return "GradientConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<index::IndexDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<catalyst::quantum::QuantumDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GradientConversionPassBase<DerivedT>)

  GradientConversionPassBase(GradientConversionPassOptions options) : GradientConversionPassBase() {
    useGenericFunctions = std::move(options.useGenericFunctions);
  }
protected:
  ::mlir::Pass::Option<bool> useGenericFunctions{*this, "use-generic-functions", ::llvm::cl::desc("Use generic allocation and deallocation functions instead of the classic 'malloc', 'aligned_alloc' and 'free' functions"), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createGradientConversionPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createGradientConversionPass(GradientConversionPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGradientConversionPass() {
  return impl::createGradientConversionPass();
}

std::unique_ptr<::mlir::Pass> createGradientConversionPass(GradientConversionPassOptions options) {
  return impl::createGradientConversionPass(std::move(options));
}
#undef GEN_PASS_DEF_GRADIENTCONVERSIONPASS
#endif // GEN_PASS_DEF_GRADIENTCONVERSIONPASS

//===----------------------------------------------------------------------===//
// GradientLoweringPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GRADIENTLOWERINGPASS
std::unique_ptr<::mlir::Pass> createGradientLoweringPass();
#undef GEN_PASS_DECL_GRADIENTLOWERINGPASS
#endif // GEN_PASS_DECL_GRADIENTLOWERINGPASS
#ifdef GEN_PASS_DEF_GRADIENTLOWERINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createGradientLoweringPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class GradientLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GradientLoweringPassBase;

  GradientLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GradientLoweringPassBase(const GradientLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  GradientLoweringPassBase& operator=(const GradientLoweringPassBase &) = delete;
  GradientLoweringPassBase(GradientLoweringPassBase &&) = delete;
  GradientLoweringPassBase& operator=(GradientLoweringPassBase &&) = delete;
  ~GradientLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-gradients");
  }
  ::llvm::StringRef getArgument() const override { return "lower-gradients"; }

  ::llvm::StringRef getDescription() const override { return "Lower operations in the gradient dialect to core MLIR dialects."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GradientLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "GradientLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<index::IndexDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<catalyst::CatalystDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GradientLoweringPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createGradientLoweringPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGradientLoweringPass() {
  return impl::createGradientLoweringPass();
}
#undef GEN_PASS_DEF_GRADIENTLOWERINGPASS
#endif // GEN_PASS_DEF_GRADIENTLOWERINGPASS

//===----------------------------------------------------------------------===//
// GradientPostprocessingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GRADIENTPOSTPROCESSINGPASS
std::unique_ptr<::mlir::Pass> createGradientPostprocessingPass();
#undef GEN_PASS_DECL_GRADIENTPOSTPROCESSINGPASS
#endif // GEN_PASS_DECL_GRADIENTPOSTPROCESSINGPASS
#ifdef GEN_PASS_DEF_GRADIENTPOSTPROCESSINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createGradientPostprocessingPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class GradientPostprocessingPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GradientPostprocessingPassBase;

  GradientPostprocessingPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GradientPostprocessingPassBase(const GradientPostprocessingPassBase &other) : ::mlir::OperationPass<>(other) {}
  GradientPostprocessingPassBase& operator=(const GradientPostprocessingPassBase &) = delete;
  GradientPostprocessingPassBase(GradientPostprocessingPassBase &&) = delete;
  GradientPostprocessingPassBase& operator=(GradientPostprocessingPassBase &&) = delete;
  ~GradientPostprocessingPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gradient-postprocess");
  }
  ::llvm::StringRef getArgument() const override { return "gradient-postprocess"; }

  ::llvm::StringRef getDescription() const override { return "Make the signatures of ForwardOp and ReverseOp compatibleto Enzyme."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GradientPostprocessingPass");
  }
  ::llvm::StringRef getName() const override { return "GradientPostprocessingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<index::IndexDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GradientPostprocessingPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createGradientPostprocessingPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGradientPostprocessingPass() {
  return impl::createGradientPostprocessingPass();
}
#undef GEN_PASS_DEF_GRADIENTPOSTPROCESSINGPASS
#endif // GEN_PASS_DEF_GRADIENTPOSTPROCESSINGPASS

//===----------------------------------------------------------------------===//
// GradientPreprocessingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GRADIENTPREPROCESSINGPASS
std::unique_ptr<::mlir::Pass> createGradientPreprocessingPass();
#undef GEN_PASS_DECL_GRADIENTPREPROCESSINGPASS
#endif // GEN_PASS_DECL_GRADIENTPREPROCESSINGPASS
#ifdef GEN_PASS_DEF_GRADIENTPREPROCESSINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createGradientPreprocessingPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class GradientPreprocessingPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GradientPreprocessingPassBase;

  GradientPreprocessingPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GradientPreprocessingPassBase(const GradientPreprocessingPassBase &other) : ::mlir::OperationPass<>(other) {}
  GradientPreprocessingPassBase& operator=(const GradientPreprocessingPassBase &) = delete;
  GradientPreprocessingPassBase(GradientPreprocessingPassBase &&) = delete;
  GradientPreprocessingPassBase& operator=(GradientPreprocessingPassBase &&) = delete;
  ~GradientPreprocessingPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gradient-preprocess");
  }
  ::llvm::StringRef getArgument() const override { return "gradient-preprocess"; }

  ::llvm::StringRef getDescription() const override { return "Insert Func.CallOp for ForwardOp and ReverseOp."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GradientPreprocessingPass");
  }
  ::llvm::StringRef getName() const override { return "GradientPreprocessingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<index::IndexDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GradientPreprocessingPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createGradientPreprocessingPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGradientPreprocessingPass() {
  return impl::createGradientPreprocessingPass();
}
#undef GEN_PASS_DEF_GRADIENTPREPROCESSINGPASS
#endif // GEN_PASS_DEF_GRADIENTPREPROCESSINGPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AnnotateInvalidGradientFunctionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerAnnotateInvalidGradientFunctionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAnnotateInvalidGradientFunctionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAnnotateInvalidGradientFunctionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAnnotateInvalidGradientFunctionsPass();
  });
}

//===----------------------------------------------------------------------===//
// GradientConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerGradientConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGradientConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGradientConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGradientConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// GradientLoweringPass Registration
//===----------------------------------------------------------------------===//

inline void registerGradientLoweringPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGradientLoweringPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGradientLoweringPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGradientLoweringPass();
  });
}

//===----------------------------------------------------------------------===//
// GradientPostprocessingPass Registration
//===----------------------------------------------------------------------===//

inline void registerGradientPostprocessingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGradientPostprocessingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGradientPostprocessingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGradientPostprocessingPass();
  });
}

//===----------------------------------------------------------------------===//
// GradientPreprocessingPass Registration
//===----------------------------------------------------------------------===//

inline void registerGradientPreprocessingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGradientPreprocessingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGradientPreprocessingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGradientPreprocessingPass();
  });
}

//===----------------------------------------------------------------------===//
// Gradient Registration
//===----------------------------------------------------------------------===//

inline void registerGradientPasses() {
  registerAnnotateInvalidGradientFunctionsPass();
  registerGradientConversionPass();
  registerGradientLoweringPass();
  registerGradientPostprocessingPass();
  registerGradientPreprocessingPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AnnotateInvalidGradientFunctionsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AnnotateInvalidGradientFunctionsPassBase;

  AnnotateInvalidGradientFunctionsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateInvalidGradientFunctionsPassBase(const AnnotateInvalidGradientFunctionsPassBase &other) : ::mlir::OperationPass<>(other) {}
  AnnotateInvalidGradientFunctionsPassBase& operator=(const AnnotateInvalidGradientFunctionsPassBase &) = delete;
  AnnotateInvalidGradientFunctionsPassBase(AnnotateInvalidGradientFunctionsPassBase &&) = delete;
  AnnotateInvalidGradientFunctionsPassBase& operator=(AnnotateInvalidGradientFunctionsPassBase &&) = delete;
  ~AnnotateInvalidGradientFunctionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("annotate-invalid-gradient-functions");
  }
  ::llvm::StringRef getArgument() const override { return "annotate-invalid-gradient-functions"; }

  ::llvm::StringRef getDescription() const override { return "Annotate functions that contain operations invalid for automatic gradient computation."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateInvalidGradientFunctionsPass");
  }
  ::llvm::StringRef getName() const override { return "AnnotateInvalidGradientFunctionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<catalyst::CatalystDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<catalyst::quantum::QuantumDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateInvalidGradientFunctionsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GradientConversionPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GradientConversionPassBase;

  GradientConversionPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GradientConversionPassBase(const GradientConversionPassBase &other) : ::mlir::OperationPass<>(other) {}
  GradientConversionPassBase& operator=(const GradientConversionPassBase &) = delete;
  GradientConversionPassBase(GradientConversionPassBase &&) = delete;
  GradientConversionPassBase& operator=(GradientConversionPassBase &&) = delete;
  ~GradientConversionPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-gradient-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-gradient-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Perform a dialect conversion from Gradient to LLVM"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GradientConversionPass");
  }
  ::llvm::StringRef getName() const override { return "GradientConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<index::IndexDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<func::FuncDialect>();
    registry.insert<catalyst::quantum::QuantumDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GradientConversionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> useGenericFunctions{*this, "use-generic-functions", ::llvm::cl::desc("Use generic allocation and deallocation functions instead of the classic 'malloc', 'aligned_alloc' and 'free' functions"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class GradientLoweringPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GradientLoweringPassBase;

  GradientLoweringPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GradientLoweringPassBase(const GradientLoweringPassBase &other) : ::mlir::OperationPass<>(other) {}
  GradientLoweringPassBase& operator=(const GradientLoweringPassBase &) = delete;
  GradientLoweringPassBase(GradientLoweringPassBase &&) = delete;
  GradientLoweringPassBase& operator=(GradientLoweringPassBase &&) = delete;
  ~GradientLoweringPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-gradients");
  }
  ::llvm::StringRef getArgument() const override { return "lower-gradients"; }

  ::llvm::StringRef getDescription() const override { return "Lower operations in the gradient dialect to core MLIR dialects."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GradientLoweringPass");
  }
  ::llvm::StringRef getName() const override { return "GradientLoweringPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<index::IndexDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<catalyst::CatalystDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GradientLoweringPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GradientPostprocessingPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GradientPostprocessingPassBase;

  GradientPostprocessingPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GradientPostprocessingPassBase(const GradientPostprocessingPassBase &other) : ::mlir::OperationPass<>(other) {}
  GradientPostprocessingPassBase& operator=(const GradientPostprocessingPassBase &) = delete;
  GradientPostprocessingPassBase(GradientPostprocessingPassBase &&) = delete;
  GradientPostprocessingPassBase& operator=(GradientPostprocessingPassBase &&) = delete;
  ~GradientPostprocessingPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gradient-postprocess");
  }
  ::llvm::StringRef getArgument() const override { return "gradient-postprocess"; }

  ::llvm::StringRef getDescription() const override { return "Make the signatures of ForwardOp and ReverseOp compatibleto Enzyme."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GradientPostprocessingPass");
  }
  ::llvm::StringRef getName() const override { return "GradientPostprocessingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<index::IndexDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GradientPostprocessingPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GradientPreprocessingPassBase : public ::mlir::OperationPass<> {
public:
  using Base = GradientPreprocessingPassBase;

  GradientPreprocessingPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GradientPreprocessingPassBase(const GradientPreprocessingPassBase &other) : ::mlir::OperationPass<>(other) {}
  GradientPreprocessingPassBase& operator=(const GradientPreprocessingPassBase &) = delete;
  GradientPreprocessingPassBase(GradientPreprocessingPassBase &&) = delete;
  GradientPreprocessingPassBase& operator=(GradientPreprocessingPassBase &&) = delete;
  ~GradientPreprocessingPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gradient-preprocess");
  }
  ::llvm::StringRef getArgument() const override { return "gradient-preprocess"; }

  ::llvm::StringRef getDescription() const override { return "Insert Func.CallOp for ForwardOp and ReverseOp."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GradientPreprocessingPass");
  }
  ::llvm::StringRef getName() const override { return "GradientPreprocessingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<index::IndexDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GradientPreprocessingPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
