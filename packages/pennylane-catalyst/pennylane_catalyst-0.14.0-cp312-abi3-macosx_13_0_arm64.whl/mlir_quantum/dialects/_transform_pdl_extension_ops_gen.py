
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class PDLMatchOp(_ods_ir.OpView):
  r"""
  Find Payload IR ops nested within the Payload IR op associated with the
  operand that match the PDL pattern identified by its name. The pattern is
  expected to be defined in the closest surrounding `WithPDLPatternsOp`.
  
  Produces a Transform IR value associated with the list of Payload IR ops
  that matched the pattern. The order of results in the list is that of the
  Operation::walk, clients are advised not to rely on a specific order though.
  If the operand is associated with multiple Payload IR ops, finds matching
  ops nested within each of those and produces a single list containing all
  of the matched ops.
  
  The transformation is considered successful regardless of whether some
  Payload IR ops actually matched the pattern and only fails if the pattern
  could not be looked up or compiled.
  """

  OPERATION_NAME = "transform.pdl_match"

  _ODS_REGIONS = (0, True)

  def __init__(self, matched, root, pattern_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(root)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pattern_name"] = (pattern_name if (
    isinstance(pattern_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(pattern_name, context=_ods_context))
    results = []
    results.append(matched)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def root(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def pattern_name(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["pattern_name"]

  @pattern_name.setter
  def pattern_name(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pattern_name"] = value

  @builtins.property
  def matched(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pdl_match(matched, root, pattern_name, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PDLMatchOp(matched=matched, root=root, pattern_name=pattern_name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WithPDLPatternsOp(_ods_ir.OpView):
  r"""
  This op contains a set of named PDL patterns that are available for the
  Transform dialect operations to be used for pattern matching. For example,
  PDLMatchOp can be used to produce a Transform IR value associated with all
  Payload IR operations that match the pattern as follows:
  
  ```mlir
  transform.with_pdl_patterns {
  ^bb0(%arg0: !transform.any_op):
    pdl.pattern @my_pattern : benefit(1) {
      %0 = pdl.operation //...
      // Regular PDL goes here.
      pdl.rewrite %0 with "transform.dialect"
    }
  
    sequence %arg0 failures(propagate) {
    ^bb0(%arg1: !transform.any_op):
      %1 = pdl_match @my_pattern in %arg1
      // Use %1 as handle
    }
  }
  ```
  
  Note that the pattern is expected to finish with a `pdl.rewrite` terminator
  that points to the custom rewriter named "transform.dialect". The rewriter
  actually does nothing, but the transform application will keep track of the
  operations that matched the pattern.
  
  This op is expected to contain `pdl.pattern` operations and exactly one
  another Transform dialect operation that gets executed with all patterns
  available. This op is a possible top-level Transform IR op, the argument of
  its entry block corresponds to either the root op of the payload IR or the
  ops associated with its operand when provided.
  """

  OPERATION_NAME = "transform.with_pdl_patterns"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, root=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if root is not None: operands.append(root)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def root(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def with_pdl_patterns(*, root=None, loc=None, ip=None) -> WithPDLPatternsOp:
  return WithPDLPatternsOp(root=root, loc=loc, ip=ip)
