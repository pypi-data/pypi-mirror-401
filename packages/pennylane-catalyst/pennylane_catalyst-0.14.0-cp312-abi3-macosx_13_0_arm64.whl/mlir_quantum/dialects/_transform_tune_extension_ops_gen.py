
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
class KnobOp(_ods_ir.OpView):
  r"""
  Provides a representation for "tunables" within schedules.
  
  Each op represents a single tunable, which has a `name` and a set
  of valid `options` described by an attribute. Without a specified
  `selected` option, this op represents a non-deterministic choice
  that has yet to be resolved -- as such, the interpreter runtime
  semantics is to raise a failure.
  
  The non-deterministic choice is resolved through providing a
  `selected` attribute. When provided, the interpreter runtime
  semantics are to return the `selected` attribute as a param through
  the op's result.
  
  -----
  
  In case the `options` attribute is an `ArrayAttr`, the verifier
  checks that the provided `selected` attribute occurs in `options`.
  """

  OPERATION_NAME = "transform.tune.knob"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, options, *, selected=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Builtin_StringAttr')) else
      _ods_ir.AttrBuilder.get('Builtin_StringAttr')(name, context=_ods_context))
    attributes["options"] = (options if (
    isinstance(options, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(options, context=_ods_context))
    if selected is not None: attributes["selected"] = (selected if (
        isinstance(selected, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(selected, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def options(self) -> _ods_ir.Attribute:
    return self.operation.attributes["options"]

  @options.setter
  def options(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["options"] = value

  @builtins.property
  def selected(self) -> _Optional[_ods_ir.Attribute]:
    if "selected" not in self.operation.attributes:
      return None
    return self.operation.attributes["selected"]

  @selected.setter
  def selected(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["selected"] = value
    elif "selected" in self.operation.attributes:
      del self.operation.attributes["selected"]

  @selected.deleter
  def selected(self):
    del self.operation.attributes["selected"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def tune_knob(result, name, options, *, selected=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return KnobOp(result=result, name=name, options=options, selected=selected, loc=loc, ip=ip).result
