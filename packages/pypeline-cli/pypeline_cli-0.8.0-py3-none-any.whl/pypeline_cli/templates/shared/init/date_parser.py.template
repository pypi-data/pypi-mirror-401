"""
Timezone-Aware DateTime Management

âœ… SAFE TO MODIFY - Customize as needed for your pipeline

This file provides the DateTimeManager class for validating and normalizing
timezone-aware datetime objects. All datetimes are normalized to UTC internally
for consistency across your pipeline.

Purpose:
    Provides validation, normalization, and structured parsing of timezone-aware
    datetime objects. Ensures all temporal data is properly timezone-aware and
    normalized to UTC as the source of truth.

Usage:
    from datetime import datetime
    from zoneinfo import ZoneInfo
    from pipelines.utils.date_parser import DateTimeManager

    # Create timezone-aware datetimes
    start_dt = datetime(2025, 3, 15, 14, 30, tzinfo=ZoneInfo("America/New_York"))
    end_dt = datetime.now(ZoneInfo("UTC"))

    # Validate and normalize
    dt_manager = DateTimeManager(
        is_required=True,
        start_date=start_dt,
        end_date=end_dt
    )

    # Access normalized UTC datetime
    utc_start = dt_manager.get_utc_datetime("start_date")

    # Access structured datetime information
    parsed = dt_manager.parsed_datetimes["start_date"]
    iso_utc = parsed["iso_string_utc"]        # "2025-03-15T19:30:00+00:00"
    iso_eastern = parsed["iso_string_eastern"] # "2025-03-15T14:30:00-05:00"
    year = parsed["year_utc"]                  # 2025
    month = parsed["month_utc"]                # "03"
    day = parsed["day_utc"]                    # "15"

Design Pattern:
    - UTC Normalization: All datetimes converted to UTC as source of truth
    - Timezone Validation: Ensures all datetimes are timezone-aware
    - Structured Output: Provides parsed components (year, month, day) in UTC
    - Display Timezone: Includes Eastern timezone for user-facing displays

Customization:
    Feel free to modify this file to add additional timezone conversions,
    validation rules, or datetime parsing utilities specific to your use case.
"""

from datetime import datetime, timezone
from typing import TypedDict, Dict, Optional
from zoneinfo import ZoneInfo

from .logger import Logger

MODULE_NAME = "utils/date_parser.py"


class ParsedDateTime(TypedDict):
    """
    TypedDict representing a validated datetime with UTC normalization.

    Attributes:
        iso_string_utc (str): ISO formatted string in UTC.
        iso_string_eastern (str): ISO formatted string in Eastern timezone (for display).
        datetime_utc (datetime): The datetime object normalized to UTC.
        datetime_original (datetime): The original datetime object with its timezone preserved.
        year_utc (int): The year component in UTC.
        month_utc (str): The month component in UTC, zero-padded.
        day_utc (str): The day component in UTC, zero-padded.
    """
    iso_string_utc: str
    iso_string_eastern: str
    datetime_utc: datetime
    datetime_original: datetime
    year_utc: int
    month_utc: str
    day_utc: str


class DateTimeManager:
    """
    Manages validation and normalization of timezone-aware datetime objects.
    All datetimes are normalized to UTC for consistency.

    Attributes:
        is_required (bool): Whether the datetimes are required.
        parsed_datetimes (Dict[str, ParsedDateTime]): Structured parsed datetime information.
    """

    def __init__(self, is_required: bool, **kwargs: Optional[datetime]) -> None:
        """
        Initialize DateTimeManager with timezone-aware datetime validation.

        Args:
            is_required (bool): Whether the datetimes are required. If True, raises
                ValueError for missing or timezone-naive datetimes. If False, logs
                warnings and skips invalid datetimes.
            **kwargs (Optional[datetime]): Named timezone-aware datetime objects to
                validate and normalize. Use descriptive names (e.g., start_date,
                end_date, processing_time).

        Raises:
            ValueError: If is_required=True and a datetime is missing or lacks
                timezone information.

        Examples:
            >>> from datetime import datetime
            >>> from zoneinfo import ZoneInfo
            >>>
            >>> # Required datetimes
            >>> dt_mgr = DateTimeManager(
            ...     is_required=True,
            ...     start_date=datetime(2025, 1, 1, tzinfo=ZoneInfo("America/New_York")),
            ...     end_date=datetime.now(ZoneInfo("UTC"))
            ... )
            >>>
            >>> # Optional datetimes
            >>> dt_mgr = DateTimeManager(
            ...     is_required=False,
            ...     processing_time=None  # Will log warning but not raise
            ... )
        """
        self.is_required: bool = is_required
        self._kwargs: Dict[str, Optional[datetime]] = kwargs
        self.logger: Logger = Logger()
        self.logger.info(
            message=f"Initializing DateTimeManager with is_required={is_required} and datetimes={list(kwargs.keys())}",
            context=MODULE_NAME
        )
        self.parsed_datetimes: Dict[str, ParsedDateTime] = self._parse_and_normalize_datetimes()

    def _parse_and_normalize_datetimes(self) -> Dict[str, ParsedDateTime]:
        """
        Validate and normalize timezone-aware datetimes to UTC.

        Returns:
            Dict[str, ParsedDateTime]: Mapping of datetime names to parsed datetime information.
            
        Raises:
            ValueError: If a required datetime is missing or lacks timezone info.
        """
        parsed_datetimes: Dict[str, ParsedDateTime] = {}
        eastern_tz = ZoneInfo("America/New_York")
        
        for datetime_name, datetime_object in self._kwargs.items():
            # Check if datetime object exists
            if datetime_object is None:
                if self.is_required:
                    self.logger.critical(
                        message=f"{datetime_name} is missing a datetime object.",
                        context=MODULE_NAME
                    )
                    raise ValueError(f"Datetime object for '{datetime_name}' is required.")
                else:
                    self.logger.warning(
                        message=f"Skipping {datetime_name} since datetime object was not provided.",
                        context=MODULE_NAME
                    )
                    continue
            
            # Check if datetime has timezone info
            if datetime_object.tzinfo is None:
                if self.is_required:
                    self.logger.critical(
                        message=f"{datetime_name} datetime object is missing timezone information.",
                        context=MODULE_NAME
                    )
                    raise ValueError(
                        f"{datetime_name} datetime object must include timezone information. "
                        f"Use datetime.now(timezone.utc) or datetime.now(ZoneInfo('America/New_York'))."
                    )
                else:
                    self.logger.warning(
                        message=f"Skipping {datetime_name} since datetime object lacks timezone information.",
                        context=MODULE_NAME
                    )
                    continue
            
            # Normalize to UTC (this is the core of your transition)
            dt_utc = datetime_object.astimezone(timezone.utc)
            dt_eastern = datetime_object.astimezone(eastern_tz)
            
            # Build structured datetime info with UTC as the source of truth
            parsed_datetimes[datetime_name] = {
                "iso_string_utc": dt_utc.isoformat(),
                "iso_string_eastern": dt_eastern.isoformat(),  # For display purposes only
                "datetime_utc": dt_utc,  # This is your source of truth
                "datetime_original": datetime_object,  # Preserved for reference
                "year_utc": dt_utc.year,
                "month_utc": f"{dt_utc.month:02d}",
                "day_utc": f"{dt_utc.day:02d}"
            }
            
            self.logger.debug(
                message=f"Normalized {datetime_name}: {datetime_object.isoformat()} â†’ {dt_utc.isoformat()}",
                context=MODULE_NAME
            )
        
        self.logger.info(
            message=f"Successfully normalized {len(parsed_datetimes)} datetime(s) to UTC.",
            context=MODULE_NAME
        )
        return parsed_datetimes

    def get_utc_datetime(self, name: str) -> Optional[datetime]:
        """
        Get the UTC-normalized datetime by name.

        Args:
            name (str): The name of the datetime passed to __init__.

        Returns:
            Optional[datetime]: The UTC-normalized datetime object, or None if the
                datetime was not provided or failed validation.

        Examples:
            >>> from datetime import datetime
            >>> from zoneinfo import ZoneInfo
            >>>
            >>> dt_mgr = DateTimeManager(
            ...     is_required=True,
            ...     start_date=datetime(2025, 3, 15, 14, 30, tzinfo=ZoneInfo("America/New_York"))
            ... )
            >>> utc_dt = dt_mgr.get_utc_datetime("start_date")
            >>> print(utc_dt)
            2025-03-15 19:30:00+00:00
            >>>
            >>> # Non-existent datetime
            >>> missing = dt_mgr.get_utc_datetime("nonexistent")
            >>> print(missing)
            None
        """
        parsed = self.parsed_datetimes.get(name)
        return parsed["datetime_utc"] if parsed else None