"""
Function Decorators for Pipeline Utilities

⚠️ DO NOT MODIFY THIS FILE DIRECTLY ⚠️

This file is auto-generated by pypeline-cli and provides reusable decorators
for common ETL operations. Manual modifications may be overwritten during CLI
updates or regeneration.

Purpose:
    Provides decorators for timing function execution, checking table existence,
    and skipping functions based on table freshness. These decorators help reduce
    boilerplate code and enforce consistent patterns across your pipeline.

Usage:
    from pipelines.utils.decorators import time_function, skip_if_exists, skip_if_updated_this_month
    from pipelines.utils.etl import ETL

    etl = ETL()

    # Time function execution
    @time_function("MyPipeline.process_data")
    def process_data():
        # Processing logic
        pass

    # Skip if table exists
    @skip_if_exists("my_catalog.staging.users_2025", etl)
    def create_users_table():
        # Table creation logic
        pass

    # Skip if table updated this month
    @skip_if_updated_this_month("my_catalog.staging.monthly_report", etl)
    def refresh_monthly_report():
        # Refresh logic
        pass

    # Can override the freshness check
    refresh_monthly_report(override=True)

Design Pattern:
    - Performance Monitoring: time_function logs execution duration
    - Idempotency: skip_if_exists prevents redundant table creation
    - Efficiency: skip_if_updated_this_month avoids unnecessary refreshes
    - Override Capability: Functions decorated with skip_if_updated_this_month
      accept an override parameter

For Custom Decorators:
    Create your own decorator functions that USE these base decorators rather
    than modifying this file directly. See pipeline templates for examples.
"""

import functools
import time
from datetime import datetime
from typing import Any, Callable, TypeVar, cast
from zoneinfo import ZoneInfo

from .logger import Logger
from .etl import ETL

F = TypeVar('F', bound=Callable[..., Any])


def time_function(module_name: str) -> Callable[[F], F]:
    """
    Decorator that measures and logs the execution time of a function.

    This decorator wraps a function to track its execution time using high-precision
    performance counters. The elapsed time is logged with the module name for easy
    identification in log files.

    Args:
        module_name (str): The name of the module or component to include in the log message.
                          This helps identify which function's timing is being reported.

    Returns:
        function: A decorator function that can be applied to other functions.

    Example:
        >>> @time_function("DataProcessor")
        ... def process_data(data):
        ...     # Process data
        ...     return processed_data

        >>> result = process_data(my_data)
        # Logs: "DataProcessor completed in 1.23 seconds."

    Note:
        The decorator preserves the original function's metadata (name, docstring, etc.)
        using functools.wraps.
    """
    def decorator_timer(func: F) -> F:
        """
        Inner decorator that wraps the target function.

        Args:
            func (callable): The function to be timed.

        Returns:
            function: The wrapped function with timing capability.
        """
        @functools.wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            """
            Wrapper that executes the function and measures its execution time.

            Args:
                *args: Positional arguments to pass to the wrapped function.
                **kwargs: Keyword arguments to pass to the wrapped function.

            Returns:
                The return value of the wrapped function.
            """
            start = time.perf_counter()
            result = func(*args, **kwargs)
            end = time.perf_counter()
            elapsed = end - start
            Logger.info(f"{module_name} completed in {elapsed:.2f} seconds.")
            return result
        return cast(F, wrapper)
    return decorator_timer


def skip_if_exists(table_string: str, etl: ETL) -> Callable[[F], F]:
    """
    Decorator that skips function execution if the specified table already exists.

    This decorator checks for table existence before executing the wrapped function.
    If the table exists, the function is skipped and None is returned. Otherwise,
    the function executes normally.

    Args:
        table_string (str): Full table path in format 'catalog.schema.table'
        etl (ETL): ETL session object with catalog access for checking table existence

    Returns:
        function: A decorator function that can be applied to table creation functions.

    Example:
        >>> @skip_if_exists('my_catalog.staging.users_2024_11', etl_session)
        ... def create_users_table():
        ...     # Table creation logic
        ...     pass

        >>> create_users_table()
        # Logs: "Table my_catalog.staging.users_2024_11 already exists. Skipping create_users_table."

    Raises:
        ValueError: If table_string is not in the correct 'catalog.schema.table' format

    Note:
        The decorator preserves the original function's metadata using functools.wraps.
    """
    def decorator(func: F) -> F:
        """
        Inner decorator that wraps the target function.

        Args:
            func (callable): The function to conditionally execute.

        Returns:
            function: The wrapped function with existence checking.
        """
        @functools.wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            """
            Wrapper that checks table existence before executing the function.

            Args:
                *args: Positional arguments to pass to the wrapped function.
                **kwargs: Keyword arguments to pass to the wrapped function.

            Returns:
                The return value of the wrapped function, or None if skipped.
            """
            if table_exists(table_string, etl):
                Logger.info(
                    f"Table {table_string} already exists. Skipping {func.__name__}."
                )
                return None
            return func(*args, **kwargs)
        return cast(F, wrapper)
    return decorator


def table_exists(table_string: str, etl: ETL) -> bool:
    """
    Check if a table exists in Databricks Unity Catalog.

    Parses the table string and queries the Databricks catalog to determine
    if the specified table exists.

    Args:
        table_string (str): Fully qualified table path in format 'catalog.schema.table'
        etl (ETL): ETL session object with catalog access

    Returns:
        bool: True if table exists, False otherwise

    Raises:
        ValueError: If table_string is not in the correct 'catalog.schema.table' format

    Examples:
        >>> from pipelines.utils.etl import ETL
        >>> from pipelines.utils.decorators import table_exists
        >>>
        >>> etl = ETL()
        >>> exists = table_exists('my_catalog.staging.users', etl)
        >>> print(exists)
        True
        >>>
        >>> # Non-existent table
        >>> exists = table_exists('my_catalog.staging.nonexistent', etl)
        >>> print(exists)
        False

    Note:
        This function is used internally by the skip_if_exists decorator.
    """
    catalog, schema, table = parse_table_string(table_string)

    try:
        # Use PySpark catalog API to check table existence
        # tableExists() expects the fully qualified name
        full_name = f"{catalog}.{schema}.{table}"
        return etl.session.catalog.tableExists(full_name)
    except Exception as e:
        Logger.error(f"Error checking table existence for {table_string}: {str(e)}")
        return False

def skip_if_updated_this_month(table_string: str, etl: ETL) -> Callable[[F], F]:
    """
    Decorator that skips function execution if the table was updated this month.

    Checks the last altered timestamp of a Databricks table from Unity Catalog
    and skips execution if the table has been modified in the current month.
    Can be overridden by passing override=True to the wrapped function.

    Args:
        table_string (str): Full table path in format 'catalog.schema.table'
        etl (ETL): ETL session object for executing queries

    Returns:
        function: A decorator function that can be applied to table update functions.

    Example:
        >>> @skip_if_updated_this_month('my_catalog.staging.users_2024_11', etl)
        ... def refresh_users_table():
        ...     # Refresh logic
        ...     pass

        >>> refresh_users_table()  # Skips if updated this month
        >>> refresh_users_table(override=True)  # Forces execution

    Note:
        The wrapped function can accept an 'override' keyword argument to bypass
        the freshness check.
    """
    def decorator(func: F) -> F:
        @functools.wraps(func)
        def wrapper(*args: Any, override: bool = False, **kwargs: Any) -> Any:
            if override:
                Logger.info(
                    message=f"Override set to True for {func.__name__}. Running function."
                )
                return func(*args, **kwargs)

            try:
                catalog, schema, table = parse_table_string(table_string)

                # Query Unity Catalog INFORMATION_SCHEMA for last_altered timestamp
                query = f"""
                    SELECT
                        table_catalog,
                        table_schema,
                        table_name,
                        last_altered,
                        DATE_TRUNC('MONTH', last_altered) = DATE_TRUNC('MONTH', CURRENT_TIMESTAMP()) as is_current_month
                    FROM system.information_schema.tables
                    WHERE table_catalog = '{catalog}'
                      AND table_schema = '{schema}'
                      AND table_name = '{table}'
                """

                result = etl.session.sql(query).collect()

                if not result:
                    Logger.warning(
                        message=f"No results returned for {table_string}. Proceeding with function execution."
                    )
                    return func(*args, **kwargs)

                last_altered = result[0]["last_altered"]
                is_current_month = result[0]["is_current_month"]

                # Convert timestamp to Eastern timezone for logging
                if isinstance(last_altered, datetime):
                    utc_time = last_altered
                else:
                    utc_time = cast(datetime, last_altered)

                eastern_tz = ZoneInfo("America/New_York")
                last_altered_eastern = utc_time.astimezone(eastern_tz)

                if is_current_month:
                    Logger.info(
                        message=f"Table {table_string} last altered: {last_altered_eastern.isoformat()}. "
                                f"IS_CURRENT_MONTH = {is_current_month}. Skipping {func.__name__}."
                    )
                    return None

                Logger.info(
                    message=f"Table {table_string} last altered: {last_altered_eastern.isoformat()}. Proceeding with {func.__name__}."
                )
                return func(*args, **kwargs)

            except Exception as e:
                Logger.error(
                    message=f"Error checking table freshness for {table_string}: {str(e)}. "
                            f"Proceeding with {func.__name__}."
                )
                return func(*args, **kwargs)

        return cast(F, wrapper)
    return decorator

def parse_table_string(table_string: str) -> tuple[str, str, str]:
    """
    Parse a fully qualified table string into catalog, schema, and table components.

    Args:
        table_string (str): Fully qualified table path in format 'catalog.schema.table'

    Returns:
        tuple[str, str, str]: A tuple of (catalog, schema, table)

    Raises:
        ValueError: If table_string is not in the correct 'catalog.schema.table' format

    Examples:
        >>> from pipelines.utils.decorators import parse_table_string
        >>>
        >>> catalog, schema, table = parse_table_string('my_catalog.staging.users')
        >>> print(catalog, schema, table)
        my_catalog staging users
        >>>
        >>> # Invalid format raises error
        >>> parse_table_string('my_catalog.users')
        ValueError: Invalid table_string format: 'my_catalog.users'. Expected format: 'catalog.schema.table'

    Note:
        This function is used internally by decorators to validate and parse table paths.
    """
    parts = table_string.split(".")
    if len(parts) != 3:
        raise ValueError(
            f"Invalid table_string format: '{table_string}'. "
            "Expected format: 'catalog.schema.table'"
        )

    return tuple(parts)
