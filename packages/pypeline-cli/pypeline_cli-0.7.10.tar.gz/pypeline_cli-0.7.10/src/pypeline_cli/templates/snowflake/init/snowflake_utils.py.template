"""
Auto-generated Snowflake utility helpers.

⚠️ DO NOT MODIFY THIS FILE DIRECTLY ⚠️

This file is generated by pypeline-cli and provides convenience helpers
for interacting with Snowflake via Snowpark sessions. Manual edits may be
overwritten by the CLI when templates are regenerated.

The functions below include example usage in their docstrings.

Example:
    from snowflake.snowpark import Session
    from pipelines.utils.snowflake_utils import get_table_last_modified

    >>> result = get_table_last_modified(
    ...     session,
    ...     database_name="MY_DB",
    ...     schema_name="PUBLIC",
    ...     table_name="MY_TABLE",
    ... )
    >>> print(result["iso"])  # ISO timestamp in America/New_York
"""

from datetime import datetime
from typing import cast
from zoneinfo import ZoneInfo

from snowflake.snowpark import Session

from .logger import Logger
from .types import (
    TableConfig,
    TimestampResult,
    ParsedTablePath
)

def get_table_last_modified(
    session: Session,
    config: TableConfig | None = None,
    year: int | None = None,
    database_name: str | None = None,
    schema_name: str | None = None,
    table_name: str | None = None,
) -> TimestampResult:
    """
    Return the last-altered timestamp for a table as Eastern time.

    Args:
        session: Active Snowpark `Session`.
        config: Optional `TableConfig` (preferred, supports templating).
        year: Optional year used by `TableConfig` when resolving path.
        database_name: Direct database name (alternative to `config`).
        schema_name: Direct schema name (alternative to `config`).
        table_name: Direct table name (alternative to `config`).

    Returns:
        A `TimestampResult` dict with keys:
            - `dt`: timezone-aware `datetime` in America/New_York
            - `iso`: ISO 8601 string representation

    Example:
        # Direct path
        res = get_table_last_modified(
            session,
            database_name="MY_DB",
            schema_name="PUBLIC",
            table_name="MY_TABLE",
        )
        print(res["iso"])  # '2025-01-01T12:34:56-05:00'

        >>> res = get_table_last_modified(session, config=my_table_config, year=2025)
    """
    # Parse table path using helper
    path = parse_table_path(config, year, database_name, schema_name, table_name)

    query = f"""
        SELECT LAST_ALTERED
        FROM {path.database}.INFORMATION_SCHEMA.TABLES
        WHERE TABLE_CATALOG = '{path.database}'
        AND TABLE_SCHEMA = '{path.schema}'
        AND TABLE_NAME = '{path.table}'
    """

    result = session.sql(query).collect()
    last_updated = cast(datetime, result[0]["LAST_ALTERED"])

    eastern_tz = ZoneInfo("America/New_York")
    dt_eastern = last_updated.astimezone(eastern_tz)

    iso_string = dt_eastern.isoformat()

    return {
        "dt": dt_eastern,
        "iso": iso_string
    }

def parse_table_path(
    config: TableConfig | None = None,
    year: int | None = None,
    database_name: str | None = None,
    schema_name: str | None = None,
    table_name: str | None = None,
) -> ParsedTablePath:
    """
    Resolve a table path from either a `TableConfig` or explicit components.

    Args:
        config: Optional `TableConfig` which can generate a parsed path.
        year: Optional year to pass to `TableConfig.generate_parsed_table_path()`.
        database_name: Direct database name.
        schema_name: Direct schema name.
        table_name: Direct table name.

    Returns:
        `ParsedTablePath` with `database`, `schema`, and `table` attributes.

    Raises:
        `ValueError` when neither a full explicit path nor a `config` is provided.

    Example:
        # From explicit parts
        path = parse_table_path(database_name="MY_DB", schema_name="PUBLIC", table_name="TBL")

        # From config
        path = parse_table_path(config=my_table_config, year=2025)
    Example:
        >>> # From explicit parts
        >>> path = parse_table_path(database_name="MY_DB", schema_name="PUBLIC", table_name="TBL")

        >>> # From config
        >>> path = parse_table_path(config=my_table_config, year=2025)
    """
    if database_name and schema_name and table_name:
        return ParsedTablePath(
            database=database_name,
            schema=schema_name,
            table=table_name
        )
    
    elif config and year:
        data = config.generate_parsed_table_path(year)
        return ParsedTablePath(
            database=data["database"],
            schema=data["schema"],
            table=data["table"]
        )
    
    elif config:
        data = config.generate_parsed_table_path()
        return ParsedTablePath(
            database=data["database"],
            schema=data["schema"],
            table=data["table"]
        )
    
    else:
        raise ValueError(
            "You must provide either (database, schema, table) or config (with optional year)"
        )


def check_table_exists(
    session: Session,
    config: TableConfig | None = None,
    year: int | None = None,
    database_name: str | None = None,
    schema_name: str | None = None,
    table_name: str | None = None,
) -> bool:
    """
    Return True if the table exists and False on any error or lack of permission.

    This helper intentionally treats permission errors and other failures as
    a non-existent result (False) to provide a simple boolean check. For
    more detailed diagnostics, inspect exceptions or implement a separate
    check routine.

    Args:
        session: Active Snowpark `Session`.
        config: Optional `TableConfig`.
        year: Optional year for config resolution.
        database_name: Direct database name.
        schema_name: Direct schema name.
        table_name: Direct table name.

    Returns:
        `True` if table exists and `False` otherwise (including on errors).

    Example:
        exists = check_table_exists(
            session,
            database_name="MY_DB",
            schema_name="PUBLIC",
            table_name="MY_TABLE",
        )
        if exists:
    Example:
        >>> exists = check_table_exists(
        ...     session,
        ...     database_name="MY_DB",
        ...     schema_name="PUBLIC",
        ...     table_name="MY_TABLE",
        ... )
        >>> if exists:
        ...     print("Table exists")
    """
    # Parse table path using helper
    path = parse_table_path(config, year, database_name, schema_name, table_name)
    
    try:
        return session.catalog.table_exists(path.table, path.database, path.schema)
    except Exception as e:
        error_msg = str(e).lower()
        Logger.error(f"Error checking table existence for {path.full_name}: {error_msg}")
        return False


def check_table_read_access(
    session: Session,
    config: TableConfig | None = None,
    year: int | None = None,
    database_name: str | None = None,
    schema_name: str | None = None,
    table_name: str | None = None
) -> bool:
    """
    Attempt a minimal read from the table to verify read permissions.

    Returns False if the table does not exist, is inaccessible, or any other
    error occurs while attempting to read a single row.

    Args:
        session: Active Snowpark `Session`.
        config: Optional `TableConfig`.
        year: Optional year for config resolution.
        database_name: Direct database name.
        schema_name: Direct schema name.
        table_name: Direct table name.

    Returns:
        `True` when a simple `SELECT 1 FROM <table> LIMIT 1` succeeds,
        otherwise `False`.

    Example:
        can_read = check_table_read_access(
            session,
            database_name="MY_DB",
            schema_name="PUBLIC",
            table_name="MY_TABLE",
        )
        if can_read:
    Example:
        >>> can_read = check_table_read_access(
        ...     session,
        ...     database_name="MY_DB",
        ...     schema_name="PUBLIC",
        ...     table_name="MY_TABLE",
        ... )
        >>> if can_read:
        ...     print("Read access OK")
        ... else:
        ...     print("No read access or table missing")
    """
    # Check existence first
    if not check_table_exists(session, config, year, database_name, schema_name, table_name):
        return False
    
    # Parse table path for read check
    path = parse_table_path(config, year, database_name, schema_name, table_name)
    
    try:
        # Try to read one row
        session.sql(f"SELECT 1 FROM {path.full_name} LIMIT 1").collect()
        Logger.debug(f"Successfully read from {path.full_name}")
        return True
    except Exception as e:
        Logger.warning(f"Cannot read from {path.full_name}: {str(e)}")
        return False
