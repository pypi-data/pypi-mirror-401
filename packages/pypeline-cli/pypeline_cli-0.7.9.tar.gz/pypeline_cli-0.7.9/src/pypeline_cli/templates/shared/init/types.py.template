import calendar
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional, Literal, Union, Dict, cast, Tuple, TypedDict

# === Enums ===

class LogLevel(Enum):
    """
    Log level enumeration with ANSI color coding.

    Defines standard log levels with numeric values for filtering and ANSI
    color codes for terminal output formatting.

    Attributes:
        numeric_level (int): Numeric severity value (10-50)
        label (str): Human-readable label for the log level
        color_code (str): ANSI escape code for color formatting
        reset_code (str): ANSI reset code to clear formatting

    Members:
        DEBUG (10): Gray - Detailed diagnostic information
        INFO (20): Green - General informational messages
        WARN (30): Yellow - Warning messages
        ERROR (40): Red - Error messages
        CRITICAL (50): Magenta - Critical failures

    Examples:
        >>> LogLevel.INFO.numeric_level
        20
        >>> LogLevel.ERROR.label
        'ERROR'
        >>> LogLevel.DEBUG.color_code
        '\\033[37m'

    Note:
        This enum is auto-generated by pypeline-cli. Do not modify directly.
    """

    DEBUG = (10, "DEBUG", "\033[37m")
    INFO = (20, "INFO", "\033[32m")
    WARN = (30, "WARN", "\033[33m")
    ERROR = (40, "ERROR", "\033[31m")
    CRITICAL = (50, "CRITICAL", "\033[35m")

    def __init__(self, numeric_level, label, color_code):
        """
        Initialize a LogLevel enum member.

        Args:
            numeric_level (int): Numeric value of the log level.
            label (str): String label for the log level.
            color_code (str): ANSI color code for terminal output.
        """
        self.numeric_level = numeric_level
        self.label = label
        self.color_code = color_code
        self.reset_code = "\033[0m"

# === Types ===

class TimestampResult(TypedDict):
    dt: datetime
    iso: str

class ParsedDateTime(TypedDict):
    """
    TypedDict representing a validated datetime with UTC normalization.

    Attributes:
        iso_string_utc (str): ISO formatted string in UTC.
        iso_string_eastern (str): ISO formatted string in Eastern timezone (for display).
        datetime_utc (datetime): The datetime object normalized to UTC.
        datetime_original (datetime): The original datetime object with its timezone preserved.
        year_utc (int): The year component in UTC.
        month_utc (str): The month component in UTC, zero-padded.
        day_utc (str): The day component in UTC, zero-padded.
    """
    iso_string_utc: str
    iso_string_eastern: str
    datetime_utc: datetime
    datetime_original: datetime
    year_utc: int
    month_utc: str
    day_utc: str

# === Dataclasses ===

# Tables

@dataclass
class TableConfig:
    """
    Configuration for dynamically named database tables.
    
    This class manages table name generation based on temporal patterns,
    supporting yearly, monthly, and stable table naming conventions.
    
    Attributes:
        database: Database name (use constants from Database class)
        schema: Schema name (use constants from Schema class)
        table_name_template: Template string with placeholders for dynamic parts
        type: Table partitioning type - "YEARLY", "MONTHLY", or "STABLE"
        month: Required for MONTHLY tables (1-12 or "01"-"12")
    
    Examples:
        >>> # Yearly table
        >>> config = TableConfig(
        ...     database="ANALYTICS",
        ...     schema="RAW",
        ...     table_name_template="sales_{YYYY}",
        ...     type="YEARLY"
        ... )
        >>> config.generate_table_name(year=2025)
        'ANALYTICS.RAW.sales_2025'
        
        >>> # Monthly table
        >>> config = TableConfig(
        ...     database="PRODUCTION",
        ...     schema="STAGING",
        ...     table_name_template="events_{MM}",
        ...     type="MONTHLY",
        ...     month=3
        ... )
        >>> config.generate_table_name()
        'PRODUCTION.STAGING.events_03'
        
        >>> # Stable table
        >>> config = TableConfig(
        ...     database="ANALYTICS",
        ...     schema="REPORTING",
        ...     table_name_template="dim_products",
        ...     type="STABLE"
        ... )
        >>> config.generate_table_name()
        'ANALYTICS.REPORTING.dim_products'
    """
    database: str
    schema: str
    table_name_template: str
    type: Literal["YEARLY", "MONTHLY", "STABLE"]
    month: Optional[Union[int, str]] = None
    is_output: bool

    def generate_table_name(self, year: Optional[int] = None) -> str:
        """
        Generate fully qualified table name from configuration.
        
        Args:
            year: Required for YEARLY tables. 4-digit year (e.g., 2025)
        
        Returns:
            Fully qualified table name in format: database.schema.table_name
        
        Raises:
            ValueError: If required parameters are missing for table type
        
        Template Placeholders:
            - {YYYY}: 4-digit year (e.g., 2025)
            - {YY}: 2-digit year (e.g., 25)
            - {MM}: 2-digit month with leading zero (e.g., 01, 12)
        
        Examples:
            >>> # YEARLY table
            >>> config.generate_table_name(year=2025)
            'DATABASE.SCHEMA.table_2025'
            
            >>> # MONTHLY table (month set in __init__)
            >>> config.generate_table_name()
            'DATABASE.SCHEMA.table_03'
            
            >>> # STABLE table
            >>> config.generate_table_name()
            'DATABASE.SCHEMA.table_name'
        """
        if self.type == "YEARLY":
            if year is None:
                raise ValueError("Year required for YEARLY table type")
            return f"{self.database}.{self.schema}.{self.table_name_template.format(YYYY=year, YY=str(year)[-2:])}"
        elif self.type == "MONTHLY":
            if self.month is None:
                raise ValueError("Month required for MONTHLY table type")
            return f"{self.database}.{self.schema}.{self.table_name_template.format(MM=f'{self.month:02d}')}"
        else:  # "STABLE"
            return f"{self.database}.{self.schema}.{self.table_name_template}"
        
    def generate_parsed_table_path(self, year: int | None) -> Dict[str, Dict[str, str]]:
        parsed_table_path = {}
        if self.type == "YEARLY":
            if year is None:
                raise ValueError("Year required for YEARLY table type")
            parsed_table_path["data"] = {
                "database": self.database,
                "schema": self.schema,
                "table": self.table_name_template.format(YYYY=year, YY=str(year)[-2:])
            }
            return parsed_table_path
        elif self.type == "MONTHLY":
            if self.month is None:
                raise ValueError("Month required for MONTHLY table type")
            parsed_table_path["data"] = {
                "database": self.database,
                "schema": self.schema,
                "table": self.table_name_template.format(MM=f'{self.month:02d}')
            }
            return parsed_table_path
        else:  # "STABLE"
            parsed_table_path["data"] = {
                "database": self.database,
                "schema": self.schema,
                "table": self.table_name_template
            }
            return parsed_table_path

# Monthly columns

@dataclass
class MonthlyColumnConfig:
    """
    Configuration for generating monthly column names and labels.

    This dataclass manages naming patterns for month-based columns in wide tables,
    providing consistent formatting and labeling across your pipeline.

    Attributes:
        prefix (str): Column name prefix (e.g., "SALES_", "REV_")
        length (int): Number of months (typically 12)
        format_type (str): Format type identifier for metadata
        label_template (str): Template for human-readable labels with {month} placeholder
        _output_prefix (Optional[str]): Optional different prefix for output columns

    Examples:
        >>> # Basic monthly column
        >>> config = MonthlyColumnConfig(
        ...     prefix="REVENUE_",
        ...     length=12,
        ...     format_type="currency",
        ...     label_template="{month} Revenue"
        ... )
        >>> config.generate_column_name(3)
        'REVENUE_03'
        >>> config.generate_column_label_from_template(3)
        'March Revenue'

        >>> # With different output prefix
        >>> config = MonthlyColumnConfig(
        ...     prefix="SALES_",
        ...     length=12,
        ...     format_type="numeric",
        ...     label_template="{month} Sales",
        ...     _output_prefix="TOTAL_SALES_"
        ... )
        >>> config.generate_column_name(1)
        'SALES_01'
        >>> config.generate_output_column_name(1)
        'TOTAL_SALES_01'

    Note:
        This class is auto-generated by pypeline-cli. Do not modify directly.
    """
    prefix: str
    length: int
    format_type: str
    label_template: str
    _output_prefix: Optional[str] = None

    def __post_init__(self):
        """
        Initialize output_prefix to match prefix if not specified.

        Called automatically after dataclass initialization to set default
        output_prefix when not explicitly provided.
        """
        if self._output_prefix is None:
            self._output_prefix = self.prefix

    @property
    def output_prefix(self) -> str:
        """
        Get the output column prefix with type enforcement.

        Returns:
            str: The output prefix for transformed columns

        Example:
            >>> config = MonthlyColumnConfig(
            ...     prefix="INPUT_", length=12, format_type="text",
            ...     label_template="{month}", _output_prefix="OUTPUT_"
            ... )
            >>> config.output_prefix
            'OUTPUT_'
        """
        assert self._output_prefix is not None
        return self._output_prefix

    def generate_column_name(self, month: int) -> str:
        """
        Generate input column name for a specific month.

        Args:
            month (int): Month number (1-12)

        Returns:
            str: Formatted column name with zero-padded month

        Example:
            >>> config = MonthlyColumnConfig(
            ...     prefix="SALES_", length=12, format_type="numeric",
            ...     label_template="{month}"
            ... )
            >>> config.generate_column_name(3)
            'SALES_03'
            >>> config.generate_column_name(11)
            'SALES_11'
        """
        return f"{self.prefix}{month:02d}"

    def generate_output_column_name(self, month: int) -> str:
        """
        Generate output column name for a specific month.

        Uses output_prefix instead of prefix, useful when transforming
        columns to a different naming convention.

        Args:
            month (int): Month number (1-12)

        Returns:
            str: Formatted output column name with zero-padded month

        Example:
            >>> config = MonthlyColumnConfig(
            ...     prefix="RAW_SALES_", length=12, format_type="numeric",
            ...     label_template="{month}", _output_prefix="PROCESSED_SALES_"
            ... )
            >>> config.generate_output_column_name(6)
            'PROCESSED_SALES_06'
        """
        return f"{self.output_prefix}{month:02d}"

    def generate_column_label_from_template(self, month: int) -> str:
        """
        Generate human-readable label for a specific month.

        Substitutes the full month name into the label_template string.

        Args:
            month (int): Month number (1-12)

        Returns:
            str: Formatted label with month name

        Example:
            >>> config = MonthlyColumnConfig(
            ...     prefix="SALES_", length=12, format_type="numeric",
            ...     label_template="{month} Sales Total"
            ... )
            >>> config.generate_column_label_from_template(1)
            'January Sales Total'
            >>> config.generate_column_label_from_template(12)
            'December Sales Total'
        """
        month_name = calendar.month_name[month]
        return self.label_template.format(month=month_name)
    
# Snowflake

@dataclass
class ParsedTablePath:
    """Parsed table location"""
    database: str
    schema: str
    table: str
    
    @property
    def full_name(self) -> str:
        """Return fully qualified table name"""
        return f"{self.database}.{self.schema}.{self.table}"
    
    def __str__(self) -> str:
        return self.full_name
    
