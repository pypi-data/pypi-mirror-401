// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <rev/config/SparkBaseConfig.h>

#include <trampolines/rev__BaseConfig.hpp>

namespace rev::spark {

template <typename CfgBase = swgen::EmptyTrampolineCfg>
struct PyTrampolineCfg_SparkBaseConfig :
  rev::PyTrampolineCfg_BaseConfig<
  CfgBase
  >
{
  using Base = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTSparkBaseConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTAbsoluteEncoderConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTAnalogSensorConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTEncoderConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTLimitSwitchConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTSoftLimitConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTClosedLoopConfig = rev::spark::SparkBaseConfig;
  using override_base_Apply_RTSignalsConfig = rev::spark::SparkBaseConfig;
  using override_base_Flatten_v = rev::spark::SparkBaseConfig;
};

template <typename PyTrampolineBase, typename PyTrampolineCfg>
using PyTrampolineBase_SparkBaseConfig =
  rev::PyTrampoline_BaseConfig<
    PyTrampolineBase
    , PyTrampolineCfg>
;

template <typename PyTrampolineBase, typename PyTrampolineCfg>
struct PyTrampoline_SparkBaseConfig : PyTrampolineBase_SparkBaseConfig<PyTrampolineBase, PyTrampolineCfg> {
  using PyTrampolineBase_SparkBaseConfig<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_SparkBaseConfig;
  using Presets [[maybe_unused]] = typename rev::spark::SparkBaseConfig::Presets;
  using IdleMode [[maybe_unused]] = typename rev::spark::SparkBaseConfig::IdleMode;

  #ifndef SWGEN_DISABLE_Apply_RTSparkBaseConfig
    SparkBaseConfig& Apply(SparkBaseConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTSparkBaseConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTAbsoluteEncoderConfig
    SparkBaseConfig& Apply(AbsoluteEncoderConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTAbsoluteEncoderConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTAnalogSensorConfig
    SparkBaseConfig& Apply(AnalogSensorConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTAnalogSensorConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTEncoderConfig
    SparkBaseConfig& Apply(EncoderConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTEncoderConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTLimitSwitchConfig
    SparkBaseConfig& Apply(LimitSwitchConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTLimitSwitchConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTSoftLimitConfig
    SparkBaseConfig& Apply(SoftLimitConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTSoftLimitConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTClosedLoopConfig
    SparkBaseConfig& Apply(ClosedLoopConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTClosedLoopConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Apply_RTSignalsConfig
    SparkBaseConfig& Apply(SignalsConfig& config) override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Apply_RTSignalsConfig;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(SparkBaseConfig&), LookupBase,
        "apply", config);
      return CxxCallBase::Apply(std::forward<decltype(config)>(config));
    }
  #endif

  #ifndef SWGEN_DISABLE_Flatten_v
    std::string Flatten() override {
      using LookupBase = typename PyTrampolineCfg::Base;
      using CxxCallBase = typename PyTrampolineCfg::override_base_Flatten_v;
      PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(std::string), LookupBase,
        "flatten", );
      return CxxCallBase::Flatten();
    }
  #endif
};

}; // namespace rev::spark
