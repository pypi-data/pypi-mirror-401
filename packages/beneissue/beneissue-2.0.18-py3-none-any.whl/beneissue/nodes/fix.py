"""Fix node implementation using Claude Code."""

import os
import secrets
import tempfile

from langsmith import traceable

from beneissue.graph.state import IssueState
from beneissue.integrations.claude_code import UsageInfo, run_claude_code
from beneissue.integrations.git import (
    configure_git_user,
    git_add_all,
    git_checkout_branch,
    git_commit,
    git_push,
    git_status,
)
from beneissue.mocks import load_mock
from beneissue.integrations.github import (
    clone_repo,
    create_pull_request,
    get_analysis_comment,
)
from beneissue.nodes.schemas import FixResult
from beneissue.nodes.utils import parse_result
from beneissue.observability import get_node_logger
from beneissue.prompts import load_prompt

logger = get_node_logger("fix")

# Timeout for Claude Code execution (5 minutes)
CLAUDE_CODE_TIMEOUT = 300


def _parse_fix_output(output: str) -> FixResult | None:
    """Parse Claude Code output for FixResult JSON."""
    return parse_result(output, FixResult, required_key="success")


def _build_fix_prompt(state: IssueState) -> str:
    """Build the fix prompt for Claude Code.

    Fetches analysis from GitHub comment if not available in state.
    This allows fix to run independently after analyze.
    """
    # Try to get analysis from GitHub comment first, fall back to state
    analysis_summary = state.get("analysis_summary")
    affected_files = state.get("affected_files", [])

    if not analysis_summary:
        logger.info("Fetching analysis from GitHub comment...")
        comment_data = get_analysis_comment(state["repo"], state["issue_number"])
        if comment_data:
            analysis_summary = comment_data.get("summary", "No analysis available")
            affected_files = comment_data.get("affected_files", [])
            logger.info("Found analysis in GitHub comment")
        else:
            analysis_summary = "No analysis available"
            logger.warning("No analysis comment found on issue")

    affected_files_str = (
        "\n".join(f"- {f}" for f in affected_files)
        if affected_files
        else "No specific files identified"
    )

    return load_prompt("fix").format(
        issue_number=state["issue_number"],
        issue_title=state["issue_title"],
        analysis_summary=analysis_summary,
        affected_files=affected_files_str,
    )


def _create_pr(
    state: IssueState, fix_result: FixResult | None, branch_name: str
) -> tuple[bool, str | None, str | None]:
    """Create a PR using PyGithub.

    Returns:
        Tuple of (success, pr_url, error)
    """
    issue_number = state["issue_number"]
    repo = state["repo"]

    pr_title = (
        fix_result.title
        if fix_result and fix_result.title
        else f"Fix #{issue_number}: {state['issue_title']}"
    )
    pr_description = (
        fix_result.description
        if fix_result and fix_result.description
        else state.get("analysis_summary", "No analysis available")
    )
    ai_disclaimer = "ðŸ¤– *This was generated by AI and may be inaccurate or inappropriate. Please review carefully!*"
    pr_body = f"{pr_description}\n\n{ai_disclaimer}\n\n---\nCloses #{issue_number}"

    result = create_pull_request(
        repo=repo,
        branch_name=branch_name,
        title=pr_title,
        body=pr_body,
    )

    return result.success, result.url, result.error


def _error_result(error: str, label: str = "fix/manual-required") -> dict:
    """Build an error result dict."""
    return {
        "fix_success": False,
        "fix_error": error,
        "labels_to_add": [label],
    }


def _run_claude_code_fix(
    repo_path: str, prompt: str
) -> tuple[FixResult | None, dict | None, UsageInfo]:
    """Run Claude Code and return parsed result or error dict.

    Returns:
        Tuple of (fix_result, error_dict, usage). fix_result or error_dict will be None.
    """
    result = run_claude_code(
        prompt=prompt,
        cwd=repo_path,
        allowed_tools=["Read", "Glob", "Grep", "Edit", "Write", "Bash"],
        timeout=CLAUDE_CODE_TIMEOUT,
    )

    usage = result.usage
    usage.log_summary(logger)

    if result.stdout:
        logger.info("Claude Code Output:\n%s", result.stdout)

    if result.error:
        logger.error("Claude Code error: %s", result.error)
        return None, _error_result(result.error), usage

    if not result.success:
        logger.error("Claude Code failed with return code %s", result.returncode)
        if result.stderr:
            logger.error("stderr: %s", result.stderr[:500])
        return None, _error_result(result.stderr[:500] if result.stderr else "Unknown error"), usage

    fix_result = _parse_fix_output(result.stdout)
    if fix_result:
        logger.info("Fix result: success=%s, title=%s", fix_result.success, fix_result.title)
    else:
        logger.warning("Could not parse structured fix result from output")

    if fix_result and not fix_result.success:
        logger.error("Fix reported failure: %s", fix_result.error)
        return None, _error_result(fix_result.error or "Fix reported failure"), usage

    return fix_result, None, usage


def _commit_and_push(
    repo_path: str, issue_number: int, fix_result: FixResult | None
) -> tuple[str, dict | None]:
    """Create branch, commit, and push. Returns (branch_name, error_dict)."""
    random_suffix = secrets.token_hex(3)
    branch_name = f"fix/issue-{issue_number}-{random_suffix}"
    git_checkout_branch(repo_path, branch_name)
    logger.info("Created branch: %s", branch_name)

    commit_title = (
        fix_result.title
        if fix_result and fix_result.title
        else f"fix: resolve issue #{issue_number}"
    )
    commit_body = (
        f"{fix_result.description}\n\n" if fix_result and fix_result.description else ""
    )
    commit_msg = f"{commit_title}\n\n{commit_body}Closes #{issue_number}\nCo-Authored-By: Claude <noreply@anthropic.com>"

    configure_git_user(repo_path)
    git_add_all(repo_path)
    git_commit(repo_path, commit_msg)
    logger.info("Committed with message: %s", commit_title)

    logger.info("Pushing branch %s...", branch_name)
    push_result = git_push(repo_path, branch_name)
    if not push_result.success:
        push_error = push_result.stderr[:200]
        logger.error("Failed to push: %s", push_error)
        return branch_name, _error_result(f"Failed to push: {push_error}")

    return branch_name, None


def _create_dry_run_pr(state: IssueState) -> tuple[bool, str | None, str | None]:
    """Create a dry-run PR with an empty commit.

    Returns:
        Tuple of (success, pr_url, error)
    """
    issue_number = state["issue_number"]
    repo = state["repo"]

    with tempfile.TemporaryDirectory() as temp_dir:
        repo_path = os.path.join(temp_dir, "repo")

        logger.info("[DRY-RUN] Cloning repository %s...", repo)
        if not clone_repo(repo, repo_path):
            return False, None, "Failed to clone repository"

        # Create branch
        random_suffix = secrets.token_hex(3)
        branch_name = f"dry-run/issue-{issue_number}-{random_suffix}"
        git_checkout_branch(repo_path, branch_name)
        logger.info("[DRY-RUN] Created branch: %s", branch_name)

        # Empty commit
        configure_git_user(repo_path)
        commit_msg = (
            f"[DRY-RUN] Test PR for issue #{issue_number}\n\n"
            "This is a dry-run test PR with no actual changes.\n"
            "Please close this PR after testing.\n\n"
            "Co-Authored-By: Claude <noreply@anthropic.com>"
        )
        commit_result = git_commit(repo_path, commit_msg, allow_empty=True)
        if not commit_result.success:
            return False, None, f"Failed to create empty commit: {commit_result.stderr}"

        # Push
        logger.info("[DRY-RUN] Pushing branch %s...", branch_name)
        push_result = git_push(repo_path, branch_name)
        if not push_result.success:
            return False, None, f"Failed to push: {push_result.stderr[:200]}"

        # Create PR
        pr_title = f"[DRY-RUN] Test PR for #{issue_number}: {state.get('issue_title', 'Unknown')}"
        pr_body = (
            "## âš ï¸ This is a DRY-RUN test PR\n\n"
            "This PR was created to test the GitHub integration without actual code changes.\n\n"
            "**Please close this PR after testing.**\n\n"
            "---\n"
            f"Related issue: #{issue_number}"
        )

        result = create_pull_request(
            repo=repo,
            branch_name=branch_name,
            title=pr_title,
            body=pr_body,
        )

        return result.success, result.url, result.error


@traceable(
    name="claude_code_fix",
    run_type="llm",
    metadata={"ls_provider": "anthropic", "ls_model_name": "claude-sonnet-4-5"},
)
def fix_node(state: IssueState) -> dict:
    """Execute fix using Claude Code CLI."""
    # Dry-run mode: create empty PR for testing
    if state.get("dry_run"):
        logger.info("[DRY-RUN] Creating test PR with empty commit...")

        success, pr_url, error = _create_dry_run_pr(state)

        if success and pr_url:
            logger.info("[DRY-RUN] Test PR created: %s", pr_url)
            return {
                "fix_success": True,
                "pr_url": pr_url,
                "fix_error": None,
                "labels_to_add": ["fix/completed"],
                **UsageInfo().to_state_dict(),
            }

        logger.error("[DRY-RUN] Failed to create test PR: %s", error)
        return {
            "fix_success": False,
            "pr_url": None,
            "fix_error": error,
            "labels_to_add": ["fix/manual-required"],
            **UsageInfo().to_state_dict(),
        }

    prompt = _build_fix_prompt(state)
    issue_number = state["issue_number"]

    logger.info("Starting fix for issue #%s", issue_number)

    with tempfile.TemporaryDirectory() as temp_dir:
        repo_path = os.path.join(temp_dir, "repo")

        logger.info("Cloning repository %s...", state["repo"])
        if not clone_repo(state["repo"], repo_path):
            logger.error("Failed to clone repository")
            return _error_result("Failed to clone repository", "fix/failed")

        logger.info("Running Claude Code to analyze and fix...")
        fix_result, error, usage = _run_claude_code_fix(repo_path, prompt)

        if error:
            return usage.with_state(error)

        changes = git_status(repo_path)
        if not changes:
            logger.warning("No changes were made by Claude Code")
            return usage.with_state(_error_result("No changes were made"))

        logger.debug("Changes detected:\n%s", changes)

        branch_name, error = _commit_and_push(repo_path, issue_number, fix_result)
        if error:
            return usage.with_state(error)

        logger.info("Creating pull request...")
        pr_success, pr_url, pr_error = _create_pr(state, fix_result, branch_name)

        if pr_success and pr_url:
            logger.info("PR created: %s", pr_url)
            return usage.with_state({
                "fix_success": True,
                "pr_url": pr_url,
                "labels_to_remove": ["fix/auto-eligible"],
                "labels_to_add": ["fix/completed"],
            })

        logger.error("Failed to create PR: %s", pr_error)
        return usage.with_state(_error_result(pr_error or "Failed to create PR"))
