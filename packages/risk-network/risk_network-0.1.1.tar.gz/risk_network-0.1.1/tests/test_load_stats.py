"""
tests/test_load_stats
~~~~~~~~~~~~~~~~~~~~~
"""

import networkx as nx
import numpy as np
import pytest


@pytest.mark.parametrize("null_distribution", ["network", "annotation"])
def test_run_binom(risk_obj, json_annotation, clusters_matrix, null_distribution):
    """
    Test running the binomial test with multiple null distributions.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
        null_distribution: Null distribution type for the binomial test (either 'network' or 'annotation').
    """
    stats_results = risk_obj.run_binom(
        annotation=json_annotation,
        clusters=clusters_matrix,
        null_distribution=null_distribution,
    )

    assert stats_results is not None
    assert "depletion_pvals" in stats_results
    assert "enrichment_pvals" in stats_results
    assert stats_results["depletion_pvals"].shape[0] > 0
    assert stats_results["enrichment_pvals"].shape[0] > 0


@pytest.mark.parametrize("null_distribution", ["network", "annotation"])
def test_run_chi2(risk_obj, json_annotation, clusters_matrix, null_distribution):
    """
    Test running the chi-squared test with multiple null distributions.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
        null_distribution: Null distribution type for the chi-squared test (either 'network' or 'annotation').
    """
    stats_results = risk_obj.run_chi2(
        annotation=json_annotation,
        clusters=clusters_matrix,
        null_distribution=null_distribution,
    )

    assert stats_results is not None
    assert "depletion_pvals" in stats_results
    assert "enrichment_pvals" in stats_results
    assert stats_results["depletion_pvals"].shape[0] > 0
    assert stats_results["enrichment_pvals"].shape[0] > 0


@pytest.mark.parametrize("null_distribution", ["network", "annotation"])
def test_run_hypergeom(risk_obj, json_annotation, clusters_matrix, null_distribution):
    """
    Test running the hypergeometric test with multiple null distributions.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
        null_distribution: Null distribution type for the hypergeometric test (either 'network' or 'annotation').
    """
    stats_results = risk_obj.run_hypergeom(
        annotation=json_annotation,
        clusters=clusters_matrix,
        null_distribution=null_distribution,
    )

    assert stats_results is not None
    assert "depletion_pvals" in stats_results
    assert "enrichment_pvals" in stats_results
    assert stats_results["depletion_pvals"].shape[0] > 0
    assert stats_results["enrichment_pvals"].shape[0] > 0


@pytest.mark.parametrize("null_distribution", ["network", "annotation"])
def test_run_permutation_single_process(
    risk_obj, json_annotation, clusters_matrix, null_distribution
):
    """
    Test running the permutation test with a single process and multiple null distributions.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
        null_distribution: Null distribution type for the permutation test (either 'network' or 'annotation').
    """
    stats_results = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_matrix,
        score_metric="stdev",
        null_distribution=null_distribution,
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )

    assert stats_results is not None
    assert "depletion_pvals" in stats_results
    assert "enrichment_pvals" in stats_results
    assert stats_results["depletion_pvals"].shape[0] > 0
    assert stats_results["enrichment_pvals"].shape[0] > 0


def test_run_permutation_multi_process(risk_obj, json_annotation, clusters_matrix):
    """
    Test running the permutation test with multiple processes.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
    """
    stats_results = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_matrix,
        score_metric="stdev",
        null_distribution="network",
        num_permutations=20,
        random_seed=887,
        max_workers=4,
    )

    assert stats_results is not None
    assert "depletion_pvals" in stats_results
    assert "enrichment_pvals" in stats_results
    assert stats_results["depletion_pvals"].shape[0] > 0
    assert stats_results["enrichment_pvals"].shape[0] > 0


@pytest.mark.parametrize("score_metric", ["sum", "stdev"])
def test_run_permutation_with_various_score_metrics(
    risk_obj, json_annotation, clusters_matrix, score_metric
):
    """
    Test running the permutation test using various score metrics.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
        score_metric: The specific score metric to be used for generating clusters.
    """
    stats_results = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_matrix,
        score_metric=score_metric,
        null_distribution="network",
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )

    assert stats_results is not None
    assert "depletion_pvals" in stats_results
    assert "enrichment_pvals" in stats_results
    assert stats_results["depletion_pvals"].shape[0] > 0
    assert stats_results["enrichment_pvals"].shape[0] > 0


@pytest.mark.parametrize("null_distribution", ["network", "annotation"])
def test_run_with_various_null_distributions(
    risk_obj, json_annotation, clusters_matrix, null_distribution
):
    """
    Test running the permutation test using various null distributions.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
        null_distribution: The specific null distribution to be used for generating clusters.
    """
    stats_results = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_matrix,
        score_metric="stdev",
        null_distribution=null_distribution,
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )

    assert stats_results is not None
    assert "depletion_pvals" in stats_results
    assert "enrichment_pvals" in stats_results
    assert stats_results["depletion_pvals"].shape[0] > 0
    assert stats_results["enrichment_pvals"].shape[0] > 0


@pytest.mark.parametrize("null_distribution", ["network", "annotation"])
def test_run_permutation_structure(risk_obj, json_annotation, clusters_matrix, null_distribution):
    """
    Test the structure of the permutation test results.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
        null_distribution: The specific null distribution to be used for generating clusters.
    """
    stats_results = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_matrix,
        score_metric="stdev",
        null_distribution=null_distribution,
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )

    # Validate that the stats_results object has the expected keys
    assert "depletion_pvals" in stats_results, "Results should contain a 'depletion_pvals' key"
    assert "enrichment_pvals" in stats_results, "Results should contain an 'enrichment_pvals' key"
    assert isinstance(
        stats_results["depletion_pvals"], np.ndarray
    ), "'depletion_pvals' should be a numpy array"
    assert isinstance(
        stats_results["enrichment_pvals"], np.ndarray
    ), "'enrichment_pvals' should be a numpy array"


@pytest.mark.parametrize("null_distribution", ["network", "annotation"])
def test_run_permutation_output_dimensions(
    risk_obj, json_annotation, clusters_matrix, null_distribution
):
    """
    Test that the output dimensions of permutation test results match expectations.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
        null_distribution: The specific null distribution to be used for generating clusters.
    """
    stats_results = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_matrix,
        score_metric="stdev",
        null_distribution=null_distribution,
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )

    # Validate dimensions of p-value matrices
    num_nodes = clusters_matrix.shape[0]
    num_annotation = len(json_annotation["ordered_annotation"])
    assert stats_results["depletion_pvals"].shape == (
        num_nodes,
        num_annotation,
    ), "Depletion p-values matrix dimensions do not match the expected size"
    assert stats_results["enrichment_pvals"].shape == (
        num_nodes,
        num_annotation,
    ), "Enrichment p-values matrix dimensions do not match the expected size"


def test_run_permutation_deterministic_output(risk_obj, json_annotation, clusters_matrix):
    """
    Test that running the permutation test with the same random seed produces consistent results.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        clusters_matrix: The clusters matrix generated by the decoupled clustering API.
    """
    stats_results_1 = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_matrix,
        score_metric="stdev",
        null_distribution="network",
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )
    stats_results_2 = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_matrix,
        score_metric="stdev",
        null_distribution="network",
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )

    # Validate that the outputs are identical
    assert np.array_equal(
        stats_results_1["depletion_pvals"], stats_results_2["depletion_pvals"]
    ), "Depletion p-values should be identical for the same random seed"
    assert np.array_equal(
        stats_results_1["enrichment_pvals"], stats_results_2["enrichment_pvals"]
    ), "Enrichment p-values should be identical for the same random seed"


def test_run_permutation_with_different_clusters(risk_obj, json_annotation, cytoscape_network):
    """
    Test that running permutation tests with different cluster matrices (Louvain vs Greedy) produces different results.

    Args:
        risk_obj: The RISK object instance used for running the test.
        json_annotation: The annotation associated with the network.
        cytoscape_network: The network object loaded from Cytoscape.
    """
    # Louvain clustering
    clusters_louvain = risk_obj.cluster_louvain(
        network=cytoscape_network,
        fraction_shortest_edges=0.7,
        resolution=4,
        random_seed=887,
    )
    # Greedy clustering
    clusters_greedy = risk_obj.cluster_greedy(
        network=cytoscape_network,
        fraction_shortest_edges=0.5,
    )
    # Run permutation tests
    results_louvain = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_louvain,
        score_metric="stdev",
        null_distribution="network",
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )
    results_greedy = risk_obj.run_permutation(
        annotation=json_annotation,
        clusters=clusters_greedy,
        score_metric="stdev",
        null_distribution="network",
        num_permutations=20,
        random_seed=887,
        max_workers=1,
    )
    # Structural validity
    for results in [results_louvain, results_greedy]:
        assert "depletion_pvals" in results
        assert "enrichment_pvals" in results
        assert isinstance(results["depletion_pvals"], np.ndarray)
        assert isinstance(results["enrichment_pvals"], np.ndarray)
    # Results should not be identical
    assert not np.array_equal(
        results_louvain["depletion_pvals"], results_greedy["depletion_pvals"]
    ), "Depletion p-values should differ for different cluster structures"
    assert not np.array_equal(
        results_louvain["enrichment_pvals"], results_greedy["enrichment_pvals"]
    ), "Enrichment p-values should differ for different cluster structures"
