# beancode: a portable IGCSE Computer Science (0478, 0984, 2210) Pseudocode interpreter.
#
# Copyright (c) Eason Qin, 2025-2026.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#

import io
import os
import sys
import argparse
from typing import NoReturn

from beancode.optimizer import Optimizer

from beancode.repl import Repl

from beancode.interpreter import Interpreter
from beancode.lexer import *
from beancode.parser import Parser
from beancode.error import *
from beancode import __version__


def _error(s: str) -> NoReturn:
    error(s)
    exit(1)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-d", "--debug", action="store_true", help="show debugging information"
    )
    parser.add_argument(
        "-N", "--no-run", action="store_true", help="only print the program's AST"
    )
    parser.add_argument(
        "-O",
        "--optimize",
        action="store_true",
        help="optimize the program before running",
    )
    parser.add_argument(
        "-v", "--version", action="version", version=f"beancode version {__version__}"
    )
    parser.add_argument(
        "--tracer-config", help="path to the tracer's configuration options."
    )
    parser.add_argument(
        "--tracer-open",
        action="store_true",
        help="open files generated by the tracer automatically.",
    )
    parser.add_argument(
        "-i",
        "--stdin",
        action="store_true",
        help="read source from stdin",
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "-c",
        "--command",
        help="pass a program in as a string",
    )
    group.add_argument("file", nargs="?", type=str)
    return parser.parse_args()


def real_main(args: argparse.Namespace):
    if args.no_run:
        args.debug = True

    tracer_open = False
    if args.tracer_open:
        tracer_open = args.tracer_open

    if args.command is not None:
        file_content = args.command
    elif args.stdin:
        file_content = sys.stdin.read()
    elif args.file is None:
        Repl(args.debug, args.no_run).repl()
        return
    else:
        if not os.path.exists(args.file):
            _error(f"file {args.file} does not exist!")

        try:
            with open(args.file, "r+") as f:
                file_content = f.read()
        except IsADirectoryError:
            _error(f"{args.file} is not a file, but a directory!")
        except Exception as e:
            _error(f"failed to open file {args.file}: {e}")

    lexer = Lexer(file_content)

    try:
        toks = lexer.tokenize()
    except BCError as err:
        err.print(args.file, file_content)
        exit(1)

    if args.debug:
        print("=== TOKENS ===", file=sys.stderr)
        for tok in toks:
            tok.print(file=sys.stderr)
        print("==============", file=sys.stderr)
        sys.stderr.flush()

    parser = Parser(toks)

    try:
        program = parser.program()
    except BCError as err:
        err.print(args.file, file_content)
        exit(1)

    if args.optimize:
        try:
            opt = Optimizer(program.stmts)
            program.stmts = opt.visit_block(None)
        except BCError as err:
            err.print(args.file, file_content)
            exit(1)

    if args.debug:
        print("=== AST ===", file=sys.stderr)
        for stmt in program.stmts:
            print(stmt, file=sys.stderr)
            print(file=sys.stderr)
        print("===========", file=sys.stderr)
        sys.stderr.flush()

    if args.no_run:
        return

    try:
        i = Interpreter(program.stmts, tracer_open=tracer_open)
        i.toplevel = True
        i.visit_block(None)
    except BCError as err:
        err.print(args.file, file_content)
        exit(1)


def main():
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8", errors="replace")
    sys.stderr = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8", errors="replace")
    args = parse_args()
    if args.debug:
        set_bcerror_debug(True)

    try:
        real_main(args)
    except KeyboardInterrupt:
        warn("Caught keyboard interrupt")
        exit(1)
    except EOFError:
        warn("Caught EOF")
        exit(1)
    except RecursionError as e:
        warn("Python recursion depth exceeded! Did you forget your base case?")
        if args.debug:
            raise e
    except Exception as e:
        error(
            f'Python exception caught ({type(e)}: "{e}")! Please report this to the developers.'
        )
        raise e


if __name__ == "__main__":
    main()
