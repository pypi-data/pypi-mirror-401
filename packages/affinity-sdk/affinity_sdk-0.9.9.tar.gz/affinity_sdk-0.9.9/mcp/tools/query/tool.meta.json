{
  "name": "query",
  "description": "Execute a structured JSON query against Affinity data. Supports filtering, includes, aggregates, and multiple output formats.\n\nQuery structure:\n- from: Entity type ('persons', 'companies', 'opportunities', 'listEntries', 'interactions', 'notes')\n- where: Filter conditions with operators (eq, neq, gt, gte, lt, lte, contains, starts_with, ends_with, in, between, is_null, is_not_null, is_empty, has_any, has_all, contains_any, contains_all)\n- include: Related entities to fetch (e.g., ['companies', 'opportunities', 'listEntries'] for persons). \n- select: Fields to return (default: all). Use 'fields.*' for all custom fields on listEntries\n- orderBy: Sort results [{field, direction}]\n- groupBy: Group by field for aggregates (e.g., 'fields.Status' for listEntries)\n- aggregate: Compute aggregates {alias: {sum/avg/count/min/max: field}}\n- limit: Max records to return\n\nAdvanced filtering (quantifiers, exists, count):\n- all: All related items must match condition - {\"all\": {\"path\": \"companies\", \"where\": {\"path\": \"name\", \"op\": \"contains\", \"value\": \"Inc\"}}}\n- none: No related items may match condition - {\"none\": {\"path\": \"interactions\", \"where\": {\"path\": \"type\", \"op\": \"eq\", \"value\": \"spam\"}}}\n- exists: At least one related item exists - {\"exists\": {\"from\": \"interactions\"}} or with filter {\"exists\": {\"from\": \"interactions\", \"where\": {\"path\": \"type\", \"op\": \"eq\", \"value\": \"email\"}}}\n- _count: Count of related items - {\"path\": \"companies._count\", \"op\": \"gte\", \"value\": 2}\n- Note: Nested quantifiers (all/none/exists inside each other) are not supported\n\nMulti-select field filtering:\n- eq with scalar value: checks if value is in the array (membership)\n- eq with array value: checks set equality (order-insensitive)\n- has_any: checks if array contains any of the specified values\n- has_all: checks if array contains all of the specified values\n- contains_any: any array element contains any substring (case-insensitive)\n- contains_all: array elements collectively contain all substrings (case-insensitive)\n\nlistEntries queries:\n- Require 'listId' or 'listName' filter (listName resolves to ID at runtime)\n- Custom field values are auto-fetched when referenced in groupBy, aggregate, or where\n- Use 'fields.<FieldName>' paths for custom list fields\n- Select fields: listEntryId, entityId, entityName, entityType, listId, createdAt, fields.<Name>, fields.*\n\nExamples:\n- {\"from\": \"persons\", \"where\": {\"path\": \"email\", \"op\": \"contains\", \"value\": \"@acme.com\"}, \"limit\": 50}\n- {\"from\": \"listEntries\", \"where\": {\"path\": \"listName\", \"op\": \"eq\", \"value\": \"Dealflow\"}, \"select\": [\"listEntryId\", \"entityName\", \"fields.Status\"]}\n- {\"from\": \"listEntries\", \"where\": {\"and\": [{\"path\": \"listName\", \"op\": \"eq\", \"value\": \"Dealflow\"}, {\"path\": \"entityName\", \"op\": \"contains\", \"value\": \"Acme\"}]}}\n- {\"from\": \"opportunities\", \"include\": [\"companies\"], \"orderBy\": [{\"field\": \"created_at\", \"direction\": \"desc\"}]}\n- {\"from\": \"persons\", \"where\": {\"path\": \"companies._count\", \"op\": \"gte\", \"value\": 2}, \"limit\": 100}\n- {\"from\": \"persons\", \"where\": {\"all\": {\"path\": \"companies\", \"where\": {\"path\": \"domain\", \"op\": \"contains\", \"value\": \".com\"}}}}\n- {\"from\": \"persons\", \"where\": {\"exists\": {\"from\": \"interactions\"}}}\n\nPerformance notes:\n- Includes cause N+1 API calls (1 per parent record) - use dryRun to preview\n- Quantifiers (all, none, exists) and _count also cause N+1 API calls to fetch relationship data\n- IMPORTANT: Quantifier queries on 'persons', 'companies', or 'opportunities' require explicit maxRecords to prevent slow queries (could take 26+ minutes on large databases)\\n- Recommended: Start from 'listEntries' (bounded by list) instead of unbounded entities for quantifier queries\\n- Use dryRun=true to preview the execution plan with estimated API calls before running",
  "inputSchema": {
    "type": "object",
    "required": ["query"],
    "properties": {
      "query": {
        "type": "object",
        "description": "JSON query object with 'from' (required) and optional where, include, select, orderBy, groupBy, aggregate, having, limit fields.",
        "properties": {
          "$version": {
            "type": "string",
            "description": "Query version (default: '1.0')"
          },
          "from": {
            "type": "string",
            "enum": ["persons", "companies", "opportunities", "listEntries", "interactions", "notes"],
            "description": "Entity type to query"
          },
          "where": {
            "type": "object",
            "description": "Filter conditions. Simple: {path, op, value}. Compound: {and: [...]} or {or: [...]}"
          },
          "include": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Related entities to include (e.g., ['companies', 'opportunities', 'listEntries'])"
          },
          "select": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Fields to return (default: all)"
          },
          "orderBy": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "field": { "type": "string" },
                "direction": { "type": "string", "enum": ["asc", "desc"] }
              }
            },
            "description": "Sort order"
          },
          "groupBy": {
            "type": "string",
            "description": "Field to group by for aggregates"
          },
          "aggregate": {
            "type": "object",
            "description": "Aggregate functions: {alias: {sum/avg/count/min/max/percentile: field}}"
          },
          "having": {
            "type": "object",
            "description": "Filter on aggregate results"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum records to return"
          }
        },
        "required": ["from"]
      },
      "dryRun": {
        "type": "boolean",
        "default": false,
        "description": "If true, return the execution plan with estimated API calls without running the query."
      },
      "maxRecords": {
        "type": "integer",
        "default": 1000,
        "description": "Safety limit for maximum records to fetch (default 1000, max 10000)."
      },
      "timeout": {
        "type": "integer",
        "default": 120,
        "description": "Query timeout in seconds (default 120)."
      },
      "maxOutputBytes": {
        "type": "integer",
        "default": 50000,
        "description": "Maximum output size in bytes (default 50000). Larger outputs are truncated."
      },
      "format": {
        "type": "string",
        "enum": ["json", "jsonl", "markdown", "toon", "csv"],
        "default": "json",
        "description": "Output format. Use 'markdown' for analysis (best LLM comprehension), 'toon' for large datasets (40% fewer tokens), 'json' for programmatic processing."
      }
    }
  },
  "timeoutSecs": 180,
  "annotations": {
    "readOnlyHint": true,
    "destructiveHint": false,
    "idempotentHint": true,
    "openWorldHint": true
  }
}
