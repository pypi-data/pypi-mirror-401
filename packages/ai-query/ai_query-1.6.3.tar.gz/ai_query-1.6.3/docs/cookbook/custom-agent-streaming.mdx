---
title: "Custom Agent Streaming"
description: "Protocol-agnostic feedback for agents"
---

This guide shows how to provide rich feedback (thinking status, tool execution logs) using the `AgentOutput` abstraction.

This approach allows your agent logic to remain independent of the transport (WebSocket, SSE, etc.).

## The Agent Logic

This agent defines **what** feedback to send, but not **how** to send it.

```python
from ai_query.agents import ChatAgent, InMemoryAgent

class ResearchBot(ChatAgent, InMemoryAgent):
    system = "You are a research assistant. Use tools to find info."

    async def on_step_start(self, event):
        """Notify the user when a thinking step starts."""
        # Use self.output to send status updates
        # This works regardless of whether we're on WebSocket or SSE
        await self.output.send_status(
            f"Thinking (Step {event.step_number})...",
            details={
                "tools_available": list(event.tools.keys()) if event.tools else []
            }
        )

    async def on_step_finish(self, event):
        """Notify the user about tool calls."""
        if event.step.tool_calls:
            for tc in event.step.tool_calls:
                await self.output.send_status(
                    f"ğŸ› ï¸ Executing tool: {tc.name}",
                    details=tc.arguments
                )
```

## Transport 1: WebSocket Server

When running as a WebSocket server, use `WebSocketOutput`.

```python
from ai_query.agents import AgentServer
from ai_query.agents.output import WebSocketOutput

class WebSocketBot(ResearchBot):
    async def on_message(self, conn, message):
        # 1. Create the adapter for this connection
        output = WebSocketOutput(conn)

        # 2. Pass it to chat()
        # The agent will use this output in its hooks
        response = await self.chat(message, output=output)

        # 3. Send final response
        await conn.send(response)

# Run the server
WebSocketBot.serve_many(port=8080)
```

**Client receives:**
```json
// Status update
{"type": "status", "status": "Thinking (Step 1)...", "details": {"tools_available": ["search"]}}

// Status update
{"type": "status", "status": "ğŸ› ï¸ Executing tool: search", "details": {"query": "python"}}

// Final response
"Here is what I found..."
```

## Transport 2: SSE (Streaming REST)

When running via an HTTP endpoint (e.g. `POST /chat`), use `SSEOutput`.

```python
from aiohttp import web
from ai_query.agents.output import SSEOutput

async def handle_chat(request):
    # Prepare SSE response
    response = web.StreamResponse(headers={"Content-Type": "text/event-stream"})
    await response.prepare(request)

    # 1. Create the adapter
    output = SSEOutput(response)

    agent = ResearchBot("user-1")

    # 2. Pass it to stream_chat()
    # Agent will send status events via SSE
    full_response = ""
    async for chunk in agent.stream_chat("Research Python", output=output):
        full_response += chunk
        # Send text chunks as message events
        await output.send_message(chunk)

    return response
```

**Client receives:**
```
event: status
data: {"status": "Thinking (Step 1)...", "details": {...}}

event: status
data: {"status": "ğŸ› ï¸ Executing tool: search", "details": {...}}

event: message
data: Here is what I found...
```

## Custom Output: Terminal

You can even run the same agent in the terminal!

```python
import asyncio
from ai_query.agents.output import AgentOutput

class TerminalOutput(AgentOutput):
    async def send_message(self, content: str) -> None:
        print(f"ğŸ¤– {content}", end="", flush=True)

    async def send_status(self, status: str, details: dict | None = None) -> None:
        print(f"\n[STATUS] {status}")
        if details:
            print(f"         {details}")

    async def send_error(self, error: str) -> None:
        print(f"\n[ERROR] {error}")

async def main():
    bot = ResearchBot("cli-bot")
    output = TerminalOutput()

    print("User: Research Python")
    await bot.chat("Research Python", output=output)

asyncio.run(main())
```

**Output:**
```
[STATUS] Thinking (Step 1)...
         {'tools_available': ['search']}
[STATUS] ğŸ› ï¸ Executing tool: search
         {'query': 'python'}
ğŸ¤– Here is what I found...
```
