from abc import ABC, abstractmethod, abstractclassmethod
from dataclasses import dataclass
from datetime import datetime, UTC
from typing import Type, TypeVar
import json
from brenthy_tools_beta.utils import (
    string_to_time,
    time_to_string,
    bytes_to_string,
    string_to_bytes,
)
from multi_crypt import Crypt
from .log import logger_keys as logger


_Key = TypeVar("_Key", bound="Key")


class GenericKey(ABC):
    @abstractclassmethod
    def from_id(cls, group_key_id: str):
        pass

    @abstractmethod
    def get_id(self) -> str:
        pass

    @abstractmethod
    def verify_signature(self, signature: bytes, data: bytes) -> bool:
        pass

    @abstractmethod
    def sign(self, data: bytes) -> bytes:
        pass

    @abstractmethod
    def encrypt(self, data_to_encrypt: bytes) -> bytes:
        pass

    @abstractmethod
    def decrypt(self, encrypted_data: bytes) -> bytes:
        pass

    @abstractmethod
    def is_unlocked(self) -> bool:
        pass

    @abstractmethod
    def serialise_private(
        self,
    ) -> dict:
        pass

    @abstractmethod
    def serialise_private_encrypted(
        self, crypt: Crypt, allow_missing_private_key: bool = False
    ) -> dict:
        pass

    @abstractmethod
    def clone_public(self):
        pass


@dataclass
class Key(Crypt, GenericKey):
    """Represents a set of cryptographic keys, compatible with DID specs."""

    family: str
    public_key: bytes
    private_key: bytes | None
    creation_time: datetime

    def __init__(
        self,
        family: str,
        public_key: bytes | str,
        private_key: bytes | str | None,
        creation_time: datetime,
    ):
        """Create a Key object."""
        if isinstance(public_key, str):
            public_key = bytes.fromhex(public_key)

        if isinstance(private_key, str):
            private_key = bytes.fromhex(private_key)
        self.family = family
        self.public_key = public_key
        self.private_key = private_key
        self.creation_time = creation_time
        super().__init__(
            family=self.family,
            private_key=self.private_key,
            public_key=self.public_key,
        )

    @classmethod
    def create(cls: Type[_Key], family: str) -> _Key:
        """Initialise a Key from a DID key spec from a DID document."""
        crypt = Crypt.new(family)

        return cls(
            family=crypt.family,
            public_key=crypt.public_key,
            private_key=crypt.private_key,
            creation_time=datetime.now(UTC),
        )

    @classmethod
    def from_crypt(
        cls: Type[_Key], crypt: Crypt, creation_time: datetime
    ) -> _Key:
        """Create a Key object from a Crypt object."""
        return cls(
            family=crypt.family,
            public_key=crypt.public_key,
            private_key=crypt.private_key,
            creation_time=creation_time,
        )

    @classmethod
    def from_key_spec(cls: Type[_Key], key_spec: dict) -> _Key:
        """Initialise a Key from a DID key spec from a DID document."""
        key = cls(
            family=key_spec["type"],
            public_key=key_spec["publicKeyMultibase"],
            private_key=None,
            creation_time=string_to_time(key_spec["creation_time"]),
        )
        if key_spec["id"].strip("#") != key.get_id():
            raise ValueError(
                "The key-spec's key ID doesn't match our convention"
            )
        return key

    @classmethod
    def from_id(cls: Type[_Key], key_id: str) -> _Key:
        """Initialise a Key from a key ID generated by this class."""
        if "|" in key_id:
            raise ValueError(
                "It looks like this key_id might be from a KeyGroup"
            )
        data = key_id.split(":")
        public_key = data[-1]
        timestamp = data[-2]
        family = ":".join(data[0:-2])
        key = cls(
            family=family,
            public_key=public_key,
            private_key=None,
            creation_time=string_to_time(timestamp),
        )
        return key

    def generate_key_spec(self, controller: str) -> dict:
        """Generate a key spec for a DID document."""
        return {
            "id": f"#{self.get_id()}",
            "type": self.family,
            "publicKeyMultibase": self.public_key.hex(),
            "creation_time": time_to_string(self.creation_time),
            "controller": controller,
        }

    def serialise_private(
        self,
    ) -> dict:
        """Serialise this key's data, including the private key encrypted."""

        if not (
            self.private_key,
            self.family and self.public_key and self.creation_time,
        ):
            error_message = "Not all of this objects' fields are set!\n".join(
                [
                    f"family: {type(self.family)}",
                    f"public_key: {type(self.public_key)}",
                    f"private_key: {type(self.private_key)}",
                    f"creation_time: {type(self.creation_time)}",
                ]
            )
            raise ValueError(error_message)

        return {
            "family": self.family,
            "public_key": self.public_key.hex(),
            "private_key": self.private_key.hex(),
            "creation_time": time_to_string(self.creation_time),
        }

    def serialise_private_encrypted(
        self, crypt: Crypt, allow_missing_private_key: bool = False
    ) -> dict:
        """Serialise this key's data, including the private key encrypted."""
        if not allow_missing_private_key and not self.private_key:
            raise ValueError(
                "Private Key is not set!\n"
                "You can use the `allow_missing_private_key` parameter to "
                "ignore this."
            )

        if not (self.family and self.public_key and self.creation_time):
            error_message = "Not all of this objects' fields are set!\n".join(
                [
                    f"family: {type(self.family)}",
                    f"public_key: {type(self.public_key)}",
                    f"creation_time: {type(self.creation_time)}",
                ]
            )
            raise ValueError(error_message)

        private_key = (
            crypt.encrypt(self.private_key).hex() if self.private_key else None
        )
        return {
            "family": self.family,
            "public_key": self.public_key.hex(),
            "private_key": private_key,
            "creation_time": time_to_string(self.creation_time),
        }

    def clone_public(self):
        return Key.from_id(self.get_id())

    def is_unlocked(self) -> bool:
        if self.private_key:
            return True
        return False

    @classmethod
    def deserialise_private(
        cls: Type[_Key],
        data: dict,
    ) -> _Key:
        """Deserialise data with encrypted private key."""
        if isinstance(data, str):
            data = json.loads(data)
        return cls(
            family=data["family"],
            public_key=bytes.fromhex(data["public_key"]),
            private_key=bytes.fromhex(data["private_key"]),
            creation_time=string_to_time(data["creation_time"]),
        )

    @classmethod
    def deserialise_private_encrypted(
        cls: Type[_Key], data: dict, crypt: Crypt
    ) -> _Key:
        """Deserialise data with encrypted private key."""
        if isinstance(data, str):
            data = json.loads(data)
        private_key = (
            crypt.decrypt(bytes.fromhex(data["private_key"]))
            if data.get("private_key")
            else None
        )
        return cls(
            family=data["family"],
            public_key=data["public_key"],
            private_key=private_key,
            creation_time=string_to_time(data["creation_time"]),
        )

    def get_private_key(self) -> str:
        if not self.private_key:
            raise ValueError("This key's private key hasn't been defined")
        return self.private_key.hex()

    def get_id(self) -> str:
        return generate_key_id(
            family=self.family,
            creation_time=self.creation_time,
            public_key=self.public_key,
        )

    def __str__(self):
        return self.get_id()


def generate_key_id(
    family: str,
    public_key: bytes | str,
    creation_time: datetime,
):
    if isinstance(public_key, bytes) or isinstance(public_key, bytearray):
        public_key = public_key.hex()
    if not (family and public_key and creation_time):
        raise ValueError("Not all key fields provided.")
    return f"{family}:{time_to_string(creation_time)}:{public_key}"


class KeyGroup(GenericKey):
    def __init__(self, keys: list[Key]):
        self.keys = keys
        assert len(self.keys) > 0, "Error: This GroupKey has 0 keys."

    @classmethod
    def create(cls, key_families: list[str]):
        keys = [Key.create(family=family) for family in key_families]
        return cls(keys)

    @classmethod
    def from_id(cls, group_key_id: str):
        key_ids = decode_keygroup_id(group_key_id)
        keys = [Key.from_id(key_id) for key_id in key_ids]
        return cls(keys)

    def get_id(self) -> str:
        assert len(self.keys) > 0, "Error: This GroupKey has 0 keys."
        # leading "|" to ensure that key-groups with 1 key are recognised as KeyGroup objects
        return "|" + "|".join(self.get_ids())

    def get_keys(self) -> list[Key]:
        assert len(self.keys) > 0, "Error: This GroupKey has 0 keys."
        return self.keys

    def get_ids(self) -> list[str]:
        assert len(self.keys) > 0, "Error: This GroupKey has 0 keys."
        return [key.get_id() for key in self.get_keys()]

    def verify_signature(
        self,
        signature: bytes,
        data: bytes,
        signature_options: str | None = None,
    ) -> bool:
        assert len(self.keys) > 0, "Error: This GroupKey has 0 keys."
        signatures = [
            bytes.fromhex(sig) for sig in signature.decode().split("-")
        ]
        if not len(signatures) == len(self.keys):
            logger.warning("Wrong number of signatures")
            return False
        for i, key in enumerate(self.keys):
            if not key.verify_signature(
                signatures[i], data, signature_options
            ):
                return False

        return True

    def sign(self, data: bytes, signature_options: str | None = None) -> bytes:
        assert len(self.keys) > 0, "Error: This GroupKey has 0 keys."
        signatures = []
        for key in self.keys:
            signatures.append(key.sign(data, signature_options))
        return str.encode(
            "-".join([bytes.hex(signature) for signature in signatures])
        )

    def encrypt(
        self,
        data_to_encrypt: bytes,
        encryption_options: list[str] | None = None,
    ) -> bytes:
        data = data_to_encrypt
        assert len(self.keys) > 0, "Error: This GroupKey has 0 keys."
        for key in self.keys:
            data = key.encrypt(data, encryption_options=encryption_options)
        return data

    def decrypt(
        self,
        encrypted_data: bytes,
        encryption_options: list[str] | None = None,
    ) -> bytes:
        data = encrypted_data
        assert len(self.keys) > 0, "Error: This GroupKey has 0 keys."
        for key in self.keys[::-1]:  # iterate through keys backwards
            data = key.decrypt(data, encryption_options=encryption_options)
        return data

    def is_unlocked(self) -> bool:
        for key in self.keys:
            if not key.is_unlocked():
                return False
        return True

    def serialise_private_encrypted(
        self, crypt: Crypt, allow_missing_private_key: bool = False
    ) -> dict:
        return [
            key.serialise_private_encrypted(
                crypt=crypt,
                allow_missing_private_key=allow_missing_private_key,
            )
            for key in self.keys
        ]

    @classmethod
    def deserialise_private_encrypted(
        cls: Type[_Key], data: list[dict], crypt: Crypt
    ) -> _Key:
        return cls([Key.deserialise_private_encrypted(s, crypt) for s in data])

    def serialise_private(
        self,
    ) -> dict:
        return [key.serialise_private() for key in self.keys]

    @classmethod
    def deserialise_private(
        cls: Type[_Key],
        data: list[dict],
    ) -> _Key:
        return cls(
            [
                Key.deserialise_private(
                    s,
                )
                for s in data
            ]
        )

    def clone_public(self):
        return KeyGroup.from_id(self.get_id())

    def generate_key_specs(self, controller: str) -> list[dict]:
        """Generate a key spec for a DID document."""
        return [key.generate_key_spec(controller) for key in self.keys]

    @classmethod
    def from_key_specs(cls: Type[_Key], key_spec: list[dict]) -> _Key:
        return cls([Key.from_key_spec(key_spec) for key_spec in key_spec])


def decode_keygroup_id(group_key_id: str) -> list[str]:
    # take account for leading "|"
    return [x for x in group_key_id.split("|") if x]


_CodePackage = TypeVar("_CodePackage", bound="CodePackage")


@dataclass
class CodePackage:
    """Package of encrypted data or a signature with crypto-key-metadata."""

    def __init__(
        self,
        key: GenericKey,
        code: bytes,
        operation_options: str | None = None,
    ):
        self.key = key
        self.code = bytes(code)
        self.operation_options = operation_options

    @classmethod
    def deserialise(cls: Type[_CodePackage], data: str) -> _CodePackage:
        _data = json.loads(data)
        return cls(
            code=string_to_bytes(_data["code"]),
            key=generic_key_from_id(_data["key_id"]),
            operation_options=_data["operation_options"],
        )

    @classmethod
    def deserialise_bytes(
        cls: Type[_CodePackage], data: bytes
    ) -> _CodePackage:
        _data = data.decode()
        return cls.deserialise(_data)

    def serialise(self) -> str:
        return json.dumps(
            {
                "code": bytes_to_string(self.code),
                "key_id": self.key.get_id(),
                "operation_options": self.operation_options,
            }
        )

    def serialise_bytes(self) -> bytes:
        return self.serialise().encode()

    def verify_signature(self, data: bytes) -> bool:
        """Assuming self.code is a signature, verify it against the signed data."""
        signature = self.code
        return self.key.verify_signature(
            signature=signature,
            data=data,
            signature_options=self.operation_options,
        )

    def decrypt(
        self,
    ) -> bool:
        """Assuming self.code is a signature, verify it against the signed data."""
        return self.key.decrypt(
            encrypted_data=self.code,
            encryption_options=self.operation_options,
        )

    def unlock_key(self, key: GenericKey) -> bool:
        if not self.key.get_id() == key.get_id():
            raise ValueError(
                "Replacement key object doesn't have the same key ID"
            )
        if not key.is_unlocked():
            raise ValueError("Replacement key is locked.")
        self.key = key

    @staticmethod
    def encrypt(
        data: bytes, key: Key, encryption_options: str | None = None
    ) -> _CodePackage:
        """Encrypt the provided data using the specified key.

        Args:
            data (bytes): the data to encrypt
            key (Key): the key to use to encrypt the data
            encryption_options (str): specification code for which
                            encryption/decryption protocol should be used
        Returns:
            CodePackage: an object containing the ciphertext, public-key,
                            crypto-family and encryption-options
        """
        cipher = key.encrypt(
            data_to_encrypt=data,
            encryption_options=encryption_options,
        )
        return CodePackage(
            code=cipher,
            key=key,
            operation_options=encryption_options,
        )

    @staticmethod
    def sign(
        data: bytes, key: Key, signature_options: str | None = None
    ) -> _CodePackage:
        """Sign the provided data using the specified key.

        Args:
            data (bytes): the data to encrypt
            key (Key): the key to use to encrypt the data
            encryption_options (str): specification code for which
                            encryption/decryption protocol should be used
        Returns:
            CodePackage: an object containing the ciphertext, public-key,
                            crypto-family and encryption-options
        """
        cipher = key.sign(
            data=data,
            signature_options=signature_options,
        )
        return CodePackage(
            code=cipher,
            key=key,
            operation_options=signature_options,
        )

    def get_key(self) -> Key:
        return self.key

    def get_id(self) -> str:
        return self.key.get_id()


def generic_key_from_id(key_id: str) -> Key | KeyGroup:
    if "|" in key_id:
        return KeyGroup.from_id(key_id)
    else:
        return Key.from_id(key_id)
