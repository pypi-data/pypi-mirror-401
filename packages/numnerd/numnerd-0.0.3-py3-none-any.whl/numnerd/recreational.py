from numnerd.primes import prime_factorization, is_prime
import math
from typing import Set

def is_armstrong_number(n: int) -> bool:
    """
    Checks if n is an Armstrong (Narcissistic) number.
    A number that is the sum of its own digits each raised to the power of 
    the number of digits.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is an Armstrong number.
    """
    if n < 0:
        return False
    s = str(n)
    power = len(s)
    return n == sum(int(digit) ** power for digit in s)

def is_happy_number(n: int) -> bool:
    """
    Checks if n is a Happy number.
    A number which eventually reaches 1 when replaced by the sum of the 
    squares of its digits.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is a Happy number.
    """
    if n <= 0:
        return False
    seen: Set[int] = set()
    temp_n = n
    while temp_n != 1 and temp_n not in seen:
        seen.add(temp_n)
        temp_n = sum(int(digit) ** 2 for digit in str(temp_n))
    return temp_n == 1

def kaprekar_routine(n: int) -> int:
    """
    Calculates the number of steps to reach Kaprekar's constant (6174) for 
    a 4-digit number.

    Args:
        n (int): A 4-digit integer with at least two distinct digits.

    Returns:
        int: Number of steps, or -1 if the digits are all identical.
        
    Raises:
        ValueError: If n is not a 4-digit number.
    """
    if not (1000 <= n <= 9999):
         raise ValueError("n must be a 4-digit number")
    
    if n == 6174:
        return 0

    steps = 0
    current = n
    
    while current != 6174:
        s = str(current).zfill(4)
        if len(set(s)) == 1:
            return -1

        digits = list(s)
        desc = int("".join(sorted(digits, reverse=True)))
        asc = int("".join(sorted(digits)))
        
        current = desc - asc
        steps += 1
        
        if steps > 50:
             break
             
    return steps

def digital_root(n: int) -> int:
    """
    Calculates the digital root of an integer.
    The recursive sum of its digits until a single digit remains.

    Args:
        n (int): The non-negative integer to check.

    Returns:
        int: The digital root.
    """
    if n < 0:
         raise ValueError("n must be non-negative")
    if n == 0:
        return 0
    return 1 + (n - 1) % 9

def is_harshad_number(n: int) -> bool:
    """
    Checks if n is a Harshad (Niven) number.
    A number divisible by the sum of its digits.

    Args:
        n (int): The positive integer to check.

    Returns:
        bool: True if n is a Harshad number.
    """
    if n <= 0: return False
    digit_sum = sum(int(d) for d in str(n))
    return n % digit_sum == 0

def is_automorphic_number(n: int) -> bool:
    """
    Checks if n is an Automorphic number.
    A number whose square ends with the same digits as n.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is Automorphic.
    """
    if n < 0: return False
    square = n * n
    return str(square).endswith(str(n))

def is_pronic_number(n: int) -> bool:
    """
    Checks if n is a Pronic (Oblong) number.
    A number that is the product of two consecutive integers: n(n+1).

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is Pronic.
    """
    if n < 0: return False
    k = int(math.sqrt(n))
    return k * (k + 1) == n

def is_smith_number(n: int) -> bool:
    """
    Checks if n is a Smith number.
    A composite number where the sum of its digits equals the sum of the 
    digits of its prime factors.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is a Smith number.
    """
    if n <= 1: return False
    if is_prime(n): return False
    
    digits_sum = sum(int(d) for d in str(n))
    
    factors = prime_factorization(n)
    factors_digits_sum = 0
    for f in factors:
        factors_digits_sum += sum(int(d) for d in str(f))
        
    return digits_sum == factors_digits_sum

def is_disarium_number(n: int) -> bool:
    """
    Checks if n is a Disarium number.
    The sum of its digits powered by their respective positions equals n.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is Disarium.
    """
    if n < 0: return False
    s = str(n)
    total = sum(int(d) ** (i + 1) for i, d in enumerate(s))
    return total == n

def is_keith_number(n: int) -> bool:
    """
    Checks if n is a Keith (Repfigit) number.
    A number that appears in a Fibonacci-like sequence generated by its digits.

    Args:
        n (int): The integer to check (typically > 9).

    Returns:
        bool: True if n is a Keith number.
    """
    if n < 10:
        return False
        
    s = str(n)
    digits = [int(d) for d in s]
    k = len(digits)
    
    sequence = digits[:]
    
    while True:
        next_term = sum(sequence[-k:])
        if next_term == n:
            return True
        if next_term > n:
            return False
        sequence.append(next_term)

def is_abundant_number(n: int) -> bool:
    """
    Checks if n is an Abundant number.
    Sum of proper divisors > n.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is Abundant.
    """
    if n <= 1: return False
    sum_divisors = 1
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            sum_divisors += i
            if i * i != n:
                sum_divisors += n // i
    return sum_divisors > n

def is_deficient_number(n: int) -> bool:
    """
    Checks if n is a Deficient number.
    Sum of proper divisors < n.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is Deficient.
    """
    if n <= 1: return True
    sum_divisors = 1
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            sum_divisors += i
            if i * i != n:
                sum_divisors += n // i
    return sum_divisors < n

def is_kaprekar_number(n: int) -> bool:
    """
    Checks if n is a Kaprekar number.
    A number whose square can be split into two parts that sum to n.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is a Kaprekar number.
    """
    if n == 1: return True
    sq = n * n
    s = str(sq)
    
    for i in range(1, len(s)):
        left = int(s[:i])
        right = int(s[i:])
        if right > 0 and left + right == n:
            return True
    return False

def is_polydivisible_number(n: int) -> bool:
    """
    Checks if n is a Polydivisible number.
    The first k digits are divisible by k for all k.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is Polydivisible.
    """
    if n <= 0: return False
    s = str(n)
    for i in range(1, len(s) + 1):
        prefix = int(s[:i])
        if prefix % i != 0:
            return False
    return True

def is_vampire_number(n: int) -> bool:
    """
    Checks if n is a Vampire number.
    A number with even digits k that can be factored into two k/2 digit 
    integers using the same digits as n.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is a Vampire number.
    """
    s = str(n)
    if len(s) % 2 != 0:
        return False
    
    half = len(s) // 2
    sorted_s = sorted(s)
    
    start = 10**(half - 1)
    end = int(math.sqrt(n)) + 1
    
    for x in range(start, end):
        if n % x == 0:
            y = n // x
            if len(str(x)) == half and len(str(y)) == half:
                if str(x).endswith("0") and str(y).endswith("0"):
                    continue
                if sorted(str(x) + str(y)) == sorted_s:
                    return True
    return False

def is_spy_number(n: int) -> bool:
    """
    Checks if n is a Spy number (Sum of digits == Product of digits).

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is a Spy number.
    """
    if n < 0: return False
    digits = [int(d) for d in str(n)]
    s = sum(digits)
    p = 1
    for d in digits:
        p *= d
    return s == p

def is_neon_number(n: int) -> bool:
    """
    Checks if n is a Neon number (Sum of digits of n^2 equals n).

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is a Neon number.
    """
    if n < 0: return False
    square = n * n
    return sum(int(d) for d in str(square)) == n

def is_munchausen_number(n: int) -> bool:
    """
    Checks if n is a Munchausen number.
    Sum of its digits raised to the power of themselves equals n.

    Args:
        n (int): The integer to check.

    Returns:
        bool: True if n is Munchausen.
    """
    if n < 0: return False
    total = 0
    temp = n
    while temp > 0:
        d = temp % 10
        val = 0 if d == 0 else d ** d
        total += val
        temp //= 10
    return total == n