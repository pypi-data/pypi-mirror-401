# /feature - Structured Feature Implementation

Force structured feature development with auto-generated requirements and validation.

## Purpose

Bypass intelligent routing and force the **auto-spec workflow**: system generates lightweight requirements, implements code, and validates against acceptance criteria.

## Usage

```bash
/feature <description>                      # Build structured feature
/feature implement user authentication      # Feature with validation
/feature add API endpoint for users         # Structured development
/feature build caching system               # With requirements
```

## When to Use

âœ… **Use /feature when**:

- Building a moderately complex feature (not trivial, not massive)
- Want validation but don't want to write full spec manually
- Need requirement traceability
- Working on something that might grow
- Want structured development without ceremony

âŒ **Don't use /feature when**:

- Task is super simple â†’ Use `/code` instead
- Already have TASK-XXX spec â†’ Use `/implement TASK-XXX` instead
- Just want quick code â†’ Use `/code` instead
- Task is extremely complex â†’ Write manual spec, then `/implement`

## How It Works

```
/feature <description>
  â†“
orchestrator analyzes complexity
  â†“
orchestrator generates lightweight requirements:
  - Auto-generated task-graph.yaml
  - Auto-generated requirements.yaml with acceptance criteria
  â†“
User reviews requirements (can edit before proceeding)
  â†“
orchestrator â†’ spec_implementer (implements with requirements)
  â†“
orchestrator â†’ spec_validator (validates against criteria)
  â†“
Returns: Implementation + validation report
```

Creates spec, formal validation, requirement tracking.

## Examples

### Example 1: Medium Feature

```bash
/feature implement JWT authentication
```

System response:

```
Analyzing feature... (complexity: 65)
Generating requirements...

AUTO-001: JWT Authentication System
- Generate JWT tokens on login
- Validate tokens on protected routes
- Secure password hashing
- Error handling for invalid tokens

Review requirements? [Y/n]: Y
[Opens editor with requirements.yaml]

Proceeding with implementation...
âœ“ spec_implementer: JWT auth implemented
âœ“ spec_validator: 4/4 acceptance criteria passed

Done! Files created:
- src/auth/jwt.py
- tests/test_jwt.py
```

### Example 2: API Endpoint

```bash
/feature add API endpoint for user registration
```

System generates:

- Task: POST /api/register endpoint
- Requirements:
  - Email/password validation
  - Database user creation
  - Return JWT token
  - Error handling
- Implements with tests
- Validates all criteria

### Example 3: Complex System

```bash
/feature build complete OAuth system with Google and GitHub
```

System response:

```
âš ï¸ This is very complex (complexity: 95)

I recommend creating manual requirements instead:
1. Write detailed spec in requirements.md
2. Run: /spec extract requirements.md
3. Run: /implement TASK-XXX

Or I can generate lightweight requirements and proceed anyway?
[1: Manual spec (recommended) / 2: Auto-generate / 3: Cancel]
```

## Comparison with Other Commands

| Command      | Spec Type  | Validation | Speed     | Use Case            |
| ------------ | ---------- | ---------- | --------- | ------------------- |
| `/code`      | âŒ None    | Basic      | âš¡ Fast   | Quick utilities     |
| `/feature`   | âœ… Auto    | Formal     | â±ï¸ Medium | Structured features |
| `/implement` | âœ… Manual  | Formal     | â±ï¸ Medium | Complex features    |
| `/ai`        | ğŸ¤– Decides | Varies     | Varies    | Let system choose   |

## What Gets Created

When you use `/feature`, the system creates:

### 1. Task Graph

`.coordination/spec/auto/YYYY-MM-DD-HHMMSS-task-graph.yaml`:

```yaml
tasks:
  - id: AUTO-001
    title: <Your Feature>
    status: pending
    dependencies: []
    spec_file: .coordination/spec/auto/YYYY-MM-DD-HHMMSS-requirements.yaml
```

### 2. Requirements File

`.coordination/spec/auto/YYYY-MM-DD-HHMMSS-requirements.yaml`:

```yaml
task_id: AUTO-001
title: <Your Feature>
description: <Auto-generated description>
generated: true
source: '/feature <your original command>'

acceptance_criteria:
  - <Criterion 1>
  - <Criterion 2>
  - <Criterion 3>

complexity: medium
estimated_subtasks: 3
```

### 3. Implementation

Code files in appropriate locations following project structure.

### 4. Tests

Test files with basic test cases.

### 5. Validation Report

`.claude/agent-outputs/YYYY-MM-DD-HHMMSS-validation-complete.json`:

```json
{
  "task_id": "AUTO-001",
  "status": "passed",
  "criteria_passed": 4,
  "criteria_failed": 0,
  "details": "..."
}
```

## After Using /feature

What you can do next:

1. **Use the feature** - It's implemented and validated
2. **Review the code** - `/review path/to/file.py`
3. **Iterate** - Request changes to implementation
4. **Run validation again** - `/validate AUTO-001`
5. **Commit** - `/git "implement authentication"`
6. **Upgrade to manual spec** - Edit requirements.yaml for more detail

## Editing Auto-Generated Requirements

You can edit requirements before implementation:

```bash
/feature implement caching system
```

â†’ System generates requirements
â†’ Opens editor for review
â†’ Edit requirements.yaml as needed
â†’ Confirm to proceed
â†’ Implementation follows your edited requirements

## Benefits of /feature

vs. `/code` (ad-hoc):

- âœ… Formal validation
- âœ… Requirement tracking
- âœ… Better for medium complexity
- âœ… Easier to maintain

vs. `/implement` (manual spec):

- âœ… Faster (auto-generated)
- âœ… Less ceremony
- âœ… Good enough for most features
- âš ï¸ Less detailed requirements

## Configuration

Behavior controlled in `.claude/config.yaml`:

```yaml
orchestration:
  workflow:
    auto_spec_enabled: true # Enable /feature
    auto_spec_prompt: true # Ask before generating
    auto_spec_auto_approve: false # Or auto-approve
    ad_hoc_max: 30 # Complexity threshold
    auto_spec_max: 70 # Max for auto-spec
```

## Workflow

```
/feature â†’ orchestrator (auto-spec mode)
         â†’ Generate requirements
         â†’ spec_implementer
         â†’ spec_validator
         â†’ Return results
```

## Aliases

The following aliases work identically:

- `/build` â†’ `/feature`
- `/develop` â†’ `/feature`
- `/impl` â†’ `/feature`

## Version

v1.0.0 (2026-01-09) - Initial creation as part of three-path workflow system
