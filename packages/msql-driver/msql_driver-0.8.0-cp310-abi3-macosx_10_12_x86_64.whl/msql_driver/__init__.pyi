# Initial type stubs auto-generated by pyo3-stub-gen using pyo3-introspection.
# Edited and completed manually.

__version__: str
__all__ = [
	'LOG_DEBUG',
	'LOG_ERR',
	'LOG_INFO',
	'LOG_TRACE',
	'CancelHandle',
	'ResultHandle',
	'RowIter',
	'RowType',
	'Rows',
	'SessionConfig',
	'SessionHandle',
	'SessionStatus',
	'set_log_level',
]

from collections.abc import Iterable
from enum import Enum
from typing import Any, Final, Never, Self

import numpy as np
import pandas as pd

class CancelHandle:
	def __new__(cls: Never, /) -> Never: ...
	async def async_cancel(self, /) -> None: ...
	def cancel(self, /) -> None: ...

class ResultHandle:
	def __new__(cls: Never, /) -> Never: ...
	async def async_get(self, /) -> list[Rows]: ...
	def get(self, /) -> list[Rows]: ...
	def try_get(self, /) -> list[Rows] | None: ...

class RowIter:
	def __new__(cls: Never, /) -> Never: ...
	def __iter__(self, /) -> Self: ...
	def __next__(self, /) -> tuple[Any, ...]: ...

class RowType:
	def __new__(cls: Never, /) -> Never: ...
	def __len__(self, /) -> int: ...
	def any_nullable(self, /) -> bool: ...
	@property
	def columns(self, /) -> list[tuple[str, str]]: ...
	@property
	def exact_size(self, /) -> int: ...
	def is_varlen(self, /) -> bool: ...
	@property
	def record_size(self, /) -> int: ...

class Rows:
	def __new__(cls: Never, /) -> Never: ...
	def __iter__(self, /) -> RowIter: ...
	def __len__(self, /) -> int: ...
	@property
	def row_type(self, /) -> RowType: ...
	def to_bytes(self, /) -> bytes: ...
	def to_list(self, /) -> list[tuple[Any, ...]]: ...
	def to_numpy(self, /) -> np.ndarray: ...
	def to_pandas(self, /) -> pd.DataFrame: ...

class SessionConfig:
	def __new__(cls, /) -> Self: ...
	def build(self, /) -> SessionHandle: ...
	def connect_backoff_base_duration(self, /, base_secs: float) -> Self: ...
	def connect_backoff_factor(self, /, factor: float) -> Self: ...
	def connect_backoff_max_duration(self, /, base_secs: float) -> Self: ...
	def connect_max_retry_count(self, /, retry_count: int) -> Self: ...
	def connect_timeout(self, /, timeout_secs: float) -> Self: ...
	def host(self, /, hostname: str) -> Self: ...
	def hosts(self, /, hostnames: Iterable[str]) -> Self: ...
	def keepalive_timeout(self, /, timeout_secs: float) -> Self: ...
	def ping_interval(self, /, interval_secs: float) -> Self: ...
	def randomize_host_order(self, /, randomize_host_order: bool) -> Self: ...
	def user(self, /, organization: str, username: str, password: str) -> Self: ...

class SessionHandle:
	def __new__(cls: Never, /) -> Never: ...
	def __bool__(self, /) -> bool: ...
	async def async_restart(self, /) -> None: ...
	async def async_run_query(self, /, query: str) -> list[Rows]: ...
	async def async_status(self, /) -> SessionStatus: ...
	async def async_stop(self, /) -> None: ...
	async def async_submit_query(self, /, query: str) -> tuple[ResultHandle, CancelHandle]: ...
	def restart(self, /) -> None: ...
	def run_query(self, /, query: str) -> list[Rows]: ...
	def status(self, /) -> SessionStatus: ...
	def stop(self, /) -> None: ...
	def submit_query(self, /, query: str) -> tuple[ResultHandle, CancelHandle]: ...

class SessionStatus(Enum):
	Connected = 0
	AuthenticationFailed = 1
	NoReachableHosts = 2
	Stopped = 3
	def __new__(cls: Never, /) -> Never: ...
	def __bool__(self, /) -> bool: ...
	def __eq__(self, /, other: object) -> bool: ...
	def __ne__(self, /, other: object) -> bool: ...

def set_log_level(verbosity: int) -> None: ...

LOG_ERR: Final = 0
LOG_INFO: Final = 1
LOG_DEBUG: Final = 2
LOG_TRACE: Final = 3
