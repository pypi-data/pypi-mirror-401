name: Auto Labeler

on:
  issues:
    types: [opened, edited]
  pull_request:
    types: [opened, edited, synchronized, reopened]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  label-item:
    runs-on: ubuntu-latest
    steps:
      - name: Auto Labeler
        uses: actions/github-script@v8
        with:
          script: |
            // Helper to add labels
            async function addLabels(labels) {
              if (labels.size > 0) {
                console.log(`Adding labels: ${Array.from(labels)}`);
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: Array.from(labels)
                  });
                } catch (error) {
                  console.log("Error adding labels. Ensure they exist in the repository.");
                  console.error(error);
                }
              } else {
                console.log("No matching label patterns found.");
              }
            }

            // Logic for Pull Requests
            if (context.payload.pull_request) {
              const title = context.payload.pull_request.title;
              const labelsToAdd = new Set();
              
              const mappings = [
                { label: 'feat', regex: /^(feat|feature|Feat)(\/|:|\s|\()/i },
                { label: 'fix', regex: /^(fix|bug|Fix)(\/|:|\s|\()/i },
                { label: 'docs', regex: /^(docs|doc|documentation|Docs)(\/|:|\s|\()/i },
                { label: 'style', regex: /^(style|format)(\/|:|\s|\()/i },
                { label: 'refactor', regex: /^(refactor|remove)(\/|:|\s|\()/i },
                { label: 'perf', regex: /^(perf|performance)(\/|:|\s|\()/i },
                { label: 'test', regex: /^(test|tests)(\/|:|\s|\()/i },
                { label: 'build', regex: /^(build)(\/|:|\s|\()/i },
                { label: 'ci', regex: /^(ci|workflow|actions)(\/|:|\s|\()/i },
                { label: 'chore', regex: /^(chore|misc)(\/|:|\s|\()/i },
                { label: 'dependencies', regex: /^(deps|dep|depbot|dependencies)(\/|:|\s|\()/i }
              ];

              for (const { label, regex } of mappings) {
                if (regex.test(title)) {
                  labelsToAdd.add(label);
                }
              }
              await addLabels(labelsToAdd);
            }
            
            // Logic for Issues
            else if (context.payload.issue) {
              const title = context.payload.issue.title || '';
              const body = context.payload.issue.body || '';
              const content = (title + ' ' + body).toLowerCase();
              const labelsToAdd = new Set();

              const windowsKeywords = [
                'windows', 'win10', 'win11', 
                'server 2019', 'server 2022', 'win server'
              ];
              
              const linuxKeywords = [
                'linux', 'ubuntu', 'debian', 
                'centos', 'fedora', 'redhat', 
                'arch', 'alpine', 'wsl'
              ];

              if (windowsKeywords.some(keyword => content.includes(keyword))) {
                labelsToAdd.add('windows');
              }

              if (linuxKeywords.some(keyword => content.includes(keyword))) {
                labelsToAdd.add('linux');
              }
              
              await addLabels(labelsToAdd);
            }
