"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright (c) 2023 Arista Networks, Inc.  All rights reserved.
Use of this source code is governed by the Apache License 2.0
that can be found in the COPYING file.

NOTE: This is a workspace-aware Resource API.
Please see workspace.v1 for more information.
"""

import builtins
import collections.abc
import fmp.wrappers_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _EntityType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EntityTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EntityType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ENTITY_TYPE_UNSPECIFIED: _EntityType.ValueType  # 0
    """ENTITY_TYPE_UNSPECIFIED indicates an unspecified entity type."""
    ENTITY_TYPE_STUDIO: _EntityType.ValueType  # 1
    """ENTITY_TYPE_STUDIO indicates the Studio entity type."""
    ENTITY_TYPE_INPUTS: _EntityType.ValueType  # 2
    """ENTITY_TYPE_INPUTS indicates the Inputs entity type."""
    ENTITY_TYPE_ASSIGNED_TAGS: _EntityType.ValueType  # 3
    """ENTITY_TYPE_ASSIGNED_TAGS indicates the AssignedTags entity type."""
    ENTITY_TYPE_BUILD_HOOK: _EntityType.ValueType  # 4
    """ENTITY_TYPE_BUILD_HOOK indicates the BuildHook entity type."""
    ENTITY_TYPE_AUTOFILL_ACTION: _EntityType.ValueType  # 5
    """ENTITY_TYPE_AUTOFILL_ACTION indicates the AutofillAction entity type."""
    ENTITY_TYPE_CONFIGLET: _EntityType.ValueType  # 6
    """ENTITY_TYPE_CONFIGLET indicates the Configlet entity type for
    static config studio.
    """
    ENTITY_TYPE_CONFIGLET_ASSIGNMENT: _EntityType.ValueType  # 7
    """ENTITY_TYPE_CONFIGLET_ASSIGNMENT indicates the ConfigletAssignment
    entity type for static config studio.
    """

class EntityType(_EntityType, metaclass=_EntityTypeEnumTypeWrapper):
    """EntityType enumerates the set of entity types."""

ENTITY_TYPE_UNSPECIFIED: EntityType.ValueType  # 0
"""ENTITY_TYPE_UNSPECIFIED indicates an unspecified entity type."""
ENTITY_TYPE_STUDIO: EntityType.ValueType  # 1
"""ENTITY_TYPE_STUDIO indicates the Studio entity type."""
ENTITY_TYPE_INPUTS: EntityType.ValueType  # 2
"""ENTITY_TYPE_INPUTS indicates the Inputs entity type."""
ENTITY_TYPE_ASSIGNED_TAGS: EntityType.ValueType  # 3
"""ENTITY_TYPE_ASSIGNED_TAGS indicates the AssignedTags entity type."""
ENTITY_TYPE_BUILD_HOOK: EntityType.ValueType  # 4
"""ENTITY_TYPE_BUILD_HOOK indicates the BuildHook entity type."""
ENTITY_TYPE_AUTOFILL_ACTION: EntityType.ValueType  # 5
"""ENTITY_TYPE_AUTOFILL_ACTION indicates the AutofillAction entity type."""
ENTITY_TYPE_CONFIGLET: EntityType.ValueType  # 6
"""ENTITY_TYPE_CONFIGLET indicates the Configlet entity type for
static config studio.
"""
ENTITY_TYPE_CONFIGLET_ASSIGNMENT: EntityType.ValueType  # 7
"""ENTITY_TYPE_CONFIGLET_ASSIGNMENT indicates the ConfigletAssignment
entity type for static config studio.
"""
global___EntityType = EntityType

class _TemplateType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _TemplateTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TemplateType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    TEMPLATE_TYPE_UNSPECIFIED: _TemplateType.ValueType  # 0
    """TEMPLATE_TYPE_UNSPECIFIED indicates an unspecified template type."""
    TEMPLATE_TYPE_MAKO: _TemplateType.ValueType  # 1
    """TEMPLATE_TYPE_MAKO is the Mako templating language for Python.
    More information: https://www.makotemplates.org
    """
    TEMPLATE_TYPE_JINJA: _TemplateType.ValueType  # 2
    """TEMPLATE_TYPE_JINJA is the Jinja templating language for Python.
    More information: https://palletsprojects.com/p/jinja
    """
    TEMPLATE_TYPE_GO: _TemplateType.ValueType  # 3
    """TEMPLATE_TYPE_GO is the Go templating language.
    More information: https://pkg.go.dev/text/template

    NOTE: Not all template functions are supported for this type.
    """

class TemplateType(_TemplateType, metaclass=_TemplateTypeEnumTypeWrapper):
    """TemplateType defines the set of supported languages that can
    be used in studio templates.
    """

TEMPLATE_TYPE_UNSPECIFIED: TemplateType.ValueType  # 0
"""TEMPLATE_TYPE_UNSPECIFIED indicates an unspecified template type."""
TEMPLATE_TYPE_MAKO: TemplateType.ValueType  # 1
"""TEMPLATE_TYPE_MAKO is the Mako templating language for Python.
More information: https://www.makotemplates.org
"""
TEMPLATE_TYPE_JINJA: TemplateType.ValueType  # 2
"""TEMPLATE_TYPE_JINJA is the Jinja templating language for Python.
More information: https://palletsprojects.com/p/jinja
"""
TEMPLATE_TYPE_GO: TemplateType.ValueType  # 3
"""TEMPLATE_TYPE_GO is the Go templating language.
More information: https://pkg.go.dev/text/template

NOTE: Not all template functions are supported for this type.
"""
global___TemplateType = TemplateType

class _InputFieldType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _InputFieldTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_InputFieldType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    INPUT_FIELD_TYPE_UNSPECIFIED: _InputFieldType.ValueType  # 0
    """INPUT_FIELD_TYPE_UNSPECIFIED indicates an unspecified input data type."""
    INPUT_FIELD_TYPE_BOOLEAN: _InputFieldType.ValueType  # 1
    """INPUT_FIELD_TYPE_BOOLEAN is the data type for a boolean value."""
    INPUT_FIELD_TYPE_INTEGER: _InputFieldType.ValueType  # 2
    """INPUT_FIELD_TYPE_INTEGER is the data type for an integer value."""
    INPUT_FIELD_TYPE_FLOAT: _InputFieldType.ValueType  # 3
    """INPUT_FIELD_TYPE_FLOAT is the data type for a float value."""
    INPUT_FIELD_TYPE_STRING: _InputFieldType.ValueType  # 4
    """INPUT_FIELD_TYPE_STRING is the data type for a string value."""
    INPUT_FIELD_TYPE_GROUP: _InputFieldType.ValueType  # 5
    """INPUT_FIELD_TYPE_GROUP is the data type for an unordered group of
    inputs of any type. This type is used in cases where inputs are
    required to be consolidated into an object for use in the template
    or to attach multiple inputs under a resolver or collection.
    """
    INPUT_FIELD_TYPE_COLLECTION: _InputFieldType.ValueType  # 6
    """INPUT_FIELD_TYPE_COLLECTION is the data type for an ordered collection
    of inputs of the same type. This type is used in cases where multiple
    input values of the same type should be given for a field, and where
    ordering matters.
    """
    INPUT_FIELD_TYPE_RESOLVER: _InputFieldType.ValueType  # 7
    """INPUT_FIELD_TYPE_RESOLVER is the data type for an input that allows
    its member input to be assigned based on a tag query match. This
    type is used in cases where the input value is conditional on a
    device or a group of devices. The query is resolved at run-time
    and each affected device is given the value that corresponds to
    the tag it is assigned to.
    """
    INPUT_FIELD_TYPE_TAG_MATCHER: _InputFieldType.ValueType  # 8
    """INPUT_FIELD_TYPE_TAG_MATCHER is the data type for an input that allows
    an unordered set of devices or interfaces to be selected. The set of
    devices or interfaces that are to be selected are specified by a tag
    query, resolved at run-time.
    """

class InputFieldType(_InputFieldType, metaclass=_InputFieldTypeEnumTypeWrapper):
    """InputFieldType defines the set of possible data types for
    values that can be input into a studio.
    """

INPUT_FIELD_TYPE_UNSPECIFIED: InputFieldType.ValueType  # 0
"""INPUT_FIELD_TYPE_UNSPECIFIED indicates an unspecified input data type."""
INPUT_FIELD_TYPE_BOOLEAN: InputFieldType.ValueType  # 1
"""INPUT_FIELD_TYPE_BOOLEAN is the data type for a boolean value."""
INPUT_FIELD_TYPE_INTEGER: InputFieldType.ValueType  # 2
"""INPUT_FIELD_TYPE_INTEGER is the data type for an integer value."""
INPUT_FIELD_TYPE_FLOAT: InputFieldType.ValueType  # 3
"""INPUT_FIELD_TYPE_FLOAT is the data type for a float value."""
INPUT_FIELD_TYPE_STRING: InputFieldType.ValueType  # 4
"""INPUT_FIELD_TYPE_STRING is the data type for a string value."""
INPUT_FIELD_TYPE_GROUP: InputFieldType.ValueType  # 5
"""INPUT_FIELD_TYPE_GROUP is the data type for an unordered group of
inputs of any type. This type is used in cases where inputs are
required to be consolidated into an object for use in the template
or to attach multiple inputs under a resolver or collection.
"""
INPUT_FIELD_TYPE_COLLECTION: InputFieldType.ValueType  # 6
"""INPUT_FIELD_TYPE_COLLECTION is the data type for an ordered collection
of inputs of the same type. This type is used in cases where multiple
input values of the same type should be given for a field, and where
ordering matters.
"""
INPUT_FIELD_TYPE_RESOLVER: InputFieldType.ValueType  # 7
"""INPUT_FIELD_TYPE_RESOLVER is the data type for an input that allows
its member input to be assigned based on a tag query match. This
type is used in cases where the input value is conditional on a
device or a group of devices. The query is resolved at run-time
and each affected device is given the value that corresponds to
the tag it is assigned to.
"""
INPUT_FIELD_TYPE_TAG_MATCHER: InputFieldType.ValueType  # 8
"""INPUT_FIELD_TYPE_TAG_MATCHER is the data type for an input that allows
an unordered set of devices or interfaces to be selected. The set of
devices or interfaces that are to be selected are specified by a tag
query, resolved at run-time.
"""
global___InputFieldType = InputFieldType

class _ResolverFieldInputMode:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ResolverFieldInputModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ResolverFieldInputMode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    RESOLVER_FIELD_INPUT_MODE_UNSPECIFIED: _ResolverFieldInputMode.ValueType  # 0
    """RESOLVER_FIELD_INPUT_MODE_UNSPECIFIED indicates an unspecified resolver input mode."""
    RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG: _ResolverFieldInputMode.ValueType  # 1
    """RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG allows devices to be
    selected based on a single tag label.
    """
    RESOLVER_FIELD_INPUT_MODE_SINGLE_INTERFACE_TAG: _ResolverFieldInputMode.ValueType  # 2
    """RESOLVER_FIELD_INPUT_MODE_SINGLE_INTERFACE_TAG allows interfaces
    to be selected based on a single tag label.
    """
    RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG: _ResolverFieldInputMode.ValueType  # 3
    """RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG allows devices to be
    selected based on any tag label.
    """
    RESOLVER_FIELD_INPUT_MODE_MULTI_INTERFACE_TAG: _ResolverFieldInputMode.ValueType  # 4
    """RESOLVER_FIELD_INPUT_MODE_MULTI_INTERFACE_TAG allows interfaces
    to be selected based on any tag label.
    """

class ResolverFieldInputMode(_ResolverFieldInputMode, metaclass=_ResolverFieldInputModeEnumTypeWrapper):
    """ResolverFieldInputMode defines the set of ways a resolver tag query
    can be specified in a studio.
    """

RESOLVER_FIELD_INPUT_MODE_UNSPECIFIED: ResolverFieldInputMode.ValueType  # 0
"""RESOLVER_FIELD_INPUT_MODE_UNSPECIFIED indicates an unspecified resolver input mode."""
RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG: ResolverFieldInputMode.ValueType  # 1
"""RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG allows devices to be
selected based on a single tag label.
"""
RESOLVER_FIELD_INPUT_MODE_SINGLE_INTERFACE_TAG: ResolverFieldInputMode.ValueType  # 2
"""RESOLVER_FIELD_INPUT_MODE_SINGLE_INTERFACE_TAG allows interfaces
to be selected based on a single tag label.
"""
RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG: ResolverFieldInputMode.ValueType  # 3
"""RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG allows devices to be
selected based on any tag label.
"""
RESOLVER_FIELD_INPUT_MODE_MULTI_INTERFACE_TAG: ResolverFieldInputMode.ValueType  # 4
"""RESOLVER_FIELD_INPUT_MODE_MULTI_INTERFACE_TAG allows interfaces
to be selected based on any tag label.
"""
global___ResolverFieldInputMode = ResolverFieldInputMode

class _ResolverFieldDisplayMode:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ResolverFieldDisplayModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ResolverFieldDisplayMode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    RESOLVER_FIELD_DISPLAY_MODE_UNSPECIFIED: _ResolverFieldDisplayMode.ValueType  # 0
    """RESOLVER_FIELD_DISPLAY_MODE_UNSPECIFIED indicates an unspecified resolver display mode."""
    RESOLVER_FIELD_DISPLAY_MODE_ALL: _ResolverFieldDisplayMode.ValueType  # 1
    """RESOLVER_FIELD_DISPLAY_MODE_ALL instructs the UI to show all
    matching devices or interfaces, including ones that have no
    inputs.
    """
    RESOLVER_FIELD_DISPLAY_MODE_SPARSE: _ResolverFieldDisplayMode.ValueType  # 2
    """RESOLVER_FIELD_DISPLAY_MODE_SPARSE instructs the UI to show
    only matching devices or interfaces that have inputs.
    """

class ResolverFieldDisplayMode(_ResolverFieldDisplayMode, metaclass=_ResolverFieldDisplayModeEnumTypeWrapper):
    """ResolverFieldDisplayMode defines the set of ways in which the matching
    devices or interfaces should be displayed on the UI.
    """

RESOLVER_FIELD_DISPLAY_MODE_UNSPECIFIED: ResolverFieldDisplayMode.ValueType  # 0
"""RESOLVER_FIELD_DISPLAY_MODE_UNSPECIFIED indicates an unspecified resolver display mode."""
RESOLVER_FIELD_DISPLAY_MODE_ALL: ResolverFieldDisplayMode.ValueType  # 1
"""RESOLVER_FIELD_DISPLAY_MODE_ALL instructs the UI to show all
matching devices or interfaces, including ones that have no
inputs.
"""
RESOLVER_FIELD_DISPLAY_MODE_SPARSE: ResolverFieldDisplayMode.ValueType  # 2
"""RESOLVER_FIELD_DISPLAY_MODE_SPARSE instructs the UI to show
only matching devices or interfaces that have inputs.
"""
global___ResolverFieldDisplayMode = ResolverFieldDisplayMode

class _TagMatcherFieldMode:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _TagMatcherFieldModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TagMatcherFieldMode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    TAG_MATCHER_FIELD_MODE_UNSPECIFIED: _TagMatcherFieldMode.ValueType  # 0
    """TAG_MATCHER_FIELD_MODE_UNSPECIFIED indicates an unspecified tag matcher mode."""
    TAG_MATCHER_FIELD_MODE_SINGLE_DEVICE_TAG: _TagMatcherFieldMode.ValueType  # 1
    """TAG_MATCHER_FIELD_MODE_SINGLE_DEVICE_TAG allows devices to be
    selected based on a single tag label.
    """
    TAG_MATCHER_FIELD_MODE_SINGLE_INTERFACE_TAG: _TagMatcherFieldMode.ValueType  # 2
    """TAG_MATCHER_FIELD_MODE_SINGLE_INTERFACE_TAG allows interfaces
    to be selected based on a single tag label.
    """
    TAG_MATCHER_FIELD_MODE_MULTI_DEVICE_TAG: _TagMatcherFieldMode.ValueType  # 3
    """TAG_MATCHER_FIELD_MODE_MULTI_DEVICE_TAG allows devices to be
    selected based on any tag label.
    """
    TAG_MATCHER_FIELD_MODE_MULTI_INTERFACE_TAG: _TagMatcherFieldMode.ValueType  # 4
    """TAG_MATCHER_FIELD_MODE_MULTI_INTERFACE_TAG allows interfaces
    to be selected based on any tag label.
    """

class TagMatcherFieldMode(_TagMatcherFieldMode, metaclass=_TagMatcherFieldModeEnumTypeWrapper):
    """TagMatcherFieldMode defines the set of ways a tag query for matching
    device or interfaces can be specified in a studio.
    """

TAG_MATCHER_FIELD_MODE_UNSPECIFIED: TagMatcherFieldMode.ValueType  # 0
"""TAG_MATCHER_FIELD_MODE_UNSPECIFIED indicates an unspecified tag matcher mode."""
TAG_MATCHER_FIELD_MODE_SINGLE_DEVICE_TAG: TagMatcherFieldMode.ValueType  # 1
"""TAG_MATCHER_FIELD_MODE_SINGLE_DEVICE_TAG allows devices to be
selected based on a single tag label.
"""
TAG_MATCHER_FIELD_MODE_SINGLE_INTERFACE_TAG: TagMatcherFieldMode.ValueType  # 2
"""TAG_MATCHER_FIELD_MODE_SINGLE_INTERFACE_TAG allows interfaces
to be selected based on a single tag label.
"""
TAG_MATCHER_FIELD_MODE_MULTI_DEVICE_TAG: TagMatcherFieldMode.ValueType  # 3
"""TAG_MATCHER_FIELD_MODE_MULTI_DEVICE_TAG allows devices to be
selected based on any tag label.
"""
TAG_MATCHER_FIELD_MODE_MULTI_INTERFACE_TAG: TagMatcherFieldMode.ValueType  # 4
"""TAG_MATCHER_FIELD_MODE_MULTI_INTERFACE_TAG allows interfaces
to be selected based on any tag label.
"""
global___TagMatcherFieldMode = TagMatcherFieldMode

class _AutofillProviderType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _AutofillProviderTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AutofillProviderType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    AUTOFILL_PROVIDER_TYPE_UNSPECIFIED: _AutofillProviderType.ValueType  # 0
    """AUTOFILL_PROVIDER_TYPE_UNSPECIFIED indicates that no provider type is specified."""
    AUTOFILL_PROVIDER_TYPE_USER_SPECIFIED: _AutofillProviderType.ValueType  # 1
    """AUTOFILL_PROVIDER_TYPE_USER_SPECIFIED is when an argument is to be
    provided at runtime by the user.
    """
    AUTOFILL_PROVIDER_TYPE_PREDEFINED: _AutofillProviderType.ValueType  # 2
    """AUTOFILL_PROVIDER_TYPE_PREDEFINED is when an argument has a predefined value."""
    AUTOFILL_PROVIDER_TYPE_LINKED: _AutofillProviderType.ValueType  # 3
    """AUTOFILL_PROVIDER_TYPE_LINKED is when an argument is linked to another studio input field."""

class AutofillProviderType(_AutofillProviderType, metaclass=_AutofillProviderTypeEnumTypeWrapper):
    """AutofillProviderType describes the set of possible provided argument types."""

AUTOFILL_PROVIDER_TYPE_UNSPECIFIED: AutofillProviderType.ValueType  # 0
"""AUTOFILL_PROVIDER_TYPE_UNSPECIFIED indicates that no provider type is specified."""
AUTOFILL_PROVIDER_TYPE_USER_SPECIFIED: AutofillProviderType.ValueType  # 1
"""AUTOFILL_PROVIDER_TYPE_USER_SPECIFIED is when an argument is to be
provided at runtime by the user.
"""
AUTOFILL_PROVIDER_TYPE_PREDEFINED: AutofillProviderType.ValueType  # 2
"""AUTOFILL_PROVIDER_TYPE_PREDEFINED is when an argument has a predefined value."""
AUTOFILL_PROVIDER_TYPE_LINKED: AutofillProviderType.ValueType  # 3
"""AUTOFILL_PROVIDER_TYPE_LINKED is when an argument is linked to another studio input field."""
global___AutofillProviderType = AutofillProviderType

@typing.final
class StudioKey(google.protobuf.message.Message):
    """StudioKey uniquely identifies a studio."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STUDIO_ID_FIELD_NUMBER: builtins.int
    WORKSPACE_ID_FIELD_NUMBER: builtins.int
    @property
    def studio_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """studio_id uniquely identifies the studio in the workspace indicated
        by `workspace_id`.
        """

    @property
    def workspace_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """workspace_id identifies the workspace within which the studio resides."""

    def __init__(
        self,
        *,
        studio_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        workspace_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["studio_id", b"studio_id", "workspace_id", b"workspace_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["studio_id", b"studio_id", "workspace_id", b"workspace_id"]) -> None: ...

global___StudioKey = StudioKey

@typing.final
class StudioConfig(google.protobuf.message.Message):
    """StudioConfig holds a configuration for a studio.

    Changes to fields other than `key` and `remove` are applied to
    a copy of the mainline.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    REMOVE_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    TEMPLATE_FIELD_NUMBER: builtins.int
    INPUT_SCHEMA_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___StudioKey:
        """key uniquely identifies the studio."""

    @property
    def remove(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """remove indicates whether to remove (`true`) or add (`false`,
        unset) the studio identified by the key if the encompassing
        workspace merges. Other data fields are not allowed if this
        field is set to true.
        """

    @property
    def display_name(self) -> google.protobuf.wrappers_pb2.StringValue:
        """display_name is the name of this studio as displayed on the UI.
        This and remaining fields are config fields, with workspace changes to be applied
        on top of mainline. The corresponding `Studio` will be present
        in the workspace only if the studio is modified (via this resource).
        """

    @property
    def description(self) -> google.protobuf.wrappers_pb2.StringValue:
        """description is a brief description of the studio."""

    @property
    def template(self) -> global___Template:
        """template is a script that builds the device configuration from the
        inputs that are described by `input_schema`.
        """

    @property
    def input_schema(self) -> global___InputSchema:
        """input_schema is the schema for the studio inputs that are processed
        by `template`.
        """

    def __init__(
        self,
        *,
        key: global___StudioKey | None = ...,
        remove: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        display_name: google.protobuf.wrappers_pb2.StringValue | None = ...,
        description: google.protobuf.wrappers_pb2.StringValue | None = ...,
        template: global___Template | None = ...,
        input_schema: global___InputSchema | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["description", b"description", "display_name", b"display_name", "input_schema", b"input_schema", "key", b"key", "remove", b"remove", "template", b"template"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["description", b"description", "display_name", b"display_name", "input_schema", b"input_schema", "key", b"key", "remove", b"remove", "template", b"template"]) -> None: ...

global___StudioConfig = StudioConfig

@typing.final
class StudioSummary(google.protobuf.message.Message):
    """StudioSummary holds basic information about a studio."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    IMMUTABLE_FIELD_NUMBER: builtins.int
    ENTITIES_FIELD_NUMBER: builtins.int
    IN_USE_FIELD_NUMBER: builtins.int
    FROM_PACKAGE_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___StudioKey:
        """key uniquely identifies the studio."""

    @property
    def display_name(self) -> google.protobuf.wrappers_pb2.StringValue:
        """display_name is the name of this studio as displayed on the UI."""

    @property
    def description(self) -> google.protobuf.wrappers_pb2.StringValue:
        """description is a brief description of the studio."""

    @property
    def immutable(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """immutable indicates if read-write studio management
        access over a given studio is granted or not.
        If studio is immutable, its display name, description,
        schema and template cannot be modified.
        """

    @property
    def entities(self) -> global___Entities:
        """entities indicate all the entities of the studio."""

    @property
    def in_use(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """in_use indicates that the studio is in use, i.e. there are non-empty inputs,
        and assigned to some devices, either in a given workspace, or in mainline.
        """

    @property
    def from_package(self) -> google.protobuf.wrappers_pb2.StringValue:
        """from_package indicates that this studio was created by a package, and can only be modified
        by the packaging service. It stores packageID.
        """

    def __init__(
        self,
        *,
        key: global___StudioKey | None = ...,
        display_name: google.protobuf.wrappers_pb2.StringValue | None = ...,
        description: google.protobuf.wrappers_pb2.StringValue | None = ...,
        immutable: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        entities: global___Entities | None = ...,
        in_use: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        from_package: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["description", b"description", "display_name", b"display_name", "entities", b"entities", "from_package", b"from_package", "immutable", b"immutable", "in_use", b"in_use", "key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["description", b"description", "display_name", b"display_name", "entities", b"entities", "from_package", b"from_package", "immutable", b"immutable", "in_use", b"in_use", "key", b"key"]) -> None: ...

global___StudioSummary = StudioSummary

@typing.final
class Entity(google.protobuf.message.Message):
    """Entity holds the basic information of an entity."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENTITY_TYPE_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_AT_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_BY_FIELD_NUMBER: builtins.int
    REMOVED_FIELD_NUMBER: builtins.int
    entity_type: global___EntityType.ValueType
    """entity_type is the type of the entity."""
    @property
    def last_modified_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """last_modified_at is the time at which the entity was last modified."""

    @property
    def last_modified_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """last_modified_by is the name of the user that last modified the entity."""

    @property
    def removed(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """removed indicates if the entity is removed."""

    def __init__(
        self,
        *,
        entity_type: global___EntityType.ValueType = ...,
        last_modified_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        last_modified_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        removed: google.protobuf.wrappers_pb2.BoolValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by", "removed", b"removed"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["entity_type", b"entity_type", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by", "removed", b"removed"]) -> None: ...

global___Entity = Entity

@typing.final
class Entities(google.protobuf.message.Message):
    """Entities is a list of Entity."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ValuesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___Entity: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___Entity | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___Entity]:
        """values is a map from entity type name to entity
        The possible keys to this map are ENTITY_TYPE_STUDIO,
        ENTITY_TYPE_INPUTS, ENTITY_TYPE_ASSIGNED_TAGS,
        ENTITY_TYPE_BUILD_HOOK and ENTITY_TYPE_AUTOFILL_ACTION.
        """

    def __init__(
        self,
        *,
        values: collections.abc.Mapping[builtins.str, global___Entity] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

global___Entities = Entities

@typing.final
class Studio(google.protobuf.message.Message):
    """Studio holds the active state for a studio."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    CREATED_AT_FIELD_NUMBER: builtins.int
    CREATED_BY_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_AT_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_BY_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    TEMPLATE_FIELD_NUMBER: builtins.int
    INPUT_SCHEMA_FIELD_NUMBER: builtins.int
    FROM_PACKAGE_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___StudioKey:
        """key uniquely identifies the studio."""

    @property
    def created_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """created_at is the time at which the studio was created."""

    @property
    def created_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """created_by is the name of the user that created the studio."""

    @property
    def last_modified_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """last_modified_at is the time at which the studio was last modified."""

    @property
    def last_modified_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """last_modified_by is the name of the user that last modified the studio."""

    @property
    def display_name(self) -> google.protobuf.wrappers_pb2.StringValue:
        """display_name is the name of this studio as displayed on the UI.
        This and remaining fields are config fields, with workspace changes applied on top of
        mainline. This resource will be present in the workspace only if
        the studio is modified (via the `StudioConfig` resource).
        """

    @property
    def description(self) -> google.protobuf.wrappers_pb2.StringValue:
        """description is a brief description of the studio."""

    @property
    def template(self) -> global___Template:
        """template is a script that builds the device configuration from the
        inputs that are described by `input_schema`.
        """

    @property
    def input_schema(self) -> global___InputSchema:
        """input_schema is the schema for the studio inputs that are processed
        by `template`.
        """

    @property
    def from_package(self) -> google.protobuf.wrappers_pb2.StringValue:
        """from_package indicates that this studio was created by a package, and can only be modified
        by the packaging service.
        """

    def __init__(
        self,
        *,
        key: global___StudioKey | None = ...,
        created_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        created_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        last_modified_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        last_modified_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        display_name: google.protobuf.wrappers_pb2.StringValue | None = ...,
        description: google.protobuf.wrappers_pb2.StringValue | None = ...,
        template: global___Template | None = ...,
        input_schema: global___InputSchema | None = ...,
        from_package: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["created_at", b"created_at", "created_by", b"created_by", "description", b"description", "display_name", b"display_name", "from_package", b"from_package", "input_schema", b"input_schema", "key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by", "template", b"template"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["created_at", b"created_at", "created_by", b"created_by", "description", b"description", "display_name", b"display_name", "from_package", b"from_package", "input_schema", b"input_schema", "key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by", "template", b"template"]) -> None: ...

global___Studio = Studio

@typing.final
class AssignedTagsConfig(google.protobuf.message.Message):
    """AssignedTagsConfig holds a configuration to assign a studio to a set of devices
    matching a tag query.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    REMOVE_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___StudioKey:
        """key uniquely identifies the studio to which to assign devices."""

    @property
    def remove(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """remove indicates whether to remove (`true`) or add (`false`,
        unset) the tag assignments involving the studio identified
        by the key if the encompassing workspace merges. Other data
        fields are not allowed if this field is set to true.
        """

    @property
    def query(self) -> google.protobuf.wrappers_pb2.StringValue:
        """query is a tag query string that conforms to the CloudVision
        tag query language. E.g., the query, `"datacenter:NYC,SFO AND
        sflow:enabled"`, matches all devices with sflow enabled in
        data centers NYC and SFO.
        """

    def __init__(
        self,
        *,
        key: global___StudioKey | None = ...,
        remove: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        query: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "query", b"query", "remove", b"remove"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "query", b"query", "remove", b"remove"]) -> None: ...

global___AssignedTagsConfig = AssignedTagsConfig

@typing.final
class AssignedTags(google.protobuf.message.Message):
    """AssignedTags can be used to retrieve additional metadata about a
    studio's `AssignedTagsConfig`.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    CREATED_AT_FIELD_NUMBER: builtins.int
    CREATED_BY_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_AT_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_BY_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___StudioKey:
        """key uniquely identifies the studio to which devices were assigned."""

    @property
    def created_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """created_at is the time at which the assignment was first created."""

    @property
    def created_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """created_by is the name of the user that created the assignment."""

    @property
    def last_modified_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """last_modified_at is the time at which the assignment was last modified."""

    @property
    def last_modified_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """last_modified_by is the name of the user that last modified the assignment."""

    @property
    def query(self) -> google.protobuf.wrappers_pb2.StringValue:
        """query is a tag query string that conforms to the CloudVision
        tag query language. See `AssignedTagsConfig`.
        """

    def __init__(
        self,
        *,
        key: global___StudioKey | None = ...,
        created_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        created_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        last_modified_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        last_modified_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        query: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["created_at", b"created_at", "created_by", b"created_by", "key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by", "query", b"query"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["created_at", b"created_at", "created_by", b"created_by", "key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by", "query", b"query"]) -> None: ...

global___AssignedTags = AssignedTags

@typing.final
class InputsKey(google.protobuf.message.Message):
    """InputsKey identifies a set of inputs for a particular studio."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STUDIO_ID_FIELD_NUMBER: builtins.int
    WORKSPACE_ID_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    @property
    def studio_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """studio_id uniquely identifies the studio in the workspace indicated
        by `workspace_id`.
        """

    @property
    def workspace_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """workspace_id uniquely identifies the workspace in which the studio resides."""

    @property
    def path(self) -> fmp.wrappers_pb2.RepeatedString:
        """path is the sequence of elements that uniquely identify an input field.
        An empty path (`[]`) stands for the root of the inputs, or the entire
        set of inputs for the studio.

        The members of a group are referenced by field name. E.g., for a group
        A with a member B, the path to B would be `["A", "B"]`.

        Collection and resolver members can be referenced in two ways:

        1. Index-based: Using an integer string index.
           E.g., for a collection A with three members, the path to the
           second member would be `["A", "1"]`.

        2. Key-based: Using bracket notation to specify
           key-value pairs for keyed collections:
           `["collectionName", "[keyName=keyValue]", ...]`
           E.g., for a collection of NTP servers keyed by IP address:
           `["ntpServers", "[ip=10.10.10.10]", "vrf"]`

        For resolver fields with tag queries, bracket notation is supported
        with the mandatory "inputs" keyword:
        `["resolverName", "[tags/query=tagQuery]", "inputs", ...]`
        E.g., for a device resolver with tag query "device:leaf1":
        `["devices", "[tags/query=device:leaf1]", "inputs", "hostname"]`

        Both index-based and key-based formats are supported for collections
        and resolvers.
        """

    def __init__(
        self,
        *,
        studio_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        workspace_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        path: fmp.wrappers_pb2.RepeatedString | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["path", b"path", "studio_id", b"studio_id", "workspace_id", b"workspace_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["path", b"path", "studio_id", b"studio_id", "workspace_id", b"workspace_id"]) -> None: ...

global___InputsKey = InputsKey

@typing.final
class InputsConfig(google.protobuf.message.Message):
    """InputsConfig is used to input values into a studio.

    NOTE: Setting an input at a higher path overwrite any prior
    `Set`s at lower paths. E.g.,

    1. Set `["A", "X"]` to `"foo"`
    2. Set `["A", "Y"]` to `"bar"`
    3. Set `["A"]` to `{"X": "bar"}`

    The resulting inputs would be:
    ```
    { "A": { "X": "bar" } }
    ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    REMOVE_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___InputsKey:
        """key uniquely identifies the set of inputs for the studio (at some path)."""

    @property
    def remove(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """remove indicates whether to remove (`true`) or add (`false`,
        unset) the inputs identified by the key if the encompassing
        workspace merges. Other data fields are not allowed if this
        field is set to true.
        """

    @property
    def inputs(self) -> google.protobuf.wrappers_pb2.StringValue:
        """inputs is the value of the input field at the path as a
        JSON string. It can be the value for a simple or complex
        input field.

        Simple types (booleans, integers, floats, strings) map to
        their JSON equivalents.

        Complex types map to either arrays or objects:

        * The group field type maps to a JSON object, where keys
          are group members.

        * The collection field type maps to a JSON array.

        * The resolver field type maps to a JSON array, where each
          element is an object of the form:
          ```
          {
        	"tags":   { "query": <query> },
        	"inputs": <input>
          }
          ```
          Above, `<input>` is the value of the base field of the resolver.
          E.g., if the base field is a group with one string member `"A"`,
          the resolver inputs would be specified as:
          ```
          "inputs": { "A": <value> }
          ```
        """

    def __init__(
        self,
        *,
        key: global___InputsKey | None = ...,
        remove: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        inputs: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["inputs", b"inputs", "key", b"key", "remove", b"remove"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["inputs", b"inputs", "key", b"key", "remove", b"remove"]) -> None: ...

global___InputsConfig = InputsConfig

@typing.final
class Inputs(google.protobuf.message.Message):
    """Inputs is used to retrieve the existing inputs to a studio."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    CREATED_AT_FIELD_NUMBER: builtins.int
    CREATED_BY_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_AT_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_BY_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___InputsKey:
        """key uniquely identifies the set of inputs for the studio (at some path)."""

    @property
    def created_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """created_at is the time at which the inputs were first set."""

    @property
    def created_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """created_by is the name of the user that first set the inputs."""

    @property
    def last_modified_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """last_modified_at is the time at which the inputs were last modified."""

    @property
    def last_modified_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """last_modified_by is the name of the user that last modified the inputs."""

    @property
    def inputs(self) -> google.protobuf.wrappers_pb2.StringValue:
        """inputs is the value of the input field at the path as a JSON string.

        NOTE: For `GetAll` and `Subscribe`, if the JSON is too large, it will
        be split across multiple messages such that each is less than the Resource
        API message size limit (1MB).
        """

    def __init__(
        self,
        *,
        key: global___InputsKey | None = ...,
        created_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        created_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        last_modified_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        last_modified_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        inputs: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["created_at", b"created_at", "created_by", b"created_by", "inputs", b"inputs", "key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["created_at", b"created_at", "created_by", b"created_by", "inputs", b"inputs", "key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by"]) -> None: ...

global___Inputs = Inputs

@typing.final
class Template(google.protobuf.message.Message):
    """Template defines a template for a studio."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    BODY_FIELD_NUMBER: builtins.int
    type: global___TemplateType.ValueType
    """type specifies the language that this template uses."""
    @property
    def body(self) -> google.protobuf.wrappers_pb2.StringValue:
        """body contains the actual source code of the template."""

    def __init__(
        self,
        *,
        type: global___TemplateType.ValueType = ...,
        body: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["body", b"body"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["body", b"body", "type", b"type"]) -> None: ...

global___Template = Template

@typing.final
class BooleanInputFieldProps(google.protobuf.message.Message):
    """BooleanInputFieldProps defines the set of properties for a single
    boolean field in a studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    @property
    def default_value(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """default_value is the default value of the boolean."""

    def __init__(
        self,
        *,
        default_value: google.protobuf.wrappers_pb2.BoolValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["default_value", b"default_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value"]) -> None: ...

global___BooleanInputFieldProps = BooleanInputFieldProps

@typing.final
class IntegerInputFieldProps(google.protobuf.message.Message):
    """IntegerInputFieldProps defines the set of properties for a single
    integer field in a studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    STATIC_OPTIONS_FIELD_NUMBER: builtins.int
    RANGE_FIELD_NUMBER: builtins.int
    DYNAMIC_OPTIONS_FIELD_NUMBER: builtins.int
    EXTRA_VALUES_ALLOWED_FIELD_NUMBER: builtins.int
    @property
    def default_value(self) -> google.protobuf.wrappers_pb2.Int64Value:
        """default_value is the default value of the integer."""

    @property
    def static_options(self) -> fmp.wrappers_pb2.RepeatedInt64:
        """static_options defines the set of possible values for the integer."""

    @property
    def range(self) -> google.protobuf.wrappers_pb2.StringValue:
        """range imposes a range (inclusive) on the value of the integer.
        This should be of the form `"<min>..<max>"`. E.g., `"-10..10"`
        means the integer can be anything in between and including `-10`
        and `10`.
        """

    @property
    def dynamic_options(self) -> fmp.wrappers_pb2.RepeatedString:
        """dynamic_options defines the set of possible values for the integer
        based on the possible values for other integers in the schema.
        Each field should be referenced by a JSON object of the form
        `{ "fieldId": <field_id> }`.

        E.g,
        ```
        [
          { "fieldId": "vlanFieldID" },
          { "fieldId": "vniFieldID" }
        ]
        ```
        Here, the possible values for the integers identified by
        `"vlanFieldID"` and `"vniFieldID"` are used as the possible
        values for this integer.
        """

    @property
    def extra_values_allowed(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """extra_values_allowed allows adding values to the field in
        addition to what's allowed by static_options/dynamic_options.
        """

    def __init__(
        self,
        *,
        default_value: google.protobuf.wrappers_pb2.Int64Value | None = ...,
        static_options: fmp.wrappers_pb2.RepeatedInt64 | None = ...,
        range: google.protobuf.wrappers_pb2.StringValue | None = ...,
        dynamic_options: fmp.wrappers_pb2.RepeatedString | None = ...,
        extra_values_allowed: google.protobuf.wrappers_pb2.BoolValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["default_value", b"default_value", "dynamic_options", b"dynamic_options", "extra_values_allowed", b"extra_values_allowed", "range", b"range", "static_options", b"static_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "dynamic_options", b"dynamic_options", "extra_values_allowed", b"extra_values_allowed", "range", b"range", "static_options", b"static_options"]) -> None: ...

global___IntegerInputFieldProps = IntegerInputFieldProps

@typing.final
class FloatInputFieldProps(google.protobuf.message.Message):
    """FloatInputFieldProps defines the set of properties for a single
    float field in a studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    STATIC_OPTIONS_FIELD_NUMBER: builtins.int
    DYNAMIC_OPTIONS_FIELD_NUMBER: builtins.int
    EXTRA_VALUES_ALLOWED_FIELD_NUMBER: builtins.int
    @property
    def default_value(self) -> google.protobuf.wrappers_pb2.FloatValue:
        """default_value is the default value of the float."""

    @property
    def static_options(self) -> fmp.wrappers_pb2.RepeatedFloat:
        """static_options defines the set of possible values for the float."""

    @property
    def dynamic_options(self) -> fmp.wrappers_pb2.RepeatedString:
        """dynamic_options defines the set of possible values for the float
        based on the possible values for other floats in the schema.
        Each field should be referenced by a JSON object of the form
        `{ fieldId: field_id }`.

        E.g,
        [
          `{ fieldId: floatField1ID }`,
          `{ fieldId: floatField2ID }`
        ]
        Here, the possible values for the floats identified by
        `floatField1ID` and `floatField2ID` are used as the
        possible values for this float.
        """

    @property
    def extra_values_allowed(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """extra_values_allowed allows adding values to the field in
        addition to what's allowed by static_options/dynamic_options.
        """

    def __init__(
        self,
        *,
        default_value: google.protobuf.wrappers_pb2.FloatValue | None = ...,
        static_options: fmp.wrappers_pb2.RepeatedFloat | None = ...,
        dynamic_options: fmp.wrappers_pb2.RepeatedString | None = ...,
        extra_values_allowed: google.protobuf.wrappers_pb2.BoolValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["default_value", b"default_value", "dynamic_options", b"dynamic_options", "extra_values_allowed", b"extra_values_allowed", "static_options", b"static_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "dynamic_options", b"dynamic_options", "extra_values_allowed", b"extra_values_allowed", "static_options", b"static_options"]) -> None: ...

global___FloatInputFieldProps = FloatInputFieldProps

@typing.final
class StringInputFieldProps(google.protobuf.message.Message):
    """StringInputFieldProps defines the set of properties for a single
    string field in a studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    STATIC_OPTIONS_FIELD_NUMBER: builtins.int
    DYNAMIC_OPTIONS_FIELD_NUMBER: builtins.int
    LENGTH_FIELD_NUMBER: builtins.int
    PATTERN_FIELD_NUMBER: builtins.int
    FORMAT_FIELD_NUMBER: builtins.int
    IS_SECRET_FIELD_NUMBER: builtins.int
    EXTRA_VALUES_ALLOWED_FIELD_NUMBER: builtins.int
    @property
    def default_value(self) -> google.protobuf.wrappers_pb2.StringValue:
        """default_value is the default value of the string."""

    @property
    def static_options(self) -> fmp.wrappers_pb2.RepeatedString:
        """static_options defines the set of possible values for the string."""

    @property
    def dynamic_options(self) -> fmp.wrappers_pb2.RepeatedString:
        """dynamic_options defines the set of possible values for the string
        based on the possible values for other strings in the schema.
        Each field should be referenced by a JSON object of the form
        `{ "fieldId": <field_id> }`.

        E.g,
        ```
        [
          { "fieldId": "deviceFieldID" },
          { "fieldId": "ipFieldID" }
        ]
        ```
        Here, the possible values for the strings identified by
        `"deviceFieldID"` and `"ipFieldID"` are used as the possible
        values for this string.
        """

    @property
    def length(self) -> google.protobuf.wrappers_pb2.StringValue:
        """length imposes a length range (inclusive) on the value of the
        string. The should be of the form `"<min>..<max>"`. E.g.,
        `"3..7"` means the value of the string can be three to seven
        characters long.
        """

    @property
    def pattern(self) -> google.protobuf.wrappers_pb2.StringValue:
        """pattern imposes a regular expression matching constraint on
        the value of the string. This should be a Google RE2-compliant
        regular expression (https://github.com/google/re2/wiki/Syntax).
        """

    @property
    def format(self) -> google.protobuf.wrappers_pb2.StringValue:
        """format imposes a well-known format on the value of the string.
        The supported formats are:

        * `"ip"`: an IPv4 or IPv6 address
        * `"ipv4"`: an IPv4 address
        * `"ipv6"`: an IPv6 address
        * `"mac"`: a MAC address
        * `"cidr"`: an IPv4 or IPv6 address in CIDR notation (e.g. 10.1.1.1/24, 2001:db8:a0b::1/32)
        * `"cidrv4"`: an IPv4 address in CIDR notation (e.g. 10.1.1.1/24)
        * `"cidrv6"`: an IPv6 address in CIDR notation (e.g. 2001:db8:a0b::1/32)
        * `"url"`: a URL (e.g., http://www.google.com)
        """

    @property
    def is_secret(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """is_secret specifies whether the string is a secret and its
        value should be masked. E.g., if this is set to `true` and
        the value of the string is `"secret-value-1"`, it will be
        masked as `"**********"`.
        """

    @property
    def extra_values_allowed(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """extra_values_allowed allows adding values to the field in
        addition to what's allowed by static_options/dynamic_options.
        """

    def __init__(
        self,
        *,
        default_value: google.protobuf.wrappers_pb2.StringValue | None = ...,
        static_options: fmp.wrappers_pb2.RepeatedString | None = ...,
        dynamic_options: fmp.wrappers_pb2.RepeatedString | None = ...,
        length: google.protobuf.wrappers_pb2.StringValue | None = ...,
        pattern: google.protobuf.wrappers_pb2.StringValue | None = ...,
        format: google.protobuf.wrappers_pb2.StringValue | None = ...,
        is_secret: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        extra_values_allowed: google.protobuf.wrappers_pb2.BoolValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["default_value", b"default_value", "dynamic_options", b"dynamic_options", "extra_values_allowed", b"extra_values_allowed", "format", b"format", "is_secret", b"is_secret", "length", b"length", "pattern", b"pattern", "static_options", b"static_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "dynamic_options", b"dynamic_options", "extra_values_allowed", b"extra_values_allowed", "format", b"format", "is_secret", b"is_secret", "length", b"length", "pattern", b"pattern", "static_options", b"static_options"]) -> None: ...

global___StringInputFieldProps = StringInputFieldProps

@typing.final
class GroupInputFieldProps(google.protobuf.message.Message):
    """GroupInputFieldProps defines the set of properties for a single
    group field in a studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MEMBERS_FIELD_NUMBER: builtins.int
    @property
    def members(self) -> fmp.wrappers_pb2.RepeatedString:
        """members (required) identifies the member fields of the group
        as defined in the schema.
        """

    def __init__(
        self,
        *,
        members: fmp.wrappers_pb2.RepeatedString | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["members", b"members"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["members", b"members"]) -> None: ...

global___GroupInputFieldProps = GroupInputFieldProps

@typing.final
class CollectionInputFieldProps(google.protobuf.message.Message):
    """CollectionInputFieldProps defines the set of properties for a single
    collection field in a studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BASE_FIELD_ID_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    @property
    def base_field_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """base_field_id (required) identifies the field in the schema
        that should be used as the type for each element in the
        collection.
        """

    @property
    def key(self) -> google.protobuf.wrappers_pb2.StringValue:
        """key can be used when `base_field_id` references a group field,
        and it identifies the field in that group that should be used
        as the key for each element in the collection. This is used
        for display purposes only.
        """

    def __init__(
        self,
        *,
        base_field_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        key: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["base_field_id", b"base_field_id", "key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["base_field_id", b"base_field_id", "key", b"key"]) -> None: ...

global___CollectionInputFieldProps = CollectionInputFieldProps

@typing.final
class ResolverInputFieldProps(google.protobuf.message.Message):
    """ResolverInputFieldProps defines the set of properties for a single
    resolver field in a studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BASE_FIELD_ID_FIELD_NUMBER: builtins.int
    DISPLAY_MODE_FIELD_NUMBER: builtins.int
    INPUT_MODE_FIELD_NUMBER: builtins.int
    INPUT_TAG_LABEL_FIELD_NUMBER: builtins.int
    TAG_FILTER_QUERY_FIELD_NUMBER: builtins.int
    display_mode: global___ResolverFieldDisplayMode.ValueType
    """display_mode (required) is the display mode of the resolver."""
    input_mode: global___ResolverFieldInputMode.ValueType
    """input_mode (required) is the input mode of the resolver."""
    @property
    def base_field_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """base_field_id (required) identifies the field in the schema
        to which the resolver query maps.
        """

    @property
    def input_tag_label(self) -> google.protobuf.wrappers_pb2.StringValue:
        """input_tag_label can be used when `input_mode` is one of
        `RESOLVER_FIELD_INPUT_MODE_SINGLE_*_TAG` and it specifies
        the tag label must be used in the resolver query.
        """

    @property
    def tag_filter_query(self) -> google.protobuf.wrappers_pb2.StringValue:
        """tag_filter_query limits the set of elements that the
        resolver query can return. E.g., `"device:D1,D2"` will
        constrain results to the devices D1 and D2.
        """

    def __init__(
        self,
        *,
        base_field_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        display_mode: global___ResolverFieldDisplayMode.ValueType = ...,
        input_mode: global___ResolverFieldInputMode.ValueType = ...,
        input_tag_label: google.protobuf.wrappers_pb2.StringValue | None = ...,
        tag_filter_query: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["base_field_id", b"base_field_id", "input_tag_label", b"input_tag_label", "tag_filter_query", b"tag_filter_query"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["base_field_id", b"base_field_id", "display_mode", b"display_mode", "input_mode", b"input_mode", "input_tag_label", b"input_tag_label", "tag_filter_query", b"tag_filter_query"]) -> None: ...

global___ResolverInputFieldProps = ResolverInputFieldProps

@typing.final
class TagMatcherInputFieldProps(google.protobuf.message.Message):
    """TagMatcherInputFieldProps defines the set of properties for a single
    selector field in a studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAG_MATCHER_MODE_FIELD_NUMBER: builtins.int
    TAG_MATCHER_LABEL_FIELD_NUMBER: builtins.int
    TAG_FILTER_QUERY_FIELD_NUMBER: builtins.int
    RESOLVER_FILTERING_ALLOWED_FIELD_NUMBER: builtins.int
    tag_matcher_mode: global___TagMatcherFieldMode.ValueType
    """tag_matcher_mode (required) is the tag mode of the matcher."""
    @property
    def tag_matcher_label(self) -> google.protobuf.wrappers_pb2.StringValue:
        """tag_matcher_label can be used when `tag_matcher_mode` is one of
        `TAG_MATCHER_FIELD_MODE_SINGLE_*_TAG` and it specifies
        the tag label which must be used in the match query.
        """

    @property
    def tag_filter_query(self) -> google.protobuf.wrappers_pb2.StringValue:
        """tag_filter_query limits the set of devices that the
        match query can return. E.g., `"device:D1,D2"` will
        constrain results to the devices D1 and D2.
        """

    @property
    def resolver_filtering_allowed(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """resolver_filtering_allowed indicates whether results of the
        match query be filtered based on what any parent resolvers
        allow. This is `true` by default.
        """

    def __init__(
        self,
        *,
        tag_matcher_mode: global___TagMatcherFieldMode.ValueType = ...,
        tag_matcher_label: google.protobuf.wrappers_pb2.StringValue | None = ...,
        tag_filter_query: google.protobuf.wrappers_pb2.StringValue | None = ...,
        resolver_filtering_allowed: google.protobuf.wrappers_pb2.BoolValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["resolver_filtering_allowed", b"resolver_filtering_allowed", "tag_filter_query", b"tag_filter_query", "tag_matcher_label", b"tag_matcher_label"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["resolver_filtering_allowed", b"resolver_filtering_allowed", "tag_filter_query", b"tag_filter_query", "tag_matcher_label", b"tag_matcher_label", "tag_matcher_mode", b"tag_matcher_mode"]) -> None: ...

global___TagMatcherInputFieldProps = TagMatcherInputFieldProps

@typing.final
class InputField(google.protobuf.message.Message):
    """InputField defines the set of properties for a single field in a
    studio input schema.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    REQUIRED_FIELD_NUMBER: builtins.int
    BOOLEAN_PROPS_FIELD_NUMBER: builtins.int
    INTEGER_PROPS_FIELD_NUMBER: builtins.int
    FLOAT_PROPS_FIELD_NUMBER: builtins.int
    STRING_PROPS_FIELD_NUMBER: builtins.int
    GROUP_PROPS_FIELD_NUMBER: builtins.int
    COLLECTION_PROPS_FIELD_NUMBER: builtins.int
    RESOLVER_PROPS_FIELD_NUMBER: builtins.int
    AUTO_FILL_ACTION_ID_FIELD_NUMBER: builtins.int
    TAG_MATCHER_PROPS_FIELD_NUMBER: builtins.int
    type: global___InputFieldType.ValueType
    """type (required) specifies the type for the field."""
    @property
    def id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """id (required) uniquely identifies the field within the schema."""

    @property
    def name(self) -> google.protobuf.wrappers_pb2.StringValue:
        """name (required) is the variable name by which the field can be
        referenced in the template for the studio.
        """

    @property
    def label(self) -> google.protobuf.wrappers_pb2.StringValue:
        """label (required) is the label of the field as displayed on the UI."""

    @property
    def description(self) -> google.protobuf.wrappers_pb2.StringValue:
        """description is a short description of the field."""

    @property
    def required(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """required indicates whether the field always requires a value. This
        is `false` by default.
        """

    @property
    def boolean_props(self) -> global___BooleanInputFieldProps:
        """boolean_props defines properties for the field if it is of type
        `INPUT_FIELD_TYPE_BOOLEAN`.
        """

    @property
    def integer_props(self) -> global___IntegerInputFieldProps:
        """integer_props defines properties for the field if it is of type
        `INPUT_FIELD_TYPE_INTEGER`.
        """

    @property
    def float_props(self) -> global___FloatInputFieldProps:
        """float_props defines properties for the field if it is of type
        `INPUT_FIELD_TYPE_FLOAT`.
        """

    @property
    def string_props(self) -> global___StringInputFieldProps:
        """string_props defines properties for the field if it is of type
        `INPUT_FIELD_TYPE_STRING`.
        """

    @property
    def group_props(self) -> global___GroupInputFieldProps:
        """group_props defines properties for the field if it is of type
        `INPUT_FIELD_TYPE_GROUP`.
        """

    @property
    def collection_props(self) -> global___CollectionInputFieldProps:
        """collection_props defines properties for the field if it is of type
        `INPUT_FIELD_TYPE_COLLECTION`.
        """

    @property
    def resolver_props(self) -> global___ResolverInputFieldProps:
        """resolver_props defines properties for the field if it is of type
        `INPUT_FIELD_TYPE_RESOLVER`.
        """

    @property
    def auto_fill_action_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """auto_fill_action_id identifies the autofill action that can be
        used to automatically populate the value of this field on the
        UI.
        """

    @property
    def tag_matcher_props(self) -> global___TagMatcherInputFieldProps:
        """tag_matcher_props defines properties for the field if it is of type
        `INPUT_FIELD_TYPE_TAG_MATCHER`.
        """

    def __init__(
        self,
        *,
        id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        type: global___InputFieldType.ValueType = ...,
        name: google.protobuf.wrappers_pb2.StringValue | None = ...,
        label: google.protobuf.wrappers_pb2.StringValue | None = ...,
        description: google.protobuf.wrappers_pb2.StringValue | None = ...,
        required: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        boolean_props: global___BooleanInputFieldProps | None = ...,
        integer_props: global___IntegerInputFieldProps | None = ...,
        float_props: global___FloatInputFieldProps | None = ...,
        string_props: global___StringInputFieldProps | None = ...,
        group_props: global___GroupInputFieldProps | None = ...,
        collection_props: global___CollectionInputFieldProps | None = ...,
        resolver_props: global___ResolverInputFieldProps | None = ...,
        auto_fill_action_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        tag_matcher_props: global___TagMatcherInputFieldProps | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["auto_fill_action_id", b"auto_fill_action_id", "boolean_props", b"boolean_props", "collection_props", b"collection_props", "description", b"description", "float_props", b"float_props", "group_props", b"group_props", "id", b"id", "integer_props", b"integer_props", "label", b"label", "name", b"name", "required", b"required", "resolver_props", b"resolver_props", "string_props", b"string_props", "tag_matcher_props", b"tag_matcher_props"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["auto_fill_action_id", b"auto_fill_action_id", "boolean_props", b"boolean_props", "collection_props", b"collection_props", "description", b"description", "float_props", b"float_props", "group_props", b"group_props", "id", b"id", "integer_props", b"integer_props", "label", b"label", "name", b"name", "required", b"required", "resolver_props", b"resolver_props", "string_props", b"string_props", "tag_matcher_props", b"tag_matcher_props", "type", b"type"]) -> None: ...

global___InputField = InputField

@typing.final
class InputFields(google.protobuf.message.Message):
    """InputFields is a collection of `InputField`."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ValuesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___InputField: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___InputField | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___InputField]:
        """values (required) is a map from input field ID to `InputField`."""

    def __init__(
        self,
        *,
        values: collections.abc.Mapping[builtins.str, global___InputField] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

global___InputFields = InputFields

@typing.final
class Layout(google.protobuf.message.Message):
    """Layout specifies the display properties for input fields. This
    is intended for UI usage only.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUE_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> google.protobuf.wrappers_pb2.StringValue:
        """value is a JSON object containing the layout config."""

    def __init__(
        self,
        *,
        value: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["value", b"value"]) -> None: ...

global___Layout = Layout

@typing.final
class InputSchema(google.protobuf.message.Message):
    """InputSchema defines an input schema for a studio, which determines
    the values that can be input into the studio.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FIELDS_FIELD_NUMBER: builtins.int
    LAYOUT_FIELD_NUMBER: builtins.int
    @property
    def fields(self) -> global___InputFields:
        """fields (required) are the set of fields that make up the schema."""

    @property
    def layout(self) -> global___Layout:
        """layout (UI only) defines the display properties for `fields`."""

    def __init__(
        self,
        *,
        fields: global___InputFields | None = ...,
        layout: global___Layout | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["fields", b"fields", "layout", b"layout"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["fields", b"fields", "layout", b"layout"]) -> None: ...

global___InputSchema = InputSchema

@typing.final
class SecretInput(google.protobuf.message.Message):
    """SecretInput can be used to retrieve the unmasked value of
    a secret in a studio.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    PLAIN_TEXT_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___InputsKey:
        """key identifies the secret in the studio inputs."""

    @property
    def plain_text(self) -> google.protobuf.wrappers_pb2.StringValue:
        """plain_text is the unmasked value of the secret."""

    def __init__(
        self,
        *,
        key: global___InputsKey | None = ...,
        plain_text: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key", "plain_text", b"plain_text"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "plain_text", b"plain_text"]) -> None: ...

global___SecretInput = SecretInput

@typing.final
class AutofillActionKey(google.protobuf.message.Message):
    """AutofillActionKey identifies an autofill action."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STUDIO_ID_FIELD_NUMBER: builtins.int
    WORKSPACE_ID_FIELD_NUMBER: builtins.int
    INPUT_FIELD_ID_FIELD_NUMBER: builtins.int
    @property
    def studio_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """studio_id uniquely identifies the studio in the workspace indicated
        by `workspace_id`.
        """

    @property
    def workspace_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """workspace_id uniquely identifies the workspace in which the studio resides."""

    @property
    def input_field_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """input_field_id uniquely identifies the input field within the schema associated
        with the action indicated by `action_id`.
        """

    def __init__(
        self,
        *,
        studio_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        workspace_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        input_field_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["input_field_id", b"input_field_id", "studio_id", b"studio_id", "workspace_id", b"workspace_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["input_field_id", b"input_field_id", "studio_id", b"studio_id", "workspace_id", b"workspace_id"]) -> None: ...

global___AutofillActionKey = AutofillActionKey

@typing.final
class AutofillActionConfig(google.protobuf.message.Message):
    """AutofillActionConfig contains configuration information for an autofill action."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    REMOVE_FIELD_NUMBER: builtins.int
    ACTION_ID_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    ARGUMENT_PROVIDERS_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___AutofillActionKey:
        """key uniquely identifies the action-to-studio association."""

    @property
    def remove(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """remove indicates whether to remove (`true`) or add (`false`, unset)
        the autofill action configuration identified by the key if the encompassing
        workspace merges. Other data fields are not allowed if this field is set to true.
        """

    @property
    def action_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """action_id uniquely identifies the autofill action associated with the input field."""

    @property
    def description(self) -> google.protobuf.wrappers_pb2.StringValue:
        """description is an optional field to describe the autofill action that will be
        displayed in a tooltip in the UI when the user hovers over the button to run
        the autofill action.
        """

    @property
    def argument_providers(self) -> global___AutofillArgumentProviders:
        """argument_providers is an optional field that specifies how dynamic arguments are
        to be provided to the autofill action when executed. If an argument is omitted
        from the provider map, it will not be defined in the arguments passed to the scripts.
        If the entire field is omitted, no additional argument values will be passed to the
        script beyond any statically defined arguments and the system-provided arguments
        which are always set in an autofill action execution context (namely InputPath,
        StudioId, and WorkspaceId).
        """

    def __init__(
        self,
        *,
        key: global___AutofillActionKey | None = ...,
        remove: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        action_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        description: google.protobuf.wrappers_pb2.StringValue | None = ...,
        argument_providers: global___AutofillArgumentProviders | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["action_id", b"action_id", "argument_providers", b"argument_providers", "description", b"description", "key", b"key", "remove", b"remove"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["action_id", b"action_id", "argument_providers", b"argument_providers", "description", b"description", "key", b"key", "remove", b"remove"]) -> None: ...

global___AutofillActionConfig = AutofillActionConfig

@typing.final
class AutofillAction(google.protobuf.message.Message):
    """AutofillAction can be used to retrieve additional metadata about an autofill action."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    CREATED_AT_FIELD_NUMBER: builtins.int
    CREATED_BY_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_AT_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_BY_FIELD_NUMBER: builtins.int
    ACTION_ID_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    ARGUMENT_PROVIDERS_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> global___AutofillActionKey:
        """key uniquely identifies the action-to-studio association."""

    @property
    def created_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """created_at is the time at which the inputs were first set."""

    @property
    def created_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """created_by is the name of the user that first set the inputs."""

    @property
    def last_modified_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """last_modified_at is the time at which the inputs were last modified."""

    @property
    def last_modified_by(self) -> google.protobuf.wrappers_pb2.StringValue:
        """last_modified_by is the name of the user that last modified the inputs."""

    @property
    def action_id(self) -> google.protobuf.wrappers_pb2.StringValue:
        """action_id uniquely identifies the autofill action associated with the input field."""

    @property
    def description(self) -> google.protobuf.wrappers_pb2.StringValue:
        """description is an optional field to describe the autofill action that will be
        displayed in a tooltip in the UI when the user hovers over the button to run
        the autofill action.
        """

    @property
    def argument_providers(self) -> global___AutofillArgumentProviders:
        """argument_providers is an optional field that specifies how dynamic arguments are
        to be provided to the autofill action when executed. If an argument is omitted
        from the provider map, it will not be defined in the arguments passed to the scripts.
        If the entire field is omitted, no additional argument values will be passed to the
        script beyond any statically defined arguments and the system-provided arguments
        which are always set in an autofill action execution context (namely InputPath,
        StudioID, and WorkspaceID).
        """

    def __init__(
        self,
        *,
        key: global___AutofillActionKey | None = ...,
        created_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        created_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        last_modified_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        last_modified_by: google.protobuf.wrappers_pb2.StringValue | None = ...,
        action_id: google.protobuf.wrappers_pb2.StringValue | None = ...,
        description: google.protobuf.wrappers_pb2.StringValue | None = ...,
        argument_providers: global___AutofillArgumentProviders | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["action_id", b"action_id", "argument_providers", b"argument_providers", "created_at", b"created_at", "created_by", b"created_by", "description", b"description", "key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["action_id", b"action_id", "argument_providers", b"argument_providers", "created_at", b"created_at", "created_by", b"created_by", "description", b"description", "key", b"key", "last_modified_at", b"last_modified_at", "last_modified_by", b"last_modified_by"]) -> None: ...

global___AutofillAction = AutofillAction

@typing.final
class AutofillArgumentProviders(google.protobuf.message.Message):
    """AutofillArgumentProviders is a map of dynamic argument name to argument provider information."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ValuesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___AutofillArgumentProvider: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___AutofillArgumentProvider | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___AutofillArgumentProvider]:
        """values is a map of dynamic argument name to argument provider information."""

    def __init__(
        self,
        *,
        values: collections.abc.Mapping[builtins.str, global___AutofillArgumentProvider] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

global___AutofillArgumentProviders = AutofillArgumentProviders

@typing.final
class AutofillArgumentProvider(google.protobuf.message.Message):
    """AutofillArgumentProvider describes a particular dynamic argument's type
    and value (if applicable).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    type: global___AutofillProviderType.ValueType
    """type is the type of argument provider, describing how it is to be
    handled when the associated action is called.
    """
    @property
    def value(self) -> google.protobuf.wrappers_pb2.StringValue:
        """value is the value of the argument, if provided.
        When the provider type is PROVIDER_TYPE_USER_SPECIFIED, the field may be nil. If non-nil,
        the field contains a default value for the user input.
        When the provider type is PROVIDER_TYPE_PREDEFINED, the field contains the predefined
        value.
        When the provider type is PROVIDER_TYPE_LINKED, the field contains the linked input
        field's ID.
        """

    def __init__(
        self,
        *,
        type: global___AutofillProviderType.ValueType = ...,
        value: google.protobuf.wrappers_pb2.StringValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["type", b"type", "value", b"value"]) -> None: ...

global___AutofillArgumentProvider = AutofillArgumentProvider
