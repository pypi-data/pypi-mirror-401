# Copyright (c) 2026 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the COPYING file.

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/studio_topology.v1/services.gen.proto, arista/studio_topology.v1/studio_topology.proto
# plugin: python-aristaproto
# This file has been @generated

__all__ = (
    "Element",
    "Operation",
    "UpdateStatus",
    "DeviceStatus",
    "DecommissionStatus",
    "ReplaceStatus",
    "DeviceInfo",
    "InterfaceInfo",
    "InterfaceInfos",
    "DeviceKey",
    "DeviceInputConfig",
    "InterfaceInputKey",
    "InterfaceInputConfig",
    "DeviceState",
    "UpdateKey",
    "UpdateConfig",
    "Update",
    "UpdateSyncConfig",
    "RevertConfig",
    "DecommissionConfig",
    "Decommission",
    "ReplaceConfig",
    "Replace",
    "MetaResponse",
    "DecommissionRequest",
    "DecommissionResponse",
    "DecommissionSomeRequest",
    "DecommissionSomeResponse",
    "DecommissionStreamRequest",
    "DecommissionStreamResponse",
    "DecommissionBatchedStreamRequest",
    "DecommissionBatchedStreamResponse",
    "DecommissionConfigRequest",
    "DecommissionConfigResponse",
    "DecommissionConfigSomeRequest",
    "DecommissionConfigSomeResponse",
    "DecommissionConfigStreamRequest",
    "DecommissionConfigStreamResponse",
    "DecommissionConfigBatchedStreamRequest",
    "DecommissionConfigBatchedStreamResponse",
    "DecommissionConfigSetRequest",
    "DecommissionConfigSetResponse",
    "DecommissionConfigSetSomeRequest",
    "DecommissionConfigSetSomeResponse",
    "DecommissionConfigDeleteRequest",
    "DecommissionConfigDeleteResponse",
    "DecommissionConfigDeleteSomeRequest",
    "DecommissionConfigDeleteSomeResponse",
    "DecommissionConfigDeleteAllRequest",
    "DecommissionConfigDeleteAllResponse",
    "DeviceInputConfigRequest",
    "DeviceInputConfigResponse",
    "DeviceInputConfigSomeRequest",
    "DeviceInputConfigSomeResponse",
    "DeviceInputConfigStreamRequest",
    "DeviceInputConfigStreamResponse",
    "DeviceInputConfigBatchedStreamRequest",
    "DeviceInputConfigBatchedStreamResponse",
    "DeviceInputConfigSetRequest",
    "DeviceInputConfigSetResponse",
    "DeviceInputConfigSetSomeRequest",
    "DeviceInputConfigSetSomeResponse",
    "DeviceInputConfigDeleteRequest",
    "DeviceInputConfigDeleteResponse",
    "DeviceInputConfigDeleteSomeRequest",
    "DeviceInputConfigDeleteSomeResponse",
    "DeviceInputConfigDeleteAllRequest",
    "DeviceInputConfigDeleteAllResponse",
    "DeviceStateRequest",
    "DeviceStateResponse",
    "DeviceStateSomeRequest",
    "DeviceStateSomeResponse",
    "DeviceStateStreamRequest",
    "DeviceStateStreamResponse",
    "DeviceStateBatchedStreamRequest",
    "DeviceStateBatchedStreamResponse",
    "InterfaceInputConfigRequest",
    "InterfaceInputConfigResponse",
    "InterfaceInputConfigSomeRequest",
    "InterfaceInputConfigSomeResponse",
    "InterfaceInputConfigStreamRequest",
    "InterfaceInputConfigStreamResponse",
    "InterfaceInputConfigBatchedStreamRequest",
    "InterfaceInputConfigBatchedStreamResponse",
    "InterfaceInputConfigSetRequest",
    "InterfaceInputConfigSetResponse",
    "InterfaceInputConfigSetSomeRequest",
    "InterfaceInputConfigSetSomeResponse",
    "InterfaceInputConfigDeleteRequest",
    "InterfaceInputConfigDeleteResponse",
    "InterfaceInputConfigDeleteSomeRequest",
    "InterfaceInputConfigDeleteSomeResponse",
    "InterfaceInputConfigDeleteAllRequest",
    "InterfaceInputConfigDeleteAllResponse",
    "ReplaceRequest",
    "ReplaceResponse",
    "ReplaceSomeRequest",
    "ReplaceSomeResponse",
    "ReplaceStreamRequest",
    "ReplaceStreamResponse",
    "ReplaceBatchedStreamRequest",
    "ReplaceBatchedStreamResponse",
    "ReplaceConfigRequest",
    "ReplaceConfigResponse",
    "ReplaceConfigSomeRequest",
    "ReplaceConfigSomeResponse",
    "ReplaceConfigStreamRequest",
    "ReplaceConfigStreamResponse",
    "ReplaceConfigBatchedStreamRequest",
    "ReplaceConfigBatchedStreamResponse",
    "ReplaceConfigSetRequest",
    "ReplaceConfigSetResponse",
    "ReplaceConfigSetSomeRequest",
    "ReplaceConfigSetSomeResponse",
    "ReplaceConfigDeleteRequest",
    "ReplaceConfigDeleteResponse",
    "ReplaceConfigDeleteSomeRequest",
    "ReplaceConfigDeleteSomeResponse",
    "ReplaceConfigDeleteAllRequest",
    "ReplaceConfigDeleteAllResponse",
    "RevertConfigRequest",
    "RevertConfigResponse",
    "RevertConfigSomeRequest",
    "RevertConfigSomeResponse",
    "RevertConfigStreamRequest",
    "RevertConfigStreamResponse",
    "RevertConfigBatchedStreamRequest",
    "RevertConfigBatchedStreamResponse",
    "RevertConfigSetRequest",
    "RevertConfigSetResponse",
    "RevertConfigSetSomeRequest",
    "RevertConfigSetSomeResponse",
    "RevertConfigDeleteRequest",
    "RevertConfigDeleteResponse",
    "RevertConfigDeleteSomeRequest",
    "RevertConfigDeleteSomeResponse",
    "RevertConfigDeleteAllRequest",
    "RevertConfigDeleteAllResponse",
    "UpdateRequest",
    "UpdateResponse",
    "UpdateSomeRequest",
    "UpdateSomeResponse",
    "UpdateStreamRequest",
    "UpdateStreamResponse",
    "UpdateBatchedStreamRequest",
    "UpdateBatchedStreamResponse",
    "UpdateConfigRequest",
    "UpdateConfigResponse",
    "UpdateConfigSomeRequest",
    "UpdateConfigSomeResponse",
    "UpdateConfigStreamRequest",
    "UpdateConfigStreamResponse",
    "UpdateConfigBatchedStreamRequest",
    "UpdateConfigBatchedStreamResponse",
    "UpdateConfigSetRequest",
    "UpdateConfigSetResponse",
    "UpdateConfigSetSomeRequest",
    "UpdateConfigSetSomeResponse",
    "UpdateConfigDeleteRequest",
    "UpdateConfigDeleteResponse",
    "UpdateConfigDeleteSomeRequest",
    "UpdateConfigDeleteSomeResponse",
    "UpdateConfigDeleteAllRequest",
    "UpdateConfigDeleteAllResponse",
    "UpdateSyncConfigRequest",
    "UpdateSyncConfigResponse",
    "UpdateSyncConfigSomeRequest",
    "UpdateSyncConfigSomeResponse",
    "UpdateSyncConfigStreamRequest",
    "UpdateSyncConfigStreamResponse",
    "UpdateSyncConfigBatchedStreamRequest",
    "UpdateSyncConfigBatchedStreamResponse",
    "UpdateSyncConfigSetRequest",
    "UpdateSyncConfigSetResponse",
    "UpdateSyncConfigSetSomeRequest",
    "UpdateSyncConfigSetSomeResponse",
    "UpdateSyncConfigDeleteRequest",
    "UpdateSyncConfigDeleteResponse",
    "UpdateSyncConfigDeleteSomeRequest",
    "UpdateSyncConfigDeleteSomeResponse",
    "UpdateSyncConfigDeleteAllRequest",
    "UpdateSyncConfigDeleteAllResponse",
    "DecommissionServiceStub",
    "DecommissionServiceBase",
    "DecommissionConfigServiceStub",
    "DecommissionConfigServiceBase",
    "DeviceInputConfigServiceStub",
    "DeviceInputConfigServiceBase",
    "DeviceStateServiceStub",
    "DeviceStateServiceBase",
    "InterfaceInputConfigServiceStub",
    "InterfaceInputConfigServiceBase",
    "ReplaceServiceStub",
    "ReplaceServiceBase",
    "ReplaceConfigServiceStub",
    "ReplaceConfigServiceBase",
    "RevertConfigServiceStub",
    "RevertConfigServiceBase",
    "UpdateServiceStub",
    "UpdateServiceBase",
    "UpdateConfigServiceStub",
    "UpdateConfigServiceBase",
    "UpdateSyncConfigServiceStub",
    "UpdateSyncConfigServiceBase",
)


from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import aristaproto
import grpclib
from aristaproto.grpc.grpclib_server import ServiceBase

if TYPE_CHECKING:
    import grpclib.server
    from aristaproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class Element(aristaproto.Enum):
    """Element defines the fundamental types of elements in topology."""

    UNSPECIFIED = 0
    """ELEMENT_UNSPECIFIED indicates an unspecified element type."""

    DEVICE = 1
    """ELEMENT_DEVICE indicates a device."""

    INTERFACE = 2
    """ELEMENT_INTERFACE indicates an interface."""

    CONNECTION = 3
    """ELEMENT_CONNECTION indicates a connection."""


class Operation(aristaproto.Enum):
    """
    Operation defines the operations that may be performed on the topology.
    """

    UNSPECIFIED = 0
    """OPERATION_UNSPECIFIED indicates an unspecified operation."""

    ADDED = 1
    """OPERATION_ADDED indicates addition of an Element."""

    MODIFIED = 2
    """OPERATION_MODIFIED indicates modification of an Element."""

    REMOVED = 3
    """OPERATION_REMOVED indicates removal of an Element."""


class UpdateStatus(aristaproto.Enum):
    """
    UpdateStatus defines the set of statuses that apply to individual topology updates.
    """

    UNSPECIFIED = 0
    """UPDATE_STATUS_UNSPECIFIED indicates an unspecified update status."""

    NEW = 1
    """UPDATE_STATUS_NEW indicates the update is new."""

    ACCEPTED = 2
    """UPDATE_STATUS_ACCEPTED indicates the update is accepted."""

    IGNORED = 3
    """UPDATE_STATUS_IGNORED indicates the update is ignored."""


class DeviceStatus(aristaproto.Enum):
    """DeviceStatus defines the set of statuses that apply to a device."""

    UNSPECIFIED = 0
    """DEVICE_STATUS_UNSPECIFIED is the default unspecified device status."""

    ACTIVE = 1
    """
    DEVICE_STATUS_ACTIVE indicates a device is streaming its telemetry data
    to CloudVision.
    """

    INACTIVE = 2
    """
    DEVICE_STATUS_INACTIVE indicates a device is not streaming its telemetry data
    to CloudVision.
    """

    EXPECTED = 3
    """
    DEVICE_STATUS_EXPECTED indicates a device has not yet streamed its telemetry
    data to CloudVision.
    """


class DecommissionStatus(aristaproto.Enum):
    """
    DecommissionStatus enumerates the status of decommissioning a device.
    """

    UNSPECIFIED = 0
    """
    DECOMMISSION_STATUS_UNSPECIFIED indicates that the device was decommissioned with
    an unspecified state.
    """

    SUCCESS = 1
    """
    DECOMMISSION_STATUS_SUCCESS indicates that the device was successfully decommissioned.
    """

    FAILURE = 2
    """
    DECOMMISSION_STATUS_FAILURE indicates an error with decommissioning the device.
    """


class ReplaceStatus(aristaproto.Enum):
    """ReplaceStatus enumerates the status of the device."""

    UNSPECIFIED = 0
    """
    REPLACE_STATUS_UNSPECIFIED indicates that the device was replaced with
    an unspecified state.
    """

    SUCCESS = 1
    """
    REPLACE_STATUS_SUCCESS indicates that the device was successfully replaced.
    """

    FAILURE = 2
    """REPLACE_STATUS_FAILURE indicates an error with replace."""


@dataclass(eq=False, repr=False)
class DeviceInfo(aristaproto.Message):
    """DeviceInfo contains device properties."""

    device_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """device_id identifies the device uniquely."""

    model_name: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """model_name indicates the model of the device."""

    mac_address: "___fmp__.MacAddress" = aristaproto.message_field(3)
    """mac_address indicates the MAC address of the device."""

    hostname: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """hostname indicates the hostname of the device."""

    match_any_device: Optional[bool] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_BOOL
    )
    """
    match_any_device is an indicator to match any online device with the device
    identified by the device_id field above. An online device is any EOS device
    which is streaming to CVP and has not been provisioned yet.
    This argument is used only if the device is an expected device and not relevant
    to other devices.
    For an expected device, the device_id fields holds an temporary UUID. Hence,
    the match has to occur based on the combination of expected_serial_numbers
    and match_any_device fields and not the device_id field.
    This field is mandatory for an expected device.
    If this field is true, expected_serial_numbers should be empty.
    If this field is false, expected_serial_numbers should be provided.
    """

    expected_serial_numbers: "___fmp__.RepeatedString" = aristaproto.message_field(6)
    """
    expected_serial_numbers indicates a list of possible serial numbers which can
    be expected for this device. The expected device entry specified by the device_id
    field above will be matched with only one of the serial numbers in this list.
    Should be populated only for an expected device and when match_any_device is set to false.
    """


@dataclass(eq=False, repr=False)
class InterfaceInfo(aristaproto.Message):
    """InterfaceInfo contains interface properties."""

    name: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """name is the name of an interface."""

    neighbor_device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    neighbor_device_id indicates the device ID of the neighbor to which
    this interface is connected.
    For an expected device, this would be a device_id (temporary UUID in case
    the neighbour is also an expected device) of a known device resource to the
    studios or lldp sysname in case of a non Arista device like third party
    external router.
    """

    neighbor_interface_name: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    neighbor_interface_name indicates the interface on the neighbor to which
    this interface is connected.
    For expected devices having the neighbour as a non Arista device, this field
    does not need to be populated.
    """

    non_provisioned: Optional[bool] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_BOOL
    )
    """
    non_provisioned indicates if the interface is connected to a non-provisioned device, ie, a
    device which is not part of the I&T studio and cannot be provisioned by CloudVision.
    """


@dataclass(eq=False, repr=False)
class InterfaceInfos(aristaproto.Message):
    """InterfaceInfos is a list of InterfaceInfo."""

    values: List["InterfaceInfo"] = aristaproto.message_field(1)
    """values is a list of InterfaceInfo."""


@dataclass(eq=False, repr=False)
class DeviceKey(aristaproto.Message):
    """DeviceKey uniquely identifies the device for a workspace."""

    workspace_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """workspace_id identifies the workspace uniquely."""

    device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """device_id identifies the device uniquely."""


@dataclass(eq=False, repr=False)
class DeviceInputConfig(aristaproto.Message):
    """DeviceInputConfig is the desired topology input for a device."""

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device ID for a given workspace."""

    device_info: "DeviceInfo" = aristaproto.message_field(2)
    """device_info contains device properties."""

    remove: Optional[bool] = aristaproto.message_field(3, wraps=aristaproto.TYPE_BOOL)
    """
    remove if set to true will remove the device from mainline
    post workspace merge.
    """

    is_expected_device: Optional[bool] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_BOOL
    )
    """is_expected_device specifies if this is an expected device."""


@dataclass(eq=False, repr=False)
class InterfaceInputKey(aristaproto.Message):
    """
    InterfaceInputKey is the set of inputs that uniquely identify
    the interface for a workspace.
    """

    workspace_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """workspace_id identifies the workspace uniquely."""

    device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """device_id identifies the device uniquely."""

    interface_id: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """interface_id along with device_id identifies the interface uniquely."""


@dataclass(eq=False, repr=False)
class InterfaceInputConfig(aristaproto.Message):
    """
    InterfaceInputConfig is the resource for manually adding
    an interface in I&T studios.
    """

    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """key uniquely identifies the interface for a given workspace."""

    interface_info: "InterfaceInfo" = aristaproto.message_field(2)
    """interface_info contains interface properties."""

    remove: Optional[bool] = aristaproto.message_field(3, wraps=aristaproto.TYPE_BOOL)
    """
    remove if set to true will remove the interface from mainline
    post workspace merge.
    """


@dataclass(eq=False, repr=False)
class DeviceState(aristaproto.Message):
    """
    DeviceState is the state of a device written by
    InterfaceInputConfig, DeviceInputConfig and
    UpdateConfig resources.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device for a given workspace."""

    device_info: "DeviceInfo" = aristaproto.message_field(2)
    """device_info contains device properties."""

    interface_infos: "InterfaceInfos" = aristaproto.message_field(3)
    """
    interface_infos contains interface properties of all the interfaces
    belonging to the device.
    """

    device_status: "DeviceStatus" = aristaproto.enum_field(4)
    """device_status contains the status of the device."""


@dataclass(eq=False, repr=False)
class UpdateKey(aristaproto.Message):
    """UpdateKey uniquely identifies a workspace topology update."""

    workspace_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """workspace_id identifies the workspace uniquely."""

    update_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """update_id identifies the update uniquely."""


@dataclass(eq=False, repr=False)
class UpdateConfig(aristaproto.Message):
    """UpdateConfig contains the acceptance status of an Update."""

    key: "UpdateKey" = aristaproto.message_field(1)
    """key uniquely identifies the update."""

    status: "UpdateStatus" = aristaproto.enum_field(2)
    """status indicates the status of the topology update."""

    remove: Optional[bool] = aristaproto.message_field(3, wraps=aristaproto.TYPE_BOOL)
    """
    remove if set to true will remove the update key from mainline
    post workspace merge. This can only be set true for ignored keys
    since we don't carry accepted keys to mainline post workspace
    merge.
    """


@dataclass(eq=False, repr=False)
class Update(aristaproto.Message):
    """Update represents an update on to the workspace."""

    key: "UpdateKey" = aristaproto.message_field(1)
    """key uniquely identifies the update."""

    element: "Element" = aristaproto.enum_field(2)
    """element indicates the type of a network element."""

    operation: "Operation" = aristaproto.enum_field(3)
    """operation indicates the type of operation on the topology update."""

    status: "UpdateStatus" = aristaproto.enum_field(4)
    """status indicates the status of the topology update."""

    description: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """description describes the topology update in short."""

    device_id: Optional[str] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_STRING
    )
    """device_id indicates the device associated with the update."""


@dataclass(eq=False, repr=False)
class UpdateSyncConfig(aristaproto.Message):
    """
    UpdateSyncConfig model represents a point in time all updates
    are to be accepted.
    """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """key uniquely identifies the workspace."""

    sync_time: datetime = aristaproto.message_field(2)
    """
    sync_time indicates the desired synchronization time with the live topology.
    If the sync_time indicated in the config takes effect without error,
    it will appear in the state model, and then all updates that occurred up to
    and including the timestamp in the state model will be accepted.
    """


@dataclass(eq=False, repr=False)
class RevertConfig(aristaproto.Message):
    """RevertConfig is the model provided to revert a workspace."""

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """key uniquely identifies the workspace."""


@dataclass(eq=False, repr=False)
class DecommissionConfig(aristaproto.Message):
    """
    DecommissionConfig is the resource for decommissioning
    the device from the studio.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device for a given workspace."""


@dataclass(eq=False, repr=False)
class Decommission(aristaproto.Message):
    """
    Decommission is the resource that holds the decommissioning
    state of a device.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device in a given workspace."""

    created_at: datetime = aristaproto.message_field(2)
    """created_at is the time at which decommissioning was first initiated."""

    created_by: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    created_by is the name of the user who first initiated decommissioning.
    """

    last_modified_at: datetime = aristaproto.message_field(4)
    """
    last_modified_at is the time at which the decommissioning was last modified.
    """

    last_modified_by: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """
    last_modified_by is the name of the user that last modified the status.
    """

    status: "DecommissionStatus" = aristaproto.enum_field(6)
    """status is the status of the decommissioning operation."""

    error: Optional[str] = aristaproto.message_field(7, wraps=aristaproto.TYPE_STRING)
    """error indicates if there is a failure in decommissioning."""


@dataclass(eq=False, repr=False)
class ReplaceConfig(aristaproto.Message):
    """
    ReplaceConfig is the resource for replacing a device with another device in Studios.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    key uniquely identifies the original device to be replaced in a given workspace.
    """

    replacement_device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    replacement_device_id is the device to replace the original device with.
    All references to the original device in Studios and tags will be replaced with this device.
    """


@dataclass(eq=False, repr=False)
class Replace(aristaproto.Message):
    """
    Replace is the resource that holds the status of the replace operation.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the original device for a given workspace."""

    replacement_device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    replacement_device_id is the device to replace the original device with.
    """

    created_at: datetime = aristaproto.message_field(3)
    """created_at is the time at which the status was first set."""

    created_by: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """created_by is the name of the user that first set the status."""

    last_modified_at: datetime = aristaproto.message_field(5)
    """last_modified_at is the time at which the status was last modified."""

    last_modified_by: Optional[str] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_STRING
    )
    """
    last_modified_by is the name of the user that last modified the status.
    """

    status: "ReplaceStatus" = aristaproto.enum_field(7)
    """status indicates the status of the replace operation."""

    error: Optional[str] = aristaproto.message_field(8, wraps=aristaproto.TYPE_STRING)
    """error provides the reason if there is a failure in replace."""


@dataclass(eq=False, repr=False)
class MetaResponse(aristaproto.Message):
    """ """

    time: datetime = aristaproto.message_field(1)
    """
    Time holds the timestamp of the last item included in the metadata calculation.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(2)
    """
    Operation indicates how the value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """

    count: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_UINT32)
    """
    Count is the number of items present under the conditions of the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a Decommission instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionResponse(aristaproto.Message):
    """ """

    value: "Decommission" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    Decommission instance in this response.
    """


@dataclass(eq=False, repr=False)
class DecommissionSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionSomeResponse(aristaproto.Message):
    """ """

    value: "Decommission" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    Decommission instance in this response.
    """


@dataclass(eq=False, repr=False)
class DecommissionStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["Decommission"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each Decommission at end.
        * Each Decommission response is fully-specified (all fields set).
      * start: Returns the state of each Decommission at start, followed by updates until now.
        * Each Decommission response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each Decommission at start, followed by updates
        until end.
        * Each Decommission response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class DecommissionStreamResponse(aristaproto.Message):
    """ """

    value: "Decommission" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this Decommission's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the Decommission value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DecommissionBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["Decommission"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each Decommission at end.
        * Each Decommission response is fully-specified (all fields set).
      * start: Returns the state of each Decommission at start, followed by updates until now.
        * Each Decommission response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each Decommission at start, followed by updates
        until end.
        * Each Decommission response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DecommissionBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["DecommissionStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DecommissionConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigResponse(aristaproto.Message):
    """ """

    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DecommissionConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSomeResponse(aristaproto.Message):
    """ """

    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DecommissionConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["DecommissionConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each DecommissionConfig at end.
        * Each DecommissionConfig response is fully-specified (all fields set).
      * start: Returns the state of each DecommissionConfig at start, followed by updates until now.
        * Each DecommissionConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each DecommissionConfig at start, followed by updates
        until end.
        * Each DecommissionConfig response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigStreamResponse(aristaproto.Message):
    """ """

    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DecommissionConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DecommissionConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["DecommissionConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each DecommissionConfig at end.
        * Each DecommissionConfig response is fully-specified (all fields set).
      * start: Returns the state of each DecommissionConfig at start, followed by updates until now.
        * Each DecommissionConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each DecommissionConfig at start, followed by updates
        until end.
        * Each DecommissionConfig response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["DecommissionConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSetRequest(aristaproto.Message):
    """ """

    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    DecommissionConfig carries the value to set into the datastore.
    See the documentation on the DecommissionConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSetResponse(aristaproto.Message):
    """ """

    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the DecommissionConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSetSomeRequest(aristaproto.Message):
    """ """

    values: List["DecommissionConfig"] = aristaproto.message_field(1)
    """
    value contains a list of DecommissionConfig values to write.
    It is possible to provide more values than can fit within either:
        - the maxiumum send size of the client
        - the maximum receive size of the server
    If this error occurs you must reduce the number of values sent.
    See gRPC \"maximum message size\" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSetSomeResponse(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key indicates which DecommissionConfig instance to remove.
    This field must always be set.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteResponse(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted DecommissionConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """key contains a list of DecommissionConfig keys to delete"""


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteSomeResponse(aristaproto.Message):
    """
    DecommissionConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteAllRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["DecommissionConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
    This requires all provided fields to be equal to the response.
    A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteAllResponse(aristaproto.Message):
    """ """

    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "DeviceKey" = aristaproto.message_field(3)
    """
    This is the key of the DecommissionConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class DeviceInputConfigRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceInputConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigResponse(aristaproto.Message):
    """ """

    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceInputConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSomeResponse(aristaproto.Message):
    """ """

    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceInputConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["DeviceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each DeviceInputConfig at end.
        * Each DeviceInputConfig response is fully-specified (all fields set).
      * start: Returns the state of each DeviceInputConfig at start, followed by updates until now.
        * Each DeviceInputConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each DeviceInputConfig at start, followed by updates
        until end.
        * Each DeviceInputConfig response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigStreamResponse(aristaproto.Message):
    """ """

    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DeviceInputConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceInputConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["DeviceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each DeviceInputConfig at end.
        * Each DeviceInputConfig response is fully-specified (all fields set).
      * start: Returns the state of each DeviceInputConfig at start, followed by updates until now.
        * Each DeviceInputConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each DeviceInputConfig at start, followed by updates
        until end.
        * Each DeviceInputConfig response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["DeviceInputConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSetRequest(aristaproto.Message):
    """ """

    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    DeviceInputConfig carries the value to set into the datastore.
    See the documentation on the DeviceInputConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSetResponse(aristaproto.Message):
    """ """

    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the DeviceInputConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSetSomeRequest(aristaproto.Message):
    """ """

    values: List["DeviceInputConfig"] = aristaproto.message_field(1)
    """
    value contains a list of DeviceInputConfig values to write.
    It is possible to provide more values than can fit within either:
        - the maxiumum send size of the client
        - the maximum receive size of the server
    If this error occurs you must reduce the number of values sent.
    See gRPC \"maximum message size\" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSetSomeResponse(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key indicates which DeviceInputConfig instance to remove.
    This field must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteResponse(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted DeviceInputConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """key contains a list of DeviceInputConfig keys to delete"""


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteSomeResponse(aristaproto.Message):
    """
    DeviceInputConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteAllRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["DeviceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
    This requires all provided fields to be equal to the response.
    A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteAllResponse(aristaproto.Message):
    """ """

    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "DeviceKey" = aristaproto.message_field(3)
    """
    This is the key of the DeviceInputConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class DeviceStateRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceState instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceStateResponse(aristaproto.Message):
    """ """

    value: "DeviceState" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceState instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceStateSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceStateSomeResponse(aristaproto.Message):
    """ """

    value: "DeviceState" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    DeviceState instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceStateStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["DeviceState"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each DeviceState at end.
        * Each DeviceState response is fully-specified (all fields set).
      * start: Returns the state of each DeviceState at start, followed by updates until now.
        * Each DeviceState response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each DeviceState at start, followed by updates
        until end.
        * Each DeviceState response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class DeviceStateStreamResponse(aristaproto.Message):
    """ """

    value: "DeviceState" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this DeviceState's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceState value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceStateBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["DeviceState"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each DeviceState at end.
        * Each DeviceState response is fully-specified (all fields set).
      * start: Returns the state of each DeviceState at start, followed by updates until now.
        * Each DeviceState response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each DeviceState at start, followed by updates
        until end.
        * Each DeviceState response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceStateBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["DeviceStateStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigRequest(aristaproto.Message):
    """ """

    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a InterfaceInputConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigResponse(aristaproto.Message):
    """ """

    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    InterfaceInputConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSomeRequest(aristaproto.Message):
    """ """

    keys: List["InterfaceInputKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSomeResponse(aristaproto.Message):
    """ """

    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    InterfaceInputConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["InterfaceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each InterfaceInputConfig at end.
        * Each InterfaceInputConfig response is fully-specified (all fields set).
      * start: Returns the state of each InterfaceInputConfig at start, followed by updates until now.
        * Each InterfaceInputConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each InterfaceInputConfig at start, followed by updates
        until end.
        * Each InterfaceInputConfig response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigStreamResponse(aristaproto.Message):
    """ """

    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this InterfaceInputConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the InterfaceInputConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["InterfaceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each InterfaceInputConfig at end.
        * Each InterfaceInputConfig response is fully-specified (all fields set).
      * start: Returns the state of each InterfaceInputConfig at start, followed by updates until now.
        * Each InterfaceInputConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each InterfaceInputConfig at start, followed by updates
        until end.
        * Each InterfaceInputConfig response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["InterfaceInputConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSetRequest(aristaproto.Message):
    """ """

    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    InterfaceInputConfig carries the value to set into the datastore.
    See the documentation on the InterfaceInputConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSetResponse(aristaproto.Message):
    """ """

    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the InterfaceInputConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSetSomeRequest(aristaproto.Message):
    """ """

    values: List["InterfaceInputConfig"] = aristaproto.message_field(1)
    """
    value contains a list of InterfaceInputConfig values to write.
    It is possible to provide more values than can fit within either:
        - the maxiumum send size of the client
        - the maximum receive size of the server
    If this error occurs you must reduce the number of values sent.
    See gRPC \"maximum message size\" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSetSomeResponse(aristaproto.Message):
    """ """

    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteRequest(aristaproto.Message):
    """ """

    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """
    Key indicates which InterfaceInputConfig instance to remove.
    This field must always be set.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteResponse(aristaproto.Message):
    """ """

    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """
    Key echoes back the key of the deleted InterfaceInputConfig instance.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteSomeRequest(aristaproto.Message):
    """ """

    keys: List["InterfaceInputKey"] = aristaproto.message_field(1)
    """key contains a list of InterfaceInputConfig keys to delete"""


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteSomeResponse(aristaproto.Message):
    """
    InterfaceInputConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteAllRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["InterfaceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
    This requires all provided fields to be equal to the response.
    A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteAllResponse(aristaproto.Message):
    """ """

    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "InterfaceInputKey" = aristaproto.message_field(3)
    """
    This is the key of the InterfaceInputConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class ReplaceRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a Replace instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ReplaceResponse(aristaproto.Message):
    """ """

    value: "Replace" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    Replace instance in this response.
    """


@dataclass(eq=False, repr=False)
class ReplaceSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ReplaceSomeResponse(aristaproto.Message):
    """ """

    value: "Replace" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    Replace instance in this response.
    """


@dataclass(eq=False, repr=False)
class ReplaceStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["Replace"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each Replace at end.
        * Each Replace response is fully-specified (all fields set).
      * start: Returns the state of each Replace at start, followed by updates until now.
        * Each Replace response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each Replace at start, followed by updates
        until end.
        * Each Replace response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class ReplaceStreamResponse(aristaproto.Message):
    """ """

    value: "Replace" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this Replace's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the Replace value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class ReplaceBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["Replace"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each Replace at end.
        * Each Replace response is fully-specified (all fields set).
      * start: Returns the state of each Replace at start, followed by updates until now.
        * Each Replace response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each Replace at start, followed by updates
        until end.
        * Each Replace response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class ReplaceBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["ReplaceStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a ReplaceConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigResponse(aristaproto.Message):
    """ """

    value: "ReplaceConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    ReplaceConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigSomeResponse(aristaproto.Message):
    """ """

    value: "ReplaceConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    ReplaceConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["ReplaceConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each ReplaceConfig at end.
        * Each ReplaceConfig response is fully-specified (all fields set).
      * start: Returns the state of each ReplaceConfig at start, followed by updates until now.
        * Each ReplaceConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each ReplaceConfig at start, followed by updates
        until end.
        * Each ReplaceConfig response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigStreamResponse(aristaproto.Message):
    """ """

    value: "ReplaceConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this ReplaceConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the ReplaceConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["ReplaceConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each ReplaceConfig at end.
        * Each ReplaceConfig response is fully-specified (all fields set).
      * start: Returns the state of each ReplaceConfig at start, followed by updates until now.
        * Each ReplaceConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each ReplaceConfig at start, followed by updates
        until end.
        * Each ReplaceConfig response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["ReplaceConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigSetRequest(aristaproto.Message):
    """ """

    value: "ReplaceConfig" = aristaproto.message_field(1)
    """
    ReplaceConfig carries the value to set into the datastore.
    See the documentation on the ReplaceConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigSetResponse(aristaproto.Message):
    """ """

    value: "ReplaceConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the ReplaceConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigSetSomeRequest(aristaproto.Message):
    """ """

    values: List["ReplaceConfig"] = aristaproto.message_field(1)
    """
    value contains a list of ReplaceConfig values to write.
    It is possible to provide more values than can fit within either:
        - the maxiumum send size of the client
        - the maximum receive size of the server
    If this error occurs you must reduce the number of values sent.
    See gRPC \"maximum message size\" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigSetSomeResponse(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigDeleteRequest(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key indicates which ReplaceConfig instance to remove.
    This field must always be set.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigDeleteResponse(aristaproto.Message):
    """ """

    key: "DeviceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted ReplaceConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigDeleteSomeRequest(aristaproto.Message):
    """ """

    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """key contains a list of ReplaceConfig keys to delete"""


@dataclass(eq=False, repr=False)
class ReplaceConfigDeleteSomeResponse(aristaproto.Message):
    """ReplaceConfigDeleteSomeResponse is only sent when there is an error."""

    key: "DeviceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigDeleteAllRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["ReplaceConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
    This requires all provided fields to be equal to the response.
    A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class ReplaceConfigDeleteAllResponse(aristaproto.Message):
    """ """

    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "DeviceKey" = aristaproto.message_field(3)
    """
    This is the key of the ReplaceConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class RevertConfigRequest(aristaproto.Message):
    """ """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a RevertConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class RevertConfigResponse(aristaproto.Message):
    """ """

    value: "RevertConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    RevertConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSomeRequest(aristaproto.Message):
    """ """

    keys: List["__workspace_v1__.WorkspaceKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSomeResponse(aristaproto.Message):
    """ """

    value: "RevertConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    RevertConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class RevertConfigStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["RevertConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each RevertConfig at end.
        * Each RevertConfig response is fully-specified (all fields set).
      * start: Returns the state of each RevertConfig at start, followed by updates until now.
        * Each RevertConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each RevertConfig at start, followed by updates
        until end.
        * Each RevertConfig response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class RevertConfigStreamResponse(aristaproto.Message):
    """ """

    value: "RevertConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this RevertConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the RevertConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class RevertConfigBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["RevertConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each RevertConfig at end.
        * Each RevertConfig response is fully-specified (all fields set).
      * start: Returns the state of each RevertConfig at start, followed by updates until now.
        * Each RevertConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each RevertConfig at start, followed by updates
        until end.
        * Each RevertConfig response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class RevertConfigBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["RevertConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class RevertConfigSetRequest(aristaproto.Message):
    """ """

    value: "RevertConfig" = aristaproto.message_field(1)
    """
    RevertConfig carries the value to set into the datastore.
    See the documentation on the RevertConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSetResponse(aristaproto.Message):
    """ """

    value: "RevertConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the RevertConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSetSomeRequest(aristaproto.Message):
    """ """

    values: List["RevertConfig"] = aristaproto.message_field(1)
    """
    value contains a list of RevertConfig values to write.
    It is possible to provide more values than can fit within either:
        - the maxiumum send size of the client
        - the maximum receive size of the server
    If this error occurs you must reduce the number of values sent.
    See gRPC \"maximum message size\" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSetSomeResponse(aristaproto.Message):
    """ """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class RevertConfigDeleteRequest(aristaproto.Message):
    """ """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    Key indicates which RevertConfig instance to remove.
    This field must always be set.
    """


@dataclass(eq=False, repr=False)
class RevertConfigDeleteResponse(aristaproto.Message):
    """ """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted RevertConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class RevertConfigDeleteSomeRequest(aristaproto.Message):
    """ """

    keys: List["__workspace_v1__.WorkspaceKey"] = aristaproto.message_field(1)
    """key contains a list of RevertConfig keys to delete"""


@dataclass(eq=False, repr=False)
class RevertConfigDeleteSomeResponse(aristaproto.Message):
    """RevertConfigDeleteSomeResponse is only sent when there is an error."""

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class RevertConfigDeleteAllRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["RevertConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
    This requires all provided fields to be equal to the response.
    A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class RevertConfigDeleteAllResponse(aristaproto.Message):
    """ """

    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(3)
    """
    This is the key of the RevertConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class UpdateRequest(aristaproto.Message):
    """ """

    key: "UpdateKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a Update instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateResponse(aristaproto.Message):
    """ """

    value: "Update" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    Update instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateSomeRequest(aristaproto.Message):
    """ """

    keys: List["UpdateKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateSomeResponse(aristaproto.Message):
    """ """

    value: "Update" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    Update instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["Update"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each Update at end.
        * Each Update response is fully-specified (all fields set).
      * start: Returns the state of each Update at start, followed by updates until now.
        * Each Update response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each Update at start, followed by updates
        until end.
        * Each Update response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class UpdateStreamResponse(aristaproto.Message):
    """ """

    value: "Update" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this Update's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the Update value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class UpdateBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["Update"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each Update at end.
        * Each Update response is fully-specified (all fields set).
      * start: Returns the state of each Update at start, followed by updates until now.
        * Each Update response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each Update at start, followed by updates
        until end.
        * Each Update response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class UpdateBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["UpdateStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class UpdateConfigRequest(aristaproto.Message):
    """ """

    key: "UpdateKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a UpdateConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigResponse(aristaproto.Message):
    """ """

    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    UpdateConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSomeRequest(aristaproto.Message):
    """ """

    keys: List["UpdateKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSomeResponse(aristaproto.Message):
    """ """

    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    UpdateConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["UpdateConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each UpdateConfig at end.
        * Each UpdateConfig response is fully-specified (all fields set).
      * start: Returns the state of each UpdateConfig at start, followed by updates until now.
        * Each UpdateConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each UpdateConfig at start, followed by updates
        until end.
        * Each UpdateConfig response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigStreamResponse(aristaproto.Message):
    """ """

    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this UpdateConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the UpdateConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["UpdateConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each UpdateConfig at end.
        * Each UpdateConfig response is fully-specified (all fields set).
      * start: Returns the state of each UpdateConfig at start, followed by updates until now.
        * Each UpdateConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each UpdateConfig at start, followed by updates
        until end.
        * Each UpdateConfig response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["UpdateConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSetRequest(aristaproto.Message):
    """ """

    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    UpdateConfig carries the value to set into the datastore.
    See the documentation on the UpdateConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSetResponse(aristaproto.Message):
    """ """

    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the UpdateConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSetSomeRequest(aristaproto.Message):
    """ """

    values: List["UpdateConfig"] = aristaproto.message_field(1)
    """
    value contains a list of UpdateConfig values to write.
    It is possible to provide more values than can fit within either:
        - the maxiumum send size of the client
        - the maximum receive size of the server
    If this error occurs you must reduce the number of values sent.
    See gRPC \"maximum message size\" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSetSomeResponse(aristaproto.Message):
    """ """

    key: "UpdateKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteRequest(aristaproto.Message):
    """ """

    key: "UpdateKey" = aristaproto.message_field(1)
    """
    Key indicates which UpdateConfig instance to remove.
    This field must always be set.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteResponse(aristaproto.Message):
    """ """

    key: "UpdateKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted UpdateConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteSomeRequest(aristaproto.Message):
    """ """

    keys: List["UpdateKey"] = aristaproto.message_field(1)
    """key contains a list of UpdateConfig keys to delete"""


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteSomeResponse(aristaproto.Message):
    """UpdateConfigDeleteSomeResponse is only sent when there is an error."""

    key: "UpdateKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteAllRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["UpdateConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
    This requires all provided fields to be equal to the response.
    A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteAllResponse(aristaproto.Message):
    """ """

    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "UpdateKey" = aristaproto.message_field(3)
    """
    This is the key of the UpdateConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class UpdateSyncConfigRequest(aristaproto.Message):
    """ """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a UpdateSyncConfig instance to retrieve.
    This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigResponse(aristaproto.Message):
    """ """

    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    UpdateSyncConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSomeRequest(aristaproto.Message):
    """ """

    keys: List["__workspace_v1__.WorkspaceKey"] = aristaproto.message_field(1)
    """
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
    If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSomeResponse(aristaproto.Message):
    """ """

    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
    This structure will be fully-populated as it exists in the datastore. If
    optional fields were not given at creation, these fields will be empty or
    set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
    It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)
    """
    Time carries the (UTC) timestamp of the last-modification of the
    UpdateSyncConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["UpdateSyncConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each UpdateSyncConfig at end.
        * Each UpdateSyncConfig response is fully-specified (all fields set).
      * start: Returns the state of each UpdateSyncConfig at start, followed by updates until now.
        * Each UpdateSyncConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each UpdateSyncConfig at start, followed by updates
        until end.
        * Each UpdateSyncConfig response at start is fully-specified, but updates until end may
          be partial.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigStreamResponse(aristaproto.Message):
    """ """

    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
    This structure will always have its key-field populated. Which other fields are
    populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this UpdateSyncConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the UpdateSyncConfig value in this response should be considered.
    Under non-subscribe requests, this value should always be INITIAL. In a subscription,
    once all initial data is streamed and the client begins to receive modification updates,
    you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigBatchedStreamRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["UpdateSyncConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
    This requires all provided fields to be equal to the response.

    While transparent to users, this field also allows services to optimize internal
    subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
    If this field is populated, at least one of the two time fields are required.

    For GetAll, the fields start and end can be used as follows:

      * end: Returns the state of each UpdateSyncConfig at end.
        * Each UpdateSyncConfig response is fully-specified (all fields set).
      * start: Returns the state of each UpdateSyncConfig at start, followed by updates until now.
        * Each UpdateSyncConfig response at start is fully-specified, but updates may be partial.
      * start and end: Returns the state of each UpdateSyncConfig at start, followed by updates
        until end.
        * Each UpdateSyncConfig response at start is fully-specified, but updates until end may
          be partial.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
    MaxMessages is required to be at least 1.
    The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
    INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigBatchedStreamResponse(aristaproto.Message):
    """ """

    responses: List["UpdateSyncConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
    The length of this structure is guaranteed to be between (inclusive) 1 and
    min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSetRequest(aristaproto.Message):
    """ """

    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    UpdateSyncConfig carries the value to set into the datastore.
    See the documentation on the UpdateSyncConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSetResponse(aristaproto.Message):
    """ """

    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the UpdateSyncConfigSetRequest as well
    as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    creation. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSetSomeRequest(aristaproto.Message):
    """ """

    values: List["UpdateSyncConfig"] = aristaproto.message_field(1)
    """
    value contains a list of UpdateSyncConfig values to write.
    It is possible to provide more values than can fit within either:
        - the maxiumum send size of the client
        - the maximum receive size of the server
    If this error occurs you must reduce the number of values sent.
    See gRPC \"maximum message size\" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSetSomeResponse(aristaproto.Message):
    """ """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteRequest(aristaproto.Message):
    """ """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    Key indicates which UpdateSyncConfig instance to remove.
    This field must always be set.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteResponse(aristaproto.Message):
    """ """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted UpdateSyncConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
    deletion. The only guarantees made about this timestamp are:

       - it is after the time the request was received
       - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteSomeRequest(aristaproto.Message):
    """ """

    keys: List["__workspace_v1__.WorkspaceKey"] = aristaproto.message_field(1)
    """key contains a list of UpdateSyncConfig keys to delete"""


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteSomeResponse(aristaproto.Message):
    """
    UpdateSyncConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    """

    error: str = aristaproto.string_field(2)
    """
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteAllRequest(aristaproto.Message):
    """ """

    partial_eq_filter: List["UpdateSyncConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
    This requires all provided fields to be equal to the response.
    A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteAllResponse(aristaproto.Message):
    """ """

    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
    A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(3)
    """
    This is the key of the UpdateSyncConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


class DecommissionServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        decommission_request: "DecommissionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DecommissionResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionService/GetOne",
            decommission_request,
            DecommissionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        decommission_some_request: "DecommissionSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/GetSome",
            decommission_some_request,
            DecommissionSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        decommission_stream_request: "DecommissionStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/GetAll",
            decommission_stream_request,
            DecommissionStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        decommission_stream_request: "DecommissionStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/Subscribe",
            decommission_stream_request,
            DecommissionStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        decommission_stream_request: "DecommissionStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionService/GetMeta",
            decommission_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        decommission_stream_request: "DecommissionStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/SubscribeMeta",
            decommission_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        decommission_batched_stream_request: "DecommissionBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/GetAllBatched",
            decommission_batched_stream_request,
            DecommissionBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        decommission_batched_stream_request: "DecommissionBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/SubscribeBatched",
            decommission_batched_stream_request,
            DecommissionBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DecommissionConfigServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        decommission_config_request: "DecommissionConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DecommissionConfigResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionConfigService/GetOne",
            decommission_config_request,
            DecommissionConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        decommission_config_some_request: "DecommissionConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionConfigSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/GetSome",
            decommission_config_some_request,
            DecommissionConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        decommission_config_stream_request: "DecommissionConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/GetAll",
            decommission_config_stream_request,
            DecommissionConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        decommission_config_stream_request: "DecommissionConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/Subscribe",
            decommission_config_stream_request,
            DecommissionConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        decommission_config_stream_request: "DecommissionConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionConfigService/GetMeta",
            decommission_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        decommission_config_stream_request: "DecommissionConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/SubscribeMeta",
            decommission_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        decommission_config_set_request: "DecommissionConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DecommissionConfigSetResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionConfigService/Set",
            decommission_config_set_request,
            DecommissionConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        decommission_config_set_some_request: "DecommissionConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionConfigSetSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/SetSome",
            decommission_config_set_some_request,
            DecommissionConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        decommission_config_delete_request: "DecommissionConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DecommissionConfigDeleteResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionConfigService/Delete",
            decommission_config_delete_request,
            DecommissionConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        decommission_config_delete_some_request: "DecommissionConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionConfigDeleteSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/DeleteSome",
            decommission_config_delete_some_request,
            DecommissionConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        decommission_config_delete_all_request: "DecommissionConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionConfigDeleteAllResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/DeleteAll",
            decommission_config_delete_all_request,
            DecommissionConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        decommission_config_batched_stream_request: "DecommissionConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/GetAllBatched",
            decommission_config_batched_stream_request,
            DecommissionConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        decommission_config_batched_stream_request: "DecommissionConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DecommissionConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/SubscribeBatched",
            decommission_config_batched_stream_request,
            DecommissionConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceInputConfigServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        device_input_config_request: "DeviceInputConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DeviceInputConfigResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetOne",
            device_input_config_request,
            DeviceInputConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_input_config_some_request: "DeviceInputConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceInputConfigSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetSome",
            device_input_config_some_request,
            DeviceInputConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_input_config_stream_request: "DeviceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceInputConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetAll",
            device_input_config_stream_request,
            DeviceInputConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_input_config_stream_request: "DeviceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceInputConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/Subscribe",
            device_input_config_stream_request,
            DeviceInputConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_input_config_stream_request: "DeviceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetMeta",
            device_input_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_input_config_stream_request: "DeviceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/SubscribeMeta",
            device_input_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_input_config_set_request: "DeviceInputConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DeviceInputConfigSetResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceInputConfigService/Set",
            device_input_config_set_request,
            DeviceInputConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        device_input_config_set_some_request: "DeviceInputConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceInputConfigSetSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/SetSome",
            device_input_config_set_some_request,
            DeviceInputConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        device_input_config_delete_request: "DeviceInputConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DeviceInputConfigDeleteResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceInputConfigService/Delete",
            device_input_config_delete_request,
            DeviceInputConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        device_input_config_delete_some_request: "DeviceInputConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceInputConfigDeleteSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/DeleteSome",
            device_input_config_delete_some_request,
            DeviceInputConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        device_input_config_delete_all_request: "DeviceInputConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceInputConfigDeleteAllResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/DeleteAll",
            device_input_config_delete_all_request,
            DeviceInputConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_input_config_batched_stream_request: "DeviceInputConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceInputConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetAllBatched",
            device_input_config_batched_stream_request,
            DeviceInputConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_input_config_batched_stream_request: "DeviceInputConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceInputConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/SubscribeBatched",
            device_input_config_batched_stream_request,
            DeviceInputConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceStateServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        device_state_request: "DeviceStateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DeviceStateResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceStateService/GetOne",
            device_state_request,
            DeviceStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_state_some_request: "DeviceStateSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceStateSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/GetSome",
            device_state_some_request,
            DeviceStateSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_state_stream_request: "DeviceStateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceStateStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/GetAll",
            device_state_stream_request,
            DeviceStateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_state_stream_request: "DeviceStateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceStateStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/Subscribe",
            device_state_stream_request,
            DeviceStateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_state_stream_request: "DeviceStateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceStateService/GetMeta",
            device_state_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_state_stream_request: "DeviceStateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/SubscribeMeta",
            device_state_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_state_batched_stream_request: "DeviceStateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceStateBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/GetAllBatched",
            device_state_batched_stream_request,
            DeviceStateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_state_batched_stream_request: "DeviceStateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[DeviceStateBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/SubscribeBatched",
            device_state_batched_stream_request,
            DeviceStateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InterfaceInputConfigServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        interface_input_config_request: "InterfaceInputConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "InterfaceInputConfigResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetOne",
            interface_input_config_request,
            InterfaceInputConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        interface_input_config_some_request: "InterfaceInputConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[InterfaceInputConfigSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetSome",
            interface_input_config_some_request,
            InterfaceInputConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        interface_input_config_stream_request: "InterfaceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[InterfaceInputConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetAll",
            interface_input_config_stream_request,
            InterfaceInputConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        interface_input_config_stream_request: "InterfaceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[InterfaceInputConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/Subscribe",
            interface_input_config_stream_request,
            InterfaceInputConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        interface_input_config_stream_request: "InterfaceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetMeta",
            interface_input_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        interface_input_config_stream_request: "InterfaceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/SubscribeMeta",
            interface_input_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        interface_input_config_set_request: "InterfaceInputConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "InterfaceInputConfigSetResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.InterfaceInputConfigService/Set",
            interface_input_config_set_request,
            InterfaceInputConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        interface_input_config_set_some_request: "InterfaceInputConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[InterfaceInputConfigSetSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/SetSome",
            interface_input_config_set_some_request,
            InterfaceInputConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        interface_input_config_delete_request: "InterfaceInputConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "InterfaceInputConfigDeleteResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.InterfaceInputConfigService/Delete",
            interface_input_config_delete_request,
            InterfaceInputConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        interface_input_config_delete_some_request: "InterfaceInputConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[InterfaceInputConfigDeleteSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/DeleteSome",
            interface_input_config_delete_some_request,
            InterfaceInputConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        interface_input_config_delete_all_request: "InterfaceInputConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[InterfaceInputConfigDeleteAllResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/DeleteAll",
            interface_input_config_delete_all_request,
            InterfaceInputConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        interface_input_config_batched_stream_request: "InterfaceInputConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[InterfaceInputConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetAllBatched",
            interface_input_config_batched_stream_request,
            InterfaceInputConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        interface_input_config_batched_stream_request: "InterfaceInputConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[InterfaceInputConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/SubscribeBatched",
            interface_input_config_batched_stream_request,
            InterfaceInputConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ReplaceServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        replace_request: "ReplaceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ReplaceResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.ReplaceService/GetOne",
            replace_request,
            ReplaceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        replace_some_request: "ReplaceSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceService/GetSome",
            replace_some_request,
            ReplaceSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        replace_stream_request: "ReplaceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceService/GetAll",
            replace_stream_request,
            ReplaceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        replace_stream_request: "ReplaceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceService/Subscribe",
            replace_stream_request,
            ReplaceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        replace_stream_request: "ReplaceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.ReplaceService/GetMeta",
            replace_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        replace_stream_request: "ReplaceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceService/SubscribeMeta",
            replace_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        replace_batched_stream_request: "ReplaceBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceService/GetAllBatched",
            replace_batched_stream_request,
            ReplaceBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        replace_batched_stream_request: "ReplaceBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceService/SubscribeBatched",
            replace_batched_stream_request,
            ReplaceBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ReplaceConfigServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        replace_config_request: "ReplaceConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ReplaceConfigResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.ReplaceConfigService/GetOne",
            replace_config_request,
            ReplaceConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        replace_config_some_request: "ReplaceConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceConfigSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/GetSome",
            replace_config_some_request,
            ReplaceConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        replace_config_stream_request: "ReplaceConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/GetAll",
            replace_config_stream_request,
            ReplaceConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        replace_config_stream_request: "ReplaceConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/Subscribe",
            replace_config_stream_request,
            ReplaceConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        replace_config_stream_request: "ReplaceConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.ReplaceConfigService/GetMeta",
            replace_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        replace_config_stream_request: "ReplaceConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/SubscribeMeta",
            replace_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        replace_config_set_request: "ReplaceConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ReplaceConfigSetResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.ReplaceConfigService/Set",
            replace_config_set_request,
            ReplaceConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        replace_config_set_some_request: "ReplaceConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceConfigSetSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/SetSome",
            replace_config_set_some_request,
            ReplaceConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        replace_config_delete_request: "ReplaceConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "ReplaceConfigDeleteResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.ReplaceConfigService/Delete",
            replace_config_delete_request,
            ReplaceConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        replace_config_delete_some_request: "ReplaceConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceConfigDeleteSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/DeleteSome",
            replace_config_delete_some_request,
            ReplaceConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        replace_config_delete_all_request: "ReplaceConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceConfigDeleteAllResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/DeleteAll",
            replace_config_delete_all_request,
            ReplaceConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        replace_config_batched_stream_request: "ReplaceConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/GetAllBatched",
            replace_config_batched_stream_request,
            ReplaceConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        replace_config_batched_stream_request: "ReplaceConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[ReplaceConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.ReplaceConfigService/SubscribeBatched",
            replace_config_batched_stream_request,
            ReplaceConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class RevertConfigServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        revert_config_request: "RevertConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "RevertConfigResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.RevertConfigService/GetOne",
            revert_config_request,
            RevertConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        revert_config_some_request: "RevertConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[RevertConfigSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/GetSome",
            revert_config_some_request,
            RevertConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        revert_config_stream_request: "RevertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[RevertConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/GetAll",
            revert_config_stream_request,
            RevertConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        revert_config_stream_request: "RevertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[RevertConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/Subscribe",
            revert_config_stream_request,
            RevertConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        revert_config_stream_request: "RevertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.RevertConfigService/GetMeta",
            revert_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        revert_config_stream_request: "RevertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/SubscribeMeta",
            revert_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        revert_config_set_request: "RevertConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "RevertConfigSetResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.RevertConfigService/Set",
            revert_config_set_request,
            RevertConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        revert_config_set_some_request: "RevertConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[RevertConfigSetSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/SetSome",
            revert_config_set_some_request,
            RevertConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        revert_config_delete_request: "RevertConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "RevertConfigDeleteResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.RevertConfigService/Delete",
            revert_config_delete_request,
            RevertConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        revert_config_delete_some_request: "RevertConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[RevertConfigDeleteSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/DeleteSome",
            revert_config_delete_some_request,
            RevertConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        revert_config_delete_all_request: "RevertConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[RevertConfigDeleteAllResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/DeleteAll",
            revert_config_delete_all_request,
            RevertConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        revert_config_batched_stream_request: "RevertConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[RevertConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/GetAllBatched",
            revert_config_batched_stream_request,
            RevertConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        revert_config_batched_stream_request: "RevertConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[RevertConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/SubscribeBatched",
            revert_config_batched_stream_request,
            RevertConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class UpdateServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        update_request: "UpdateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "UpdateResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateService/GetOne",
            update_request,
            UpdateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        update_some_request: "UpdateSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/GetSome",
            update_some_request,
            UpdateSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        update_stream_request: "UpdateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/GetAll",
            update_stream_request,
            UpdateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        update_stream_request: "UpdateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/Subscribe",
            update_stream_request,
            UpdateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        update_stream_request: "UpdateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateService/GetMeta",
            update_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        update_stream_request: "UpdateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/SubscribeMeta",
            update_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        update_batched_stream_request: "UpdateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/GetAllBatched",
            update_batched_stream_request,
            UpdateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        update_batched_stream_request: "UpdateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/SubscribeBatched",
            update_batched_stream_request,
            UpdateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class UpdateConfigServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        update_config_request: "UpdateConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "UpdateConfigResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateConfigService/GetOne",
            update_config_request,
            UpdateConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        update_config_some_request: "UpdateConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateConfigSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/GetSome",
            update_config_some_request,
            UpdateConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        update_config_stream_request: "UpdateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/GetAll",
            update_config_stream_request,
            UpdateConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        update_config_stream_request: "UpdateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/Subscribe",
            update_config_stream_request,
            UpdateConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        update_config_stream_request: "UpdateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateConfigService/GetMeta",
            update_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        update_config_stream_request: "UpdateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/SubscribeMeta",
            update_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        update_config_set_request: "UpdateConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "UpdateConfigSetResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateConfigService/Set",
            update_config_set_request,
            UpdateConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        update_config_set_some_request: "UpdateConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateConfigSetSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/SetSome",
            update_config_set_some_request,
            UpdateConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        update_config_delete_request: "UpdateConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "UpdateConfigDeleteResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateConfigService/Delete",
            update_config_delete_request,
            UpdateConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        update_config_delete_some_request: "UpdateConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateConfigDeleteSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/DeleteSome",
            update_config_delete_some_request,
            UpdateConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        update_config_delete_all_request: "UpdateConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateConfigDeleteAllResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/DeleteAll",
            update_config_delete_all_request,
            UpdateConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        update_config_batched_stream_request: "UpdateConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/GetAllBatched",
            update_config_batched_stream_request,
            UpdateConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        update_config_batched_stream_request: "UpdateConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/SubscribeBatched",
            update_config_batched_stream_request,
            UpdateConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class UpdateSyncConfigServiceStub(aristaproto.ServiceStub):
    """ """

    async def get_one(
        self,
        update_sync_config_request: "UpdateSyncConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "UpdateSyncConfigResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetOne",
            update_sync_config_request,
            UpdateSyncConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        update_sync_config_some_request: "UpdateSyncConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSyncConfigSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetSome",
            update_sync_config_some_request,
            UpdateSyncConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        update_sync_config_stream_request: "UpdateSyncConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSyncConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetAll",
            update_sync_config_stream_request,
            UpdateSyncConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        update_sync_config_stream_request: "UpdateSyncConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSyncConfigStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/Subscribe",
            update_sync_config_stream_request,
            UpdateSyncConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        update_sync_config_stream_request: "UpdateSyncConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "MetaResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetMeta",
            update_sync_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        update_sync_config_stream_request: "UpdateSyncConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[MetaResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/SubscribeMeta",
            update_sync_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        update_sync_config_set_request: "UpdateSyncConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "UpdateSyncConfigSetResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateSyncConfigService/Set",
            update_sync_config_set_request,
            UpdateSyncConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        update_sync_config_set_some_request: "UpdateSyncConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSyncConfigSetSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/SetSome",
            update_sync_config_set_some_request,
            UpdateSyncConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        update_sync_config_delete_request: "UpdateSyncConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "UpdateSyncConfigDeleteResponse":
        """ """

        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateSyncConfigService/Delete",
            update_sync_config_delete_request,
            UpdateSyncConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        update_sync_config_delete_some_request: "UpdateSyncConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSyncConfigDeleteSomeResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/DeleteSome",
            update_sync_config_delete_some_request,
            UpdateSyncConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        update_sync_config_delete_all_request: "UpdateSyncConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSyncConfigDeleteAllResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/DeleteAll",
            update_sync_config_delete_all_request,
            UpdateSyncConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        update_sync_config_batched_stream_request: "UpdateSyncConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSyncConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetAllBatched",
            update_sync_config_batched_stream_request,
            UpdateSyncConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        update_sync_config_batched_stream_request: "UpdateSyncConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AsyncIterator[UpdateSyncConfigBatchedStreamResponse]":
        """ """

        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/SubscribeBatched",
            update_sync_config_batched_stream_request,
            UpdateSyncConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


from .... import fmp as ___fmp__
from ... import subscriptions as __subscriptions__
from ... import time as __time__
from ...workspace import v1 as __workspace_v1__


class DecommissionServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, decommission_request: "DecommissionRequest"
    ) -> "DecommissionResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, decommission_some_request: "DecommissionSomeRequest"
    ) -> AsyncIterator[DecommissionSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, decommission_stream_request: "DecommissionStreamRequest"
    ) -> AsyncIterator[DecommissionStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, decommission_stream_request: "DecommissionStreamRequest"
    ) -> AsyncIterator[DecommissionStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, decommission_stream_request: "DecommissionStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, decommission_stream_request: "DecommissionStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, decommission_batched_stream_request: "DecommissionBatchedStreamRequest"
    ) -> AsyncIterator[DecommissionBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, decommission_batched_stream_request: "DecommissionBatchedStreamRequest"
    ) -> AsyncIterator[DecommissionBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[DecommissionRequest, DecommissionResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DecommissionSomeRequest, DecommissionSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DecommissionStreamRequest, DecommissionStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DecommissionStreamRequest, DecommissionStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[DecommissionStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[DecommissionStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DecommissionBatchedStreamRequest, DecommissionBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DecommissionBatchedStreamRequest, DecommissionBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.DecommissionService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionRequest,
                DecommissionResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionSomeRequest,
                DecommissionSomeResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionStreamRequest,
                DecommissionStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionStreamRequest,
                DecommissionStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionBatchedStreamRequest,
                DecommissionBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionBatchedStreamRequest,
                DecommissionBatchedStreamResponse,
            ),
        }


class DecommissionConfigServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, decommission_config_request: "DecommissionConfigRequest"
    ) -> "DecommissionConfigResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, decommission_config_some_request: "DecommissionConfigSomeRequest"
    ) -> AsyncIterator[DecommissionConfigSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, decommission_config_stream_request: "DecommissionConfigStreamRequest"
    ) -> AsyncIterator[DecommissionConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, decommission_config_stream_request: "DecommissionConfigStreamRequest"
    ) -> AsyncIterator[DecommissionConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, decommission_config_stream_request: "DecommissionConfigStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, decommission_config_stream_request: "DecommissionConfigStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, decommission_config_set_request: "DecommissionConfigSetRequest"
    ) -> "DecommissionConfigSetResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, decommission_config_set_some_request: "DecommissionConfigSetSomeRequest"
    ) -> AsyncIterator[DecommissionConfigSetSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, decommission_config_delete_request: "DecommissionConfigDeleteRequest"
    ) -> "DecommissionConfigDeleteResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        decommission_config_delete_some_request: "DecommissionConfigDeleteSomeRequest",
    ) -> AsyncIterator[DecommissionConfigDeleteSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        decommission_config_delete_all_request: "DecommissionConfigDeleteAllRequest",
    ) -> AsyncIterator[DecommissionConfigDeleteAllResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        decommission_config_batched_stream_request: "DecommissionConfigBatchedStreamRequest",
    ) -> AsyncIterator[DecommissionConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        decommission_config_batched_stream_request: "DecommissionConfigBatchedStreamRequest",
    ) -> AsyncIterator[DecommissionConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigRequest, DecommissionConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigSomeRequest, DecommissionConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigStreamRequest, DecommissionConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigStreamRequest, DecommissionConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigSetRequest, DecommissionConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigSetSomeRequest, DecommissionConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigDeleteRequest, DecommissionConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigDeleteSomeRequest, DecommissionConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigDeleteAllRequest, DecommissionConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigBatchedStreamRequest, DecommissionConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigBatchedStreamRequest, DecommissionConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.DecommissionConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionConfigRequest,
                DecommissionConfigResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigSomeRequest,
                DecommissionConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigStreamRequest,
                DecommissionConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigStreamRequest,
                DecommissionConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionConfigSetRequest,
                DecommissionConfigSetResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigSetSomeRequest,
                DecommissionConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionConfigDeleteRequest,
                DecommissionConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigDeleteSomeRequest,
                DecommissionConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigDeleteAllRequest,
                DecommissionConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigBatchedStreamRequest,
                DecommissionConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigBatchedStreamRequest,
                DecommissionConfigBatchedStreamResponse,
            ),
        }


class DeviceInputConfigServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, device_input_config_request: "DeviceInputConfigRequest"
    ) -> "DeviceInputConfigResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, device_input_config_some_request: "DeviceInputConfigSomeRequest"
    ) -> AsyncIterator[DeviceInputConfigSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_input_config_stream_request: "DeviceInputConfigStreamRequest"
    ) -> AsyncIterator[DeviceInputConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, device_input_config_stream_request: "DeviceInputConfigStreamRequest"
    ) -> AsyncIterator[DeviceInputConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, device_input_config_stream_request: "DeviceInputConfigStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, device_input_config_stream_request: "DeviceInputConfigStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, device_input_config_set_request: "DeviceInputConfigSetRequest"
    ) -> "DeviceInputConfigSetResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, device_input_config_set_some_request: "DeviceInputConfigSetSomeRequest"
    ) -> AsyncIterator[DeviceInputConfigSetSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, device_input_config_delete_request: "DeviceInputConfigDeleteRequest"
    ) -> "DeviceInputConfigDeleteResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        device_input_config_delete_some_request: "DeviceInputConfigDeleteSomeRequest",
    ) -> AsyncIterator[DeviceInputConfigDeleteSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        device_input_config_delete_all_request: "DeviceInputConfigDeleteAllRequest",
    ) -> AsyncIterator[DeviceInputConfigDeleteAllResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        device_input_config_batched_stream_request: "DeviceInputConfigBatchedStreamRequest",
    ) -> AsyncIterator[DeviceInputConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        device_input_config_batched_stream_request: "DeviceInputConfigBatchedStreamRequest",
    ) -> AsyncIterator[DeviceInputConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigRequest, DeviceInputConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigSomeRequest, DeviceInputConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigStreamRequest, DeviceInputConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigStreamRequest, DeviceInputConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigSetRequest, DeviceInputConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigSetSomeRequest, DeviceInputConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigDeleteRequest, DeviceInputConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigDeleteSomeRequest, DeviceInputConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigDeleteAllRequest, DeviceInputConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigBatchedStreamRequest, DeviceInputConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigBatchedStreamRequest, DeviceInputConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.DeviceInputConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceInputConfigRequest,
                DeviceInputConfigResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigSomeRequest,
                DeviceInputConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigStreamRequest,
                DeviceInputConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigStreamRequest,
                DeviceInputConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceInputConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceInputConfigSetRequest,
                DeviceInputConfigSetResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigSetSomeRequest,
                DeviceInputConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceInputConfigDeleteRequest,
                DeviceInputConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigDeleteSomeRequest,
                DeviceInputConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigDeleteAllRequest,
                DeviceInputConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigBatchedStreamRequest,
                DeviceInputConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigBatchedStreamRequest,
                DeviceInputConfigBatchedStreamResponse,
            ),
        }


class DeviceStateServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, device_state_request: "DeviceStateRequest"
    ) -> "DeviceStateResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, device_state_some_request: "DeviceStateSomeRequest"
    ) -> AsyncIterator[DeviceStateSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_state_stream_request: "DeviceStateStreamRequest"
    ) -> AsyncIterator[DeviceStateStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, device_state_stream_request: "DeviceStateStreamRequest"
    ) -> AsyncIterator[DeviceStateStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, device_state_stream_request: "DeviceStateStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, device_state_stream_request: "DeviceStateStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, device_state_batched_stream_request: "DeviceStateBatchedStreamRequest"
    ) -> AsyncIterator[DeviceStateBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, device_state_batched_stream_request: "DeviceStateBatchedStreamRequest"
    ) -> AsyncIterator[DeviceStateBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[DeviceStateRequest, DeviceStateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DeviceStateSomeRequest, DeviceStateSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceStateStreamRequest, DeviceStateStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceStateStreamRequest, DeviceStateStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[DeviceStateStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[DeviceStateStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceStateBatchedStreamRequest, DeviceStateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceStateBatchedStreamRequest, DeviceStateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.DeviceStateService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceStateRequest,
                DeviceStateResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateSomeRequest,
                DeviceStateSomeResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateStreamRequest,
                DeviceStateStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateStreamRequest,
                DeviceStateStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceStateStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateBatchedStreamRequest,
                DeviceStateBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateBatchedStreamRequest,
                DeviceStateBatchedStreamResponse,
            ),
        }


class InterfaceInputConfigServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, interface_input_config_request: "InterfaceInputConfigRequest"
    ) -> "InterfaceInputConfigResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, interface_input_config_some_request: "InterfaceInputConfigSomeRequest"
    ) -> AsyncIterator[InterfaceInputConfigSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, interface_input_config_stream_request: "InterfaceInputConfigStreamRequest"
    ) -> AsyncIterator[InterfaceInputConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, interface_input_config_stream_request: "InterfaceInputConfigStreamRequest"
    ) -> AsyncIterator[InterfaceInputConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, interface_input_config_stream_request: "InterfaceInputConfigStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, interface_input_config_stream_request: "InterfaceInputConfigStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, interface_input_config_set_request: "InterfaceInputConfigSetRequest"
    ) -> "InterfaceInputConfigSetResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self,
        interface_input_config_set_some_request: "InterfaceInputConfigSetSomeRequest",
    ) -> AsyncIterator[InterfaceInputConfigSetSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, interface_input_config_delete_request: "InterfaceInputConfigDeleteRequest"
    ) -> "InterfaceInputConfigDeleteResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        interface_input_config_delete_some_request: "InterfaceInputConfigDeleteSomeRequest",
    ) -> AsyncIterator[InterfaceInputConfigDeleteSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        interface_input_config_delete_all_request: "InterfaceInputConfigDeleteAllRequest",
    ) -> AsyncIterator[InterfaceInputConfigDeleteAllResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        interface_input_config_batched_stream_request: "InterfaceInputConfigBatchedStreamRequest",
    ) -> AsyncIterator[InterfaceInputConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        interface_input_config_batched_stream_request: "InterfaceInputConfigBatchedStreamRequest",
    ) -> AsyncIterator[InterfaceInputConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigRequest, InterfaceInputConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigSomeRequest, InterfaceInputConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigStreamRequest, InterfaceInputConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigStreamRequest, InterfaceInputConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigSetRequest, InterfaceInputConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigSetSomeRequest, InterfaceInputConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigDeleteRequest, InterfaceInputConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigDeleteSomeRequest, InterfaceInputConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigDeleteAllRequest, InterfaceInputConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigBatchedStreamRequest, InterfaceInputConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigBatchedStreamRequest, InterfaceInputConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceInputConfigRequest,
                InterfaceInputConfigResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigSomeRequest,
                InterfaceInputConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigStreamRequest,
                InterfaceInputConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigStreamRequest,
                InterfaceInputConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceInputConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceInputConfigSetRequest,
                InterfaceInputConfigSetResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigSetSomeRequest,
                InterfaceInputConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceInputConfigDeleteRequest,
                InterfaceInputConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigDeleteSomeRequest,
                InterfaceInputConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigDeleteAllRequest,
                InterfaceInputConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigBatchedStreamRequest,
                InterfaceInputConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigBatchedStreamRequest,
                InterfaceInputConfigBatchedStreamResponse,
            ),
        }


class ReplaceServiceBase(ServiceBase):
    """ """

    async def get_one(self, replace_request: "ReplaceRequest") -> "ReplaceResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, replace_some_request: "ReplaceSomeRequest"
    ) -> AsyncIterator[ReplaceSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, replace_stream_request: "ReplaceStreamRequest"
    ) -> AsyncIterator[ReplaceStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, replace_stream_request: "ReplaceStreamRequest"
    ) -> AsyncIterator[ReplaceStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, replace_stream_request: "ReplaceStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, replace_stream_request: "ReplaceStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, replace_batched_stream_request: "ReplaceBatchedStreamRequest"
    ) -> AsyncIterator[ReplaceBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, replace_batched_stream_request: "ReplaceBatchedStreamRequest"
    ) -> AsyncIterator[ReplaceBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[ReplaceRequest, ReplaceResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self, stream: "grpclib.server.Stream[ReplaceSomeRequest, ReplaceSomeResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[ReplaceStreamRequest, ReplaceStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[ReplaceStreamRequest, ReplaceStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[ReplaceStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[ReplaceStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[ReplaceBatchedStreamRequest, ReplaceBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[ReplaceBatchedStreamRequest, ReplaceBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.ReplaceService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReplaceRequest,
                ReplaceResponse,
            ),
            "/arista.studio_topology.v1.ReplaceService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceSomeRequest,
                ReplaceSomeResponse,
            ),
            "/arista.studio_topology.v1.ReplaceService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceStreamRequest,
                ReplaceStreamResponse,
            ),
            "/arista.studio_topology.v1.ReplaceService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceStreamRequest,
                ReplaceStreamResponse,
            ),
            "/arista.studio_topology.v1.ReplaceService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReplaceStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.ReplaceService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.ReplaceService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceBatchedStreamRequest,
                ReplaceBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.ReplaceService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceBatchedStreamRequest,
                ReplaceBatchedStreamResponse,
            ),
        }


class ReplaceConfigServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, replace_config_request: "ReplaceConfigRequest"
    ) -> "ReplaceConfigResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, replace_config_some_request: "ReplaceConfigSomeRequest"
    ) -> AsyncIterator[ReplaceConfigSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, replace_config_stream_request: "ReplaceConfigStreamRequest"
    ) -> AsyncIterator[ReplaceConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, replace_config_stream_request: "ReplaceConfigStreamRequest"
    ) -> AsyncIterator[ReplaceConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, replace_config_stream_request: "ReplaceConfigStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, replace_config_stream_request: "ReplaceConfigStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, replace_config_set_request: "ReplaceConfigSetRequest"
    ) -> "ReplaceConfigSetResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, replace_config_set_some_request: "ReplaceConfigSetSomeRequest"
    ) -> AsyncIterator[ReplaceConfigSetSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, replace_config_delete_request: "ReplaceConfigDeleteRequest"
    ) -> "ReplaceConfigDeleteResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, replace_config_delete_some_request: "ReplaceConfigDeleteSomeRequest"
    ) -> AsyncIterator[ReplaceConfigDeleteSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, replace_config_delete_all_request: "ReplaceConfigDeleteAllRequest"
    ) -> AsyncIterator[ReplaceConfigDeleteAllResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, replace_config_batched_stream_request: "ReplaceConfigBatchedStreamRequest"
    ) -> AsyncIterator[ReplaceConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, replace_config_batched_stream_request: "ReplaceConfigBatchedStreamRequest"
    ) -> AsyncIterator[ReplaceConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigRequest, ReplaceConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigSomeRequest, ReplaceConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigStreamRequest, ReplaceConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigStreamRequest, ReplaceConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[ReplaceConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[ReplaceConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigSetRequest, ReplaceConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigSetSomeRequest, ReplaceConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigDeleteRequest, ReplaceConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigDeleteSomeRequest, ReplaceConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigDeleteAllRequest, ReplaceConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigBatchedStreamRequest, ReplaceConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[ReplaceConfigBatchedStreamRequest, ReplaceConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.ReplaceConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReplaceConfigRequest,
                ReplaceConfigResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigSomeRequest,
                ReplaceConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigStreamRequest,
                ReplaceConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigStreamRequest,
                ReplaceConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReplaceConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReplaceConfigSetRequest,
                ReplaceConfigSetResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigSetSomeRequest,
                ReplaceConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                ReplaceConfigDeleteRequest,
                ReplaceConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigDeleteSomeRequest,
                ReplaceConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigDeleteAllRequest,
                ReplaceConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigBatchedStreamRequest,
                ReplaceConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.ReplaceConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReplaceConfigBatchedStreamRequest,
                ReplaceConfigBatchedStreamResponse,
            ),
        }


class RevertConfigServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, revert_config_request: "RevertConfigRequest"
    ) -> "RevertConfigResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, revert_config_some_request: "RevertConfigSomeRequest"
    ) -> AsyncIterator[RevertConfigSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, revert_config_stream_request: "RevertConfigStreamRequest"
    ) -> AsyncIterator[RevertConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, revert_config_stream_request: "RevertConfigStreamRequest"
    ) -> AsyncIterator[RevertConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, revert_config_stream_request: "RevertConfigStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, revert_config_stream_request: "RevertConfigStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, revert_config_set_request: "RevertConfigSetRequest"
    ) -> "RevertConfigSetResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, revert_config_set_some_request: "RevertConfigSetSomeRequest"
    ) -> AsyncIterator[RevertConfigSetSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, revert_config_delete_request: "RevertConfigDeleteRequest"
    ) -> "RevertConfigDeleteResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, revert_config_delete_some_request: "RevertConfigDeleteSomeRequest"
    ) -> AsyncIterator[RevertConfigDeleteSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, revert_config_delete_all_request: "RevertConfigDeleteAllRequest"
    ) -> AsyncIterator[RevertConfigDeleteAllResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, revert_config_batched_stream_request: "RevertConfigBatchedStreamRequest"
    ) -> AsyncIterator[RevertConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, revert_config_batched_stream_request: "RevertConfigBatchedStreamRequest"
    ) -> AsyncIterator[RevertConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[RevertConfigRequest, RevertConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[RevertConfigSomeRequest, RevertConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[RevertConfigStreamRequest, RevertConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[RevertConfigStreamRequest, RevertConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[RevertConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[RevertConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[RevertConfigSetRequest, RevertConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[RevertConfigSetSomeRequest, RevertConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[RevertConfigDeleteRequest, RevertConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[RevertConfigDeleteSomeRequest, RevertConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[RevertConfigDeleteAllRequest, RevertConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[RevertConfigBatchedStreamRequest, RevertConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[RevertConfigBatchedStreamRequest, RevertConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.RevertConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevertConfigRequest,
                RevertConfigResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigSomeRequest,
                RevertConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigStreamRequest,
                RevertConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigStreamRequest,
                RevertConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevertConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevertConfigSetRequest,
                RevertConfigSetResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigSetSomeRequest,
                RevertConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevertConfigDeleteRequest,
                RevertConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigDeleteSomeRequest,
                RevertConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigDeleteAllRequest,
                RevertConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigBatchedStreamRequest,
                RevertConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigBatchedStreamRequest,
                RevertConfigBatchedStreamResponse,
            ),
        }


class UpdateServiceBase(ServiceBase):
    """ """

    async def get_one(self, update_request: "UpdateRequest") -> "UpdateResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, update_some_request: "UpdateSomeRequest"
    ) -> AsyncIterator[UpdateSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, update_stream_request: "UpdateStreamRequest"
    ) -> AsyncIterator[UpdateStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, update_stream_request: "UpdateStreamRequest"
    ) -> AsyncIterator[UpdateStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, update_stream_request: "UpdateStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, update_stream_request: "UpdateStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, update_batched_stream_request: "UpdateBatchedStreamRequest"
    ) -> AsyncIterator[UpdateBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, update_batched_stream_request: "UpdateBatchedStreamRequest"
    ) -> AsyncIterator[UpdateBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[UpdateRequest, UpdateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self, stream: "grpclib.server.Stream[UpdateSomeRequest, UpdateSomeResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[UpdateStreamRequest, UpdateStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[UpdateStreamRequest, UpdateStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[UpdateStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[UpdateStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[UpdateBatchedStreamRequest, UpdateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[UpdateBatchedStreamRequest, UpdateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.UpdateService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateRequest,
                UpdateResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSomeRequest,
                UpdateSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateStreamRequest,
                UpdateStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateStreamRequest,
                UpdateStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateBatchedStreamRequest,
                UpdateBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateBatchedStreamRequest,
                UpdateBatchedStreamResponse,
            ),
        }


class UpdateConfigServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, update_config_request: "UpdateConfigRequest"
    ) -> "UpdateConfigResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, update_config_some_request: "UpdateConfigSomeRequest"
    ) -> AsyncIterator[UpdateConfigSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, update_config_stream_request: "UpdateConfigStreamRequest"
    ) -> AsyncIterator[UpdateConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, update_config_stream_request: "UpdateConfigStreamRequest"
    ) -> AsyncIterator[UpdateConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, update_config_stream_request: "UpdateConfigStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, update_config_stream_request: "UpdateConfigStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, update_config_set_request: "UpdateConfigSetRequest"
    ) -> "UpdateConfigSetResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, update_config_set_some_request: "UpdateConfigSetSomeRequest"
    ) -> AsyncIterator[UpdateConfigSetSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, update_config_delete_request: "UpdateConfigDeleteRequest"
    ) -> "UpdateConfigDeleteResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, update_config_delete_some_request: "UpdateConfigDeleteSomeRequest"
    ) -> AsyncIterator[UpdateConfigDeleteSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, update_config_delete_all_request: "UpdateConfigDeleteAllRequest"
    ) -> AsyncIterator[UpdateConfigDeleteAllResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, update_config_batched_stream_request: "UpdateConfigBatchedStreamRequest"
    ) -> AsyncIterator[UpdateConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, update_config_batched_stream_request: "UpdateConfigBatchedStreamRequest"
    ) -> AsyncIterator[UpdateConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[UpdateConfigRequest, UpdateConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[UpdateConfigSomeRequest, UpdateConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[UpdateConfigStreamRequest, UpdateConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[UpdateConfigStreamRequest, UpdateConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[UpdateConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[UpdateConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[UpdateConfigSetRequest, UpdateConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[UpdateConfigSetSomeRequest, UpdateConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[UpdateConfigDeleteRequest, UpdateConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[UpdateConfigDeleteSomeRequest, UpdateConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[UpdateConfigDeleteAllRequest, UpdateConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[UpdateConfigBatchedStreamRequest, UpdateConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[UpdateConfigBatchedStreamRequest, UpdateConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.UpdateConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateConfigRequest,
                UpdateConfigResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigSomeRequest,
                UpdateConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigStreamRequest,
                UpdateConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigStreamRequest,
                UpdateConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateConfigSetRequest,
                UpdateConfigSetResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigSetSomeRequest,
                UpdateConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateConfigDeleteRequest,
                UpdateConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigDeleteSomeRequest,
                UpdateConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigDeleteAllRequest,
                UpdateConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigBatchedStreamRequest,
                UpdateConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigBatchedStreamRequest,
                UpdateConfigBatchedStreamResponse,
            ),
        }


class UpdateSyncConfigServiceBase(ServiceBase):
    """ """

    async def get_one(
        self, update_sync_config_request: "UpdateSyncConfigRequest"
    ) -> "UpdateSyncConfigResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, update_sync_config_some_request: "UpdateSyncConfigSomeRequest"
    ) -> AsyncIterator[UpdateSyncConfigSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, update_sync_config_stream_request: "UpdateSyncConfigStreamRequest"
    ) -> AsyncIterator[UpdateSyncConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, update_sync_config_stream_request: "UpdateSyncConfigStreamRequest"
    ) -> AsyncIterator[UpdateSyncConfigStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, update_sync_config_stream_request: "UpdateSyncConfigStreamRequest"
    ) -> "MetaResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, update_sync_config_stream_request: "UpdateSyncConfigStreamRequest"
    ) -> AsyncIterator[MetaResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, update_sync_config_set_request: "UpdateSyncConfigSetRequest"
    ) -> "UpdateSyncConfigSetResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, update_sync_config_set_some_request: "UpdateSyncConfigSetSomeRequest"
    ) -> AsyncIterator[UpdateSyncConfigSetSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, update_sync_config_delete_request: "UpdateSyncConfigDeleteRequest"
    ) -> "UpdateSyncConfigDeleteResponse":
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        update_sync_config_delete_some_request: "UpdateSyncConfigDeleteSomeRequest",
    ) -> AsyncIterator[UpdateSyncConfigDeleteSomeResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, update_sync_config_delete_all_request: "UpdateSyncConfigDeleteAllRequest"
    ) -> AsyncIterator[UpdateSyncConfigDeleteAllResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        update_sync_config_batched_stream_request: "UpdateSyncConfigBatchedStreamRequest",
    ) -> AsyncIterator[UpdateSyncConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        update_sync_config_batched_stream_request: "UpdateSyncConfigBatchedStreamRequest",
    ) -> AsyncIterator[UpdateSyncConfigBatchedStreamResponse]:
        """ """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigRequest, UpdateSyncConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigSomeRequest, UpdateSyncConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigStreamRequest, UpdateSyncConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigStreamRequest, UpdateSyncConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigSetRequest, UpdateSyncConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigSetSomeRequest, UpdateSyncConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigDeleteRequest, UpdateSyncConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigDeleteSomeRequest, UpdateSyncConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigDeleteAllRequest, UpdateSyncConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigBatchedStreamRequest, UpdateSyncConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigBatchedStreamRequest, UpdateSyncConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateSyncConfigRequest,
                UpdateSyncConfigResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigSomeRequest,
                UpdateSyncConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigStreamRequest,
                UpdateSyncConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigStreamRequest,
                UpdateSyncConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateSyncConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateSyncConfigSetRequest,
                UpdateSyncConfigSetResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigSetSomeRequest,
                UpdateSyncConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateSyncConfigDeleteRequest,
                UpdateSyncConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigDeleteSomeRequest,
                UpdateSyncConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigDeleteAllRequest,
                UpdateSyncConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigBatchedStreamRequest,
                UpdateSyncConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigBatchedStreamRequest,
                UpdateSyncConfigBatchedStreamResponse,
            ),
        }
