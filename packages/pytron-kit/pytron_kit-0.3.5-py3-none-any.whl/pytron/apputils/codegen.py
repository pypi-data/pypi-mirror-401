import os
import inspect
import typing
from ..webview import Webview

try:
    import pydantic
except ImportError:
    pydantic = None


class CodegenMixin:
    """
    Mixin class to handle TypeScript generation.
    """

    def generate_types(self, output_path="frontend/src/pytron.d.ts"):
        """
        Generates TypeScript definitions for all exposed functions.
        """
        ts_lines = [
            "// Auto-generated by Pytron. Do not edit manually.",
            "// This file provides type definitions for the Pytron client.",
            "",
            "declare module 'pytron-client' {",
        ]

        # 0. Add Pydantic Interfaces
        processed_models = set()
        while True:
            current_models = set(self._pydantic_models.keys())
            new_models = current_models - processed_models
            if not new_models:
                break

            for model_name in new_models:
                model_cls = self._pydantic_models[model_name]
                ts_lines.append(
                    self._generate_pydantic_interface(model_name, model_cls)
                )
                processed_models.add(model_name)

        ts_lines.append("")
        ts_lines.append("  export interface PytronClient {")
        ts_lines.append("    /**")
        ts_lines.append("     * Local state cache synchronized with the backend.")
        ts_lines.append("     */")
        ts_lines.append("    state: Record<string, any>;")
        ts_lines.append("")
        ts_lines.append("    /**")
        ts_lines.append("     * Listen for an event sent from the Python backend.")
        ts_lines.append("     */")
        ts_lines.append("    on(event: string, callback: (data: any) => void): void;")
        ts_lines.append("")
        ts_lines.append("    /**")
        ts_lines.append("     * Remove an event listener.")
        ts_lines.append("     */")
        ts_lines.append("    off(event: string, callback: (data: any) => void): void;")
        ts_lines.append("")
        ts_lines.append("    /**")
        ts_lines.append("     * Wait for the backend to be connected.")
        ts_lines.append("     */")
        ts_lines.append("    waitForBackend(timeout?: number): Promise<void>;")
        ts_lines.append("")
        ts_lines.append("    /**")
        ts_lines.append("     * Log a message to the Python console.")
        ts_lines.append("     */")
        ts_lines.append("    log(message: string): Promise<void>;")
        ts_lines.append("")

        # 1. Add User Exposed Functions (pre-calculated in expose)
        for def_str in self._exposed_ts_defs.values():
            ts_lines.append(def_str)

        # 3. Add Window methods
        # Map exposed name to Window class method name
        win_map = {
            "minimize": "minimize",
            "toggle_maximize": "toggle_maximize",
            "close": "close",
            "hide": "hide",
            "show": "show",
            "notify": "notify",
            "start_drag": "start_drag",
            "set_title": "set_title",
            "set_size": "set_size",
            "center": "center",
            "system_notification": "system_notification",
            "set_bounds": "set_bounds",
        }
        for exposed_name, method_name in win_map.items():
            method = getattr(Webview, method_name, None)
            if method:
                ts_lines.append(self._get_ts_definition(exposed_name, method))
        # 4. Add dynamic methods that are not on Window class
        ts_lines.append("    trigger_shortcut(combo: string): Promise<boolean>;")
        ts_lines.append("    get_registered_shortcuts(): Promise<string[]>;")

        ts_lines.append("  }")
        ts_lines.append("")
        ts_lines.append("  const pytron: PytronClient;")
        ts_lines.append("  export default pytron;")
        ts_lines.append("}")

        # Ensure directory exists
        dirname = os.path.dirname(output_path)
        if dirname and not os.path.exists(dirname):
            try:
                os.makedirs(dirname)
            except Exception as e:
                self.logger.error(
                    f"Failed to create directory for typescript definitions: {e}"
                )

        try:
            with open(output_path, "w") as f:
                f.write("\n".join(ts_lines))
            self.logger.info(f"Generated TypeScript definitions at {output_path}")
        except Exception as e:
            self.logger.error(f"Failed to write TypeScript definitions: {e}")

    def _get_ts_definition(self, name, func):
        """
        Generate TypeScript definition for a given function.
        """
        try:
            sig = inspect.signature(func)
            params = []

            for param_name, param in sig.parameters.items():
                if param_name == "self":
                    continue

                py_type = param.annotation
                ts_type = self._python_type_to_ts(py_type)
                if py_type == inspect.Parameter.empty:
                    ts_type = "any"

                params.append(f"{param_name}: {ts_type}")

            param_str = ", ".join(params)

            return_annotation = sig.return_annotation
            ts_return = self._python_type_to_ts(return_annotation)
            if return_annotation == inspect.Parameter.empty:
                ts_return = "any"

            lines = []
            doc = inspect.getdoc(func)
            if doc:
                lines.append("    /**")
                for line in doc.split("\n"):
                    lines.append(f"     * {line}")
                lines.append("     */")

            lines.append(f"    {name}({param_str}): Promise<{ts_return}>;")
            return "\n".join(lines)

        except Exception as e:
            self.logger.warning(f"Could not generate types for {name}: {e}")
            return f"    {name}(...args: any[]): Promise<any>;"

    def _generate_pydantic_interface(self, model_name, model_cls):
        """
        Generate TypeScript interface for a Pydantic model.
        """
        lines = [f"  export interface {model_name} {{"]

        # Pydantic v1 vs v2
        fields = {}
        if hasattr(model_cls, "model_fields"):  # v2
            fields = model_cls.model_fields
        elif hasattr(model_cls, "__fields__"):  # v1
            fields = model_cls.__fields__

        for field_name, field in fields.items():
            # Get type annotation
            if hasattr(field, "annotation"):  # v2
                py_type = field.annotation
            elif hasattr(field, "type_"):  # v1
                py_type = field.type_
            else:
                py_type = typing.Any

            ts_type = self._python_type_to_ts(py_type)

            # Check if optional
            is_optional = False
            if hasattr(field, "is_required"):  # v2
                is_optional = not field.is_required()
            elif hasattr(field, "required"):  # v1
                is_optional = not field.required

            suffix = "?" if is_optional else ""
            lines.append(f"    {field_name}{suffix}: {ts_type};")

        lines.append("  }")
        return "\n".join(lines)

    def _python_type_to_ts(self, py_type):
        if py_type == str:
            return "string"
        if py_type == int:
            return "number"
        if py_type == float:
            return "number"
        if py_type == bool:
            return "boolean"
        if py_type == type(None):
            return "void"
        if py_type == list:
            return "any[]"
        if py_type == dict:
            return "Record<string, any>"

        # Handle Pydantic Models
        if (
            pydantic
            and isinstance(py_type, type)
            and issubclass(py_type, pydantic.BaseModel)
        ):
            model_name = py_type.__name__
            self._pydantic_models[model_name] = py_type
            return model_name

        # Handle typing module
        origin = getattr(py_type, "__origin__", None)
        args = getattr(py_type, "__args__", ())

        if origin is list or origin is typing.List:
            if args:
                return f"{self._python_type_to_ts(args[0])}[]"
            return "any[]"

        if origin is dict or origin is typing.Dict:
            if args and len(args) == 2:
                k = self._python_type_to_ts(args[0])
                v = self._python_type_to_ts(args[1])
                if k == "number":
                    return f"Record<number, {v}>"
                return f"Record<string, {v}>"
            return "Record<string, any>"

        if origin is typing.Union:
            non_none = [t for t in args if t != type(None)]
            # Check for pydantic models inside Union
            if pydantic:
                for t in non_none:
                    if isinstance(t, type) and issubclass(t, pydantic.BaseModel):
                        self._pydantic_models[t.__name__] = t

            if len(non_none) == len(args):
                return " | ".join([self._python_type_to_ts(t) for t in args])
            else:
                if len(non_none) == 1:
                    return f"{self._python_type_to_ts(non_none[0])} | null"
                return (
                    " | ".join([self._python_type_to_ts(t) for t in non_none])
                    + " | null"
                )
        return "any"
