"""
{{ agent_name }} - A2A Server Main Entry Point

This module initializes and starts the A2A server for {{ agent_name }}.
Auto-generated for the {{ agent_name }} utility agent.
Supports HTTP/2 multiplexing and SSE streaming.
"""

import logging
import os
import json
import ssl
from pathlib import Path
from typing import AsyncIterator, Dict, Any, Optional
import asyncio
import uuid
from datetime import datetime
import time
import tempfile
import subprocess

from a2a.server.apps import A2AStarletteApplication
from a2a.types import AgentCard, AgentSkill, AgentCapabilities
from a2a.server.tasks import InMemoryTaskStore
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.events.event_queue import EventQueue
import uvicorn
from starlette.responses import StreamingResponse, JSONResponse
from starlette.requests import Request
from starlette.routing import Route
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.middleware.cors import CORSMiddleware
from starlette.responses import Response

# Import D402 payment middleware and helpers (generalized version)
from traia_iatp.d402.servers import D402PaymentMiddleware, build_payment_config
from traia_iatp.d402.asgi_wrapper import D402ASGIWrapper
from traia_iatp.d402 import D402PriceBuilder

# Import httpx for MCP server verification
import httpx

# Import AgentOps for monitoring and observability
try:
    import agentops
    AGENTOPS_AVAILABLE = True
except ImportError:
    AGENTOPS_AVAILABLE = False
    agentops = None


import sys
from pathlib import Path
# Add parent directory to path to import mcp_agent_template
sys.path.insert(0, str(Path(__file__).parent.parent))
from traia_iatp.mcp import MCPServerConfig
from .agent_executor import {{ class_name }}AgentExecutor

# Configure logging FIRST (before any logger usage)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# D402 payment support is configured via environment variables and handled by middleware
# The D402PaymentMiddleware is added to the Starlette app based on .env configuration
# No additional imports needed here - middleware handles all D402 logic
D402_AVAILABLE = os.getenv("D402_ENABLED", "false").lower() == "true"
if D402_AVAILABLE:
    logger.info("‚úÖ D402 payment support enabled (configured via environment)")
else:
    logger.info("‚ÑπÔ∏è  D402 payment support disabled (set D402_ENABLED=true to enable)")

# Enable debug logging for HTTP/2 and connection events if requested
if os.environ.get("DEBUG_PROTOCOL", "false").lower() == "true":
    logging.getLogger("hypercorn.access").setLevel(logging.DEBUG)
    logging.getLogger("hypercorn.error").setLevel(logging.DEBUG)
    logging.getLogger("httpcore").setLevel(logging.DEBUG)
    logging.getLogger("httpx").setLevel(logging.DEBUG)
    logging.getLogger("h2").setLevel(logging.DEBUG)
    logging.getLogger("a2a").setLevel(logging.DEBUG)
    logger.setLevel(logging.DEBUG)
    logger.info("Protocol-level debug logging enabled")


class ProtocolLoggingMiddleware(BaseHTTPMiddleware):
    """Middleware to log HTTP protocol details for debugging."""
    
    def __init__(self, app):
        super().__init__(app)
        self.request_counter = 0
    
    async def dispatch(self, request: Request, call_next):
        self.request_counter += 1
        request_id = self.request_counter
        
        # Log request details
        logger.info(f"[Request {request_id}] {request.method} {request.url.path}")
        logger.info(f"[Request {request_id}] Client: {request.client}")
        logger.info(f"[Request {request_id}] Headers: {dict(request.headers)}")
        
        # Check HTTP version
        http_version = request.scope.get("http_version", "unknown")
        logger.info(f"[Request {request_id}] HTTP Version: {http_version}")
        
        # Check if it's HTTP/2
        if http_version == "2.0":
            logger.info(f"[Request {request_id}] ‚úÖ HTTP/2 connection detected")
            stream_id = request.scope.get("stream_id", "unknown")
            logger.info(f"[Request {request_id}] HTTP/2 Stream ID: {stream_id}")
        else:
            logger.info(f"[Request {request_id}] ‚ö†Ô∏è  HTTP/1.1 connection (not HTTP/2)")
        
        # Time the request
        start_time = time.time()
        
        # Process the request
        response = await call_next(request)
        
        # Log response details
        process_time = time.time() - start_time
        logger.info(f"[Request {request_id}] Response Status: {response.status_code}")
        logger.info(f"[Request {request_id}] Process Time: {process_time:.3f}s")
        
        return response


# Global state for MCP connection tracking
mcp_connection_status = {
    "verified": False,
    "last_checked": None,
    "error": None
}

async def verify_mcp_connection(mcp_url: str, mcp_name: str) -> bool:
    """
    Verify connection to the MCP server by testing endpoints.
    Returns True if connection is working, False otherwise.
    """
    global mcp_connection_status
    
    try:
        logger.info(f"üîç Verifying MCP server connection to: {mcp_url}")
        
        # Increased timeout for Cloud Run cold starts (MCP server may need time to wake up)
        async with httpx.AsyncClient(timeout=60.0) as client:
            # Try to test the MCP server is reachable
            # First try .well-known/mcp.json (if available)
            card_url = f"{mcp_url}/.well-known/mcp.json"
            logger.info(f"   Trying MCP card at: {card_url}")
            
            try:
                response = await client.get(card_url)
                response.raise_for_status()
                
                mcp_card = response.json()
                logger.info(f"   ‚úÖ MCP card fetched successfully")
                logger.info(f"   MCP Server: {mcp_card.get('name', 'Unknown')}")
                logger.info(f"   Capabilities: {len(mcp_card.get('capabilities', []))} tools")
            except Exception as e:
                # Well-known endpoint not available - that's OK for some MCP servers
                logger.info(f"   ‚ÑπÔ∏è  MCP card not available (some servers don't expose it): {e}")
            
            # Test the MCP endpoint properly (like the tests do)
            logger.info(f"   Testing MCP JSON-RPC endpoint: {mcp_url}")
            
            # Step 1: Initialize MCP session (required before tools/list)
            init_request = {
                "jsonrpc": "2.0",
                "method": "initialize",
                "id": "verify-init",
                "params": {
                    "protocolVersion": "2024-11-05",
                    "capabilities": {},
                    "clientInfo": {"name": "utility-agent-verifier", "version": "1.0"}
                }
            }
            
            init_response = await client.post(
                mcp_url,
                json=init_request,
                headers={
                    "Content-Type": "application/json",
                    "Accept": "application/json, text/event-stream"
                }
            )
            init_response.raise_for_status()
            
            session_id = init_response.headers.get("mcp-session-id")
            if session_id:
                logger.info(f"   ‚úÖ MCP session initialized: {session_id[:20]}...")
            else:
                logger.warning(f"   ‚ö†Ô∏è  No session ID returned (may be OK for some servers)")
            
            # Step 2: Test tools/list with session
            list_request = {
                "jsonrpc": "2.0",
                "method": "tools/list",
                "id": "verify-list"
            }
            
            list_headers = {
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream"
            }
            if session_id:
                list_headers["mcp-session-id"] = session_id
            
            list_response = await client.post(
                mcp_url,
                json=list_request,
                headers=list_headers
            )
            list_response.raise_for_status()
            
            logger.info(f"   ‚úÖ MCP server responding correctly (HTTP {list_response.status_code})")
            
            # Update connection status
            mcp_connection_status["verified"] = True
            mcp_connection_status["last_checked"] = datetime.now()
            mcp_connection_status["error"] = None
            
            logger.info(f"‚úÖ MCP server connection verified successfully!")
            return True
            
    except httpx.HTTPError as e:
        error_msg = f"HTTP error connecting to MCP server: {e}"
        logger.error(f"‚ùå {error_msg}")
        mcp_connection_status["verified"] = False
        mcp_connection_status["last_checked"] = datetime.now()
        mcp_connection_status["error"] = error_msg
        return False
    except Exception as e:
        error_msg = f"Unexpected error verifying MCP connection: {e}"
        logger.error(f"‚ùå {error_msg}")
        mcp_connection_status["verified"] = False
        mcp_connection_status["last_checked"] = datetime.now()
        mcp_connection_status["error"] = error_msg
        return False


class StreamingRequestHandler(DefaultRequestHandler):
    """Extended request handler with SSE streaming support."""
    
    def __init__(self, agent_executor, task_store):
        super().__init__(agent_executor, task_store)
        self._active_streams: Dict[str, EventQueue] = {}
    
    async def handle_subscribe(self, request: Dict[str, Any]) -> StreamingResponse:
        """Handle tasks/sendSubscribe requests for SSE streaming."""
        params = request.get("params", {})
        task_id = params.get("id")
        history_length = params.get("historyLength", 0)
        
        if not task_id:
            return {"error": {"code": -32602, "message": "Missing task ID"}}
        
        # Get or create event queue for this task
        event_queue = self._active_streams.get(task_id)
        if not event_queue:
            event_queue = EventQueue()
            self._active_streams[task_id] = event_queue
        
        async def event_generator():
            """Generate SSE events."""
            try:
                # Send initial connection event
                yield f"data: {json.dumps({'type': 'connection', 'status': 'connected', 'task_id': task_id})}\n\n"
                
                # Send history if requested
                if history_length > 0:
                    # TODO: Implement history retrieval from task store
                    pass
                
                # Stream events
                event_count = 0
                while True:
                    try:
                        # Wait for events with timeout
                        event = await asyncio.wait_for(
                            event_queue.dequeue_event(),
                            timeout=30.0  # 30 second timeout
                        )
                        
                        if event:
                            event_count += 1
                            # Handle different event types
                            if hasattr(event, 'type') and hasattr(event, 'data'):
                                event_data = {
                                    "type": event.type,
                                    "sequence": event_count,
                                    "timestamp": datetime.utcnow().isoformat(),
                                    "data": event.data
                                }
                            else:
                                # Fallback for simple message events
                                event_data = {
                                    "type": "message",
                                    "sequence": event_count,
                                    "timestamp": datetime.utcnow().isoformat(),
                                    "data": str(event)
                                }
                            yield f"data: {json.dumps(event_data)}\n\n"
                            
                            # Check for completion
                            if hasattr(event, 'type') and event.type == "status" and hasattr(event, 'data') and event.data.get("state") in ["COMPLETED", "FAILED"]:
                                yield "data: [DONE]\n\n"
                                break
                    except asyncio.TimeoutError:
                        # Send keepalive
                        yield f"data: {json.dumps({'type': 'keepalive', 'timestamp': datetime.utcnow().isoformat()})}\n\n"
                        
            except Exception as e:
                logger.error(f"Error in SSE stream: {e}")
                yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"
            finally:
                # Cleanup
                if task_id in self._active_streams:
                    del self._active_streams[task_id]
        
        return StreamingResponse(
            event_generator(),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "X-Accel-Buffering": "no"  # Disable nginx buffering
            }
        )
    
    async def handle_resubscribe(self, request: Dict[str, Any]) -> StreamingResponse:
        """Handle tasks/resubscribe requests to resume SSE streaming."""
        # Resubscribe uses the same logic as subscribe
        # but may start from a different history point
        return await self.handle_subscribe(request)


def create_app():
    """Create and configure the A2A application with SSE support."""
    
    # Load agent configuration if it exists
    config_path = "agent_config.json"
    if os.path.exists(config_path):
        with open(config_path, "r") as f:
            config_data = json.load(f)
        mcp_data = config_data.get("mcp_server", {})
    else:
        # Use template variables directly
        mcp_data = {
            "name": "{{ mcp_server_name }}",
            "url": "{{ mcp_server_url }}",
            "description": "{{ mcp_server_description }}",
            "server_type": "{{ mcp_server_type }}",
            "capabilities": {{ mcp_server_capabilities | tojson }},
            "metadata": {{ mcp_server_metadata | tojson }}
        }
    
    # Create MCP server configuration
    mcp_config = MCPServerConfig(
        name=mcp_data["name"],
        url=mcp_data["url"],
        description=mcp_data["description"],
        server_type=mcp_data.get("server_type", "streamable-http"),
        capabilities=mcp_data.get("capabilities", []),
        metadata=mcp_data.get("metadata", {})
    )
    
    # Check if MCP server supports streaming
    supports_streaming = mcp_data.get("server_type") == "streamable-http" or \
                        "stream" in mcp_data.get("capabilities", [])
    
    # D402 Configuration (if enabled) - for A2A endpoint protection
    d402_enabled = D402_AVAILABLE and os.getenv("D402_ENABLED", "false").lower() == "true"
    d402_token_amount = None
    
    if d402_enabled:
        logger.info("‚úÖ D402 payments enabled")
        
        contract_address = os.getenv("UTILITY_AGENT_CONTRACT_ADDRESS")
        token_address = os.getenv("D402_TOKEN_ADDRESS")
        token_symbol = os.getenv("D402_TOKEN_SYMBOL", "USDC")
        token_decimals = int(os.getenv("D402_TOKEN_DECIMALS", "6"))
        network = os.getenv("D402_NETWORK", "sepolia")
        facilitator_url = os.getenv("D402_FACILITATOR_URL", "http://localhost:7070")
        operator_key = os.getenv("UTILITY_AGENT_OPERATOR_PRIVATE_KEY")
        testing_mode = os.getenv("D402_TESTING_MODE", "false").lower() == "true"
        
        if not contract_address:
            logger.error("‚ùå D402 enabled but UTILITY_AGENT_CONTRACT_ADDRESS not set!")
            d402_enabled = False
        elif not token_address:
            logger.error("‚ùå D402 enabled but D402_TOKEN_ADDRESS not set!")
            d402_enabled = False
        else:
            # Use D402PriceBuilder for clean price creation
            usd_price = float(os.getenv("D402_PRICE_USD", "0.01"))
            
            price_builder = D402PriceBuilder(
                token_address=token_address,
                token_decimals=token_decimals,
                network=network,
                token_symbol=token_symbol
            )
            
            d402_token_amount = price_builder.create_price(usd_price)
            
            logger.info(f"üí∞ D402 Price: ${usd_price} USD ({d402_token_amount.amount} wei with {token_decimals} decimals)")
            logger.info(f"üìç Pay to: {contract_address}")
            logger.info(f"üåê Network: {network}")
            logger.info(f"ü™ô  Token: {token_symbol} ({token_address})")
            logger.info(f"üîó Facilitator: {facilitator_url}")
            logger.info(f"üß™ Testing mode: {testing_mode}")
    
    # Create agent skills based on MCP capabilities
    skills = []
    
    # Add main processing skill
    main_skill = AgentSkill(
        id="process_request",
        name=f"Process request using {{ agent_name }}",
        description="{{ agent_description }}",
        examples=[
            {% for example in skill_examples %}
            "{{ example }}",
            {% endfor %}
        ],
        inputModes=["text", "text/plain"],
        outputModes=["text", "text/plain", "text/event-stream"] if supports_streaming else ["text", "text/plain"],
        tags=[
            "mcp", "{{ mcp_server_name }}", "utility",
            {% if mcp_server_metadata.tags %}
            {% for tag in mcp_server_metadata.tags %}
            "{{ tag }}",
            {% endfor %}
            {% endif %}
            {% for capability in mcp_server_capabilities[:5] %}
            "{{ capability }}",
            {% endfor %}
        ]
    )
    skills.append(main_skill)
    
    {% if expose_individual_tools %}
    # Add individual MCP tool skills
    {% for capability in mcp_server_capabilities %}
    skill_{{ loop.index }} = AgentSkill(
        id="mcp_{{ capability }}",
        name="Execute {{ capability }}",
        description="Execute {{ capability }} tool on MCP server",
        examples=[f"Run {{ capability }} with these parameters"],
        inputModes=["text", "text/plain"],
        outputModes=["text", "text/plain", "text/event-stream"] if supports_streaming else ["text", "text/plain"],
        tags=["mcp", "{{ mcp_server_name }}", "{{ capability }}"]
    )
    skills.append(skill_{{ loop.index }})
    {% endfor %}
    {% endif %}
    
    # Create capabilities with streaming support if available
    capabilities = AgentCapabilities(
        streaming=supports_streaming,  # Enable streaming if MCP server supports it
        pushNotifications=False,  # Can be extended to support push notifications
        stateTransitionHistory=True  # Enable for SSE history support
    )
    
    # Authentication can be added here if needed in the future
    # Currently the A2A protocol handles authentication at a different layer
    
    # Create agent card with proper URL
    # For Cloud Run: use PUBLIC_URL environment variable
    # For local: use http://0.0.0.0:{port}/a2a
    public_url = os.environ.get("PUBLIC_URL") or os.environ.get("SERVICE_URL")
    if public_url:
        # Cloud Run - use public URL with /a2a endpoint
        agent_url = f"{public_url}/a2a"
    else:
        # Local - use 0.0.0.0:{port}
        agent_url = f"http://0.0.0.0:{os.environ.get('PORT', 8000)}/a2a"
    
    agent_card_dict = {
        "name": "{{ agent_id }}",
        "description": "{{ agent_description }}",
        "url": agent_url,
        "version": "{{ agent_version }}",
        "capabilities": capabilities.model_dump(),
        "skills": [s.model_dump() for s in skills],
        "defaultInputModes": ["text", "text/plain"],
        "defaultOutputModes": ["text", "text/plain", "text/event-stream"] if supports_streaming else ["text", "text/plain"]
    }
    
    # D402 payment info is automatically added to agent card by middleware
    agent_card = AgentCard(**agent_card_dict)
    
    # Create executor with MCP config
    executor = {{ class_name }}AgentExecutor(mcp_config, supports_streaming=supports_streaming)
    
    # Create task store and request handler with streaming support
    task_store = InMemoryTaskStore()
    request_handler = StreamingRequestHandler(
        agent_executor=executor,
        task_store=task_store
    )
    
    # Create the A2A application
    app = A2AStarletteApplication(
        agent_card=agent_card,
        http_handler=request_handler
    )
    
    # Build the Starlette app with A2A JSON-RPC endpoint at /a2a
    # Add D402 middleware using Starlette's raw ASGI wrapper if enabled
    if d402_enabled and d402_token_amount:
        logger.info("‚úÖ Configuring D402 payment middleware for A2A endpoints")
        
        # Get D402 configuration from environment
        contract_address = os.getenv("UTILITY_AGENT_CONTRACT_ADDRESS")
        facilitator_url = os.getenv("D402_FACILITATOR_URL", "http://localhost:7070")
        operator_key = os.getenv("UTILITY_AGENT_OPERATOR_PRIVATE_KEY")
        testing_mode = os.getenv("D402_TESTING_MODE", "false").lower() == "true"
        
        # Build payment configs for A2A endpoint
        endpoint_payment_configs = {
            "/a2a": build_payment_config(
                price=d402_token_amount,
                server_address=contract_address,
                description="{{ agent_description }}"
            )
        }
        
        logger.info(f"   üí≥ Middleware configured for {len(endpoint_payment_configs)} endpoint(s)")
        logger.info(f"   üîí Protected paths: {list(endpoint_payment_configs.keys())}")
        logger.info(f"   üîê Requires auth: False (payment-only)")
        logger.info(f"   üß™ Testing mode: {testing_mode}")
        
        # Build Starlette app first (without middleware)
        starlette_app = app.build(rpc_url='/a2a')
        
        # Add CORS middleware to allow all origins
        starlette_app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],  # Allow all origins
            allow_credentials=True,
            allow_methods=["*"],  # Allow all methods
            allow_headers=["*"],  # Allow all headers
        )
        logger.info("‚úÖ Added CORS middleware (allow all origins)")
        
        # Wrap with raw ASGI wrapper (bypasses Starlette middleware issues)
        # This intercepts at the lowest ASGI level before any framework processing
        d402_wrapped_app = D402ASGIWrapper(
            app=starlette_app,
            server_address=contract_address,
            endpoint_payment_configs=endpoint_payment_configs,
            requires_auth=False,
            internal_api_key=None,
            testing_mode=testing_mode,
            facilitator_url=facilitator_url,
            facilitator_api_key=os.getenv("D402_FACILITATOR_API_KEY"),
            server_name="{{ agent_id }}"
        )
        
        logger.info("   ‚úÖ D402 raw ASGI wrapper applied (guaranteed interception)")
    else:
        # No D402 - just build normally
        starlette_app = app.build(rpc_url='/a2a')
        
        # Add CORS middleware even without D402
        starlette_app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],  # Allow all origins
            allow_credentials=True,
            allow_methods=["*"],  # Allow all methods
            allow_headers=["*"],  # Allow all headers
        )
        logger.info("‚úÖ Added CORS middleware (allow all origins)")
        
        d402_wrapped_app = None
    
    # Add protocol logging middleware if debug mode is enabled
    if os.environ.get("DEBUG_PROTOCOL", "false").lower() == "true":
        starlette_app.add_middleware(ProtocolLoggingMiddleware)
        logger.info("Added protocol logging middleware")
    
    # Log all routes that were created
    logger.info("Routes created by A2A application:")
    for route in starlette_app.routes:
        if hasattr(route, 'path') and hasattr(route, 'methods'):
            logger.info(f"  {route.methods} {route.path}")
        else:
            logger.info(f"  {route}")
    
    # The A2AStarletteApplication.build() should have already added the JSON-RPC endpoint
    # We only need to add custom SSE endpoints if they're not already included
    
    # Add SSE endpoints using Starlette's routing
    async def handle_subscribe_endpoint(request: Request):
        """Handle SSE subscription requests."""
        data = await request.json()
        return await request_handler.handle_subscribe(data)
    
    async def handle_resubscribe_endpoint(request: Request):
        """Handle SSE resubscription requests."""
        data = await request.json()
        return await request_handler.handle_resubscribe(data)
    
    # Add custom SSE routes (these might not be included by default)
    starlette_app.routes.append(
        Route("/a2a/tasks/subscribe", handle_subscribe_endpoint, methods=["POST"])
    )
    starlette_app.routes.append(
        Route("/a2a/tasks/resubscribe", handle_resubscribe_endpoint, methods=["POST"])
    )
    
    # Add health endpoint with MCP connection verification
    async def health_endpoint(request: Request):
        """Health check endpoint that verifies MCP connection every 10 minutes."""
        global mcp_connection_status
        
        # Check if we need to reverify (more than 10 minutes since last check)
        now = datetime.now()
        should_reverify = (
            mcp_connection_status["last_checked"] is None or
            (now - mcp_connection_status["last_checked"]).total_seconds() > 600  # 10 minutes
        )
        
        if should_reverify:
            logger.info("‚è∞ 10 minutes elapsed since last MCP verification, rechecking...")
            await verify_mcp_connection(mcp_config.url, mcp_config.name)
        
        # Return health status
        if mcp_connection_status["verified"]:
            return JSONResponse({
                "status": "healthy",
                "mcp_connection": "verified",
                "mcp_server": mcp_config.name,
                "mcp_url": mcp_config.url,
                "last_verified": mcp_connection_status["last_checked"].isoformat() if mcp_connection_status["last_checked"] else None
            })
        else:
            return JSONResponse(
                {
                    "status": "unhealthy",
                    "mcp_connection": "failed",
                    "mcp_server": mcp_config.name,
                    "mcp_url": mcp_config.url,
                    "error": mcp_connection_status["error"],
                    "last_checked": mcp_connection_status["last_checked"].isoformat() if mcp_connection_status["last_checked"] else None
                },
                status_code=503
            )
    
    starlette_app.routes.append(
        Route("/health", health_endpoint, methods=["GET"])
    )
    
    # Return the D402-wrapped app if D402 is enabled, otherwise return the unwrapped app
    if d402_wrapped_app:
        logger.info(f"üîí Returning D402-wrapped app (type: {type(d402_wrapped_app).__name__})")
        return d402_wrapped_app
    else:
        logger.info(f"‚ö†Ô∏è  Returning unwrapped app (D402 disabled, type: {type(starlette_app).__name__})")
    return starlette_app


def generate_self_signed_cert(cert_path: str = "cert.pem", key_path: str = "key.pem") -> None:
    """Generate self-signed certificate for local development."""
    if Path(cert_path).exists() and Path(key_path).exists():
        logger.info("TLS certificates already exist")
        return
    
    logger.info("Generating self-signed certificates for local development...")
    
    try:
        # Generate self-signed certificate using openssl
        subprocess.run([
            "openssl", "req", "-x509", "-newkey", "rsa:4096",
            "-keyout", key_path, "-out", cert_path,
            "-days", "365", "-nodes",
            "-subj", "/CN=localhost/O=A2A Development/C=US"
        ], check=True, capture_output=True)
        
        logger.info(f"Generated self-signed certificates: {cert_path}, {key_path}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to generate certificates: {e}")
        logger.error(f"Stdout: {e.stdout}")
        logger.error(f"Stderr: {e.stderr}")
        raise
    except FileNotFoundError:
        logger.error("OpenSSL not found. Please install OpenSSL to generate certificates.")
        raise


async def verify_mcp_before_start():
    """Verify MCP connection before starting server with retry logic for Cloud Run cold starts."""
    # Get MCP configuration
    mcp_url = os.getenv("MCP_SERVER_URL")
    mcp_name = "{{ mcp_server_name }}"
    
    if not mcp_url:
        logger.error("MCP_SERVER_URL not set!")
        return False
    
    logger.info("="*80)
    logger.info("üîç Verifying MCP server connection before startup...")
    logger.info("   (Cloud Run may need time to cold-start the MCP server)")
    logger.info("="*80)
    
    # Retry logic for Cloud Run cold starts (up to 3 attempts)
    max_attempts = 3
    retry_delay = 5  # seconds
    
    for attempt in range(1, max_attempts + 1):
        logger.info(f"üì° Connection attempt {attempt}/{max_attempts}...")
        mcp_ok = await verify_mcp_connection(mcp_url, mcp_name)
        
        if mcp_ok:
            logger.info("="*80)
            logger.info("‚úÖ MCP server verification complete - proceeding with startup")
            logger.info("="*80)
            return True
        
        if attempt < max_attempts:
            logger.warning(f"‚ö†Ô∏è  Connection failed, waiting {retry_delay}s before retry {attempt + 1}/{max_attempts}...")
            await asyncio.sleep(retry_delay)
            retry_delay *= 2  # Exponential backoff
    
    logger.error("="*80)
    logger.error(f"‚ùå STARTUP FAILED: Cannot connect to MCP server after {max_attempts} attempts!")
    logger.error("   The utility agent will NOT start without MCP server access.")
    logger.error("   Please check the MCP server is running and accessible.")
    logger.error("="*80)
    return False


def main():
    """Main function to start the A2A server."""
    
    # Initialize AgentOps for monitoring and observability
    agentops_session_id = None
    if AGENTOPS_AVAILABLE:
        agentops_api_key = os.environ.get("AGENTOPS_API_KEY")
        if agentops_api_key:
            try:
                # Initialize AgentOps with CrewAI-friendly settings
                agentops_session_id = agentops.init(
                    api_key=agentops_api_key,
                    skip_auto_end_session=True,  # Let CrewAI handle session lifecycle
                    tags=["{{ agent_name }}", "{{ mcp_server_name }}", "IATP", "A2A"],
                    auto_start_session=True
                )
                logger.info(f"‚úÖ AgentOps initialized successfully - Session ID: {agentops_session_id}")
                logger.info("üìä View session at: https://app.agentops.ai")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  Failed to initialize AgentOps: {e}")
                logger.warning("   Continuing without AgentOps monitoring...")
        else:
            logger.info("‚ÑπÔ∏è  AGENTOPS_API_KEY not set - AgentOps monitoring disabled")
            logger.info("   Set AGENTOPS_API_KEY environment variable to enable monitoring")
    else:
        logger.info("‚ÑπÔ∏è  AgentOps not installed - monitoring disabled")
        logger.info("   Install with: pip install agentops")
    
    # Get configuration from environment
    host = os.environ.get("HOST", "0.0.0.0")
    port = int(os.environ.get("PORT", 8000))
    
    # MCP was already verified by verify_mcp_before_start()
    # Create the application
    app = create_app()
    
    # Log startup information
    logger.info(f"Starting {{ agent_name }} A2A Server")
    logger.info(f"MCP Server: {{ mcp_server_name }}")
    logger.info(f"Listening on {host}:{port}")
    logger.info(f"Agent Card available at: http://{host}:{port}/.well-known/agent-card.json")
    logger.info(f"A2A Endpoint: http://{host}:{port}/a2a")
    logger.info(f"SSE endpoints available at: /a2a/tasks/subscribe and /a2a/tasks/resubscribe")
    
    if agentops_session_id:
        logger.info(f"üìä AgentOps Session ID: {agentops_session_id}")
        logger.info("üìä Monitor agent performance at: https://app.agentops.ai")
    
    # Configure Uvicorn (same as MCP servers for D402 compatibility)
    uvicorn_config = {
        "host": host,
        "port": port,
        "log_level": "info"
    }
    
    # Enable access logging if debug mode is on
    if os.environ.get("DEBUG_PROTOCOL", "false").lower() == "true":
        uvicorn_config["log_level"] = "debug"
        logger.info("Debug logging enabled")
    
    try:
        # Run the server with Uvicorn (for D402 middleware compatibility)
        uvicorn.run(app, **uvicorn_config)
    except KeyboardInterrupt:
        logger.info("üõë Server shutdown requested")
        if AGENTOPS_AVAILABLE and agentops_session_id:
            try:
                agentops.end_session('Success')
                logger.info("‚úÖ AgentOps session ended successfully")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  Failed to end AgentOps session: {e}")
    except Exception as e:
        logger.error(f"‚ùå Server error: {e}")
        if AGENTOPS_AVAILABLE and agentops_session_id:
            try:
                agentops.end_session('Fail', end_state_reason=str(e))
                logger.info("üìä AgentOps session ended with failure status")
            except Exception as ae:
                logger.warning(f"‚ö†Ô∏è  Failed to end AgentOps session: {ae}")
        raise


if __name__ == "__main__":
    # Run async MCP verification first
    import asyncio
    mcp_verified = asyncio.run(verify_mcp_before_start())
    
    if not mcp_verified:
        sys.exit(1)
    
    # Then run synchronous main (Uvicorn handles its own event loop)
    main() 