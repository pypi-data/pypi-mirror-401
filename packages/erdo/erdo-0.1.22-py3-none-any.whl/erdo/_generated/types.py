# DO NOT EDIT THIS FILE MANUALLY - it will be overwritten.
# Generated by: erdo gen-client
"""
Auto-generated type definitions from shared Go types.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

# Import TemplateString for Union types
if False:  # TYPE_CHECKING
    from erdo.template import TemplateString


# ParameterType (from ParameterType in Go)
class ParameterType(str, Enum):
    """Enum for ParameterType values"""

    STRING = "string"
    INTEGER = "integer"
    FLOAT = "float"
    BOOL = "bool"
    JSON = "json"


# ParameterHydrationBehaviour (from ParameterHydrationBehaviour in Go)
class ParameterHydrationBehaviour(str, Enum):
    """Enum for ParameterHydrationBehaviour values"""

    HYDRATE = "hydrate"
    RAW = "raw"
    NONE = "none"


# OutputVisibility (from OutputVisibility in Go)
class OutputVisibility(str, Enum):
    """Enum for OutputVisibility values"""

    VISIBLE = "visible"
    HIDDEN = "hidden"


# OutputContentType (from OutputContentType in Go)
class OutputContentType(str, Enum):
    """Enum for OutputContentType values"""

    TEXT = "text"
    JSON = "json"
    HTML = "html"


# HandlerType (from HandlerType in Go)
class HandlerType(str, Enum):
    """Enum for HandlerType values"""

    INTERMEDIATE = "intermediate"
    FINAL = "final"


# ExecutionModeType (from ExecutionModeType in Go)
class ExecutionModeType(str, Enum):
    """Enum for ExecutionModeType values"""

    ALL = "all"
    ITERATE_OVER = "iterate_over"
    ALL_BACKGROUND = "all_background"


# Model (from Model in Go)
class LlmModel(str, Enum):
    """Enum for LlmModel values"""

    CLAUDE_SONNET_4 = "claude-sonnet-4"
    CLAUDE_SONNET_4_5 = "claude-sonnet-4-5"
    CLAUDE_HAIKU_4_5 = "claude-haiku-4-5"
    GPT_4O = "gpt-4o"
    GPT_4O_MINI = "gpt-4o-mini"
    GPT_4_1 = "gpt-4.1"
    GPT_4_1_MINI = "gpt-4.1-mini"
    GPT_4_1_NANO = "gpt-4.1-nano"
    GPT_5 = "gpt-5"
    GPT_5_MINI = "gpt-5-mini"
    GPT_5_NANO = "gpt-5-nano"
    GEMINI_2_5_PRO = "gemini-2.5-pro"
    GEMINI_2_5_FLASH = "gemini-2.5-flash"
    GEMINI_2_5_FLASH_LITE = "gemini-2.5-flash-lite"


# OutputBehaviorType (from OutputBehaviorType in Go)
class OutputBehaviorType(str, Enum):
    """Enum for OutputBehaviorType values"""

    STEP_ONLY = "step_only"
    MERGE = "merge"
    OVERWRITE = "overwrite"


# CredentialSource (from CredentialSource in Go)
class CredentialSource(str, Enum):
    """Enum for CredentialSource values"""

    INTEGRATION_CREDENTIALS = "integration_credentials"
    CONFIG_PROVIDER_CREDENTIALS = "config_provider_credentials"
    SEGMENT = "segment"
    DATASET_PARAMETERS = "dataset_parameters"


# SensitivityLevel (from SensitivityLevel in Go)
class SensitivityLevel(str, Enum):
    """Enum for SensitivityLevel values"""

    NEVER_VIEWABLE = "never_viewable"
    OWNER_VIEWABLE = "owner_viewable"
    ADMIN_VIEWABLE = "admin_viewable"
    EDIT_VIEWABLE = "edit_viewable"
    ALL_VIEWABLE = "all_viewable"


# JSONSchemaType (from JSONSchemaType in Go)
class JSONSchemaType(str, Enum):
    """Enum for JSONSchemaType values"""

    STRING = "string"
    NUMBER = "number"
    BOOLEAN = "boolean"
    OBJECT = "object"
    ARRAY = "array"


# InvocationEventType (from InvocationEventType in Go)
class InvocationEventType(str, Enum):
    """Enum for InvocationEventType values"""

    BOT_STARTED = "bot started"
    MESSAGE_CREATED = "message created"
    MESSAGE_FINISHED = "message finished"
    MESSAGE_CONTENT_DELTA = "message content delta"
    CREATE_MESSAGE_CONTENT = "create message content"
    MESSAGE_CONTENT_RESULT = "message content result"
    STEP_OUTPUT_CREATED = "step output created"
    STEP_OUTPUT_FINISHED = "step output finished"
    STEP_OUTPUT_CONTENT_DELTA = "step output content delta"
    CREATE_STEP_OUTPUT_CONTENT = "create step output content"
    STEP_OUTPUT_CONTENT_RESULT = "step output content result"
    STEP_STARTED = "step started"
    STEP_RESULT = "step result"
    RESULT_HANDLER_STARTED = "result handler started"
    REQUIRES_INFO = "requires info"
    ERROR = "error"
    STATUS = "status"
    RESULT = "result"
    DATASET_CREATED = "dataset created"
    LOG = "log"


# Status (from Status in Go)
class Status(str, Enum):
    """Enum for Status values"""

    SKIPPED = "skipped"
    SUCCESS = "success"
    BREAK = "break"
    ERROR = "error"
    REQUIRES_INFO = "requires info"
    GO_TO_STEP = "go to step"


# Error (from Error in Go)
class Error(str, Enum):
    """Enum for Error values"""

    ACTION_NOT_FOUND = "action not found"
    INTERNAL_ERROR = "internal error"
    INFO_NEEDED = "info needed"
    TERMINATED = "terminated"
    BAD_REQUEST = "bad request"
    TIMEOUT = "timeout"


# DatasetType (from DatasetType in Go)
class DatasetType(str, Enum):
    """Enum for DatasetType values"""

    FILE = "file"
    DATABASE = "database"
    INTEGRATION = "integration"


# IntegrationType (from IntegrationType in Go)
class IntegrationType(str, Enum):
    """Enum for IntegrationType values"""

    API = "api"
    DATABASE = "database"
    FILE = "file"


# AuthType (from AuthType in Go)
class AuthType(str, Enum):
    """Enum for AuthType values"""

    OAUTH2 = "oauth2"
    API_KEY = "api_key"
    DATABASE = "database"
    BASIC_AUTH = "basic_auth"


# IntegrationStatus (from IntegrationStatus in Go)
class IntegrationStatus(str, Enum):
    """Enum for IntegrationStatus values"""

    ACTIVE = "active"
    INACTIVE = "inactive"
    BETA = "beta"
    COMING_SOON = "coming_soon"
    ERROR = "error"
    NEEDS_REAUTH = "needs_reauth"


# SegmentSelectionType (from SegmentSelectionType in Go)
class SegmentSelectionType(str, Enum):
    """Enum for SegmentSelectionType values"""

    SINGLE = "single"
    MULTIPLE = "multiple"
    REQUIRED = "required"
    OPTIONAL = "optional"


# ExpiryType (from ExpiryType in Go)
class ExpiryType(str, Enum):
    """Enum for ExpiryType values"""

    OAUTH_DEFAULT = "oauth_default"
    CONSTANT = "constant"
    OAUTH_FIELD = "oauth_field"


# ResourceType (from ResourceType in Go)
class ResourceType(str, Enum):
    """Enum for ResourceType values"""

    TABLE = "table"
    ENDPOINT = "endpoint"
    DOCUMENT = "document"
    PARTIAL_DOCUMENT = "partial_document"
    ENTITY = "entity"
    SHEET = "sheet"


# ResourceState (from ResourceState in Go)
class ResourceState(str, Enum):
    """Enum for ResourceState values"""

    ACTIVE = "active"
    REMOVED = "removed"
    DELETED = "deleted"


# ResourceRelationshipType (from ResourceRelationshipType in Go)
class ResourceRelationshipType(str, Enum):
    """Enum for ResourceRelationshipType values"""

    ACCEPTS = "accepts"
    RETURNS = "returns"
    LINKS_TO = "links_to"


# ResourceAttachType (from ResourceAttachType in Go)
class ResourceAttachType(str, Enum):
    """Enum for ResourceAttachType values"""

    ALWAYS = "always"
    SEARCHABLE = "searchable"


# Strongly-typed classes from Go structs
@dataclass
class Bot:
    """Bot matching Go backend structure."""

    id: str
    name: str
    description: str
    code: str
    file_path: str
    organization_id: str
    visibility: str
    source: str
    key: Optional[str] = None
    persona: Optional[str] = None
    running_status: Optional[Union[str, TemplateString]] = None
    finished_status: Optional[Union[str, TemplateString]] = None
    running_status_context: Optional[Union[str, TemplateString]] = None
    finished_status_context: Optional[Union[str, TemplateString]] = None
    running_status_prompt: Optional[Union[str, TemplateString]] = None
    finished_status_prompt: Optional[Union[str, TemplateString]] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["code"] = self.code.value if hasattr(self.code, "value") else self.code
        result["file_path"] = (
            self.file_path.value if hasattr(self.file_path, "value") else self.file_path
        )
        if self.key is not None:
            result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        if self.persona is not None:
            result["persona"] = (
                self.persona.value if hasattr(self.persona, "value") else self.persona
            )
        if self.running_status is not None:
            result["running_status"] = (
                str(self.running_status)
                if hasattr(self.running_status, "__str__")
                else self.running_status
            )
        if self.finished_status is not None:
            result["finished_status"] = (
                str(self.finished_status)
                if hasattr(self.finished_status, "__str__")
                else self.finished_status
            )
        if self.running_status_context is not None:
            result["running_status_context"] = (
                str(self.running_status_context)
                if hasattr(self.running_status_context, "__str__")
                else self.running_status_context
            )
        if self.finished_status_context is not None:
            result["finished_status_context"] = (
                str(self.finished_status_context)
                if hasattr(self.finished_status_context, "__str__")
                else self.finished_status_context
            )
        if self.running_status_prompt is not None:
            result["running_status_prompt"] = (
                str(self.running_status_prompt)
                if hasattr(self.running_status_prompt, "__str__")
                else self.running_status_prompt
            )
        if self.finished_status_prompt is not None:
            result["finished_status_prompt"] = (
                str(self.finished_status_prompt)
                if hasattr(self.finished_status_prompt, "__str__")
                else self.finished_status_prompt
            )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        result["organization_id"] = (
            self.organization_id.value
            if hasattr(self.organization_id, "value")
            else self.organization_id
        )
        result["visibility"] = (
            self.visibility.value
            if hasattr(self.visibility, "value")
            else self.visibility
        )
        result["source"] = (
            self.source.value if hasattr(self.source, "value") else self.source
        )
        return result


@dataclass
class ParameterDefinition:
    """ParameterDefinition matching Go backend structure."""

    name: str
    key: str
    type: Any
    is_required: bool
    id: Optional[UUID] = None
    bot_id: Optional[UUID] = None
    description: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    value_sources: List["ParameterValueSource"] = None
    interpreters: List["ParameterInterpreter"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.bot_id is not None:
            result["bot_id"] = (
                self.bot_id.value if hasattr(self.bot_id, "value") else self.bot_id
            )
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["is_required"] = (
            self.is_required.value
            if hasattr(self.is_required, "value")
            else self.is_required
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        if self.value_sources is not None:
            result["value_sources"] = (
                self.value_sources.value
                if hasattr(self.value_sources, "value")
                else self.value_sources
            )
        if self.interpreters is not None:
            result["interpreters"] = (
                self.interpreters.value
                if hasattr(self.interpreters, "value")
                else self.interpreters
            )
        return result


@dataclass
class ParameterValueSource:
    """ParameterValueSource matching Go backend structure."""

    type: Any
    parameters: Dict[str, Any]
    id: Optional[UUID] = None
    parameter_definition_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    on_populate: List["ParameterValueSourceHandler"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.parameter_definition_id is not None:
            result["parameter_definition_id"] = (
                self.parameter_definition_id.value
                if hasattr(self.parameter_definition_id, "value")
                else self.parameter_definition_id
            )
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        if self.on_populate is not None:
            result["on_populate"] = (
                self.on_populate.value
                if hasattr(self.on_populate, "value")
                else self.on_populate
            )
        return result


@dataclass
class ParameterValueSourceHandler:
    """ParameterValueSourceHandler matching Go backend structure."""

    action_type: str
    parameters: Dict[str, Any]
    execution_mode: str
    id: Optional[UUID] = None
    parameter_value_source_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.parameter_value_source_id is not None:
            result["parameter_value_source_id"] = (
                self.parameter_value_source_id.value
                if hasattr(self.parameter_value_source_id, "value")
                else self.parameter_value_source_id
            )
        result["action_type"] = (
            self.action_type.value
            if hasattr(self.action_type, "value")
            else self.action_type
        )
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        result["execution_mode"] = (
            self.execution_mode.value
            if hasattr(self.execution_mode, "value")
            else self.execution_mode
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        return result


@dataclass
class ParameterInterpreter:
    """ParameterInterpreter matching Go backend structure."""

    action_type: str
    parameters: Dict[str, Any]
    interpreter_order: int
    id: Optional[UUID] = None
    parameter_definition_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.parameter_definition_id is not None:
            result["parameter_definition_id"] = (
                self.parameter_definition_id.value
                if hasattr(self.parameter_definition_id, "value")
                else self.parameter_definition_id
            )
        result["action_type"] = (
            self.action_type.value
            if hasattr(self.action_type, "value")
            else self.action_type
        )
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        result["interpreter_order"] = (
            self.interpreter_order.value
            if hasattr(self.interpreter_order, "value")
            else self.interpreter_order
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        return result


@dataclass
class UpsertBotRequest:
    """UpsertBotRequest matching Go backend structure."""

    bot: "Bot"
    steps: List["APIStepWithHandlers"]
    source: str
    parameter_definitions: List["APIParameterDefinition"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["bot"] = self.bot.value if hasattr(self.bot, "value") else self.bot
        result["steps"] = (
            self.steps.value if hasattr(self.steps, "value") else self.steps
        )
        result["source"] = (
            self.source.value if hasattr(self.source, "value") else self.source
        )
        if self.parameter_definitions is not None:
            result["parameter_definitions"] = (
                self.parameter_definitions.value
                if hasattr(self.parameter_definitions, "value")
                else self.parameter_definitions
            )
        return result


@dataclass
class BotsResponse:
    """BotsResponse matching Go backend structure."""

    bots: List["Bot"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["bots"] = self.bots.value if hasattr(self.bots, "value") else self.bots
        return result


@dataclass
class StepsResponse:
    """StepsResponse matching Go backend structure."""

    steps: List["APIStep"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["steps"] = (
            self.steps.value if hasattr(self.steps, "value") else self.steps
        )
        return result


@dataclass
class ServiceDefinition:
    """ServiceDefinition matching Go backend structure."""

    name: str
    description: str
    actions: List["ActionDefinition"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["actions"] = (
            self.actions.value if hasattr(self.actions, "value") else self.actions
        )
        return result


@dataclass
class ActionDefinition:
    """ActionDefinition matching Go backend structure."""

    name: str
    description: str
    parameters: List["ParameterDefinition"]
    result_schema: Optional["ResultSchema"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        if self.result_schema is not None:
            result["result_schema"] = (
                self.result_schema.value
                if hasattr(self.result_schema, "value")
                else self.result_schema
            )
        return result


@dataclass
class ResultSchema:
    """ResultSchema matching Go backend structure."""

    properties: Dict[str, Any]
    description: str = None
    required_fields: List[str] = None
    optional_fields: List[str] = None
    examples: List[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        if self.required_fields is not None:
            result["required_fields"] = (
                self.required_fields.value
                if hasattr(self.required_fields, "value")
                else self.required_fields
            )
        if self.optional_fields is not None:
            result["optional_fields"] = (
                self.optional_fields.value
                if hasattr(self.optional_fields, "value")
                else self.optional_fields
            )
        result["properties"] = (
            self.properties.value
            if hasattr(self.properties, "value")
            else self.properties
        )
        if self.examples is not None:
            result["examples"] = (
                self.examples.value
                if hasattr(self.examples, "value")
                else self.examples
            )
        return result


@dataclass
class PropertySchema:
    """PropertySchema matching Go backend structure."""

    type: Any
    description: str = None
    items: Optional["PropertySchema"] = None
    properties: Dict[str, Any] = None
    example: Any = None
    enum: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        if self.items is not None:
            result["items"] = (
                self.items.value if hasattr(self.items, "value") else self.items
            )
        if self.properties is not None:
            result["properties"] = (
                self.properties.value
                if hasattr(self.properties, "value")
                else self.properties
            )
        if self.example is not None:
            result["example"] = (
                self.example.value if hasattr(self.example, "value") else self.example
            )
        if self.enum is not None:
            result["enum"] = (
                self.enum.value if hasattr(self.enum, "value") else self.enum
            )
        return result


@dataclass
class IntegrationSchema:
    """IntegrationSchema matching Go backend structure."""

    key: str
    name: str
    description: str
    type: str
    auth_types: List[str]
    credential_schema: Dict[str, Any]
    available_scopes: List[str]
    documentation_url: str
    codegen_details: Optional[CodegenDetails] = None
    analysis_details: Optional[AnalysisDetails] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["auth_types"] = (
            self.auth_types.value
            if hasattr(self.auth_types, "value")
            else self.auth_types
        )
        result["credential_schema"] = (
            self.credential_schema.value
            if hasattr(self.credential_schema, "value")
            else self.credential_schema
        )
        result["available_scopes"] = (
            self.available_scopes.value
            if hasattr(self.available_scopes, "value")
            else self.available_scopes
        )
        result["documentation_url"] = (
            self.documentation_url.value
            if hasattr(self.documentation_url, "value")
            else self.documentation_url
        )
        if self.codegen_details is not None:
            result["codegen_details"] = (
                self.codegen_details.value
                if hasattr(self.codegen_details, "value")
                else self.codegen_details
            )
        if self.analysis_details is not None:
            result["analysis_details"] = (
                self.analysis_details.value
                if hasattr(self.analysis_details, "value")
                else self.analysis_details
            )
        return result


@dataclass
class CodegenDetails:
    """CodegenDetails matching Go backend structure."""

    code: str
    imports: List[str]
    hint: str = None
    edp_hint: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["code"] = self.code.value if hasattr(self.code, "value") else self.code
        result["imports"] = (
            self.imports.value if hasattr(self.imports, "value") else self.imports
        )
        if self.hint is not None:
            result["hint"] = (
                self.hint.value if hasattr(self.hint, "value") else self.hint
            )
        if self.edp_hint is not None:
            result["edp_hint"] = (
                self.edp_hint.value
                if hasattr(self.edp_hint, "value")
                else self.edp_hint
            )
        return result


@dataclass
class AnalysisDetails:
    """AnalysisDetails matching Go backend structure."""

    imports: List[str]
    code: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["imports"] = (
            self.imports.value if hasattr(self.imports, "value") else self.imports
        )
        result["code"] = self.code.value if hasattr(self.code, "value") else self.code
        return result


@dataclass
class CredentialSchema:
    """CredentialSchema matching Go backend structure."""

    type: str
    description: str
    required: bool
    source: Any
    sensitivity: Any = None
    jq: str = None
    header: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["required"] = (
            self.required.value if hasattr(self.required, "value") else self.required
        )
        result["source"] = (
            self.source.value if hasattr(self.source, "value") else self.source
        )
        if self.sensitivity is not None:
            result["sensitivity"] = (
                self.sensitivity.value
                if hasattr(self.sensitivity, "value")
                else self.sensitivity
            )
        if self.jq is not None:
            result["jq"] = self.jq.value if hasattr(self.jq, "value") else self.jq
        if self.header is not None:
            result["header"] = (
                self.header.value if hasattr(self.header, "value") else self.header
            )
        return result


@dataclass
class ExportActionsResponse:
    """ExportActionsResponse matching Go backend structure."""

    services: Dict[str, Any]
    integrations: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["services"] = (
            self.services.value if hasattr(self.services, "value") else self.services
        )
        result["integrations"] = (
            self.integrations.value
            if hasattr(self.integrations, "value")
            else self.integrations
        )
        return result


@dataclass
class ConditionDefinition:
    """ConditionDefinition matching Go backend structure."""

    type: str
    conditions: List["ConditionDefinition"] = None
    leaf: Dict[str, Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.conditions is not None:
            result["conditions"] = (
                self.conditions.value
                if hasattr(self.conditions, "value")
                else self.conditions
            )
        if self.leaf is not None:
            result["leaf"] = (
                self.leaf.value if hasattr(self.leaf, "value") else self.leaf
            )
        return result


@dataclass
class TempCondition:
    """TempCondition matching Go backend structure."""

    type: str
    conditions: Any = None
    leaf: Dict[str, Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.conditions is not None:
            result["conditions"] = (
                self.conditions.value
                if hasattr(self.conditions, "value")
                else self.conditions
            )
        if self.leaf is not None:
            result["leaf"] = (
                self.leaf.value if hasattr(self.leaf, "value") else self.leaf
            )
        return result


@dataclass
class JSONSchemaProperty:
    """JSONSchemaProperty matching Go backend structure."""

    type: Any
    description: str = None
    items: Optional["JSONSchemaProperty"] = None
    enum: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        if self.items is not None:
            result["items"] = (
                self.items.value if hasattr(self.items, "value") else self.items
            )
        if self.enum is not None:
            result["enum"] = (
                self.enum.value if hasattr(self.enum, "value") else self.enum
            )
        return result


@dataclass
class JSONSchema:
    """JSONSchema matching Go backend structure."""

    type: Any
    properties: Dict[str, Any] = None
    required: List[str] = None
    items: Optional["JSONSchemaProperty"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.properties is not None:
            result["properties"] = (
                self.properties.value
                if hasattr(self.properties, "value")
                else self.properties
            )
        if self.required is not None:
            result["required"] = (
                self.required.value
                if hasattr(self.required, "value")
                else self.required
            )
        if self.items is not None:
            result["items"] = (
                self.items.value if hasattr(self.items, "value") else self.items
            )
        return result


@dataclass
class Tool:
    """Tool matching Go backend structure."""

    name: str
    description: str
    input_schema: "JSONSchema"
    action_type: str
    parameters: Dict[str, Any]
    bot_output_visibility: str = None
    history_content_type: str = None
    ui_content_type: str = None
    as_root: bool = None
    running_status: Optional[Union[str, TemplateString]] = None
    finished_status: Optional[Union[str, TemplateString]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["input_schema"] = (
            self.input_schema.value
            if hasattr(self.input_schema, "value")
            else self.input_schema
        )
        result["action_type"] = (
            self.action_type.value
            if hasattr(self.action_type, "value")
            else self.action_type
        )
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        if self.bot_output_visibility is not None:
            result["bot_output_visibility"] = (
                self.bot_output_visibility.value
                if hasattr(self.bot_output_visibility, "value")
                else self.bot_output_visibility
            )
        if self.history_content_type is not None:
            result["history_content_type"] = (
                self.history_content_type.value
                if hasattr(self.history_content_type, "value")
                else self.history_content_type
            )
        if self.ui_content_type is not None:
            result["ui_content_type"] = (
                self.ui_content_type.value
                if hasattr(self.ui_content_type, "value")
                else self.ui_content_type
            )
        if self.as_root is not None:
            result["as_root"] = (
                self.as_root.value if hasattr(self.as_root, "value") else self.as_root
            )
        if self.running_status is not None:
            result["running_status"] = (
                str(self.running_status)
                if hasattr(self.running_status, "__str__")
                else self.running_status
            )
        if self.finished_status is not None:
            result["finished_status"] = (
                str(self.finished_status)
                if hasattr(self.finished_status, "__str__")
                else self.finished_status
            )
        return result


@dataclass
class Message:
    """Message matching Go backend structure."""

    id: str
    role: str
    content: str
    created_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        result["role"] = self.role.value if hasattr(self.role, "value") else self.role
        result["content"] = (
            self.content.value if hasattr(self.content, "value") else self.content
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        return result


@dataclass
class SystemParameters:
    """SystemParameters matching Go backend structure."""

    current_date: str
    messages: List["Message"]
    session_messages: List["Message"]
    current_message: str
    thread_id: UUID
    organization_id: str
    invocation_id: UUID

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["current_date"] = (
            self.current_date.value
            if hasattr(self.current_date, "value")
            else self.current_date
        )
        result["messages"] = (
            self.messages.value if hasattr(self.messages, "value") else self.messages
        )
        result["session_messages"] = (
            self.session_messages.value
            if hasattr(self.session_messages, "value")
            else self.session_messages
        )
        result["current_message"] = (
            self.current_message.value
            if hasattr(self.current_message, "value")
            else self.current_message
        )
        result["thread_id"] = (
            self.thread_id.value if hasattr(self.thread_id, "value") else self.thread_id
        )
        result["organization_id"] = (
            self.organization_id.value
            if hasattr(self.organization_id, "value")
            else self.organization_id
        )
        result["invocation_id"] = (
            self.invocation_id.value
            if hasattr(self.invocation_id, "value")
            else self.invocation_id
        )
        return result


@dataclass
class Result:
    """Result matching Go backend structure."""

    status: Any
    parameters: Optional[Dict[str, Any]] = None
    output: Optional[Dict[str, Any]] = None
    message: Optional[str] = None
    error: Optional[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["status"] = (
            self.status.value if hasattr(self.status, "value") else self.status
        )
        if self.parameters is not None:
            result["parameters"] = (
                self.parameters.value
                if hasattr(self.parameters, "value")
                else self.parameters
            )
        if self.output is not None:
            result["output"] = (
                self.output.value if hasattr(self.output, "value") else self.output
            )
        if self.message is not None:
            result["message"] = (
                self.message.value if hasattr(self.message, "value") else self.message
            )
        if self.error is not None:
            result["error"] = (
                self.error.value if hasattr(self.error, "value") else self.error
            )
        return result


@dataclass
class APIStep:
    """APIStep matching Go backend structure."""

    id: str
    bot_id: str
    action_type: str
    parameters: Any
    step_order: int
    output_content_type: str
    user_output_visibility: str
    bot_output_visibility: str
    execution_mode: "APIExecutionMode"
    output_behaviour: Any
    output_channels: List[str]
    depends_on: Optional[List[str]] = None
    key: Optional[str] = None
    running_status: Optional[Union[str, TemplateString]] = None
    finished_status: Optional[Union[str, TemplateString]] = None
    history_content_type: Optional[str] = None
    ui_content_type: Optional[str] = None
    parameter_hydration_behaviour: Optional[Any] = None
    result_handler_id: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        result["bot_id"] = (
            self.bot_id.value if hasattr(self.bot_id, "value") else self.bot_id
        )
        result["action_type"] = (
            self.action_type.value
            if hasattr(self.action_type, "value")
            else self.action_type
        )
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        if self.depends_on is not None:
            result["depends_on"] = (
                self.depends_on.value
                if hasattr(self.depends_on, "value")
                else self.depends_on
            )
        if self.key is not None:
            result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        result["step_order"] = (
            self.step_order.value
            if hasattr(self.step_order, "value")
            else self.step_order
        )
        result["output_content_type"] = (
            self.output_content_type.value
            if hasattr(self.output_content_type, "value")
            else self.output_content_type
        )
        result["user_output_visibility"] = (
            self.user_output_visibility.value
            if hasattr(self.user_output_visibility, "value")
            else self.user_output_visibility
        )
        result["bot_output_visibility"] = (
            self.bot_output_visibility.value
            if hasattr(self.bot_output_visibility, "value")
            else self.bot_output_visibility
        )
        result["execution_mode"] = (
            self.execution_mode.value
            if hasattr(self.execution_mode, "value")
            else self.execution_mode
        )
        result["output_behaviour"] = (
            self.output_behaviour.value
            if hasattr(self.output_behaviour, "value")
            else self.output_behaviour
        )
        result["output_channels"] = (
            self.output_channels.value
            if hasattr(self.output_channels, "value")
            else self.output_channels
        )
        if self.running_status is not None:
            result["running_status"] = (
                str(self.running_status)
                if hasattr(self.running_status, "__str__")
                else self.running_status
            )
        if self.finished_status is not None:
            result["finished_status"] = (
                str(self.finished_status)
                if hasattr(self.finished_status, "__str__")
                else self.finished_status
            )
        if self.history_content_type is not None:
            result["history_content_type"] = (
                self.history_content_type.value
                if hasattr(self.history_content_type, "value")
                else self.history_content_type
            )
        if self.ui_content_type is not None:
            result["ui_content_type"] = (
                self.ui_content_type.value
                if hasattr(self.ui_content_type, "value")
                else self.ui_content_type
            )
        if self.parameter_hydration_behaviour is not None:
            result["parameter_hydration_behaviour"] = (
                self.parameter_hydration_behaviour.value
                if hasattr(self.parameter_hydration_behaviour, "value")
                else self.parameter_hydration_behaviour
            )
        if self.result_handler_id is not None:
            result["result_handler_id"] = (
                self.result_handler_id.value
                if hasattr(self.result_handler_id, "value")
                else self.result_handler_id
            )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        return result


@dataclass
class APIParameterValueSource:
    """APIParameterValueSource matching Go backend structure."""

    type: Any
    parameters: Any
    id: Optional[UUID] = None
    parameter_definition_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    on_populate: List["APIParameterValueSourceHandler"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.parameter_definition_id is not None:
            result["parameter_definition_id"] = (
                self.parameter_definition_id.value
                if hasattr(self.parameter_definition_id, "value")
                else self.parameter_definition_id
            )
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        if self.on_populate is not None:
            result["on_populate"] = (
                self.on_populate.value
                if hasattr(self.on_populate, "value")
                else self.on_populate
            )
        return result


@dataclass
class APIParameterValueSourceHandler:
    """APIParameterValueSourceHandler matching Go backend structure."""

    action_type: str
    parameters: Any
    execution_mode: "APIExecutionMode"
    id: Optional[UUID] = None
    parameter_value_source_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.parameter_value_source_id is not None:
            result["parameter_value_source_id"] = (
                self.parameter_value_source_id.value
                if hasattr(self.parameter_value_source_id, "value")
                else self.parameter_value_source_id
            )
        result["action_type"] = (
            self.action_type.value
            if hasattr(self.action_type, "value")
            else self.action_type
        )
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        result["execution_mode"] = (
            self.execution_mode.value
            if hasattr(self.execution_mode, "value")
            else self.execution_mode
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        return result


@dataclass
class APIParameterInterpreter:
    """APIParameterInterpreter matching Go backend structure."""

    action_type: str
    parameters: Any
    interpreter_order: int
    id: Optional[UUID] = None
    parameter_definition_id: Optional[UUID] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.parameter_definition_id is not None:
            result["parameter_definition_id"] = (
                self.parameter_definition_id.value
                if hasattr(self.parameter_definition_id, "value")
                else self.parameter_definition_id
            )
        result["action_type"] = (
            self.action_type.value
            if hasattr(self.action_type, "value")
            else self.action_type
        )
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        result["interpreter_order"] = (
            self.interpreter_order.value
            if hasattr(self.interpreter_order, "value")
            else self.interpreter_order
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        return result


@dataclass
class APIExecutionMode:
    """APIExecutionMode matching Go backend structure."""

    mode: Any
    data: Any
    if_condition: Optional["APIConditionDefinition"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["mode"] = self.mode.value if hasattr(self.mode, "value") else self.mode
        result["data"] = self.data.value if hasattr(self.data, "value") else self.data
        if self.if_condition is not None:
            result["if_condition"] = (
                self.if_condition.value
                if hasattr(self.if_condition, "value")
                else self.if_condition
            )
        return result


@dataclass
class APIConditionDefinition:
    """APIConditionDefinition matching Go backend structure."""

    type: str
    conditions: List["APIConditionDefinition"] = None
    leaf: Any = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.conditions is not None:
            result["conditions"] = (
                self.conditions.value
                if hasattr(self.conditions, "value")
                else self.conditions
            )
        if self.leaf is not None:
            result["leaf"] = (
                self.leaf.value if hasattr(self.leaf, "value") else self.leaf
            )
        return result


@dataclass
class APITool:
    """APITool matching Go backend structure."""

    name: str
    description: str
    input_schema: Any
    action_type: str
    parameters: Any
    bot_output_visibility: str = None
    history_content_type: str = None
    ui_content_type: str = None
    as_root: bool = None
    running_status: Optional[Union[str, TemplateString]] = None
    finished_status: Optional[Union[str, TemplateString]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["input_schema"] = (
            self.input_schema.value
            if hasattr(self.input_schema, "value")
            else self.input_schema
        )
        result["action_type"] = (
            self.action_type.value
            if hasattr(self.action_type, "value")
            else self.action_type
        )
        result["parameters"] = (
            self.parameters.value
            if hasattr(self.parameters, "value")
            else self.parameters
        )
        if self.bot_output_visibility is not None:
            result["bot_output_visibility"] = (
                self.bot_output_visibility.value
                if hasattr(self.bot_output_visibility, "value")
                else self.bot_output_visibility
            )
        if self.history_content_type is not None:
            result["history_content_type"] = (
                self.history_content_type.value
                if hasattr(self.history_content_type, "value")
                else self.history_content_type
            )
        if self.ui_content_type is not None:
            result["ui_content_type"] = (
                self.ui_content_type.value
                if hasattr(self.ui_content_type, "value")
                else self.ui_content_type
            )
        if self.as_root is not None:
            result["as_root"] = (
                self.as_root.value if hasattr(self.as_root, "value") else self.as_root
            )
        if self.running_status is not None:
            result["running_status"] = (
                str(self.running_status)
                if hasattr(self.running_status, "__str__")
                else self.running_status
            )
        if self.finished_status is not None:
            result["finished_status"] = (
                str(self.finished_status)
                if hasattr(self.finished_status, "__str__")
                else self.finished_status
            )
        return result


@dataclass
class APIResultHandler:
    """APIResultHandler matching Go backend structure."""

    type: str
    if_conditions: "APIConditionDefinition"
    result_handler_order: int
    output_content_type: str
    steps: List["APIStepWithHandlers"]
    history_content_type: Optional[str] = None
    ui_content_type: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["if_conditions"] = (
            self.if_conditions.value
            if hasattr(self.if_conditions, "value")
            else self.if_conditions
        )
        result["result_handler_order"] = (
            self.result_handler_order.value
            if hasattr(self.result_handler_order, "value")
            else self.result_handler_order
        )
        result["output_content_type"] = (
            self.output_content_type.value
            if hasattr(self.output_content_type, "value")
            else self.output_content_type
        )
        if self.history_content_type is not None:
            result["history_content_type"] = (
                self.history_content_type.value
                if hasattr(self.history_content_type, "value")
                else self.history_content_type
            )
        if self.ui_content_type is not None:
            result["ui_content_type"] = (
                self.ui_content_type.value
                if hasattr(self.ui_content_type, "value")
                else self.ui_content_type
            )
        result["steps"] = (
            self.steps.value if hasattr(self.steps, "value") else self.steps
        )
        return result


@dataclass
class APIParameterDefinition:
    """APIParameterDefinition matching Go backend structure."""

    name: str
    key: str
    type: str
    is_required: bool
    id: Optional[UUID] = None
    bot_id: Optional[UUID] = None
    description: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.id is not None:
            result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.bot_id is not None:
            result["bot_id"] = (
                self.bot_id.value if hasattr(self.bot_id, "value") else self.bot_id
            )
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["is_required"] = (
            self.is_required.value
            if hasattr(self.is_required, "value")
            else self.is_required
        )
        if self.created_at is not None:
            result["created_at"] = (
                self.created_at.value
                if hasattr(self.created_at, "value")
                else self.created_at
            )
        if self.updated_at is not None:
            result["updated_at"] = (
                self.updated_at.value
                if hasattr(self.updated_at, "value")
                else self.updated_at
            )
        return result


@dataclass
class APIStepWithHandlers:
    """APIStepWithHandlers matching Go backend structure."""

    step: "APIStep"
    result_handlers: List["APIResultHandler"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["step"] = self.step.value if hasattr(self.step, "value") else self.step
        result["result_handlers"] = (
            self.result_handlers.value
            if hasattr(self.result_handlers, "value")
            else self.result_handlers
        )
        return result


@dataclass
class Dataset:
    """Dataset matching Go backend structure."""

    id: UUID
    type: DatasetType
    key: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    analysis_summary: Optional[str] = None
    last_analyzed: Optional[datetime] = None
    instructions: Optional[str] = None
    file: Optional[str] = None
    file_type: Optional[str] = None
    filename: Optional[str] = None
    url: Optional[str] = None
    integration_id: Optional[UUID] = None
    integration_config_id: Optional[UUID] = None
    integration_config: Optional[IntegrationConfig] = None
    encrypted_integration_credentials: Optional[Dict[str, str]] = None
    credential_schema: Optional[Dict[str, Any]] = None
    codegen_details: Optional[CodegenDetails] = None
    analysis_details: Optional[AnalysisDetails] = None
    available_scopes: Optional[List[str]] = None
    parameters: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.key is not None:
            result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        if self.name is not None:
            result["name"] = (
                self.name.value if hasattr(self.name, "value") else self.name
            )
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        if self.analysis_summary is not None:
            result["analysis_summary"] = (
                self.analysis_summary.value
                if hasattr(self.analysis_summary, "value")
                else self.analysis_summary
            )
        if self.last_analyzed is not None:
            result["last_analyzed"] = (
                self.last_analyzed.value
                if hasattr(self.last_analyzed, "value")
                else self.last_analyzed
            )
        if self.instructions is not None:
            result["instructions"] = (
                self.instructions.value
                if hasattr(self.instructions, "value")
                else self.instructions
            )
        if self.file is not None:
            result["file"] = (
                self.file.value if hasattr(self.file, "value") else self.file
            )
        if self.file_type is not None:
            result["file_type"] = (
                self.file_type.value
                if hasattr(self.file_type, "value")
                else self.file_type
            )
        if self.filename is not None:
            result["filename"] = (
                self.filename.value
                if hasattr(self.filename, "value")
                else self.filename
            )
        if self.url is not None:
            result["url"] = self.url.value if hasattr(self.url, "value") else self.url
        if self.integration_id is not None:
            result["integration_id"] = (
                self.integration_id.value
                if hasattr(self.integration_id, "value")
                else self.integration_id
            )
        if self.integration_config_id is not None:
            result["integration_config_id"] = (
                self.integration_config_id.value
                if hasattr(self.integration_config_id, "value")
                else self.integration_config_id
            )
        if self.integration_config is not None:
            result["integration_config"] = (
                self.integration_config.value
                if hasattr(self.integration_config, "value")
                else self.integration_config
            )
        if self.encrypted_integration_credentials is not None:
            result["encrypted_integration_credentials"] = (
                self.encrypted_integration_credentials.value
                if hasattr(self.encrypted_integration_credentials, "value")
                else self.encrypted_integration_credentials
            )
        if self.credential_schema is not None:
            result["credential_schema"] = (
                self.credential_schema.value
                if hasattr(self.credential_schema, "value")
                else self.credential_schema
            )
        if self.codegen_details is not None:
            result["codegen_details"] = (
                self.codegen_details.value
                if hasattr(self.codegen_details, "value")
                else self.codegen_details
            )
        if self.analysis_details is not None:
            result["analysis_details"] = (
                self.analysis_details.value
                if hasattr(self.analysis_details, "value")
                else self.analysis_details
            )
        if self.available_scopes is not None:
            result["available_scopes"] = (
                self.available_scopes.value
                if hasattr(self.available_scopes, "value")
                else self.available_scopes
            )
        if self.parameters is not None:
            result["parameters"] = (
                self.parameters.value
                if hasattr(self.parameters, "value")
                else self.parameters
            )
        return result


@dataclass
class BotResource:
    """BotResource matching Go backend structure."""

    id: int
    created_by: str
    extra: Dict[str, Any]
    dataset: Optional[Dataset] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        if self.dataset is not None:
            result["dataset"] = (
                self.dataset.value if hasattr(self.dataset, "value") else self.dataset
            )
        result["created_by"] = (
            self.created_by.value
            if hasattr(self.created_by, "value")
            else self.created_by
        )
        result["extra"] = (
            self.extra.value if hasattr(self.extra, "value") else self.extra
        )
        return result


@dataclass
class UIConfigIcon:
    """UIConfigIcon matching Go backend structure."""

    set: str
    name: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["set"] = self.set.value if hasattr(self.set, "value") else self.set
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        return result


@dataclass
class UIConfig:
    """UIConfig matching Go backend structure."""

    brand_logo_icon: "UIConfigIcon"
    brand_color: str
    button_style: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["brand_logo_icon"] = (
            self.brand_logo_icon.value
            if hasattr(self.brand_logo_icon, "value")
            else self.brand_logo_icon
        )
        result["brand_color"] = (
            self.brand_color.value
            if hasattr(self.brand_color, "value")
            else self.brand_color
        )
        result["button_style"] = (
            self.button_style.value
            if hasattr(self.button_style, "value")
            else self.button_style
        )
        return result


@dataclass
class ErrorHandlingConfig:
    """ErrorHandlingConfig matching Go backend structure."""

    ignore_errors: List[str] = None
    error_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.ignore_errors is not None:
            result["ignore_errors"] = (
                self.ignore_errors.value
                if hasattr(self.ignore_errors, "value")
                else self.ignore_errors
            )
        if self.error_path is not None:
            result["error_path"] = (
                self.error_path.value
                if hasattr(self.error_path, "value")
                else self.error_path
            )
        return result


@dataclass
class SegmentLevel:
    """SegmentLevel matching Go backend structure."""

    name: str
    type: str
    selectable: bool
    url_template: str = None
    method: str = None
    body: str = None
    id_path: str = None
    id_regex: str = None
    name_path: str = None
    parent_key: str = None
    required_credentials: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["selectable"] = (
            self.selectable.value
            if hasattr(self.selectable, "value")
            else self.selectable
        )
        if self.url_template is not None:
            result["url_template"] = (
                self.url_template.value
                if hasattr(self.url_template, "value")
                else self.url_template
            )
        if self.method is not None:
            result["method"] = (
                self.method.value if hasattr(self.method, "value") else self.method
            )
        if self.body is not None:
            result["body"] = (
                self.body.value if hasattr(self.body, "value") else self.body
            )
        if self.id_path is not None:
            result["id_path"] = (
                self.id_path.value if hasattr(self.id_path, "value") else self.id_path
            )
        if self.id_regex is not None:
            result["id_regex"] = (
                self.id_regex.value
                if hasattr(self.id_regex, "value")
                else self.id_regex
            )
        if self.name_path is not None:
            result["name_path"] = (
                self.name_path.value
                if hasattr(self.name_path, "value")
                else self.name_path
            )
        if self.parent_key is not None:
            result["parent_key"] = (
                self.parent_key.value
                if hasattr(self.parent_key, "value")
                else self.parent_key
            )
        if self.required_credentials is not None:
            result["required_credentials"] = (
                self.required_credentials.value
                if hasattr(self.required_credentials, "value")
                else self.required_credentials
            )
        return result


@dataclass
class SegmentConfig:
    """SegmentConfig matching Go backend structure."""

    selection_type: Any
    description: str
    hierarchical: bool
    levels: List["SegmentLevel"]
    min_selections: Optional[int] = None
    max_selections: Optional[int] = None
    base_url: str = None
    error_handling: Optional["ErrorHandlingConfig"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["selection_type"] = (
            self.selection_type.value
            if hasattr(self.selection_type, "value")
            else self.selection_type
        )
        if self.min_selections is not None:
            result["min_selections"] = (
                self.min_selections.value
                if hasattr(self.min_selections, "value")
                else self.min_selections
            )
        if self.max_selections is not None:
            result["max_selections"] = (
                self.max_selections.value
                if hasattr(self.max_selections, "value")
                else self.max_selections
            )
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["hierarchical"] = (
            self.hierarchical.value
            if hasattr(self.hierarchical, "value")
            else self.hierarchical
        )
        if self.base_url is not None:
            result["base_url"] = (
                self.base_url.value
                if hasattr(self.base_url, "value")
                else self.base_url
            )
        result["levels"] = (
            self.levels.value if hasattr(self.levels, "value") else self.levels
        )
        if self.error_handling is not None:
            result["error_handling"] = (
                self.error_handling.value
                if hasattr(self.error_handling, "value")
                else self.error_handling
            )
        return result


@dataclass
class ResourceTypeConfig:
    """ResourceTypeConfig matching Go backend structure."""

    type: str
    url_template: str
    id_path: str
    name_path: str
    method: str = None
    body: str = None
    description_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["url_template"] = (
            self.url_template.value
            if hasattr(self.url_template, "value")
            else self.url_template
        )
        if self.method is not None:
            result["method"] = (
                self.method.value if hasattr(self.method, "value") else self.method
            )
        if self.body is not None:
            result["body"] = (
                self.body.value if hasattr(self.body, "value") else self.body
            )
        result["id_path"] = (
            self.id_path.value if hasattr(self.id_path, "value") else self.id_path
        )
        result["name_path"] = (
            self.name_path.value if hasattr(self.name_path, "value") else self.name_path
        )
        if self.description_path is not None:
            result["description_path"] = (
                self.description_path.value
                if hasattr(self.description_path, "value")
                else self.description_path
            )
        return result


@dataclass
class DatasetResourceDiscoveryConfig:
    """DatasetResourceDiscoveryConfig matching Go backend structure."""

    min_resources_required: int
    table_query: str = None
    relationship_query: str = None
    index_query: str = None
    constraint_query: str = None
    statistics_query: str = None
    size_query: str = None
    base_url: str = None
    resource_types: List["ResourceTypeConfig"] = None
    error_handling: Optional["ErrorHandlingConfig"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["min_resources_required"] = (
            self.min_resources_required.value
            if hasattr(self.min_resources_required, "value")
            else self.min_resources_required
        )
        if self.table_query is not None:
            result["table_query"] = (
                self.table_query.value
                if hasattr(self.table_query, "value")
                else self.table_query
            )
        if self.relationship_query is not None:
            result["relationship_query"] = (
                self.relationship_query.value
                if hasattr(self.relationship_query, "value")
                else self.relationship_query
            )
        if self.index_query is not None:
            result["index_query"] = (
                self.index_query.value
                if hasattr(self.index_query, "value")
                else self.index_query
            )
        if self.constraint_query is not None:
            result["constraint_query"] = (
                self.constraint_query.value
                if hasattr(self.constraint_query, "value")
                else self.constraint_query
            )
        if self.statistics_query is not None:
            result["statistics_query"] = (
                self.statistics_query.value
                if hasattr(self.statistics_query, "value")
                else self.statistics_query
            )
        if self.size_query is not None:
            result["size_query"] = (
                self.size_query.value
                if hasattr(self.size_query, "value")
                else self.size_query
            )
        if self.base_url is not None:
            result["base_url"] = (
                self.base_url.value
                if hasattr(self.base_url, "value")
                else self.base_url
            )
        if self.resource_types is not None:
            result["resource_types"] = (
                self.resource_types.value
                if hasattr(self.resource_types, "value")
                else self.resource_types
            )
        if self.error_handling is not None:
            result["error_handling"] = (
                self.error_handling.value
                if hasattr(self.error_handling, "value")
                else self.error_handling
            )
        return result


@dataclass
class ExpiryConfig:
    """ExpiryConfig matching Go backend structure."""

    type: Any
    duration: Any = None
    field_name: str = None
    refresh_token_duration: Optional[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.duration is not None:
            result["duration"] = (
                self.duration.value
                if hasattr(self.duration, "value")
                else self.duration
            )
        if self.field_name is not None:
            result["field_name"] = (
                self.field_name.value
                if hasattr(self.field_name, "value")
                else self.field_name
            )
        if self.refresh_token_duration is not None:
            result["refresh_token_duration"] = (
                self.refresh_token_duration.value
                if hasattr(self.refresh_token_duration, "value")
                else self.refresh_token_duration
            )
        return result


@dataclass
class SegmentOption:
    """SegmentOption matching Go backend structure."""

    id: str
    name: str
    type: str
    metadata: Dict[str, str]
    children: List["SegmentOption"]
    parent_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.parent_id is not None:
            result["parent_id"] = (
                self.parent_id.value
                if hasattr(self.parent_id, "value")
                else self.parent_id
            )
        result["metadata"] = (
            self.metadata.value if hasattr(self.metadata, "value") else self.metadata
        )
        result["children"] = (
            self.children.value if hasattr(self.children, "value") else self.children
        )
        return result


@dataclass
class IntegrationDefinition:
    """IntegrationDefinition matching Go backend structure."""

    name: str
    key: str
    type: Any
    auth_types: List[Any]
    status: Any
    description: Optional[str] = None
    provider_name: Optional[str] = None
    documentation_url: Optional[str] = None
    openapi_documentation_url: Optional[str] = None
    llms_txt_url: Optional[str] = None
    healthcheck_url: Optional[str] = None
    auth_url: Optional[str] = None
    token_url: Optional[str] = None
    client_id: Optional[str] = None
    client_secret: Optional[str] = None
    available_scopes: List[str] = None
    optional_scopes: List[str] = None
    scope_separator: Optional[str] = None
    api_version: Optional[str] = None
    api_version_description: Optional[str] = None
    credential_schema: Dict[str, Any] = None
    ui_config: Optional["UIConfig"] = None
    codegen_details: Optional[CodegenDetails] = None
    analysis_details: Optional[AnalysisDetails] = None
    segment_config: Optional["SegmentConfig"] = None
    dataset_resource_discovery_config: Optional["DatasetResourceDiscoveryConfig"] = None
    expiry_config: Optional["ExpiryConfig"] = None
    provider_credentials: Dict[str, Any] = None
    default_resource_attach_type: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["auth_types"] = (
            self.auth_types.value
            if hasattr(self.auth_types, "value")
            else self.auth_types
        )
        result["status"] = (
            self.status.value if hasattr(self.status, "value") else self.status
        )
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        if self.provider_name is not None:
            result["provider_name"] = (
                self.provider_name.value
                if hasattr(self.provider_name, "value")
                else self.provider_name
            )
        if self.documentation_url is not None:
            result["documentation_url"] = (
                self.documentation_url.value
                if hasattr(self.documentation_url, "value")
                else self.documentation_url
            )
        if self.openapi_documentation_url is not None:
            result["openapi_documentation_url"] = (
                self.openapi_documentation_url.value
                if hasattr(self.openapi_documentation_url, "value")
                else self.openapi_documentation_url
            )
        if self.llms_txt_url is not None:
            result["llms_txt_url"] = (
                self.llms_txt_url.value
                if hasattr(self.llms_txt_url, "value")
                else self.llms_txt_url
            )
        if self.healthcheck_url is not None:
            result["healthcheck_url"] = (
                self.healthcheck_url.value
                if hasattr(self.healthcheck_url, "value")
                else self.healthcheck_url
            )
        if self.auth_url is not None:
            result["auth_url"] = (
                self.auth_url.value
                if hasattr(self.auth_url, "value")
                else self.auth_url
            )
        if self.token_url is not None:
            result["token_url"] = (
                self.token_url.value
                if hasattr(self.token_url, "value")
                else self.token_url
            )
        if self.client_id is not None:
            result["client_id"] = (
                self.client_id.value
                if hasattr(self.client_id, "value")
                else self.client_id
            )
        if self.client_secret is not None:
            result["client_secret"] = (
                self.client_secret.value
                if hasattr(self.client_secret, "value")
                else self.client_secret
            )
        if self.available_scopes is not None:
            result["available_scopes"] = (
                self.available_scopes.value
                if hasattr(self.available_scopes, "value")
                else self.available_scopes
            )
        if self.optional_scopes is not None:
            result["optional_scopes"] = (
                self.optional_scopes.value
                if hasattr(self.optional_scopes, "value")
                else self.optional_scopes
            )
        if self.scope_separator is not None:
            result["scope_separator"] = (
                self.scope_separator.value
                if hasattr(self.scope_separator, "value")
                else self.scope_separator
            )
        if self.api_version is not None:
            result["api_version"] = (
                self.api_version.value
                if hasattr(self.api_version, "value")
                else self.api_version
            )
        if self.api_version_description is not None:
            result["api_version_description"] = (
                self.api_version_description.value
                if hasattr(self.api_version_description, "value")
                else self.api_version_description
            )
        if self.credential_schema is not None:
            result["credential_schema"] = (
                self.credential_schema.value
                if hasattr(self.credential_schema, "value")
                else self.credential_schema
            )
        if self.ui_config is not None:
            result["ui_config"] = (
                self.ui_config.value
                if hasattr(self.ui_config, "value")
                else self.ui_config
            )
        if self.codegen_details is not None:
            result["codegen_details"] = (
                self.codegen_details.value
                if hasattr(self.codegen_details, "value")
                else self.codegen_details
            )
        if self.analysis_details is not None:
            result["analysis_details"] = (
                self.analysis_details.value
                if hasattr(self.analysis_details, "value")
                else self.analysis_details
            )
        if self.segment_config is not None:
            result["segment_config"] = (
                self.segment_config.value
                if hasattr(self.segment_config, "value")
                else self.segment_config
            )
        if self.dataset_resource_discovery_config is not None:
            result["dataset_resource_discovery_config"] = (
                self.dataset_resource_discovery_config.value
                if hasattr(self.dataset_resource_discovery_config, "value")
                else self.dataset_resource_discovery_config
            )
        if self.expiry_config is not None:
            result["expiry_config"] = (
                self.expiry_config.value
                if hasattr(self.expiry_config, "value")
                else self.expiry_config
            )
        if self.provider_credentials is not None:
            result["provider_credentials"] = (
                self.provider_credentials.value
                if hasattr(self.provider_credentials, "value")
                else self.provider_credentials
            )
        if self.default_resource_attach_type is not None:
            result["default_resource_attach_type"] = (
                self.default_resource_attach_type.value
                if hasattr(self.default_resource_attach_type, "value")
                else self.default_resource_attach_type
            )
        return result


@dataclass
class IntegrationConfig:
    """IntegrationConfig matching Go backend structure."""

    definition: "IntegrationDefinition"
    source: str
    file_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["definition"] = (
            self.definition.value
            if hasattr(self.definition, "value")
            else self.definition
        )
        result["source"] = (
            self.source.value if hasattr(self.source, "value") else self.source
        )
        if self.file_path is not None:
            result["file_path"] = (
                self.file_path.value
                if hasattr(self.file_path, "value")
                else self.file_path
            )
        return result


@dataclass
class PythonIntegrationInstance:
    """PythonIntegrationInstance matching Go backend structure."""

    config: IntegrationConfig
    credentials: Dict[str, Any]
    methods: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["config"] = (
            self.config.value if hasattr(self.config, "value") else self.config
        )
        result["credentials"] = (
            self.credentials.value
            if hasattr(self.credentials, "value")
            else self.credentials
        )
        if self.methods is not None:
            result["methods"] = (
                self.methods.value if hasattr(self.methods, "value") else self.methods
            )
        return result


@dataclass
class IntegrationDiscovery:
    """IntegrationDiscovery matching Go backend structure."""

    config: IntegrationConfig
    file_path: str
    source_code: str
    instance: Optional["PythonIntegrationInstance"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["config"] = (
            self.config.value if hasattr(self.config, "value") else self.config
        )
        if self.instance is not None:
            result["instance"] = (
                self.instance.value
                if hasattr(self.instance, "value")
                else self.instance
            )
        result["file_path"] = (
            self.file_path.value if hasattr(self.file_path, "value") else self.file_path
        )
        result["source_code"] = (
            self.source_code.value
            if hasattr(self.source_code, "value")
            else self.source_code
        )
        return result


@dataclass
class UpsertIntegrationRequest:
    """UpsertIntegrationRequest matching Go backend structure."""

    integration: "IntegrationDefinition"
    source: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integration"] = (
            self.integration.value
            if hasattr(self.integration, "value")
            else self.integration
        )
        result["source"] = (
            self.source.value if hasattr(self.source, "value") else self.source
        )
        return result


@dataclass
class UpsertIntegrationResponse:
    """UpsertIntegrationResponse matching Go backend structure."""

    integration_id: str
    status: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integration_id"] = (
            self.integration_id.value
            if hasattr(self.integration_id, "value")
            else self.integration_id
        )
        result["status"] = (
            self.status.value if hasattr(self.status, "value") else self.status
        )
        return result


@dataclass
class ListIntegrationsResponse:
    """ListIntegrationsResponse matching Go backend structure."""

    integrations: List["IntegrationDefinition"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integrations"] = (
            self.integrations.value
            if hasattr(self.integrations, "value")
            else self.integrations
        )
        return result


@dataclass
class ExportIntegrationsResponse:
    """ExportIntegrationsResponse matching Go backend structure."""

    integrations: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integrations"] = (
            self.integrations.value
            if hasattr(self.integrations, "value")
            else self.integrations
        )
        return result


@dataclass
class Memory:
    """Memory matching Go backend structure."""

    id: str
    content: str
    description: str
    tags: List[str]
    state: str
    created_by_entity_type: str
    created_by_id: str
    extra: Dict[str, Any]
    created_at: datetime
    updated_at: datetime
    type: str
    current_version: int
    approval_status: str
    estimated_stale_at: Optional[datetime] = None
    stale_when_text: Optional[str] = None
    created_from: Optional[str] = None
    organization_id: Optional[str] = None
    dataset_id: Optional[str] = None
    integration_config_id: Optional[str] = None
    user_id: Optional[str] = None
    thread_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        result["content"] = (
            self.content.value if hasattr(self.content, "value") else self.content
        )
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["tags"] = self.tags.value if hasattr(self.tags, "value") else self.tags
        result["state"] = (
            self.state.value if hasattr(self.state, "value") else self.state
        )
        if self.estimated_stale_at is not None:
            result["estimated_stale_at"] = (
                self.estimated_stale_at.value
                if hasattr(self.estimated_stale_at, "value")
                else self.estimated_stale_at
            )
        if self.stale_when_text is not None:
            result["stale_when_text"] = (
                self.stale_when_text.value
                if hasattr(self.stale_when_text, "value")
                else self.stale_when_text
            )
        result["created_by_entity_type"] = (
            self.created_by_entity_type.value
            if hasattr(self.created_by_entity_type, "value")
            else self.created_by_entity_type
        )
        result["created_by_id"] = (
            self.created_by_id.value
            if hasattr(self.created_by_id, "value")
            else self.created_by_id
        )
        if self.created_from is not None:
            result["created_from"] = (
                self.created_from.value
                if hasattr(self.created_from, "value")
                else self.created_from
            )
        if self.organization_id is not None:
            result["organization_id"] = (
                self.organization_id.value
                if hasattr(self.organization_id, "value")
                else self.organization_id
            )
        result["extra"] = (
            self.extra.value if hasattr(self.extra, "value") else self.extra
        )
        result["created_at"] = (
            self.created_at.value
            if hasattr(self.created_at, "value")
            else self.created_at
        )
        result["updated_at"] = (
            self.updated_at.value
            if hasattr(self.updated_at, "value")
            else self.updated_at
        )
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.dataset_id is not None:
            result["dataset_id"] = (
                self.dataset_id.value
                if hasattr(self.dataset_id, "value")
                else self.dataset_id
            )
        if self.integration_config_id is not None:
            result["integration_config_id"] = (
                self.integration_config_id.value
                if hasattr(self.integration_config_id, "value")
                else self.integration_config_id
            )
        if self.user_id is not None:
            result["user_id"] = (
                self.user_id.value if hasattr(self.user_id, "value") else self.user_id
            )
        if self.thread_id is not None:
            result["thread_id"] = (
                self.thread_id.value
                if hasattr(self.thread_id, "value")
                else self.thread_id
            )
        result["current_version"] = (
            self.current_version.value
            if hasattr(self.current_version, "value")
            else self.current_version
        )
        result["approval_status"] = (
            self.approval_status.value
            if hasattr(self.approval_status, "value")
            else self.approval_status
        )
        return result


@dataclass
class ResourceAnalysis:
    """ResourceAnalysis matching Go backend structure."""

    entity_key: str
    summary: Optional[str] = None
    last_analyzed: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.summary is not None:
            result["summary"] = (
                self.summary.value if hasattr(self.summary, "value") else self.summary
            )
        if self.last_analyzed is not None:
            result["last_analyzed"] = (
                self.last_analyzed.value
                if hasattr(self.last_analyzed, "value")
                else self.last_analyzed
            )
        result["entity_key"] = (
            self.entity_key.value
            if hasattr(self.entity_key, "value")
            else self.entity_key
        )
        return result


@dataclass
class Resource:
    """Resource matching Go backend structure."""

    id: str
    key: str
    name: str
    type: Any
    use_cases: List[str]
    tags: List[str]
    created_at: datetime
    updated_at: datetime
    integration_config_id: str
    state: Any
    attach_type: Any
    dataset_id: str
    analyses: List["ResourceAnalysis"]
    related_resources: List[Resource]
    metadata: Dict[str, Any]
    description: Optional[str] = None
    instructions: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        result["use_cases"] = (
            self.use_cases.value if hasattr(self.use_cases, "value") else self.use_cases
        )
        result["tags"] = self.tags.value if hasattr(self.tags, "value") else self.tags
        result["created_at"] = (
            self.created_at.value
            if hasattr(self.created_at, "value")
            else self.created_at
        )
        result["updated_at"] = (
            self.updated_at.value
            if hasattr(self.updated_at, "value")
            else self.updated_at
        )
        result["integration_config_id"] = (
            self.integration_config_id.value
            if hasattr(self.integration_config_id, "value")
            else self.integration_config_id
        )
        result["state"] = (
            self.state.value if hasattr(self.state, "value") else self.state
        )
        result["attach_type"] = (
            self.attach_type.value
            if hasattr(self.attach_type, "value")
            else self.attach_type
        )
        result["dataset_id"] = (
            self.dataset_id.value
            if hasattr(self.dataset_id, "value")
            else self.dataset_id
        )
        if self.instructions is not None:
            result["instructions"] = (
                self.instructions.value
                if hasattr(self.instructions, "value")
                else self.instructions
            )
        result["analyses"] = (
            self.analyses.value if hasattr(self.analyses, "value") else self.analyses
        )
        result["related_resources"] = (
            self.related_resources.value
            if hasattr(self.related_resources, "value")
            else self.related_resources
        )
        result["metadata"] = (
            self.metadata.value if hasattr(self.metadata, "value") else self.metadata
        )
        return result


# Integration classes from Go structs
@dataclass
class UIConfigIcon:
    """UIConfigIcon matching Go backend structure."""

    set: str
    name: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["set"] = self.set.value if hasattr(self.set, "value") else self.set
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        return result


@dataclass
class UIConfig:
    """UIConfig matching Go backend structure."""

    brand_logo_icon: "UIConfigIcon"
    brand_color: str
    button_style: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["brand_logo_icon"] = (
            self.brand_logo_icon.value
            if hasattr(self.brand_logo_icon, "value")
            else self.brand_logo_icon
        )
        result["brand_color"] = (
            self.brand_color.value
            if hasattr(self.brand_color, "value")
            else self.brand_color
        )
        result["button_style"] = (
            self.button_style.value
            if hasattr(self.button_style, "value")
            else self.button_style
        )
        return result


@dataclass
class ErrorHandlingConfig:
    """ErrorHandlingConfig matching Go backend structure."""

    ignore_errors: List[str] = None
    error_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        if self.ignore_errors is not None:
            result["ignore_errors"] = (
                self.ignore_errors.value
                if hasattr(self.ignore_errors, "value")
                else self.ignore_errors
            )
        if self.error_path is not None:
            result["error_path"] = (
                self.error_path.value
                if hasattr(self.error_path, "value")
                else self.error_path
            )
        return result


@dataclass
class SegmentLevel:
    """SegmentLevel matching Go backend structure."""

    name: str
    type: str
    selectable: bool
    url_template: str = None
    method: str = None
    body: str = None
    id_path: str = None
    id_regex: str = None
    name_path: str = None
    parent_key: str = None
    required_credentials: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["selectable"] = (
            self.selectable.value
            if hasattr(self.selectable, "value")
            else self.selectable
        )
        if self.url_template is not None:
            result["url_template"] = (
                self.url_template.value
                if hasattr(self.url_template, "value")
                else self.url_template
            )
        if self.method is not None:
            result["method"] = (
                self.method.value if hasattr(self.method, "value") else self.method
            )
        if self.body is not None:
            result["body"] = (
                self.body.value if hasattr(self.body, "value") else self.body
            )
        if self.id_path is not None:
            result["id_path"] = (
                self.id_path.value if hasattr(self.id_path, "value") else self.id_path
            )
        if self.id_regex is not None:
            result["id_regex"] = (
                self.id_regex.value
                if hasattr(self.id_regex, "value")
                else self.id_regex
            )
        if self.name_path is not None:
            result["name_path"] = (
                self.name_path.value
                if hasattr(self.name_path, "value")
                else self.name_path
            )
        if self.parent_key is not None:
            result["parent_key"] = (
                self.parent_key.value
                if hasattr(self.parent_key, "value")
                else self.parent_key
            )
        if self.required_credentials is not None:
            result["required_credentials"] = (
                self.required_credentials.value
                if hasattr(self.required_credentials, "value")
                else self.required_credentials
            )
        return result


@dataclass
class SegmentConfig:
    """SegmentConfig matching Go backend structure."""

    selection_type: Any
    description: str
    hierarchical: bool
    levels: List["SegmentLevel"]
    min_selections: Optional[int] = None
    max_selections: Optional[int] = None
    base_url: str = None
    error_handling: Optional["ErrorHandlingConfig"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["selection_type"] = (
            self.selection_type.value
            if hasattr(self.selection_type, "value")
            else self.selection_type
        )
        if self.min_selections is not None:
            result["min_selections"] = (
                self.min_selections.value
                if hasattr(self.min_selections, "value")
                else self.min_selections
            )
        if self.max_selections is not None:
            result["max_selections"] = (
                self.max_selections.value
                if hasattr(self.max_selections, "value")
                else self.max_selections
            )
        result["description"] = (
            self.description.value
            if hasattr(self.description, "value")
            else self.description
        )
        result["hierarchical"] = (
            self.hierarchical.value
            if hasattr(self.hierarchical, "value")
            else self.hierarchical
        )
        if self.base_url is not None:
            result["base_url"] = (
                self.base_url.value
                if hasattr(self.base_url, "value")
                else self.base_url
            )
        result["levels"] = (
            self.levels.value if hasattr(self.levels, "value") else self.levels
        )
        if self.error_handling is not None:
            result["error_handling"] = (
                self.error_handling.value
                if hasattr(self.error_handling, "value")
                else self.error_handling
            )
        return result


@dataclass
class ResourceTypeConfig:
    """ResourceTypeConfig matching Go backend structure."""

    type: str
    url_template: str
    id_path: str
    name_path: str
    method: str = None
    body: str = None
    description_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["url_template"] = (
            self.url_template.value
            if hasattr(self.url_template, "value")
            else self.url_template
        )
        if self.method is not None:
            result["method"] = (
                self.method.value if hasattr(self.method, "value") else self.method
            )
        if self.body is not None:
            result["body"] = (
                self.body.value if hasattr(self.body, "value") else self.body
            )
        result["id_path"] = (
            self.id_path.value if hasattr(self.id_path, "value") else self.id_path
        )
        result["name_path"] = (
            self.name_path.value if hasattr(self.name_path, "value") else self.name_path
        )
        if self.description_path is not None:
            result["description_path"] = (
                self.description_path.value
                if hasattr(self.description_path, "value")
                else self.description_path
            )
        return result


@dataclass
class DatasetResourceDiscoveryConfig:
    """DatasetResourceDiscoveryConfig matching Go backend structure."""

    min_resources_required: int
    table_query: str = None
    relationship_query: str = None
    index_query: str = None
    constraint_query: str = None
    statistics_query: str = None
    size_query: str = None
    base_url: str = None
    resource_types: List["ResourceTypeConfig"] = None
    error_handling: Optional["ErrorHandlingConfig"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["min_resources_required"] = (
            self.min_resources_required.value
            if hasattr(self.min_resources_required, "value")
            else self.min_resources_required
        )
        if self.table_query is not None:
            result["table_query"] = (
                self.table_query.value
                if hasattr(self.table_query, "value")
                else self.table_query
            )
        if self.relationship_query is not None:
            result["relationship_query"] = (
                self.relationship_query.value
                if hasattr(self.relationship_query, "value")
                else self.relationship_query
            )
        if self.index_query is not None:
            result["index_query"] = (
                self.index_query.value
                if hasattr(self.index_query, "value")
                else self.index_query
            )
        if self.constraint_query is not None:
            result["constraint_query"] = (
                self.constraint_query.value
                if hasattr(self.constraint_query, "value")
                else self.constraint_query
            )
        if self.statistics_query is not None:
            result["statistics_query"] = (
                self.statistics_query.value
                if hasattr(self.statistics_query, "value")
                else self.statistics_query
            )
        if self.size_query is not None:
            result["size_query"] = (
                self.size_query.value
                if hasattr(self.size_query, "value")
                else self.size_query
            )
        if self.base_url is not None:
            result["base_url"] = (
                self.base_url.value
                if hasattr(self.base_url, "value")
                else self.base_url
            )
        if self.resource_types is not None:
            result["resource_types"] = (
                self.resource_types.value
                if hasattr(self.resource_types, "value")
                else self.resource_types
            )
        if self.error_handling is not None:
            result["error_handling"] = (
                self.error_handling.value
                if hasattr(self.error_handling, "value")
                else self.error_handling
            )
        return result


@dataclass
class ExpiryConfig:
    """ExpiryConfig matching Go backend structure."""

    type: Any
    duration: Any = None
    field_name: str = None
    refresh_token_duration: Optional[Any] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.duration is not None:
            result["duration"] = (
                self.duration.value
                if hasattr(self.duration, "value")
                else self.duration
            )
        if self.field_name is not None:
            result["field_name"] = (
                self.field_name.value
                if hasattr(self.field_name, "value")
                else self.field_name
            )
        if self.refresh_token_duration is not None:
            result["refresh_token_duration"] = (
                self.refresh_token_duration.value
                if hasattr(self.refresh_token_duration, "value")
                else self.refresh_token_duration
            )
        return result


@dataclass
class SegmentOption:
    """SegmentOption matching Go backend structure."""

    id: str
    name: str
    type: str
    metadata: Dict[str, str]
    children: List["SegmentOption"]
    parent_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["id"] = self.id.value if hasattr(self.id, "value") else self.id
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        if self.parent_id is not None:
            result["parent_id"] = (
                self.parent_id.value
                if hasattr(self.parent_id, "value")
                else self.parent_id
            )
        result["metadata"] = (
            self.metadata.value if hasattr(self.metadata, "value") else self.metadata
        )
        result["children"] = (
            self.children.value if hasattr(self.children, "value") else self.children
        )
        return result


@dataclass
class IntegrationDefinition:
    """IntegrationDefinition matching Go backend structure."""

    name: str
    key: str
    type: Any
    auth_types: List[Any]
    status: Any
    description: Optional[str] = None
    provider_name: Optional[str] = None
    documentation_url: Optional[str] = None
    openapi_documentation_url: Optional[str] = None
    llms_txt_url: Optional[str] = None
    healthcheck_url: Optional[str] = None
    auth_url: Optional[str] = None
    token_url: Optional[str] = None
    client_id: Optional[str] = None
    client_secret: Optional[str] = None
    available_scopes: List[str] = None
    optional_scopes: List[str] = None
    scope_separator: Optional[str] = None
    api_version: Optional[str] = None
    api_version_description: Optional[str] = None
    credential_schema: Dict[str, Any] = None
    ui_config: Optional["UIConfig"] = None
    codegen_details: Optional[CodegenDetails] = None
    analysis_details: Optional[AnalysisDetails] = None
    segment_config: Optional["SegmentConfig"] = None
    dataset_resource_discovery_config: Optional["DatasetResourceDiscoveryConfig"] = None
    expiry_config: Optional["ExpiryConfig"] = None
    provider_credentials: Dict[str, Any] = None
    default_resource_attach_type: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["name"] = self.name.value if hasattr(self.name, "value") else self.name
        result["key"] = self.key.value if hasattr(self.key, "value") else self.key
        result["type"] = self.type.value if hasattr(self.type, "value") else self.type
        result["auth_types"] = (
            self.auth_types.value
            if hasattr(self.auth_types, "value")
            else self.auth_types
        )
        result["status"] = (
            self.status.value if hasattr(self.status, "value") else self.status
        )
        if self.description is not None:
            result["description"] = (
                self.description.value
                if hasattr(self.description, "value")
                else self.description
            )
        if self.provider_name is not None:
            result["provider_name"] = (
                self.provider_name.value
                if hasattr(self.provider_name, "value")
                else self.provider_name
            )
        if self.documentation_url is not None:
            result["documentation_url"] = (
                self.documentation_url.value
                if hasattr(self.documentation_url, "value")
                else self.documentation_url
            )
        if self.openapi_documentation_url is not None:
            result["openapi_documentation_url"] = (
                self.openapi_documentation_url.value
                if hasattr(self.openapi_documentation_url, "value")
                else self.openapi_documentation_url
            )
        if self.llms_txt_url is not None:
            result["llms_txt_url"] = (
                self.llms_txt_url.value
                if hasattr(self.llms_txt_url, "value")
                else self.llms_txt_url
            )
        if self.healthcheck_url is not None:
            result["healthcheck_url"] = (
                self.healthcheck_url.value
                if hasattr(self.healthcheck_url, "value")
                else self.healthcheck_url
            )
        if self.auth_url is not None:
            result["auth_url"] = (
                self.auth_url.value
                if hasattr(self.auth_url, "value")
                else self.auth_url
            )
        if self.token_url is not None:
            result["token_url"] = (
                self.token_url.value
                if hasattr(self.token_url, "value")
                else self.token_url
            )
        if self.client_id is not None:
            result["client_id"] = (
                self.client_id.value
                if hasattr(self.client_id, "value")
                else self.client_id
            )
        if self.client_secret is not None:
            result["client_secret"] = (
                self.client_secret.value
                if hasattr(self.client_secret, "value")
                else self.client_secret
            )
        if self.available_scopes is not None:
            result["available_scopes"] = (
                self.available_scopes.value
                if hasattr(self.available_scopes, "value")
                else self.available_scopes
            )
        if self.optional_scopes is not None:
            result["optional_scopes"] = (
                self.optional_scopes.value
                if hasattr(self.optional_scopes, "value")
                else self.optional_scopes
            )
        if self.scope_separator is not None:
            result["scope_separator"] = (
                self.scope_separator.value
                if hasattr(self.scope_separator, "value")
                else self.scope_separator
            )
        if self.api_version is not None:
            result["api_version"] = (
                self.api_version.value
                if hasattr(self.api_version, "value")
                else self.api_version
            )
        if self.api_version_description is not None:
            result["api_version_description"] = (
                self.api_version_description.value
                if hasattr(self.api_version_description, "value")
                else self.api_version_description
            )
        if self.credential_schema is not None:
            result["credential_schema"] = (
                self.credential_schema.value
                if hasattr(self.credential_schema, "value")
                else self.credential_schema
            )
        if self.ui_config is not None:
            result["ui_config"] = (
                self.ui_config.value
                if hasattr(self.ui_config, "value")
                else self.ui_config
            )
        if self.codegen_details is not None:
            result["codegen_details"] = (
                self.codegen_details.value
                if hasattr(self.codegen_details, "value")
                else self.codegen_details
            )
        if self.analysis_details is not None:
            result["analysis_details"] = (
                self.analysis_details.value
                if hasattr(self.analysis_details, "value")
                else self.analysis_details
            )
        if self.segment_config is not None:
            result["segment_config"] = (
                self.segment_config.value
                if hasattr(self.segment_config, "value")
                else self.segment_config
            )
        if self.dataset_resource_discovery_config is not None:
            result["dataset_resource_discovery_config"] = (
                self.dataset_resource_discovery_config.value
                if hasattr(self.dataset_resource_discovery_config, "value")
                else self.dataset_resource_discovery_config
            )
        if self.expiry_config is not None:
            result["expiry_config"] = (
                self.expiry_config.value
                if hasattr(self.expiry_config, "value")
                else self.expiry_config
            )
        if self.provider_credentials is not None:
            result["provider_credentials"] = (
                self.provider_credentials.value
                if hasattr(self.provider_credentials, "value")
                else self.provider_credentials
            )
        if self.default_resource_attach_type is not None:
            result["default_resource_attach_type"] = (
                self.default_resource_attach_type.value
                if hasattr(self.default_resource_attach_type, "value")
                else self.default_resource_attach_type
            )
        return result


@dataclass
class IntegrationConfig:
    """IntegrationConfig matching Go backend structure."""

    definition: "IntegrationDefinition"
    source: str
    file_path: str = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["definition"] = (
            self.definition.value
            if hasattr(self.definition, "value")
            else self.definition
        )
        result["source"] = (
            self.source.value if hasattr(self.source, "value") else self.source
        )
        if self.file_path is not None:
            result["file_path"] = (
                self.file_path.value
                if hasattr(self.file_path, "value")
                else self.file_path
            )
        return result


@dataclass
class PythonIntegrationInstance:
    """PythonIntegrationInstance matching Go backend structure."""

    config: IntegrationConfig
    credentials: Dict[str, Any]
    methods: List[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["config"] = (
            self.config.value if hasattr(self.config, "value") else self.config
        )
        result["credentials"] = (
            self.credentials.value
            if hasattr(self.credentials, "value")
            else self.credentials
        )
        if self.methods is not None:
            result["methods"] = (
                self.methods.value if hasattr(self.methods, "value") else self.methods
            )
        return result


@dataclass
class IntegrationDiscovery:
    """IntegrationDiscovery matching Go backend structure."""

    config: IntegrationConfig
    file_path: str
    source_code: str
    instance: Optional["PythonIntegrationInstance"] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["config"] = (
            self.config.value if hasattr(self.config, "value") else self.config
        )
        if self.instance is not None:
            result["instance"] = (
                self.instance.value
                if hasattr(self.instance, "value")
                else self.instance
            )
        result["file_path"] = (
            self.file_path.value if hasattr(self.file_path, "value") else self.file_path
        )
        result["source_code"] = (
            self.source_code.value
            if hasattr(self.source_code, "value")
            else self.source_code
        )
        return result


@dataclass
class UpsertIntegrationRequest:
    """UpsertIntegrationRequest matching Go backend structure."""

    integration: "IntegrationDefinition"
    source: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integration"] = (
            self.integration.value
            if hasattr(self.integration, "value")
            else self.integration
        )
        result["source"] = (
            self.source.value if hasattr(self.source, "value") else self.source
        )
        return result


@dataclass
class UpsertIntegrationResponse:
    """UpsertIntegrationResponse matching Go backend structure."""

    integration_id: str
    status: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integration_id"] = (
            self.integration_id.value
            if hasattr(self.integration_id, "value")
            else self.integration_id
        )
        result["status"] = (
            self.status.value if hasattr(self.status, "value") else self.status
        )
        return result


@dataclass
class ListIntegrationsResponse:
    """ListIntegrationsResponse matching Go backend structure."""

    integrations: List["IntegrationDefinition"]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integrations"] = (
            self.integrations.value
            if hasattr(self.integrations, "value")
            else self.integrations
        )
        return result


@dataclass
class ExportIntegrationsResponse:
    """ExportIntegrationsResponse matching Go backend structure."""

    integrations: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict format expected by backend."""
        result = {}
        result["integrations"] = (
            self.integrations.value
            if hasattr(self.integrations, "value")
            else self.integrations
        )
        return result


# Auto-generated __all__ list for import *
__all__ = [
    "APIConditionDefinition",
    "APIExecutionMode",
    "APIParameterDefinition",
    "APIParameterInterpreter",
    "APIParameterValueSource",
    "APIParameterValueSourceHandler",
    "APIResultHandler",
    "APIStep",
    "APIStepWithHandlers",
    "APITool",
    "ActionDefinition",
    "AnalysisDetails",
    "AuthType",
    "Bot",
    "BotResource",
    "BotsResponse",
    "CodegenDetails",
    "ConditionDefinition",
    "CredentialSchema",
    "CredentialSource",
    "Dataset",
    "DatasetResourceDiscoveryConfig",
    "DatasetType",
    "Error",
    "ErrorHandlingConfig",
    "ExecutionModeType",
    "ExpiryConfig",
    "ExpiryType",
    "ExportActionsResponse",
    "ExportIntegrationsResponse",
    "HandlerType",
    "IntegrationConfig",
    "IntegrationDefinition",
    "IntegrationDiscovery",
    "IntegrationSchema",
    "IntegrationStatus",
    "IntegrationType",
    "InvocationEventType",
    "JSONSchema",
    "JSONSchemaProperty",
    "JSONSchemaType",
    "ListIntegrationsResponse",
    "LlmModel",
    "Memory",
    "Message",
    "OutputBehaviorType",
    "OutputContentType",
    "OutputVisibility",
    "ParameterDefinition",
    "ParameterHydrationBehaviour",
    "ParameterInterpreter",
    "ParameterType",
    "ParameterValueSource",
    "ParameterValueSourceHandler",
    "PropertySchema",
    "PythonIntegrationInstance",
    "Resource",
    "ResourceAnalysis",
    "ResourceAttachType",
    "ResourceRelationshipType",
    "ResourceState",
    "ResourceType",
    "ResourceTypeConfig",
    "Result",
    "ResultSchema",
    "SegmentConfig",
    "SegmentLevel",
    "SegmentOption",
    "SegmentSelectionType",
    "SensitivityLevel",
    "ServiceDefinition",
    "Status",
    "StepsResponse",
    "SystemParameters",
    "TempCondition",
    "Tool",
    "UIConfig",
    "UIConfigIcon",
    "UpsertBotRequest",
    "UpsertIntegrationRequest",
    "UpsertIntegrationResponse",
]


# Helper functions for creating bot definitions
def create_step(
    key: str,
    action_type: str,
    parameters: Dict[str, Any] = None,
    depends_on: List[str] = None,
    **kwargs,
) -> Dict[str, Any]:
    """Create a step definition dictionary."""
    step = {
        "key": key,
        "action_type": action_type,
        "parameters": parameters or {},
        "output_content_type": kwargs.get("output_content_type", "text"),
        "user_output_visibility": kwargs.get("user_output_visibility", "visible"),
        "bot_output_visibility": kwargs.get("bot_output_visibility", "hidden"),
    }

    # Add optional fields if provided
    for field in [
        "history_content_type",
        "ui_content_type",
        "running_status",
        "finished_status",
    ]:
        if field in kwargs:
            step[field] = kwargs[field]

    return {
        "step": step,
        "depends_on": depends_on,
        "result_handlers": [],
        "output_channels": [],
    }


def create_result_handler(
    condition: Dict[str, Any],
    action_type: str = None,
    parameters: Dict[str, Any] = None,
    steps: List[Dict[str, Any]] = None,
    **kwargs,
) -> Dict[str, Any]:
    """Create a result handler definition dictionary."""
    handler = {
        "type": kwargs.get("type", "final"),
        "if_conditions": condition,
        "output_content_type": kwargs.get("output_content_type", "text"),
        "steps": steps or [],
    }

    # Add optional fields
    for field in ["history_content_type", "ui_content_type"]:
        if field in kwargs:
            handler[field] = kwargs[field]

    # If action_type is provided, create a step for it
    if action_type:
        step = {
            "key": f"handler_step_{len(handler['steps'])}",
            "action_type": action_type,
            "parameters": parameters or {},
            "output_content_type": "text",
            "user_output_visibility": "visible",
            "bot_output_visibility": "hidden",
        }
        handler["steps"].append(step)

    return handler


def create_bot(
    name: str, description: str = "", visibility: str = "private", **kwargs
) -> Dict[str, Any]:
    """Create a bot definition dictionary."""
    return {
        "Name": name,
        "Description": description,
        "Visibility": visibility,
        "RunningMessage": {
            "String": kwargs.get("running_status", ""),
            "Valid": bool(kwargs.get("running_status")),
        },
        "FinishedMessage": {
            "String": kwargs.get("finished_status", ""),
            "Valid": bool(kwargs.get("finished_status")),
        },
        "Persona": {
            "String": kwargs.get("persona", ""),
            "Valid": bool(kwargs.get("persona")),
        },
        "Source": "python",
    }
