import sys
import os

# Add parent dir to path to import realfastapi
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../..")))

from typing import List, Optional, Any, Sequence

import uvicorn
from fastapi import Depends
from pydantic import BaseModel, ConfigDict
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, Mapped, mapped_column, selectinload
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import HTTPException

# Import from the package
from realfastapi.core import RealFastAPI, RealFastAPIConfig, DatabaseConfig, AuthConfig
from realfastapi.crud.base import BaseCRUD
from realfastapi.database.base import Base
from realfastapi.crud.routes import create_crud_router


# --- 1. Define Models (with Relationships) ---
class User(Base):
    __tablename__ = "user"  # type: ignore[assignment]
    id: Mapped[int] = mapped_column(primary_key=True)
    username: Mapped[str] = mapped_column(unique=True, index=True)
    password: Mapped[str] = mapped_column()
    # Relationship
    items: Mapped[List["Item"]] = relationship(back_populates="owner")


class Item(Base):
    __tablename__ = "item"  # type: ignore[assignment]
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(index=True)
    description: Mapped[Optional[str]] = mapped_column(nullable=True)
    owner_id: Mapped[int] = mapped_column(ForeignKey("user.id"))
    # Relationship
    owner: Mapped["User"] = relationship(back_populates="items")


# --- 2. Define Schemas ---
# Item Schemas
class ItemBase(BaseModel):
    title: str
    description: Optional[str] = None


class ItemCreate(ItemBase):
    owner_id: int


class ItemUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None


class ItemOut(ItemBase):
    id: int
    owner_id: int

    model_config = ConfigDict(from_attributes=True)


# User Schemas
class UserBase(BaseModel):
    username: str


class UserCreate(UserBase):
    password: str


class UserUpdate(BaseModel):
    username: Optional[str] = None


class UserOut(UserBase):
    id: int
    # We can include items here to demonstrate relationships
    # But usually avoided to prevent circular deps or huge payloads in lists
    # items: List[ItemOut] = []

    model_config = ConfigDict(from_attributes=True)


class UserOutWithItems(UserOut):
    items: List[ItemOut] = []


# --- 3. Define CRUD ---
crud_user = BaseCRUD(User, UserCreate, UserUpdate, UserOut)
# We can also use UserOutWithItems for specific endpoints if we want
crud_item = BaseCRUD(Item, ItemCreate, ItemUpdate, ItemOut)

# --- 4. Setup App ---
# Use absolute path to avoid CWD ambiguity
db_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "example_app.db"))
# Fix for Windows paths in URL
db_path = db_path.replace("\\", "/")
db_config = DatabaseConfig(url=f"sqlite+aiosqlite:///{db_path}")
auth_config = AuthConfig(secret_key="SUPER_SECRET_KEY", token_url="/auth/login")

config = RealFastAPIConfig(
    title="RealFastAPI Showcase",
    db_config=db_config,
    auth_config=auth_config,
)

app = RealFastAPI(config)


# Helper to access DB safely
async def get_db() -> AsyncSession:  # type: ignore[misc]
    if app.db is None:
        raise RuntimeError("Database not initialized")
    async for session in app.db.get_db():
        yield session


# --- 5. Register Routes ---

# A. Auth Routes (Auto-generated by RealFastAPI if auth_config is present?
# No, only get_current_user helper is added. We still need generic routes if we want them.)
# But RealFastAPI currently includes methods, let's use the explicit router helper.
from realfastapi.auth.routes import create_auth_router

create_auth_router(
    app=app,
    prefix="/auth",
    tags=["Auth"],
    crud=crud_user,  # Use user CRUD for auth
    secret_key="SUPER_SECRET_KEY",
    username_field="username",
    password_field="password",
)

# B. CRUD Routes for Users
# We want to allow anyone to see users, but only authenticated to modify?
# Let's keep it simple: Public Read, Protected Write.
# Note: create_crud_router assumes one security level for the whole router if dependencies is passed.
# For mixed, we might need two routers or custom override.
# Let's make Users protected.
create_crud_router(
    crud=crud_user,
    path="/users",
    app=app,
    password_field="password",  # Handles hashing automatically
    tags=["Users"],
)

# C. CRUD Routes for Items
# Let's make Items public to read, but protected to write?
# For simplicity, let's just make a standard generic router.
create_crud_router(crud=crud_item, path="/items", app=app, tags=["Items"])

# --- 6. Custom Endpoints (Showcasing Advanced Features) ---


@app.on_event("startup")
async def startup() -> None:
    if app.db is None:
        raise RuntimeError("Database not initialized")
    async with app.db.engine.begin() as conn:
        # Base.metadata is sometimes hidden from mypy
        await conn.run_sync(Base.metadata.create_all)  # type: ignore[attr-defined]


# Example: Custom endpoint using load_options to eager load items for a user
@app.get("/users/{user_id}/details", response_model=UserOutWithItems)
async def read_user_with_items(
    user_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: str = Depends(app.get_current_user),
) -> Any:
    """
    Demonstrates using `load_options` to eager load relationships (N+1 prevention).
    """
    # We use selectinload because it's async-friendly for collection loading
    user: Any = await crud_user.read(
        db, id=user_id, load_options=[selectinload(User.items)]
    )

    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    if current_user != user.username:
        raise HTTPException(status_code=403, detail="User not authorized")

    return user


# Example: Custom endpoint using Advanced Filtering manually
@app.get("/search/items")
async def search_items(q: str, db: AsyncSession = Depends(get_db)) -> Any:
    """
    Demonstrates using advanced filters manually via BaseCRUD.
    """
    # Finds items where title ILIKE %q% OR description ILIKE %q%
    # Note: BaseCRUD.read_multi filters are ANDed. For OR, we'd need custom query.
    # But we can show standard filtering:

    return await crud_item.read_multi(db, filters={"title__ilike": f"%{q}%"})


if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8000, reload=False)
