import os
import tomllib
from typing import Any, Optional

from loguru import logger
from typeguard import CollectionCheckStrategy, TypeCheckError, check_type

from pymetropolis.metro_common import MetropyError
from pymetropolis.metro_common.types import MetroType, Path


class ConfigItem:
    def __init__(
        self,
        slug: str,
        key: str,
        description: Optional[str] = None,
        example: Optional[str] = None,
        note: Optional[str] = None,
    ):
        self.slug = slug
        self.key = key
        self.description = description
        self.example = example
        self.note = note


class ConfigValue(ConfigItem):
    def __init__(
        self,
        slug: str,
        key: str,
        expected_type=None,
        default=None,
        description: Optional[str] = None,
        example: Optional[str] = None,
        note: Optional[str] = None,
    ):
        super().__init__(slug, key, description, example, note)
        self.expected_type = expected_type
        self.default = default

    def is_file(self) -> bool:
        return False

    def has_default(self) -> bool:
        return self.default is not None

    def parse(self, value: Any) -> Any:
        if isinstance(self.expected_type, MetroType):
            return self.expected_type.parse(value)
        else:
            return value

    def value_is_valid(self, value: Any) -> bool:
        if isinstance(self.expected_type, MetroType):
            return self.expected_type.check(value)
        else:
            try:
                check_type(
                    value,
                    self.expected_type,
                    collection_check_strategy=CollectionCheckStrategy.ALL_ITEMS,
                )
            except TypeCheckError:
                return False
            else:
                return True


class InputFile(ConfigValue):
    def __init__(
        self,
        slug: str,
        key: str,
        description: Optional[str] = None,
        example: Optional[str] = None,
        note: Optional[str] = None,
        extensions: Optional[list[str]] = None,
    ):
        super().__init__(
            slug,
            key,
            description=description,
            example=example,
            note=note,
            expected_type=Path(extensions),
            default=None,
        )

    def is_file(self) -> bool:
        return True


class ConfigTable(ConfigItem):
    def __init__(
        self,
        slug: str,
        key: str,
        items: list[ConfigItem],
        description: Optional[str] = None,
        example: Optional[str] = None,
        note: Optional[str] = None,
    ):
        super().__init__(slug, key, description, example, note)
        self.items = items


MAIN_DIRECTORY = ConfigValue(
    "main_directory",
    "main_directory",
    expected_type=Path(),
    default="output/",
    description="Directory where the files generated by pymetropolis will be stored.",
    example='"paris/output/"',
    note="If the directory does not exist, it will be created automatically.",
)

RANDOM_SEED = ConfigValue(
    "random_seed",
    "random_seed",
    expected_type=int,
    default=None,
    description="Random seed used to initialize the random number generator.",
    note=(
        "If the random seed is not defined, some operations are not deterministic, i.e., they can "
        "produce different results if re-run."
    ),
)

BASE_SCHEMA = [MAIN_DIRECTORY, RANDOM_SEED]


class Config:
    def __init__(self):
        self.flat_config = dict()

    @classmethod
    def from_toml(cls, path: str, schema: list[ConfigItem]):
        """Initializes a Config from the path to a TOML file.

        Raises an exception if the given filename does not exist or is an invalid TOML file.
        """
        if not os.path.isfile(path):
            raise MetropyError("Cannot read config file: {}".format(os.path.abspath(path)))
        with open(path, "rb") as f:
            input_dict = tomllib.load(f)
        inst = cls()
        inst.parse_config(input_dict, schema)
        inst.check_main_directory()
        return inst

    def parse_config(self, input_dict: dict, schema: list[ConfigItem]):
        for item in schema:
            if isinstance(item, ConfigTable):
                inner = input_dict.get(item.key)
                if inner is None:
                    # Parse the table even if it is not defined, so that default values are created.
                    self.parse_config(dict(), item.items)
                else:
                    if not isinstance(inner, dict):
                        raise MetropyError(f"Config value {item.key} should be a Toml table")
                    # Add an entry in the flat config so that it is possible to check whether the table
                    # is defined (even when it has no defined items).
                    self.flat_config[item.slug] = None
                    self.parse_config(inner, item.items)
            elif isinstance(item, ConfigValue):
                if item.slug in self.flat_config:
                    raise MetropyError(f"Duplicate slug in the configuration: {item.slug}")
                if item.key in input_dict:
                    input_value = input_dict[item.key]
                    if not item.value_is_valid(input_value):
                        # The provided value is not a valid value.
                        # TODO: store error message, only show these error message if asked or if
                        # the key-value is actually read.
                        logger.warning(f"Config parameter `{item.slug}` is not valid")
                        pass
                    self.flat_config[item.slug] = item.parse(input_value)
                elif item.has_default():
                    self.flat_config[item.slug] = item.default
                else:
                    # No value is provided and there is no default: do not insert the item in the
                    # flat dictionary.
                    continue

    def check_main_directory(self):
        """Asserts that `main_directory` is properly defined and that the directory exists.

        If the directory does not exist, creates it.
        """
        if not self.has_value(MAIN_DIRECTORY):
            raise MetropyError("Config value `main_directory` is mandatory")
        main_dir = self[MAIN_DIRECTORY]
        if not os.path.isdir(main_dir):
            os.makedirs(main_dir)
        # Also create the update_files/ directory if needed.
        update_files_dir = os.path.join(main_dir, "update_files")
        if not os.path.isdir(update_files_dir):
            os.makedirs(update_files_dir)

    def has_value(self, value: ConfigValue) -> bool:
        """Returns `True` if the given ConfigValue exists in the config."""
        return value.slug in self.flat_config

    def has_table(self, table: ConfigTable) -> bool:
        """Returns `True` if the given ConfigTable exists in the config."""
        return table.slug in self.flat_config

    def __getitem__(self, value: ConfigValue) -> Any:
        """Returns the value for the given key.

        Raises IndexError if the value is missing.
        """
        return self.flat_config[value.slug]

    def get(self, value: ConfigValue) -> Any:
        """Returns the value for the given key.

        Returns None if the value is missing.
        """
        try:
            return self.flat_config[value.slug]
        except KeyError:
            return None

    def path_from_main_dir(self, path: str) -> str:
        return os.path.join(self[MAIN_DIRECTORY], path)

    def update_dict_path(self, slug: str) -> str:
        """Returns the path to the JSON update file corresponding to the given slug."""
        return self.path_from_main_dir(os.path.join("update_files", f"{slug}.json"))
