<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Klaude Code - Mermaid</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%233b82f6%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22><polyline points=%2216 18 22 12 16 6%22></polyline><polyline points=%228 6 2 12 8 18%22></polyline></svg>"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/@fontsource/geist/400.css"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/@fontsource/geist/600.css"
      rel="stylesheet"
    />

    <style>

      :root {
        --font-sans: "Geist", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        --font-mono: "SF Mono", Menlo, ui-monospace, SFMono-Regular, monospace;
        --bg-color: #f8fafc;
        --panel-bg: rgba(255, 255, 255, 0.95);
        --panel-border: rgba(226, 232, 240, 1);
        --text-primary: #1e293b;
        --text-secondary: #64748b;
        --accent: #3b82f6;
        --accent-hover: #2563eb;
        --error: #ef4444;
        --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1),
          0 2px 4px -2px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),
          0 4px 6px -4px rgb(0 0 0 / 0.05);
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        margin: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        background-color: var(--bg-color);
        font-family: var(--font-sans);
        color: var(--text-primary);
        -webkit-font-smoothing: antialiased;
      }

      .app {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
      }

      /* Preview / Canvas Area */
      .preview-container {
        position: absolute;
        inset: 0;
        z-index: 0;
        overflow: hidden;
        cursor: grab;
        background-color: #f8fafc;
        background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
        background-size: 24px 24px;
        /* Hardware acceleration can cause blurriness on scale if not careful.
           We removed will-change: transform to prefer crisp rasterization on each frame/zoom stop. */
      }

      .preview-container:active,
      .preview-container.grabbing {
        cursor: grabbing;
      }

      .canvas-wrapper {
        width: 100%;
        height: 100%;
        transform-origin: 0 0;
        /* Removed will-change: transform to fix blurriness on zoom */
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }

      #canvas {
        pointer-events: auto;
      }

      #canvas svg {
        overflow: visible;
        /* Ensure specific dimensions from mermaid are respected but allow override */
        max-width: none !important;
        height: auto;
      }

      /* Mermaid edge/arrow thickness */
      #canvas svg .flowchart-link,
      #canvas svg .edgePath path,
      #canvas svg .edgePath path.path {
        stroke-width: 1px !important;
      }

      #canvas svg marker path {
        stroke-width: 1px !important;
      }

      /* Floating Editor Panel (Sidebar) */
      .editor-panel {
        position: absolute;
        top: 24px;
        left: 24px;
        bottom: 24px;
        width: 360px;
        max-width: 90vw;
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        box-shadow: var(--shadow-lg);
        display: flex;
        flex-direction: column;
        z-index: 10;
        transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s;
      }

      .editor-panel.collapsed {
        transform: translateX(calc(-100% - 40px));
        opacity: 0;
        pointer-events: none;
      }

      .expand-trigger {
        position: absolute;
        top: 24px;
        left: 24px;
        z-index: 15;
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        box-shadow: var(--shadow-md);
        border-radius: 8px;
        height: 40px;
        padding: 0 14px;
        font-family: var(--font-sans);
        font-size: 13px;
        font-weight: 600;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        opacity: 0;
        transform: translateX(-20px) scale(0.95);
        pointer-events: none;
      }

      .expand-trigger:hover {
        background: #fff;
        transform: translateX(0) scale(1.02);
      }

      .expand-trigger.visible {
        opacity: 1;
        transform: translateX(0) scale(1);
        pointer-events: auto;
      }

      .panel-header {
        padding: 14px 18px;
        border-bottom: 1px solid var(--panel-border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: rgba(248, 250, 252, 0.5);
        border-radius: 12px 12px 0 0;
      }

      .brand {
        display: flex;
        flex-direction: column;
      }

      .brand h1 {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
        letter-spacing: -0.01em;
      }

      .brand span {
        font-size: 11px;
        color: var(--text-secondary);
        margin-top: 2px;
      }

      .header-actions {
        display: flex;
        gap: 4px;
      }

      .icon-btn {
        background: transparent;
        border: 1px solid transparent;
        cursor: pointer;
        padding: 6px;
        border-radius: 6px;
        color: var(--text-secondary);
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
      }

      .icon-btn:hover {
        background: rgba(0, 0, 0, 0.05);
        color: var(--text-primary);
      }

      .icon-btn svg {
        width: 16px;
        height: 16px;
      }

      .editor-content {
        flex: 1;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      textarea {
        flex: 1;
        width: 100%;
        border: none;
        background: transparent;
        padding: 16px;
        font-family: var(--font-mono);
        font-size: 12px;
        line-height: 1.5;
        color: var(--text-primary);
        resize: none;
        outline: none;
        white-space: pre;
      }

      textarea::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      textarea::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.1);
        border-radius: 4px;
      }
      textarea::-webkit-scrollbar-track {
        background: transparent;
      }

      .error-overlay {
        border-top: 1px solid #fee2e2;
        background: #fef2f2;
        color: #b91c1c;
        padding: 12px 16px;
        font-size: 12px;
        font-family: var(--font-mono);
        line-height: 1.4;
        max-height: 120px;
        overflow-y: auto;
        display: none;
      }

      .error-overlay.visible {
        display: block;
      }

      /* Floating Toolbar */
      .toolbar {
        position: absolute;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        padding: 4px;
        border-radius: 99px;
        display: flex;
        align-items: center;
        gap: 2px;
        box-shadow: var(--shadow-lg);
        z-index: 20;
      }

      .tool-btn {
        background: transparent;
        border: none;
        border-radius: 99px;
        height: 32px;
        min-width: 32px;
        padding: 0 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        font-size: 13px;
        font-weight: 500;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s;
        font-family: var(--font-sans);
        white-space: nowrap;
      }

      .tool-btn:hover {
        background: rgba(0, 0, 0, 0.04);
        color: var(--text-primary);
      }

      .tool-btn:active {
        background: rgba(0, 0, 0, 0.08);
      }

      .divider {
        width: 1px;
        height: 16px;
        background: var(--panel-border);
        margin: 0 4px;
      }

      #zoom-label {
        font-feature-settings: "tnum";
        min-width: 4ch;
        text-align: center;
        font-size: 12px;
      }

      @media (max-width: 768px) {
        .editor-panel {
          top: auto;
          bottom: 0;
          left: 0;
          right: 0;
          width: 100%;
          height: 40vh;
          max-width: none;
          border-radius: 16px 16px 0 0;
          border-left: none;
          border-right: none;
          border-bottom: none;
        }

        .editor-panel.collapsed {
          transform: translateY(110%);
        }

        .expand-trigger {
          top: auto;
          bottom: 90px;
          left: 50%;
          transform: translateX(-50%) translateY(20px) scale(0.95);
        }

        .expand-trigger:hover {
          transform: translateX(-50%) translateY(0) scale(1.02);
        }

        .expand-trigger.visible {
          transform: translateX(-50%) translateY(0) scale(1);
        }

        .toolbar {
          bottom: calc(40vh + 16px);
          scale: 0.95;
          transition: bottom 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .editor-panel.collapsed ~ .toolbar {
          bottom: 32px;
        }

        .tool-btn span {
          display: none;
        }
        #zoom-label {
          display: block;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <button id="btn-expand" class="expand-trigger visible" title="Show Editor">
        <svg
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path
            d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"
          ></path>
          <polyline points="17 21 17 13 7 13 7 21"></polyline>
          <polyline points="7 3 7 8 15 8"></polyline>
        </svg>
        <span>Editor</span>
      </button>

      <!-- Canvas Area -->
      <div class="preview-container" id="preview-container">
        <div class="canvas-wrapper" id="canvas-wrapper">
          <div id="canvas"></div>
        </div>
      </div>

      <!-- Editor Panel -->
      <div class="editor-panel collapsed">
        <div class="panel-header">
          <div class="brand">
            <h1>Mermaid Viewer</h1>
            <span>Live Editor</span>
          </div>
          <div class="header-actions">
            <button id="btn-collapse" class="icon-btn" title="Hide Editor">
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="9" y1="3" x2="9" y2="21"></line>
                <polyline points="16 15 13 12 16 9"></polyline>
              </svg>
            </button>
            <div class="divider" style="height: 12px; margin: 0 4px"></div>
            <a
              href="__KLAUDE_VIEW_LINK__"
              target="_blank"
              class="icon-btn"
              title="Open in Cloud Viewer"
            >
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"
                ></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
              </svg>
            </a>
            <button id="btn-copy-code" class="icon-btn" title="Copy Code">
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path
                  d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"
                ></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="editor-content">
          <textarea
            id="source-code"
            spellcheck="false"
            placeholder="Enter mermaid diagram codeâ€¦"
          >
__KLAUDE_CODE__</textarea
          >
          <div id="error-overlay" class="error-overlay"></div>
        </div>
      </div>

      <!-- Controls -->
      <div class="toolbar">
        <button class="tool-btn" id="btn-zoom-out" title="Zoom Out">
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <line x1="5" y1="12" x2="19" y2="12"></line>
          </svg>
        </button>
        <button class="tool-btn" id="btn-reset" title="Fit to View">
          <span id="zoom-label">100%</span>
        </button>
        <button class="tool-btn" id="btn-zoom-in" title="Zoom In">
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
          </svg>
        </button>
        <div class="divider"></div>
        <button class="tool-btn" id="btn-download" title="Download SVG">
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          <span>SVG</span>
        </button>
      </div>
    </div>

    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

      // --- State ---
      const state = {
        scale: 1,
        x: 0,
        y: 0,
        isDragging: false,
        startX: 0,
        startY: 0,
        initialX: 0,
        initialY: 0,
      };

      // --- Elements ---
      const els = {
        preview: document.getElementById("preview-container"),
        wrapper: document.getElementById("canvas-wrapper"),
        canvas: document.getElementById("canvas"),
        textarea: document.getElementById("source-code"),
        error: document.getElementById("error-overlay"),
        zoomLabel: document.getElementById("zoom-label"),
        btns: {
          zoomIn: document.getElementById("btn-zoom-in"),
          zoomOut: document.getElementById("btn-zoom-out"),
          reset: document.getElementById("btn-reset"),
          download: document.getElementById("btn-download"),
          copy: document.getElementById("btn-copy-code"),
          collapse: document.getElementById("btn-collapse"),
          expand: document.getElementById("btn-expand"),
        },
      };

      // --- Config ---
      const sansFont = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--font-sans");

      mermaid.initialize({
        startOnLoad: false,
        theme: "neutral",
        themeVariables: {
          fontFamily: sansFont,
          fontSize: "14px",
          lineColor: "#5c6c7f", // Match slate-500 roughly for better contrast
        },
        flowchart: {
          useMaxWidth: false,
          htmlLabels: true,
          curve: "basis",
          nodeSpacing: 30, // Tighter horizontal
          rankSpacing: 40,
          ranker: "tight-tree", // Tighter vertical layout algorithm
          diagramPadding: 10,
          wrappingWidth: 250, // Allow slightly wider text to reduce height
        },
        sequence: { useMaxWidth: false },
        gantt: { useMaxWidth: false },
        journey: { useMaxWidth: false },
        class: { useMaxWidth: false },
        state: { useMaxWidth: false },
        er: { useMaxWidth: false },
        pie: { useMaxWidth: false },
        securityLevel: "loose",
      });

      // --- Render ---
      let renderedOnce = false;

      const render = async () => {
        const code = els.textarea.value.trim();
        if (!code) {
          els.canvas.innerHTML = "";
          return;
        }

        try {
          const id = "mermaid-" + Date.now();
          // Generate SVG
          const { svg } = await mermaid.render(id, code);
          els.canvas.innerHTML = svg;

          els.error.textContent = "";
          els.error.classList.remove("visible");

          if (!renderedOnce) {
            renderedOnce = true;
            // Short delay to ensure layout is done
            setTimeout(fitToViewInitial, 50);
          }
        } catch (e) {
          console.error(e);
          const msg = e.message || String(e);
          // Show simplified error
          const cleanMsg = msg.split("\n")[0];
          els.error.textContent = cleanMsg;
          els.error.classList.add("visible");
        }
      };

      const debounce = (fn, ms) => {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn(...args), ms);
        };
      };

      els.textarea.addEventListener("input", debounce(render, 400));
      els.textarea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          render();
        }
      });

      // --- Zoom / Pan ---
      const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

      const updateTransform = () => {
        els.wrapper.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
        els.zoomLabel.textContent = `${Math.round(state.scale * 100)}%`;
      };

      // Attempt to fit content to view, but don't shrink too much initially
      const fitToViewInitial = () => {
        fitToView(true);
      };

      const fitToView = (isInitial = false) => {
        const svg = els.canvas.querySelector("svg");
        if (!svg) return;

        try {
          const bbox = svg.getBBox();
          if (bbox.width < 1 || bbox.height < 1) return;

          const padding = 60;
          const containerW = els.preview.clientWidth;
          const containerH = els.preview.clientHeight;

          // Calculate scale to fit
          const scaleW = (containerW - padding * 2) / bbox.width;
          const scaleH = (containerH - padding * 2) / bbox.height;
          const fitScale = Math.min(scaleW, scaleH);

          // Logic:
          // If user clicks "Fit" (isInitial=false), force fit (clamp 0.1 - 2)
          // If initial load (isInitial=true):
          //   - If diagram is small, fit it (up to 1.5x)
          //   - If diagram is huge (fitScale very small), don't shrink below 0.75x so text stays readable.

          let finalScale = fitScale;

          if (isInitial) {
            // Prevent starting too small, unless the graph is absolutely massive in a way that navigation is impossible?
            // Usually 0.8 is a good compromise for "Overview" vs "Readability"
            finalScale = Math.max(fitScale, 0.85);
          }

          state.scale = clamp(finalScale, 0.1, 3);

          // Center
          // We moved the svg to center using flexbox in wrapper
          // But we translate the wrapper.
          // If wrapper is centered, x=0 y=0 is center.
          state.x = 0;
          state.y = 0;

          updateTransform();
        } catch (e) {
          console.error("Fit failed", e);
        }
      };

      const zoomAt = (factor, cx, cy) => {
        const oldScale = state.scale;
        const newScale = clamp(oldScale * factor, 0.1, 5);

        // Adjust position to keep client point relatively stable
        // Formula: NewPos = MousePos - (MousePos - OldPos) * (NewScale/OldScale)
        // Note: state.x/y are translations from center? No, they are translate() values.
        // And origin is 0,0 (top left of wrapper). Wrapper is size of screen.
        // cx, cy are client coordinates.
        // We need wrapper-relative coords.

        const rect = els.wrapper.getBoundingClientRect();
        // wrapper's top-left in client space:
        const wx = rect.left;
        const wy = rect.top;

        // The point on the scaled content under the mouse:
        // (cx - wx) is distance from current top-left of transformed element
        // But (cx - wx) includes the current scale.

        // This math is tricky. Simplified approach:
        // x -= (cx - wrapperLeft) * (factor - 1) ... ?
        // Let's use the delta approach which is robust.

        // Relative mouse pos from wrapper center (since we pan the wrapper):
        // Actually, let's treat it simply:

        // P_world = (P_screen - Translate) / Scale
        // We want P_world to stay at P_screen after scale change.
        // P_screen = P_world * NewScale + NewTranslate
        // NewTranslate = P_screen - P_world * NewScale
        //              = P_screen - ((P_screen - Translate)/Scale) * NewScale

        // Wait, element is w=100% h=100%, top=0 left=0.
        // Translate is applied to it.
        // Origin is top-left (default).
        // So:

        state.x = cx - ((cx - state.x) / oldScale) * newScale;
        state.y = cy - ((cy - state.y) / oldScale) * newScale;
        state.scale = newScale;

        updateTransform();
      };

      // --- event listeners ---

      els.preview.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          // User requested mouse wheel to zoom (Maps style)
          // Drag is used for panning
          const factor = Math.exp(-e.deltaY * 0.002);
          zoomAt(factor, e.clientX, e.clientY);
        },
        { passive: false }
      );

      // Pointer events for panning
      els.preview.addEventListener("pointerdown", (e) => {
        if (e.pointerType === "touch" || e.button !== 0) return;
        state.isDragging = true;
        state.startX = e.clientX;
        state.startY = e.clientY;
        state.initialX = state.x;
        state.initialY = state.y;
        els.preview.classList.add("grabbing");
        els.preview.setPointerCapture(e.pointerId);
      });

      els.preview.addEventListener("pointermove", (e) => {
        if (!state.isDragging) return;
        const dx = e.clientX - state.startX;
        const dy = e.clientY - state.startY;
        state.x = state.initialX + dx;
        state.y = state.initialY + dy;
        updateTransform();
      });

      els.preview.addEventListener("pointerup", () => {
        state.isDragging = false;
        els.preview.classList.remove("grabbing");
      });

      // Touch handling
      let lastPinchDist = -1;

      els.preview.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastPinchDist = Math.hypot(dx, dy);
          } else if (e.touches.length === 1) {
            state.isDragging = true;
            state.startX = e.touches[0].clientX;
            state.startY = e.touches[0].clientY;
            state.initialX = state.x;
            state.initialY = state.y;
          }
        },
        { passive: false }
      );

      els.preview.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          if (e.touches.length === 2 && lastPinchDist > 0) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;

            const factor = dist / lastPinchDist; // relative change
            // We need to apply this factor to the current scale
            // But zoomAt takes a multiplier for state.scale.
            // So factor is correct.

            const oldScale = state.scale;
            const newScale = clamp(oldScale * factor, 0.1, 5);

            // Same math as zoomAt
            state.x = cx - ((cx - state.x) / oldScale) * newScale;
            state.y = cy - ((cy - state.y) / oldScale) * newScale;
            state.scale = newScale;

            updateTransform();
            lastPinchDist = dist;
          } else if (e.touches.length === 1 && state.isDragging) {
            const dx = e.touches[0].clientX - state.startX;
            const dy = e.touches[0].clientY - state.startY;
            state.x = state.initialX + dx;
            state.y = state.initialY + dy;
            updateTransform();
          }
        },
        { passive: false }
      );

      els.preview.addEventListener("touchend", (e) => {
        if (e.touches.length < 2) lastPinchDist = -1;
        if (e.touches.length === 0) state.isDragging = false;
      });

      // Buttons
      els.btns.zoomIn.onclick = () =>
        zoomAt(1.2, els.preview.clientWidth / 2, els.preview.clientHeight / 2);
      els.btns.zoomOut.onclick = () =>
        zoomAt(
          1 / 1.2,
          els.preview.clientWidth / 2,
          els.preview.clientHeight / 2
        );
      els.btns.reset.onclick = () => fitToView(false); // Force fit

      els.btns.download.onclick = () => {
        const svg = els.canvas.querySelector("svg");
        if (!svg) return;
        // Add white background for download
        const clone = svg.cloneNode(true);
        clone.style.backgroundColor = "white";
        const blob = new Blob([clone.outerHTML], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "diagram.svg";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };

      els.btns.copy.onclick = async () => {
        try {
          await navigator.clipboard.writeText(els.textarea.value);
          els.btns.copy.style.color = "var(--accent)";
          setTimeout(() => (els.btns.copy.style.color = ""), 1000);
        } catch {}
      };

      const toggleEditor = (show) => {
        const panel = document.querySelector(".editor-panel");
        const trigger = document.getElementById("btn-expand");

        if (!show) {
          panel.classList.add("collapsed");
          trigger.classList.add("visible");
        } else {
          panel.classList.remove("collapsed");
          trigger.classList.remove("visible");
        }
      };

      if (els.btns.collapse)
        els.btns.collapse.onclick = () => toggleEditor(false);
      if (els.btns.expand) els.btns.expand.onclick = () => toggleEditor(true);

      // Start
      requestAnimationFrame(render);
    </script>
  </body>
</html>
