"""Tests for OANDA provider implementation."""

import os

# Mock oandapyV20 before importing provider
import sys
from datetime import UTC, datetime
from unittest.mock import MagicMock, Mock, patch

import polars as pl
import pytest

# Create mock oandapyV20 module
mock_oanda = MagicMock()
mock_oanda.exceptions.V20Error = type("V20Error", (Exception,), {})
sys.modules["oandapyV20"] = mock_oanda
sys.modules["oandapyV20.endpoints"] = mock_oanda.endpoints
sys.modules["oandapyV20.endpoints.instruments"] = mock_oanda.endpoints.instruments
sys.modules["oandapyV20.exceptions"] = mock_oanda.exceptions

from ml4t.data.core.exceptions import (
    AuthenticationError,
    DataNotAvailableError,
    RateLimitError,
)
from ml4t.data.providers.oanda import OandaProvider


class TestOandaProvider:
    """Test suite for OANDA provider."""

    @pytest.fixture
    def mock_client(self):
        """Create mock OANDA client."""
        client = Mock()
        return client

    @pytest.fixture
    def provider(self, mock_client):
        """Create provider with mocked client."""
        with patch("ml4t.data.providers.oanda.oandapyV20.API") as mock_api:
            mock_api.return_value = mock_client
            provider = OandaProvider(api_key="test_key")
            provider.client = mock_client
            return provider

    def test_initialization_with_api_key(self):
        """Test provider initialization with API key."""
        with patch("ml4t.data.providers.oanda.oandapyV20.API") as mock_api:
            provider = OandaProvider(api_key="test_key")
            assert provider.api_key == "test_key"
            assert provider.practice is True
            assert provider.base_url == "https://api-fxpractice.oanda.com"
            mock_api.assert_called_once()

    def test_initialization_from_environment(self, monkeypatch):
        """Test provider initialization from environment variable."""
        monkeypatch.setenv("OANDA_API_KEY", "env_key")
        with patch("ml4t.data.providers.oanda.oandapyV20.API") as mock_api:
            provider = OandaProvider()
            assert provider.api_key == "env_key"
            mock_api.assert_called_once()

    def test_initialization_without_api_key(self):
        """Test that initialization fails without API key."""
        with patch.dict(os.environ, {}, clear=True):
            with pytest.raises(AuthenticationError, match="OANDA API key required"):
                OandaProvider()

    def test_live_account_initialization(self):
        """Test initialization with live account type."""
        with patch("ml4t.data.providers.oanda.oandapyV20.API") as mock_api:
            provider = OandaProvider(api_key="test_key", practice=False)
            assert provider.practice is False
            assert provider.base_url == "https://api-fxtrade.oanda.com"
            # Check that live environment was set
            call_kwargs = mock_api.call_args.kwargs
            assert call_kwargs["environment"] == "live"

    def test_name(self, provider):
        """Test provider name."""
        assert provider.name == "oanda"

    def test_validate_pair(self, provider):
        """Test currency pair validation."""
        # Test 6-character format
        assert provider._validate_pair("EURUSD") == "EUR_USD"
        assert provider._validate_pair("GBPJPY") == "GBP_JPY"

        # Test underscore format
        assert provider._validate_pair("EUR_USD") == "EUR_USD"
        assert provider._validate_pair("gbp_usd") == "GBP_USD"

        # Test invalid format
        with pytest.raises(ValueError, match="Invalid currency pair format"):
            provider._validate_pair("EUR")

        with pytest.raises(ValueError, match="Invalid currency pair format"):
            provider._validate_pair("EURUSDGBP")

    def test_fetch_raw_data_success(self, provider, mock_client):
        """Test successful raw data fetch."""
        # Mock response
        mock_response = {
            "candles": [
                {
                    "complete": True,
                    "time": "2024-01-01T00:00:00.000000000Z",
                    "mid": {"o": "1.0950", "h": "1.0960", "l": "1.0940", "c": "1.0955"},
                    "volume": 1000,
                },
                {
                    "complete": True,
                    "time": "2024-01-01T01:00:00.000000000Z",
                    "mid": {"o": "1.0955", "h": "1.0965", "l": "1.0950", "c": "1.0960"},
                    "volume": 1100,
                },
            ]
        }

        # Mock the request/response cycle
        mock_request = Mock()
        mock_request.response = mock_response
        mock_oanda.endpoints.instruments.InstrumentsCandles.return_value = mock_request
        mock_client.request = Mock()  # Just needs to exist

        result = provider._fetch_raw_data("EUR_USD", "2024-01-01", "2024-01-01", "hourly")

        # We should get 4 candles (2 candles x 2 calls)
        assert len(result) == 4
        assert result[0]["time"] == "2024-01-01T00:00:00.000000000Z"

    def test_fetch_raw_data_with_spread(self, provider, mock_client):
        """Test fetching data with bid/ask spread."""
        provider.include_spread = True

        mock_response = {
            "candles": [
                {
                    "complete": True,
                    "time": "2024-01-01T00:00:00.000000000Z",
                    "mid": {"o": "1.0950", "h": "1.0960", "l": "1.0940", "c": "1.0955"},
                    "bid": {"o": "1.0949", "h": "1.0959", "l": "1.0939", "c": "1.0954"},
                    "ask": {"o": "1.0951", "h": "1.0961", "l": "1.0941", "c": "1.0956"},
                    "volume": 1000,
                }
            ]
        }

        mock_request = Mock()
        mock_request.response = mock_response
        mock_oanda.endpoints.instruments.InstrumentsCandles.return_value = mock_request
        mock_client.request = Mock()

        result = provider._fetch_raw_data("EUR_USD", "2024-01-01", "2024-01-01", "H1")

        # We get duplicates due to mock behavior, just check the structure
        assert len(result) >= 1
        assert "bid" in result[0]
        assert "ask" in result[0]

    def test_transform_data_basic(self, provider):
        """Test transforming basic OHLCV data."""
        raw_data = [
            {
                "complete": True,
                "time": "2024-01-01T00:00:00.000000000Z",
                "mid": {"o": "1.0950", "h": "1.0960", "l": "1.0940", "c": "1.0955"},
                "volume": 1000,
            }
        ]

        df = provider._transform_data(raw_data, "EUR_USD")

        assert not df.is_empty()
        assert "timestamp" in df.columns
        assert "open" in df.columns
        assert "high" in df.columns
        assert "low" in df.columns
        assert "close" in df.columns
        assert "volume" in df.columns
        assert "symbol" in df.columns

        assert df["symbol"][0] == "EUR_USD"
        assert df["open"][0] == 1.0950
        assert df["volume"][0] == 1000

    def test_transform_data_with_spread(self, provider):
        """Test transforming data with spread information."""
        provider.include_spread = True

        raw_data = [
            {
                "complete": True,
                "time": "2024-01-01T00:00:00.000000000Z",
                "mid": {"o": "1.0950", "h": "1.0960", "l": "1.0940", "c": "1.0955"},
                "bid": {"o": "1.0949", "h": "1.0959", "l": "1.0939", "c": "1.0954"},
                "ask": {"o": "1.0951", "h": "1.0961", "l": "1.0941", "c": "1.0956"},
                "volume": 1000,
            }
        ]

        df = provider._transform_data(raw_data, "EUR_USD")

        assert "bid_open" in df.columns
        assert "bid_close" in df.columns
        assert "ask_open" in df.columns
        assert "ask_close" in df.columns
        assert "spread" in df.columns

        assert df["spread"][0] == pytest.approx(0.0002, rel=1e-5)

    def test_map_frequency_to_granularity(self, provider):
        """Test frequency to granularity mapping."""
        # Direct mappings
        assert provider._map_frequency_to_granularity("M1") == "M1"
        assert provider._map_frequency_to_granularity("H1") == "H1"
        assert provider._map_frequency_to_granularity("D") == "D"

        # Aliases
        assert provider._map_frequency_to_granularity("daily") == "D"
        assert provider._map_frequency_to_granularity("hourly") == "H1"
        assert provider._map_frequency_to_granularity("minute") == "M1"
        assert provider._map_frequency_to_granularity("5min") == "M5"
        assert provider._map_frequency_to_granularity("4hour") == "H4"
        assert provider._map_frequency_to_granularity("weekly") == "W"
        assert provider._map_frequency_to_granularity("monthly") == "M"

        # Default fallback
        assert provider._map_frequency_to_granularity("unknown") == "H1"

    def test_fetch_fx_pairs(self, provider, mock_client):
        """Test fetching multiple FX pairs."""
        mock_response = {
            "candles": [
                {
                    "complete": True,
                    "time": "2024-01-01T00:00:00.000000000Z",
                    "mid": {"o": "1.0950", "h": "1.0960", "l": "1.0940", "c": "1.0955"},
                    "volume": 1000,
                }
            ]
        }

        mock_request = Mock()
        mock_request.response = mock_response
        mock_oanda.endpoints.instruments.InstrumentsCandles.return_value = mock_request
        mock_client.request = Mock()

        pairs = ["EUR_USD", "GBP_USD"]
        results = provider.fetch_fx_pairs(pairs, "2024-01-01", "2024-01-01", "H1")

        assert "EUR_USD" in results
        assert "GBP_USD" in results
        assert results["EUR_USD"] is not None

    def test_validate_data(self, provider):
        """Test data validation."""
        # Valid data
        df = pl.DataFrame(
            {
                "timestamp": [datetime(2024, 1, 1, tzinfo=UTC)],
                "open": [1.0950],
                "high": [1.0960],
                "low": [1.0940],
                "close": [1.0955],
                "volume": [1000],
                "symbol": ["EUR_USD"],
            }
        )

        result = provider.validate_data(df)
        assert result["valid"] is True
        assert result["total_records"] == 1
        assert len(result["issues"]) == 0

        # Invalid OHLC relationships
        df_invalid = pl.DataFrame(
            {
                "timestamp": [datetime(2024, 1, 1, tzinfo=UTC)],
                "open": [1.0950],
                "high": [1.0940],  # High < Low
                "low": [1.0960],  # Low > High
                "close": [1.0955],
                "volume": [1000],
                "symbol": ["EUR_USD"],
            }
        )

        result = provider.validate_data(df_invalid)
        assert result["valid"] is False
        assert "Invalid OHLC relationships" in str(result["issues"])

    def test_error_handling_authentication(self, provider, mock_client):
        """Test authentication error handling."""
        from oandapyV20.exceptions import V20Error

        mock_request = Mock()
        mock_oanda.endpoints.instruments.InstrumentsCandles.return_value = mock_request
        mock_client.request.side_effect = V20Error("401 Unauthorized")

        with pytest.raises(AuthenticationError, match="authentication failed"):
            provider._fetch_raw_data("EUR_USD", "2024-01-01", "2024-01-31", "H1")

    def test_error_handling_rate_limit(self, provider, mock_client):
        """Test rate limit error handling."""
        from oandapyV20.exceptions import V20Error

        mock_request = Mock()
        mock_oanda.endpoints.instruments.InstrumentsCandles.return_value = mock_request
        mock_client.request.side_effect = V20Error("429 Too Many Requests")

        with pytest.raises(RateLimitError, match="rate limit exceeded"):
            provider._fetch_raw_data("EUR_USD", "2024-01-01", "2024-01-31", "H1")

    def test_error_handling_invalid_instrument(self, provider, mock_client):
        """Test invalid instrument error handling."""
        from oandapyV20.exceptions import V20Error

        mock_request = Mock()
        mock_oanda.endpoints.instruments.InstrumentsCandles.return_value = mock_request
        mock_client.request.side_effect = V20Error("404 Not Found")

        with pytest.raises(DataNotAvailableError, match="Invalid instrument"):
            provider._fetch_raw_data("INVALID_PAIR", "2024-01-01", "2024-01-31", "H1")

    def test_integration_with_base_provider(self, provider, mock_client):
        """Test integration with base provider's template method."""
        mock_response = {
            "candles": [
                {
                    "complete": True,
                    "time": "2024-01-01T00:00:00.000000000Z",
                    "mid": {"o": "1.0950", "h": "1.0960", "l": "1.0940", "c": "1.0955"},
                    "volume": 1000,
                }
            ]
        }

        mock_request = Mock()
        mock_request.response = mock_response
        mock_oanda.endpoints.instruments.InstrumentsCandles.return_value = mock_request
        mock_client.request = Mock()

        # Call the main fetch_ohlcv method (from base class)
        df = provider.fetch_ohlcv("EUR_USD", "2024-01-01", "2024-01-01", "H1")

        # Verify the full pipeline worked
        assert not df.is_empty()
        assert "timestamp" in df.columns
        assert "open" in df.columns
        assert df["open"][0] == 1.0950


@pytest.mark.integration
class TestOandaProviderIntegration:
    """Integration tests for OANDA provider (requires API key)."""

    @pytest.mark.skipif(not os.getenv("OANDA_API_KEY"), reason="OANDA_API_KEY not set")
    def test_real_api_fetch(self):
        """Test with real OANDA API (if key available)."""
        from datetime import datetime, timedelta

        provider = OandaProvider()

        # Use recent date (7 days ago) to ensure data availability
        # Avoid weekends by using Monday-Friday
        end_date = datetime.now() - timedelta(days=7)
        start_date = end_date - timedelta(days=1)

        # Fetch a small amount of data to minimize API usage
        df = provider.fetch_ohlcv(
            "EUR_USD",
            start_date.strftime("%Y-%m-%d"),
            end_date.strftime("%Y-%m-%d"),
            "H1",
        )

        assert not df.is_empty()
        assert "timestamp" in df.columns
        assert "open" in df.columns
        assert "close" in df.columns

        # Verify data quality
        assert (df["high"] >= df["low"]).all()
        assert (df["high"] >= df["open"]).all()
        assert (df["high"] >= df["close"]).all()

    @pytest.mark.skipif(not os.getenv("OANDA_API_KEY"), reason="OANDA_API_KEY not set")
    def test_spread_data_real(self):
        """Test fetching data with spread from real API."""
        provider = OandaProvider(include_spread=True)

        df = provider.fetch_ohlcv("EUR_USD", "2024-01-02", "2024-01-02", "H1")

        assert not df.is_empty()
        if "spread" in df.columns:
            assert (df["spread"] >= 0).all()
