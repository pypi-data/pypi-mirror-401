import base64
import json
import time
from datetime import datetime

import streamlit as st
from websocket import WebSocketConnectionClosedException

from besser.agent.core.file import File
from besser.agent.core.message import Message, MessageType
from besser.agent.platforms.payload import Payload, PayloadAction, PayloadEncoder
from besser.agent.platforms.websocket.streamlit_ui.initialization import (
    ensure_websocket_connection,
    reconnect_websocket,
)
from besser.agent.platforms.websocket.streamlit_ui.vars import (
    TYPING_TIME,
    HISTORY,
    QUEUE,
    ASSISTANT,
    USER,
    WEBSOCKET_READY,
)

user_type = {
    0: ASSISTANT,
    1: USER
}


def stream_text(text: str):
    def stream_callback():
        for word in text.split(" "):
            yield word + " "
            time.sleep(TYPING_TIME)
    return stream_callback


def write_or_stream(content, stream: bool):
    if stream:
        st.write_stream(stream_text(content))
    else:
        st.write(content)


def write_message(message: Message, key_count: int, stream: bool = False):
    key = f'message_{key_count}'
    with st.chat_message(user_type[message.is_user]):
        if message.type == MessageType.AUDIO:
            # only do for the TTS component, as it returns a dictionary through Payload message
            if isinstance(message.content, dict):
                audio = message.content['audio']
                sample_rate = message.content['sampling_rate']
                st.audio(audio, format="audio/mpeg", sample_rate=sample_rate, loop=False, autoplay=True)
            else:
                st.audio(message.content, format="audio/wav")

        elif message.type == MessageType.FILE:
            file: File = File.from_dict(message.content)
            file_name = file.name
            file_type = file.type
            file_data = base64.b64decode(file.base64.encode('utf-8'))
            st.download_button(label='Download ' + file_name, file_name=file_name, data=file_data, mime=file_type, key=key)

        elif message.type == MessageType.IMAGE:
            st.image(message.content)

        elif message.type == MessageType.OPTIONS:
            def send_option():
                option = st.session_state[key]
                message = Message(t=MessageType.STR, content=option, is_user=True, timestamp=datetime.now())
                st.session_state.history.append(message)
                payload = Payload(
                    action=PayloadAction.USER_MESSAGE,
                    message=option,
                )
                ws = ensure_websocket_connection()
                if not ws:
                    st.warning("WebSocket connection unavailable. Please retry.")
                    return
                try:
                    ws.send(json.dumps(payload, cls=PayloadEncoder))
                except WebSocketConnectionClosedException:
                    reconnect_websocket()
                    st.warning("Connection dropped. Your option was not sent; please try again.")
                except Exception as exc:
                    st.warning(f"Unable to send option: {exc}")

            st.pills(
                label='Choose an option',
                options=message.content,
                selection_mode='single',
                on_change=send_option,
                key=key,
            )

        elif message.type == MessageType.LOCATION:
            st.map(message.content)

        elif message.type == MessageType.HTML:
            st.html(message.content)

        elif message.type == MessageType.DATAFRAME:
            st.dataframe(message.content, key=key)

        elif message.type == MessageType.PLOTLY:
            st.plotly_chart(message.content, key=key)

        elif message.type == MessageType.RAG_ANSWER:
            # TODO: Add stream text
            write_or_stream(f'ðŸ”® {message.content["answer"]}', stream)
            with st.expander('Details'):
                write_or_stream(f'This answer has been generated by an LLM: **{message.content["llm_name"]}**', stream)
                write_or_stream(f'It received the following documents as input to come up with a relevant answer:', stream)
                if 'docs' in message.content:
                    for i, doc in enumerate(message.content['docs']):
                        st.write(f'**Document {i + 1}/{len(message.content["docs"])}**')
                        st.write(f'- **Source:** {doc["metadata"]["source"]}')
                        st.write(f'- **Page:** {doc["metadata"]["page"]}')
                        st.write(f'- **Content:** {doc["content"]}')

        elif message.type in [MessageType.STR, MessageType.MARKDOWN]:
            write_or_stream(message.content, stream=(stream and isinstance(message.content, str)))


def load_chat():
    username = st.session_state.get("username")
    fetched_history = st.session_state.get("fetched_user_messages", False)
    websocket_ready = st.session_state.get(WEBSOCKET_READY, False)

    if username and not fetched_history:
        if not websocket_ready:
            st.info("Connecting to the chat serverâ€¦ your previous messages will appear shortly.")
        else:
            ws = ensure_websocket_connection()
            if not ws:
                st.warning("WebSocket connection unavailable. Retryingâ€¦")
            else:
                payload = Payload(
                    action=PayloadAction.FETCH_USER_MESSAGES,
                    message=None,
                )
                try:
                    ws.send(json.dumps(payload, cls=PayloadEncoder))
                    st.session_state["fetched_user_messages"] = True
                except WebSocketConnectionClosedException:
                    reconnect_websocket()
                    st.session_state["fetched_user_messages"] = False
                    st.warning("Connection dropped while loading history. Reconnectingâ€¦")
                except Exception as exc:
                    st.warning(f"Unable to fetch previous messages: {exc}")
                    st.session_state["fetched_user_messages"] = False

    key_count = 0
    for message in st.session_state[HISTORY]:
        write_message(message, key_count, stream=False)
        key_count += 1

    while not st.session_state[QUEUE].empty():
        message = st.session_state[QUEUE].get()
        st.session_state[HISTORY].append(message)
        write_message(message, key_count, stream=True)
        key_count += 1
