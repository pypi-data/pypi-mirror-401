"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2010-2025 Google LLC
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ortools.util.int128_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class SetCoverProto(google.protobuf.message.Message):
    """TODO(user): use uint64 instead of int32 for indices, as the solver
    supports it.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Subset(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        COST_FIELD_NUMBER: builtins.int
        ELEMENT_FIELD_NUMBER: builtins.int
        cost: builtins.float
        """The cost for using the given subset."""
        @property
        def element(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """The list of elements in the subset."""

        def __init__(
            self,
            *,
            cost: builtins.float | None = ...,
            element: collections.abc.Iterable[builtins.int] | None = ...,
        ) -> None: ...
        _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_cost", b"_cost", "cost", b"cost"]
        def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
        _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_cost", b"_cost", "cost", b"cost", "element", b"element"]
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__cost: typing_extensions.TypeAlias = typing.Literal["cost"]
        _WhichOneofArgType__cost: typing_extensions.TypeAlias = typing.Literal["_cost", b"_cost"]
        def WhichOneof(self, oneof_group: _WhichOneofArgType__cost) -> _WhichOneofReturnType__cost | None: ...

    SUBSET_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    FINGERPRINT_FIELD_NUMBER: builtins.int
    name: builtins.str
    """A user-defined name for the model."""
    @property
    def subset(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___SetCoverProto.Subset]:
        """The list of subsets in the model."""

    @property
    def fingerprint(self) -> ortools.util.int128_pb2.Int128:
        """An automatically fingerprint for the model. TODO(user): Implement."""

    def __init__(
        self,
        *,
        subset: collections.abc.Iterable[Global___SetCoverProto.Subset] | None = ...,
        name: builtins.str | None = ...,
        fingerprint: ortools.util.int128_pb2.Int128 | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_fingerprint", b"_fingerprint", "_name", b"_name", "fingerprint", b"fingerprint", "name", b"name"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_fingerprint", b"_fingerprint", "_name", b"_name", "fingerprint", b"fingerprint", "name", b"name", "subset", b"subset"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__fingerprint: typing_extensions.TypeAlias = typing.Literal["fingerprint"]
    _WhichOneofArgType__fingerprint: typing_extensions.TypeAlias = typing.Literal["_fingerprint", b"_fingerprint"]
    _WhichOneofReturnType__name: typing_extensions.TypeAlias = typing.Literal["name"]
    _WhichOneofArgType__name: typing_extensions.TypeAlias = typing.Literal["_name", b"_name"]
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__fingerprint) -> _WhichOneofReturnType__fingerprint | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__name) -> _WhichOneofReturnType__name | None: ...

Global___SetCoverProto: typing_extensions.TypeAlias = SetCoverProto

@typing.final
class SetCoverSolutionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Status:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SetCoverSolutionResponse._Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNDEFINED: SetCoverSolutionResponse._Status.ValueType  # 0
        """Undefined."""
        OPTIMAL: SetCoverSolutionResponse._Status.ValueType  # 1
        """The solver found the proven optimal solution."""
        FEASIBLE: SetCoverSolutionResponse._Status.ValueType  # 2
        """The solver had enough time to find some solution that satisfied all
        constraints, but it did not reach the optimal.
        """
        INFEASIBLE: SetCoverSolutionResponse._Status.ValueType  # 3
        """The model does not have any solution."""
        INVALID: SetCoverSolutionResponse._Status.ValueType  # 4
        """The model is invalid."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        """Result of the optimization."""

    UNDEFINED: SetCoverSolutionResponse.Status.ValueType  # 0
    """Undefined."""
    OPTIMAL: SetCoverSolutionResponse.Status.ValueType  # 1
    """The solver found the proven optimal solution."""
    FEASIBLE: SetCoverSolutionResponse.Status.ValueType  # 2
    """The solver had enough time to find some solution that satisfied all
    constraints, but it did not reach the optimal.
    """
    INFEASIBLE: SetCoverSolutionResponse.Status.ValueType  # 3
    """The model does not have any solution."""
    INVALID: SetCoverSolutionResponse.Status.ValueType  # 4
    """The model is invalid."""

    STATUS_FIELD_NUMBER: builtins.int
    NUM_SUBSETS_FIELD_NUMBER: builtins.int
    SUBSET_FIELD_NUMBER: builtins.int
    COST_FIELD_NUMBER: builtins.int
    COST_LOWER_BOUND_FIELD_NUMBER: builtins.int
    FINGERPRINT_FIELD_NUMBER: builtins.int
    MODEL_FINGERPRINT_FIELD_NUMBER: builtins.int
    status: Global___SetCoverSolutionResponse.Status.ValueType
    """For future use. TODO(user): Implement."""
    num_subsets: builtins.int
    """The number of subsets that are selected in the solution. This is used
    to decompress their indices below.
    """
    cost: builtins.float
    """The cost of the solution, as computed by the algorithm."""
    cost_lower_bound: builtins.float
    """A lower bound of the solution, as computed by the algorithm."""
    @property
    def subset(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The list of the subsets selected in the solution."""

    @property
    def fingerprint(self) -> ortools.util.int128_pb2.Int128:
        """An automatically fingerprint for the solution. TODO(user): Implement."""

    @property
    def model_fingerprint(self) -> ortools.util.int128_pb2.Int128:
        """A reference to the model the solution applies to. TODO(user): Implement."""

    def __init__(
        self,
        *,
        status: Global___SetCoverSolutionResponse.Status.ValueType | None = ...,
        num_subsets: builtins.int | None = ...,
        subset: collections.abc.Iterable[builtins.int] | None = ...,
        cost: builtins.float | None = ...,
        cost_lower_bound: builtins.float | None = ...,
        fingerprint: ortools.util.int128_pb2.Int128 | None = ...,
        model_fingerprint: ortools.util.int128_pb2.Int128 | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["_cost", b"_cost", "_cost_lower_bound", b"_cost_lower_bound", "_fingerprint", b"_fingerprint", "_model_fingerprint", b"_model_fingerprint", "_num_subsets", b"_num_subsets", "_status", b"_status", "cost", b"cost", "cost_lower_bound", b"cost_lower_bound", "fingerprint", b"fingerprint", "model_fingerprint", b"model_fingerprint", "num_subsets", b"num_subsets", "status", b"status"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["_cost", b"_cost", "_cost_lower_bound", b"_cost_lower_bound", "_fingerprint", b"_fingerprint", "_model_fingerprint", b"_model_fingerprint", "_num_subsets", b"_num_subsets", "_status", b"_status", "cost", b"cost", "cost_lower_bound", b"cost_lower_bound", "fingerprint", b"fingerprint", "model_fingerprint", b"model_fingerprint", "num_subsets", b"num_subsets", "status", b"status", "subset", b"subset"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__cost: typing_extensions.TypeAlias = typing.Literal["cost"]
    _WhichOneofArgType__cost: typing_extensions.TypeAlias = typing.Literal["_cost", b"_cost"]
    _WhichOneofReturnType__cost_lower_bound: typing_extensions.TypeAlias = typing.Literal["cost_lower_bound"]
    _WhichOneofArgType__cost_lower_bound: typing_extensions.TypeAlias = typing.Literal["_cost_lower_bound", b"_cost_lower_bound"]
    _WhichOneofReturnType__fingerprint: typing_extensions.TypeAlias = typing.Literal["fingerprint"]
    _WhichOneofArgType__fingerprint: typing_extensions.TypeAlias = typing.Literal["_fingerprint", b"_fingerprint"]
    _WhichOneofReturnType__model_fingerprint: typing_extensions.TypeAlias = typing.Literal["model_fingerprint"]
    _WhichOneofArgType__model_fingerprint: typing_extensions.TypeAlias = typing.Literal["_model_fingerprint", b"_model_fingerprint"]
    _WhichOneofReturnType__num_subsets: typing_extensions.TypeAlias = typing.Literal["num_subsets"]
    _WhichOneofArgType__num_subsets: typing_extensions.TypeAlias = typing.Literal["_num_subsets", b"_num_subsets"]
    _WhichOneofReturnType__status: typing_extensions.TypeAlias = typing.Literal["status"]
    _WhichOneofArgType__status: typing_extensions.TypeAlias = typing.Literal["_status", b"_status"]
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__cost) -> _WhichOneofReturnType__cost | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__cost_lower_bound) -> _WhichOneofReturnType__cost_lower_bound | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__fingerprint) -> _WhichOneofReturnType__fingerprint | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__model_fingerprint) -> _WhichOneofReturnType__model_fingerprint | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__num_subsets) -> _WhichOneofReturnType__num_subsets | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: _WhichOneofArgType__status) -> _WhichOneofReturnType__status | None: ...

Global___SetCoverSolutionResponse: typing_extensions.TypeAlias = SetCoverSolutionResponse
