

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>htrdrPy.geometry module &mdash; htrdrPy 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=d45e8c67"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="htrdrPy.script module" href="htrdrPy.script.html" />
    <link rel="prev" title="htrdrPy.data module" href="htrdrPy.data.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            htrdrPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="htrdrPy.html">htrdrPy documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="htrdrPy.data.html">htrdrPy.data module</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">htrdrPy.geometry module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#htrdrPy.geometry.Geometry"><code class="docutils literal notranslate"><span class="pre">Geometry</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#htrdrPy.geometry.Geometry.exportGeometry"><code class="docutils literal notranslate"><span class="pre">Geometry.exportGeometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#htrdrPy.geometry.Geometry.geometryFromAPIE"><code class="docutils literal notranslate"><span class="pre">Geometry.geometryFromAPIE()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#htrdrPy.geometry.Geometry.plotGeometry"><code class="docutils literal notranslate"><span class="pre">Geometry.plotGeometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#htrdrPy.geometry.Geometry.setCamera"><code class="docutils literal notranslate"><span class="pre">Geometry.setCamera()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#htrdrPy.geometry.Geometry.setImage"><code class="docutils literal notranslate"><span class="pre">Geometry.setImage()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#htrdrPy.geometry.Geometry.setSource"><code class="docutils literal notranslate"><span class="pre">Geometry.setSource()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#htrdrPy.geometry.Geometry.setSpectralCumulDist"><code class="docutils literal notranslate"><span class="pre">Geometry.setSpectralCumulDist()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#htrdrPy.geometry.Geometry.setVolrad"><code class="docutils literal notranslate"><span class="pre">Geometry.setVolrad()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="htrdrPy.script.html">htrdrPy.script module</a></li>
<li class="toctree-l2"><a class="reference internal" href="htrdrPy.postprocess.html">htrdrPy.postprocess module</a></li>
<li class="toctree-l2"><a class="reference internal" href="htrdrPy.helperFunctions.html">htrdrPy.helperFunctions module</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">htrdrPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="htrdrPy.html">htrdrPy documentation</a></li>
      <li class="breadcrumb-item active">htrdrPy.geometry module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/htrdrPy.geometry.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-htrdrPy.geometry">
<span id="htrdrpy-geometry-module"></span><h1>htrdrPy.geometry module<a class="headerlink" href="#module-htrdrPy.geometry" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">htrdrPy.geometry.</span></span><span class="sig-name descname"><span class="pre">Geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volrad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">case</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">htrdrPy.Geometry</span></code> is a class that aims at managing all information
related to the observation geometry. It handles the camera, source and image
properties as well as the mesh on which running the volumic radiative budget
calculations, if running on this mode.</p>
<p>The Geometry module handles the positioning, orientation and properties
of the camera and source.  The data can be provided directly when
creating an instance as distinct dictionnaries for the source, the
camera and the image, with the following keys:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Dictionnary containing the information on the source, with the
following keys:</p>
<ul>
<li><dl class="simple">
<dt>”longitude”<span class="classifier">float</span></dt><dd><p>Longitude of the source [°].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”latitude”<span class="classifier">float</span></dt><dd><p>Latitude of the source [°].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”distance” :</dt><dd><p>Distance of the source [m].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”radius”<span class="classifier">float</span></dt><dd><p>Radius of the source [m].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”temperature”<span class="classifier">float, optional</span></dt><dd><p>Surface temperature of the source [K] (used to calculate
the Planck’s function)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”radiance”<span class="classifier">str, optional</span></dt><dd><p>Path to a radiance file in htrdr readable format.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>”spectrum”<span class="classifier"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, optional</span></dt><dd><p>2-D array containing the spectrum (shape=(nWavelength,2)).
The first column contains the wavelength [nm] and the second
contains the radiance [W/m2/sr/nm]) at the surface of the
source.</p>
</dd>
</dl>
</li>
</ul>
</p></li>
<li><p><strong>camera</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Dictionnary containing the information on the camera, with the
following keys:</p>
<ul>
<li><dl>
<dt>”position”<span class="classifier"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>Position of the camera in cartesian coordinates (shape=(3),
[m]). The origin corresponds to the center of the observed
target.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>”target”<span class="classifier"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>Position of the target in cartesian coordinates (shape=(3),
[m]). The origin corresponds to the center of the observed
target. This is NOT the line of sight but the position
vector of the target.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”field of view”<span class="classifier">float</span></dt><dd><p>Vertical field of view of the camera [°] (the horizontal
field of view is calculated via scaling by the image aspect
ratio, assuming square pixels).</p>
</dd>
</dl>
</li>
<li><dl>
<dt>”roll”<span class="classifier"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, optional</span></dt><dd><p>Vector setting the upward direction of the camera (shape=(3),
[m]) i.e. a vector in the pixel plane to turn the camera
around the line of sight. If not provided, it is calculated
as perpendicular to the line of sight and to z axis (or x
axis if the z axis corresponds to the line of sight).</p>
</dd>
</dl>
</li>
</ul>
</p></li>
<li><p><strong>image</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Dictionnary containing the information on the image, with the
following keys:</p>
<ul>
<li><dl class="simple">
<dt>”definition”<span class="classifier">array-like</span></dt><dd><p>Definition (number of pixels) of the image (shape=(2), the
first value is the horizontal number of pixel and the second
value is the vertical pixel count).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”sampling”<span class="classifier">int</span></dt><dd><p>Number of rays to sample for each pixel.</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry.exportGeometry">
<span class="sig-name descname"><span class="pre">exportGeometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry.exportGeometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry.exportGeometry" title="Link to this definition"></a></dt>
<dd><p>Export the geometry (source, camera and image data) in a
geometry_{case}.json file stored in the “geometries/” repository</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry.geometryFromAPIE">
<span class="sig-name descname"><span class="pre">geometryFromAPIE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cameraFOV</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sourceDist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sourceRad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sourceTemp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radianceFile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry.geometryFromAPIE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry.geometryFromAPIE" title="Link to this definition"></a></dt>
<dd><p>Calulate the observation geometry from Azimut, Phase, Incident and
Emergent angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observation</strong> (<em>dict</em>) – <p>Dictionnary containing the geometry of the observation with the
following items:</p>
<ul>
<li><dl class="simple">
<dt>”azimut”<span class="classifier">float</span></dt><dd><p>Angle between the projected incidence and the projected
emergence [°].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”phase”<span class="classifier">float</span></dt><dd><p>Angle between incident rays (directly from the source) and
the line of sight [°].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”incidence”<span class="classifier">float</span></dt><dd><p>Angle between the incident rays (directly from the source)
and the normal to the ground at the observed loaction [°].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>”emergence”<span class="classifier">float</span></dt><dd><p>Angle between the normal to the line of sight and the normal
to the ground at the observed loaction [°].</p>
</dd>
</dl>
</li>
</ul>
</p></li>
<li><p><strong>distance</strong> (<em>float</em>) – Distance from the camera to the target [m].</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of the planet to locate the target on the surface [m].</p></li>
<li><p><strong>cameraFOV</strong> (<em>float</em>) – Field of view of the camera (c.f. <code class="docutils literal notranslate"><span class="pre">htrdrPy.Geometry.setCamera</span></code>).</p></li>
<li><p><strong>sourceDist</strong> (<em>float</em>) – Distance of the source [m] (c.f. <code class="docutils literal notranslate"><span class="pre">htrdrPy.Geometry.setSource</span></code>).</p></li>
<li><p><strong>sourceRad</strong> (<em>float</em>) – Radius of the source [m] (c.f. <code class="docutils literal notranslate"><span class="pre">htrdrPy.Geometry.setSource</span></code>).</p></li>
<li><p><strong>spectrum</strong> (<em>float</em><em>, </em><em>optional</em>) – Spectrum of the source (c.f. <code class="docutils literal notranslate"><span class="pre">htrdrpy.geometry.setsource</span></code>).</p></li>
<li><p><strong>radianceFile</strong> (<em>float</em><em>, </em><em>optional</em>) – Path to the radiance file of the source (c.f.
<cite>htrdrpy.geometry.setsource</cite>).</p></li>
<li><p><strong>sourcetemp</strong> (<em>float</em><em>, </em><em>optional</em>) – Temperature of the source (c.f. <code class="docutils literal notranslate"><span class="pre">htrdrpy.geometry.setsource</span></code>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry.plotGeometry">
<span class="sig-name descname"><span class="pre">plotGeometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry.plotGeometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry.plotGeometry" title="Link to this definition"></a></dt>
<dd><p>Plot the gometry: the observed planet, the line of sight (blue vector),
the source direction (red vector), the camera plan (black vectors) and
the field of view (green vectors).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ax</strong> (<em>matplotlib.pyplot.Axes</em>) – Axe on which draxing the plot. It must be a 3D axe.</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of the planet [m].</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>matplotlib.pyplot 3d projection has some issues with vector orientation.
If they have the right direction, they may not have the right sens.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry.setCamera">
<span class="sig-name descname"><span class="pre">setCamera</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targetPosition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fieldOfView</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry.setCamera"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry.setCamera" title="Link to this definition"></a></dt>
<dd><p>Setup the camera position, orientation and field of view</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>position</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – Position of the camera in cartesian coordinates (shape=(3),
[m]). The origin corresponds to the center of the observed
target.</p></li>
<li><p><strong>targetPosition</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – Position of the target in cartesian coordinates (shape=(3),
[m]). The origin corresponds to the center of the observed
target. This is NOT the line of sight but the position
vector of the target.</p></li>
<li><p><strong>fieldOfView</strong> (<em>float</em>) – Vertical field of view of the camera [°] (the horizontal
field of view is calculated via scaling by the image aspect
ratio, assuming square pixels).</p></li>
<li><p><strong>roll</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, optional) – Vector setting the upward direction of the camera (shape=(3),
[m]) i.e. a vector in the pixel plane to turn the camera
around the line of sight. If not provided, it is calculated
as perpendicular to the line of sight and to z axis (or x
axis if the z axis corresponds to the line of sight).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry.setImage">
<span class="sig-name descname"><span class="pre">setImage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">definition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry.setImage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry.setImage" title="Link to this definition"></a></dt>
<dd><p>Setup the image properties</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>definition&quot;</strong> (<em>array-like</em>) – Definition (number of pixels) of the image (shape=(2), the
first value is the horizontal number of pixel and the second
value is the vertical pixel count).</p></li>
<li><p><strong>sampling&quot;</strong> (<em>int</em>) – Number of rays to sample for each pixel.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry.setSource">
<span class="sig-name descname"><span class="pre">setSource</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">longitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radianceFile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry.setSource"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry.setSource" title="Link to this definition"></a></dt>
<dd><p>Setup the source properties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>longitude</strong> (<em>float</em>) – Longitude of the source [°].</p></li>
<li><p><strong>latitude</strong> (<em>float</em>) – Latitude of the source [°].</p></li>
<li><p><strong>distance</strong> – Distance of the source [m].</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of the source [m].</p></li>
<li><p><strong>temperature</strong> (<em>float</em><em>, </em><em>optional</em>) – Surface temperature of the source [K] (used to calculate
the Planck’s function)</p></li>
<li><p><strong>radianceFile</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to a radiance file in htrdr readable format.</p></li>
<li><p><strong>spectrum</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, optional) – 2-D array containing the spectrum (shape=(nWavelength,2)).
The first column contains the wavelength [nm] and the second
contains the radiance [W/m2/sr/nm]) at the surface of the
source.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Whereas <code class="docutils literal notranslate"><span class="pre">temperature</span></code>, <code class="docutils literal notranslate"><span class="pre">radianceFile</span></code> and <code class="docutils literal notranslate"><span class="pre">spectrum</span></code> are optional,
at least one of those must be provided. If more than one is provided,
the <code class="docutils literal notranslate"><span class="pre">spectrum</span></code> is taken in priority, then the <code class="docutils literal notranslate"><span class="pre">radianceFile</span></code> and
finally the <code class="docutils literal notranslate"><span class="pre">temperature</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry.setSpectralCumulDist">
<span class="sig-name descname"><span class="pre">setSpectralCumulDist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry.setSpectralCumulDist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry.setSpectralCumulDist" title="Link to this definition"></a></dt>
<dd><p>Setup the probability density function to used for sampling the
wavelength and correlated-k coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pdf</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – Table containing the cumulative distribution used to sample the
wavelength and k-coefficient
(shape=(nAltitudes,nLatitudes,nLongitudes,nSpectralElements)).
nSpectralElements correspond to nWavelength * nCoeff.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="htrdrPy.geometry.Geometry.setVolrad">
<span class="sig-name descname"><span class="pre">setVolrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'origin'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/htrdrPy/geometry.html#Geometry.setVolrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#htrdrPy.geometry.Geometry.setVolrad" title="Link to this definition"></a></dt>
<dd><p>Setup the volumic radiative budget properties.
The volumic radiative budget mode evaluate the divergence of the flux
within each provided tetrahedron. This method handles the generation of
the mesh on which the calulation will be conducted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sampling</strong> (<em>int</em>) – Number of ray to sample for each tetrahedron.</p></li>
<li><p><strong>mesh</strong> (<em>{&quot;origin&quot;</em><em>, </em><em>&quot;makeColumnPP&quot;</em><em>, </em><em>&quot;makeFromCellCoord&quot;</em><em>, </em><em>&quot;makeSliceAltLat&quot;</em><em>, </em><em>&quot;extractFromData&quot;}</em><em>, </em><em>default &quot;origin&quot;</em>) – <p>Method to build the mesh on which the radiative budget calculation
is realized.</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Building method</span><a class="headerlink" href="#id1" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>”origin”</p></td>
<td><p>Use the original atmosphere mesh.</p></td>
</tr>
<tr class="row-even"><td><p>”makeColumnPP”</p></td>
<td><p>Generate one plane-parallel column.</p></td>
</tr>
<tr class="row-odd"><td><p>”makeFromCellCoord”</p></td>
<td><p>Generate a complete sphere from a table of coordinates.</p></td>
</tr>
<tr class="row-even"><td><p>”makeSliceAltLat”</p></td>
<td><p>Generate a slice in altitude / latitude from a table of
coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p>”extractFromData”</p></td>
<td><p>Extract a list of cells from an already generated mesh.</p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>args</strong> (<em>tuple</em>) – <p>Tuple containing the arguments required by the chosen mesh
generation method.</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Arguments</span><a class="headerlink" href="#id2" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Required arguments</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>”origin”</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>”makeColumnPP”</p></td>
<td><dl>
<dt>altitudes<span class="classifier"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>Array continaing the altitudes [m], either at the center
of the cells or at the boundaries (shape = nLevel or
nLayer).</p>
</dd>
<dt>hwidth<span class="classifier">float</span></dt><dd><p>Horizontal dimension of the squared base column [m].</p>
</dd>
<dt>center<span class="classifier">bool, default: True</span></dt><dd><p>True if the altitudes represent the cell centers and
False if they correspond to the boundaries of the cells.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>”makeFromCellCoord”</p></td>
<td><dl>
<dt>cellCoord<span class="classifier"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>Coordinates of the cells centers or cell interface
centers (c.f. <code class="docutils literal notranslate"><span class="pre">onLevels</span></code>,
shape=(nAltitudes,nLatitudes,nLongitudes,3), [m])</p>
</dd>
<dt>radius<span class="classifier">float</span></dt><dd><p>Radius of the planet [m].</p>
</dd>
<dt>poles<span class="classifier">bool, default False</span></dt><dd><p>Whether or not the first and last latitudes correspond
to the poles in the given array of coordinates.</p>
</dd>
<dt>onLevels<span class="classifier">bool, default False</span></dt><dd><p>Whether or not the altitudes provided in the coordinates
are given on the levels or in the center of the cells.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>”makeSliceAltLat”</p></td>
<td><dl>
<dt>cellCoord<span class="classifier"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>Coordinates of the cells centers or cell interface
centers (c.f. <code class="docutils literal notranslate"><span class="pre">onLevels</span></code>,
shape=(nAltitudes,nLatitudes,3), [m])</p>
</dd>
<dt>radius<span class="classifier">float</span></dt><dd><p>Radius of the planet [m].</p>
</dd>
<dt>dLongitude<span class="classifier">float</span></dt><dd><p>Longitude width of the slice [°].</p>
</dd>
<dt>poles<span class="classifier">bool, default False</span></dt><dd><p>Whether or not the first and last latitudes correspond
to the poles in the given array of coordinates.</p>
</dd>
<dt>onLevels<span class="classifier">bool, default False</span></dt><dd><p>Whether or not the altitudes provided in the coordinates
are given on the levels or in the center of the cells.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>”extractFromData”</p></td>
<td><dl>
<dt>data<span class="classifier"><code class="docutils literal notranslate"><span class="pre">htrdrPy.Data</span></code> or <code class="docutils literal notranslate"><span class="pre">htrdrPy.Geometry</span></code></span></dt><dd><p>Object instance containing an already generated mesh
from which extracting the list of cells. This is
non-desctructive for the original <code class="docutils literal notranslate"><span class="pre">htrdrPy.Data</span></code> or
<code class="docutils literal notranslate"><span class="pre">htrdrPy.Geometry</span></code> and only affects the current
instance that “steals” the wanted cells.</p>
</dd>
<dt>cells<span class="classifier"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>Array of the cells to be extracted (shape=(nCell,3))
with the altitude, latitude and longitude indices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="htrdrPy.data.html" class="btn btn-neutral float-left" title="htrdrPy.data module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="htrdrPy.script.html" class="btn btn-neutral float-right" title="htrdrPy.script module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Anthony Arfaux.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>