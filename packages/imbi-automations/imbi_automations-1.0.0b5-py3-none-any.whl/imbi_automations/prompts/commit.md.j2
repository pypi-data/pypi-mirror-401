Your task is to analyze pending changes and create logical commits.

Your current working directory is already set to the repository directory. Run git commands directly without changing directories.

If there are no pending changes, exit immediately without performing any actions.

Analyze all pending changes in the current repository and create logical commits by grouping related changes together.

# Follow these guidelines:

1. Group changes by functional context:
   - Feature additions or modifications
   - Bug fixes
   - Refactoring without behavior changes
   - Documentation updates
   - Configuration changes
   - Test additions or modifications
   - Dependency updates

2. Within each functional group, further organize by:
   - Related files or modules
   - Logical components or subsystems
   - Interdependent changes that should stay together

3. For each commit:
   - Include only changes that logically belong together
   - Ensure each commit represents a complete, coherent unit of work

4. Prioritize commits in this order:
   - Critical bug fixes first
   - Core functionality changes
   - Supporting changes (tests, docs, config)
   - Cleanup and refactoring

# COMMIT EXECUTION PROCESS:

Step 1: For each logical group of changes, create a shell script at {{ working_directory }}/do-commit.sh with this content:

```bash
#!/bin/bash
set -e

# Stage the files
git add {file1} {file2} ...

# Create commit message file
COMMIT_MSG_FILE="{{ working_directory }}/commit_msg.txt"
cat > "${COMMIT_MSG_FILE}" << 'EOF'
imbi-automations: {{ workflow_name }} - {{ action_name }}

{Detailed description of what changed}
- Bullet points for multiple changes if needed

ðŸ¤– Generated with [Imbi Automations](https://github.com/AWeber-Imbi/)
EOF

# Perform the commit with trailers
GIT_AUTHOR_NAME="{{ commit_author_name }}" \
GIT_AUTHOR_EMAIL="{{ commit_author_address }}" \
GIT_COMMITTER_NAME="{{ commit_author_name }}" \
GIT_COMMITTER_EMAIL="{{ commit_author_address }}" \
git commit -F "${COMMIT_MSG_FILE}" {{ configuration.git.commit_args }} \
  --trailer "Authored-By: {{ commit_author }}" \
  --trailer "Co-Authored-By: Claude <noreply@anthropic.com>"

# Cleanup
rm "${COMMIT_MSG_FILE}"
```

Step 2: Make the script executable and run it:

```bash
chmod +x {{ working_directory }}/do-commit.sh
{{ working_directory }}/do-commit.sh
rm {{ working_directory }}/do-commit.sh
```

# CRITICAL RULES
- NEVER use 'git commit' directly in your bash commands
- ALWAYS create and execute the shell script
- The subject line MUST be exactly "imbi-automations: {{ workflow_name }} - {{ action_name }}" with NO other text
- NEVER use "Claude Code" in the attribution line
- Set GIT_AUTHOR_* and GIT_COMMITTER_* environment variables to ensure proper attribution

# RESPONSE FORMAT

After successfully creating commits (or determining there are no changes), you MUST call the `submit_task_response` tool with a message summarizing what was done.

Examples:
- If commits were created: `submit_task_response(message="Created 2 commits: fix-auth-bug (a1b2c3d) and update-docs (e4f5g6h)")`
- If no changes: `submit_task_response(message="No changes to commit - working tree is clean")`
- If commit failed: `submit_task_response(message="Commit failed: <error details>")`

IMPORTANT: You MUST call submit_task_response - simply outputting JSON is not sufficient.
