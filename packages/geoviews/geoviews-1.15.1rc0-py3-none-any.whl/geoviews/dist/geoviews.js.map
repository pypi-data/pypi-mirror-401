{"version":3,"sources":["@@/geoviews/dist/lib/index.js","@@/geoviews/dist/lib/models/index.js","@@/geoviews/dist/lib/models/checkpoint_tool.js","@@/geoviews/dist/lib/models/clear_tool.js","@@/geoviews/dist/lib/models/poly_draw.js","@@/geoviews/dist/lib/models/poly_edit.js","@@/geoviews/dist/lib/models/restore_tool.js","@@/geoviews/dist/lib/models/wind_barb.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* index.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const GeoViews = tslib_1.__importStar(require(\"2e3df39bba\") /* ./models */);\n    exports.GeoViews = GeoViews;\n    const base_1 = require(\"@bokehjs/base\");\n    (0, base_1.register_models)(GeoViews);\n}\n","/* models/index.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    var checkpoint_tool_1 = require(\"49636d3eef\") /* ./checkpoint_tool */;\n    __esExport(\"CheckpointTool\", checkpoint_tool_1.CheckpointTool);\n    var clear_tool_1 = require(\"356402dee7\") /* ./clear_tool */;\n    __esExport(\"ClearTool\", clear_tool_1.ClearTool);\n    var poly_draw_1 = require(\"c03d81e6d5\") /* ./poly_draw */;\n    __esExport(\"PolyVertexDrawTool\", poly_draw_1.PolyVertexDrawTool);\n    var poly_edit_1 = require(\"238deef1f5\") /* ./poly_edit */;\n    __esExport(\"PolyVertexEditTool\", poly_edit_1.PolyVertexEditTool);\n    var restore_tool_1 = require(\"1a96add9eb\") /* ./restore_tool */;\n    __esExport(\"RestoreTool\", restore_tool_1.RestoreTool);\n    var wind_barb_1 = require(\"028985dc77\") /* ./wind_barb */;\n    __esExport(\"WindBarb\", wind_barb_1.WindBarb);\n}\n","/* models/checkpoint_tool.js */ function _(require, module, exports, __esModule, __esExport) {\n    var _a;\n    __esModule();\n    const object_1 = require(\"@bokehjs/core/util/object\");\n    const array_1 = require(\"@bokehjs/core/util/array\");\n    const action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\n    const column_data_source_1 = require(\"@bokehjs/models/sources/column_data_source\");\n    const icons_css_1 = require(\"@bokehjs/styles/icons.css\");\n    class CheckpointToolView extends action_tool_1.ActionToolView {\n        doit() {\n            const sources = this.model.sources;\n            for (const source of sources) {\n                if (source.buffer == null) {\n                    source.buffer = [];\n                }\n                const data_copy = {};\n                for (const [key, column] of (0, object_1.entries)(source.data)) {\n                    const new_column = [];\n                    for (const arr of column) {\n                        if (Array.isArray(arr) || ArrayBuffer.isView(arr)) {\n                            new_column.push((0, array_1.copy)(arr));\n                        }\n                        else {\n                            new_column.push(arr);\n                        }\n                    }\n                    data_copy[key] = new_column;\n                }\n                source.buffer.push(data_copy);\n            }\n        }\n    }\n    exports.CheckpointToolView = CheckpointToolView;\n    CheckpointToolView.__name__ = \"CheckpointToolView\";\n    class CheckpointTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Checkpoint\";\n            this.tool_icon = icons_css_1.tool_icon_save;\n        }\n    }\n    exports.CheckpointTool = CheckpointTool;\n    _a = CheckpointTool;\n    CheckpointTool.__name__ = \"CheckpointTool\";\n    CheckpointTool.__module__ = \"geoviews.models.custom_tools\";\n    (() => {\n        _a.prototype.default_view = CheckpointToolView;\n        _a.define(({ List, Ref }) => ({\n            sources: [List(Ref(column_data_source_1.ColumnDataSource)), []],\n        }));\n    })();\n}\n","/* models/clear_tool.js */ function _(require, module, exports, __esModule, __esExport) {\n    var _a;\n    __esModule();\n    const action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\n    const column_data_source_1 = require(\"@bokehjs/models/sources/column_data_source\");\n    const icons_css_1 = require(\"@bokehjs/styles/icons.css\");\n    class ClearToolView extends action_tool_1.ActionToolView {\n        doit() {\n            for (const source of this.model.sources) {\n                source.clear();\n            }\n        }\n    }\n    exports.ClearToolView = ClearToolView;\n    ClearToolView.__name__ = \"ClearToolView\";\n    class ClearTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Clear data\";\n            this.tool_icon = icons_css_1.tool_icon_reset;\n        }\n    }\n    exports.ClearTool = ClearTool;\n    _a = ClearTool;\n    ClearTool.__name__ = \"ClearTool\";\n    ClearTool.__module__ = \"geoviews.models.custom_tools\";\n    (() => {\n        _a.prototype.default_view = ClearToolView;\n        _a.define(({ List, Ref }) => ({\n            sources: [List(Ref(column_data_source_1.ColumnDataSource)), []],\n        }));\n    })();\n}\n","/* models/poly_draw.js */ function _(require, module, exports, __esModule, __esExport) {\n    var _a;\n    __esModule();\n    const vectorization_1 = require(\"@bokehjs/core/vectorization\");\n    const object_1 = require(\"@bokehjs/core/util/object\");\n    const types_1 = require(\"@bokehjs/core/util/types\");\n    const assert_1 = require(\"@bokehjs/core/util/assert\");\n    const poly_draw_tool_1 = require(\"@bokehjs/models/tools/edit/poly_draw_tool\");\n    class PolyVertexDrawToolView extends poly_draw_tool_1.PolyDrawToolView {\n        _split_path(x, y) {\n            for (const renderer of this.model.renderers) {\n                const glyph = renderer.glyph;\n                const cds = renderer.data_source;\n                const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n                const xpaths = cds.data[xkey];\n                const ypaths = cds.data[ykey];\n                for (let index = 0; index < xpaths.length; index++) {\n                    let xs = xpaths[index];\n                    if (!(0, types_1.isArray)(xs)) {\n                        xs = Array.from(xs);\n                        cds.data[xkey][index] = xs;\n                    }\n                    let ys = ypaths[index];\n                    if (!(0, types_1.isArray)(ys)) {\n                        ys = Array.from(ys);\n                        cds.data[ykey][index] = ys;\n                    }\n                    for (let i = 0; i < xs.length; i++) {\n                        if ((xs[i] == x) && (ys[i] == y) && (i != 0) && (i != (xs.length - 1))) {\n                            xpaths.splice(index + 1, 0, xs.slice(i));\n                            ypaths.splice(index + 1, 0, ys.slice(i));\n                            xs.splice(i + 1);\n                            ys.splice(i + 1);\n                            for (const column of cds.columns()) {\n                                if ((column !== xkey) && (column != ykey)) {\n                                    cds.data[column].splice(index + 1, 0, cds.data[column][index]);\n                                }\n                            }\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        _snap_to_vertex(ev, x, y) {\n            const { vertex_renderer } = this.model;\n            if (vertex_renderer != null) {\n                // If an existing vertex is hit snap to it\n                const vertex_selected = this._select_event(ev, \"replace\", [vertex_renderer]);\n                const point_ds = vertex_renderer.data_source;\n                // Type once dataspecs are typed\n                const point_glyph = vertex_renderer.glyph;\n                const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n                if (vertex_selected.length > 0) {\n                    // If existing vertex is hit split path at that location\n                    // converting to feature vertex\n                    const index = point_ds.selected.indices[0];\n                    if (pxkey) {\n                        x = point_ds.get(pxkey)[index];\n                    }\n                    if (pykey) {\n                        y = point_ds.get(pykey)[index];\n                    }\n                    if (ev.type != \"move\") {\n                        this._split_path(x, y);\n                    }\n                    point_ds.selection_manager.clear();\n                }\n            }\n            return [x, y];\n        }\n        _set_vertices(xs, ys, styles) {\n            const { vertex_renderer } = this.model;\n            if (vertex_renderer == null) {\n                return;\n            }\n            const point_glyph = vertex_renderer.glyph;\n            const point_cds = vertex_renderer.data_source;\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n            if (pxkey) {\n                if ((0, types_1.isArray)(xs)) {\n                    point_cds.set(pxkey, xs);\n                }\n                else {\n                    point_glyph.x = { value: xs };\n                }\n            }\n            if (pykey) {\n                if ((0, types_1.isArray)(ys)) {\n                    point_cds.set(pykey, ys);\n                }\n                else {\n                    point_glyph.y = { value: ys };\n                }\n            }\n            if (styles != null) {\n                for (const key of (0, object_1.keys)(styles)) {\n                    point_cds.set(key, styles[key]);\n                    point_glyph[key] = { field: key };\n                }\n            }\n            else {\n                for (const col of point_cds.columns()) {\n                    point_cds.set(col, []);\n                }\n            }\n            this._emit_cds_changes(point_cds, true, true, false);\n        }\n        _show_vertices() {\n            if (!this.model.active) {\n                return;\n            }\n            const { renderers, node_style, end_style } = this.model;\n            const xs = [];\n            const ys = [];\n            const styles = {};\n            for (const key of (0, object_1.keys)(end_style)) {\n                styles[key] = [];\n            }\n            for (let i = 0; i < renderers.length; i++) {\n                const renderer = renderers[i];\n                const cds = renderer.data_source;\n                const glyph = renderer.glyph;\n                const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n                for (const array of cds.get_array(xkey)) {\n                    (0, assert_1.assert)((0, types_1.isArray)(array));\n                    xs.push(...array);\n                    for (const [key, val] of (0, object_1.entries)(end_style)) {\n                        styles[key].push(val);\n                    }\n                    for (const [key, val] of (0, object_1.entries)(node_style)) {\n                        for (let index = 0; index < array.length - 2; index++) {\n                            styles[key].push(val);\n                        }\n                    }\n                    for (const [key, val] of (0, object_1.entries)(end_style)) {\n                        styles[key].push(val);\n                    }\n                }\n                for (const array of cds.get_array(ykey)) {\n                    (0, assert_1.assert)((0, types_1.isArray)(array));\n                    ys.push(...array);\n                }\n                if (this._drawing && i == renderers.length - 1) {\n                    // Skip currently drawn vertex\n                    xs.splice(xs.length - 1, 1);\n                    ys.splice(ys.length - 1, 1);\n                    for (const [_, array] of (0, object_1.entries)(styles)) {\n                        array.splice(array.length - 1, 1);\n                    }\n                }\n            }\n            this._set_vertices(xs, ys, styles);\n        }\n        _remove() {\n            const renderer = this.model.renderers[0];\n            const cds = renderer.data_source;\n            const glyph = renderer.glyph;\n            if ((0, vectorization_1.isField)(glyph.xs)) {\n                const xkey = glyph.xs.field;\n                const array = cds.get_array(xkey);\n                const xidx = array.length - 1;\n                const xs = array[xidx];\n                xs.splice(xs.length - 1, 1);\n                if (xs.length == 1) {\n                    array.splice(xidx, 1);\n                }\n            }\n            if ((0, vectorization_1.isField)(glyph.ys)) {\n                const ykey = glyph.ys.field;\n                const array = cds.get_array(ykey);\n                const yidx = array.length - 1;\n                const ys = array[yidx];\n                ys.splice(ys.length - 1, 1);\n                if (ys.length == 1) {\n                    array.splice(yidx, 1);\n                }\n            }\n            this._emit_cds_changes(cds);\n            this._drawing = false;\n            this._show_vertices();\n        }\n    }\n    exports.PolyVertexDrawToolView = PolyVertexDrawToolView;\n    PolyVertexDrawToolView.__name__ = \"PolyVertexDrawToolView\";\n    class PolyVertexDrawTool extends poly_draw_tool_1.PolyDrawTool {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.PolyVertexDrawTool = PolyVertexDrawTool;\n    _a = PolyVertexDrawTool;\n    PolyVertexDrawTool.__name__ = \"PolyVertexDrawTool\";\n    PolyVertexDrawTool.__module__ = \"geoviews.models.custom_tools\";\n    (() => {\n        _a.prototype.default_view = PolyVertexDrawToolView;\n        _a.define(({ Dict, Unknown }) => ({\n            end_style: [Dict(Unknown), {}],\n            node_style: [Dict(Unknown), {}],\n        }));\n    })();\n}\n","/* models/poly_edit.js */ function _(require, module, exports, __esModule, __esExport) {\n    var _a;\n    __esModule();\n    const object_1 = require(\"@bokehjs/core/util/object\");\n    const types_1 = require(\"@bokehjs/core/util/types\");\n    const poly_edit_tool_1 = require(\"@bokehjs/models/tools/edit/poly_edit_tool\");\n    class PolyVertexEditToolView extends poly_edit_tool_1.PolyEditToolView {\n        deactivate() {\n            this._hide_vertices();\n            if (this._selected_renderer == null) {\n                return;\n            }\n            else if (this._drawing) {\n                this._remove_vertex();\n                this._drawing = false;\n            }\n            this._emit_cds_changes(this._selected_renderer.data_source, false, true, false);\n        }\n        _pan(ev) {\n            if (this._basepoint == null || this.model.vertex_renderer == null) {\n                return;\n            }\n            const points = this._drag_points(ev, [this.model.vertex_renderer]);\n            if (!ev.modifiers.shift) {\n                this._move_linked(points);\n            }\n            if (this._selected_renderer != null) {\n                this._selected_renderer.data_source.change.emit();\n            }\n        }\n        _pan_end(ev) {\n            if (this._basepoint == null || this.model.vertex_renderer == null) {\n                return;\n            }\n            const points = this._drag_points(ev, [this.model.vertex_renderer]);\n            if (!ev.modifiers.shift) {\n                this._move_linked(points);\n            }\n            this._emit_cds_changes(this.model.vertex_renderer.data_source, false, true, true);\n            if (this._selected_renderer != null) {\n                this._emit_cds_changes(this._selected_renderer.data_source);\n            }\n            this._basepoint = null;\n        }\n        _drag_points(ev, renderers) {\n            if (this._basepoint == null) {\n                return [];\n            }\n            const [bx, by] = this._basepoint;\n            const points = [];\n            for (const renderer of renderers) {\n                const basepoint = this._map_drag(bx, by, renderer);\n                const point = this._map_drag(ev.sx, ev.sy, renderer);\n                if (point == null || basepoint == null) {\n                    continue;\n                }\n                const [x, y] = point;\n                const [px, py] = basepoint;\n                const [dx, dy] = [x - px, y - py];\n                // Type once dataspecs are typed\n                const glyph = renderer.glyph;\n                const cds = renderer.data_source;\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n                for (const index of cds.selected.indices) {\n                    const point = [];\n                    if (xkey) {\n                        const xs = cds.get(xkey);\n                        point.push(xs[index]);\n                        xs[index] += dx;\n                    }\n                    if (ykey) {\n                        const ys = cds.get(ykey);\n                        point.push(ys[index]);\n                        ys[index] += dy;\n                    }\n                    point.push(dx);\n                    point.push(dy);\n                    points.push(point);\n                }\n                cds.change.emit();\n            }\n            this._basepoint = [ev.sx, ev.sy];\n            return points;\n        }\n        _set_vertices(xs, ys, styles) {\n            if (this.model.vertex_renderer == null) {\n                return;\n            }\n            const point_glyph = this.model.vertex_renderer.glyph;\n            const point_cds = this.model.vertex_renderer.data_source;\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n            if (pxkey) {\n                if ((0, types_1.isArray)(xs)) {\n                    point_cds.set(pxkey, xs);\n                }\n                else {\n                    point_glyph.x = { value: xs };\n                }\n            }\n            if (pykey) {\n                if ((0, types_1.isArray)(ys)) {\n                    point_cds.set(pykey, ys);\n                }\n                else {\n                    point_glyph.y = { value: ys };\n                }\n            }\n            if (styles != null) {\n                for (const [key, array] of (0, object_1.entries)(styles)) {\n                    point_cds.set(key, array);\n                    point_glyph[key] = { field: key };\n                }\n            }\n            else {\n                for (const col of point_cds.columns()) {\n                    point_cds.set(col, []);\n                }\n            }\n            this._emit_cds_changes(point_cds, true, true, false);\n        }\n        _move_linked(points) {\n            if (this._selected_renderer == null) {\n                return;\n            }\n            const renderer = this._selected_renderer;\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            const xpaths = cds.data[xkey];\n            const ypaths = cds.data[ykey];\n            for (const point of points) {\n                const [x, y, dx, dy] = point;\n                for (let index = 0; index < xpaths.length; index++) {\n                    const xs = xpaths[index];\n                    const ys = ypaths[index];\n                    for (let i = 0; i < xs.length; i++) {\n                        if ((xs[i] == x) && (ys[i] == y)) {\n                            xs[i] += dx;\n                            ys[i] += dy;\n                        }\n                    }\n                }\n            }\n        }\n        _tap(ev) {\n            if (this.model.vertex_renderer == null) {\n                return;\n            }\n            const renderer = this.model.vertex_renderer;\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\n            if (point == null) {\n                return;\n            }\n            else if (this._drawing && this._selected_renderer != null) {\n                let [x, y] = point;\n                const cds = renderer.data_source;\n                // Type once dataspecs are typed\n                const glyph = renderer.glyph;\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n                const indices = cds.selected.indices;\n                [x, y] = this._snap_to_vertex(ev, x, y);\n                const index = indices[0];\n                cds.selected.indices = [index + 1];\n                if (xkey) {\n                    const xs = cds.get_array(xkey);\n                    const nx = xs[index];\n                    xs[index] = x;\n                    xs.splice(index + 1, 0, nx);\n                }\n                if (ykey) {\n                    const ys = cds.get_array(ykey);\n                    const ny = ys[index];\n                    ys[index] = y;\n                    ys.splice(index + 1, 0, ny);\n                }\n                cds.change.emit();\n                this._emit_cds_changes(this._selected_renderer.data_source, true, false, true);\n                return;\n            }\n            this._select_event(ev, this._select_mode(ev), [renderer]);\n        }\n        _show_vertices(ev) {\n            if (!this.model.active) {\n                return;\n            }\n            const renderers = this._select_event(ev, \"replace\", this.model.renderers);\n            if (renderers.length === 0) {\n                this._hide_vertices();\n                this._selected_renderer = null;\n                this._drawing = false;\n                return;\n            }\n            const renderer = renderers[0];\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const index = cds.selected.indices[0];\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            let xs;\n            let ys;\n            if (xkey) {\n                xs = cds.get(xkey)[index];\n                if (!(0, types_1.isArray)(xs)) {\n                    cds.get(xkey)[index] = xs = Array.from(xs);\n                }\n            }\n            else {\n                xs = glyph.xs.value;\n            }\n            if (ykey) {\n                ys = cds.get(ykey)[index];\n                if (!(0, types_1.isArray)(ys)) {\n                    cds.get(ykey)[index] = ys = Array.from(ys);\n                }\n            }\n            else {\n                ys = glyph.ys.value;\n            }\n            const { end_style, node_style } = this.model;\n            const styles = {};\n            for (const [key, val] of (0, object_1.entries)(end_style)) {\n                styles[key] = [val];\n            }\n            for (const [key, val] of (0, object_1.entries)(node_style)) {\n                for (let index = 0; index < xs.length - 2; index++) {\n                    styles[key].push(val);\n                }\n            }\n            for (const [key, val] of (0, object_1.entries)(end_style)) {\n                styles[key].push(val);\n            }\n            this._selected_renderer = renderer;\n            this._set_vertices(xs, ys, styles);\n        }\n    }\n    exports.PolyVertexEditToolView = PolyVertexEditToolView;\n    PolyVertexEditToolView.__name__ = \"PolyVertexEditToolView\";\n    class PolyVertexEditTool extends poly_edit_tool_1.PolyEditTool {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.PolyVertexEditTool = PolyVertexEditTool;\n    _a = PolyVertexEditTool;\n    PolyVertexEditTool.__name__ = \"PolyVertexEditTool\";\n    PolyVertexEditTool.__module__ = \"geoviews.models.custom_tools\";\n    (() => {\n        _a.prototype.default_view = PolyVertexEditToolView;\n        _a.define(({ Dict, Unknown }) => ({\n            end_style: [Dict(Unknown), {}],\n            node_style: [Dict(Unknown), {}],\n        }));\n    })();\n}\n","/* models/restore_tool.js */ function _(require, module, exports, __esModule, __esExport) {\n    var _a;\n    __esModule();\n    const action_tool_1 = require(\"@bokehjs/models/tools/actions/action_tool\");\n    const column_data_source_1 = require(\"@bokehjs/models/sources/column_data_source\");\n    const icons_css_1 = require(\"@bokehjs/styles/icons.css\");\n    class RestoreToolView extends action_tool_1.ActionToolView {\n        doit() {\n            const sources = this.model.sources;\n            for (const source of sources) {\n                const new_data = source.buffer?.pop();\n                if (new_data == null) {\n                    continue;\n                }\n                source.data = new_data;\n                source.change.emit();\n                source.properties.data.change.emit();\n            }\n        }\n    }\n    exports.RestoreToolView = RestoreToolView;\n    RestoreToolView.__name__ = \"RestoreToolView\";\n    class RestoreTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Restore\";\n            this.tool_icon = icons_css_1.tool_icon_undo;\n        }\n    }\n    exports.RestoreTool = RestoreTool;\n    _a = RestoreTool;\n    RestoreTool.__name__ = \"RestoreTool\";\n    RestoreTool.__module__ = \"geoviews.models.custom_tools\";\n    (() => {\n        _a.prototype.default_view = RestoreToolView;\n        _a.define(({ List, Ref }) => ({\n            sources: [List(Ref(column_data_source_1.ColumnDataSource)), []],\n        }));\n    })();\n}\n","/* models/wind_barb.js */ function _(require, module, exports, __esModule, __esExport) {\n    var _a;\n    __esModule();\n    const tslib_1 = require(\"tslib\");\n    const xy_glyph_1 = require(\"@bokehjs/models/glyphs/xy_glyph\");\n    const property_mixins_1 = require(\"@bokehjs/core/property_mixins\");\n    const p = tslib_1.__importStar(require(\"@bokehjs/core/properties\"));\n    const selection_1 = require(\"@bokehjs/models/selections/selection\");\n    class WindBarbView extends xy_glyph_1.XYGlyphView {\n        _paint(ctx, indices, data) {\n            const { sx, sy, angle, magnitude } = data ?? this;\n            const y = this.y;\n            const scale = this.model.scale;\n            for (const i of indices) {\n                const screen_x = sx[i];\n                const screen_y = sy[i];\n                const a = angle.get(i);\n                const mag = magnitude.get(i);\n                const lat = y[i];\n                if (!isFinite(screen_x + screen_y + a + mag + lat))\n                    continue;\n                this._draw_wind_barb(ctx, screen_x, screen_y, a, mag, scale, i);\n            }\n        }\n        _draw_wind_barb(ctx, cx, cy, angle, magnitude, scale, idx = 0) {\n            // Wind barb drawing using meteorological convention\n            // magnitude is in knots (or appropriate units)\n            // angle is in meteorological convention (direction wind comes FROM)\n            // barbs point in the direction the wind is coming FROM\n            const barb_length = this.model.barb_length * scale;\n            const barb_width = this.model.barb_width * scale;\n            const flag_width = this.model.flag_width * scale;\n            ctx.save();\n            ctx.translate(cx, cy);\n            ctx.rotate(-angle);\n            ctx.beginPath();\n            this.visuals.line.apply(ctx, idx);\n            ctx.strokeStyle = ctx.strokeStyle || \"black\";\n            ctx.lineCap = \"round\";\n            ctx.lineJoin = \"round\";\n            // Determine barbs/flags based on magnitude\n            // Standard increments: 50 knots = flag (triangle), 10 knots = full barb, 5 knots = half barb\n            const mag_rounded = Math.round(magnitude / 5) * 5;\n            if (mag_rounded >= 5) {\n                // Draw the main staff (pointing in direction wind is coming from)\n                ctx.moveTo(0, 0);\n                ctx.lineTo(0, -barb_length);\n                ctx.stroke();\n                let remaining = mag_rounded;\n                let y_offset = -barb_length;\n                const spacing = this.model.spacing * scale;\n                // Draw 50-knot flags (filled triangles)\n                while (remaining >= 50) {\n                    ctx.fillStyle = ctx.strokeStyle || \"black\";\n                    ctx.beginPath();\n                    ctx.moveTo(0, y_offset);\n                    ctx.lineTo(flag_width, y_offset + spacing);\n                    ctx.lineTo(0, y_offset + spacing * 2);\n                    ctx.closePath();\n                    ctx.fill();\n                    y_offset += spacing * 2.5;\n                    remaining -= 50;\n                }\n                // Draw 10-knot barbs (full lines)\n                while (remaining >= 10) {\n                    ctx.beginPath();\n                    ctx.moveTo(0, y_offset);\n                    ctx.lineTo(barb_width, y_offset + barb_width * 0.2);\n                    ctx.stroke();\n                    y_offset += spacing;\n                    remaining -= 10;\n                }\n                // Draw 5-knot half-barb\n                if (remaining >= 5) {\n                    ctx.beginPath();\n                    ctx.moveTo(0, y_offset);\n                    ctx.lineTo(barb_width / 2, y_offset + barb_width * 0.1);\n                    ctx.stroke();\n                }\n            }\n            else {\n                // For calm winds (< 5 knots), draw only a circle (no staff line)\n                ctx.beginPath();\n                ctx.arc(0, 0, this.model.calm_circle_radius * scale, 0, 2 * Math.PI);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const candidates = [];\n            for (let i = 0; i < this.data_size; i++) {\n                const dx = this.sx[i] - sx;\n                const dy = this.sy[i] - sy;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n                if (dist < 10 * this.model.scale) { // Hit radius\n                    candidates.push(i);\n                }\n            }\n            return new selection_1.Selection({ indices: candidates });\n        }\n        draw_legend_for_index(ctx, { x0, x1, y0, y1 }, _index) {\n            const cx = (x0 + x1) / 2;\n            const cy = (y0 + y1) / 2;\n            // Draw a representative wind barb in the legend\n            this._draw_wind_barb(ctx, cx, cy, Math.PI / 4, 25, 0.5);\n        }\n    }\n    exports.WindBarbView = WindBarbView;\n    WindBarbView.__name__ = \"WindBarbView\";\n    class WindBarb extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.WindBarb = WindBarb;\n    _a = WindBarb;\n    WindBarb.__name__ = \"WindBarb\";\n    WindBarb.__module__ = \"geoviews.models.wind_barb\";\n    (() => {\n        _a.prototype.default_view = WindBarbView;\n        _a.define(({ Float }) => ({\n            angle: [p.AngleSpec, { value: 0 }],\n            magnitude: [p.NumberSpec, { value: 0 }],\n            scale: [Float, 1.0],\n            barb_length: [Float, 30.0],\n            barb_width: [Float, 15.0],\n            flag_width: [Float, 15.0],\n            spacing: [Float, 6.0],\n            calm_circle_radius: [Float, 3.0],\n        }));\n        _a.mixins(property_mixins_1.LineVector);\n    })();\n}\n"]}