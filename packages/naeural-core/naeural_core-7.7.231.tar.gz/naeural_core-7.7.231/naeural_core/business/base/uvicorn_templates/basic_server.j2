# AUTOGENERATED FILE
from fastapi import FastAPI, Request, HTTPException, Header, Depends, UploadFile, File, Form, Query
from fastapi.responses import FileResponse, JSONResponse, RedirectResponse, StreamingResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.staticfiles import StaticFiles
from starlette.responses import Response
from starlette.exceptions import HTTPException as StarletteHTTPException
from pathlib import Path
from typing import Dict, Any, List, Optional
import json
import re
from pydantic import BaseModel
from fastapi.middleware.cors import CORSMiddleware
from os import path as file_path
import time

import asyncio
import tempfile
import uuid
import os
import shutil
import aiofiles


from naeural_core.utils.uvicorn_fast_api_ipc_manager import UvicornPluginComms

eng = UvicornPluginComms(port={{ manager_port }}, auth={{ manager_auth }}, timeout_s={{ request_timeout }})

app = FastAPI(
  title={{ api_title }},
  summary={{ api_summary }},
  description={{ api_description }},
  version={{ api_version }},
)

app.add_middleware(
  CORSMiddleware,
  allow_origins=["*"],
  allow_credentials=True,
  allow_methods=["*"],
  allow_headers=["*"],
)

STATIC_DIR = "{{ static_directory }}"
DEBUG = {{ debug_web_app }}
{% if default_route is not none %}
DEFAULT_ROUTE = "{{ default_route }}"
{% else %}
DEFAULT_ROUTE = None
{% endif %}

PROFILE_RATE = {{ profile_rate }}
PROFILE_LOG_PER_REQUEST = {{ profile_log_per_request }}

"""
Profiling timings nomenclature (all timestamps are integers in nanoseconds).

This web server can emit sampled per-request timing profiles back to the
corresponding business plugin (`FastApiWebAppPlugin`) for aggregation/logging.
Most requests do not incur extra work; profiling is enabled only when
`PROFILE_RATE > 0`.

Clock domains
-------------
- `*_ns` fields use `time.perf_counter_ns()` (monotonic, suitable for durations).
- `*_wall_ns` fields use `time.time_ns()` (wall clock, used to estimate cross-process
  queueing delay on the same host).

Uvicorn/FastAPI-side markers
----------------------------
- `t_http_start_ns`: captured at the very start of the route handler.
- `t_before_call_plugin_ns`: right before IPC call (`eng.call_plugin(...)`).
- `t_after_call_plugin_ns`: immediately after IPC returns.
- `t_before_return_ns`: immediately before returning the HTTP response from the route.
- `t_upload_written_ns`: (upload endpoints only) after the uploaded payload is fully written to disk.

IPC markers (UvicornPluginComms)
-------------------------------
- `t_put_start_ns`, `t_put_end_ns`: duration of enqueueing the request to the IPC queue.
- `t_wait_start_ns`, `t_wait_end_ns`: duration spent waiting for the business plugin response.
- `t_put_wall_ns`: wall-clock time when the request was enqueued (used with plugin dequeue wall time).

Plugin-side markers (slice-aware for postponed requests)
-------------------------------------------------------
The plugin may return `PostponedRequest`, meaning the request completes over multiple
plugin-loop iterations. For this reason, execution time is represented as:
- `slice_count`: number of execution slices performed by the plugin for this request.
- `exec_total_ns`: sum of all slice durations in the plugin (monotonic).

Additionally, for queueing estimation on a single host:
- `t_plugin_dequeue_wall_ns`: wall-clock time when the plugin dequeued the request.
"""

# Define security scheme for Swagger UI
security = HTTPBearer()

def get_bearer_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    """
    Extract the Bearer token using FastAPI's HTTPBearer dependency.

    Parameters
    ----------
    credentials : HTTPAuthorizationCredentials
        Automatically provided by FastAPI when using HTTPBearer.

    Returns
    -------
    str
        The extracted token.

    Raises
    ------
    HTTPException
        If the token is invalid or missing.
    """
    if DEBUG:
        print(f"Received authorization credentials: {credentials}")
    if not credentials:
        raise HTTPException(status_code=401, detail="Authorization credentials are missing. Please provide a Bearer token.")
    if credentials.scheme.lower() != "bearer":
        raise HTTPException(status_code=401, detail=f"Invalid authorization scheme '{credentials.scheme}'. Expected 'Bearer'.")
    return credentials.credentials

def _should_profile() -> bool:
    if not isinstance(PROFILE_RATE, (int, float)) or PROFILE_RATE <= 0:
        return False
    if PROFILE_RATE >= 1:
        return True
    tail = uuid.uuid4().int & 0xFFFF
    return (tail / 0xFFFF) < PROFILE_RATE

def _start_profile(endpoint_name: str) -> dict | None:
    if not _should_profile():
        return None
    return {
        "endpoint": endpoint_name,
        "t_http_start_ns": time.perf_counter_ns(),
    }

async def _profiled_call_plugin(endpoint_name: str, call_plugin_args: List, profile: dict | None):
    if isinstance(profile, dict):
        profile["t_before_call_plugin_ns"] = time.perf_counter_ns()
    result = await eng.call_plugin(
        endpoint_name,
        *call_plugin_args,
        profile=profile,
    )
    if isinstance(profile, dict):
        profile["t_after_call_plugin_ns"] = time.perf_counter_ns()
    return result

def _finalize_profile(profile: dict | None, result: Any = None) -> None:
    if not isinstance(profile, dict):
        return
    profile["t_before_return_ns"] = time.perf_counter_ns()
    if isinstance(result, dict):
        status_code = result.get("status_code")
        if status_code is not None:
            profile["status_code"] = status_code
    asyncio.create_task(eng.send_profile_event(profile))
    return


{% for item in node_comm_params %}
{% if item['streaming_type'] == 'upload' %}
# Streaming upload endpoint
@app.post("/{{ item['name'] }}")
async def {{ item['name'] }}_upload(
    file: UploadFile = File(...),
    body: str = Form(None),
    {% if item['has_kwargs'] %}extras: str | None = Form(None),{% endif %}
    {% if item['require_token'] %}token: str = Depends(get_bearer_token){% endif %}
):
    """{{ item['endpoint_doc'] }}"""
    profile = _start_profile("{{ item['name'] }}")

    body_json = {}
    if body:
        try:
            body_json = json.loads(body)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid JSON in form field 'body'")

    {% if item['has_kwargs'] %}
        extras_dict: Dict[str, Any] = {}
        if extras:
            try:
                extras_dict = json.loads(extras)
            except Exception:
                raise HTTPException(status_code=400,
                                    detail="Invalid JSON in form field 'extras'")
    {% endif %}

    temp_dir = None
    file_path = None

    try:
        # Create a unique temp directory and file path
        temp_dir = tempfile.mkdtemp(prefix="upload_", dir="/tmp")
        file_name = f"{file.filename}"
        file_path = os.path.join(temp_dir, file_name)

        # Save uploaded file stream chunk by chunk to disk
        with open(file_path, "wb") as f:
            while True:
                chunk = await file.read(1024 * 1024)
                if not chunk:
                    break
                f.write(chunk)
        if isinstance(profile, dict):
            profile["t_upload_written_ns"] = time.perf_counter_ns()

        # Prepare arguments for plugin call

        call_plugin_args: List = []
        {% if item['require_token'] %}call_plugin_args.append(token){% endif %}
        call_plugin_args += [file_path, body_json]

{#        call_plugin_kwargs: Dict[str, Any] = {}#}
{#        {% if item['has_kwargs'] %}call_plugin_kwargs.update(extras_dict){% endif %}#}
        {% if item['has_kwargs'] %}call_plugin_args.append(extras_dict){% endif %}

        result = await _profiled_call_plugin("{{ item['name'] }}", call_plugin_args, profile)

        _finalize_profile(profile, result)
        return result

    except Exception as e:
        # Optionally log the exception or wrap it in an HTTPException
        import traceback
        print(f"Error during file upload endpoint: {e}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")

    finally:
        # Cleanup: remove temp file and directory if they exist
        try:
            if file_path and os.path.isfile(file_path):
                os.remove(file_path)
            if temp_dir and os.path.isdir(temp_dir):
                shutil.rmtree(temp_dir)
        except Exception as cleanup_exc:
            print(f"Failed to cleanup temp upload files: {cleanup_exc}")


{% elif item['streaming_type'] == 'download' %}
# Streaming download endpoint
@app.get("/{{ item['name'] }}")
async def {{ item['name'] }}_download(
{#    {% for arg in item['args'] %}{{ arg }}, {% endfor %}#}
    {% if item['has_kwargs'] %}extras: str | None = Query(None),{% endif %}
    {% for arg in item['args'] %}{{ arg }}, {% endfor %}
    {% if item['require_token'] %}token: str = Depends(get_bearer_token){% endif %}
):
    """{{ item['endpoint_doc'] }}"""
    profile = _start_profile("{{ item['name'] }}")

    {% if item['has_kwargs'] %}
    kwargs_dict: dict = {}
    if extras:
        try:
            kwargs_dict = json.loads(extras)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid JSON in query param 'extras'")
    {% endif %}

    call_plugin_args: List = []
    {% if item['require_token'] %}call_plugin_args.append(token){% endif %}
    {% for param in item['params'] %}
    call_plugin_args.append({{ param }})
    {% endfor %}
    {% if item['has_kwargs'] %}call_plugin_args.append(kwargs_dict){% endif %}

    response = await _profiled_call_plugin("{{ item['name'] }}", call_plugin_args, profile)

    file_path = ''
    meta = {}

    if isinstance(response, dict):
        # If the plugin returns a dict, extract the file path and metadata
        result = response.get("result", {})
        file_path = result.get("file_path", "")
        meta = result.get("meta", {})

    if not (isinstance(file_path, str) and os.path.isfile(file_path)):
        a = f"File not found!"
        raise HTTPException(status_code=404, detail=a)

    meta_str = json.dumps(meta)

    async def file_generator():
        chunk_size = 1024 * 1024  # 1 MB chunks
        async with aiofiles.open(file_path, 'rb') as f:
            while True:
                chunk = await f.read(chunk_size)
                if not chunk:
                    break
                yield chunk

    headers = {
        "x-meta": meta_str
    }

    _finalize_profile(profile, response)
    return StreamingResponse(file_generator(), media_type='application/octet-stream', headers=headers)

{% else %}
# Regular endpoint
{% if item['method']=='post' %}
class {{ item['name'] }}Model(BaseModel):
    {% if item['args'] %}
    {% for arg in item['args'] %}
    {{ arg }}
    {% endfor %}
    {% if item['has_kwargs'] %}extras: Dict[str, Any] | None = None{% endif %}
    {% else %}
    pass
    {% endif %}

@app.post("/{{ item['name'] }}")
async def {{ item['name'] }}(
    request: {{ item['name'] }}Model
    {% if item['require_token'] %}, token: str = Depends(get_bearer_token){% endif %}
):
    """{{ item['endpoint_doc'] }}"""
    profile = _start_profile("{{ item['name'] }}")
    {% for param in item['params'] %}
    {{ param }} = request.{{ param }}
    {% endfor %}

    {% if item['has_kwargs'] %}
    kwargs_dict = request.extras or {}
    {% endif %}

    # ---- build call arguments once, no nested ifs ----
    call_plugin_args: List = []
    {% if item['require_token'] %}call_plugin_args.append(token){% endif %}
    {% for param in item['params'] %}
    call_plugin_args.append({{ param }})
    {% endfor %}

{#    call_plugin_kwargs: Dict[str, Any] = {}#}
{#    {% if item['has_kwargs'] %}call_plugin_kwargs.update(kwargs_dict){% endif %}#}
    {% if item['has_kwargs'] %}call_plugin_args.append(kwargs_dict){% endif %}

    result = await _profiled_call_plugin("{{ item['name'] }}", call_plugin_args, profile)

    {% if item['require_token'] %}
    if result.get("result") == "Unauthorized token" or result.get("status_code") == 401:
        raise HTTPException(status_code=401, detail=result.get("result", result))
    {% endif %}
    _finalize_profile(profile, result)
    return result
{% else %}
{% if item['method'] is not none %}@app.{{ item['method'] }}("/{{ item['name'] }}"){% endif %}
async def {{ item['name'] }}(
    {% if item['has_kwargs'] %}extras: str | None = Query(None), {% endif %}
    {% for arg in item['args'] %}
    {{ arg }}, {% if not loop.last %} {% endif %}
    {% endfor %}
    {% if item['require_token'] %}token: str = Depends(get_bearer_token){% endif %}
):
    """{{ item['endpoint_doc'] }}"""
    profile = _start_profile("{{ item['name'] }}")
    {% if item['has_kwargs'] %}
    kwargs_dict: Dict[str, Any] = {}
    if extras:
        try:
            kwargs_dict = json.loads(extras)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid JSON in query param 'extras'")
    {% endif %}

    # ---- build call arguments once, no nested ifs ----
    call_plugin_args: List = []
    {% if item['require_token'] %}call_plugin_args.append(token){% endif %}
    {% for param in item['params'] %}
    call_plugin_args.append({{ param }})
    {% endfor %}

{#    call_plugin_kwargs: Dict[str, Any] = {}#}
{#    {% if item['has_kwargs'] %}call_plugin_kwargs.update(kwargs_dict){% endif %}#}
    {% if item['has_kwargs'] %}call_plugin_args.append(kwargs_dict){% endif %}

    result = await _profiled_call_plugin("{{ item['name'] }}", call_plugin_args, profile)

    {% if item['require_token'] %}
    if result.get("result") == "Unauthorized token" or result.get("status_code") == 401:
        raise HTTPException(status_code=401, detail=result.get("result", result))
    {% endif %}
    _finalize_profile(profile, result)
    return result
{% endif %}
{% endif %} # endif item['streaming_type'] %}
{% endfor %}


{% for item in html_files %}
@app.{{ item['method'] }}('{{ item['route'] }}')
async def html_route{{ loop.index }}():
  return FileResponse(file_path.join(STATIC_DIR, '{{ item['name'] }}'))

{% endfor %}

HTML_ROUTE_TO_FILE = {
{% for item in html_files %}
    "{{ item['route'] }}": "{{ item['name'] }}",
{% endfor %}
}
DEFAULT_ROUTE_FILE = HTML_ROUTE_TO_FILE.get(DEFAULT_ROUTE) if DEFAULT_ROUTE is not None else None


@app.exception_handler(StarletteHTTPException)
async def custom_404_handler(request: Request, exc: StarletteHTTPException):
    if exc.status_code == 404:
        # Regex pattern to match files with specific extensions
        pattern = re.compile(r".*\.(js|png|jpg|css|jpeg|gif|svg|ico)$")
        if pattern.match(request.url.path):
            file_path = Path(STATIC_DIR) / request.url.path.strip("/")
            if file_path.exists() and file_path.is_file():
                return FileResponse(file_path)

    if DEFAULT_ROUTE is not None and request.url.path != DEFAULT_ROUTE:
        if DEFAULT_ROUTE_FILE is not None:
            return FileResponse(file_path.join(STATIC_DIR, DEFAULT_ROUTE_FILE))
        return RedirectResponse(url=DEFAULT_ROUTE, status_code=307)
    # endif DEFAULT_ROUTE defined

    print(f"StarletteHTTPException during request for {request.url}:\n{exc}")
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail or "An error occurred."},
    )

app.mount(f"/{STATIC_DIR}", StaticFiles(directory=STATIC_DIR), name="static")
