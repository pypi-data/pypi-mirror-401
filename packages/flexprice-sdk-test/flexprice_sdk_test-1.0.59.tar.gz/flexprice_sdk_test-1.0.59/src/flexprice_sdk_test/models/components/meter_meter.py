"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .meter_aggregation import MeterAggregation, MeterAggregationTypedDict
from .meter_filter import MeterFilter, MeterFilterTypedDict
from .types_resetusage import TypesResetUsage
from .types_status import TypesStatus
from flexprice_sdk_test.types import BaseModel
from typing import List, Optional
from typing_extensions import NotRequired, TypedDict


class MeterMeterTypedDict(TypedDict):
    aggregation: NotRequired[MeterAggregationTypedDict]
    created_at: NotRequired[str]
    created_by: NotRequired[str]
    environment_id: NotRequired[str]
    r"""EnvironmentID is the environment identifier for the meter"""
    event_name: NotRequired[str]
    r"""EventName is the unique identifier for the event that this meter is tracking
    It is a mandatory field in the events table and hence being used as the primary matching field
    We can have multiple meters tracking the same event but with different filters and aggregation
    """
    filters: NotRequired[List[MeterFilterTypedDict]]
    r"""Filters define the criteria for the meter to be applied on the events before aggregation
    It also defines the possible values on which later the charges will be applied
    """
    id: NotRequired[str]
    r"""ID is the unique identifier for the meter"""
    name: NotRequired[str]
    r"""Name is the display name of the meter"""
    reset_usage: NotRequired[TypesResetUsage]
    status: NotRequired[TypesStatus]
    tenant_id: NotRequired[str]
    updated_at: NotRequired[str]
    updated_by: NotRequired[str]


class MeterMeter(BaseModel):
    aggregation: Optional[MeterAggregation] = None

    created_at: Optional[str] = None

    created_by: Optional[str] = None

    environment_id: Optional[str] = None
    r"""EnvironmentID is the environment identifier for the meter"""

    event_name: Optional[str] = None
    r"""EventName is the unique identifier for the event that this meter is tracking
    It is a mandatory field in the events table and hence being used as the primary matching field
    We can have multiple meters tracking the same event but with different filters and aggregation
    """

    filters: Optional[List[MeterFilter]] = None
    r"""Filters define the criteria for the meter to be applied on the events before aggregation
    It also defines the possible values on which later the charges will be applied
    """

    id: Optional[str] = None
    r"""ID is the unique identifier for the meter"""

    name: Optional[str] = None
    r"""Name is the display name of the meter"""

    reset_usage: Optional[TypesResetUsage] = None

    status: Optional[TypesStatus] = None

    tenant_id: Optional[str] = None

    updated_at: Optional[str] = None

    updated_by: Optional[str] = None
