Metadata-Version: 2.4
Name: django-gisserver
Version: 2.3.0
Summary: Django speaking WFS 2.0 (exposing GeoDjango model fields)
Home-page: https://github.com/amsterdam/django-gisserver
Author: Diederik van der Boor
Author-email: opensource@edoburu.nl
License: Mozilla Public License 2.0
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Web Environment
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: 3.14
Classifier: Framework :: Django
Classifier: Framework :: Django :: 4.2
Classifier: Framework :: Django :: 5.2
Classifier: Topic :: Internet :: WWW/HTTP
Classifier: Topic :: Internet :: WWW/HTTP :: Dynamic Content
Classifier: Topic :: Software Development :: Libraries :: Application Frameworks
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires: Django (>=4.2, >=5.2, <6.0)
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: Django<6.0,>=4.2
Requires-Dist: defusedxml>=0.7.1
Requires-Dist: lru_dict>=1.4.1
Requires-Dist: orjson>=3.11.5
Requires-Dist: pyproj>=3.7.1
Provides-Extra: tests
Requires-Dist: django-environ>=0.12.0; extra == "tests"
Requires-Dist: psycopg2-binary>=2.9.11; extra == "tests"
Requires-Dist: lxml>=6.0.2; extra == "tests"
Requires-Dist: pytest>=9.0.2; extra == "tests"
Requires-Dist: pytest-django>=4.11.1; extra == "tests"
Requires-Dist: pytest-cov>=7.0.0; extra == "tests"
Provides-Extra: docs
Requires-Dist: Django~=5.2; extra == "docs"
Requires-Dist: sphinxcontrib-django>=2.5; extra == "docs"
Requires-Dist: myst-parser>=4.0.1; extra == "docs"
Requires-Dist: psycopg2-binary>=2.9.11; extra == "docs"
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: license
Dynamic: license-file
Dynamic: provides-extra
Dynamic: requires
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

[![Documentation](https://readthedocs.org/projects/django-gisserver/badge/?version=latest)](https://django-gisserver.readthedocs.io/en/latest/?badge=latest)
[![Actions](https://github.com/Amsterdam/django-gisserver/actions/workflows/tests.yaml/badge.svg?branch=main)](https://github.com/Amsterdam/django-gisserver/actions/workflows/tests.yaml)
[![PyPI](https://img.shields.io/pypi/v/django-gisserver.svg)](https://pypi.python.org/pypi/django-gisserver)
[![MPL License](https://img.shields.io/badge/license-MPL%202.0-blue.svg)](https://pypi.python.org/pypi/django-gisserver)
[![Coverage](https://img.shields.io/codecov/c/github/amsterdam/django-gisserver/main.svg)](https://codecov.io/github/amsterdam/django-gisserver?branch=main)

# django-gisserver

Django speaking WFS 2.0 to expose geo data.

## Features

* WFS 2.0 Basic implementation.
* GML 3.2 output.
* Standard and spatial filtering (FES 2.0)
* GeoJSON and CSV export formats.
* Extensible view/operations.
* Uses GeoDjango queries for filtering.
* Streaming responses for large datasets.

## Documentation

For more details, see: <https://django-gisserver.readthedocs.io/>

## Test drive

* Run `docker compose up`.
* Open http://localhost:8000/ to see this works.
* Connect to http://localhost:8000/wfs/ in your GIS client (e.g. QGis) and zoom to Amsterdam.
* Add more data on the map using the Django admin, username and password are both "admin".

## Quickstart

Install the module in your project:

```bash
pip install django-gisserver
```

Add it to the ``INSTALLED_APPS``:

```python
INSTALLED_APPS = [
    ...
    "gisserver",
]
```

Create a model that exposes a GeoDjango field:

```python
from django.contrib.gis.db.models import PointField
from django.db import models


class Restaurant(models.Model):
    name = models.CharField(max_length=200)
    location = PointField(null=True)

    def __str__(self):
        return self.name
```

Write a view that exposes this model as a WFS feature:

```python
from gisserver.crs import CRS, CRS84, WEB_MERCATOR
from gisserver.features import FeatureType, ServiceDescription
from gisserver.views import WFSView
from .models import Restaurant

# As example, the local coordinate system for The Netherlands
RD_NEW = CRS.from_string("urn:ogc:def:crs:EPSG::28992")


class PlacesWFSView(WFSView):
    """An simple view that uses the WFSView against our test model."""

    xml_namespace = "http://example.org/gisserver"

    # The service metadata
    service_description = ServiceDescription(
        title="Places",
        abstract="Unittesting",
        keywords=["django-gisserver"],
        provider_name="Django",
        provider_site="https://www.example.com/",
        contact_person="django-gisserver",
    )

    # Each Django model is listed here as a feature.
    feature_types = [
        FeatureType(
            Restaurant.objects.all(),
            fields="__all__",
            other_crs=[RD_NEW, CRS84, WEB_MERCATOR]
        ),
    ]
```

Use that view in the URLConf:

```python
from django.urls import path
from . import views

urlpatterns = [
    path("/wfs/places/", views.PlacesWFSView.as_view()),
]
```

You can now use http://localhost:8000/wfs/places/ in your GIS application.
It will perform requests such as:

* <http://localhost:8000/wfs/places/?SERVICE=WFS&REQUEST=GetCapabilities&ACCEPTVERSIONS=2.0.0,1.1.0,1.0.0>
* <http://localhost:8000/wfs/places/?SERVICE=WFS&REQUEST=DescribeFeatureType&VERSION=2.0.0&TYPENAMES=restaurant>
* <http://localhost:8000/wfs/places/?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=restaurant&STARTINDEX=0&COUNT=1000&SRSNAME=urn:ogc:def:crs:EPSG::28992>

By adding `&OUTPUTFORMAT=geojson` or `&OUTPUTFORMAT=csv` to the `GetFeature` request, the GeoJSON and CSV outputs are returned.
The CSV output has an unlimited page size, as it's quite performant.



## Why this code is shared

The "datapunt" team of the Municipality of Amsterdam develops software for the municipality.
Much of this software is then published as Open Source so that other municipalities,
organizations and citizens can use the software as a basis and inspiration to develop
similar software themselves. The Municipality of Amsterdam considers it important that
software developed with public money is also publicly available.

This package is initially developed by the City of Amsterdam, but the tools
and concepts created in this project can be used in any city.
