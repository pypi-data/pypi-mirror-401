了解です。`m1k1o/neko` を **tspec-runner の “UI backend” として追加**し、「使える状態（まずは *安定して* 使える範囲から）」にします。

現時点で n.eko(v3) の公開ドキュメントから **確実に叩ける REST** は少なくとも以下です：

* ヘルスチェック: `GET /health` ([neko.m1k1o.net][1])
* ログイン: `POST /api/login` ([neko.m1k1o.net][2])
* スクショ取得: `GET /api/room/screen/shot.jpg` ([neko.m1k1o.net][3])
* 操作権: request / release / reset

  * `POST /api/room/control/request` ([neko.m1k1o.net][4])
  * `POST /api/room/control/release` ([neko.m1k1o.net][5])
  * `POST /api/room/control/reset` ([neko.m1k1o.net][6])

一方で、**キーボード/マウス入力イベントの REST エンドポイント**は、ドキュメント検索では確証が取れませんでした（v3 は WebRTC / WebSocket / DataChannel の比重が高い）。([neko.m1k1o.net][7])
なので、まずは **「n.eko を “実行環境(ブラウザ/デスクトップ) として扱い、スクショ証跡と状態確認を強化」**する形で backend を入れ、入力系は **後続のバージョンで段階的に拡張**するのが安全です（ここで推測実装すると、あなたの未来のデバッグ時間が溶けます。猫だけに。）

---

## 追加する仕様（backend: `neko`）

### 1) CLI 追加（`tspec run`）

* `--backend neko` を追加
* n.eko 接続情報（いずれも環境変数で代替可）

  * `--neko-url`（例: `http://127.0.0.1:8080`）
  * `--neko-user`（例: `guest`）
  * `--neko-password`（例: `neko`）
  * `--neko-token`（任意。将来的に bearer / token auth 用）
  * `--neko-implicit-control`（true の場合、control request を省略。n.eko 側の implicit control を使う想定）

環境変数も同等に対応：

* `TSPEC_NEKO_URL`
* `TSPEC_NEKO_USER`
* `TSPEC_NEKO_PASSWORD`
* `TSPEC_NEKO_TOKEN`
* `TSPEC_NEKO_IMPLICIT_CONTROL`

### 2) 実装する UI アクション（最小コア）

* `ui.open_app`（意味を “n.eko へログイン & 操作権取得” に読み替え）
* `ui.screenshot`（`shot.jpg` を保存して証跡に）
* `ui.wait_for`（最低限：ヘルスが OK / スクショが取得できるまで待つ、の2モード）
* `ui.close_app`（control release して終了）

> `ui.click / ui.type` などの入力系は v1 では **NotSupported** とし、エラーメッセージで「対応予定」と「回避策」を出す（例：Selenium/Appium backend を使う、または n.eko 側の拡張が必要）。

### 3) レポート統合

* 既存 JSON / pytest-html / junitxml はそのまま
* `neko` 実行時は「取得したスクショパス」「n.eko url」「control request/release の結果」を step metadata に入れる（今の forensics 表示が活きる）

### 4) `tspec versions` 拡張

* `TSPEC_NEKO_URL` があれば `GET /health` を叩いて表示 ([neko.m1k1o.net][1])
* 可能なら `GET /api/stats` も表示（認証要否は環境次第なので失敗は WARN 扱い）([neko.m1k1o.net][8])

---

## 追加ファイル（コード）—コピペで入れられる形

> あなたのリポジトリ構造が `src/tspec/ui/*.py` 系なので、それに合わせています。
> ※ いまこちら側で ZIP を再生成するための実行環境ツールが落ちていて、直接ファイルを生成して渡せません。なので「そのまま貼れば動く」パッチとして出します。

---

### A) `src/tspec/ui/neko_driver.py`（新規）

```python
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Optional, Any, Dict
import time

import requests


class NekoError(RuntimeError):
    pass


@dataclass
class NekoConfig:
    url: str
    user: Optional[str] = None
    password: Optional[str] = None
    token: Optional[str] = None
    implicit_control: bool = False
    timeout_s: float = 30.0


class NekoUIDriver:
    """
    Minimal n.eko(v3) REST client driver.

    Supported (documented):
      - GET  /health
      - POST /api/login
      - GET  /api/room/screen/shot.jpg
      - POST /api/room/control/request|release|reset
    """

    def __init__(self, cfg: NekoConfig):
        self.cfg = cfg
        self.session = requests.Session()
        self._logged_in = False
        self._has_control = False

        # Token support (future-proof): if provided, use Authorization header.
        if cfg.token:
            self.session.headers["Authorization"] = f"Bearer {cfg.token}"

    def _u(self, path: str) -> str:
        return self.cfg.url.rstrip("/") + path

    def health(self) -> bool:
        r = self.session.get(self._u("/health"), timeout=self.cfg.timeout_s)
        return r.status_code == 200

    def login(self) -> None:
        # If already logged in, skip
        if self._logged_in:
            return

        # Some deployments may allow noauth, in that case login could be unnecessary.
        if not self.cfg.user and not self.cfg.password:
            # Try access screenshot to see if auth is required.
            self._logged_in = True
            return

        payload = {"username": self.cfg.user or "", "password": self.cfg.password or ""}
        r = self.session.post(self._u("/api/login"), json=payload, timeout=self.cfg.timeout_s)

        if r.status_code != 200:
            raise NekoError(f"neko login failed: {r.status_code} {r.text[:200]}")

        # n.eko uses session cookie auth; requests.Session keeps cookies.
        self._logged_in = True

    def request_control(self) -> None:
        if self._has_control or self.cfg.implicit_control:
            return
        r = self.session.post(self._u("/api/room/control/request"), timeout=self.cfg.timeout_s)
        if r.status_code not in (204,):
            raise NekoError(f"neko control request failed: {r.status_code} {r.text[:200]}")
        self._has_control = True

    def release_control(self) -> None:
        if not self._has_control:
            return
        r = self.session.post(self._u("/api/room/control/release"), timeout=self.cfg.timeout_s)
        if r.status_code not in (204,):
            # release は失敗しても後始末なので WARN 相当で握りつぶし可だが、
            # ここでは例外にして上位で WARN 扱いにしてもらう想定。
            raise NekoError(f"neko control release failed: {r.status_code} {r.text[:200]}")
        self._has_control = False

    def reset_control(self) -> None:
        r = self.session.post(self._u("/api/room/control/reset"), timeout=self.cfg.timeout_s)
        if r.status_code not in (204,):
            raise NekoError(f"neko control reset failed: {r.status_code} {r.text[:200]}")

    def screenshot(self, out_path: Path) -> Path:
        out_path.parent.mkdir(parents=True, exist_ok=True)
        r = self.session.get(self._u("/api/room/screen/shot.jpg"), timeout=self.cfg.timeout_s)
        if r.status_code != 200:
            raise NekoError(f"neko screenshot failed: {r.status_code} {r.text[:200]}")
        out_path.write_bytes(r.content)
        return out_path

    def wait_ready(self, timeout_s: float = 30.0, poll_s: float = 0.5) -> None:
        t0 = time.time()
        last_err: Optional[str] = None
        while time.time() - t0 < timeout_s:
            try:
                if self.health():
                    return
                last_err = "health != 200"
            except Exception as e:
                last_err = repr(e)
            time.sleep(poll_s)
        raise NekoError(f"neko not ready within {timeout_s}s ({last_err})")

    # ---- Compatibility methods (mapped from tspec actions) ----

    def open_app(self) -> Dict[str, Any]:
        self.wait_ready(timeout_s=self.cfg.timeout_s)
        self.login()
        self.request_control()
        return {
            "neko_url": self.cfg.url,
            "implicit_control": self.cfg.implicit_control,
        }

    def close_app(self) -> None:
        # Best effort
        try:
            self.release_control()
        finally:
            self.session.close()
```

---

### B) backend 選択に `neko` を追加する（例：`src/tspec/actions_ui.py`）

既存がだいたいこういう “driver factory” になっているはずなので、そこに追加します。

```python
# 既存 imports に追加
from .ui.neko_driver import NekoUIDriver, NekoConfig
```

driver factory の分岐に：

```python
elif backend == "neko":
    cfg = NekoConfig(
        url=ctx.env("TSPEC_NEKO_URL", required=True),
        user=ctx.env("TSPEC_NEKO_USER", default=None),
        password=ctx.env("TSPEC_NEKO_PASSWORD", default=None),
        token=ctx.env("TSPEC_NEKO_TOKEN", default=None),
        implicit_control=ctx.env_bool("TSPEC_NEKO_IMPLICIT_CONTROL", default=False),
        timeout_s=float(ctx.env("TSPEC_NEKO_TIMEOUT_S", default="30")),
    )
    return NekoUIDriver(cfg)
```

※ `ctx.env()` / `env_bool()` はあなたの既存実装に合わせて置換してください（なければ単純に `os.getenv` でOK）。

---

### C) CLI オプション追加（例：`src/tspec/cli.py` の `run` コマンド）

`--neko-url` などを追加して、実行時に `TSPEC_NEKO_*` に流し込むか、RunContext に直接入れてください。

最小は「環境変数で渡す」でも運用できます：

PowerShell:

```powershell
$env:TSPEC_NEKO_URL="http://127.0.0.1:8080"
$env:TSPEC_NEKO_USER="guest"
$env:TSPEC_NEKO_PASSWORD="neko"
tspec run examples/neko_smoke.tspec.md --backend neko --report out/neko.json
```

---

### D) `pyproject.toml` の extras 追加

`[project.optional-dependencies]` に追加：

```toml
neko = ["requests>=2.31"]
```

※ すでに `requests` を通常依存で入れているなら `neko = []` でもOK。

---

## サンプル tspec（n.eko の疎通＋証跡取得）

`examples/neko_smoke.tspec.md`

````md
# n.eko smoke (screenshot evidence)

```tspec
spec: 0.1.0
cases:
  - id: NEKO-001
    title: "n.eko health/login/control + screenshot"
    steps:
      - do: ui.open_app
        with:
          # backend=neko の場合、ここは “ログイン/操作権” の開始として扱う
          # 実値は環境変数 TSPEC_NEKO_* から渡す運用推奨
          note: "connect to neko"

      - do: ui.screenshot
        with:
          path: artifacts/neko/NEKO-001__after_open.jpg

      - do: ui.close_app
````

````

---

## 環境構築マニュアル（tspec形式で管理）—`manuals/neko_setup.tspec.md`

「編集可能」「ヘルプから表示できる」「tspec形式に対応」を踏襲して、既存の manual 機能に追加する想定です。

```md
# n.eko setup (Docker)

```tspec
spec: 0.1.0
manual:
  id: MANUAL-NEKO-SETUP
  title: "n.eko (m1k1o/neko) セットアップ手順"
  sections:
    - title: "前提"
      body: |
        - Docker が必要です
        - WebRTC 用に UDP ポート範囲を開けます
        - 例ではローカル(127.0.0.1)前提

    - title: "起動（Docker run）"
      body: |
        公式ドキュメントでは Docker が推奨です。:contentReference[oaicite:9]{index=9}
        例（Firefoxイメージ）:

          docker run -d --rm ^
            -p 8080:8080 ^
            -p 56000-56100:56000-56100/udp ^
            -e NEKO_WEBRTC_EPR=56000-56100 ^
            -e NEKO_WEBRTC_NAT1TO1=127.0.0.1 ^
            -e NEKO_MEMBER_MULTIUSER_USER_PASSWORD=neko ^
            -e NEKO_MEMBER_MULTIUSER_ADMIN_PASSWORD=admin ^
            ghcr.io/m1k1o/neko/firefox:latest

        起動後:
          http://127.0.0.1:8080

    - title: "tspec-runner からの利用（backend=neko）"
      body: |
        まず疎通確認:
          - GET /health が 200 :contentReference[oaicite:10]{index=10}

        PowerShell:
          $env:TSPEC_NEKO_URL="http://127.0.0.1:8080"
          $env:TSPEC_NEKO_USER="guest"
          $env:TSPEC_NEKO_PASSWORD="neko"
          tspec run examples/neko_smoke.tspec.md --backend neko --report out/neko.json

        取得スクショ:
          - GET /api/room/screen/shot.jpg :contentReference[oaicite:11]{index=11}
````

```

---

## 重要：入力（クリック/タイプ）を n.eko に通したい件
n.eko は WebRTC / WebSocket / DataChannel を併用する設計で、**入力イベントは “同じ接続上で送る”** が基本です。:contentReference[oaicite:12]{index=12}  
なので、**n.eko を完全自動操作**したいなら次のどちらかになります：

1. **公式の入力 API（REST or WS）の仕様を確実に特定して実装**  
2. **n.eko のクライアント互換（WebSocket + DataChannel）**を実装（最強だが工数も最強）

今回の追加は 1 の前段として「n.eko を “テスト実行環境 + 証跡収集装置” として使える状態」を先に固めます。  
次のバージョンで、入力イベント仕様が確定したら `ui.click/ui.type` を backend=neko にも実装します。

---

## 次にあなたにやってほしい最短手順
1) 上記ファイルを追加して、factory/CLI/pyproject を更新  
2) `uv pip install -e ".[dev,neko]"`  
3) `docker run ...` で n.eko 起動  
4) `examples/neko_smoke.tspec.md` を `--backend neko` で実行

---

必要なら、あなたの **今の tspec-runner の ZIP（最新）**をこのチャットに再アップしてくれれば、こちらで差分を吸収した「統合済み一式」を **その構造に完全一致**させた形で出します（ファイル名/関数名をあなたの現実に合わせてズレなく揃えます）。
::contentReference[oaicite:13]{index=13}
```

[1]: https://neko.m1k1o.net/docs/v3/api/healthcheck?utm_source=chatgpt.com "Health Check | n.eko"
[2]: https://neko.m1k1o.net/docs/v3/api/login?utm_source=chatgpt.com "User Login | n.eko"
[3]: https://neko.m1k1o.net/docs/v3/api/screen-shot-image?utm_source=chatgpt.com "Get Screenshot Image | n.eko"
[4]: https://neko.m1k1o.net/docs/v3/api/control-request?utm_source=chatgpt.com "Request Control | n.eko"
[5]: https://neko.m1k1o.net/docs/v3/api/control-release?utm_source=chatgpt.com "Release Control | n.eko"
[6]: https://neko.m1k1o.net/docs/v3/api/control-reset?utm_source=chatgpt.com "Reset Control | n.eko"
[7]: https://neko.m1k1o.net/docs/v3/api?utm_source=chatgpt.com "Neko API Reference | n.eko"
[8]: https://neko.m1k1o.net/docs/v3/api/stats?utm_source=chatgpt.com "Get Stats | n.eko"
