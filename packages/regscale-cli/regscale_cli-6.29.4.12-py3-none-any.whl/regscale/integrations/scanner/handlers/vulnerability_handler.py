#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Vulnerability Handler Module.

This module contains the VulnerabilityHandler class that extracts vulnerability-related
functionality from ScannerIntegration to support handler-based delegation pattern.
"""
from __future__ import annotations

import ipaddress
import logging
import time
from typing import Any, Callable, Dict, List, Optional, Set, TYPE_CHECKING

from rich.progress import Progress

from regscale.core.app.utils.app_utils import get_current_datetime
from regscale.integrations.scanner.models import IntegrationFinding
from regscale.integrations.value_mappers import normalize_severity_to_vulnerability, normalize_status_to_issue_status
from regscale.models import regscale_models
from regscale.models.regscale_models.batch_options import VulnerabilityBatchOptions

if TYPE_CHECKING:
    from regscale.integrations.scanner_integration import ScannerIntegration

logger = logging.getLogger("regscale")


class VulnerabilityHandler:
    """
    Handler class for vulnerability-related operations.

    This class encapsulates all vulnerability creation, conversion, and batch processing
    logic to support a handler-based delegation pattern in ScannerIntegration.

    :param int plan_id: The ID of the security plan
    :param str parent_module: The parent module for vulnerabilities (e.g., "securityplans")
    :param str scanner_title: The title of the scanner integration
    :param Optional[Progress] progress: Optional progress context for tracking operations
    :param int batch_size: Batch size for vulnerability operations, defaults to 1000
    """

    # Default field length limits to prevent database errors
    DEFAULT_MAX_FIELD_LENGTH = 450
    IP_ADDRESS_MAX_LENGTH = 45
    DESCRIPTION_MAX_LENGTH = 4000
    FIX_STATUS_MAX_LENGTH = 100
    DNS_MAX_LENGTH = 255

    def __init__(
        self,
        plan_id: int,
        parent_module: str = "securityplans",
        scanner_title: str = "Scanner Integration",
        progress: Optional[Progress] = None,
        batch_size: int = 1000,
        suppress_asset_not_found_errors: bool = False,
    ):
        """
        Initialize the VulnerabilityHandler.

        :param int plan_id: The ID of the security plan
        :param str parent_module: The parent module for vulnerabilities
        :param str scanner_title: The title of the scanner integration
        :param Optional[Progress] progress: Optional progress context for tracking operations
        :param int batch_size: Batch size for vulnerability operations
        :param bool suppress_asset_not_found_errors: Whether to suppress asset not found warnings
        """
        self.plan_id = plan_id
        self.parent_module = parent_module
        self.scanner_title = scanner_title
        self.progress = progress
        self.batch_size = batch_size
        self.suppress_asset_not_found_errors = suppress_asset_not_found_errors
        self.scan_date: Optional[str] = None

    def create_vulnerability(
        self,
        finding: IntegrationFinding,
        asset: Optional[regscale_models.Asset] = None,
        scan_history: Optional[regscale_models.ScanHistory] = None,
    ) -> Optional[regscale_models.Vulnerability]:
        """
        Create a vulnerability from a finding.

        This method handles the full lifecycle of vulnerability creation including
        validation, conversion, and persistence.

        :param IntegrationFinding finding: The integration finding to convert
        :param Optional[regscale_models.Asset] asset: The associated asset (optional with server-side discovery)
        :param Optional[regscale_models.ScanHistory] scan_history: The scan history for tracking
        :return: The created vulnerability or None if creation failed
        :rtype: Optional[regscale_models.Vulnerability]
        """
        # Validate required fields
        if not self._has_required_vulnerability_fields(finding):
            return None

        # Create vulnerability with retry logic
        return self._create_vulnerability_with_retry(finding, asset, scan_history)

    def convert_finding_to_vulnerability(self, finding: IntegrationFinding) -> Optional[regscale_models.Vulnerability]:
        """
        Convert an IntegrationFinding to a RegScale Vulnerability object without making API calls.

        The backend handles asset discovery via enableAssetDiscovery option, so we don't
        need to look up assets client-side. We just pass the IP/DNS info and let the
        server match or create assets.

        This is a convenience wrapper around build_vulnerability_object() for batch processing.

        :param IntegrationFinding finding: The finding to convert
        :return: Vulnerability object ready for batch processing, or None if conversion fails
        :rtype: Optional[regscale_models.Vulnerability]
        """
        try:
            return self.build_vulnerability_object(finding, asset=None, scan_history=None)
        except Exception as exc:
            logger.error("Error converting finding to vulnerability: %s - %s", finding.external_id, exc)
            return None

    def batch_create_vulnerabilities(
        self,
        vulnerabilities: List[regscale_models.Vulnerability],
        options: Optional[VulnerabilityBatchOptions] = None,
    ) -> List[regscale_models.Vulnerability]:
        """
        Batch create or update vulnerabilities using the streaming endpoint.

        This method leverages the server-side asset discovery and POAM creation
        capabilities for efficient bulk processing via streamBatchCreateOrUpdate.

        :param List[regscale_models.Vulnerability] vulnerabilities: List of vulnerabilities to create/update
        :param Optional[VulnerabilityBatchOptions] options: Server-side processing options
        :return: List of created/updated vulnerabilities
        :rtype: List[regscale_models.Vulnerability]
        """
        if not vulnerabilities:
            logger.debug("No vulnerabilities to batch create")
            return []

        # Build default options if not provided
        batch_options = options or self._build_default_batch_options()

        logger.info("Batch creating/updating %d vulnerabilities...", len(vulnerabilities))
        try:
            results = regscale_models.Vulnerability.batch_create_or_update(
                items=vulnerabilities,
                progress_context=self.progress,
                batch_size=self.batch_size,
                options=batch_options,
            )
            logger.info("Successfully processed %d vulnerabilities in batch", len(results))
            return results
        except Exception as exc:
            logger.error("Error in batch vulnerability creation: %s", exc)
            return []

    def update_vulnerability(self, vuln: regscale_models.Vulnerability) -> Optional[regscale_models.Vulnerability]:
        """
        Update an existing vulnerability.

        :param regscale_models.Vulnerability vuln: The vulnerability to update
        :return: The updated vulnerability or None if update failed
        :rtype: Optional[regscale_models.Vulnerability]
        """
        try:
            updated = vuln.save()
            if updated:
                logger.debug("Successfully updated vulnerability %d", vuln.id)
            return updated
        except Exception as exc:
            logger.error("Error updating vulnerability %d: %s", vuln.id, exc)
            return None

    def build_vulnerability_object(
        self,
        finding: IntegrationFinding,
        asset: Optional[regscale_models.Asset],
        scan_history: Optional[regscale_models.ScanHistory],
    ) -> regscale_models.Vulnerability:
        """
        Build a vulnerability object from finding data.

        This method creates a fully populated Vulnerability model instance
        with all available data from the finding and optional asset.

        :param IntegrationFinding finding: The integration finding
        :param Optional[regscale_models.Asset] asset: The associated asset
        :param Optional[regscale_models.ScanHistory] scan_history: The scan history
        :return: A Vulnerability object ready for persistence
        :rtype: regscale_models.Vulnerability
        """
        # Get mapped values - prefer finding data, fall back to asset if available
        severity = self._get_mapped_severity(finding)
        ip_address = self._get_ip_address(finding, asset)
        dns = self._get_dns(finding, asset)
        operating_system = self._get_operating_system(finding, asset)

        # Normalize status using the robust mapper
        normalized_status = normalize_status_to_issue_status(
            status=finding.status, default=regscale_models.IssueStatus.Open, source=self.scanner_title
        )

        return regscale_models.Vulnerability(
            title=self._truncate_field(finding.title, field_name="title"),
            cve=self._truncate_field(finding.cve, field_name="cve"),
            vprScore=self._get_vpr_score(finding),
            cvsSv3BaseScore=self._get_cvss_v3_score(finding),
            cvsSv2BaseScore=finding.cvss_v2_score,
            cvsSv3BaseVector=self._truncate_field(finding.cvss_v3_vector, field_name="cvsSv3BaseVector"),
            cvsSv2BaseVector=self._truncate_field(finding.cvss_v2_vector, field_name="cvsSv2BaseVector"),
            scanId=scan_history.id if scan_history else None,
            severity=severity,
            description=self._truncate_field(
                finding.description, max_length=self.DESCRIPTION_MAX_LENGTH, field_name="description"
            ),
            dateLastUpdated=finding.date_last_updated,
            parentId=self.plan_id,
            parentModule=self.parent_module,
            dns=self._truncate_field(dns, max_length=self.DNS_MAX_LENGTH, field_name="dns"),
            status=normalized_status,
            ipAddress=self._truncate_field(ip_address, max_length=self.IP_ADDRESS_MAX_LENGTH, field_name="ipAddress"),
            firstSeen=finding.first_seen,
            lastSeen=finding.last_seen,
            plugInName=self._truncate_field(finding.cve or finding.plugin_name, field_name="plugInName"),
            plugInId=finding.plugin_id or finding.external_id,
            exploitAvailable=None,
            plugInText=finding.plugin_text or finding.observations,  # Unlimited length - TEXT field
            port=getattr(finding, "port", None),
            protocol=self._truncate_field(getattr(finding, "protocol", None), field_name="protocol"),
            operatingSystem=self._truncate_field(operating_system, field_name="operatingSystem"),
            fixedVersions=self._truncate_field(finding.fixed_versions, field_name="fixedVersions"),
            buildVersion=self._truncate_field(finding.build_version, field_name="buildVersion"),
            fixStatus=self._truncate_field(
                finding.fix_status, max_length=self.FIX_STATUS_MAX_LENGTH, field_name="fixStatus"
            ),
            installedVersions=self._truncate_field(finding.installed_versions, field_name="installedVersions"),
            affectedOS=self._truncate_field(finding.affected_os, field_name="affectedOS"),
            packagePath=self._truncate_field(finding.package_path, field_name="packagePath"),
            imageDigest=self._truncate_field(finding.image_digest, field_name="imageDigest"),
            affectedPackages=self._truncate_field(finding.affected_packages, field_name="affectedPackages"),
        )

    def has_required_vulnerability_fields(self, finding: IntegrationFinding) -> bool:
        """
        Check if a finding has the required fields for vulnerability creation.

        :param IntegrationFinding finding: The finding to check
        :return: True if required fields are present, False otherwise
        :rtype: bool
        """
        return self._has_required_vulnerability_fields(finding)

    def is_finding_valid_for_vulnerability(self, finding: IntegrationFinding) -> bool:
        """
        Check if a finding is valid for vulnerability creation.

        :param IntegrationFinding finding: The finding to validate
        :return: True if valid, False otherwise
        :rtype: bool
        """
        if not (finding.plugin_name or finding.cve):
            logger.warning("No Plugin Name or CVE found for finding %s", finding.title)
            return False
        return True

    # Private helper methods

    def _has_required_vulnerability_fields(self, finding: IntegrationFinding) -> bool:
        """Check if finding has required fields (plugin_name or cve)."""
        plugin_name = getattr(finding, "plugin_name", None)
        cve = getattr(finding, "cve", None)

        if not plugin_name and not cve:
            logger.warning("No Plugin Name or CVE found for finding %s", finding.title)
            logger.debug("Finding plugin_name: %s, cve: %s", plugin_name, cve)
            return False

        logger.debug("Finding plugin_name: %s, cve: %s", plugin_name, cve)
        return True

    def _create_vulnerability_with_retry(
        self,
        finding: IntegrationFinding,
        asset: Optional[regscale_models.Asset],
        scan_history: Optional[regscale_models.ScanHistory],
    ) -> Optional[regscale_models.Vulnerability]:
        """Create vulnerability with retry logic."""
        max_retries = 3
        retry_delay = 2  # seconds

        for attempt in range(max_retries):
            vuln = self._try_create_vulnerability(finding, asset, scan_history, attempt, max_retries, retry_delay)
            if vuln is not None:
                return vuln

            if attempt < max_retries - 1:
                time.sleep(retry_delay)
                retry_delay *= 2  # Exponential backoff

        return None

    def _try_create_vulnerability(
        self,
        finding: IntegrationFinding,
        asset: Optional[regscale_models.Asset],
        scan_history: Optional[regscale_models.ScanHistory],
        attempt: int,
        max_retries: int,
        retry_delay: int,
    ) -> Optional[regscale_models.Vulnerability]:
        """Try to create vulnerability for a single attempt."""
        try:
            logger.debug("Creating vulnerability for finding %s (attempt %d)", finding.external_id, attempt + 1)
            vulnerability = self.build_vulnerability_object(finding, asset, scan_history)

            # Save vulnerability using bulk mode for better performance
            logger.debug("Calling create_or_update (bulk mode) for vulnerability with title: %s", vulnerability.title)
            vulnerability = vulnerability.create_or_update(bulk_create=True, bulk_update=True)
            logger.debug("Vulnerability queued for bulk save with temporary ID: %d", vulnerability.id)

            return vulnerability

        except Exception as e:
            self._handle_vulnerability_creation_error(e, finding, attempt, max_retries, retry_delay)
            return None

    def _handle_vulnerability_creation_error(
        self, error: Exception, finding: IntegrationFinding, attempt: int, max_retries: int, retry_delay: int
    ) -> None:
        """Handle error during vulnerability creation."""
        if attempt < max_retries - 1:
            logger.warning(
                "Vulnerability creation failed for finding %s (attempt %d/%d): %s. Retrying in %d seconds...",
                finding.external_id,
                attempt + 1,
                max_retries,
                error,
                retry_delay,
            )
        else:
            logger.error(
                "Failed to create vulnerability for finding %s after %d attempts: %s",
                finding.external_id,
                max_retries,
                error,
            )

    def _build_default_batch_options(self) -> VulnerabilityBatchOptions:
        """Build default batch options for vulnerability processing."""
        return VulnerabilityBatchOptions(
            source=self.scanner_title,
            uniqueKeys=["plugInId", "parentId", "parentModule"],
            enableMopUp=True,
            mopUpStatus="Closed",
            enableAssetDiscovery=True,
            suppressAssetNotFoundWarnings=self.suppress_asset_not_found_errors,
            poamCreation=True,
            parentId=self.plan_id,
            parentModule=self.parent_module,
        )

    def _extract_ip_address(self, finding: IntegrationFinding) -> Optional[str]:
        """Extract IP address from finding."""
        ip_address = getattr(finding, "ip_address", None)

        # If no explicit IP address, check if asset_identifier is an IP
        if not ip_address and finding.asset_identifier:
            try:
                # Try to parse as IP address
                ipaddress.ip_address(finding.asset_identifier)
                ip_address = finding.asset_identifier
            except ValueError:
                pass  # Not an IP address

        return ip_address

    def _extract_dns_name(self, finding: IntegrationFinding, ip_address: Optional[str]) -> Optional[str]:
        """Extract DNS name from finding."""
        dns_name = getattr(finding, "dns", None) or getattr(finding, "fqdn", None)

        # If asset_identifier is not an IP, treat as DNS name
        if not dns_name and finding.asset_identifier and not ip_address:
            try:
                ipaddress.ip_address(finding.asset_identifier)
            except ValueError:
                dns_name = finding.asset_identifier

        return dns_name

    def _get_mapped_severity(self, finding: IntegrationFinding) -> regscale_models.VulnerabilitySeverity:
        """
        Get mapped severity for the finding using robust normalization.

        :param IntegrationFinding finding: The finding with severity to map
        :return: Normalized VulnerabilitySeverity enum value
        :rtype: regscale_models.VulnerabilitySeverity
        """
        logger.debug("Finding severity: '%s' (type: %s)", finding.severity, type(finding.severity))

        mapped_severity = normalize_severity_to_vulnerability(
            severity=finding.severity,
            default=regscale_models.VulnerabilitySeverity.Low,
            source=self.scanner_title,
        )

        logger.debug("Mapped severity: %s", mapped_severity)
        return mapped_severity

    def _get_ip_address(self, finding: IntegrationFinding, asset: Optional[regscale_models.Asset]) -> str:
        """Get IP address from finding or asset."""
        if finding.ip_address:
            return finding.ip_address
        # Fall back to extraction logic if no explicit IP and no asset
        extracted_ip = self._extract_ip_address(finding)
        if extracted_ip:
            return extracted_ip
        if asset and hasattr(asset, "ipAddress") and asset.ipAddress:
            return asset.ipAddress
        return ""

    def _get_dns(self, finding: IntegrationFinding, asset: Optional[regscale_models.Asset] = None) -> str:
        """Get DNS from finding or asset."""
        # Prefer finding data (from scanner) over asset lookup
        if finding.dns:
            return finding.dns
        # Check for fqdn attribute (used by some scanners)
        fqdn = getattr(finding, "fqdn", None)
        if fqdn:
            return fqdn
        # Fall back to extraction logic
        ip_address = self._extract_ip_address(finding)
        extracted_dns = self._extract_dns_name(finding, ip_address)
        if extracted_dns:
            return extracted_dns
        if finding.asset_identifier:
            return finding.asset_identifier
        if asset and hasattr(asset, "fqdn") and asset.fqdn:
            return asset.fqdn
        return "unknown"

    def _get_operating_system(
        self, finding: IntegrationFinding, asset: Optional[regscale_models.Asset]
    ) -> Optional[str]:
        """Get operating system from finding or asset."""
        # Check finding first (some scanners provide OS info)
        os_value = getattr(finding, "operating_system", None)
        if os_value:
            return os_value
        if asset and hasattr(asset, "operatingSystem"):
            return asset.operatingSystem
        return None

    def _get_vpr_score(self, finding: IntegrationFinding) -> Optional[float]:
        """Get VPR score from finding."""
        if hasattr(finding, "vpr_score"):
            return finding.vpr_score
        return None

    def _get_cvss_v3_score(self, finding: IntegrationFinding) -> Optional[float]:
        """Get CVSS v3 score from finding."""
        return finding.cvss_v3_base_score or finding.cvss_v3_score or finding.cvss_score

    def _truncate_field(self, value: Optional[str], max_length: int = 450, field_name: str = "") -> Optional[str]:
        """
        Truncate a field to the maximum allowed length to prevent database errors.

        :param Optional[str] value: The value to truncate
        :param int max_length: Maximum allowed length, defaults to 450
        :param str field_name: Name of the field being truncated (for logging)
        :return: Truncated value or None
        :rtype: Optional[str]
        """
        if not value:
            return value

        if len(value) > max_length:
            truncated = value[:max_length]
            logger.debug(
                "Truncated %s field from %d to %d characters for value: %s...",
                field_name or "field",
                len(value),
                max_length,
                truncated[:100],
            )
            return truncated
        return value
