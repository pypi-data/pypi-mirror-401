#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Model for Vulnerability in the application"""
import logging
from enum import Enum
from typing import List, Optional, Union
from urllib.parse import urljoin
from warnings import warn

from pydantic import ConfigDict, Field, field_validator, model_validator
from requests import Response

from regscale.core.app.api import Api
from regscale.core.app.application import Application
from regscale.core.app.utils.app_utils import get_current_datetime
from regscale.models import regscale_models
from regscale.models.regscale_models.issue import IssueStatus
from regscale.models.regscale_models.regscale_model import RegScaleModel

logger = logging.getLogger("regscale")


def deprecated(message):
    def decorator(func):
        def wrapper(*args, **kwargs):
            warn(f"{func.__name__} is deprecated. {message}", DeprecationWarning, stacklevel=2)
            return func(*args, **kwargs)

        return wrapper

    return decorator


class VulnerabilitySeverity(str, Enum):
    """Vulnerability Severity"""

    Low = "Low"
    Medium = "Medium"
    High = "High"
    Critical = "Critical"
    Informational = "Informational"


class VulnerabilityStatus(str, Enum):
    """Vulnerability Status"""

    Open = "Open"
    Closed = "Closed"


class Vulnerability(RegScaleModel):
    """Vulnerability Model"""

    _module_slug = "vulnerability"
    _plural_name = "vulnerabilities"
    _unique_fields = [
        ["plugInName", "plugInId", "parentId", "parentModule"],
    ]

    id: int = 0
    createdById: str = Field(default_factory=RegScaleModel.get_user_id)
    dateCreated: str = Field(default_factory=get_current_datetime)
    lastUpdatedById: str = Field(default_factory=RegScaleModel.get_user_id)
    dateLastUpdated: str = Field(default_factory=get_current_datetime)
    uuid: Optional[str] = None
    scanId: Optional[int] = None
    parentId: Optional[int] = None
    parentModule: Optional[str] = None
    lastSeen: Optional[str] = None
    firstSeen: Optional[str] = None
    daysOpen: Optional[int] = None
    dns: Optional[str] = ""
    ipAddress: Optional[str] = ""
    mitigated: Optional[bool] = None
    operatingSystem: Optional[str] = None
    port: Optional[Union[str, int]] = None
    protocol: Optional[str] = None
    severity: Optional[Union[str, VulnerabilitySeverity]] = None
    plugInName: Optional[str] = None
    plugInId: Optional[Union[int, str]] = None
    cve: Optional[str] = Field(default=None, max_length=200)
    vprScore: Optional[Union[int, float]] = None
    exploitAvailable: Optional[bool] = None
    title: Optional[str] = None
    cvsSv3BaseScore: Optional[Union[float, int]] = None
    description: Optional[str] = None
    plugInText: Optional[str] = None
    tenantsId: int = Field(default_factory=RegScaleModel.get_tenant_id)
    isPublic: bool = Field(default=False)
    dateClosed: Optional[str] = None
    status: Optional[Union[str, IssueStatus]] = Field(default_factory=lambda: IssueStatus.Open)
    buildVersion: Optional[str] = None
    cvsSv3BaseVector: Optional[str] = None
    cvsSv2BaseVector: Optional[str] = None
    cvsSv2BaseScore: Optional[Union[float, int]] = None
    affectedOS: Optional[str] = None
    packagePath: Optional[str] = None
    imageDigest: Optional[str] = None
    affectedPackages: Optional[str] = None
    installedVersions: Optional[str] = None
    fixedVersions: Optional[str] = None
    fixStatus: Optional[str] = None

    @field_validator("plugInId")
    def validate_regscale_version_and_plugin_id_type(cls, v: Union[int, str]) -> Union[int, str, None]:
        """
        Validate the RegScale version and if plugInId should be a string or an integer, >= 6.16 is a string

        :param int v: pluginId value
        :return: The correct type for plugInId depending on the RegScale version, None if unable to determine
        :rtype: Union[int, str, None]
        """
        from packaging.version import Version

        try:
            regscale_version = cls._get_api_handler().regscale_version

            if len(regscale_version) >= 10 or Version(regscale_version) >= Version("6.16.0.0"):
                return str(v) if v else None
            else:
                if isinstance(v, str):
                    return int(v) if v.isdigit() else None
                elif isinstance(v, int):
                    return v
                return None
        except Exception as e:
            logger.debug("Unable to determine RegScale version or pluginId type: %s", str(e))
            return None

    @field_validator("severity")
    def validate_and_normalize_severity(
        cls, v: Union[str, VulnerabilitySeverity, None]
    ) -> Optional[VulnerabilitySeverity]:
        """
        Validate and normalize severity values to VulnerabilitySeverity enum.

        Automatically converts various severity formats (e.g., "I - High - Significant Deficiency")
        to the proper VulnerabilitySeverity enum value.

        :param Union[str, VulnerabilitySeverity, None] v: The severity value to validate
        :return: Normalized VulnerabilitySeverity enum value or None
        :rtype: Optional[VulnerabilitySeverity]
        """
        if v is None:
            return None

        # If already the correct enum type, return it
        if isinstance(v, VulnerabilitySeverity):
            return v

        # Import the normalizer here to avoid circular imports
        from regscale.integrations.value_mappers import normalize_severity_to_vulnerability

        # Normalize the string to a VulnerabilitySeverity enum
        normalized = normalize_severity_to_vulnerability(v, source="Vulnerability Model")

        return normalized

    @model_validator(mode="before")
    @classmethod
    def move_non_cve_to_plugin_fields(cls, data: dict) -> dict:
        """
        Validate CVE field and move non-CVE identifiers to plugInName/plugInId.

        If CVE field contains a non-CVE identifier (RHSA, ALAS, etc.):
        1. Move it to plugInName if plugInName is empty
        2. Move it to plugInId if plugInId is empty
        3. Set CVE to None

        :param data: Model data dictionary
        :return: Modified data dictionary
        :rtype: dict
        """
        from regscale.utils.cve_utils import validate_single_cve

        if not isinstance(data, dict):
            return data

        cve_value = data.get("cve")
        if not cve_value:
            return data

        # Check if it's a valid CVE format
        validated_cve = validate_single_cve(cve_value)

        if validated_cve:
            # Valid CVE - keep it
            data["cve"] = validated_cve
        else:
            # Not a valid CVE - move to plugInName or plugInId
            if not data.get("plugInName"):
                data["plugInName"] = cve_value
                logger.debug("Moved non-CVE identifier '%s' to plugInName", cve_value)
            elif not data.get("plugInId"):
                data["plugInId"] = cve_value
                logger.debug("Moved non-CVE identifier '%s' to plugInId", cve_value)
            else:
                logger.debug("Discarded non-CVE identifier '%s' (plugInName and plugInId already set)", cve_value)
            data["cve"] = None

        return data

    def __eq__(self, other: "Vulnerability") -> bool:
        """
        Check if two Vulnerability objects are equal is needed for comparison operations in flat file importer

        :param Vulnerability other: the other Vulnerability object to compare
        :return: True if the two objects are equal, False otherwise
        :rtype: bool
        """
        if not isinstance(other, Vulnerability):
            return False
        return (
            self.plugInName == other.plugInName
            and self.plugInId == other.plugInId
            and self.parentId == other.parentId
            and self.parentModule == other.parentModule
            and self.ipAddress == other.ipAddress
            and self.dns == other.dns
        )

    def __init__(self, *args, **data):
        # Map snake_case to camelCase before initialization
        field_mappings = {
            "scan_id": "scanId",
            "parent_id": "parentId",
            "parent_module": "parentModule",
            "last_seen": "lastSeen",
            "first_seen": "firstSeen",
            "days_open": "daysOpen",
            "ip_address": "ipAddress",
            "operating_system": "operatingSystem",
            "plugin_name": "plugInName",
            "plugin_id": "plugInId",
            "vpr_score": "vprScore",
            "exploit_available": "exploitAvailable",
            "cvss_v3_base_score": "cvsSv3BaseScore",
            "plugin_text": "plugInText",
            "tenants_id": "tenantsId",
            "is_public": "isPublic",
            "date_closed": "dateClosed",
            "build_version": "buildVersion",
            "cvss_v3_vector": "cvsSv3BaseVector",
            "cvss_v2_score": "cvsSv2BaseScore",
            "cvss_v2_vector": "cvsSv2BaseVector",
            "affected_os": "affectedOS",
            "image_digest": "imageDigest",
            "affected_packages": "affectedPackages",
            "installed_versions": "installedVersions",
            "fixed_versions": "fixedVersions",
            "fix_status": "fixStatus",
        }

        # Convert snake_case keys to camelCase
        for snake_key, camel_key in field_mappings.items():
            if snake_key in data:
                data[camel_key] = data.pop(snake_key)

        super().__init__(*args, **data)

    @staticmethod
    def _get_additional_endpoints() -> ConfigDict:
        """
        Get additional endpoints for the Vulnerability model, using {model_slug} as a placeholder for the model slug.

        :return: A dictionary of additional endpoints
        :rtype: ConfigDict
        """
        return ConfigDict(  # type: ignore
            get_count="/api/{model_slug}/getCount",  # type: ignore
            batch_create="/api/{model_slug}/batchCreate",  # type: ignore
            # Note: Standard batchCreateOrUpdate returns 405 for vulnerabilities.
            # Use streaming endpoint instead which handles create/update server-side.
            batch_create_or_update="/api/{model_slug}/streamBatchCreateOrUpdate",  # type: ignore
            find_by_guid="/api/{model_slug}/findByGUID/{strGUID}",  # type: ignore
            drilldown="/api/{model_slug}/drilldown/{parentId}/{scanId}/{strSeverity}/{intPage}/"  # type: ignore
            "{intPageSize}",
            lookup_cve="/api/{model_slug}/lookupCVE/{strCVE}",  # type: ignore
            get="/api/{model_slug}/find/{id}",  # type: ignore
        )

    @staticmethod
    def determine_cvss3_severity_text(cvss_v3_base_score: float) -> str:
        """
        Determine CVSS3 Severity Text from CVSS3 Base Score

        :param float cvss_v3_base_score: CVSS3 Base Score
        :return: CVSS3 Severity Text
        :rtype: str
        """
        results = "low"
        if 4.0 <= cvss_v3_base_score <= 6.9:
            results = "medium"
        elif 7.0 <= cvss_v3_base_score <= 8.9:
            results = "high"
        elif cvss_v3_base_score > 8.9:
            results = "critical"
        return results

    @staticmethod
    @deprecated("Use Vulnerability.get_all_by_parent() instead")
    def find_vulns_by_scan(app: Application, scan_id: int) -> List["Vulnerability"]:  # noqa: F841
        """
        Find Vulnerabilities by Scan ID

        :param Application app: Application instance
        :param int scan_id: Scan ID
        :return: List of Vulnerabilities
        :rtype: List[Vulnerability]
        """
        return Vulnerability.get_all_by_parent(parent_id=scan_id, parent_module=regscale_models.Scan.get_module_slug())

    @classmethod
    @deprecated("Use Vulnerability.create() instead")
    def post_vulnerability(cls, vulnerability: "Vulnerability") -> Optional["Vulnerability"]:
        """
        Post a vulnerability to the API

        :param Vulnerability vulnerability: The vulnerability to be posted
        :return: The response from the API as a dictionary
        :rtype: Optional["Vulnerability"]
        """
        return vulnerability.create()

    @classmethod
    @deprecated(
        "Use Vulnerability.create() for individual vulnerabilities or Vulnerability.batch_create() for "
        "multiple vulnerabilities"
    )
    def post_vulnerabilities(
        cls,
        app: Application,  # noqa: F841
        vulnerabilities: List["Vulnerability"],
        output_to_console: Optional[bool] = True,
    ) -> List[Response]:
        """
        Insert new vulnerabilities into RegScale

        :param Application app: Application object
        :param List[Vulnerability] vulnerabilities: List of Vulnerability objects
        :param Optional[bool] output_to_console: Whether to output to console, defaults to True
        :return: A list of Responses
        :rtype List[Response]
        """
        responses = []

        def batch_post(url: str, dat: list[dict]) -> Response:
            """
            Simple wrapper to post a list of JSON data to a URL

            :param str url: URL to post to
            :param list[dict] dat: A list of JSON data to post
            :return: Response object
            :rtype: Response
            """
            return api.post(url=url, json=dat)

        api = Api()
        if output_to_console and vulnerabilities:
            api.logger.info("Creating %i new vulnerabilities in RegScale...", len(vulnerabilities))
        # Create batches of vulnerabilities to post
        batch_size = 500
        batches = [vulnerabilities[i : i + batch_size] for i in range(0, len(vulnerabilities), batch_size)]
        for batch in batches:
            res = batch_post(
                url=urljoin(api.config["domain"], cls.get_endpoint("batch_create")),
                dat=[vuln.model_dump() for vuln in batch],
            )
            if res.ok:
                responses.extend(res.json())
        if len(responses):
            api.logger.info("Successfully created %i new vulnerabilities in RegScale", len(responses))
        return responses
