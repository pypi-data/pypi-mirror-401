"""
Tests for server-side vulnerability mapping in scanner_integration.

This tests the workflow where:
1. Vulnerabilities are created with bulk_create=True (queued with id=0)
2. Vulnerability.bulk_save() sends them to the streaming endpoint with options
3. Server creates VulnerabilityMappings automatically via enableAssetDiscovery=True
4. No local mapping creation needed
"""

from typing import Iterator, List
from unittest.mock import MagicMock, patch

from rich.progress import Progress

from regscale.core.app.utils.app_utils import get_current_datetime
from regscale.integrations.scanner_integration import (
    ScannerIntegration,
    ScannerIntegrationType,
    IntegrationAsset,
    IntegrationFinding,
)
from regscale.models import regscale_models
from tests.fixtures.test_fixture import CLITestFixture


def create_test_asset(asset_id: int = 456) -> regscale_models.Asset:
    """Helper to create a test Asset with all required fields."""
    return regscale_models.Asset(
        id=asset_id,
        name="Test Asset",
        otherTrackingNumber=f"ASSET-{asset_id:03d}",
        assetType="Server",
        assetCategory="Virtual",
        status="Active",
        parentId=1,
        parentModule="securityplans",
    )


def create_test_scan_history(scan_id: int = 789) -> regscale_models.ScanHistory:
    """Helper to create a test ScanHistory with all required fields."""
    return regscale_models.ScanHistory(
        id=scan_id,
        scanningTool="Test Scanner",
        parentId=1,
        parentModule="securityplans",
    )


class TestServerSideVulnerabilityMapping(CLITestFixture):
    """Test server-side vulnerability mapping creation functionality."""

    plan_id = 1
    tenant_id = 1

    @patch("regscale.models.regscale_models.vulnerability.Vulnerability.create_or_update")
    def test_vulnerability_creation_uses_bulk_mode(self, mock_create_or_update):
        """Test that vulnerability creation uses bulk_create=True."""

        class TestScanner(ScannerIntegration):
            title = "Test Scanner"
            asset_identifier_field = "identifier"
            type = ScannerIntegrationType.VULNERABILITY

            def fetch_assets(self, *args, **kwargs) -> Iterator[IntegrationAsset]:
                return iter([])

            def fetch_findings(self, *args, **kwargs) -> List[IntegrationFinding]:
                return []

        # Mock vulnerability with id=0 (queued for bulk save)
        mock_vuln = regscale_models.Vulnerability(
            id=0,
            plugInId="TEST-001",
            plugInName="Test Vuln",
            parentId=1,
            parentModule="securityplans",
        )
        mock_create_or_update.return_value = mock_vuln

        scanner = TestScanner(plan_id=self.plan_id, tenant_id=self.tenant_id)

        # Create test data
        asset = create_test_asset()
        scan_history = create_test_scan_history()
        finding = IntegrationFinding(
            title="Test Finding",
            external_id="FINDING-001",
            plugin_id="TEST-001",
            plugin_name="Test Plugin",
            severity="High",
            status="Open",
            control_labels=[],
            category="Vulnerability",
            description="Test vulnerability description",
            first_seen=get_current_datetime(),
            last_seen=get_current_datetime(),
        )

        # Call create_vulnerability_from_finding
        scanner.create_vulnerability_from_finding(finding, asset, scan_history)

        # Verify vulnerability was created with bulk mode
        mock_create_or_update.assert_called_once()
        call_kwargs = mock_create_or_update.call_args.kwargs
        assert call_kwargs.get("bulk_create") is True
        assert call_kwargs.get("bulk_update") is True

    @patch("regscale.models.regscale_models.vulnerability.Vulnerability.bulk_save")
    def test_batch_operations_passes_server_side_options(self, mock_bulk_save):
        """Test that _perform_batch_operations passes enableAssetDiscovery option."""
        mock_bulk_save.return_value = {"created": [], "updated": []}

        class TestScanner(ScannerIntegration):
            title = "Test Scanner"
            asset_identifier_field = "identifier"
            type = ScannerIntegrationType.VULNERABILITY

            def fetch_assets(self, *args, **kwargs) -> Iterator[IntegrationAsset]:
                return iter([])

            def fetch_findings(self, *args, **kwargs) -> List[IntegrationFinding]:
                return []

        scanner = TestScanner(plan_id=self.plan_id, tenant_id=self.tenant_id)

        # Call _perform_batch_operations
        progress = MagicMock(spec=Progress)
        scanner._perform_batch_operations(progress)

        # Verify bulk_save was called with options
        mock_bulk_save.assert_called_once()
        call_kwargs = mock_bulk_save.call_args.kwargs
        assert "options" in call_kwargs

        options = call_kwargs["options"]
        assert options.get("enableAssetDiscovery") is True
        assert options.get("suppressAssetNotFoundWarnings") is True
        assert options.get("parentId") == self.plan_id
        assert options.get("parentModule") == "securityplans"
        assert options.get("source") == "Test Scanner"

    @patch("regscale.models.regscale_models.vulnerability_mapping.VulnerabilityMapping.batch_create")
    @patch("regscale.models.regscale_models.vulnerability.Vulnerability.bulk_save")
    def test_no_local_mapping_creation_after_bulk_save(self, mock_bulk_save, mock_mapping_batch_create):
        """Test that VulnerabilityMapping.batch_create is NOT called (server handles it)."""
        mock_bulk_save.return_value = {"created": [], "updated": []}

        class TestScanner(ScannerIntegration):
            title = "Test Scanner"
            asset_identifier_field = "identifier"
            type = ScannerIntegrationType.VULNERABILITY

            def fetch_assets(self, *args, **kwargs) -> Iterator[IntegrationAsset]:
                return iter([])

            def fetch_findings(self, *args, **kwargs) -> List[IntegrationFinding]:
                return []

        scanner = TestScanner(plan_id=self.plan_id, tenant_id=self.tenant_id)

        # Perform batch operations
        progress = MagicMock(spec=Progress)
        scanner._perform_batch_operations(progress)

        # Verify local mapping creation was NOT called
        mock_mapping_batch_create.assert_not_called()


class TestVulnerabilityStreamingEndpoint(CLITestFixture):
    """Test Vulnerability model's streaming endpoint integration."""

    plan_id = 1
    tenant_id = 1

    @patch("regscale.models.regscale_models.vulnerability.Vulnerability._get_api_handler")
    def test_batch_create_or_update_sends_proper_format(self, mock_get_api_handler):
        """Test that batch_create_or_update sends payload in proper format."""
        mock_api = MagicMock()
        mock_api.post.return_value = {"items": [], "summary": {"totalCreated": 1, "totalUpdated": 0}}
        mock_get_api_handler.return_value = mock_api

        # Create test vulnerability
        vuln = regscale_models.Vulnerability(
            plugInId="TEST-001",
            plugInName="Test Plugin",
            parentId=self.plan_id,
            parentModule="securityplans",
            severity="High",
            ipAddress="192.168.1.100",
            dns="test.example.com",
        )

        options: regscale_models.VulnerabilityBatchOptions = {
            "source": "Test Integration",
            "enableAssetDiscovery": True,
            "parentId": self.plan_id,
            "parentModule": "securityplans",
        }

        # Call batch_create_or_update
        regscale_models.Vulnerability.batch_create_or_update(
            items=[vuln],
            batch_size=100,
            options=options,
        )

        # Verify the API was called
        mock_api.post.assert_called_once()

        # Verify payload format
        call_kwargs = mock_api.post.call_args.kwargs
        payload = call_kwargs["data"]

        assert "vulnerabilities" in payload
        assert "options" in payload
        assert len(payload["vulnerabilities"]) == 1
        assert payload["options"]["enableAssetDiscovery"] is True
        assert payload["options"]["source"] == "Test Integration"

        # Verify vulnerability data includes asset linking fields
        vuln_data = payload["vulnerabilities"][0]
        assert vuln_data["ipAddress"] == "192.168.1.100"
        assert vuln_data["dns"] == "test.example.com"

    @patch("regscale.models.regscale_models.vulnerability.Vulnerability._get_api_handler")
    def test_batch_create_or_update_handles_summary_response(self, mock_get_api_handler):
        """Test handling of summary-only response from streaming endpoint."""
        mock_api = MagicMock()
        # Simulate summary-only response (no items returned)
        mock_api.post.return_value = {
            "summary": {
                "totalCreated": 5,
                "totalUpdated": 3,
                "totalProcessed": 8,
            }
        }
        mock_get_api_handler.return_value = mock_api

        vulns = [
            regscale_models.Vulnerability(
                plugInId=f"TEST-{i:03d}",
                plugInName=f"Test Plugin {i}",
                parentId=self.plan_id,
                parentModule="securityplans",
            )
            for i in range(8)
        ]

        # Call batch_create_or_update
        result = regscale_models.Vulnerability.batch_create_or_update(
            items=vulns,
            batch_size=100,
        )

        # Verify original items are returned when summary-only response
        assert len(result) == 8


class TestVulnerabilityBulkSaveOverride(CLITestFixture):
    """Test Vulnerability.bulk_save override that uses streaming endpoint."""

    plan_id = 1
    tenant_id = 1

    @patch("regscale.models.regscale_models.vulnerability.Vulnerability.batch_create_or_update")
    def test_bulk_save_uses_batch_create_or_update(self, mock_batch_create_or_update):
        """Test that bulk_save calls batch_create_or_update (not separate batch_create/batch_update)."""
        mock_batch_create_or_update.return_value = []

        # Clear cache
        regscale_models.Vulnerability.clear_cache()

        # Create and queue vulnerability for bulk save
        vuln = regscale_models.Vulnerability(
            plugInId="TEST-BULK-001",
            plugInName="Test Bulk Plugin",
            parentId=self.plan_id,
            parentModule="securityplans",
        )
        vuln.create_or_update(bulk_create=True)

        # Call bulk_save
        regscale_models.Vulnerability.bulk_save()

        # Verify batch_create_or_update was called
        mock_batch_create_or_update.assert_called_once()

    @patch("regscale.models.regscale_models.vulnerability.Vulnerability.batch_create_or_update")
    @patch("regscale.models.regscale_models.vulnerability.Vulnerability.create_or_update")
    def test_bulk_save_combines_creates_and_updates(self, mock_create_or_update, mock_batch_create_or_update):
        """Test that bulk_save combines both pending creates and updates."""
        mock_batch_create_or_update.return_value = []

        regscale_models.Vulnerability.clear_cache()

        # Create vulnerability objects and cache them directly
        vuln1 = regscale_models.Vulnerability(
            plugInId="TEST-CREATE-001",
            plugInName="Test Create Plugin",
            parentId=self.plan_id,
            parentModule="securityplans",
            severity="High",
            title="Test Create Vuln",
        )
        regscale_models.Vulnerability.cache_object(vuln1)
        regscale_models.Vulnerability._get_pending_creations().add(regscale_models.Vulnerability._get_cache_key(vuln1))

        vuln2 = regscale_models.Vulnerability(
            id=123,
            plugInId="TEST-UPDATE-001",
            plugInName="Test Update Plugin",
            parentId=self.plan_id,
            parentModule="securityplans",
            severity="Medium",
            title="Test Update Vuln",
        )
        regscale_models.Vulnerability.cache_object(vuln2)
        regscale_models.Vulnerability._get_pending_updates().add(regscale_models.Vulnerability._get_cache_key(vuln2))

        # Call bulk_save
        regscale_models.Vulnerability.bulk_save()

        # Verify batch_create_or_update was called once with all items
        # (server handles upsert logic)
        mock_batch_create_or_update.assert_called_once()
