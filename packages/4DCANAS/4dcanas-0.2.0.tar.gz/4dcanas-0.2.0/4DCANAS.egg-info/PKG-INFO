Metadata-Version: 2.4
Name: 4DCANAS
Version: 0.2.0
Summary: Advanced 4D Visualization and Simulation Suite
Home-page: https://github.com/6x-u/4DCANAS
Author: MERO
Author-email: MERO <mero@ps.com>
License: MIT
Project-URL: Homepage, https://github.com/6x-u/4DCANAS
Project-URL: Documentation, https://github.com/6x-u/4DCANAS/wiki
Project-URL: Repository, https://github.com/6x-u/4DCANAS.git
Project-URL: Issues, https://github.com/6x-u/4DCANAS/issues
Keywords: 4D,visualization,physics,mathematics,tesseract,simulation,geometry,quaternion,relativity,quantum-mechanics
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Science/Research
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Scientific/Engineering :: Mathematics
Classifier: Topic :: Scientific/Engineering :: Physics
Classifier: Topic :: Multimedia :: Graphics
Classifier: Topic :: Multimedia :: Graphics :: 3D Rendering
Classifier: Topic :: Scientific/Engineering :: Visualization
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Requires-Dist: numpy<2.0.0,>=1.21.0
Requires-Dist: scipy<2.0.0,>=1.7.0
Requires-Dist: matplotlib>=3.4.0
Requires-Dist: PyOpenGL>=3.1.5
Requires-Dist: PyQt5>=5.15.0
Requires-Dist: pillow>=8.3.0
Requires-Dist: scikit-learn>=0.24.0
Requires-Dist: psutil>=5.8.0
Requires-Dist: sympy>=1.9
Requires-Dist: numba>=0.55.0
Requires-Dist: pandas>=1.3.0
Requires-Dist: plotly>=5.0.0
Requires-Dist: opencv-python>=4.5.0
Requires-Dist: networkx>=2.6
Requires-Dist: pyyaml>=5.4
Requires-Dist: tqdm>=4.62.0
Provides-Extra: torch
Requires-Dist: torch>=1.9.0; extra == "torch"
Requires-Dist: torchvision>=0.10.0; extra == "torch"
Provides-Extra: tensorflow
Requires-Dist: tensorflow>=2.6.0; extra == "tensorflow"
Provides-Extra: jupyter
Requires-Dist: jupyter>=1.0.0; extra == "jupyter"
Requires-Dist: ipywidgets>=7.6.0; extra == "jupyter"
Requires-Dist: ipykernel>=6.0.0; extra == "jupyter"
Requires-Dist: notebook>=6.4.0; extra == "jupyter"
Provides-Extra: dev
Requires-Dist: pytest>=6.2.0; extra == "dev"
Requires-Dist: pytest-cov>=2.12.0; extra == "dev"
Requires-Dist: black>=21.5b0; extra == "dev"
Requires-Dist: flake8>=3.9.0; extra == "dev"
Requires-Dist: mypy>=0.910; extra == "dev"
Provides-Extra: all
Requires-Dist: 4DCANAS[dev,jupyter,tensorflow,torch]; extra == "all"
Dynamic: author
Dynamic: home-page
Dynamic: requires-python

# 4DCANAS v0.2.0 - Advanced 4D Visualization and Simulation Suite

## Overview

4DCANAS is a comprehensive Python library for 4D mathematics, physics simulation, visualization, and VR/AR applications. It provides powerful tools for working with 4D objects, real-time rendering, physics engines, AI-assisted development, and game creation.

## Table of Contents

1. [Installation](#installation)
2. [Features](#features)
3. [Quick Start](#quick-start)
4. [4D Mathematics](#4d-mathematics)
5. [2D Rendering](#2d-rendering)
6. [3D Rendering](#3d-rendering)
7. [4D Visualization](#4d-visualization)
8. [Physics Simulation](#physics-simulation)
9. [VR/AR Support](#vrar-support)
10. [AI Assistant](#ai-assistant)
11. [Game Engine](#game-engine)
12. [File Handling](#file-handling)
13. [Export Formats](#export-formats)
14. [Advanced Examples](#advanced-examples)
15. [API Reference](#api-reference)

## Installation

```bash
pip install 4DCANAS
```

For development with VR support:
```bash
pip install 4DCANAS[torch,tensorflow,viz]
```

## Features

- Complete 4D Mathematics Library
- 2D/3D/4D Rendering Engines
- Advanced Physics Simulation (Gravity, EM, Dark Energy, Quantum)
- Full VR/AR Support (All Major Headsets)
- AI Assistant (MEROAI) for Development
- Game Engine for Interactive Experiences
- File I/O Support (OBJ, JSON, PLY, GLTF)
- Professional Export Tools
- Real-time Visualization
- Shape Generation and Analysis

## Quick Start

### Basic 4D Tesseract

```python
from 4DCANAS import Tesseract, AdvancedVisualizer4D

tesseract = Tesseract(size=1.0)
tesseract.rotate([0.1, 0.2, 0.15, 0.05])
projected, edges = tesseract.get_3d_projection()

visualizer = AdvancedVisualizer4D()
vertices_4d = [v.coords for v in tesseract.vertices]
fig = visualizer.multi_projection_view(vertices_4d, edges)
```

### AI Assistant

```python
from 4DCANAS import start_chat

start_chat()
```

Or programmatically:
```python
from 4DCANAS import MEROAIAssistant

assistant = MEROAIAssistant()
response = assistant.chat("How do I create a rotating tesseract?")
print(response)
```

## 4D Mathematics

### Point4D Operations

```python
from 4DCANAS import Point4D, Vector4D

p1 = Point4D(1.0, 2.0, 3.0, 4.0)
p2 = Point4D(5.0, 6.0, 7.0, 8.0)

distance = p1.distance_to(p2)
projected_3d = p1.project_3d(method='perspective')
p3 = p1 + p2
p4 = p1 * 2.0
```

### Vector4D Operations

```python
v1 = Vector4D(1.0, 0.0, 0.0, 0.0)
v2 = Vector4D(0.0, 1.0, 0.0, 0.0)

dot_product = v1.dot(v2)
angle = v1.angle_to(v2)
normalized = v1.normalize()
projected = v1.project_onto(v2)
reflected = v1.reflect_about(v2)
```

### Tesseract Creation and Manipulation

```python
from 4DCANAS import Tesseract, Rotation4D

tesseract = Tesseract(center=Point4D(0, 0, 0, 0), size=2.0)

tesseract.rotate([0.1, 0.2, 0.15, 0.05, 0.03, 0.02])
tesseract.translate(Vector4D(1.0, 0.0, 0.0, 0.0))
tesseract.scale(1.5)

projections = tesseract.to_3d_projections()
orthogonal_proj = projections['orthogonal']
perspective_proj = projections['perspective']
stereographic_proj = projections['stereographic']
```

### 4D Rotations

```python
from 4DCANAS import Rotation4D, Point4D

rotation = Rotation4D([np.pi/4, np.pi/6, np.pi/8, np.pi/12])
point = Point4D(1.0, 0.0, 0.0, 0.0)
rotated = rotation.apply(point)

composed = rotation.compose(Rotation4D([0.1, 0.2, 0.0, 0.0]))
inverse = rotation.inverse()
```

## 2D Rendering

```python
from 4DCANAS import Renderer2D
import numpy as np

renderer = Renderer2D(width=1920, height=1080)

points = [
    np.array([-0.5, -0.5]),
    np.array([0.5, -0.5]),
    np.array([0.5, 0.5]),
    np.array([-0.5, 0.5])
]
edges = [(0, 1), (1, 2), (2, 3), (3, 0)]

canvas = renderer.render_lines_2d(points, edges)
canvas_points = renderer.render_points_2d(points, colors=[1.0, 0.8, 0.6, 0.9])
canvas_circle = renderer.render_circle_2d(np.array([0.0, 0.0]), 0.3)
```

## 3D Rendering

```python
from 4DCANAS import Renderer3D
import numpy as np

renderer = Renderer3D(width=1920, height=1080)

renderer.set_camera(
    position=np.array([3.0, 3.0, 3.0]),
    target=np.array([0.0, 0.0, 0.0]),
    up=np.array([0.0, 1.0, 0.0])
)

vertices = [
    np.array([-1.0, -1.0, -1.0]),
    np.array([1.0, -1.0, -1.0]),
    np.array([1.0, 1.0, -1.0]),
    np.array([-1.0, 1.0, -1.0]),
    np.array([-1.0, -1.0, 1.0]),
    np.array([1.0, -1.0, 1.0]),
    np.array([1.0, 1.0, 1.0]),
    np.array([-1.0, 1.0, 1.0])
]

edges = [
    (0, 1), (1, 2), (2, 3), (3, 0),
    (4, 5), (5, 6), (6, 7), (7, 4),
    (0, 4), (1, 5), (2, 6), (3, 7)
]

canvas = renderer.render_lines_3d(vertices, edges)
canvas_points = renderer.render_points_3d(vertices)

faces = [
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [0, 1, 5, 4],
    [2, 3, 7, 6],
    [0, 3, 7, 4],
    [1, 2, 6, 5]
]
wireframe = renderer.render_wireframe_3d(vertices, faces)
```

## 4D Visualization

```python
from 4DCANAS import AdvancedVisualizer4D, Tesseract
import matplotlib.pyplot as plt

visualizer = AdvancedVisualizer4D(figsize=(16, 12))

tesseract = Tesseract(size=1.0)
vertices_4d = [v.coords for v in tesseract.vertices]
edges = tesseract.edges

fig = visualizer.multi_projection_view(vertices_4d, edges)

fig = visualizer.visualize_with_lighting(
    vertices_4d,
    edges,
    light_position=np.array([2, 2, 2]),
    ambient_light=0.3
)

def shape_generator(t):
    tesseract_copy = Tesseract(size=1.0)
    tesseract_copy.rotate([t * 0.5, t * 0.3, t * 0.2, t * 0.1])
    vertices = [v.coords for v in tesseract_copy.vertices]
    return vertices, tesseract_copy.edges

animation = visualizer.time_evolution_animation(
    shape_generator,
    time_steps=100,
    interval=50
)

plt.show()
```

## Physics Simulation

### Basic Physics Engine

```python
from 4DCANAS import Physics4DEngine
import numpy as np

engine = Physics4DEngine(
    gravity_vector=np.array([0, -9.81, 0, 0]),
    damping=0.99,
    time_step=0.001,
    solver='rk4'
)

engine.add_particle(
    position=np.array([0.0, 10.0, 0.0, 0.0]),
    velocity=np.array([1.0, 0.0, 0.0, 0.0]),
    mass=1.0,
    charge=0.0
)

engine.add_particle(
    position=np.array([0.0, 0.0, 0.0, 0.0]),
    velocity=np.array([0.0, 0.0, 0.0, 0.0]),
    mass=100.0,
    charge=0.0
)

for step in range(1000):
    engine.update(0.016)
    if step % 60 == 0:
        positions = [p.position for p in engine.particles]
        print(f"Step {step}: Particle 1 at {positions[0]}")
```

### Relativity Simulation

```python
from 4DCANAS import RelativityEngine4D

rel_engine = RelativityEngine4D(c=299792458.0)

velocity = np.array([0.9 * 299792458.0, 0.0, 0.0])
gamma = rel_engine.lorentz_factor(velocity)
energy = rel_engine.relativistic_energy(1.0, velocity)
momentum = rel_engine.relativistic_momentum(1.0, velocity)

event1 = np.array([0.0, 0.0, 0.0, 0.0])
event2 = np.array([1.0, 1.0, 0.0, 0.0])
interval = rel_engine.spacetime_interval(event1, event2)

transformed = rel_engine.lorentz_transform(event2, velocity)
```

### Quantum Mechanics

```python
from 4DCANAS import QuantumMechanics4D

qm = QuantumMechanics4D()

def harmonic_potential(x):
    return 0.5 * np.sum(x**2)

initial_state = np.random.randn(100).astype(complex)
initial_state = initial_state / np.linalg.norm(initial_state)

states = qm.schrodinger_equation_solver(
    potential=harmonic_potential,
    initial_state=initial_state,
    dt=1e-6,
    steps=1000
)

prob_density = qm.probability_density(states[-1])
expectation = qm.expectation_value(states[-1], np.diag(np.arange(100)))
```

## VR/AR Support

### VR Setup

```python
from 4DCANAS import VRSession, VRDeviceType, Tesseract
import numpy as np

session = VRSession(VRDeviceType.OCULUS_QUEST_2)
session.start()

tesseract = Tesseract(size=1.0)

while session.active:
    tesseract.rotate([0.01, 0.0, 0.0, 0.0])
    vertices_4d = [v.coords for v in tesseract.vertices]
    edges = tesseract.edges
    
    left_view, right_view = session.render_frame(vertices_4d, edges)
    
    session.update(0.016)

session.stop()
```

### Supported VR Devices

- Oculus Quest / Quest 2 / Quest 3
- Oculus Rift / Rift S
- HTC Vive / Vive Pro / Vive Cosmos / Vive Pro 2
- Valve Index
- PlayStation VR / PSVR 2
- Windows Mixed Reality
- HP Reverb / Reverb G2
- Pico Neo / Pico 4
- Varjo Aero / XR-3
- Meta Quest Pro
- Apple Vision Pro
- Generic SteamVR / OpenXR

### AR System

```python
from 4DCANAS import ARSystem
import numpy as np

ar = ARSystem(camera_resolution=(1920, 1080))

point_4d = np.array([1.0, 1.0, 1.0, 1.0])
camera_pose = np.eye(4)
projected_2d = ar.project_4d_to_ar(point_4d, camera_pose)

planes = ar.detect_planes()
anchor_id = ar.create_anchor(np.array([0.0, 0.0, 0.0]))
```

## AI Assistant

### Chat Interface

```python
from 4DCANAS import start_chat

start_chat()
```

### Programmatic Usage

```python
from 4DCANAS import MEROAIAssistant

assistant = MEROAIAssistant(use_g4f=True)

response = assistant.chat("How do I create a physics simulation with gravity?")
print(response)

code = assistant.generate_code("create a rotating tesseract with VR support")
print(code)

explanation = assistant.explain_concept("4d rotation")
print(explanation)

info = assistant.get_library_info()
print(f"Library: {info['name']} v{info['version']}")
```

## Game Engine

### Basic Game

```python
from 4DCANAS import GameEngine4D, VRDeviceType
import numpy as np

engine = GameEngine4D(vr_device=VRDeviceType.OCULUS_QUEST_2, use_physics=True)

engine.add_game_object(
    obj_id='player',
    position_4d=np.array([0.0, 0.0, 0.0, 0.0]),
    shape_type='tesseract',
    scale=1.0,
    physics_enabled=True,
    mass=1.0
)

engine.add_game_object(
    obj_id='enemy',
    position_4d=np.array([5.0, 0.0, 0.0, 0.0]),
    shape_type='tesseract',
    scale=0.5
)

def update_callback(dt):
    engine.translate_object('player', np.array([0.01, 0.0, 0.0, 0.0]))

engine.on_update(update_callback)

engine.run(max_frames=1000, target_fps=60.0)
```

### Game Library

```python
from 4DCANAS import GameLibrary, GameEngine4D, VRDeviceType

library = GameLibrary()

def my_game(engine):
    engine.add_game_object('object1', np.array([0, 0, 0, 0]), 'tesseract')
    engine.add_game_object('object2', np.array([2, 0, 0, 0]), 'tesseract')
    
    def game_update(dt):
        engine.rotate_object('object1', np.array([0.01, 0, 0, 0, 0, 0]))

library.register_game('my_game', my_game)

engine = GameEngine4D(vr_device=VRDeviceType.HTC_VIVE)
library.create_game('my_game', engine)
engine.run()
```

## File Handling

### Loading Files

```python
from 4DCANAS import FileHandler4D

handler = FileHandler4D()

shape_obj = handler.load_file('model.obj')
shape_json = handler.load_file('data.json')
shape_ply = handler.load_file('points.ply')
shape_gltf = handler.load_file('scene.gltf')

tesseract = handler.convert_to_tesseract(shape_obj, target_size=2.0)
```

### Saving Files

```python
from 4DCANAS import FileHandler4D, Tesseract

handler = FileHandler4D()
tesseract = Tesseract(size=1.0)

shape = {
    'vertices': [v.coords for v in tesseract.vertices],
    'edges': tesseract.edges,
    'type': 'tesseract'
}

handler.save_file(shape, 'output.obj', format='obj')
handler.save_file(shape, 'output.json', format='json')
handler.save_file(shape, 'output.ply', format='ply')
handler.save_file(shape, 'output.gltf', format='gltf')
```

## Export Formats

```python
from 4DCANAS import AdvancedExportTools, Tesseract

tesseract = Tesseract(size=1.0)
shape = {
    'vertices': [v.coords for v in tesseract.vertices],
    'edges': tesseract.edges,
    'type': 'tesseract'
}

AdvancedExportTools.quick_export(shape, format='obj', filename='tesseract.obj')
AdvancedExportTools.quick_export(shape, format='json', filename='tesseract.json')
AdvancedExportTools.quick_export(shape, format='gltf', filename='tesseract.gltf')
AdvancedExportTools.quick_export(shape, format='ply', filename='tesseract.ply')
```

## Advanced Examples

### Complete VR Experience with Physics

```python
from 4DCANAS import (
    VRSession, VRDeviceType, Tesseract, 
    Physics4DEngine, GameEngine4D
)
import numpy as np

game = GameEngine4D(
    vr_device=VRDeviceType.META_QUEST_3,
    use_physics=True
)

game.add_game_object(
    'tesseract1',
    np.array([0.0, 0.0, 0.0, 0.0]),
    'tesseract',
    1.0,
    physics_enabled=True,
    mass=1.0
)

def game_loop():
    game.update(0.016)
    canvas = game.render('vr')

game.run(target_fps=72.0)
```

### AI-Powered Shape Generation

```python
from 4DCANAS import AutoGenerator4D, DeepAnalyzer4D, AdvancedVisualizer4D

generator = AutoGenerator4D()
analyzer = DeepAnalyzer4D()
visualizer = AdvancedVisualizer4D()

shapes = []
for seed in range(10):
    shape = generator.generate_shape("complex rotating polytope", seed=seed)
    analysis = analyzer.analyze_shape(shape['vertices'], shape['edges'])
    
    if analysis['aesthetic_score'] > 0.7:
        shapes.append(shape)
        fig = visualizer.multi_projection_view(
            shape['vertices'],
            shape['edges']
        )
```

### Multi-dimensional Visualization Pipeline

```python
from 4DCANAS import (
    Tesseract, Renderer2D, Renderer3D, Renderer4D,
    AdvancedVisualizer4D
)

tesseract = Tesseract(size=1.0)
tesseract.rotate([0.1, 0.2, 0.15, 0.05])

vertices_4d = [v.coords for v in tesseract.vertices]
edges = tesseract.edges

renderer_2d = Renderer2D(1920, 1080)
renderer_3d = Renderer3D(1920, 1080)
renderer_4d = Renderer4D(1920, 1080)

vertices_2d = [v[:2] for v in vertices_4d]
vertices_3d = [v[:3] for v in vertices_4d]

canvas_2d = renderer_2d.render_lines_2d(vertices_2d, edges)
canvas_3d = renderer_3d.render_lines_3d(vertices_3d, edges)
canvas_4d = renderer_4d.render_4d(vertices_4d, edges)
```

## API Reference

### Core Classes

- `Point4D(x, y, z, w)` - 4D point with projection methods
- `Vector4D(x, y, z, w)` - 4D vector with operations
- `Tesseract(center, size)` - 4D hypercube
- `Rotation4D(angles)` - 4D rotation matrices
- `Matrix4D(matrix)` - 4x4 matrix operations
- `Quaternion4D(w, x, y, z)` - 4D quaternions

### Physics Classes

- `Physics4DEngine()` - Physics simulation engine
- `RelativityEngine4D(c)` - Relativistic calculations
- `QuantumMechanics4D()` - Quantum mechanics solver
- `Particle4D` - Particle data structure

### Rendering Classes

- `Renderer2D(width, height)` - 2D rendering
- `Renderer3D(width, height)` - 3D rendering
- `Renderer4D(width, height)` - 4D rendering
- `AdvancedVisualizer4D()` - Advanced visualization

### VR Classes

- `VRSession(device_type)` - VR session management
- `VRSystem(device_type)` - VR device interface
- `VRRenderer(vr_system)` - VR rendering
- `ARSystem()` - AR system

### AI Classes

- `MEROAIAssistant(use_g4f)` - AI assistant
- `ChatBot(assistant)` - Chat interface

### Game Classes

- `GameEngine4D(vr_device, use_physics)` - Game engine
- `GameObject` - Game object data
- `GameLibrary()` - Game library

### File Handling

- `FileHandler4D()` - File I/O operations

## Performance Tips

1. Use `np.float64` for precision in 4D calculations
2. Batch operations when possible
3. Use `Physics4DEngine.simulate()` for long simulations
4. Enable GPU acceleration where available
5. Cache projections for static objects
6. Use appropriate projection methods for your use case

## Contributing

Contributions welcome! Areas of interest:
- Additional 4D shapes
- Physics simulations
- Visualization methods
- VR/AR improvements
- Performance optimizations

## License

MIT License

## Author

MERO (mero@ps.com)

## Version

0.2.0

## Support

For questions and support:
- Use MEROAI assistant: `from 4DCANAS import start_chat; start_chat()`
- Check documentation and examples
- Review test files for usage patterns
