# Универсальные правила архитектуры и принципы разработки

Этот документ содержит формализованные универсальные правила архитектуры и принципы разработки, применимые к любым проектам независимо от технологий и предметной области.

---

## 1. Архитектурные принципы

### 1.1 Многослойная архитектура (Layered Architecture)

**Правило:** Разделяйте систему на независимые слои с чёткой ответственностью.

**Структура:**
```
┌─────────────────────────────────────┐
│   PRESENTATION LAYER                 │
│   - Форматирование вывода           │
│   - Интерфейсы (API, CLI, UI)       │
└─────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│   BUSINESS LOGIC LAYER               │
│   - Бизнес-правила                  │
│   - Оркестрация операций            │
│   - Валидация                       │
└─────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│   DATA ACCESS LAYER                  │
│   - Репозитории                     │
│   - Доступ к данным                 │
│   - Низкоуровневые операции        │
└─────────────────────────────────────┘
```

**Принципы:**
- Каждый слой знает только о соседних слоях
- Presentation Layer не знает о Data Access Layer
- Data Access Layer не знает о бизнес-логике
- Слои взаимодействуют через интерфейсы (абстракции)
- Направление зависимостей: от внешних слоёв к внутренним

**Преимущества:**
- Разделение ответственности
- Независимое тестирование слоёв
- Возможность замены реализации слоя без влияния на другие
- Упрощение понимания системы

---

### 1.2 Dependency Injection (Внедрение зависимостей)

**Правило:** Зависимости передаются извне, а не создаются внутри компонента.

**Принципы:**
- Компоненты не создают свои зависимости напрямую
- Зависимости передаются через конструктор или методы
- Используется контейнер зависимостей для управления жизненным циклом
- Lazy loading — зависимости создаются при первом обращении
- Поддержка кастомных зависимостей для тестирования

**Преимущества:**
- Упрощение тестирования (можно подменять зависимости)
- Слабая связанность компонентов
- Централизованное управление жизненным циклом
- Избежание циклических зависимостей
- Единая точка конфигурации

**Анти-паттерн:**
```java
// Плохо: жёсткая связь
class UserService {
    private Database db = new MySQLDatabase(); // Создание внутри
}

// Хорошо: Dependency Injection
class UserService {
    private Database db;
    public UserService(Database db) {
        this.db = db; // Зависимость извне
    }
}
```

---

### 1.3 Интерфейсы и абстракции

**Правило:** Программируйте на уровне интерфейсов, а не реализаций.

**Принципы:**
- Все публичные API должны иметь интерфейсы/контракты
- Реализации соответствуют интерфейсам (structural typing или explicit implementation)
- Интерфейсы используются для типизации, а не наследования
- Строгая типизация: избегайте `Any`/`Object`, используйте конкретные типы
- Интерфейсы определяют "что", реализации определяют "как"

**Преимущества:**
- Упрощение тестирования через моки
- Явное определение контрактов
- Возможность замены реализаций без изменения кода
- Улучшение читаемости и понимания API
- Слабая связанность компонентов

---

### 1.4 Repository Pattern (Паттерн Репозиторий)

**Правило:** Инкапсулируйте доступ к данным через репозитории.

**Принципы:**
- Репозитории абстрагируют низкоуровневые операции с хранилищем данных
- Репозитории не знают о бизнес-логике
- Один репозиторий на одну сущность или доменную область
- Методы репозиториев возвращают доменные объекты, а не сырые данные хранилища
- Репозитории скрывают детали реализации хранилища (SQL, NoSQL, файлы и т.д.)

**Преимущества:**
- Изоляция бизнес-логики от деталей хранения данных
- Упрощение тестирования (можно мокировать репозитории)
- Возможность смены хранилища данных без изменения бизнес-логики
- Единообразный доступ к данным

---

### 1.5 Strategy Pattern (Паттерн Стратегия)

**Правило:** Используйте Strategy pattern для алгоритмов с разными реализациями.

**Принципы:**
- Базовый интерфейс/класс для стратегий
- Конкретные реализации для разных случаев
- Выбор стратегии на основе контекста (runtime или compile-time)
- Стратегии взаимозаменяемы

**Преимущества:**
- Гибкость в выборе алгоритма
- Избежание условных операторов (if/switch) для выбора алгоритма
- Легкое добавление новых стратегий
- Разделение логики выбора и реализации

---

## 2. Принципы разработки

### 2.1 Строгая типизация

**Правило:** Используйте строгую типизацию везде, избегайте неопределённых типов.

**Принципы:**
- Все функции/методы должны иметь аннотации типов
- Используйте конкретные типы вместо общих (например, `List<User>` вместо `List<Object>`)
- Избегайте `Any`/`Object` — используйте конкретные типы или дженерики
- Используйте типы для документирования контрактов
- Компилятор/линтер должен проверять типы

**Преимущества:**
- Раннее обнаружение ошибок (на этапе компиляции/статического анализа)
- Улучшение читаемости кода
- Автодополнение в IDE
- Документация через типы

---

### 2.2 Асинхронность для I/O операций

**Правило:** Все I/O операции должны быть асинхронными.

**Принципы:**
- Используйте асинхронные операции для всех операций с диском, сетью, БД
- Синхронные I/O операции выполняйте в отдельном потоке/executor
- Используйте семафоры/пулы для ограничения параллелизма
- Используйте параллельное выполнение для независимых операций
- Не блокируйте основной поток выполнения

**Преимущества:**
- Эффективное использование ресурсов
- Масштабируемость системы
- Отзывчивость приложения
- Возможность обработки множества запросов одновременно

---

### 2.3 Обработка ошибок через специализированные исключения

**Правило:** Используйте иерархию специализированных исключений с контекстом.

**Принципы:**
- Базовый класс для всех исключений домена
- Специализированные исключения для разных типов ошибок
- Все исключения должны содержать контекст (идентификаторы, параметры операции)
- Используйте декораторы/обёртки для автоматической обработки ошибок
- Различайте recoverable и non-recoverable ошибки

**Преимущества:**
- Ясная обработка разных типов ошибок
- Контекст для отладки
- Возможность централизованной обработки ошибок
- Улучшение пользовательского опыта (понятные сообщения об ошибках)

---

### 2.4 Нормализация данных

**Правило:** Всегда нормализуйте данные через централизованный нормализатор.

**Принципы:**
- Единая точка нормализации (один класс/модуль)
- Нормализация перед сохранением в хранилище
- Консистентная обработка данных во всей системе
- Нормализация включает: приведение к единому формату, очистку, валидацию

**Преимущества:**
- Консистентность данных
- Упрощение поиска и сравнения
- Избежание дублирования логики нормализации
- Единообразное представление данных

---

### 2.5 Защита от инъекций

**Правило:** Всегда экранируйте и валидируйте пользовательский ввод.

**Принципы:**
- Используйте параметризованные запросы для БД
- Экранируйте специальные символы в строках
- Никогда не используйте конкатенацию строк для SQL/команд
- Валидируйте входные данные перед использованием
- Используйте whitelist вместо blacklist для валидации

**Преимущества:**
- Защита от SQL injection, command injection, XSS
- Безопасность системы
- Защита данных пользователей

---

### 2.6 Структурированное логирование

**Правило:** Используйте структурированное логирование с контекстом.

**Принципы:**
- Используйте структурированные форматы (JSON, key-value пары)
- Логируйте с контекстом (идентификаторы запросов, пользователи, параметры)
- Используйте разные уровни логирования (DEBUG, INFO, WARNING, ERROR)
- Логируйте важные события (начало/конец операций, ошибки, изменения состояния)
- Не логируйте чувствительные данные (пароли, токены)

**Преимущества:**
- Упрощение поиска и анализа логов
- Возможность агрегации и мониторинга
- Контекст для отладки
- Аудит операций

---

### 2.7 Connection Pooling (Пул соединений)

**Правило:** Используйте пулы соединений для ресурсов с высокой стоимостью создания.

**Принципы:**
- Единый менеджер соединений для каждого типа ресурса
- Переиспользование соединений между компонентами
- Context manager для безопасного использования
- Ограничение количества соединений
- Автоматическое закрытие неиспользуемых соединений

**Преимущества:**
- Снижение накладных расходов на создание соединений
- Эффективное использование ресурсов
- Масштабируемость
- Предсказуемое использование ресурсов

---

### 2.8 Graceful Degradation (Плавная деградация)

**Правило:** Система должна продолжать работать при частичных сбоях.

**Принципы:**
- Fallback на альтернативные методы при ошибках
- Circuit Breaker для защиты от каскадных сбоев
- Retry с exponential backoff для временных ошибок
- Логирование всех fallback операций
- Предоставление частичной функциональности вместо полного отказа

**Преимущества:**
- Высокая доступность системы
- Защита от каскадных сбоев
- Улучшение пользовательского опыта
- Устойчивость к временным проблемам

---

### 2.9 Caching Strategy (Стратегия кэширования)

**Правило:** Кэшируйте дорогие операции и данные, которые не меняются часто.

**Принципы:**
- Кэш для результатов вычислений и запросов
- Инвалидация кэша при изменении данных
- Уникальный ключ кэша: hash(параметры) + версия
- Хранение кэша в быстром хранилище (память, Redis)
- TTL (Time To Live) для автоматической инвалидации

**Преимущества:**
- Ускорение операций
- Снижение нагрузки на ресурсы
- Улучшение отзывчивости системы

---

### 2.10 Schema Migrations (Миграции схемы)

**Правило:** Автоматизируйте изменения схемы хранилища данных.

**Принципы:**
- Версионирование схемы хранилища
- Автоматическое обнаружение и применение миграций
- Сохранение данных при миграции
- Откат миграций при ошибках
- Миграции должны быть идемпотентными

**Преимущества:**
- Безопасное обновление схемы
- Автоматизация процесса развёртывания
- Возможность отката изменений
- Контроль версий схемы

---

## 3. Паттерны проектирования

### 3.1 Factory Pattern (Паттерн Фабрика)

**Правило:** Используйте Factory для создания сложных объектов.

**Принципы:**
- Централизованное создание объектов
- Lazy initialization
- Поддержка кастомных настроек
- Скрытие деталей создания объекта

**Преимущества:**
- Упрощение создания сложных объектов
- Централизованная логика создания
- Возможность подмены реализации для тестирования

---

### 3.2 Circuit Breaker (Автоматический выключатель)

**Правило:** Защищайте систему от каскадных сбоев.

**Принципы:**
- Открытие circuit breaker при превышении порога ошибок
- Автоматическое закрытие после таймаута
- Три состояния: Closed (норма), Open (отказ), Half-Open (тестирование)
- Мониторинг состояния circuit breaker

**Преимущества:**
- Защита от каскадных сбоев
- Быстрое обнаружение проблемных сервисов
- Снижение нагрузки на проблемные компоненты

---

### 3.3 Retry с Exponential Backoff

**Правило:** Повторяйте операции с увеличивающейся задержкой.

**Принципы:**
- Максимальное количество попыток
- Exponential backoff: delay = initial_delay * (base ^ attempt)
- Ограничение максимальной задержки
- Логирование всех попыток
- Различайте retryable и non-retryable ошибки

**Преимущества:**
- Устойчивость к временным сбоям
- Снижение нагрузки на систему при сбоях
- Предсказуемое поведение при ошибках

---

### 3.4 Batch Processing (Пакетная обработка)

**Правило:** Обрабатывайте большие объёмы данных батчами.

**Принципы:**
- Обработка батчами с настраиваемым размером
- Callback для отслеживания прогресса
- Возможность отмены длительных операций
- Обработка ошибок на уровне батча
- Параллельная обработка батчей при возможности

**Преимущества:**
- Эффективное использование ресурсов
- Видимость прогресса
- Возможность отмены операций
- Лучшая обработка ошибок

---

## 4. Правила кода

### 4.1 Именование

**Правило:** Используйте понятные имена, следующие конвенциям языка.

**Принципы:**
- Имена должны отражать назначение
- Следуйте конвенциям языка (camelCase, snake_case, PascalCase)
- Избегайте сокращений (кроме общепринятых)
- Используйте глаголы для методов, существительные для классов
- Приватные элементы помечайте соответствующим образом

**Преимущества:**
- Улучшение читаемости кода
- Упрощение понимания назначения
- Самодокументируемый код

---

### 4.2 Документация

**Правило:** Документируйте все публичные API.

**Принципы:**
- Документация для всех классов и публичных методов
- Описание параметров
- Описание возвращаемых значений
- Описание исключений
- Примеры использования для сложных API

**Преимущества:**
- Упрощение использования API
- Снижение необходимости изучения исходного кода
- Улучшение поддерживаемости

---

### 4.3 Тестирование

**Правило:** Покрывайте код тестами, используйте моки для зависимостей.

**Принципы:**
- Unit тесты для каждого компонента
- Интеграционные тесты для взаимодействия компонентов
- Использование моков через интерфейсы
- Тестирование на реальных данных (test fixtures)
- Покрытие >= 80% для критичных компонентов
- Тесты должны быть быстрыми, изолированными, повторяемыми

**Преимущества:**
- Раннее обнаружение ошибок
- Уверенность при рефакторинге
- Документация через тесты
- Упрощение отладки

---

## 5. Правила работы с данными

### 5.1 Нормализация схемы данных

**Правило:** Используйте нормализованную схему данных.

**Принципы:**
- Отдельные таблицы/коллекции для разных сущностей
- Связи через foreign keys/references
- Избегайте денормализации (кроме случаев оптимизации)
- Версионирование схемы

**Преимущества:**
- Избежание дублирования данных
- Консистентность данных
- Упрощение обновлений

---

### 5.2 Оптимизация запросов

**Правило:** Оптимизируйте запросы к хранилищу данных.

**Принципы:**
- Использование индексов
- Ограничение количества результатов (LIMIT)
- Предварительная фильтрация перед дорогими операциями
- Кэширование результатов запросов
- Избежание N+1 проблем

**Преимущества:**
- Улучшение производительности
- Снижение нагрузки на хранилище
- Масштабируемость

---

## 6. Правила производительности

### 6.1 Параллелизм

**Правило:** Используйте параллелизм для независимых операций.

**Принципы:**
- Ограничение параллелизма через семафоры/пулы
- Параллельное выполнение независимых операций
- Batch processing для больших объёмов данных
- Мониторинг использования ресурсов

**Преимущества:**
- Эффективное использование ресурсов
- Ускорение операций
- Масштабируемость

---

### 6.2 Профилирование

**Правило:** Измеряйте производительность перед оптимизацией.

**Принципы:**
- Профилирование для выявления узких мест
- Метрики производительности (latency, throughput)
- Мониторинг в production
- Оптимизация только измеренных проблем

**Преимущества:**
- Фокус на реальных проблемах
- Избежание преждевременной оптимизации
- Доказательство эффективности оптимизаций

---

## 7. Правила безопасности

### 7.1 Валидация входных данных

**Правило:** Всегда валидируйте входные данные.

**Принципы:**
- Валидация на границах системы (API, UI)
- Проверка типов и диапазонов значений
- Санитизация пользовательского ввода
- Обработка некорректных данных

**Преимущества:**
- Защита от некорректных данных
- Предсказуемое поведение системы
- Улучшение пользовательского опыта

---

### 7.2 Принцип наименьших привилегий

**Правило:** Компоненты должны иметь минимально необходимые права доступа.

**Принципы:**
- Ограничение доступа к ресурсам
- Разделение прав доступа по ролям
- Изоляция компонентов
- Аудит доступа к ресурсам

**Преимущества:**
- Снижение риска компрометации
- Ограничение ущерба при атаке
- Соответствие требованиям безопасности

---

## 8. Правила расширяемости

### 8.1 Открытость/Закрытость (Open/Closed Principle)

**Правило:** Код должен быть открыт для расширения, но закрыт для модификации.

**Принципы:**
- Добавление новой функциональности через расширение, а не изменение
- Использование интерфейсов и абстракций
- Плагинная архитектура для расширяемости
- Избежание изменения существующего кода при добавлении функций

**Преимущества:**
- Стабильность существующего кода
- Легкое добавление новых функций
- Снижение риска регрессий

---

### 8.2 Принцип единственной ответственности (Single Responsibility)

**Правило:** Каждый класс/модуль должен иметь одну причину для изменения.

**Принципы:**
- Одна ответственность на класс/модуль
- Разделение по областям ответственности
- Избежание "божественных объектов" (God Object)

**Преимущества:**
- Упрощение понимания кода
- Упрощение тестирования
- Упрощение поддержки

---

### 8.3 Принцип инверсии зависимостей (Dependency Inversion)

**Правило:** Зависимости должны направляться на абстракции, а не на конкретные реализации.

**Принципы:**
- Высокоуровневые модули не зависят от низкоуровневых
- Оба зависят от абстракций
- Абстракции не зависят от деталей
- Детали зависят от абстракций

**Преимущества:**
- Слабая связанность компонентов
- Упрощение тестирования
- Гибкость в выборе реализации

---

## 9. Чек-лист для нового кода

- [ ] Код следует многослойной архитектуре
- [ ] Используются интерфейсы/абстракции
- [ ] Строгая типизация (нет неопределённых типов)
- [ ] Все I/O операции асинхронные
- [ ] Обработка ошибок через специализированные исключения
- [ ] Данные нормализуются централизованно
- [ ] Пользовательский ввод валидируется и экранируется
- [ ] Структурированное логирование
- [ ] Используется Dependency Injection
- [ ] Добавлена документация
- [ ] Написаны тесты
- [ ] Код проходит линтер/статические проверки

---

## 10. Анти-паттерны (чего избегать)

### ❌ Глобальные экземпляры
**Проблема:** Жёсткая связь, сложность тестирования
**Решение:** Используйте Dependency Injection

### ❌ Синхронный I/O в async функциях
**Проблема:** Блокировка потока выполнения
**Решение:** Используйте асинхронные операции или executor

### ❌ Использование неопределённых типов
**Проблема:** Потеря информации о типах, ошибки в runtime
**Решение:** Используйте конкретные типы

### ❌ Прямое создание зависимостей
**Проблема:** Жёсткая связь, сложность тестирования
**Решение:** Передавайте зависимости извне

### ❌ Игнорирование ошибок
**Проблема:** Непредсказуемое поведение системы
**Решение:** Обрабатывайте все ошибки явно

### ❌ Дублирование кода (DRY violation)
**Проблема:** Сложность поддержки, риск рассинхронизации
**Решение:** Выносите общую логику в переиспользуемые компоненты

### ❌ Большие классы/методы
**Проблема:** Сложность понимания и тестирования
**Решение:** Разбивайте на меньшие компоненты

### ❌ Циклические зависимости
**Проблема:** Сложность понимания, проблемы с компиляцией
**Решение:** Используйте Dependency Injection и интерфейсы

---

## 11. SOLID принципы

### S - Single Responsibility Principle
Каждый класс должен иметь одну причину для изменения.

### O - Open/Closed Principle
Классы должны быть открыты для расширения, но закрыты для модификации.

### L - Liskov Substitution Principle
Объекты должны быть заменяемы экземплярами их подтипов без изменения корректности программы.

### I - Interface Segregation Principle
Клиенты не должны зависеть от интерфейсов, которые они не используют.

### D - Dependency Inversion Principle
Зависимости должны направляться на абстракции, а не на конкретные реализации.

---

## 12. Принципы проектирования API

### 12.1 Консистентность
- Единообразные имена методов
- Единообразная структура ответов
- Единообразная обработка ошибок

### 12.2 Простота
- Простые интерфейсы
- Минимум параметров
- Понятные имена

### 12.3 Обратная совместимость
- Не ломайте существующие API
- Версионирование API при необходимости
- Deprecation вместо удаления

### 12.4 Документация
- Полная документация API
- Примеры использования
- Описание ограничений и требований

---

## Заключение

Эти правила основаны на проверенных практиках разработки и применимы к проектам любого масштаба и технологического стека. Ключевые принципы:

1. **Разделение ответственности** — каждый компонент решает одну задачу
2. **Зависимости через интерфейсы** — упрощение тестирования и расширяемости
3. **Строгая типизация** — раннее обнаружение ошибок
4. **Асинхронность** — эффективное использование ресурсов
5. **Обработка ошибок** — надёжность системы
6. **Расширяемость** — простота добавления новых функций
7. **Безопасность** — защита данных и системы
8. **Производительность** — оптимизация на основе измерений

Следование этим принципам поможет создать поддерживаемый, масштабируемый и надёжный код.
