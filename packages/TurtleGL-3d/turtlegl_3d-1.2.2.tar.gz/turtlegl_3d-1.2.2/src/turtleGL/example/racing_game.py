#generated by GLM4.7

import turtle
import random
import time
from turtleGL import camera


class RacingGame:
    def __init__(self):
        self.cam = camera('赛车游戏')
        self.cam.point_behind_cam_type = 2
        self.cam.status()
        self.cam.setposition([0, 3, -10])
        self.cam.setdirection([0, 0, 1])
        self.cam.setfocal(400)
        self.cam.tracer(0)
        
        self.player_x = 0
        self.player_z = 0
        self.speed = 0
        self.max_speed = 2
        self.acceleration = 0.1
        self.deceleration = 0.05
        self.turn_speed = 0.5
        
        self.obstacles = []
        self.score = 0
        self.game_over = False
        self.road_width = 10
        
        self.setup_controls()
        self.generate_road()
        self.game_loop()
    
    def setup_controls(self):
        self.keys = {'left': False, 'right': False, 'up': False, 'down': False}
        
        def press_left():
            self.keys['left'] = True
        
        def release_left():
            self.keys['left'] = False
        
        def press_right():
            self.keys['right'] = True
        
        def release_right():
            self.keys['right'] = False
        
        def press_up():
            self.keys['up'] = True
        
        def release_up():
            self.keys['up'] = False
        
        def press_down():
            self.keys['down'] = True
        
        def release_down():
            self.keys['down'] = False
        
        turtle.listen()
        turtle.onkeypress(press_left, 'Left')
        turtle.onkeyrelease(release_left, 'Left')
        turtle.onkeypress(press_right, 'Right')
        turtle.onkeyrelease(release_right, 'Right')
        turtle.onkeypress(press_up, 'Up')
        turtle.onkeyrelease(release_up, 'Up')
        turtle.onkeypress(press_down, 'Down')
        turtle.onkeyrelease(release_down, 'Down')
    
    def generate_road(self):
        self.road_segments = []
        for i in range(50):
            z = i * 20
            self.road_segments.append(z)
    
    def create_car(self, x, z, color='#FF0000'):
        car = []
        w, h, d = 1, 0.8, 2
        
        car.append([[[x-w/2, 0, z-d/2], [x+w/2, 0, z-d/2], [x+w/2, 0, z+d/2], [x-w/2, 0, z+d/2]], '#333333'])
        car.append([[[x-w/2, h, z-d/2], [x+w/2, h, z-d/2], [x+w/2, h, z+d/2], [x-w/2, h, z+d/2]], color])
        car.append([[[x-w/2, 0, z-d/2], [x-w/2, h, z-d/2], [x+w/2, h, z-d/2], [x+w/2, 0, z-d/2]], color])
        car.append([[[x+w/2, 0, z-d/2], [x+w/2, h, z-d/2], [x+w/2, h, z+d/2], [x+w/2, 0, z+d/2]], color])
        car.append([[[x-w/2, 0, z+d/2], [x-w/2, h, z+d/2], [x+w/2, h, z+d/2], [x+w/2, 0, z+d/2]], color])
        car.append([[[x-w/2, 0, z-d/2], [x-w/2, h, z-d/2], [x-w/2, h, z+d/2], [x-w/2, 0, z+d/2]], color])
        
        return car
    
    def create_obstacle(self, x, z):
        obstacle = []
        w, h, d = 1.5, 1.5, 1.5
        color = random.choice(['#FF6600', '#FFCC00', '#CC0000', '#990000'])
        
        obstacle.append([[[x-w/2, 0, z-d/2], [x+w/2, 0, z-d/2], [x+w/2, 0, z+d/2], [x-w/2, 0, z+d/2]], color])
        obstacle.append([[[x-w/2, h, z-d/2], [x+w/2, h, z-d/2], [x+w/2, h, z+d/2], [x-w/2, h, z+d/2]], color])
        obstacle.append([[[x-w/2, 0, z-d/2], [x-w/2, h, z-d/2], [x+w/2, h, z-d/2], [x+w/2, 0, z-d/2]], color])
        obstacle.append([[[x+w/2, 0, z-d/2], [x+w/2, h, z-d/2], [x+w/2, h, z+d/2], [x+w/2, 0, z+d/2]], color])
        obstacle.append([[[x-w/2, 0, z+d/2], [x-w/2, h, z+d/2], [x+w/2, h, z+d/2], [x+w/2, 0, z+d/2]], color])
        obstacle.append([[[x-w/2, 0, z-d/2], [x-w/2, h, z-d/2], [x-w/2, h, z+d/2], [x-w/2, 0, z+d/2]], color])
        
        return obstacle
    
    def create_road_segment(self, z):
        road = []
        road_width = self.road_width
        
        road.append([[[ -road_width/2, -0.1, z], [ road_width/2, -0.1, z], 
                       [ road_width/2, -0.1, z+20], [-road_width/2, -0.1, z+20]], '#444444'])
        
        road.append([[[ -road_width/2-1, -0.2, z], [ -road_width/2, -0.2, z], 
                       [ -road_width/2, -0.2, z+20], [-road_width/2-1, -0.2, z+20]], '#228B22'])
        road.append([[[ road_width/2, -0.2, z], [ road_width/2+1, -0.2, z], 
                       [ road_width/2+1, -0.2, z+20], [ road_width/2, -0.2, z+20]], '#228B22'])
        
        if (int(z/20) % 2 == 0):
            road.append([[[ -0.3, -0.05, z+5], [ 0.3, -0.05, z+5], 
                           [ 0.3, -0.05, z+15], [-0.3, -0.05, z+15]], '#FFFFFF'])
        
        return road
    
    def update_player(self):
        if self.keys['up']:
            self.speed = min(self.speed + self.acceleration, self.max_speed)
        elif self.keys['down']:
            self.speed = max(self.speed - self.acceleration, -self.max_speed/2)
        else:
            if self.speed > 0:
                self.speed = max(self.speed - self.deceleration, 0)
            elif self.speed < 0:
                self.speed = min(self.speed + self.deceleration, 0)
        
        if self.keys['right']:
            self.player_x -= self.turn_speed * (1 + abs(self.speed)/2)
        if self.keys['left']:
            self.player_x += self.turn_speed * (1 + abs(self.speed)/2)
        
        self.player_x = max(-self.road_width/2 + 1, min(self.road_width/2 - 1, self.player_x))
        self.player_z += self.speed
        self.score = int(self.player_z / 10)
    
    def update_obstacles(self):
        if random.random() < 0.02 and self.speed > 0.5:
            spawn_z = self.player_z + 100
            spawn_x = random.uniform(-self.road_width/2 + 2, self.road_width/2 - 2)
            self.obstacles.append({'x': spawn_x, 'z': spawn_z})
        
        for obs in self.obstacles:
            obs['z'] -= self.speed
        
        self.obstacles = [obs for obs in self.obstacles if obs['z'] > self.player_z - 20]
    
    def check_collision(self):
        car_width = 1
        car_length = 2
        
        for obs in self.obstacles:
            dx = abs(self.player_x - obs['x'])
            dz = abs(self.player_z - obs['z'])
            
            if dx < car_width + 0.75 and dz < car_length + 0.75:
                return True
        return False
    
    def render(self):
        turtle.clear()
        
        scene = []
        
        visible_road_start = int(self.player_z / 20) - 1
        visible_road_end = visible_road_start + 10
        
        for i in range(visible_road_start, visible_road_end):
            z = i * 20
            scene.extend(self.create_road_segment(z))
        
        for obs in self.obstacles:
            if obs['z'] < self.player_z + 80 and obs['z'] > self.player_z - 10:
                scene.extend(self.create_obstacle(obs['x'], obs['z']))
        
        scene.extend(self.create_car(self.player_x, self.player_z, '#FF0000'))
        
        self.cam.setposition([self.player_x, 5, self.player_z - 8])
        self.cam.setdirection([0, -0.5, 1])
        
        self.cam.draw_from_scene(scene)
        
        self.cam.write([self.player_x - 15, 8, self.player_z], f'分数: {self.score}', font=("Arial", 16, "bold"))
        self.cam.write([self.player_x - 15, 6, self.player_z], f'速度: {int(self.speed*50)}', font=("Arial", 16, "bold"))
        
        if self.game_over:
            self.cam.write([self.player_x - 5, 0, self.player_z + 10], '游戏结束!', font=("Arial", 24, "bold"))
            self.cam.write([self.player_x - 8, -2, self.player_z + 10], '按R键重新开始', font=("Arial", 16, "bold"))
        
        turtle.update()
    
    def reset_game(self):
        self.player_x = 0
        self.player_z = 0
        self.speed = 0
        self.obstacles = []
        self.score = 0
        self.game_over = False
    
    def game_loop(self):
        if not self.game_over:
            self.update_player()
            self.update_obstacles()
            
            if self.check_collision():
                self.game_over = True
                self.speed = 0
        
        self.render()
        
        if self.game_over:
            def restart():
                self.reset_game()
            turtle.onkeypress(restart, 'r')
            turtle.onkeypress(restart, 'R')
        
        turtle.ontimer(self.game_loop, 30)
    
    def start(self):
        turtle.setup(1000, 800)
        turtle.bgcolor('#87CEEB')
        self.cam.done()

if __name__ == '__main__':
    game = RacingGame()
    game.start()
