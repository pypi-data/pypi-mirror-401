from __future__ import annotations
import phoenix5._ctre
import typing
import wpimath.geometry._geometry
import wpiutil._wpiutil
__all__: list[str] = ['BasePigeon', 'BasePigeonConfigUtils', 'BasePigeonConfiguration', 'BasePigeonSimCollection', 'PigeonIMU', 'PigeonIMUConfigUtils', 'PigeonIMUConfiguration', 'PigeonIMU_ControlFrame', 'PigeonIMU_Faults', 'PigeonIMU_StatusFrame', 'PigeonIMU_StickyFaults', 'SensorVelocityMeasPeriod', 'WPI_PigeonIMU']
class BasePigeon(phoenix5._ctre.CANBusAddressable):
    """
    Pigeon IMU Class.
    Class supports communicating over CANbus and over ribbon-cable (CAN Talon SRX).
    """
    @staticmethod
    def destroyAllBasePigeons() -> None:
        """
        Destructs all pigeon objects
        """
    def __init__(self, deviceNumber: typing.SupportsInt, version: str, canbus: str = '') -> None:
        """
        Create a Pigeon object that communicates with Pigeon on CAN Bus.
        
        :param deviceNumber: CAN Device Id of Pigeon [0,62]
        :param canbus:       Name of the CANbus; can be a SocketCAN interface (on Linux),
                             or a CANivore device name or serial number
        """
    def addYaw(self, angleDeg: typing.SupportsFloat, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Atomically add to the Yaw register.
        
        :param angleDeg:  Degrees to add to the Yaw register.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearStickyFaults(self, timeoutMs: typing.SupportsInt = 0) -> phoenix5._ctre.ErrorCode:
        """
        Clears the Sticky Faults
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAllSettings(self, allConfigs: BasePigeonConfiguration, timeoutMs: typing.SupportsInt = 50) -> phoenix5._ctre.ErrorCode:
        """
        Configures all persistent settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: typing.SupportsInt = 50) -> phoenix5._ctre.ErrorCode:
        """
        Configures all persistent settings to defaults.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: typing.SupportsInt, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Gets the value of a custom parameter. This is for arbitrary use.
        
        Sometimes it is necessary to save calibration/declination/offset
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.
        
        :param paramIndex: Index of custom parameter. [0-1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: phoenix5._ctre.ParamEnum, ordinal: typing.SupportsInt, timeoutMs: typing.SupportsInt = 0) -> float:
        """
        Gets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.
        
        :param param:     Parameter enumeration.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Value of parameter.
        """
    @typing.overload
    def configGetParameter(self, param: phoenix5._ctre.ParamEnum, valueToSend: typing.SupportsInt, ordinal: typing.SupportsInt, timeoutMs: typing.SupportsInt) -> tuple[phoenix5._ctre.ErrorCode, int, int]:
        """
        Gets a parameter by passing an int by reference
        
        :param param:         Parameter enumeration
        :param valueToSend:   Value to send to parameter
        :param valueReceived: Reference to integer to receive
        :param subValue:      SubValue of parameter
        :param ordinal:       Ordinal of parameter
        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetCustomParam(self, newValue: typing.SupportsInt, paramIndex: typing.SupportsInt, timeoutMs: typing.SupportsInt = 0) -> phoenix5._ctre.ErrorCode:
        """
        Sets the value of a custom parameter. This is for arbitrary use.
        
        Sometimes it is necessary to save calibration/declination/offset
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.
        
        :param newValue:   Value for custom parameter.
        :param paramIndex: Index of custom parameter. [0-1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: phoenix5._ctre.ParamEnum, value: typing.SupportsFloat, subValue: typing.SupportsInt, ordinal: typing.SupportsInt, timeoutMs: typing.SupportsInt = 0) -> phoenix5._ctre.ErrorCode:
        """
        Sets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.
        
        :param param:     Parameter enumeration.
        :param value:     Value of parameter.
        :param subValue:  Subvalue for parameter. Maximum value of 255.
        :param ordinal:   Ordinal of parameter.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def get6dQuaternion(self) -> tuple[phoenix5._ctre.ErrorCode, typing.Annotated[list[float], "FixedSize(4)"]]:
        """
        Get 6d Quaternion data.
        
        :param wxyz: Array to fill with quaternion data w[0], x[1], y[2], z[3]
        
        :returns: The last ErrorCode generated.
        """
    def getAbsoluteCompassHeading(self) -> float:
        """
        Get the absolute compass heading.
        
        :returns: compass heading [0,360) degrees.
        """
    def getAccumGyro(self) -> tuple[int, typing.Annotated[list[float], "FixedSize(3)"]]:
        """
        Get AccumGyro data.
        AccumGyro is the integrated gyro value on each axis.
        
        :param xyz_deg: Array to fill with x[0], y[1], and z[2] AccumGyro data
        
        :returns: The last ErrorCode generated.
        """
    def getAllConfigs(self, allConfigs: BasePigeonConfiguration, timeoutMs: typing.SupportsInt = 50) -> None:
        """
        Gets all persistant settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getBiasedAccelerometer(self) -> tuple[int, typing.Annotated[list[int], "FixedSize(3)"]]:
        """
        Get Biased Accelerometer data.
        
        :param ba_xyz: Array to fill with x[0], y[1], and z[2] data.
                       These are in fixed point notation Q2.14.  eg. 16384 = 1G
        
        :returns: The last ErrorCode generated.
        """
    def getBiasedMagnetometer(self) -> tuple[int, typing.Annotated[list[int], "FixedSize(3)"]]:
        """
        Get Biased Magnetometer data.
        
        :param bm_xyz: Array to fill with x[0], y[1], and z[2] data
                       Number is equal to 0.6 microTeslas per unit.
        
        :returns: The last ErrorCode generated.
        """
    def getCompassFieldStrength(self) -> float:
        """
        Gets the compass' measured magnetic field strength.
        
        :returns: field strength in Microteslas (uT).
        """
    def getCompassHeading(self) -> float:
        """
        Get the continuous compass heading.
        
        :returns: continuous compass heading [-23040, 23040) degrees. Use
                  SetCompassHeading to modify the wrap-around portion.
        """
    def getFirmVers(self) -> int:
        """
        :returns: firmware version of Pigeon
        """
    def getFirmwareVersion(self) -> int:
        """
        Gets the firmware version of the device.
        
        :returns: param holds the firmware version of the device. Device must be powered
                  cycled at least once.
        """
    def getLastError(self) -> phoenix5._ctre.ErrorCode:
        """
        Call GetLastError() generated by this object.
        Not all functions return an error code but can
        potentially report errors.
        
        This function can be used to retrieve those error codes.
        
        :returns: The last ErrorCode generated.
        """
    def getPitch(self) -> float:
        """
        Get the pitch from the Pigeon
        
        :returns: Pitch
        """
    def getRawGyro(self) -> tuple[int, typing.Annotated[list[float], "FixedSize(3)"]]:
        """
        Get Raw Gyro data.
        
        :param xyz_dps: Array to fill with x[0], y[1], and z[2] data in degrees per second.
        
        :returns: The last ErrorCode generated.
        """
    def getRawMagnetometer(self) -> tuple[int, typing.Annotated[list[int], "FixedSize(3)"]]:
        """
        Get Raw Magnetometer data.
        
        :param rm_xyz: Array to fill with x[0], y[1], and z[2] data
                       Number is equal to 0.6 microTeslas per unit.
        
        :returns: The last ErrorCode generated.
        """
    def getResetCount(self) -> int:
        """
        :returns: number of times Pigeon Reset
        """
    def getResetFlags(self) -> int:
        """
        :returns: Reset flags for Pigeon
        """
    def getRoll(self) -> float:
        """
        Get the roll from the Pigeon
        
        :returns: Roll
        """
    def getSimCollection(self) -> BasePigeonSimCollection:
        """
        :returns: object that can set simulation inputs.
        """
    def getStatusFramePeriod(self, frame: PigeonIMU_StatusFrame, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    def getTemp(self) -> float:
        """
        Gets the temperature of the pigeon.
        
        :returns: Temperature in ('C)
        """
    def getUpTime(self) -> int:
        """
        Gets the current Pigeon uptime.
        
        :returns: How long has Pigeon been running in whole seconds. Value caps at
                  255.
        """
    def getYaw(self) -> float:
        """
        Get the yaw from the Pigeon
        
        :returns: Yaw
        """
    def getYawPitchRoll(self) -> tuple[phoenix5._ctre.ErrorCode, typing.Annotated[list[float], "FixedSize(3)"]]:
        """
        Get Yaw, Pitch, and Roll data.
        
        :param ypr: Array to fill with yaw[0], pitch[1], and roll[2] data.
                    *					Yaw is within [-368,640, +368,640] degrees.
                    *					Pitch is within [-90,+90] degrees.
                    *					Roll is within [-90,+90] degrees.
        
        :returns: The last ErrorCode generated.
        """
    def hasResetOccurred(self) -> bool:
        """
        :returns: true iff a reset has occurred since last call.
        """
    def setAccumZAngle(self, angleDeg: typing.SupportsFloat, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Sets the AccumZAngle.
        
        :param angleDeg:  Degrees to set AccumZAngle to.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setControlFramePeriod(self, frame: PigeonIMU_ControlFrame, periodMs: typing.SupportsInt) -> phoenix5._ctre.ErrorCode:
        """
        Sets the period of the given control frame.
        
        :param frame:    Frame whose period is to be changed.
        :param periodMs: Period in ms for the given frame.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setStatusFramePeriod(self, statusFrame: PigeonIMU_StatusFrame, periodMs: typing.SupportsInt, timeoutMs: typing.SupportsInt = 0) -> phoenix5._ctre.ErrorCode:
        """
        Sets the period of the given status frame.
        
        :param statusFrame: Frame whose period is to be changed.
        :param periodMs:    Period in ms for the given frame.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setYaw(self, angleDeg: typing.SupportsFloat, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Sets the Yaw register to the specified value.
        
        :param angleDeg:  Degree of Yaw  [+/- 368,640 degrees]
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setYawToCompass(self, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Sets the Yaw register to match the current compass value.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
class BasePigeonConfigUtils:
    """
    Util class to help with Pigeon configurations
    """
    @staticmethod
    def customParam0Different(settings: BasePigeonConfiguration) -> bool:
        """
        Determine if specified value is different from default
        
        :param settings: settings to compare against
        
        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def customParam1Different(settings: BasePigeonConfiguration) -> bool:
        ...
    def __init__(self) -> None:
        ...
class BasePigeonConfiguration(phoenix5._ctre.CustomParamConfiguration):
    """
    Configurables available to Pigeon
    """
    def __init__(self) -> None:
        ...
    @typing.overload
    def toString(self) -> str:
        """
        :returns: String representation of configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to configs
        
        :returns: String representation of configs
        """
class BasePigeonSimCollection:
    """
    Collection of simulation functions available to a Pigeon IMU.
    Use the getSimCollection() function in your BasePigeon object to create the respective sim collection.
    """
    def __init__(self, pigeon: BasePigeon, isRibbonCable: bool) -> None:
        """
        :param pigeon: Pigeon IMU to connect so sim collection
        """
    def addHeading(self, dHeading: typing.SupportsFloat) -> phoenix5._ctre.ErrorCode:
        """
        Adds to the simulated heading of the Pigeon IMU
        
        :param dHeading: the change in heading in degrees
        
        :returns: error code
        """
    def setRawHeading(self, newHeading: typing.SupportsFloat) -> phoenix5._ctre.ErrorCode:
        """
        Sets the simulated input heading position of the Pigeon IMU.
        
        The Pigeon IMU integrates the delta between each new raw heading value and uses
        this to calculate the true reported yaw and fused heading.
        
        When using the WPI Sim GUI, you will notice a readonly 'yaw' and
        settable 'RawHeading'.  The readonly signal is the emulated yaw
        which will match self-test in Tuner and the hardware API.  Changes to
        'RawHeading' will be integrated into the emulated yaw.  This way
        a simulator can modify the heading without overriding your
        hardware API calls for home-ing your sensor.
        
        Inputs to this function over time should be continuous,
        as user calls of setYaw() or setFusedHeading()
        will be accounted for in the calculation.
        
        :param newHeading: the new input heading in degrees
        
        :returns: error code
        """
class PigeonIMU(BasePigeon):
    """
    Pigeon IMU Class.
    Class supports communicating over CANbus and over ribbon-cable (CAN Talon SRX).
    """
    class CalibrationMode:
        """
        Various calibration modes supported by Pigeon.
        
        Note that you can instead use Phoenix Tuner to accomplish certain calibrations.
        
        Members:
        
          BootTareGyroAccel : Boot-Calibrate the pigeon
        
          Temperature : Temperature-Calibrate the pigeon
        
          Magnetometer12Pt : Magnetometer-Calibrate the pigeon using the 12pt process
        
          Magnetometer360 : Magnetometer-Calibrate the pigeon using 360 turns
        
          Accelerometer : Calibrate the pigeon accelerometer
        """
        Accelerometer: typing.ClassVar[PigeonIMU.CalibrationMode]  # value = <CalibrationMode.Accelerometer: 5>
        BootTareGyroAccel: typing.ClassVar[PigeonIMU.CalibrationMode]  # value = <CalibrationMode.BootTareGyroAccel: 0>
        Magnetometer12Pt: typing.ClassVar[PigeonIMU.CalibrationMode]  # value = <CalibrationMode.Magnetometer12Pt: 2>
        Magnetometer360: typing.ClassVar[PigeonIMU.CalibrationMode]  # value = <CalibrationMode.Magnetometer360: 3>
        Temperature: typing.ClassVar[PigeonIMU.CalibrationMode]  # value = <CalibrationMode.Temperature: 1>
        __members__: typing.ClassVar[dict[str, PigeonIMU.CalibrationMode]]  # value = {'BootTareGyroAccel': <CalibrationMode.BootTareGyroAccel: 0>, 'Temperature': <CalibrationMode.Temperature: 1>, 'Magnetometer12Pt': <CalibrationMode.Magnetometer12Pt: 2>, 'Magnetometer360': <CalibrationMode.Magnetometer360: 3>, 'Accelerometer': <CalibrationMode.Accelerometer: 5>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: typing.SupportsInt) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: typing.SupportsInt) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class FusionStatus:
        """
        Data object for holding fusion information.
        """
        def __init__(self) -> None:
            ...
        @property
        def bIsFusing(self) -> bool:
            """
            Whether the pigeon is fusing
            """
        @bIsFusing.setter
        def bIsFusing(self, arg0: bool) -> None:
            ...
        @property
        def bIsValid(self) -> bool:
            """
            Whether the fusion is valid
            """
        @bIsValid.setter
        def bIsValid(self, arg0: bool) -> None:
            ...
        @property
        def description(self) -> str:
            """
            Description of fusion status
            """
        @description.setter
        def description(self, arg0: str) -> None:
            ...
        @property
        def heading(self) -> float:
            """
            Fused Heading
            """
        @heading.setter
        def heading(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def lastError(self) -> int:
            """
            Same as GetLastError()
            """
        @lastError.setter
        def lastError(self, arg0: typing.SupportsInt) -> None:
            ...
    class GeneralStatus:
        """
        Data object for status on current calibration and general status.
        
        Pigeon has many calibration modes supported for a variety of uses.
        The modes generally collects and saves persistently information that makes
        the Pigeon signals more accurate.  This includes collecting temperature, gyro, accelerometer,
        and compass information.
        
        For FRC use-cases, typically compass and temperature calibration is not required.
        
        Additionally when motion driver software in the Pigeon boots, it will perform a fast boot calibration
        to initially bias gyro and setup accelerometer.
        
        These modes can be enabled with the EnterCalibration mode.
        
        When a calibration mode is entered, caller can expect...
        
        - PigeonState to reset to Initializing and bCalIsBooting is set to true.  Pigeon LEDs will blink the boot pattern.
        This is similar to the normal boot cal, however it can an additional ~30 seconds since calibration generally
        requires more information.
        currentMode will reflect the user's selected calibration mode.
        
        - PigeonState will eventually settle to UserCalibration and Pigeon LEDs will show cal specific blink patterns.
        bCalIsBooting is now false.
        
        - Follow the instructions in the Pigeon User Manual to meet the calibration specific requirements.
        When finished calibrationError will update with the result.
        Pigeon will solid-fill LEDs with red (for failure) or green (for success) for ~5 seconds.
        Pigeon then perform boot-cal to cleanly apply the newly saved calibration data.
        """
        def __init__(self) -> None:
            ...
        @property
        def bCalIsBooting(self) -> bool:
            """
            After caller requests a calibration mode, pigeon will perform a boot-cal before
            entering the requested mode.  During this period, this flag is set to true.
            """
        @bCalIsBooting.setter
        def bCalIsBooting(self, arg0: bool) -> None:
            ...
        @property
        def calibrationError(self) -> int:
            """
            The error code for the last calibration mode.
            Zero represents a successful cal (with solid green LEDs at end of cal)
            and nonzero is a failed calibration (with solid red LEDs at end of cal).
            Different calibration
            """
        @calibrationError.setter
        def calibrationError(self, arg0: typing.SupportsInt) -> None:
            ...
        @property
        def currentMode(self) -> PigeonIMU.CalibrationMode:
            """
            The currently applied calibration mode if state is in UserCalibration or if bCalIsBooting is true.
            Otherwise it holds the last selected calibration mode (when calibrationError was updated).
            """
        @currentMode.setter
        def currentMode(self, arg0: PigeonIMU.CalibrationMode) -> None:
            ...
        @property
        def description(self) -> str:
            """
            general string description of current status
            """
        @description.setter
        def description(self, arg0: str) -> None:
            ...
        @property
        def lastError(self) -> int:
            """
            Same as GetLastError()
            """
        @lastError.setter
        def lastError(self, arg0: typing.SupportsInt) -> None:
            ...
        @property
        def noMotionBiasCount(self) -> int:
            """
            Number of times the Pigeon has automatically rebiased the gyro.
            This counter overflows from 15 -> 0 with no cap.
            """
        @noMotionBiasCount.setter
        def noMotionBiasCount(self, arg0: typing.SupportsInt) -> None:
            ...
        @property
        def state(self) -> PigeonIMU.PigeonState:
            """
            The current state of the motion driver.  This reflects if the sensor signals are accurate.
            Most calibration modes will force Pigeon to reinit the motion driver.
            """
        @state.setter
        def state(self, arg0: PigeonIMU.PigeonState) -> None:
            ...
        @property
        def tempC(self) -> float:
            """
            Temperature in Celsius
            """
        @tempC.setter
        def tempC(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def tempCompensationCount(self) -> int:
            """
            Number of times the Pigeon has temperature compensated the various signals.
            This counter overflows from 15 -> 0 with no cap.
            """
        @tempCompensationCount.setter
        def tempCompensationCount(self, arg0: typing.SupportsInt) -> None:
            ...
        @property
        def upTimeSec(self) -> int:
            """
            Number of seconds Pigeon has been up (since boot).
            This register is reset on power boot or processor reset.
            Register is capped at 255 seconds with no wrap around.
            """
        @upTimeSec.setter
        def upTimeSec(self, arg0: typing.SupportsInt) -> None:
            ...
    class PigeonState:
        """
        Overall state of the Pigeon.
        
        Members:
        
          NoComm : No communications with Pigeon
        
          Initializing : Pigeon is initializing
        
          Ready : Pigeon is ready
        
          UserCalibration : Pigeon is calibrating due to user
        """
        Initializing: typing.ClassVar[PigeonIMU.PigeonState]  # value = <PigeonState.Initializing: 1>
        NoComm: typing.ClassVar[PigeonIMU.PigeonState]  # value = <PigeonState.NoComm: 0>
        Ready: typing.ClassVar[PigeonIMU.PigeonState]  # value = <PigeonState.Ready: 2>
        UserCalibration: typing.ClassVar[PigeonIMU.PigeonState]  # value = <PigeonState.UserCalibration: 3>
        __members__: typing.ClassVar[dict[str, PigeonIMU.PigeonState]]  # value = {'NoComm': <PigeonState.NoComm: 0>, 'Initializing': <PigeonState.Initializing: 1>, 'Ready': <PigeonState.Ready: 2>, 'UserCalibration': <PigeonState.UserCalibration: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: typing.SupportsInt) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: typing.SupportsInt) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    @staticmethod
    @typing.overload
    def toString(state: PigeonIMU.PigeonState) -> str:
        """
        Gets the string representation of a PigeonState
        
        :param state: PigeonState to get the string representation of
        
        :returns: string representation of specified PigeonState
        """
    @staticmethod
    @typing.overload
    def toString(cm: PigeonIMU.CalibrationMode) -> str:
        """
        Gets the string representation of a CalibrationMode
        
        :param cm: CalibrationMode to get the string representation of
        
        :returns: string representation of specified CalibrationMode
        """
    @typing.overload
    def __init__(self, deviceNumber: typing.SupportsInt) -> None:
        """
        Create a Pigeon object that communicates with Pigeon on CAN Bus.
        
        :param deviceNumber: CAN Device Id of Pigeon [0,62]
        """
    @typing.overload
    def __init__(self, talonSrx: phoenix5._ctre.TalonSRX) -> None:
        """
        Create a Pigeon object that communciates with Pigeon through the
        Gadgeteer ribbon cable connected to a Talon on CAN Bus.
        
        :param talonSrx: Object for the TalonSRX connected via ribbon cable.
        """
    def addFusedHeading(self, angleDeg: typing.SupportsFloat, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Atomically add to the Fused Heading register.
        
        :param angleDeg:  Degrees to add to the Fused Heading register.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearStickyFaults(self, timeoutMs: typing.SupportsInt = 0) -> phoenix5._ctre.ErrorCode:
        """
        Clears the Sticky Faults
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAllSettings(self, allConfigs: PigeonIMUConfiguration, timeoutMs: typing.SupportsInt = 50) -> phoenix5._ctre.ErrorCode:
        """
        Configures all persistent settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: typing.SupportsInt = 50) -> phoenix5._ctre.ErrorCode:
        """
        Configures all persistent settings to defaults.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetCustomParam(self, newValue: typing.SupportsInt, paramIndex: typing.SupportsInt, timeoutMs: typing.SupportsInt = 0) -> phoenix5._ctre.ErrorCode:
        """
        Sets the value of a custom parameter. This is for arbitrary use.
        
        Sometimes it is necessary to save calibration/declination/offset
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.
        
        :param newValue:   Value for custom parameter.
        :param paramIndex: Index of custom parameter. [0-1]
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def enterCalibrationMode(self, calMode: PigeonIMU.CalibrationMode, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Enters the Calbration mode.  See the Pigeon IMU documentation for More
        information on Calibration.
        
        Note that you can instead use Phoenix Tuner to accomplish this.
        Note you should NOT be calling this during normal robot operation.
        
        :param calMode:   Calibration to execute
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getAccelerometerAngles(self) -> tuple[int, typing.Annotated[list[float], "FixedSize(3)"]]:
        """
        Get Accelerometer tilt angles.
        
        :param tiltAngles: Array to fill with x[0], y[1], and z[2] angles in degrees.
        
        :returns: The last ErrorCode generated.
        """
    def getAllConfigs(self, allConfigs: PigeonIMUConfiguration, timeoutMs: typing.SupportsInt = 50) -> None:
        """
        Gets all persistant settings.
        
        :param allConfigs: Object with all of the persistant settings
        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.
        """
    def getFaults(self, toFill: PigeonIMU_Faults) -> phoenix5._ctre.ErrorCode:
        """
        Gets the fault status
        
        :param toFill: Container for fault statuses.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getFirmwareVersion(self) -> int:
        """
        Gets the firmware version of the device.
        
        :returns: param holds the firmware version of the device. Device must be powered
                  cycled at least once.
        """
    @typing.overload
    def getFusedHeading(self, status: PigeonIMU.FusionStatus) -> float:
        """
        Get the current Fusion Status (including fused heading)
        
        :param status: object reference to fill with fusion status flags.
                       *					Caller may pass null if flags are not needed.
        
        :returns: The fused heading in degrees.
        """
    @typing.overload
    def getFusedHeading(self) -> float:
        """
        Gets the Fused Heading
        
        :returns: The fused heading in degrees.
        """
    def getGeneralStatus(self, statusToFill: PigeonIMU.GeneralStatus) -> int:
        """
        Get the status of the current (or previousley complete) calibration.
        
        :param out: statusToFill Container for the status information.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getResetCount(self) -> int:
        """
        :returns: number of times Pigeon Reset
        """
    def getResetFlags(self) -> int:
        """
        :returns: Reset flags for Pigeon
        """
    def getState(self) -> PigeonIMU.PigeonState:
        """
        Gets the current Pigeon state
        
        :returns: PigeonState enum
        """
    def getStatusFramePeriod(self, frame: PigeonIMU_StatusFrame, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Gets the period of the given status frame.
        
        :param frame:     Frame to get the period of.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: PigeonIMU_StickyFaults) -> phoenix5._ctre.ErrorCode:
        """
        Gets the sticky fault status
        
        :param toFill: Container for sticky fault statuses.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setCompassAngle(self, angleDeg: typing.SupportsFloat, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Sets the compass angle. Although compass is absolute [0,360) degrees, the
        continuous compass register holds the wrap-arounds.
        
        :param angleDeg:  Degrees to set continuous compass angle to.
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setCompassDeclination(self, angleDegOffset: typing.SupportsFloat, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Set the declination for compass. Declination is the difference between
        Earth Magnetic north, and the geographic "True North".
        
        :param angleDegOffset: Degrees to set Compass Declination to.
        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setControlFramePeriod(self, frame: PigeonIMU_ControlFrame, periodMs: typing.SupportsInt) -> phoenix5._ctre.ErrorCode:
        """
        Sets the period of the given control frame.
        
        :param frame:    Frame whose period is to be changed.
        :param periodMs: Period in ms for the given frame.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setFusedHeading(self, angleDeg: typing.SupportsFloat, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Sets the Fused Heading to the specified value.
        
        :param angleDeg:  New fused-heading in degrees [+/- 23,040 degrees]
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setFusedHeadingToCompass(self, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Sets the Fused Heading register to match the current compass value.
        
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setStatusFramePeriod(self, statusFrame: PigeonIMU_StatusFrame, periodMs: typing.SupportsInt, timeoutMs: typing.SupportsInt = 0) -> phoenix5._ctre.ErrorCode:
        """
        Sets the period of the given status frame.
        
        :param statusFrame: Frame whose period is to be changed.
        :param periodMs:    Period in ms for the given frame.
        :param timeoutMs:   Timeout value in ms. If nonzero, function will wait for
                            config success and report an error if it times out.
                            If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setTemperatureCompensationDisable(self, bTempCompDisable: bool, timeoutMs: typing.SupportsInt = 0) -> int:
        """
        Disable/Enable Temp compensation. Pigeon has this on/False at boot.
        
        :param bTempCompDisable: Set to "False" to enable temperature compensation.
        :param timeoutMs:        Timeout value in ms. If nonzero, function will wait for
                                 config success and report an error if it times out.
                                 If zero, no blocking or checking is performed.
        
        :returns: Error Code generated by function. 0 indicates no error.
        """
class PigeonIMUConfigUtils(BasePigeonConfigUtils):
    """
    Util class to help with Pigeon configurations
    """
    def __init__(self) -> None:
        ...
class PigeonIMUConfiguration(BasePigeonConfiguration):
    """
    Configurables available to Pigeon
    """
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        """
        :returns: String representation of configs
        """
    def toString(self, prependString: str) -> str:
        """
        :param prependString: String to prepend to configs
        
        :returns: String representation of configs
        """
class PigeonIMU_ControlFrame:
    """
    Enumerated type for status frame types.
    
    Members:
    
      PigeonIMU_CondStatus_Control_1
    """
    PigeonIMU_CondStatus_Control_1: typing.ClassVar[PigeonIMU_ControlFrame]  # value = <PigeonIMU_ControlFrame.PigeonIMU_CondStatus_Control_1: 272384>
    __members__: typing.ClassVar[dict[str, PigeonIMU_ControlFrame]]  # value = {'PigeonIMU_CondStatus_Control_1': <PigeonIMU_ControlFrame.PigeonIMU_CondStatus_Control_1: 272384>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class PigeonIMU_Faults:
    @typing.overload
    def __init__(self, bits: typing.SupportsInt) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def hasAnyFault(self) -> bool:
        ...
    def toBitfield(self) -> int:
        ...
    def update(self, bits: typing.SupportsInt) -> None:
        ...
class PigeonIMU_StatusFrame:
    """
    Enumerated type for status frame types.
    
    Members:
    
      PigeonIMU_CondStatus_1_General
    
      PigeonIMU_CondStatus_9_SixDeg_YPR
    
      PigeonIMU_CondStatus_6_SensorFusion
    
      PigeonIMU_CondStatus_11_GyroAccum
    
      PigeonIMU_CondStatus_2_GeneralCompass
    
      PigeonIMU_CondStatus_3_GeneralAccel
    
      PigeonIMU_CondStatus_10_SixDeg_Quat
    
      PigeonIMU_RawStatus_4_Mag
    
      PigeonIMU_BiasedStatus_2_Gyro
    
      PigeonIMU_BiasedStatus_4_Mag
    
      PigeonIMU_BiasedStatus_6_Accel
    """
    PigeonIMU_BiasedStatus_2_Gyro: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_BiasedStatus_2_Gyro: 269376>
    PigeonIMU_BiasedStatus_4_Mag: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_RawStatus_4_Mag: 269504>
    PigeonIMU_BiasedStatus_6_Accel: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_BiasedStatus_6_Accel: 269632>
    PigeonIMU_CondStatus_10_SixDeg_Quat: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_10_SixDeg_Quat: 270912>
    PigeonIMU_CondStatus_11_GyroAccum: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_11_GyroAccum: 270976>
    PigeonIMU_CondStatus_1_General: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_1_General: 270336>
    PigeonIMU_CondStatus_2_GeneralCompass: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_2_GeneralCompass: 270400>
    PigeonIMU_CondStatus_3_GeneralAccel: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_3_GeneralAccel: 270464>
    PigeonIMU_CondStatus_6_SensorFusion: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_6_SensorFusion: 270656>
    PigeonIMU_CondStatus_9_SixDeg_YPR: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_9_SixDeg_YPR: 270848>
    PigeonIMU_RawStatus_4_Mag: typing.ClassVar[PigeonIMU_StatusFrame]  # value = <PigeonIMU_StatusFrame.PigeonIMU_RawStatus_4_Mag: 269504>
    __members__: typing.ClassVar[dict[str, PigeonIMU_StatusFrame]]  # value = {'PigeonIMU_CondStatus_1_General': <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_1_General: 270336>, 'PigeonIMU_CondStatus_9_SixDeg_YPR': <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_9_SixDeg_YPR: 270848>, 'PigeonIMU_CondStatus_6_SensorFusion': <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_6_SensorFusion: 270656>, 'PigeonIMU_CondStatus_11_GyroAccum': <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_11_GyroAccum: 270976>, 'PigeonIMU_CondStatus_2_GeneralCompass': <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_2_GeneralCompass: 270400>, 'PigeonIMU_CondStatus_3_GeneralAccel': <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_3_GeneralAccel: 270464>, 'PigeonIMU_CondStatus_10_SixDeg_Quat': <PigeonIMU_StatusFrame.PigeonIMU_CondStatus_10_SixDeg_Quat: 270912>, 'PigeonIMU_RawStatus_4_Mag': <PigeonIMU_StatusFrame.PigeonIMU_RawStatus_4_Mag: 269504>, 'PigeonIMU_BiasedStatus_2_Gyro': <PigeonIMU_StatusFrame.PigeonIMU_BiasedStatus_2_Gyro: 269376>, 'PigeonIMU_BiasedStatus_4_Mag': <PigeonIMU_StatusFrame.PigeonIMU_RawStatus_4_Mag: 269504>, 'PigeonIMU_BiasedStatus_6_Accel': <PigeonIMU_StatusFrame.PigeonIMU_BiasedStatus_6_Accel: 269632>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class PigeonIMU_StickyFaults:
    @typing.overload
    def __init__(self, bits: typing.SupportsInt) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def hasAnyFault(self) -> bool:
        ...
    def toBitfield(self) -> int:
        ...
    def update(self, bits: typing.SupportsInt) -> None:
        ...
class SensorVelocityMeasPeriod:
    """
    Enumerate filter periods for any sensor that measures velocity.
    
    Members:
    
      Period_1Ms : 1ms velocity measurement period
    
      Period_2Ms : 2ms velocity measurement period
    
      Period_5Ms : 5ms velocity measurement period
    
      Period_10Ms : 10ms velocity measurement period
    
      Period_20Ms : 20ms velocity measurement period
    
      Period_25Ms : 25ms velocity measurement period
    
      Period_50Ms : 50ms velocity measurement period
    
      Period_100Ms : 100ms velocity measurement period
    """
    Period_100Ms: typing.ClassVar[SensorVelocityMeasPeriod]  # value = <SensorVelocityMeasPeriod.Period_100Ms: 100>
    Period_10Ms: typing.ClassVar[SensorVelocityMeasPeriod]  # value = <SensorVelocityMeasPeriod.Period_10Ms: 10>
    Period_1Ms: typing.ClassVar[SensorVelocityMeasPeriod]  # value = <SensorVelocityMeasPeriod.Period_1Ms: 1>
    Period_20Ms: typing.ClassVar[SensorVelocityMeasPeriod]  # value = <SensorVelocityMeasPeriod.Period_20Ms: 20>
    Period_25Ms: typing.ClassVar[SensorVelocityMeasPeriod]  # value = <SensorVelocityMeasPeriod.Period_25Ms: 25>
    Period_2Ms: typing.ClassVar[SensorVelocityMeasPeriod]  # value = <SensorVelocityMeasPeriod.Period_2Ms: 2>
    Period_50Ms: typing.ClassVar[SensorVelocityMeasPeriod]  # value = <SensorVelocityMeasPeriod.Period_50Ms: 50>
    Period_5Ms: typing.ClassVar[SensorVelocityMeasPeriod]  # value = <SensorVelocityMeasPeriod.Period_5Ms: 5>
    __members__: typing.ClassVar[dict[str, SensorVelocityMeasPeriod]]  # value = {'Period_1Ms': <SensorVelocityMeasPeriod.Period_1Ms: 1>, 'Period_2Ms': <SensorVelocityMeasPeriod.Period_2Ms: 2>, 'Period_5Ms': <SensorVelocityMeasPeriod.Period_5Ms: 5>, 'Period_10Ms': <SensorVelocityMeasPeriod.Period_10Ms: 10>, 'Period_20Ms': <SensorVelocityMeasPeriod.Period_20Ms: 20>, 'Period_25Ms': <SensorVelocityMeasPeriod.Period_25Ms: 25>, 'Period_50Ms': <SensorVelocityMeasPeriod.Period_50Ms: 50>, 'Period_100Ms': <SensorVelocityMeasPeriod.Period_100Ms: 100>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class WPI_PigeonIMU(PigeonIMU, wpiutil._wpiutil.Sendable):
    @typing.overload
    def __init__(self, deviceNumber: typing.SupportsInt) -> None:
        """
        Construtor for WPI_PigeonIMU.
        
        :param deviceNumber: CAN Device ID of the Pigeon IMU.
        """
    @typing.overload
    def __init__(self, talon: phoenix5._ctre.TalonSRX) -> None:
        """
        Construtor for WPI_PigeonIMU.
        
        :param talon: The Talon SRX ribbon-cabled to Pigeon.
        """
    def getAngle(self) -> float:
        """
        Returns the heading of the robot in degrees.
        
        The angle increases as the Pigeon IMU turns clockwise when looked
        at from the top. This follows the NED axis convention.
        
        \\details The angle is continuous; that is, it will continue from
        360 to 361 degrees. This allows for algorithms that wouldn't want
        to see a discontinuity in the gyro output as it sweeps past from
        360 to 0 on the second time around.
        
        :returns: The current heading of the robot in degrees
        """
    def getRate(self) -> float:
        """
        Returns the rate of rotation of the Pigeon IMU.
        
        The rate is positive as the Pigeon IMU turns clockwise when looked
        at from the top.
        
        :returns: The current rate in degrees per second
        """
    def getRotation2d(self) -> wpimath.geometry._geometry.Rotation2d:
        """
        Returns the heading of the robot as a frc#Rotation2d.
        
        The angle increases as the Pigeon IMU turns counterclockwise when
        looked at from the top. This follows the NWU axis convention.
        
        \\details The angle is continuous; that is, it will continue from
        360 to 361 degrees. This allows for algorithms that wouldn't want
        to see a discontinuity in the gyro output as it sweeps past from
        360 to 0 on the second time around.
        
        :returns: The current heading of the robot as a frc#Rotation2d
        """
    def initSendable(self, builder: wpiutil._wpiutil.SendableBuilder) -> None:
        ...
    def reset(self) -> None:
        """
        Resets the Pigeon IMU to a heading of zero.
        
        \\details This can be used if there is significant drift in the gyro,
        and it needs to be recalibrated after it has been running.
        """
