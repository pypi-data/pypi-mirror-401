#!/bin/bash
# Extract kernel and initramfs from Alpine linux-virt package
#
# Uses Alpine container with apk to get both vmlinuz-virt AND initramfs-virt
# (initramfs is generated by apk, not included in raw APK file)
#
# Usage:
#   ./scripts/extract-kernel.sh              # Extract for current arch
#   ./scripts/extract-kernel.sh x86_64       # Extract for x86_64
#   ./scripts/extract-kernel.sh aarch64      # Extract for aarch64
#   ./scripts/extract-kernel.sh all          # Extract for both

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
OUTPUT_DIR="$REPO_ROOT/images/dist"
ALPINE_VERSION="${ALPINE_VERSION:-3.21}"

detect_arch() {
    case "$(uname -m)" in
        x86_64|amd64) echo "x86_64" ;;
        aarch64|arm64) echo "aarch64" ;;
        *) echo "Unsupported arch: $(uname -m)" >&2; exit 1 ;;
    esac
}

# =============================================================================
# Cache helpers - content-addressable build caching via .hash sidecar files
# =============================================================================

# Compute hash for kernel inputs (Alpine version + arch + init script)
compute_kernel_hash() {
    local arch=$1
    (
        echo "alpine=$ALPINE_VERSION arch=$arch"
        cat "$REPO_ROOT/images/minimal-init.sh" 2>/dev/null || true
    ) | sha256sum | cut -d' ' -f1
}

# Check if output is up-to-date (hash matches)
cache_hit() {
    local output_file=$1
    local current_hash=$2
    local hash_file="${output_file}.hash"

    if [ -f "$output_file" ] && [ -f "$hash_file" ]; then
        local cached_hash
        cached_hash=$(cat "$hash_file" 2>/dev/null || echo "")
        [ "$cached_hash" = "$current_hash" ]
    else
        return 1
    fi
}

# Save hash after successful build
save_hash() {
    local output_file=$1
    local hash=$2
    echo "$hash" > "${output_file}.hash"
}

# =============================================================================
# Build functions
# =============================================================================

extract_for_arch() {
    local target_arch=$1
    local docker_platform
    local vmlinuz_file="$OUTPUT_DIR/vmlinuz-$target_arch"
    local initramfs_file="$OUTPUT_DIR/initramfs-$target_arch"

    case "$target_arch" in
        x86_64)  docker_platform="linux/amd64" ;;
        aarch64) docker_platform="linux/arm64" ;;
    esac

    # Check cache (use vmlinuz as the cache key file)
    local current_hash
    current_hash=$(compute_kernel_hash "$target_arch")

    if cache_hit "$vmlinuz_file" "$current_hash" && [ -f "$initramfs_file" ]; then
        echo "Kernel up-to-date: $target_arch (cache hit)"
        return 0
    fi

    echo "Extracting kernel for $target_arch (Alpine $ALPINE_VERSION)..."

    mkdir -p "$OUTPUT_DIR"

    # Extract only kernel from Alpine (we build our own minimal initramfs)
    docker run --rm \
        -v "$OUTPUT_DIR:/output" \
        --platform "$docker_platform" \
        "alpine:$ALPINE_VERSION" \
        sh -c "
            apk add --no-cache linux-virt >/dev/null 2>&1
            cp /boot/vmlinuz-virt /output/vmlinuz-$target_arch
            chmod 644 /output/vmlinuz-$target_arch
        "

    # Build custom minimal initramfs (2MB vs 9MB Alpine stock)
    # This includes only essential modules: virtio_blk, ext4 + dependencies
    "$SCRIPT_DIR/build-initramfs.sh" "$target_arch" "$OUTPUT_DIR"

    save_hash "$vmlinuz_file" "$current_hash"

    local vmlinuz_size initramfs_size
    vmlinuz_size=$(du -h "$vmlinuz_file" | cut -f1)
    initramfs_size=$(du -h "$initramfs_file" | cut -f1)
    echo "Extracted: vmlinuz-$target_arch ($vmlinuz_size), initramfs-$target_arch ($initramfs_size)"
}

main() {
    local target="${1:-$(detect_arch)}"

    # Check Docker is available
    if ! command -v docker >/dev/null 2>&1; then
        echo "Docker is required" >&2
        exit 1
    fi

    if [ "$target" = "all" ]; then
        extract_for_arch "x86_64"
        extract_for_arch "aarch64"
    else
        extract_for_arch "$target"
    fi
}

main "$@"
