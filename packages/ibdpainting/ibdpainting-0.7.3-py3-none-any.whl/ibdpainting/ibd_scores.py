import numpy as np
import pandas as pd
import warnings

def ibd_scores(ibd_table, rank_threshold:int=100):
    """
    Genetic distance between offspring and parents for pairs of plausible 
    candidate parents.

    This starts with the premise that crossed individuals can be thought of as 
    a mosaic of the two parents, such that in any single window they ought to be
    identical to one, but not the other parent.
    
    Beginning with a table of genetic distances between a test individual and
    each genotype in a reference panel, this function compares all plausible 
    pairs of candidates and pulls out the *minimum* genetic distance to the 
    offspring in each window. It then takes the average over windows, excluding
    windows with NA values.
    
    Because there can be a very large number of pairs to consider, candidates 
    are first filtered to retain the N candidates with the lowest mean genetic
    distance from the offspring. N is controlled by the argument
    `rank_threshold`.

    Parameters
    ==========
    ibd_table: pd.DataFrame
        DataFrame with a row for each window in the genome and a column for each 
        sample in the reference panel. Elements show genetic distance between the 
        test individual and each reference individual in a single window.
        This is generated by ibd_table().
    rank_threshold: int, optional
        Number of most-plausible to consider as pairs. Defaults to 20. Setting 
        this number to something large will make the output very large!

    Returns
    =======
    A DataFrame with a row for each pair of candidate parents, giving candidate
    IDs and the average mimimum genetic distance from either parent to the
    offspring, averaged over windows. Values closer to zero indicate that the 
    pair is more likely to be a match.
    """
    # Remove the column with heterozygosity from the table, as this is not a candidate
    # for parentage.
    ibd_table = ibd_table.drop(columns=['heterozygosity'], axis=1)  
    # Coerce missing data to NaN for correct column means.
    ibd_table = ibd_table.replace(-9,np.nan)
    
    # Get column-mean IBD for each candidate, allowing for missing data
    # Note the index from 1 onwards to skip the window column
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        ibd_scores_for_each_candidate = np.array(
            [ np.nanmean(ibd_table[col]) for col in ibd_table.keys()[1:] ]
        )
    # Get the indices of the top N values in ibd_scores_for_each_candidate
    # where N is rank_threshold
    if rank_threshold < ibd_table.shape[1]:
        score_ix = np.argpartition(-ibd_scores_for_each_candidate, -rank_threshold)[-rank_threshold:]
    else:
        score_ix = np.arange(len(ibd_scores_for_each_candidate))
    
    # For each pair of candidates indexed by score_ix, pull out the minimum 
    # genetic distance from the offspring in each window.
    scores_for_pairs = []
    for i in score_ix+1: # +1 is to skip the column with window names
        for j in score_ix+1:
            if j >= i:
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore")
                    # List containing the ID of candidates 1 and 2, plus the minimum genetic distance
                    scores_for_pairs.append(
                        [ibd_table.keys()[i], ibd_table.keys()[j], np.nanmean(ibd_table.iloc[:, [i,j]].min(axis=1, skipna=False))]
                        )
    scores_for_pairs = pd.DataFrame(scores_for_pairs, columns = ['parent1', 'parent2', 'min_IBD'])
    scores_for_pairs = scores_for_pairs.sort_values('min_IBD')
    
    return scores_for_pairs