<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HtmlGraph.js Test Suite</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; }
        .test-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-case {
            border-left: 4px solid #ddd;
            padding: 10px 15px;
            margin: 10px 0;
            background: #f9f9f9;
        }
        .test-case.pass {
            border-left-color: #4caf50;
            background: #f1f8f4;
        }
        .test-case.fail {
            border-left-color: #f44336;
            background: #fff5f5;
        }
        .test-name { font-weight: bold; margin-bottom: 5px; }
        .test-error { color: #f44336; margin-top: 5px; font-family: monospace; font-size: 12px; }
        .test-success { color: #4caf50; }
        .summary {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .stat {
            flex: 1;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .stat.total { background: #2196f3; color: white; }
        .stat.pass { background: #4caf50; color: white; }
        .stat.fail { background: #f44336; color: white; }
        .stat-number { font-size: 32px; font-weight: bold; }
        .stat-label { font-size: 14px; opacity: 0.9; }
    </style>
</head>
<body>
    <h1>HtmlGraph.js Test Suite</h1>
    <div class="summary">
        <div class="stat total">
            <div class="stat-number" id="total-tests">0</div>
            <div class="stat-label">Total Tests</div>
        </div>
        <div class="stat pass">
            <div class="stat-number" id="passed-tests">0</div>
            <div class="stat-label">Passed</div>
        </div>
        <div class="stat fail">
            <div class="stat-number" id="failed-tests">0</div>
            <div class="stat-label">Failed</div>
        </div>
    </div>
    <div id="test-results"></div>

    <!-- Load the library -->
    <script src="../../src/js/htmlgraph.js"></script>

    <script>
        // Simple test framework
        class TestRunner {
            constructor() {
                this.results = [];
                this.currentSection = null;
            }

            section(name) {
                this.currentSection = name;
            }

            assert(name, condition, errorMsg = null) {
                const result = {
                    section: this.currentSection,
                    name,
                    passed: condition,
                    error: errorMsg
                };
                this.results.push(result);

                if (!condition && errorMsg) {
                    console.error(`❌ ${name}: ${errorMsg}`);
                } else if (condition) {
                    console.log(`✅ ${name}`);
                }
            }

            assertEqual(name, actual, expected) {
                const passed = JSON.stringify(actual) === JSON.stringify(expected);
                this.assert(
                    name,
                    passed,
                    passed ? null : `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`
                );
            }

            assertThrows(name, fn, expectedError = null) {
                try {
                    fn();
                    this.assert(name, false, 'Expected function to throw an error');
                } catch (error) {
                    if (expectedError) {
                        const passed = error.message.includes(expectedError);
                        this.assert(
                            name,
                            passed,
                            passed ? null : `Expected error containing "${expectedError}", got "${error.message}"`
                        );
                    } else {
                        this.assert(name, true);
                    }
                }
            }

            render() {
                const passed = this.results.filter(r => r.passed).length;
                const failed = this.results.filter(r => !r.passed).length;

                document.getElementById('total-tests').textContent = this.results.length;
                document.getElementById('passed-tests').textContent = passed;
                document.getElementById('failed-tests').textContent = failed;

                const sections = {};
                this.results.forEach(result => {
                    if (!sections[result.section]) {
                        sections[result.section] = [];
                    }
                    sections[result.section].push(result);
                });

                const container = document.getElementById('test-results');
                for (const [section, results] of Object.entries(sections)) {
                    const sectionDiv = document.createElement('div');
                    sectionDiv.className = 'test-section';
                    sectionDiv.innerHTML = `<h2>${section}</h2>`;

                    results.forEach(result => {
                        const testDiv = document.createElement('div');
                        testDiv.className = `test-case ${result.passed ? 'pass' : 'fail'}`;
                        testDiv.innerHTML = `
                            <div class="test-name">${result.passed ? '✅' : '❌'} ${result.name}</div>
                            ${result.error ? `<div class="test-error">${result.error}</div>` : ''}
                        `;
                        sectionDiv.appendChild(testDiv);
                    });

                    container.appendChild(sectionDiv);
                }
            }
        }

        // Run tests
        const runner = new TestRunner();

        // Test 1: Basic Node Operations
        runner.section('Basic Node Operations');
        const graph = new HtmlGraph();

        const node1 = {
            id: 'node-1',
            title: 'Test Node 1',
            type: 'feature',
            status: 'todo',
            priority: 'high',
            edges: {},
            properties: {}
        };

        graph.add(node1);
        runner.assertEqual('Add node', graph.get('node-1').id, 'node-1');
        runner.assertEqual('Get node title', graph.get('node-1').title, 'Test Node 1');

        // Test 2: Edge Index
        runner.section('Edge Index');
        const node2 = {
            id: 'node-2',
            title: 'Test Node 2',
            type: 'feature',
            status: 'done',
            edges: {
                blocked_by: [{ targetId: 'node-1', relationship: 'blocked_by' }]
            }
        };

        graph.add(node2);
        const incoming = graph.getIncomingEdges('node-1', 'blocked_by');
        runner.assertEqual('Incoming edges', incoming.length, 1);
        runner.assertEqual('Incoming edge source', incoming[0].sourceId, 'node-2');

        // Test 3: Query Builder
        runner.section('Query Builder');
        const results = graph.queryBuilder()
            .where('status', 'todo')
            .execute();
        runner.assertEqual('Query by status', results.length, 1);
        runner.assertEqual('Query result ID', results[0].id, 'node-1');

        const highPriority = graph.queryBuilder()
            .where('priority').eq('high')
            .execute();
        runner.assertEqual('Query with condition builder', highPriority.length, 1);

        // Test 4: Find API
        runner.section('Find API');
        const found = graph.find('feature', { status: 'done' });
        runner.assertEqual('Find by type and status', found.id, 'node-2');

        const allFeatures = graph.findAll('feature');
        runner.assertEqual('Find all features', allFeatures.length, 2);

        const blockedBy = graph.findBlockedBy('node-2');
        runner.assertEqual('Find blocked by', blockedBy.length, 1);
        runner.assertEqual('Blocked by node', blockedBy[0].id, 'node-1');

        // Test 5: Graph Traversal
        runner.section('Graph Traversal');
        const node3 = {
            id: 'node-3',
            title: 'Test Node 3',
            type: 'feature',
            status: 'todo',
            edges: {
                blocked_by: [{ targetId: 'node-2', relationship: 'blocked_by' }]
            }
        };
        graph.add(node3);

        const ancestors = graph.ancestors('node-3', 'blocked_by');
        runner.assertEqual('Ancestors count', ancestors.length, 2);
        runner.assert('Ancestors includes node-2', ancestors.includes('node-2'));
        runner.assert('Ancestors includes node-1', ancestors.includes('node-1'));

        const descendants = graph.descendants('node-1', 'blocked_by');
        runner.assertEqual('Descendants count', descendants.length, 2);

        // Test 6: Shortest Path
        runner.section('Shortest Path');
        const path = graph.shortestPath('node-3', 'node-1', 'blocked_by');
        runner.assert('Path exists', path !== null);
        runner.assertEqual('Path length', path.length, 3);
        runner.assertEqual('Path start', path[0], 'node-3');
        runner.assertEqual('Path end', path[path.length - 1], 'node-1');

        // Test 7: Connected Component
        runner.section('Connected Component');
        const component = graph.connectedComponent('node-1', 'blocked_by');
        runner.assertEqual('Component size', component.size, 3);
        runner.assert('Component includes node-1', component.has('node-1'));
        runner.assert('Component includes node-2', component.has('node-2'));
        runner.assert('Component includes node-3', component.has('node-3'));

        // Test 8: Subgraph
        runner.section('Subgraph');
        const sub = graph.subgraph(['node-1', 'node-2'], true);
        runner.assertEqual('Subgraph node count', Array.from(sub.nodes()).length, 2);
        const subNode2 = sub.get('node-2');
        runner.assertEqual('Subgraph edges preserved', subNode2.edges.blocked_by.length, 1);

        // Test 9: HTML Parsing
        runner.section('HTML Parsing');
        const sampleHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test Feature</title>
</head>
<body>
    <article id="test-feature"
             data-type="feature"
             data-status="in-progress"
             data-priority="high"
             data-created="2024-12-16T10:00:00Z">
        <header>
            <h1>Test Feature Title</h1>
        </header>
        <nav data-graph-edges>
            <section data-edge-type="blocked_by">
                <h3>Blocked By:</h3>
                <ul>
                    <li><a href="other-feature.html" data-relationship="blocked_by">Other Feature</a></li>
                </ul>
            </section>
        </nav>
        <section data-properties>
            <dl>
                <dt>Effort</dt>
                <dd data-key="effort" data-value="8" data-unit="hours">8 hours</dd>
            </dl>
        </section>
        <section data-steps>
            <ol>
                <li data-completed="true" data-agent="claude">✅ First step</li>
                <li data-completed="false">⏳ Second step</li>
            </ol>
        </section>
    </article>
</body>
</html>
        `;

        const parsed = graph.parseHtml(sampleHtml);
        runner.assertEqual('Parse HTML - ID', parsed.id, 'test-feature');
        runner.assertEqual('Parse HTML - Title', parsed.title, 'Test Feature');
        runner.assertEqual('Parse HTML - Type', parsed.type, 'feature');
        runner.assertEqual('Parse HTML - Status', parsed.status, 'in-progress');
        runner.assertEqual('Parse HTML - Priority', parsed.priority, 'high');
        runner.assertEqual('Parse HTML - Edges count', parsed.edges.blocked_by.length, 1);
        runner.assertEqual('Parse HTML - Edge target', parsed.edges.blocked_by[0].targetId, 'other-feature');
        runner.assertEqual('Parse HTML - Properties', parsed.properties.effort.value, '8');
        runner.assertEqual('Parse HTML - Steps count', parsed.steps.length, 2);
        runner.assertEqual('Parse HTML - First step completed', parsed.steps[0].completed, true);
        runner.assertEqual('Parse HTML - Second step completed', parsed.steps[1].completed, false);

        // Test 10: CSS Selector Query
        runner.section('CSS Selector Query');
        const graph2 = new HtmlGraph();
        graph2.add({ id: 'f1', status: 'done', priority: 'high' });
        graph2.add({ id: 'f2', status: 'done', priority: 'low' });
        graph2.add({ id: 'f3', status: 'todo', priority: 'high' });

        const queryResults = graph2.query('[data-status="done"][data-priority="high"]');
        runner.assertEqual('CSS query - matches', queryResults.length, 1);
        runner.assertEqual('CSS query - result ID', queryResults[0].id, 'f1');

        // Test 11: Operators
        runner.section('Query Operators');
        const graph3 = new HtmlGraph();
        graph3.add({ id: 't1', type: 'task', properties: { effort: 5 } });
        graph3.add({ id: 't2', type: 'task', properties: { effort: 10 } });
        graph3.add({ id: 't3', type: 'task', properties: { effort: 15 } });

        const highEffort = graph3.queryBuilder()
            .where('properties.effort').gt(8)
            .execute();
        runner.assertEqual('Greater than operator', highEffort.length, 2);

        const mediumEffort = graph3.queryBuilder()
            .where('properties.effort').gte(5)
            .and_('properties.effort').lte(10)
            .execute();
        runner.assertEqual('Between operator (gte + lte)', mediumEffort.length, 2);

        // Render results
        runner.render();
    </script>
</body>
</html>
