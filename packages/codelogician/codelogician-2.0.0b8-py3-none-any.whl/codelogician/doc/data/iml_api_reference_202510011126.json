[
  {
    "id": "816cc214-8cf7-4f67-88c3-b6c4f9d37b9c",
    "module": "",
    "name": "+.",
    "type": "function",
    "signature": "val +. : real -> real -> real",
    "doc": "[+.] is addition for reals",
    "pattern": "Real number arithmetic addition"
  },
  {
    "id": "783e92ea-4881-4bad-bd23-d632aadf4a6e",
    "module": "Int",
    "name": "t",
    "type": "type",
    "signature": "type t = int",
    "doc": "Integer type using arbitrary precision integers (Z.t from Zarith)",
    "pattern": null
  },
  {
    "id": "f9af599e-5bc2-420b-a092-81e095b8f0c4",
    "module": "Int",
    "name": "mod_zero_prod",
    "type": "axiom",
    "signature": "val mod_zero_prod : int -> int -> int -> bool",
    "doc": null,
    "pattern": null
  },
  {
    "id": "220a0821-5907-4853-87d0-a1c7007730ff",
    "module": "Int",
    "name": "mod_sub_id",
    "type": "axiom",
    "signature": "val mod_sub_id : int -> int -> bool",
    "doc": null,
    "pattern": null
  },
  {
    "id": "a0ff157a-9cf9-4c1b-b32b-0de7376a27fe",
    "module": "List",
    "name": "append_to_nil",
    "type": "theorem",
    "signature": "val append_to_nil : 'a list -> bool",
    "doc": "Theorem: (List.append x []) = x",
    "pattern": null
  },
  {
    "id": "53a710d3-ad7b-410d-b40e-f627ee5dfc2c",
    "module": "List",
    "name": "append_single",
    "type": "theorem",
    "signature": "val append_single : 'a -> 'a list -> 'a list -> bool",
    "doc": "Theorem: (List.append (List.append y ([x])) z) = (List.append y ((x :: z)))",
    "pattern": null
  },
  {
    "id": "5fa1c807-7993-469e-84ab-35034e451ffa",
    "module": "List",
    "name": "len_nonnegative",
    "type": "theorem",
    "signature": "val len_nonnegative : 'a list -> bool",
    "doc": "Length of a list is non-negative. This useful theorem is installed as a forward-chaining rule.",
    "pattern": null
  },
  {
    "id": "bdda99fc-51f0-4fc7-a091-7593d01c7572",
    "module": "List",
    "name": "len_zero_is_empty",
    "type": "theorem",
    "signature": "val len_zero_is_empty : 'a list -> bool",
    "doc": "A list has length zero iff it is empty. This is a useful rewrite rule for obtaining empty lists.",
    "pattern": null
  },
  {
    "id": "e2aa502e-153f-4832-b974-238c6caa2ce6",
    "module": "List",
    "name": "len_append",
    "type": "theorem",
    "signature": "val len_append : 'a list -> 'a list -> bool",
    "doc": "The length of (x @ y) is the sum of the lengths of x and y",
    "pattern": null
  },
  {
    "id": "ea043897-7367-4821-9653-fbb839102338",
    "module": "",
    "name": "int",
    "type": "type",
    "signature": "type int = <logic_core_builtin>",
    "doc": "Builtin integer type, using arbitrary precision integers. This type is an alias to {!Z.t} (using Zarith). NOTE: here Imandra diverges from normal OCaml, where integers width is bounded by native machine integers. \"Normal\" OCaml integers have type {!Caml.Int.t} and can be entered using the 'i' suffix: [0i]",
    "pattern": "Arbitrary precision integers for unbounded calculations"
  },
  {
    "id": "2a266e26-aca1-4ee5-a525-910765899fd3",
    "module": "",
    "name": "bool",
    "type": "type",
    "signature": "type nonrec bool = <logic_core_builtin>",
    "doc": "Builtin boolean type.",
    "pattern": "Boolean true\/false values for logical operations"
  },
  {
    "id": "d101a983-3a9a-4d26-976e-84e46ecf44b9",
    "module": "",
    "name": "||",
    "type": "function",
    "signature": "val || : bool -> bool -> bool",
    "doc": "[||] is the boolean OR operator",
    "pattern": "Logical OR operation between two boolean values"
  },
  {
    "id": "9d9e874b-3317-43e0-ac94-25acd175504c",
    "module": "",
    "name": "&&",
    "type": "function",
    "signature": "val && : bool -> bool -> bool",
    "doc": "[&&] is the boolean AND operator",
    "pattern": "Logical AND operation between two boolean values"
  },
  {
    "id": "18eaed7e-66fc-4898-81a4-5c6c0f165190",
    "module": "",
    "name": "unit",
    "type": "type",
    "signature": "type nonrec unit = | ()",
    "doc": "Unit type with single constructor [()]",
    "pattern": "Represents absence of a meaningful value"
  },
  {
    "id": "1474599c-32af-445a-a5be-f54f98cf22db",
    "module": "",
    "name": "=",
    "type": "function",
    "signature": "val = : 'a -> 'a -> bool",
    "doc": "Equality. Must be applied to non-function types.",
    "pattern": "Value equality comparison"
  },
  {
    "id": "8be5e3f6-aea8-42e4-9f2c-1bbe7e023af7",
    "module": "",
    "name": "<>",
    "type": "function",
    "signature": "val <> : 'a -> 'a -> bool",
    "doc": "[<>] is the inequality operator",
    "pattern": "Value inequality comparison"
  },
  {
    "id": "380e6531-57bc-4b8b-8154-d138de6c56b8",
    "module": "",
    "name": "not",
    "type": "function",
    "signature": "val not : bool -> bool",
    "doc": "[not] is the boolean NOT operator",
    "pattern": "Logical negation of boolean values"
  },
  {
    "id": "06730de9-1d7c-4b60-bf8d-02fdf490932c",
    "module": "",
    "name": "==>",
    "type": "function",
    "signature": "val ==> : bool -> bool -> bool",
    "doc": "[==>] is logical implication",
    "pattern": "Logical implication in mathematical reasoning"
  },
  {
    "id": "46e0d5c8-4faa-43fe-8215-93db4b17ed3b",
    "module": "",
    "name": "<==",
    "type": "function",
    "signature": "val <== : bool -> bool -> bool",
    "doc": "[<==] is reverse logical implication",
    "pattern": "Reverse logical implication in mathematical reasoning"
  },
  {
    "id": "4a82c392-f298-4842-a1f8-dfbf72ebd02e",
    "module": "",
    "name": "<==>",
    "type": "function",
    "signature": "val <==> : bool -> bool -> bool",
    "doc": "[<==>] is logical equivalence",
    "pattern": "Logical equivalence\/biconditional in mathematical reasoning"
  },
  {
    "id": "b5dd0dee-b4f2-472d-b30f-7b5c851ca0da",
    "module": "",
    "name": "+",
    "type": "function",
    "signature": "val + : int -> int -> int",
    "doc": "[+] is integer addition",
    "pattern": "Basic arithmetic addition of integers"
  },
  {
    "id": "6b61e59b-df08-4982-9a4e-5a4c918fb1dd",
    "module": "",
    "name": "const",
    "type": "function",
    "signature": "val const : 'a -> 'b -> 'a",
    "doc": "[const x y] returns [x]. In other words, [const x] is the constant function that always returns [x].",
    "pattern": "Creating constant functions in functional programming"
  },
  {
    "id": "97fcec37-ac07-465b-aefd-bfde1699372d",
    "module": "",
    "name": ">=",
    "type": "function",
    "signature": "val >= : int -> int -> bool",
    "doc": "[>=] is greater than or equal comparison for integers",
    "pattern": "Numeric comparison for ordering"
  },
  {
    "id": "77394844-daf9-45c5-90fe-d416d875a377",
    "module": "",
    "name": "mk_nat",
    "type": "function",
    "signature": "val mk_nat : int -> int",
    "doc": "[mk_nat x] converts integer [x] to natural number by returning [x] if non-negative, 0 otherwise",
    "pattern": "Converting integers to non-negative numbers"
  },
  {
    "id": "85c4fb67-2c60-427d-85d1-4c89b1cfa607",
    "module": "",
    "name": "option",
    "type": "type",
    "signature": "type nonrec option = | None | Some of 'a",
    "doc": "Option type representing optional values",
    "pattern": "Representing values that may or may not exist"
  },
  {
    "id": "60da8296-bd49-4dfa-a1df-5a4306ab9696",
    "module": "",
    "name": "list",
    "type": "type",
    "signature": "type list = | [] | :: of 'a * 'a list",
    "doc": "List type with empty list [] and cons :: constructors",
    "pattern": "Sequential data structure with variable length"
  },
  {
    "id": "8a16202a-6089-49cc-b6f8-3bf545152c5f",
    "module": "",
    "name": "float",
    "type": "type",
    "signature": "type nonrec float = <logic_core_builtin>",
    "doc": "Floating point number type",
    "pattern": "IEEE 754 floating point arithmetic"
  },
  {
    "id": "621acf79-5aa7-49dd-bf2a-a2c4d694edc7",
    "module": "",
    "name": "real",
    "type": "type",
    "signature": "type nonrec real = <logic_core_builtin>",
    "doc": "Real number type",
    "pattern": "Mathematical real number calculations"
  },
  {
    "id": "65257510-7868-4c1a-b290-5d6a1c64c492",
    "module": "",
    "name": "string",
    "type": "type",
    "signature": "type nonrec string = <logic_core_builtin>",
    "doc": "String type",
    "pattern": "Text manipulation and processing"
  },
  {
    "id": "0f9eb757-0d35-471c-82b9-26a4adf6adc3",
    "module": "",
    "name": "<",
    "type": "function",
    "signature": "val < : int -> int -> bool",
    "doc": "[<] is less than comparison for integers",
    "pattern": "Numeric comparison for strict ordering"
  },
  {
    "id": "b3d6876c-114c-4f75-b3a4-f306766fea21",
    "module": "",
    "name": "<=",
    "type": "function",
    "signature": "val <= : int -> int -> bool",
    "doc": "[<=] is less than or equal comparison for integers",
    "pattern": "Numeric comparison for non-strict ordering"
  },
  {
    "id": "d9da79f6-8174-42df-ab00-aa15cfeb9845",
    "module": "",
    "name": ">",
    "type": "function",
    "signature": "val > : int -> int -> bool",
    "doc": "[>] is greater than comparison for integers",
    "pattern": "Numeric comparison for strict ordering"
  },
  {
    "id": "61763f9a-14d8-42d1-ae2b-08206b5f611f",
    "module": "",
    "name": "min",
    "type": "function",
    "signature": "val min : int -> int -> int",
    "doc": "[min x y] returns the minimum of integers [x] and [y]",
    "pattern": "Finding smaller of two numbers"
  },
  {
    "id": "276a37ce-6751-40bc-8740-86042404b108",
    "module": "",
    "name": "max",
    "type": "function",
    "signature": "val max : int -> int -> int",
    "doc": "[max x y] returns the maximum of integers [x] and [y]",
    "pattern": "Finding larger of two numbers"
  },
  {
    "id": "de0fa20c-116f-4286-8f97-01569ecbdb50",
    "module": "",
    "name": "<.",
    "type": "function",
    "signature": "val <. : real -> real -> bool",
    "doc": "[<.] is less than comparison for reals",
    "pattern": "Real number comparison for strict ordering"
  },
  {
    "id": "6e85f823-a566-474a-954f-f35d4ccea44c",
    "module": "",
    "name": "<=.",
    "type": "function",
    "signature": "val <=. : real -> real -> bool",
    "doc": "[<=.] is less than or equal comparison for reals",
    "pattern": "Real number comparison for non-strict ordering"
  },
  {
    "id": "0e0c990f-7953-4b29-bc56-50edcb7ee859",
    "module": "",
    "name": ">.",
    "type": "function",
    "signature": "val >. : real -> real -> bool",
    "doc": "[>.] is greater than comparison for reals",
    "pattern": "Real number comparison for strict ordering"
  },
  {
    "id": "caa4a4f8-1855-4096-aa01-e06f626cb223",
    "module": "",
    "name": ">=.",
    "type": "function",
    "signature": "val >=. : real -> real -> bool",
    "doc": "[>=.] is greater than or equal comparison for reals",
    "pattern": "Real number comparison for non-strict ordering"
  },
  {
    "id": "ec8b03e3-286a-4fc7-abf7-ac16b5a1d0e8",
    "module": "",
    "name": "min_r",
    "type": "function",
    "signature": "val min_r : real -> real -> real",
    "doc": "[min_r x y] returns the minimum of reals [x] and [y]",
    "pattern": "Finding smaller of two real numbers"
  },
  {
    "id": "6eb95dd2-6c6c-421a-9715-32681d9f64d4",
    "module": "",
    "name": "max_r",
    "type": "function",
    "signature": "val max_r : real -> real -> real",
    "doc": "[max_r x y] returns the maximum of reals [x] and [y]",
    "pattern": "Finding larger of two real numbers"
  },
  {
    "id": "71b6fbf5-cbe5-438d-bbf3-e6a5a4bd318e",
    "module": "",
    "name": "~-",
    "type": "function",
    "signature": "val ~- : int -> int",
    "doc": "[~- x] returns the negation of integer [x]",
    "pattern": "Arithmetic negation of integers"
  },
  {
    "id": "400aec3f-22be-446e-99f3-ccd64efe2369",
    "module": "",
    "name": "abs",
    "type": "function",
    "signature": "val abs : int -> int",
    "doc": "[abs x] returns the absolute value of integer [x]",
    "pattern": "Computing magnitude of numbers"
  },
  {
    "id": "072c4060-a355-4218-9e22-49220393656e",
    "module": "",
    "name": "-",
    "type": "function",
    "signature": "val - : int -> int -> int",
    "doc": "[-] is integer subtraction",
    "pattern": "Basic arithmetic subtraction"
  },
  {
    "id": "d1bf4f61-838d-41ff-a349-01b4046992d2",
    "module": "",
    "name": "~+",
    "type": "function",
    "signature": "val ~+ : int -> int",
    "doc": "[~+ x] returns [x] unchanged (unary plus)",
    "pattern": "Identity operation on numbers"
  },
  {
    "id": "3d21ac7a-c079-4864-9247-1ade6cdbb94f",
    "module": "",
    "name": "*",
    "type": "function",
    "signature": "val * : int -> int -> int",
    "doc": "[*] is integer multiplication",
    "pattern": "Basic arithmetic multiplication"
  },
  {
    "id": "38941337-acd5-4814-b6ab-f79e1dc8e8be",
    "module": "",
    "name": "\/",
    "type": "function",
    "signature": "val \/ : int -> int -> int",
    "doc": "Euclidian division on integers, see http:\/\/smtlib.cs.uiowa.edu\/theories-Ints.shtml",
    "pattern": "Integer division with rounding towards zero"
  },
  {
    "id": "b5ef8869-1f4a-4c7c-b29c-89f44c47d035",
    "module": "",
    "name": "mod",
    "type": "function",
    "signature": "val mod : int -> int -> int",
    "doc": "Euclidian remainder on integers",
    "pattern": "Computing remainders in modular arithmetic"
  },
  {
    "id": "d18daa01-9976-453d-be13-b84c224ab0d8",
    "module": "",
    "name": "compare",
    "type": "function",
    "signature": "val compare : int -> int -> int",
    "doc": "Total order, if x = y then 0 else if x < y then -1 else 1",
    "pattern": "Three-way comparison for sorting and ordering"
  },
  {
    "id": "f104476b-a894-446b-84fe-ac96f046dc60",
    "module": "",
    "name": "result",
    "type": "type",
    "signature": "type result = | Ok of 'a | Error of 'b",
    "doc": "Result type, representing either a successful result [Ok x] or an error [Error x].",
    "pattern": "Error handling and computation results"
  },
  {
    "id": "7cfc5a31-b42b-46ac-b5ea-9ddb1afadf51",
    "module": "",
    "name": "either",
    "type": "type",
    "signature": "type either = | Left of 'a | Right of 'b",
    "doc": "A familiar type for Haskellers",
    "pattern": "Representing values of two different types"
  },
  {
    "id": "4e1151a5-488a-4b9e-91f2-b70259c13b4e",
    "module": "",
    "name": "|>",
    "type": "function",
    "signature": "val |> : 'a -> ('a -> 'b) -> 'b",
    "doc": "Pipeline operator. [x |> f] is the same as [f x], but it composes nicely: [ x |> f |> g |> h] can be more readable than [h(g(f x))].",
    "pattern": "Function composition in data processing pipelines"
  },
  {
    "id": "c646b88f-5b4d-44c7-8a60-0c0fec7d98f2",
    "module": "",
    "name": "@@",
    "type": "function",
    "signature": "val @@ : ('a -> 'b) -> 'a -> 'b",
    "doc": "Right-associative application operator. [f @@ x] is the same as [f x], but it binds to the right: [f @@ g @@ h @@ x] is the same as [f (g (h x))] but with fewer parentheses.",
    "pattern": "Nested function application without parentheses"
  },
  {
    "id": "b795ebfa-d220-49e4-9d89-388246facd38",
    "module": "",
    "name": "id",
    "type": "function",
    "signature": "val id : 'a -> 'a",
    "doc": "Identity function. [id x = x] always holds.",
    "pattern": "Function that returns its input unchanged"
  },
  {
    "id": "1e787da3-ea10-43d6-be90-9c8446fb2e1a",
    "module": "",
    "name": "%>",
    "type": "function",
    "signature": "val %> : ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c",
    "doc": "Mathematical composition operator. [f %> g] is [fun x -> g (f x)]",
    "pattern": "Composing functions in mathematical style"
  },
  {
    "id": "282cac77-5cf5-4309-b537-443af86d365b",
    "module": "",
    "name": "-.",
    "type": "function",
    "signature": "val -. : real -> real -> real",
    "doc": "[-.] is subtraction for reals",
    "pattern": "Real number arithmetic subtraction"
  },
  {
    "id": "ec2f5453-ec81-4b0a-9e40-9f66c4ed02d4",
    "module": "",
    "name": "~-.",
    "type": "function",
    "signature": "val ~-. : real -> real",
    "doc": "[~-.] is negation for reals",
    "pattern": "Real number arithmetic negation"
  },
  {
    "id": "f7a03fed-6cab-4c43-b4bb-f28aeae13c51",
    "module": "",
    "name": "*.",
    "type": "function",
    "signature": "val *. : real -> real -> real",
    "doc": "[*.] is multiplication for reals",
    "pattern": "Real number arithmetic multiplication"
  },
  {
    "id": "b2833c13-b3ae-4136-87d5-99fa3af70d0d",
    "module": "",
    "name": "\/.",
    "type": "function",
    "signature": "val \/. : real -> real -> real",
    "doc": "[\/.] is division for reals",
    "pattern": "Real number arithmetic division"
  },
  {
    "id": "5e71dbd8-c33d-4077-976b-0ebe5e2314b2",
    "module": "",
    "name": "@",
    "type": "function",
    "signature": "val @ : 'a list -> 'a list -> 'a list",
    "doc": "Infix alias to {!List.append}",
    "pattern": "List concatenation"
  },
  {
    "id": "3da92130-9226-4d01-b195-2cbccaa15dc3",
    "module": "",
    "name": "^",
    "type": "function",
    "signature": "val ^ : String.t -> String.t -> String.t",
    "doc": "Alias to {!String.append}",
    "pattern": "String concatenation"
  },
  {
    "id": "c3144eeb-5d53-4e49-93f3-dd174d99834f",
    "module": "",
    "name": "succ",
    "type": "function",
    "signature": "val succ : int -> int",
    "doc": "[succ x] returns the successor of integer [x]",
    "pattern": "Incrementing integers by one"
  },
  {
    "id": "5f8d081a-65e1-40e4-bce1-7f138ddca171",
    "module": "",
    "name": "pred",
    "type": "function",
    "signature": "val pred : int -> int",
    "doc": "[pred x] returns the predecessor of integer [x]",
    "pattern": "Decrementing integers by one"
  },
  {
    "id": "4780a4ea-2956-420d-9feb-125ba45bc3bb",
    "module": "",
    "name": "fst",
    "type": "function",
    "signature": "val fst : ('a * 'b) -> 'a",
    "doc": "[fst (x,y)] returns the first component [x] of pair [(x,y)]",
    "pattern": "Accessing first element of a pair"
  },
  {
    "id": "c2ba4635-b5f2-4c3c-8063-60c5fc5cd522",
    "module": "",
    "name": "snd",
    "type": "function",
    "signature": "val snd : ('a * 'b) -> 'b",
    "doc": "[snd (x,y)] returns the second component [y] of pair [(x,y)]",
    "pattern": "Accessing second element of a pair"
  },
  {
    "id": "7dfd4cc5-21b9-498c-a89f-b9153bd5ba90",
    "module": "Set",
    "name": "t",
    "type": "type",
    "signature": "type Set.t = ('a, bool) Map.t",
    "doc": "The set type, implemented as a map from elements to boolean values indicating membership",
    "pattern": null
  },
  {
    "id": "51cc7e7f-a982-454a-91f7-3cd76be5fcff",
    "module": "Set",
    "name": "empty",
    "type": "function",
    "signature": "val empty : ('a, bool) Map.t",
    "doc": "Creates an empty set where all elements are mapped to false",
    "pattern": "Initializing a new set before adding elements, similar to creating an empty HashSet or Set in other languages"
  },
  {
    "id": "d8e5ad40-2887-476e-9c28-a9bfe5e9b18e",
    "module": "Set",
    "name": "full",
    "type": "function",
    "signature": "val full : ('a, bool) Map.t",
    "doc": "Creates a full set where all elements are mapped to true",
    "pattern": "Creating a universal set containing all possible elements, often used as a starting point for set operations like complement"
  },
  {
    "id": "9c8223db-8726-4888-bd85-8886a31543d1",
    "module": "Set",
    "name": "is_empty",
    "type": "function",
    "signature": "val is_empty : 'a Set.t -> bool",
    "doc": "Tests if set [s] is empty by comparing it to the empty set",
    "pattern": "Checking if a collection contains any elements before performing operations, like validating user input or checking search results"
  },
  {
    "id": "06fa258f-6add-4c90-9aa2-2f79388c3084",
    "module": "Set",
    "name": "is_valid",
    "type": "function",
    "signature": "val is_valid : 'a Set.t -> bool",
    "doc": "Checks if set [s] is valid. Always returns true since all sets are valid",
    "pattern": "Validating set integrity, though in this implementation all sets are considered valid by design"
  },
  {
    "id": "34373535-6272-4b54-bca5-52b6a1eb4b8e",
    "module": "Set",
    "name": "mem",
    "type": "function",
    "signature": "val mem : 'a -> 'a Set.t -> bool",
    "doc": "Tests if element [x] is a member of set [s]",
    "pattern": "Testing element existence in a collection, like checking if a user ID exists or if a value is allowed"
  },
  {
    "id": "f327c1f4-96c8-438c-b586-1b0f6fa52528",
    "module": "Set",
    "name": "subset",
    "type": "function",
    "signature": "val subset : 'a Set.t -> 'a Set.t -> bool",
    "doc": "Tests if set [s1] is a subset of set [s2]",
    "pattern": "Checking if one collection's elements are fully contained within another, like validating permissions or category hierarchies"
  },
  {
    "id": "31e061ff-87dc-484d-a2de-d07550816f52",
    "module": "Set",
    "name": "add",
    "type": "function",
    "signature": "val add : 'a -> 'a Set.t -> 'a Set.t",
    "doc": "Adds element [x] to set [s]",
    "pattern": "Adding unique elements to a collection, ensuring no duplicates, like building a set of unique identifiers or tags"
  },
  {
    "id": "5eb55d62-c2c4-4924-aeea-7ce131f93955",
    "module": "Set",
    "name": "remove",
    "type": "function",
    "signature": "val remove : 'a -> 'a Set.t -> 'a Set.t",
    "doc": "Removes element [x] from set [s]",
    "pattern": "Removing elements from a collection while maintaining uniqueness, like removing revoked permissions or deleted items"
  },
  {
    "id": "ae9cc99c-5fc9-4a5c-8907-e8137de3d3c5",
    "module": "Set",
    "name": "inter",
    "type": "function",
    "signature": "val inter : 'a Set.t -> 'a Set.t -> 'a Set.t",
    "doc": "Computes the intersection of sets [s1] and [s2]",
    "pattern": "Finding common elements between two collections, like identifying shared permissions or matching criteria"
  },
  {
    "id": "b8213894-065a-47ae-be3c-663dbd179ca2",
    "module": "Set",
    "name": "union",
    "type": "function",
    "signature": "val union : 'a Set.t -> 'a Set.t -> 'a Set.t",
    "doc": "Computes the union of sets [s1] and [s2]",
    "pattern": "Combining two collections while eliminating duplicates, like merging user groups or combining search results"
  },
  {
    "id": "fca6d177-e52a-4094-b290-080e9e230079",
    "module": "Set",
    "name": "complement",
    "type": "function",
    "signature": "val complement : 'a Set.t -> 'a Set.t",
    "doc": "Computes the complement of set [s]",
    "pattern": "Finding all elements not in a set, useful for implementing negation or finding excluded items"
  },
  {
    "id": "b811fd70-f1fa-449e-9ce3-8bae0a5d9c66",
    "module": "Set",
    "name": "diff",
    "type": "function",
    "signature": "val diff : 'a Set.t -> 'a Set.t -> 'a Set.t",
    "doc": "Computes the difference of sets [s1] and [s2]",
    "pattern": "Finding elements in one collection but not another, like identifying unique permissions or filtering exclusions"
  },
  {
    "id": "32e0bb10-35da-4cd0-bdd9-c90d859ac50f",
    "module": "Set",
    "name": "of_list",
    "type": "function",
    "signature": "val of_list : 'a list -> ('a, bool) Map.t",
    "doc": "Creates a set from list [l] by recursively adding each element",
    "pattern": "Converting sequences or arrays to sets while eliminating duplicates, like creating a set of unique values from user input or data import"
  },
  {
    "id": "2605be9c-7a26-443f-ac0f-ca807baca360",
    "module": "Set",
    "name": "++",
    "type": "function",
    "signature": "val (++) : 'a Set.t -> 'a Set.t -> 'a Set.t",
    "doc": "An infix operator alias for [Set.union]",
    "pattern": "Providing a more concise syntax for combining sets, similar to overloaded operators in other languages"
  },
  {
    "id": "39cec8ee-d7e6-4b61-9e09-0f30f415ca6c",
    "module": "Set",
    "name": "--",
    "type": "function",
    "signature": "val (--) : 'a Set.t -> 'a Set.t -> 'a Set.t",
    "doc": "An infix operator alias for [Set.diff]",
    "pattern": "Providing a more concise syntax for set difference, similar to overloaded operators in other languages"
  },
  {
    "id": "5cf2a675-2feb-4bbb-9cbe-114940e417a6",
    "module": "Result",
    "name": "t",
    "type": "type",
    "signature": "type ('a, 'b) t = ('a, 'b) result",
    "doc": "The result type represents either success (Ok) or failure (Error) outcomes.",
    "pattern": null
  },
  {
    "id": "62acb534-f860-49d6-a81e-7cbbbe84b7e7",
    "module": "Result",
    "name": "return",
    "type": "function",
    "signature": "val return : 'a -> ('a, 'b) result",
    "doc": "wraps a value [x] in an Ok result",
    "pattern": "Converting raw values into success results for validation chains and computation sequences"
  },
  {
    "id": "14dcbbc8-cd0d-43f2-ae0d-63cb6bbab34e",
    "module": "Result",
    "name": "fail",
    "type": "function",
    "signature": "val fail : 'a -> ('b, 'a) result",
    "doc": "wraps a value [s] in an Error result",
    "pattern": "Converting error information into error results during validation or error handling"
  },
  {
    "id": "6e673e18-a5c9-46ae-9abb-e613780155aa",
    "module": "Result",
    "name": "map",
    "type": "function",
    "signature": "val map : ('b -> 'c) -> ('b, 'a) result -> ('c, 'a) result",
    "doc": "applies function [f] to the value inside [e] if it's Ok, otherwise propagates the Error",
    "pattern": "Applying transformations to success values while preserving error state"
  },
  {
    "id": "8be25b3a-06fa-4e6b-a7ea-3fe58894d2ad",
    "module": "Result",
    "name": "map_err",
    "type": "function",
    "signature": "val map_err : ('a -> 'c) -> ('b, 'a) result -> ('b, 'c) result",
    "doc": "applies function [f] to the error value if [e] is Error, otherwise propagates the Ok value",
    "pattern": "Converting between error types while preserving success values"
  },
  {
    "id": "ccec1298-fcaf-4c01-9f1a-01f9cb5d8f88",
    "module": "Result",
    "name": "get_or",
    "type": "function",
    "signature": "val get_or : default:'a -> ('a, 'b) result -> 'a",
    "doc": "extracts the Ok value from [e], or returns [default] if [e] is Error",
    "pattern": "Extracting values with fallback for error cases"
  },
  {
    "id": "8d24d7a0-1327-49bf-8134-88b40ef5f2c1",
    "module": "Result",
    "name": "map_or",
    "type": "function",
    "signature": "val map_or : default:'a -> ('c -> 'a) -> ('c, 'b) result -> 'a",
    "doc": "applies [f] to the Ok value in [e], or returns [default] if [e] is Error",
    "pattern": "Transforming success values with a fallback for error cases"
  },
  {
    "id": "182d80df-97ec-4d29-8c82-04867ee6d5e2",
    "module": "Result",
    "name": ">|=",
    "type": "function",
    "signature": "val (>|=) : ('b, 'a) result -> ('b -> 'c) -> ('c, 'a) result",
    "doc": "is an infix operator alias for [Result.map]",
    "pattern": "Infix syntax for transforming success values"
  },
  {
    "id": "f9e19df9-60c7-4e91-a7d6-b3d924629e8e",
    "module": "Result",
    "name": "flat_map",
    "type": "function",
    "signature": "val flat_map : ('b -> ('c, 'a) result) -> ('b, 'a) result -> ('c, 'a) result",
    "doc": "applies [f] to the Ok value in [e] to produce a new result, or propagates the Error",
    "pattern": "Chaining operations that can fail"
  },
  {
    "id": "93c47e0f-4b74-4910-b858-7edfa51647e1",
    "module": "Result",
    "name": ">>=",
    "type": "function",
    "signature": "val (>>=) : ('b, 'a) result -> ('b -> ('c, 'a) result) -> ('c, 'a) result",
    "doc": "is an infix operator alias for [Result.flat_map]",
    "pattern": "Infix syntax for chaining fallible operations"
  },
  {
    "id": "f34f7bd8-9311-47ee-bf13-cdbb152edc21",
    "module": "Result",
    "name": "fold",
    "type": "function",
    "signature": "val fold : ('b -> 'c) -> ('a -> 'c) -> ('b, 'a) result -> 'c",
    "doc": "applies [ok] to the value if [x] is Ok, or applies [error] if [x] is Error",
    "pattern": "Converting both success and error cases to a single type"
  },
  {
    "id": "6b1cf610-412d-4f10-9bfe-1144fecde003",
    "module": "Result",
    "name": "is_ok",
    "type": "function",
    "signature": "val is_ok : ('a, 'b) result -> bool",
    "doc": "returns true if [x] is Ok, false otherwise",
    "pattern": "Testing if a result represents success"
  },
  {
    "id": "1496c959-0bc5-4c7c-83a2-0f18b2fb7eb9",
    "module": "Result",
    "name": "is_error",
    "type": "function",
    "signature": "val is_error : ('a, 'b) result -> bool",
    "doc": "returns true if [x] is Error, false otherwise",
    "pattern": "Testing if a result represents failure"
  },
  {
    "id": "2ba78bbe-6695-49e2-8c36-47dc71877675",
    "module": "Result",
    "name": "monoid_product",
    "type": "function",
    "signature": "val monoid_product : ('a, 'b) result -> ('c, 'b) result -> ('a * 'c, 'b) result",
    "doc": "combines two results into a tuple if both are Ok, otherwise returns the first Error encountered",
    "pattern": "Combining two independent results into a tuple result"
  },
  {
    "id": "af1de029-f69f-451c-8611-9cbcd15fc870",
    "module": "Result",
    "name": "let+",
    "type": "function",
    "signature": "val let+ : ('c, 'a) result",
    "doc": "is a binding operator alias for [>|=] (map)",
    "pattern": "Binding syntax for transforming success values"
  },
  {
    "id": "3799b294-2bea-4c23-ba54-257abd84e413",
    "module": "Result",
    "name": "and+",
    "type": "function",
    "signature": "val and+ : (('a * 'c), 'b) result",
    "doc": "is a binding operator alias for [Result.monoid_product]",
    "pattern": "Binding syntax for combining independent results"
  },
  {
    "id": "1d5616cc-5a8f-47ce-b3ba-8d68af9fff60",
    "module": "Result",
    "name": "let*",
    "type": "function",
    "signature": "val let* : ('c, 'a) result",
    "doc": "is a binding operator alias for [>>=] (flat_map)",
    "pattern": "Binding syntax for chaining fallible operations"
  },
  {
    "id": "f3157bb4-0678-44b8-8aa6-8de92594ed53",
    "module": "Result",
    "name": "and*",
    "type": "function",
    "signature": "val and* : (('a * 'c), 'b) result",
    "doc": "is a binding operator alias for [Result.monoid_product]",
    "pattern": "Alternative binding syntax for combining results"
  },
  {
    "id": "a55b51bb-ea7e-4978-8e0d-b46781dfc747",
    "module": "Real",
    "name": "t",
    "type": "type",
    "signature": "type t = real",
    "doc": "The real number type representing arbitrary precision real numbers",
    "pattern": "Representing exact decimal numbers without floating point imprecision"
  },
  {
    "id": "83d6352a-77fa-4e95-ac57-2a26693b7071",
    "module": "Real",
    "name": "of_int",
    "type": "function",
    "signature": "val of_int : int -> real",
    "doc": "Converts an integer [i] to a real number",
    "pattern": "Converting integer values to real numbers for exact decimal arithmetic"
  },
  {
    "id": "bb2c8963-b829-4332-94f7-27acf75b1567",
    "module": "Real",
    "name": "_to_int_round_down",
    "type": "function",
    "signature": "val _to_int_round_down : real -> int",
    "doc": "Converts a real number [r] to an integer by rounding down. Internal helper function.",
    "pattern": "Internal function for floor rounding in integer conversion"
  },
  {
    "id": "c6479a26-0f3d-4dfb-b986-06ba5c2f88d0",
    "module": "Real",
    "name": "to_int",
    "type": "function",
    "signature": "val to_int : real -> int",
    "doc": "Converts a real number [r] to an integer by rounding towards zero",
    "pattern": "Converting real numbers to integers when decimal precision is no longer needed"
  },
  {
    "id": "65e32ef1-1589-46f5-838c-b700de1a860b",
    "module": "Real",
    "name": "+",
    "type": "function",
    "signature": "val (+) : real -> real -> real",
    "doc": "Adds two real numbers",
    "pattern": "Performing exact decimal addition without floating point errors"
  },
  {
    "id": "17e85764-2b59-4c9d-bb72-95eb1aa3b444",
    "module": "Real",
    "name": "-",
    "type": "function",
    "signature": "val (-) : real -> real -> real",
    "doc": "Subtracts two real numbers",
    "pattern": "Performing exact decimal subtraction without floating point errors"
  },
  {
    "id": "8e92578c-e048-4b27-8742-69808749b171",
    "module": "Real",
    "name": "~-",
    "type": "function",
    "signature": "val (~-) : real -> real",
    "doc": "Negates a real number",
    "pattern": "Changing the sign of a real number while preserving its magnitude"
  },
  {
    "id": "34234b09-fdeb-42e6-816e-6a80fd7714b0",
    "module": "Real",
    "name": "*",
    "type": "function",
    "signature": "val (*) : real -> real -> real",
    "doc": "Multiplies two real numbers",
    "pattern": "Performing exact decimal multiplication without floating point errors"
  },
  {
    "id": "f332bcf8-c53e-47d8-8091-f7ebf0cb70dc",
    "module": "Real",
    "name": "\/",
    "type": "function",
    "signature": "val (\/) : real -> real -> real",
    "doc": "Divides two real numbers",
    "pattern": "Performing exact decimal division without floating point errors"
  },
  {
    "id": "d2806bd0-3821-45b8-882f-06f85dcff698",
    "module": "Real",
    "name": "<",
    "type": "function",
    "signature": "val (<) : real -> real -> bool",
    "doc": "Tests if one real number is less than another",
    "pattern": "Comparing real numbers for strict ordering relationships"
  },
  {
    "id": "774484f4-2589-4303-9fda-9ec62085d6ad",
    "module": "Real",
    "name": "<=",
    "type": "function",
    "signature": "val (<=) : real -> real -> bool",
    "doc": "Tests if one real number is less than or equal to another",
    "pattern": "Comparing real numbers for non-strict ordering relationships"
  },
  {
    "id": "653ae89b-d4c2-4cc5-a390-e0ba24d92be4",
    "module": "Int",
    "name": "\/",
    "type": "function",
    "signature": "val (\/) : int -> int -> int",
    "doc": "Division operator for integers",
    "pattern": "Integer division with truncation toward zero"
  },
  {
    "id": "0d1b928a-cad8-4dba-ab0b-8ea358372634",
    "module": "Real",
    "name": ">",
    "type": "function",
    "signature": "val (>) : real -> real -> bool",
    "doc": "Tests if one real number is greater than another",
    "pattern": "Comparing real numbers for strict ordering relationships"
  },
  {
    "id": "ca6cf17d-c86c-4236-8785-86da9fef8df2",
    "module": "Real",
    "name": ">=",
    "type": "function",
    "signature": "val (>=) : real -> real -> bool",
    "doc": "Tests if one real number is greater than or equal to another",
    "pattern": "Comparing real numbers for non-strict ordering relationships"
  },
  {
    "id": "2c1c94d9-e94d-4945-8e6a-813b91da0a9d",
    "module": "Real",
    "name": "abs",
    "type": "function",
    "signature": "val abs : real -> real",
    "doc": "Returns the absolute value of real number [r]",
    "pattern": "Getting the magnitude of a real number regardless of sign"
  },
  {
    "id": "0e53f3c2-fd38-4c57-8d7e-b7017b40f828",
    "module": "Real",
    "name": "min",
    "type": "function",
    "signature": "val min : real -> real -> real",
    "doc": "Returns the minimum of two real numbers",
    "pattern": "Finding the smaller of two real numbers in comparisons"
  },
  {
    "id": "aff2e2e5-3d3a-42dc-a950-bb5e0de358ba",
    "module": "Real",
    "name": "max",
    "type": "function",
    "signature": "val max : real -> real -> real",
    "doc": "Returns the maximum of two real numbers",
    "pattern": "Finding the larger of two real numbers in comparisons"
  },
  {
    "id": "d8e7e7bc-e7c3-4560-a5ba-897b4a36bd44",
    "module": "Real",
    "name": "of_float",
    "type": "function",
    "signature": "val of_float : float -> real",
    "doc": "Converts a float [f] to a real number",
    "pattern": "Converting approximate floating point numbers to exact real numbers"
  },
  {
    "id": "9344c029-c633-48f6-8c89-75b9450b78ad",
    "module": "Real",
    "name": "pow",
    "type": "function",
    "signature": "val pow : real -> int -> real",
    "doc": "Raises real number [base] to integer power [exp]",
    "pattern": "Computing exact integer powers of real numbers"
  },
  {
    "id": "b6519f55-7fa7-49c7-9196-f534fbc5458a",
    "module": "String",
    "name": "t",
    "type": "type",
    "signature": "type String.t = string",
    "doc": "These strings correspond to OCaml native strings, and do not have a particular unicode encoding. Rather, they should be seen as sequences of bytes, and it is also this way that Imandra considers them.",
    "pattern": null
  },
  {
    "id": "214d7a6c-e90a-4d4b-9370-048f868ddec6",
    "module": "String",
    "name": "empty",
    "type": "function",
    "signature": "val empty : string",
    "doc": "Returns an empty string",
    "pattern": "Initializing an empty string, like \"\" in other languages"
  },
  {
    "id": "3b0ac11f-8278-4f6b-8d68-2aa15c85d156",
    "module": "String",
    "name": "length",
    "type": "function",
    "signature": "val length : String.t -> int",
    "doc": "Length of the string, i.e. its number of bytes",
    "pattern": "Getting string length, similar to .length or len() in other languages"
  },
  {
    "id": "3aa61e07-b32c-4d20-917d-21893d1ea5d5",
    "module": "String",
    "name": "append",
    "type": "function",
    "signature": "val append : String.t -> String.t -> String.t",
    "doc": "String concatenation",
    "pattern": "Joining two strings together, like + operator or concat() in other languages"
  },
  {
    "id": "30d58c6d-3229-4ca3-b216-194f9c348f51",
    "module": "String",
    "name": "concat",
    "type": "function",
    "signature": "val concat : string -> String.t list -> string",
    "doc": "[concat sep l] concatenates strings in [l] with [sep] inserted between each element. - [concat sep [] = \"\"]\n- [concat sep [x] = x]\n- [concat sep [x;y] = x ^ sep ^ y]\n- [concat sep (x :: tail) = x ^ sep ^ concat sep tail]",
    "pattern": "Joining array\/list of strings with separator, like join() or String.join() in other languages"
  },
  {
    "id": "3e9fa6bd-6f10-416e-a029-b3a2e87496a7",
    "module": "String",
    "name": "prefix",
    "type": "function",
    "signature": "val prefix : String.t -> String.t -> bool",
    "doc": "[prefix a b] returns [true] iff [a] is a prefix of [b] (or if [a=b])",
    "pattern": "Checking if string starts with another string, like startsWith() in other languages"
  },
  {
    "id": "460b04a1-3fe4-4fc6-990a-e3fbc0f77fef",
    "module": "String",
    "name": "suffix",
    "type": "function",
    "signature": "val suffix : String.t -> String.t -> bool",
    "doc": "[suffix a b] returns [true] iff [a] is a suffix of [b] (or if [a=b])",
    "pattern": "Checking if string ends with another string, like endsWith() in other languages"
  },
  {
    "id": "903d5649-5d06-410b-9319-7c99c8d29f4c",
    "module": "String",
    "name": "contains",
    "type": "function",
    "signature": "val contains : String.t -> String.t -> bool",
    "doc": "[String.contains s1 s2] tests if [s2] appears as a substring within [s1]",
    "pattern": "Checking if string contains substring, like includes() or contains() in other languages"
  },
  {
    "id": "6e8bdfe2-42f9-4cd7-959b-a19ece6b3512",
    "module": "String",
    "name": "unsafe_sub",
    "type": "function",
    "signature": "val unsafe_sub : String.t -> int -> int -> String.t",
    "doc": "[String.unsafe_sub s pos len] extracts substring of [s] starting at [pos] of length [len]. No bounds checking - use [String.sub] for safe substring extraction",
    "pattern": "Low-level substring extraction without bounds checking, like internal substring operations"
  },
  {
    "id": "5f68408f-92b2-4c58-8d2b-546e474e79bc",
    "module": "String",
    "name": "sub",
    "type": "function",
    "signature": "val sub : string -> int -> int -> String.t option",
    "doc": "[String.sub s i len] returns the string [s[i], s[i+1],â€¦,s[i+len-1]].",
    "pattern": "Safe substring extraction with bounds checking, like substring() in other languages"
  },
  {
    "id": "6a33ade7-d7a0-41d5-aca4-8e8e2775141e",
    "module": "String",
    "name": "of_int",
    "type": "function",
    "signature": "val of_int : int -> string",
    "doc": "String representation of an integer",
    "pattern": "Converting integer to string, like toString() or str() in other languages"
  },
  {
    "id": "ca6bae19-3a5c-45d2-ac55-84110f55253f",
    "module": "String",
    "name": "unsafe_to_nat",
    "type": "function",
    "signature": "val unsafe_to_nat : String.t -> int",
    "doc": "[String.unsafe_to_nat s] converts string [s] to natural number without validation. Use [String.to_nat] for safe conversion",
    "pattern": "Low-level string to number conversion without validation"
  },
  {
    "id": "9ccf4bc9-cbea-47e0-8eab-77db3aeacefe",
    "module": "String",
    "name": "to_nat",
    "type": "function",
    "signature": "val to_nat : string -> int option",
    "doc": "Parse a string into a nonnegative number, or return [None]",
    "pattern": "Safe conversion of string to natural number, like parseInt() with validation"
  },
  {
    "id": "4c27ff4a-4a0e-46ab-bd65-8b9c5069d4b0",
    "module": "String",
    "name": "is_nat",
    "type": "function",
    "signature": "val is_nat : string -> bool",
    "doc": "[String.is_nat s] tests if string [s] represents a valid natural number",
    "pattern": "Validating if string represents non-negative integer, like input validation"
  },
  {
    "id": "e5978e5b-2df6-4393-9c7b-c87d82a5699d",
    "module": "String",
    "name": "is_int",
    "type": "function",
    "signature": "val is_int : string -> bool",
    "doc": "[String.is_int s] tests if string [s] represents a valid integer",
    "pattern": "Validating if string represents any integer (positive\/negative), like input validation"
  },
  {
    "id": "2b296601-a766-4afb-838b-cda7d212a73b",
    "module": "String",
    "name": "unsafe_to_int",
    "type": "function",
    "signature": "val unsafe_to_int : string -> int",
    "doc": "[String.unsafe_to_int s] converts string [s] to integer without validation. Use [String.to_int] for safe conversion",
    "pattern": "Low-level string to integer conversion without validation"
  },
  {
    "id": "22698976-4a1a-4716-942f-fdc4093a5d72",
    "module": "String",
    "name": "to_int",
    "type": "function",
    "signature": "val to_int : string -> int option",
    "doc": "[String.to_int s] safely converts string [s] to integer. Returns None if [s] is not a valid integer",
    "pattern": "Safe conversion of string to integer with validation, like parseInt() with error handling"
  },
  {
    "id": "6c16e396-c5b7-4c9e-979a-ca399b525460",
    "module": "Option",
    "name": "t",
    "type": "type",
    "signature": "type 'a t = 'a option",
    "doc": "The option type representing optional values. Can be either [None] representing absence of a value, or [Some x] containing a value [x] of type ['a].",
    "pattern": null
  },
  {
    "id": "07057c15-2c82-4b25-989b-7bb244201526",
    "module": "Option",
    "name": "map",
    "type": "function",
    "signature": "val map : ('a -> 'b) -> 'a option -> 'b option",
    "doc": "Transforms an optional value by applying function [f] to the contained value. If [x] is [None], returns [None]. If [x] is [Some v], returns [Some (f v)]. This allows transforming the value while preserving the optional structure.",
    "pattern": "Transforming optional values without having to explicitly handle the None case"
  },
  {
    "id": "94f6f3e8-b104-4df0-8810-e8a2390c564b",
    "module": "Int",
    "name": "mod",
    "type": "function",
    "signature": "val (mod) : int -> int -> int",
    "doc": "Modulo operator for integers",
    "pattern": "Computing remainders and wrapping values"
  },
  {
    "id": "5d5fab0b-8ed7-4eef-9f76-647329bdf600",
    "module": "Int",
    "name": "<",
    "type": "function",
    "signature": "val (<) : int -> int -> bool",
    "doc": "Less than comparison operator",
    "pattern": "Numeric ordering comparison"
  },
  {
    "id": "b201a32e-5678-4767-bfa9-5b169ba08220",
    "module": "Option",
    "name": "map_or",
    "type": "function",
    "signature": "val map_or : default:'a -> ('b -> 'a) -> 'b option -> 'a",
    "doc": "Transforms an optional value into a definite value. If [x] is [Some v], applies [f] to [v]. If [x] is [None], returns the [default] value. This ensures a value is always returned, handling the None case with a default.",
    "pattern": "Converting optional values to non-optional with a fallback value"
  },
  {
    "id": "f59dc5f3-7d5d-4bbd-9709-ce3465fff444",
    "module": "Option",
    "name": "is_some",
    "type": "function",
    "signature": "val is_some : 'a option -> bool",
    "doc": "Checks if an option contains a value. Returns [true] if [x] is [Some _], [false] if [x] is [None]. Useful for checking presence of optional values without extracting them.",
    "pattern": "Testing if an optional value is present before attempting to use it"
  },
  {
    "id": "34ce3a24-8fdc-4fea-93b8-4e160044e09b",
    "module": "Option",
    "name": "is_none",
    "type": "function",
    "signature": "val is_none : 'a option -> bool",
    "doc": "Checks if an option is empty. Returns [true] if [x] is [None], [false] if [x] is [Some _]. Complement of [Option.is_some].",
    "pattern": "Testing if an optional value is absent\/null\/undefined"
  },
  {
    "id": "2f27d926-2996-4b39-acf2-57c6b63e742c",
    "module": "Option",
    "name": "return",
    "type": "function",
    "signature": "val return : 'a -> 'a option",
    "doc": "Wraps a value in [Some] constructor. This is the fundamental way to create an optional value containing something. Always returns [Some x] for any input [x].",
    "pattern": "Converting regular values into optional values for optional-aware functions"
  },
  {
    "id": "de8fe3bd-266a-4496-b049-72870667fcd2",
    "module": "Option",
    "name": ">|=",
    "type": "function",
    "signature": "val (>|=) : 'a option -> ('a -> 'b) -> 'b option",
    "doc": "An infix operator version of [Option.map]. Allows writing [x >|= f] instead of [Option.map f x] for more natural composition syntax.",
    "pattern": "Chaining transformations on optional values in a pipeline style"
  },
  {
    "id": "33898860-addb-45e7-8211-55da2e69bb10",
    "module": "Option",
    "name": "flat_map",
    "type": "function",
    "signature": "val flat_map : ('a -> 'b option) -> 'a option -> 'b option",
    "doc": "Applies a function that returns an option to an optional value. If [x] is [None], returns [None]. If [x] is [Some v], returns [f v]. Used for composing operations that may each produce optional results.",
    "pattern": "Chaining multiple operations that each might fail\/return nothing"
  },
  {
    "id": "ba6a52c3-d047-422e-a4e5-47c00e147717",
    "module": "Option",
    "name": ">>=",
    "type": "function",
    "signature": "val (>>=) : 'a option -> ('a -> 'b option) -> 'b option",
    "doc": "An infix operator version of [Option.flat_map]. Allows writing [x >>= f] instead of [Option.flat_map f x]. Standard monadic bind operator for options.",
    "pattern": "Chaining optional computations in a pipeline style"
  },
  {
    "id": "3de8d8e6-f481-4f67-a53f-165c4a4494c7",
    "module": "Option",
    "name": "or_",
    "type": "function",
    "signature": "val or_ : 'a option -> 'a option -> 'a option",
    "doc": "Provides a fallback option. Returns [a] if it contains a value, otherwise returns [b]. Useful for providing default optional values.",
    "pattern": "Providing fallback values when the primary optional value is None"
  },
  {
    "id": "51cc930f-f69f-4c1e-8fc3-930f66cd779f",
    "module": "Option",
    "name": "<+>",
    "type": "function",
    "signature": "val (<+>) : 'a option -> 'a option -> 'a option",
    "doc": "An infix operator version of [Option.or_]. Allows writing [a <+> b] instead of [Option.or_ a b] for more natural fallback syntax.",
    "pattern": "Chaining multiple fallback options in order of preference"
  },
  {
    "id": "708e7438-de81-4629-8689-520d5a1177ee",
    "module": "Option",
    "name": "exists",
    "type": "function",
    "signature": "val exists : ('a -> bool) -> 'a option -> bool",
    "doc": "Tests if the value in an option satisfies a predicate. Returns [false] if [x] is [None], otherwise returns [p v] where [v] is the contained value. Similar to [List.exists] but for a single optional value.",
    "pattern": "Testing properties of optional values without explicit None handling"
  },
  {
    "id": "8506d628-5811-4dcc-96cc-887a3e59cded",
    "module": "Option",
    "name": "for_all",
    "type": "function",
    "signature": "val for_all : ('a -> bool) -> 'a option -> bool",
    "doc": "Tests if the value in an option satisfies a predicate. Returns [true] if [x] is [None], otherwise returns [p v] where [v] is the contained value. Similar to [List.for_all] but for a single optional value.",
    "pattern": "Validating properties of optional values with None considered valid"
  },
  {
    "id": "08d046e3-109e-4307-ac7f-a27b7aa49083",
    "module": "Option",
    "name": "get_or",
    "type": "function",
    "signature": "val get_or : default:'a -> 'a option -> 'a",
    "doc": "Safely extracts the value from an option with a fallback. Returns the value contained in [x] if present, otherwise returns the [default] value. Ensures a value is always returned without risk of exceptions.",
    "pattern": "Safely extracting values from optionals with a default value"
  },
  {
    "id": "6dc8b1e0-41d8-492b-a8b1-cca4aab6fc79",
    "module": "Option",
    "name": "fold",
    "type": "function",
    "signature": "val fold : ('a -> 'b -> 'a) -> 'a -> 'b option -> 'a",
    "doc": "Reduces an optional value using an accumulator. If [x] is [None], returns [acc] unchanged. If [x] is [Some v], returns [f acc v]. Similar to [List.fold_left] but for a single optional value.",
    "pattern": "Accumulating\/reducing optional values into a single result"
  },
  {
    "id": "c61579ac-03df-4a69-8e26-5242a3a5fd81",
    "module": "Option",
    "name": "<$>",
    "type": "function",
    "signature": "val (<$>) : ('a -> 'b) -> 'a option -> 'b option",
    "doc": "An infix operator alias for [Option.map f x]. Provides applicative functor syntax for mapping over options.",
    "pattern": "Applying functions to optional values in a functional style"
  },
  {
    "id": "7fc7d8df-fe39-4f1d-a5e5-e515c62cfc38",
    "module": "Option",
    "name": "monoid_product",
    "type": "function",
    "signature": "val monoid_product : 'a option -> 'b option -> ('a * 'b) option",
    "doc": "Combines two options into a tuple option. Returns [Some (x,y)] if both inputs contain values, [None] if either is [None]. Used for combining independent optional computations.",
    "pattern": "Combining multiple optional values that all must be present"
  },
  {
    "id": "1a82a4c2-261a-4f77-86d7-5ec96714aafc",
    "module": "Option",
    "name": "let+",
    "type": "function",
    "signature": "val let+ : 'a option -> ('a -> 'b) -> 'b option",
    "doc": "A binding operator alias for [Option.>|=]. Provides syntactic sugar for mapping over options in let-binding syntax.",
    "pattern": "Transforming optional values in a let-binding style"
  },
  {
    "id": "993062eb-9bb2-4ef4-ba73-3b681949b18b",
    "module": "Option",
    "name": "and+",
    "type": "function",
    "signature": "val and+ : 'a option -> 'b option -> ('a * 'b) option",
    "doc": "A binding operator alias for [Option.monoid_product]. Provides syntactic sugar for combining options in let-binding syntax.",
    "pattern": "Combining multiple optional values in a let-binding style"
  },
  {
    "id": "9982e4f8-266d-4a86-a811-c42311041d79",
    "module": "Option",
    "name": "let*",
    "type": "function",
    "signature": "val let* : 'a option -> ('a -> 'b option) -> 'b option",
    "doc": "A binding operator alias for [Option.>>=]. Provides monadic let-binding syntax for sequencing optional computations.",
    "pattern": "Chaining optional computations in a let-binding style"
  },
  {
    "id": "899bd2d2-b5c2-44d3-ac18-862405c8cb86",
    "module": "Option",
    "name": "and*",
    "type": "function",
    "signature": "val and* : 'a option -> 'b option -> ('a * 'b) option",
    "doc": "A binding operator alias for [Option.monoid_product]. Alternative syntax for combining options in monadic let-binding style.",
    "pattern": "Combining multiple optional values in a monadic let-binding style"
  },
  {
    "id": "d336aa59-c410-406b-8dff-54d73a12ba24",
    "module": "Int",
    "name": "+",
    "type": "function",
    "signature": "val (+) : int -> int -> int",
    "doc": "Addition operator for integers",
    "pattern": "Basic arithmetic addition"
  },
  {
    "id": "7dfb1917-a5d1-4052-96a8-beca4102de17",
    "module": "Int",
    "name": "-",
    "type": "function",
    "signature": "val (-) : int -> int -> int",
    "doc": "Subtraction operator for integers",
    "pattern": "Basic arithmetic subtraction"
  },
  {
    "id": "85587cab-d140-4b1f-8c67-43333fc65b53",
    "module": "Int",
    "name": "~-",
    "type": "function",
    "signature": "val (~-) : int -> int",
    "doc": "Unary negation operator for integers",
    "pattern": "Negating a number"
  },
  {
    "id": "5c30cf02-185f-42d8-b968-566efbae3352",
    "module": "Int",
    "name": "*",
    "type": "function",
    "signature": "val (*) : int -> int -> int",
    "doc": "Multiplication operator for integers",
    "pattern": "Basic arithmetic multiplication"
  },
  {
    "id": "34d96993-d31e-4a2c-9dfc-ef2a0eb5041d",
    "module": "Int",
    "name": "<=",
    "type": "function",
    "signature": "val (<=) : int -> int -> bool",
    "doc": "Less than or equal comparison operator",
    "pattern": "Numeric ordering and equality comparison"
  },
  {
    "id": "3750bdeb-8cd2-411d-bdf8-6228018287cd",
    "module": "Int",
    "name": ">",
    "type": "function",
    "signature": "val (>) : int -> int -> bool",
    "doc": "Greater than comparison operator",
    "pattern": "Numeric ordering comparison"
  },
  {
    "id": "3af51977-af50-4380-8869-116cd1cef491",
    "module": "Int",
    "name": ">=",
    "type": "function",
    "signature": "val (>=) : int -> int -> bool",
    "doc": "Greater than or equal comparison operator",
    "pattern": "Numeric ordering and equality comparison"
  },
  {
    "id": "44f83e75-cffb-40f9-8f80-0275c9354923",
    "module": "Int",
    "name": "min",
    "type": "function",
    "signature": "val min : int -> int -> int",
    "doc": "Returns the minimum of two integers",
    "pattern": "Finding smaller of two values"
  },
  {
    "id": "74bc2ac0-82c7-4533-bdaf-eb2bf0012a79",
    "module": "Int",
    "name": "max",
    "type": "function",
    "signature": "val max : int -> int -> int",
    "doc": "Returns the maximum of two integers",
    "pattern": "Finding larger of two values"
  },
  {
    "id": "12742dea-51d5-4290-9d29-357b545e2f4b",
    "module": "Int",
    "name": "abs",
    "type": "function",
    "signature": "val abs : int -> int",
    "doc": "Returns absolute value of an integer",
    "pattern": "Getting magnitude of a number"
  },
  {
    "id": "2c3f1599-3c5e-4f6a-8fd1-f022b3c11d3e",
    "module": "Int",
    "name": "to_string",
    "type": "function",
    "signature": "val to_string : int -> string",
    "doc": "Converts non-negative integer to string representation",
    "pattern": "String formatting and display of numbers"
  },
  {
    "id": "2d9cd9ef-0c9f-4773-b3be-dab0e884cdda",
    "module": "Int",
    "name": "compare",
    "type": "function",
    "signature": "val compare : int -> int -> int",
    "doc": "Returns -1 if x < y, 0 if x = y, 1 if x > y",
    "pattern": "Three-way comparison for sorting and ordering"
  },
  {
    "id": "49ce5119-aed1-4e58-8561-ffdd1e4231e8",
    "module": "Int",
    "name": "equal",
    "type": "function",
    "signature": "val equal : 'a -> 'a -> bool",
    "doc": "Tests equality of two integers",
    "pattern": "Value equality comparison"
  },
  {
    "id": "1e9628ca-9856-4a82-8971-9ebf35b5f3f4",
    "module": "Int",
    "name": "pow",
    "type": "function",
    "signature": "val pow : int -> int -> int",
    "doc": "Computes x raised to power n",
    "pattern": "Exponential calculations"
  },
  {
    "id": "02fb2f80-526f-432c-ae9c-c08a1bb0e844",
    "module": "LChar",
    "name": "t",
    "type": "type",
    "signature": "type LChar.t =\n LChar.Char of bool * bool * bool * bool * bool * bool * bool * bool",
    "doc": "An 8-bit character",
    "pattern": null
  },
  {
    "id": "f4e1cec9-1cab-4d1d-95da-6a5b9411a646",
    "module": "LChar",
    "name": "zero",
    "type": "function",
    "signature": "val zero : LChar.t",
    "doc": "Returns a character with all bits set to false (null character)",
    "pattern": "Creating a null\/zero character, like '\\0' or character code 0 in other languages"
  },
  {
    "id": "7fb9fac2-4f04-4571-bfd9-1846cff5ef9f",
    "module": "LChar",
    "name": "is_printable",
    "type": "function",
    "signature": "val is_printable : LChar.t -> bool",
    "doc": "Tests if character [c] is printable based on its bit pattern",
    "pattern": "Checking if a character is displayable\/printable, like isprint() or similar character classification functions"
  },
  {
    "id": "ad5f7639-625a-4af5-901e-3b21ebc4a113",
    "module": "List",
    "name": "t",
    "type": "type",
    "signature": "type 'a t = 'a list",
    "doc": "list",
    "pattern": null
  },
  {
    "id": "e3b3a3cf-b33f-4931-91a8-17c3a3789ecf",
    "module": "List",
    "name": "empty",
    "type": "function",
    "signature": "val empty : 'a list",
    "doc": "Returns an empty list",
    "pattern": "Creating an empty list, initializing a new list with no elements"
  },
  {
    "id": "b9f2d3ab-7445-4e74-a90a-87ace0b81bfa",
    "module": "List",
    "name": "is_empty",
    "type": "function",
    "signature": "val is_empty : 'a list -> bool",
    "doc": "Tests whether list [l] is empty",
    "pattern": "Checking if a list has no elements"
  },
  {
    "id": "82007d38-2d42-4620-b6de-6dfce7d3c38d",
    "module": "List",
    "name": "cons",
    "type": "function",
    "signature": "val cons : 'a -> 'a list -> 'a list",
    "doc": "Prepends [x] to the beginning of [l], returning a new list",
    "pattern": "Adding an element to the front of a list"
  },
  {
    "id": "7635622c-f121-4078-8c34-501b81ed97a3",
    "module": "List",
    "name": "return",
    "type": "function",
    "signature": "val return : 'a -> 'a list",
    "doc": "Creates a singleton list containing only [x]",
    "pattern": "Creating a single-element list"
  },
  {
    "id": "96c30a1c-edb9-4b86-9b82-ea3f700e60c3",
    "module": "List",
    "name": "hd",
    "type": "function",
    "signature": "val hd : 'a list -> 'a",
    "doc": "Returns the first element of list [l]. Partial function that fails on empty lists. But it is recommended to rely on pattern matching instead",
    "pattern": "Getting first element of list, with no safety check"
  },
  {
    "id": "6fb7cf9b-45fa-4030-b479-70b1d2854f4b",
    "module": "List",
    "name": "tl",
    "type": "function",
    "signature": "val tl : 'a list -> 'a list",
    "doc": "Returns the list [l] without its first element. Partial function that fails on empty lists. But it is recommended to rely on pattern matching instead",
    "pattern": "Getting all elements except first, with no safety check"
  },
  {
    "id": "d71c2a0f-7145-4098-bce0-8dabcf4ed1f5",
    "module": "List",
    "name": "head_opt",
    "type": "function",
    "signature": "val head_opt : 'a list -> 'a option",
    "doc": "Returns [Some x] where [x] is the first element of [l], or [None] if [l] is empty",
    "pattern": "Safely getting first element of list with null check"
  },
  {
    "id": "f1fa585f-54f3-4794-b648-e90555c1a4cd",
    "module": "List",
    "name": "append",
    "type": "function",
    "signature": "val append : 'a list -> 'a list -> 'a list",
    "doc": "Returns a list composed of all elements of [l1], followed by all elements of [l2]",
    "pattern": "Concatenating two lists together"
  },
  {
    "id": "42fd44a3-b2d9-4c1c-b0e5-1b957ea08934",
    "module": "List",
    "name": "rev",
    "type": "function",
    "signature": "val rev : 'a list -> 'a list",
    "doc": "Returns a new list with all elements of [l] in reverse order",
    "pattern": "Reversing order of elements in list"
  },
  {
    "id": "eb3d4ae5-7b61-40f2-ba28-2678cfccf74f",
    "module": "List",
    "name": "length",
    "type": "function",
    "signature": "val length : 'a list -> int",
    "doc": "Returns the number of elements in list [l]. Linear time",
    "pattern": "Getting number of elements in list"
  },
  {
    "id": "a3aaa94b-a468-45d2-9d7d-36b47de8b0e7",
    "module": "List",
    "name": "split",
    "type": "function",
    "signature": "val split : ('a * 'b) list -> 'a list * 'b list",
    "doc": "Takes a list of pairs and returns a pair of lists",
    "pattern": "Converting list of tuples into tuple of lists"
  },
  {
    "id": "402862fd-cc56-4b2a-a9af-a295f499dd31",
    "module": "List",
    "name": "map",
    "type": "function",
    "signature": "val map : ('a -> 'b) -> 'a list -> 'b list",
    "doc": "Applies function [f] to each element of [l] and returns the resulting list.",
    "pattern": "Transforming each element of list using a function"
  },
  {
    "id": "e77bf44b-80d9-453a-979a-3defcdbe86cd",
    "module": "List",
    "name": "map2",
    "type": "function",
    "signature": "val map2 : ('c -> 'a -> 'b) -> 'c list -> 'a list -> ('b list, string) result",
    "doc": "Maps function [f] over pairs of elements from [l1] and [l2]. Returns [Error] if lists have different lengths",
    "pattern": "Combining elements from two lists using a function"
  },
  {
    "id": "40e19c3b-db50-4dc7-8549-94f7ffaaef03",
    "module": "List",
    "name": "for_all",
    "type": "function",
    "signature": "val for_all : ('a -> bool) -> 'a list -> bool",
    "doc": "Tests whether all elements of [l] satisfy predicate [f]",
    "pattern": "Testing if condition holds for all elements"
  },
  {
    "id": "83a200c7-a8bf-4f75-a023-6190bd9d8852",
    "module": "List",
    "name": "exists",
    "type": "function",
    "signature": "val exists : ('a -> bool) -> 'a list -> bool",
    "doc": "Tests whether there exists an element in [l] that satisfies predicate [f]",
    "pattern": "Testing if condition holds for at least one element"
  },
  {
    "id": "17b3892d-b7f9-42d5-a024-e5dc6a3556fb",
    "module": "List",
    "name": "fold_left",
    "type": "function",
    "signature": "val fold_left : ('b -> 'a -> 'b) -> 'b -> 'a list -> 'b",
    "doc": "Folds list [l] from left to right using function [f] and initial accumulator [acc]",
    "pattern": "Reducing list to single value by processing elements left-to-right"
  },
  {
    "id": "f9acbfd8-27e4-4933-a306-e16c649fe90a",
    "module": "List",
    "name": "fold_right",
    "type": "function",
    "signature": "val fold_right : ('b -> 'a -> 'a) -> 'b list -> 'a -> 'a",
    "doc": "Folds list [l] from right to left using function [f] and initial accumulator [acc]",
    "pattern": "Reducing list to single value by processing elements right-to-left"
  },
  {
    "id": "c7c2880c-8c14-4aa3-bf5e-476cd7b51808",
    "module": "List",
    "name": "mapi",
    "type": "function",
    "signature": "val mapi : (int -> 'b -> 'a) -> 'b list -> 'a list",
    "doc": "Maps function [f] over list [l], passing both the element and its index to [f]",
    "pattern": "Transforming elements with access to their position\/index"
  },
  {
    "id": "ff7f9bf8-430c-4901-86d1-a364e2204884",
    "module": "List",
    "name": "filter",
    "type": "function",
    "signature": "val filter : ('a -> bool) -> 'a list -> 'a list",
    "doc": "Keeps only the elements of [l] that satisfy [f]",
    "pattern": "Filtering elements from a collection based on a condition"
  },
  {
    "id": "8de956fa-ffff-4ea0-9de1-054352501a17",
    "module": "Multiset",
    "name": "t",
    "type": "type",
    "signature": "type Multiset.t = ('a, int) Map.t",
    "doc": "The multiset type, implemented as a map from elements to their occurrence counts. Each element is associated with an integer representing how many times it appears in the multiset.",
    "pattern": null
  },
  {
    "id": "9c07b7a6-599a-41f3-964d-0743b5a4d791",
    "module": "List",
    "name": "filter_map",
    "type": "function",
    "signature": "val filter_map : ('a -> 'b option) -> 'a list -> 'b list",
    "doc": "Applies [f] to each element of [l]. If [f] returns [Some y], keeps [y] in result list. If [f] returns [None], that element is dropped",
    "pattern": "Combined filtering and transformation of elements, like filter().map() or comprehensions"
  },
  {
    "id": "8e0443d0-b73f-4b51-bdbc-c45a8d7ca70e",
    "module": "List",
    "name": "flat_map",
    "type": "function",
    "signature": "val flat_map : ('b -> 'a list) -> 'b list -> 'a list",
    "doc": "Applies [f] to each element of [l] and concatenates all resulting lists",
    "pattern": "Mapping elements to lists and flattening results, like flatMap() or SelectMany()"
  },
  {
    "id": "22933771-8b21-443c-82c9-f28fecb42dda",
    "module": "List",
    "name": "find",
    "type": "function",
    "signature": "val find : ('a -> bool) -> 'a list -> 'a option",
    "doc": "Returns [Some x] if [x] is the first element of [l] such that [f x] is true. Otherwise it returns [None]",
    "pattern": "Finding first element matching condition, like find() or First()"
  },
  {
    "id": "6f831096-b7d1-4446-8bd3-288c1bf42403",
    "module": "List",
    "name": "mem",
    "type": "function",
    "signature": "val mem : 'a -> 'a list -> bool",
    "doc": "Returns [true] iff [x] is an element of [l]",
    "pattern": "Testing if value exists in collection, like includes() or contains()"
  },
  {
    "id": "8aa6ff21-8339-44c1-a12c-9b7b92a72d40",
    "module": "List",
    "name": "mem_assoc",
    "type": "function",
    "signature": "val mem_assoc : 'a -> ('a * 'b) list -> bool",
    "doc": "Returns [true] if [x] appears as a key in association list [l]",
    "pattern": "Testing if key exists in key-value pairs, like hasKey() or containsKey()"
  },
  {
    "id": "543dd867-ef5c-4fcc-ad87-c40bb9a09999",
    "module": "List",
    "name": "nth",
    "type": "function",
    "signature": "val nth : int -> 'a list -> 'a option",
    "doc": "Returns [Some x] where [x] is the nth element of [l], or [None] if list is too short",
    "pattern": "Safe indexed access to collection elements, like get() or ElementAt()"
  },
  {
    "id": "1acdd676-1e07-4538-b399-8fe6e118b189",
    "module": "List",
    "name": "assoc",
    "type": "function",
    "signature": "val assoc : 'a -> ('a * 'b) list -> 'b option",
    "doc": "Returns [Some v] if [(x,v)] appears in association list [l], [None] otherwise",
    "pattern": "Looking up values by key in key-value pairs, like get() or TryGetValue()"
  },
  {
    "id": "a2411299-4099-45b6-b4a1-abcd613161d6",
    "module": "List",
    "name": "bounded_recons",
    "type": "function",
    "signature": "val bounded_recons : int -> 'a list -> 'a list",
    "doc": "Like [List.take n l], but measured subset is [n] instead of [l]",
    "pattern": "Taking first N elements with focus on count rather than input"
  },
  {
    "id": "c7c2d78a-e61f-4d7a-8317-26bed81d7b81",
    "module": "List",
    "name": "take",
    "type": "function",
    "signature": "val take : int -> 'a list -> 'a list",
    "doc": "Returns a list composed of the first (at most) [n] elements of [l]. If [length l <= n] then it returns [l]",
    "pattern": "Taking first N elements from collection, like take() or slice(0,n)"
  },
  {
    "id": "6d51029c-2604-466a-8d4c-857f1ed7fed3",
    "module": "List",
    "name": "drop",
    "type": "function",
    "signature": "val drop : int -> 'a list -> 'a list",
    "doc": "Returns [l] where the first (at most) [n] elements have been removed. If [length l <= n] then it returns [[]]",
    "pattern": "Skipping first N elements from collection, like skip() or slice(n)"
  },
  {
    "id": "28a28c40-369c-4b97-8c93-210d5b0975e3",
    "module": "List",
    "name": "range",
    "type": "function",
    "signature": "val range : int -> int -> int list",
    "doc": "Integer range. [List.range i j] is the list [[i; i+1; i+2; â€¦; j-1]]. Returns the empty list if [i >= j]",
    "pattern": "Generating sequence of integers, like range() or Enumerable.Range()"
  },
  {
    "id": "48509b77-7483-48c2-8277-08babca760cd",
    "module": "List",
    "name": "insert_sorted",
    "type": "function",
    "signature": "val insert_sorted : leq:('a -> 'a -> bool) -> 'a -> 'a list -> 'a list",
    "doc": "Inserts [x] in [l], keeping [l] sorted according to [leq]",
    "pattern": "Inserting element while maintaining sort order"
  },
  {
    "id": "98883226-32ed-44ab-8d8f-367d6f80144b",
    "module": "List",
    "name": "sort",
    "type": "function",
    "signature": "val sort : leq:('a -> 'a -> bool) -> 'a list -> 'a list",
    "doc": "Sorts list [l] according to [leq] ordering",
    "pattern": "Sorting collection with custom comparison"
  },
  {
    "id": "23ec17f2-4a4c-4736-8773-8b64149e16f9",
    "module": "List",
    "name": "is_sorted",
    "type": "function",
    "signature": "val is_sorted : leq:('a -> 'a -> bool) -> 'a list -> bool",
    "doc": "Checks whether list [l] is sorted according to [leq] ordering",
    "pattern": "Testing if collection is in sorted order"
  },
  {
    "id": "bfc30b24-8b66-4bc4-8b44-1943ebd5d449",
    "module": "List",
    "name": "monoid_product",
    "type": "function",
    "signature": "val monoid_product : 'a list -> 'b list -> ('a * 'b) list",
    "doc": "Returns list of all pairs [(x,y)] where [x] comes from [l1] and [y] from [l2]",
    "pattern": "Cartesian product of two collections"
  },
  {
    "id": "3197fea2-9538-4b6c-a6b1-b645d42ca5cd",
    "module": "List",
    "name": ">|=",
    "type": "function",
    "signature": "val (>|=) : 'a list -> ('a -> 'b) -> 'b list",
    "doc": "Infix operator alias for [List.map]",
    "pattern": "Infix syntax for mapping\/transforming elements"
  },
  {
    "id": "99f25d49-931d-477e-84fb-70feb514b837",
    "module": "List",
    "name": ">>=",
    "type": "function",
    "signature": "val (>>=) : 'b list -> ('b -> 'a list) -> 'a list",
    "doc": "Infix operator alias for [List.flat_map]",
    "pattern": "Infix syntax for flat mapping elements"
  },
  {
    "id": "786cd6be-a6d0-4feb-8092-80800f6b966a",
    "module": "List",
    "name": "let+",
    "type": "function",
    "signature": "val let+ : 'b list -> ('b -> 'a) -> 'a list",
    "doc": "Alias for [List.>|=]",
    "pattern": "Alternative syntax for mapping in monadic contexts"
  },
  {
    "id": "1f765c1e-1e78-4e7f-874d-4a6f27d98d29",
    "module": "List",
    "name": "and+",
    "type": "function",
    "signature": "val and+ : 'a list -> 'b list -> ('a * 'b) list",
    "doc": "Alias for [List.monoid_product]",
    "pattern": "Alternative syntax for cartesian product in applicative contexts"
  },
  {
    "id": "13dc12de-b9d9-4dae-9945-ed729bc35f1b",
    "module": "List",
    "name": "let*",
    "type": "function",
    "signature": "val let* : 'b list -> ('b -> 'a list) -> 'a list",
    "doc": "Alias for [List.>>=]",
    "pattern": "Alternative syntax for flat mapping in monadic contexts"
  },
  {
    "id": "e4fd54d8-d770-4f75-b09d-b2ac183afab3",
    "module": "List",
    "name": "and*",
    "type": "function",
    "signature": "val and* : 'a list -> 'b list -> ('a * 'b) list",
    "doc": "Alias for [List.monoid_product]",
    "pattern": "Alternative syntax for cartesian product in applicative contexts"
  },
  {
    "id": "18d45525-735e-4948-8854-7a237316252c",
    "module": "Map",
    "name": "t",
    "type": "type",
    "signature": "type Map.t = {| l : ('a * 'b) list; | default : 'b}",
    "doc": "The map type representing a key-value mapping where each key is associated with exactly one value",
    "pattern": null
  },
  {
    "id": "15fa61ea-6de2-4c33-bfee-0f1f92c2202a",
    "module": "Map",
    "name": "const",
    "type": "function",
    "signature": "val const : 'b -> ('a, 'b) Map.t",
    "doc": "Creates a constant map that maps every key to the same value [v]",
    "pattern": "Initializing maps with a default value for all possible keys, useful for creating maps with a uniform base value"
  },
  {
    "id": "9824cf7a-7562-4818-b427-51feb96a4246",
    "module": "Map",
    "name": "add'",
    "type": "function",
    "signature": "val add' : ('a, 'b) Map.t -> 'a -> 'b -> ('a, 'b) Map.t",
    "doc": "Adds or updates the binding from key [k] to value [v] in map [m]",
    "pattern": "Adding or updating key-value pairs in a map with map-first argument order"
  },
  {
    "id": "8a7188d9-8b84-42ac-bb83-582317e1db3f",
    "module": "Map",
    "name": "add",
    "type": "function",
    "signature": "val add : 'a -> 'b -> ('a, 'b) Map.t -> ('a, 'b) Map.t",
    "doc": "Adds or updates the binding from key [k] to value [v] in map [m]",
    "pattern": "Adding or updating key-value pairs in a map with key-first argument order, similar to dictionary updates in other languages"
  },
  {
    "id": "0cb74217-839f-4819-8ae2-c658f72afa74",
    "module": "Map",
    "name": "get_default",
    "type": "function",
    "signature": "val get_default : ('a, 'b) Map.t -> 'b",
    "doc": "Returns the default value associated with map [m]",
    "pattern": "Retrieving the default value used for keys not explicitly set in the map"
  },
  {
    "id": "b91f076f-7e53-4903-985b-0b9d6c489d1e",
    "module": "Map",
    "name": "get'",
    "type": "function",
    "signature": "val get' : ('a, 'b) Map.t -> 'a -> 'b",
    "doc": "Retrieves the value associated with key [k] in map [m]",
    "pattern": "Looking up values by key in a map with map-first argument order"
  },
  {
    "id": "78dcc898-0774-4ea8-b001-e9ec8f1701dc",
    "module": "Map",
    "name": "get",
    "type": "function",
    "signature": "val get : 'a -> ('a, 'b) Map.t -> 'b",
    "doc": "Retrieves the value associated with key [k] in map [m]",
    "pattern": "Looking up values by key in a map with key-first argument order, similar to dictionary lookups in other languages"
  },
  {
    "id": "4f892742-1c63-4a04-9f23-31b405f509cc",
    "module": "Map",
    "name": "of_list",
    "type": "function",
    "signature": "val of_list : 'b -> ('a * 'b) list -> ('a, 'b) Map.t",
    "doc": "Creates a map from a list [l] of key-value pairs, using [default] as the value for keys not in the list",
    "pattern": "Converting a list of key-value pairs into a map, commonly used when initializing a map from existing data"
  },
  {
    "id": "7eab7cab-d383-4ee3-b7dc-72e6a306522b",
    "module": "Multiset",
    "name": "empty",
    "type": "function",
    "signature": "val empty : ('a, int) Map.t",
    "doc": "Creates an empty multiset where all possible elements implicitly have a count of 0. This serves as the starting point for building multisets.",
    "pattern": "Initializing a new multiset before adding elements, similar to creating an empty array or list in other languages"
  },
  {
    "id": "0ce16348-68c7-44b8-b88e-2142a072f1ee",
    "module": "Multiset",
    "name": "add",
    "type": "function",
    "signature": "val add : 'a -> ('a, int) Map.t -> ('a, int) Map.t",
    "doc": "Adds one occurrence of element [x] to multiset [m] by retrieving its current count, incrementing it by 1, and storing the new count. This maintains the multiset property of tracking multiple occurrences.",
    "pattern": "Incrementing counters for elements, like counting word frequencies or adding items to a shopping cart"
  },
  {
    "id": "5b34f739-385a-4c80-bd5e-9fa77fa9dcc4",
    "module": "Multiset",
    "name": "find",
    "type": "function",
    "signature": "val find : 'a -> ('a, int) Map.t -> int",
    "doc": "Retrieves the number of occurrences of element [x] in multiset [m]. This is an alias for Map.get that returns the count directly.",
    "pattern": "Querying how many times an element appears, such as checking inventory levels or word frequencies"
  },
  {
    "id": "abacba6b-da50-4536-a6dc-c53eabb6a72b",
    "module": "Multiset",
    "name": "mem",
    "type": "function",
    "signature": "val mem : 'a -> ('a, int) Map.t -> bool",
    "doc": "Tests if element [x] exists in multiset [m] by checking if its occurrence count is greater than 0. This distinguishes between elements that are present (count > 0) and absent (count = 0).",
    "pattern": "Testing if an element exists at least once in the collection, like checking if an item is in stock"
  },
  {
    "id": "ea885b1c-1c9a-4018-bb03-0936671859c2",
    "module": "Multiset",
    "name": "remove",
    "type": "function",
    "signature": "val remove : 'a -> ('a, int) Map.t -> ('a, int) Map.t",
    "doc": "Removes one occurrence of element [x] from multiset [m] by decreasing its count by 1, ensuring the count never goes below 0. This maintains the invariant that counts are always non-negative.",
    "pattern": "Decreasing element counts one at a time, such as removing items from a shopping cart or consuming inventory"
  },
  {
    "id": "42052e9c-a36b-4b44-af3c-a868809661ac",
    "module": "Multiset",
    "name": "of_list",
    "type": "function",
    "signature": "val of_list : 'a list -> ('a, int) Map.t",
    "doc": "Converts a list [l] into a multiset by recursively processing each element. It starts with an empty multiset and adds each element from the list in sequence, building up the occurrence counts.",
    "pattern": "Converting sequences or collections from other data structures into counted form, like building a frequency table from a list of events"
  },
  {
    "id": "72ed65b3-7afe-4483-aa7a-e45e36f44d74",
    "module": "LString",
    "name": "t",
    "type": "type",
    "signature": "type t = LChar.t list",
    "doc": "A list of logic-mode characters",
    "pattern": null
  },
  {
    "id": "85b8208d-f354-4149-afd2-047e5db4dde6",
    "module": "LString",
    "name": "empty",
    "type": "function",
    "signature": "val empty : LChar.t list",
    "doc": "Returns an empty string (empty list of characters)",
    "pattern": "Creating an empty string, like \"\" or empty string literal in other languages"
  },
  {
    "id": "8ba4f5b4-2848-4bc0-b9ce-f44fee9c21de",
    "module": "LString",
    "name": "of_list",
    "type": "function",
    "signature": "val of_list : 'a -> 'a",
    "doc": "Converts a list directly to an LString.t",
    "pattern": "Converting array\/list of characters to string, like String.fromCharArray() or similar"
  },
  {
    "id": "574ea737-d418-4c20-b374-36263ba1d554",
    "module": "LString",
    "name": "length",
    "type": "function",
    "signature": "val length : LChar.t list -> int",
    "doc": "Returns the number of characters in string [s]",
    "pattern": "Getting string length, like .length or len() in other languages"
  },
  {
    "id": "e00429ee-8808-4c71-a9d0-808966c4e27d",
    "module": "LString",
    "name": "append",
    "type": "function",
    "signature": "val append : LChar.t list -> LChar.t list -> LChar.t list",
    "doc": "Concatenates strings [s1] and [s2]",
    "pattern": "Joining two strings together, like + operator or concat() in other languages"
  },
  {
    "id": "7ffd5a57-7574-4a10-a8c2-312086ba6192",
    "module": "LString",
    "name": "^^",
    "type": "function",
    "signature": "val (^^) : LChar.t list -> LChar.t list -> LChar.t list",
    "doc": "An infix operator alias for LString.append",
    "pattern": "Infix string concatenation, like + or .. operators in other languages"
  },
  {
    "id": "434ee5ea-df2a-46d6-b92f-f712fdb1b5e5",
    "module": "LString",
    "name": "for_all",
    "type": "function",
    "signature": "val for_all : (LChar.t -> bool) -> LChar.t list -> bool",
    "doc": "Tests if all characters in [s] satisfy predicate [f]",
    "pattern": "Checking if all characters match a condition, like every() or all() in other languages"
  },
  {
    "id": "437c3390-4f5e-4118-8062-92ef42b8651c",
    "module": "LString",
    "name": "exists",
    "type": "function",
    "signature": "val exists : (LChar.t -> bool) -> LChar.t list -> bool",
    "doc": "Tests if any character in [s] satisfies predicate [f]",
    "pattern": "Checking if any character matches a condition, like some() or any() in other languages"
  },
  {
    "id": "6727bd78-59d8-43a3-b130-b18488faee65",
    "module": "LString",
    "name": "concat",
    "type": "function",
    "signature": "val concat : LChar.t list -> LChar.t list list -> LChar.t list",
    "doc": "Concatenates all strings in list [l], placing [sep] between each",
    "pattern": "Joining array of strings with separator, like join() or String.join() in other languages"
  },
  {
    "id": "99916e8d-3efa-4f1d-a955-a85e6c29e492",
    "module": "LString",
    "name": "is_printable",
    "type": "function",
    "signature": "val is_printable : LChar.t list -> bool",
    "doc": "Tests if all characters in [s] are printable",
    "pattern": "Checking if string contains only printable characters, like string validation"
  },
  {
    "id": "f2c42096-6185-43ed-bdec-a2ae54b90743",
    "module": "LString",
    "name": "sub",
    "type": "function",
    "signature": "val sub : LChar.t list -> int -> int -> LChar.t list",
    "doc": "Extracts substring of [s] starting at position [i] of length [len]",
    "pattern": "Extracting substring, like substring() or slice() in other languages"
  },
  {
    "id": "346ba7ca-151b-4f8e-9144-aa79c78b696d",
    "module": "LString",
    "name": "prefix",
    "type": "function",
    "signature": "val prefix : LChar.t list -> LChar.t list -> bool",
    "doc": "Tests if [s1] is a prefix of [s2]",
    "pattern": "Checking if string starts with another string, like startsWith() in other languages"
  },
  {
    "id": "2f99a158-14b6-42dc-924f-d9e51489d489",
    "module": "LString",
    "name": "suffix",
    "type": "function",
    "signature": "val suffix : LChar.t list -> LChar.t list -> bool",
    "doc": "Tests if [s1] is a suffix of [s2]",
    "pattern": "Checking if string ends with another string, like endsWith() in other languages"
  },
  {
    "id": "9bacf23f-834d-4509-bb5c-38fe2e7769b6",
    "module": "LString",
    "name": "contains",
    "type": "function",
    "signature": "val contains : LChar.t list -> LChar.t list -> bool",
    "doc": "Tests if [s2] appears as a substring within [s1]",
    "pattern": "Checking if string contains substring, like includes() or contains() in other languages"
  },
  {
    "id": "751e5d3b-e0db-4821-97bf-2cf40b13a681",
    "module": "LString",
    "name": "take",
    "type": "function",
    "signature": "val take : int -> LString.t -> LString.t",
    "doc": "Returns first [n] characters of string [s]. The [LString.t] version of [List.take]",
    "pattern": "Taking first N characters from string, like slice(0,n) or substring(0,n) in other languages"
  },
  {
    "id": "eb97129f-d91b-4062-a0a7-8e73e04119e9",
    "module": "LString",
    "name": "drop",
    "type": "function",
    "signature": "val drop : int -> LString.t -> LString.t",
    "doc": "Removes first [n] characters from string [s]. The [LString.t] version of [List.drop]",
    "pattern": "Removing first N characters from string, like slice(n) or substring(n) in other languages"
  },
  {
    "id": "f496a144-a9a3-4f41-89cb-ce7a744e578b",
    "module": "LString",
    "name": "len_pos",
    "type": "theorem",
    "signature": "val len_pos : LChar.t list -> bool",
    "doc": "The length of a string is always non-negative",
    "pattern": null
  },
  {
    "id": "df425caa-b9e5-4837-8312-79ada469a3c1",
    "module": "LString",
    "name": "len_zero_inversion",
    "type": "theorem",
    "signature": "val len_zero_inversion : LChar.t list -> bool",
    "doc": "If the length of a string is zero, then the string is empty",
    "pattern": null
  },
  {
    "id": "e785b885-d5e2-423c-9564-a3964e72a830",
    "module": "",
    "name": "--",
    "type": "function",
    "signature": "val -- : int list -> int list -> int list",
    "doc": "Alias to {!List.(--)}\n- Note: `end` is not included in the generated list of `(start -- end)`.\n- Example: `(1--3) (* gives [1;2] *)`",
    "pattern": "Integer range generation"
  },
  {
    "id": "d78b6676-7f49-412c-833c-c5fabf3fcce2",
    "module": "List",
    "name": "--",
    "type": "function",
    "signature": "val (--) : int -> int -> int list",
    "doc": "Infix operator alias for [List.range]\n- Note: `end` is not included in the generated list of `(start -- end)`.\n- Example: `List.(--) 1 3 (* gives [1;2] *)`",
    "pattern": "Infix syntax for integer ranges"
  }
]
