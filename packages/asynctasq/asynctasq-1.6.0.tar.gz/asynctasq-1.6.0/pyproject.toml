[project]
name = "asynctasq"
version = "1.6.0"
description = "AsyncTasQ: A modern, async-first, type-safe task queue Python package inspired by Laravel. Runs on uvloop for maximum performance. Native FastAPI integration. Switch between multiple queue backends (Redis, PostgreSQL, MySQL, RabbitMQ, AWS SQS) with one config line. Automatic, smart ORM serialization (SQLAlchemy, Django, Tortoise) using msgpack reduces payloads by 90%+."
readme = "README.md"
requires-python = ">=3.12"
license = { text = "MIT" }
authors = [{ name = "Adam Refaey" }]
keywords = [
    "queue",
    "task",
    "async",
    "laravel",
    "redis",
    "sqs",
    "background-tasks",
    "worker",
    "fastapi",
    "sqlalchemy",
    "django",
    "tortoise-orm",
]
classifiers = [
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Programming Language :: Python :: 3.14",
    "Framework :: AsyncIO",
    "Topic :: Software Development :: Libraries :: Python Modules",
]

dependencies = [
    "msgspec>=0.18.0",
    "pydantic-settings>=2.0.0",
    "rich>=13.6.0",
    "uvloop>=0.19.0",
]

[project.optional-dependencies]
redis = ["redis[hiredis]>=5.0.1"]
sqs = ["aioboto3>=12.0.0", "types-aioboto3[sqs]>=12.0.0"]
postgres = ["asyncpg>=0.29.0", "asyncpg-stubs>=0.29.0"]
mysql = ["asyncmy>=0.2.9", "cryptography>=41.0.5"]
rabbitmq = ["aio-pika>=9.3.1"]
sqlalchemy = ["sqlalchemy>=2.0.22", "greenlet>=3.0.0"]
django = ["django>=5.0", "psycopg2-binary>=2.9.9"]
tortoise = ["tortoise-orm>=0.21.0"]
fastapi = ["fastapi>=0.109.0"]
monitor = ["redis[hiredis]>=5.0.1"]                       # Required for real-time monitoring UI

all = [
    "asynctasq[redis,sqs,postgres,mysql,rabbitmq,sqlalchemy,django,tortoise,fastapi,monitor]",
]

[project.urls]
Homepage = "https://github.com/adamrefaey/asynctasq"
Repository = "https://github.com/adamrefaey/asynctasq"
Issues = "https://github.com/adamrefaey/asynctasq/issues"

[project.scripts]
asynctasq = "asynctasq.cli.main:main"


[build-system]
requires = ["uv_build>=0.9.20"]
build-backend = "uv_build"

[tool.uv]
# Enable uv build backend for 10-35x faster builds compared to hatchling/setuptools
# Optimized for pure-Python projects with good defaults and user-friendly errors

[dependency-groups]
dev = [
    "boto3-stubs[essential]>=1.42.19",
    "pyright>=1.1.407",
    "pytest>=9.0.2",
    "pytest-asyncio>=1.3.0",
    "pytest-cov>=7.0.0",
    "ruff>=0.14.10",
    "pre-commit>=4.5.1",
    "pytest-mock>=3.15.1",
    "pytest-timeout>=2.4.0",
    "httpx>=0.28.1",
    "bandit>=1.9.2",
    "pip-audit>=2.10.0",
    "coverage-badge>=1.1.2",
    "yamllint>=1.37.1",
]

[tool.ruff]
line-length = 100
target-version = "py312"

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
]
ignore = ["E501"] # line too long (handled by formatter)

[tool.ruff.lint.isort]
known-first-party = ["asynctasq"]
force-sort-within-sections = true

[tool.ruff.lint.mccabe]
max-complexity = 10

[tool.ruff.lint.pylint]
max-args = 8
max-branches = 12
max-returns = 6
max-statements = 50

[tool.pyright]
pythonVersion = "3.12"
typeCheckingMode = "standard"
# Allow task subclasses to override methods with class attributes for configuration
# This is a valid pattern where max_attempts/timeout can be either:
# 1. Class attributes for default configuration (e.g., max_attempts = 3)
# 2. Instance methods for chaining (e.g., task.max_attempts(5))
#
# Pyright sees this as an assignment type error, but it's intentional shadowing
reportAssignmentType = "none"
# Ignore missing imports for optional dependencies (installed only when needed)
reportMissingImports = "none"

[tool.pytest.ini_options]
# Use strict mode to avoid false positives from auto-detection
# Strict mode requires explicit @pytest.mark.asyncio decorators on async tests
# This prevents RuntimeWarnings from pytest-asyncio auto-detection interfering with mocks
asyncio_mode = "strict"
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
# Prevent pytest from rewriting third-party async libraries
# This avoids "Module already imported so cannot be rewritten" warnings
# when these modules are imported by pytest-asyncio or our event loop fixture
asyncio_default_fixture_loop_scope = "function"
addopts = [
    "-s",
    "-v",
    # "--cov=asynctasq",
    # "--cov-branch",
    # "--cov-report=term-missing",
    # "--cov-report=html",
]
markers = [
    "unit: marks tests as unit tests (deselect with '-m \"not unit\"')",
    "integration: marks tests as integration tests (deselect with '-m \"not integration\"')",
]
# Filter warnings from unittest.mock.AsyncMock internals
# These warnings occur because AsyncMock creates coroutines internally that aren't always
# awaited during test collection/teardown. This is a known limitation of unittest.mock
# when used with pytest-asyncio, not an issue with our code.
# Reference: https://github.com/python/cpython/issues/95778
# We use strict mode + explicit @pytest.mark.asyncio decorators (best practice),
# but AsyncMock warnings persist due to mock internals.
filterwarnings = [
    # Filter warnings from unittest.mock.AsyncMock internals
    # These are false positives from AsyncMock's internal coroutine handling
    # when used with pytest-asyncio. This is a known limitation, not a code issue.
    # The warnings can appear from various modules (argparse, importlib, etc.) when
    # AsyncMock coroutines are accessed during test collection or teardown.
    "ignore:coroutine.*was never awaited:RuntimeWarning:unittest.mock",
    "ignore:coroutine.*was never awaited:RuntimeWarning:importlib",
    "ignore:coroutine.*was never awaited:RuntimeWarning:tracemalloc",
    "ignore:coroutine.*was never awaited:RuntimeWarning:re",
    "ignore:coroutine.*was never awaited:RuntimeWarning:argparse",
    # Filter warnings from pytest detecting unawaited coroutines in test fixtures
    # SharedAsyncFactorialTask is used in test fixtures and may create coroutines
    # that are not awaited during test collection/teardown
    "ignore:coroutine 'SharedAsyncFactorialTask.execute' was never awaited:RuntimeWarning",
    # Filter all RuntimeWarnings about unawaited coroutines from test code
    # These occur when tests intentionally create coroutines that may not be awaited
    # due to mocking, exceptions, or test design (not actual bugs)
    "ignore:coroutine.*was never awaited:RuntimeWarning",
    # Filter pytest assertion rewrite warnings for third-party async libraries
    # anyio is imported by pytest-asyncio before pytest can rewrite it
    # This is expected behavior and not an issue with our code
    "ignore:Module already imported so cannot be rewritten.*anyio:pytest.PytestAssertRewriteWarning",
]

[tool.coverage.run]
source = ["src"]
omit = ["tests/*", "examples/*"]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
    "\\.\\.\\.",                  # Exclude ellipsis in abstract methods
    "@abstractmethod",
]
