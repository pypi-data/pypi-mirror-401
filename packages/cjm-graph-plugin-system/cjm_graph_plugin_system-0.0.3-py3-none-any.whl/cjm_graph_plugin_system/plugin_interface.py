"""Domain-specific plugin interface for Context Graphs"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/plugin_interface.ipynb.

# %% auto 0
__all__ = ['GraphPlugin']

# %% ../nbs/plugin_interface.ipynb 3
from abc import abstractmethod
from typing import Any, Dict, List, Optional, Union

from cjm_plugin_system.core.interface import PluginInterface

from cjm_graph_plugin_system.core import (
    GraphNode,
    GraphEdge,
    GraphContext,
    GraphQuery,
    SourceRef
)

# %% ../nbs/plugin_interface.ipynb 5
class GraphPlugin(PluginInterface):
    """Abstract base class for all Context Graph plugins."""

    entry_point_group = "graph.plugins"  # Entry point for discovery

    # -------------------------------------------------------------------------
    # EXECUTE (Main Entry Point for RemotePluginProxy)
    # -------------------------------------------------------------------------

    @abstractmethod
    def execute(
        self,
        action: str = "get_schema",  # Action to perform (see docstring for available actions)
        **kwargs
    ) -> Dict[str, Any]:  # JSON-serializable result
        """
        Execute a graph operation. This is the main entry point for RemotePluginProxy.
        
        Dispatches to the appropriate method based on `action` parameter.
        All return values are JSON-serializable dictionaries for HTTP transport.
        """
        ...

    # -------------------------------------------------------------------------
    # CREATE
    # -------------------------------------------------------------------------

    @abstractmethod
    def add_nodes(
        self,
        nodes: List[GraphNode]  # Nodes to create
    ) -> List[str]:  # Created node IDs
        """Bulk create nodes."""
        ...

    @abstractmethod
    def add_edges(
        self,
        edges: List[GraphEdge]  # Edges to create
    ) -> List[str]:  # Created edge IDs
        """Bulk create edges."""
        ...

    # -------------------------------------------------------------------------
    # READ
    # -------------------------------------------------------------------------

    @abstractmethod
    def get_node(
        self,
        node_id: str  # UUID of node to retrieve
    ) -> Optional[GraphNode]:  # Node or None if not found
        """Get a single node by ID."""
        ...

    @abstractmethod
    def get_edge(
        self,
        edge_id: str  # UUID of edge to retrieve
    ) -> Optional[GraphEdge]:  # Edge or None if not found
        """Get a single edge by ID."""
        ...

    @abstractmethod
    def get_context(
        self,
        node_id: str,  # Starting node UUID
        depth: int = 1,  # Traversal depth (1 = immediate neighbors)
        filter_labels: Optional[List[str]] = None  # Only include nodes with these labels
    ) -> GraphContext:  # Subgraph containing node and its neighborhood
        """Get the neighborhood of a specific node."""
        ...

    @abstractmethod
    def find_nodes_by_source(
        self,
        source_ref: SourceRef  # External resource reference
    ) -> List[GraphNode]:  # Nodes attached to this source
        """Find all nodes linked to a specific external resource."""
        ...

    @abstractmethod
    def find_nodes_by_label(
        self,
        label: str,  # Node label to search for
        limit: int = 100  # Max results
    ) -> List[GraphNode]:  # Matching nodes
        """Find nodes by label."""
        ...

    # -------------------------------------------------------------------------
    # UPDATE
    # -------------------------------------------------------------------------

    @abstractmethod
    def update_node(
        self,
        node_id: str,  # UUID of node to update
        properties: Dict[str, Any]  # Properties to merge/update
    ) -> bool:  # True if successful
        """Partial update of node properties."""
        ...

    @abstractmethod
    def update_edge(
        self,
        edge_id: str,  # UUID of edge to update
        properties: Dict[str, Any]  # Properties to merge/update
    ) -> bool:  # True if successful
        """Partial update of edge properties."""
        ...

    # -------------------------------------------------------------------------
    # DELETE
    # -------------------------------------------------------------------------

    @abstractmethod
    def delete_nodes(
        self,
        node_ids: List[str],  # UUIDs of nodes to delete
        cascade: bool = True  # Also delete connected edges
    ) -> int:  # Number of nodes deleted
        """Delete nodes (and optionally connected edges)."""
        ...

    @abstractmethod
    def delete_edges(
        self,
        edge_ids: List[str]  # UUIDs of edges to delete
    ) -> int:  # Number of edges deleted
        """Delete edges."""
        ...

    # -------------------------------------------------------------------------
    # LIFECYCLE & INTROSPECTION
    # -------------------------------------------------------------------------

    @abstractmethod
    def get_schema(self) -> Dict[str, Any]:  # Graph schema/ontology
        """Return the current ontology/schema of the graph."""
        ...

    @abstractmethod
    def import_graph(
        self,
        graph_data: GraphContext,  # Data to import
        merge_strategy: str = "overwrite"  # "overwrite", "skip", or "merge"
    ) -> Dict[str, int]:  # Import statistics {nodes_created, edges_created, ...}
        """Bulk import a GraphContext (e.g., from backup or another plugin)."""
        ...

    @abstractmethod
    def export_graph(
        self,
        filter_query: Optional[GraphQuery] = None  # Optional filter
    ) -> GraphContext:  # Exported subgraph or full graph
        """Export the entire graph or a filtered subset."""
        ...
