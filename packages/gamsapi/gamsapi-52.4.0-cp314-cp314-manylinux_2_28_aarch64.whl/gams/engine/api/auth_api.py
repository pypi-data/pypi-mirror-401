# coding: utf-8

"""
    GAMS Engine

    With GAMS Engine you can register and solve GAMS models. It has a namespace management system, so you can restrict your users to certain models.

    The version of the OpenAPI document: latest
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from gams.engine.models.forwarded_token_response import ForwardedTokenResponse
from gams.engine.models.identity_provider import IdentityProvider
from gams.engine.models.identity_provider_ldap import IdentityProviderLdap
from gams.engine.models.identity_provider_oauth2_with_secret import IdentityProviderOauth2WithSecret
from gams.engine.models.identity_provider_oidc_with_secret import IdentityProviderOidcWithSecret
from gams.engine.models.message import Message
from gams.engine.models.model_auth_token import ModelAuthToken
from gams.engine.models.password_policy import PasswordPolicy

from gams.engine.api_client import ApiClient, RequestSerialized
from gams.engine.api_response import ApiResponse
from gams.engine.rest import RESTResponseType


class AuthApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_jwt_token(
        self,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelAuthToken:
        """Creates a JSON Web Token(JWT) for authentication


        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_jwt_token_serialize(
            expires_in=expires_in,
            scope=scope,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_jwt_token_with_http_info(
        self,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelAuthToken]:
        """Creates a JSON Web Token(JWT) for authentication


        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_jwt_token_serialize(
            expires_in=expires_in,
            scope=scope,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_jwt_token_without_preload_content(
        self,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a JSON Web Token(JWT) for authentication


        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_jwt_token_serialize(
            expires_in=expires_in,
            scope=scope,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_jwt_token_serialize(
        self,
        expires_in,
        scope,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if expires_in is not None:
            _form_params.append(('expires_in', expires_in))
        if scope is not None:
            _form_params.append(('scope', scope))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_jwt_token_json(
        self,
        username: StrictStr,
        password: StrictStr,
        grant_type: Optional[StrictStr] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        access_scopes: Annotated[Optional[List[StrictStr]], Field(description="Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelAuthToken:
        """Creates a JSON Web Token(JWT) for authentication (username and password in request body)


        :param username: (required)
        :type username: str
        :param password: (required)
        :type password: str
        :param grant_type:
        :type grant_type: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param access_scopes: Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type access_scopes: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_jwt_token_json_serialize(
            username=username,
            password=password,
            grant_type=grant_type,
            scope=scope,
            expires_in=expires_in,
            access_scopes=access_scopes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_jwt_token_json_with_http_info(
        self,
        username: StrictStr,
        password: StrictStr,
        grant_type: Optional[StrictStr] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        access_scopes: Annotated[Optional[List[StrictStr]], Field(description="Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelAuthToken]:
        """Creates a JSON Web Token(JWT) for authentication (username and password in request body)


        :param username: (required)
        :type username: str
        :param password: (required)
        :type password: str
        :param grant_type:
        :type grant_type: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param access_scopes: Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type access_scopes: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_jwt_token_json_serialize(
            username=username,
            password=password,
            grant_type=grant_type,
            scope=scope,
            expires_in=expires_in,
            access_scopes=access_scopes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_jwt_token_json_without_preload_content(
        self,
        username: StrictStr,
        password: StrictStr,
        grant_type: Optional[StrictStr] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        access_scopes: Annotated[Optional[List[StrictStr]], Field(description="Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a JSON Web Token(JWT) for authentication (username and password in request body)


        :param username: (required)
        :type username: str
        :param password: (required)
        :type password: str
        :param grant_type:
        :type grant_type: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param access_scopes: Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type access_scopes: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_jwt_token_json_serialize(
            username=username,
            password=password,
            grant_type=grant_type,
            scope=scope,
            expires_in=expires_in,
            access_scopes=access_scopes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_jwt_token_json_serialize(
        self,
        username,
        password,
        grant_type,
        scope,
        expires_in,
        access_scopes,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'access_scopes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if grant_type is not None:
            _form_params.append(('grant_type', grant_type))
        if username is not None:
            _form_params.append(('username', username))
        if password is not None:
            _form_params.append(('password', password))
        if scope is not None:
            _form_params.append(('scope', scope))
        if expires_in is not None:
            _form_params.append(('expires_in', expires_in))
        if access_scopes is not None:
            _form_params.append(('access_scopes', access_scopes))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/login',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ldap_identity_provider(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider")],
        label: Annotated[str, Field(strict=True, description="Suggested login tab name")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when all identity providers are listed?")],
        host: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="Host of the LDAP server excluding protocol and port")],
        port: Annotated[int, Field(le=65535, strict=True, ge=1, description="Port of the LDAP server. Examples: 389 and 636(for simple_tls)")],
        uid: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause.")],
        encryption: Annotated[StrictStr, Field(description="Encryption method")],
        base: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\"")],
        user_filter: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\"")],
        bind_dn: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"")] = None,
        password: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The password of the user who is used for binding")] = None,
        verify_certificates: Optional[StrictBool] = None,
        active_directory: Annotated[Optional[StrictBool], Field(description="Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Creates an identity provider of type LDAP

        Fields are visible through the API after creation only via an admin account. Requires admin role. Timeout value for communication is 10 seconds

        :param name: A unique string to identify the identity provider (required)
        :type name: str
        :param label: Suggested login tab name (required)
        :type label: str
        :param hidden: Should the identity provider be listed when all identity providers are listed? (required)
        :type hidden: bool
        :param host: Host of the LDAP server excluding protocol and port (required)
        :type host: str
        :param port: Port of the LDAP server. Examples: 389 and 636(for simple_tls) (required)
        :type port: int
        :param uid: The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause. (required)
        :type uid: str
        :param encryption: Encryption method (required)
        :type encryption: str
        :param base: DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\" (required)
        :type base: str
        :param user_filter: LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\" (required)
        :type user_filter: str
        :param bind_dn: The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"
        :type bind_dn: str
        :param password: The password of the user who is used for binding
        :type password: str
        :param verify_certificates:
        :type verify_certificates: bool
        :param active_directory: Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used
        :type active_directory: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ldap_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            host=host,
            port=port,
            uid=uid,
            encryption=encryption,
            base=base,
            user_filter=user_filter,
            bind_dn=bind_dn,
            password=password,
            verify_certificates=verify_certificates,
            active_directory=active_directory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ldap_identity_provider_with_http_info(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider")],
        label: Annotated[str, Field(strict=True, description="Suggested login tab name")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when all identity providers are listed?")],
        host: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="Host of the LDAP server excluding protocol and port")],
        port: Annotated[int, Field(le=65535, strict=True, ge=1, description="Port of the LDAP server. Examples: 389 and 636(for simple_tls)")],
        uid: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause.")],
        encryption: Annotated[StrictStr, Field(description="Encryption method")],
        base: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\"")],
        user_filter: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\"")],
        bind_dn: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"")] = None,
        password: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The password of the user who is used for binding")] = None,
        verify_certificates: Optional[StrictBool] = None,
        active_directory: Annotated[Optional[StrictBool], Field(description="Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Creates an identity provider of type LDAP

        Fields are visible through the API after creation only via an admin account. Requires admin role. Timeout value for communication is 10 seconds

        :param name: A unique string to identify the identity provider (required)
        :type name: str
        :param label: Suggested login tab name (required)
        :type label: str
        :param hidden: Should the identity provider be listed when all identity providers are listed? (required)
        :type hidden: bool
        :param host: Host of the LDAP server excluding protocol and port (required)
        :type host: str
        :param port: Port of the LDAP server. Examples: 389 and 636(for simple_tls) (required)
        :type port: int
        :param uid: The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause. (required)
        :type uid: str
        :param encryption: Encryption method (required)
        :type encryption: str
        :param base: DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\" (required)
        :type base: str
        :param user_filter: LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\" (required)
        :type user_filter: str
        :param bind_dn: The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"
        :type bind_dn: str
        :param password: The password of the user who is used for binding
        :type password: str
        :param verify_certificates:
        :type verify_certificates: bool
        :param active_directory: Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used
        :type active_directory: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ldap_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            host=host,
            port=port,
            uid=uid,
            encryption=encryption,
            base=base,
            user_filter=user_filter,
            bind_dn=bind_dn,
            password=password,
            verify_certificates=verify_certificates,
            active_directory=active_directory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ldap_identity_provider_without_preload_content(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider")],
        label: Annotated[str, Field(strict=True, description="Suggested login tab name")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when all identity providers are listed?")],
        host: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="Host of the LDAP server excluding protocol and port")],
        port: Annotated[int, Field(le=65535, strict=True, ge=1, description="Port of the LDAP server. Examples: 389 and 636(for simple_tls)")],
        uid: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause.")],
        encryption: Annotated[StrictStr, Field(description="Encryption method")],
        base: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\"")],
        user_filter: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\"")],
        bind_dn: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"")] = None,
        password: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The password of the user who is used for binding")] = None,
        verify_certificates: Optional[StrictBool] = None,
        active_directory: Annotated[Optional[StrictBool], Field(description="Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates an identity provider of type LDAP

        Fields are visible through the API after creation only via an admin account. Requires admin role. Timeout value for communication is 10 seconds

        :param name: A unique string to identify the identity provider (required)
        :type name: str
        :param label: Suggested login tab name (required)
        :type label: str
        :param hidden: Should the identity provider be listed when all identity providers are listed? (required)
        :type hidden: bool
        :param host: Host of the LDAP server excluding protocol and port (required)
        :type host: str
        :param port: Port of the LDAP server. Examples: 389 and 636(for simple_tls) (required)
        :type port: int
        :param uid: The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause. (required)
        :type uid: str
        :param encryption: Encryption method (required)
        :type encryption: str
        :param base: DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\" (required)
        :type base: str
        :param user_filter: LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\" (required)
        :type user_filter: str
        :param bind_dn: The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"
        :type bind_dn: str
        :param password: The password of the user who is used for binding
        :type password: str
        :param verify_certificates:
        :type verify_certificates: bool
        :param active_directory: Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used
        :type active_directory: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ldap_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            host=host,
            port=port,
            uid=uid,
            encryption=encryption,
            base=base,
            user_filter=user_filter,
            bind_dn=bind_dn,
            password=password,
            verify_certificates=verify_certificates,
            active_directory=active_directory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ldap_identity_provider_serialize(
        self,
        name,
        label,
        hidden,
        host,
        port,
        uid,
        encryption,
        base,
        user_filter,
        bind_dn,
        password,
        verify_certificates,
        active_directory,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if label is not None:
            _form_params.append(('label', label))
        if hidden is not None:
            _form_params.append(('hidden', hidden))
        if host is not None:
            _form_params.append(('host', host))
        if port is not None:
            _form_params.append(('port', port))
        if uid is not None:
            _form_params.append(('uid', uid))
        if bind_dn is not None:
            _form_params.append(('bind_dn', bind_dn))
        if password is not None:
            _form_params.append(('password', password))
        if encryption is not None:
            _form_params.append(('encryption', encryption))
        if verify_certificates is not None:
            _form_params.append(('verify_certificates', verify_certificates))
        if active_directory is not None:
            _form_params.append(('active_directory', active_directory))
        if base is not None:
            _form_params.append(('base', base))
        if user_filter is not None:
            _form_params.append(('user_filter', user_filter))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/ldap-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_o_auth2_identity_provider(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.")] = None,
        override_audience: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        use_oauth2_auth_server_metadata: Annotated[Optional[StrictBool], Field(description="Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        response_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).")] = None,
        grant_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        request_scope_readonly: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'READONLY' scope")] = None,
        request_scope_namespaces: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'NAMESPACES' scope")] = None,
        request_scope_jobs: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'JOBS' scope")] = None,
        request_scope_users: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USERS' scope")] = None,
        request_scope_hypercube: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'HYPERCUBE' scope")] = None,
        request_scope_cleanup: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CLEANUP' scope")] = None,
        request_scope_licenses: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'LICENSES' scope")] = None,
        request_scope_usage: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USAGE' scope")] = None,
        request_scope_auth: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'AUTH' scope")] = None,
        request_scope_configuration: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CONFIGURATION' scope")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Creates an identity provider of type OAuth2

        The access token provided by the identity provider must be a valid JWT token. Opaque tokens are not supported. Requires admin role.

        :param name: A unique string to identify the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.
        :type device_client_id: str
        :param override_audience: By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.
        :type override_audience: str
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param use_oauth2_auth_server_metadata: Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server
        :type use_oauth2_auth_server_metadata: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param response_types_supported: Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).
        :type response_types_supported: List[str]
        :param grant_types_supported: Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).
        :type grant_types_supported: List[str]
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param request_scope_readonly: Scope that the client should request from the OP to get 'READONLY' scope
        :type request_scope_readonly: str
        :param request_scope_namespaces: Scope that the client should request from the OP to get 'NAMESPACES' scope
        :type request_scope_namespaces: str
        :param request_scope_jobs: Scope that the client should request from the OP to get 'JOBS' scope
        :type request_scope_jobs: str
        :param request_scope_users: Scope that the client should request from the OP to get 'USERS' scope
        :type request_scope_users: str
        :param request_scope_hypercube: Scope that the client should request from the OP to get 'HYPERCUBE' scope
        :type request_scope_hypercube: str
        :param request_scope_cleanup: Scope that the client should request from the OP to get 'CLEANUP' scope
        :type request_scope_cleanup: str
        :param request_scope_licenses: Scope that the client should request from the OP to get 'LICENSES' scope
        :type request_scope_licenses: str
        :param request_scope_usage: Scope that the client should request from the OP to get 'USAGE' scope
        :type request_scope_usage: str
        :param request_scope_auth: Scope that the client should request from the OP to get 'AUTH' scope
        :type request_scope_auth: str
        :param request_scope_configuration: Scope that the client should request from the OP to get 'CONFIGURATION' scope
        :type request_scope_configuration: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_o_auth2_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            override_audience=override_audience,
            use_oidc_discover=use_oidc_discover,
            use_oauth2_auth_server_metadata=use_oauth2_auth_server_metadata,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            response_types_supported=response_types_supported,
            grant_types_supported=grant_types_supported,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            request_scope_readonly=request_scope_readonly,
            request_scope_namespaces=request_scope_namespaces,
            request_scope_jobs=request_scope_jobs,
            request_scope_users=request_scope_users,
            request_scope_hypercube=request_scope_hypercube,
            request_scope_cleanup=request_scope_cleanup,
            request_scope_licenses=request_scope_licenses,
            request_scope_usage=request_scope_usage,
            request_scope_auth=request_scope_auth,
            request_scope_configuration=request_scope_configuration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_o_auth2_identity_provider_with_http_info(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.")] = None,
        override_audience: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        use_oauth2_auth_server_metadata: Annotated[Optional[StrictBool], Field(description="Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        response_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).")] = None,
        grant_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        request_scope_readonly: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'READONLY' scope")] = None,
        request_scope_namespaces: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'NAMESPACES' scope")] = None,
        request_scope_jobs: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'JOBS' scope")] = None,
        request_scope_users: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USERS' scope")] = None,
        request_scope_hypercube: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'HYPERCUBE' scope")] = None,
        request_scope_cleanup: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CLEANUP' scope")] = None,
        request_scope_licenses: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'LICENSES' scope")] = None,
        request_scope_usage: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USAGE' scope")] = None,
        request_scope_auth: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'AUTH' scope")] = None,
        request_scope_configuration: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CONFIGURATION' scope")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Creates an identity provider of type OAuth2

        The access token provided by the identity provider must be a valid JWT token. Opaque tokens are not supported. Requires admin role.

        :param name: A unique string to identify the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.
        :type device_client_id: str
        :param override_audience: By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.
        :type override_audience: str
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param use_oauth2_auth_server_metadata: Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server
        :type use_oauth2_auth_server_metadata: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param response_types_supported: Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).
        :type response_types_supported: List[str]
        :param grant_types_supported: Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).
        :type grant_types_supported: List[str]
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param request_scope_readonly: Scope that the client should request from the OP to get 'READONLY' scope
        :type request_scope_readonly: str
        :param request_scope_namespaces: Scope that the client should request from the OP to get 'NAMESPACES' scope
        :type request_scope_namespaces: str
        :param request_scope_jobs: Scope that the client should request from the OP to get 'JOBS' scope
        :type request_scope_jobs: str
        :param request_scope_users: Scope that the client should request from the OP to get 'USERS' scope
        :type request_scope_users: str
        :param request_scope_hypercube: Scope that the client should request from the OP to get 'HYPERCUBE' scope
        :type request_scope_hypercube: str
        :param request_scope_cleanup: Scope that the client should request from the OP to get 'CLEANUP' scope
        :type request_scope_cleanup: str
        :param request_scope_licenses: Scope that the client should request from the OP to get 'LICENSES' scope
        :type request_scope_licenses: str
        :param request_scope_usage: Scope that the client should request from the OP to get 'USAGE' scope
        :type request_scope_usage: str
        :param request_scope_auth: Scope that the client should request from the OP to get 'AUTH' scope
        :type request_scope_auth: str
        :param request_scope_configuration: Scope that the client should request from the OP to get 'CONFIGURATION' scope
        :type request_scope_configuration: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_o_auth2_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            override_audience=override_audience,
            use_oidc_discover=use_oidc_discover,
            use_oauth2_auth_server_metadata=use_oauth2_auth_server_metadata,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            response_types_supported=response_types_supported,
            grant_types_supported=grant_types_supported,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            request_scope_readonly=request_scope_readonly,
            request_scope_namespaces=request_scope_namespaces,
            request_scope_jobs=request_scope_jobs,
            request_scope_users=request_scope_users,
            request_scope_hypercube=request_scope_hypercube,
            request_scope_cleanup=request_scope_cleanup,
            request_scope_licenses=request_scope_licenses,
            request_scope_usage=request_scope_usage,
            request_scope_auth=request_scope_auth,
            request_scope_configuration=request_scope_configuration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_o_auth2_identity_provider_without_preload_content(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.")] = None,
        override_audience: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        use_oauth2_auth_server_metadata: Annotated[Optional[StrictBool], Field(description="Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        response_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).")] = None,
        grant_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        request_scope_readonly: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'READONLY' scope")] = None,
        request_scope_namespaces: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'NAMESPACES' scope")] = None,
        request_scope_jobs: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'JOBS' scope")] = None,
        request_scope_users: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USERS' scope")] = None,
        request_scope_hypercube: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'HYPERCUBE' scope")] = None,
        request_scope_cleanup: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CLEANUP' scope")] = None,
        request_scope_licenses: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'LICENSES' scope")] = None,
        request_scope_usage: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USAGE' scope")] = None,
        request_scope_auth: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'AUTH' scope")] = None,
        request_scope_configuration: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CONFIGURATION' scope")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates an identity provider of type OAuth2

        The access token provided by the identity provider must be a valid JWT token. Opaque tokens are not supported. Requires admin role.

        :param name: A unique string to identify the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.
        :type device_client_id: str
        :param override_audience: By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.
        :type override_audience: str
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param use_oauth2_auth_server_metadata: Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server
        :type use_oauth2_auth_server_metadata: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param response_types_supported: Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).
        :type response_types_supported: List[str]
        :param grant_types_supported: Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).
        :type grant_types_supported: List[str]
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param request_scope_readonly: Scope that the client should request from the OP to get 'READONLY' scope
        :type request_scope_readonly: str
        :param request_scope_namespaces: Scope that the client should request from the OP to get 'NAMESPACES' scope
        :type request_scope_namespaces: str
        :param request_scope_jobs: Scope that the client should request from the OP to get 'JOBS' scope
        :type request_scope_jobs: str
        :param request_scope_users: Scope that the client should request from the OP to get 'USERS' scope
        :type request_scope_users: str
        :param request_scope_hypercube: Scope that the client should request from the OP to get 'HYPERCUBE' scope
        :type request_scope_hypercube: str
        :param request_scope_cleanup: Scope that the client should request from the OP to get 'CLEANUP' scope
        :type request_scope_cleanup: str
        :param request_scope_licenses: Scope that the client should request from the OP to get 'LICENSES' scope
        :type request_scope_licenses: str
        :param request_scope_usage: Scope that the client should request from the OP to get 'USAGE' scope
        :type request_scope_usage: str
        :param request_scope_auth: Scope that the client should request from the OP to get 'AUTH' scope
        :type request_scope_auth: str
        :param request_scope_configuration: Scope that the client should request from the OP to get 'CONFIGURATION' scope
        :type request_scope_configuration: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_o_auth2_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            override_audience=override_audience,
            use_oidc_discover=use_oidc_discover,
            use_oauth2_auth_server_metadata=use_oauth2_auth_server_metadata,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            response_types_supported=response_types_supported,
            grant_types_supported=grant_types_supported,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            request_scope_readonly=request_scope_readonly,
            request_scope_namespaces=request_scope_namespaces,
            request_scope_jobs=request_scope_jobs,
            request_scope_users=request_scope_users,
            request_scope_hypercube=request_scope_hypercube,
            request_scope_cleanup=request_scope_cleanup,
            request_scope_licenses=request_scope_licenses,
            request_scope_usage=request_scope_usage,
            request_scope_auth=request_scope_auth,
            request_scope_configuration=request_scope_configuration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_o_auth2_identity_provider_serialize(
        self,
        name,
        label,
        hidden,
        web_ui_client_id,
        issuer,
        web_ui_client_secret,
        device_client_id,
        override_audience,
        use_oidc_discover,
        use_oauth2_auth_server_metadata,
        authorization_endpoint,
        token_endpoint,
        jwks_uri,
        response_types_supported,
        grant_types_supported,
        token_endpoint_auth_methods_supported,
        end_session_endpoint,
        device_authorization_endpoint,
        request_scope_readonly,
        request_scope_namespaces,
        request_scope_jobs,
        request_scope_users,
        request_scope_hypercube,
        request_scope_cleanup,
        request_scope_licenses,
        request_scope_usage,
        request_scope_auth,
        request_scope_configuration,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'response_types_supported': 'csv',
            'grant_types_supported': 'csv',
            'token_endpoint_auth_methods_supported': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if label is not None:
            _form_params.append(('label', label))
        if hidden is not None:
            _form_params.append(('hidden', hidden))
        if web_ui_client_id is not None:
            _form_params.append(('web_ui_client_id', web_ui_client_id))
        if web_ui_client_secret is not None:
            _form_params.append(('web_ui_client_secret', web_ui_client_secret))
        if device_client_id is not None:
            _form_params.append(('device_client_id', device_client_id))
        if issuer is not None:
            _form_params.append(('issuer', issuer))
        if override_audience is not None:
            _form_params.append(('override_audience', override_audience))
        if use_oidc_discover is not None:
            _form_params.append(('use_oidc_discover', use_oidc_discover))
        if use_oauth2_auth_server_metadata is not None:
            _form_params.append(('use_oauth2_auth_server_metadata', use_oauth2_auth_server_metadata))
        if authorization_endpoint is not None:
            _form_params.append(('authorization_endpoint', authorization_endpoint))
        if token_endpoint is not None:
            _form_params.append(('token_endpoint', token_endpoint))
        if jwks_uri is not None:
            _form_params.append(('jwks_uri', jwks_uri))
        if response_types_supported is not None:
            _form_params.append(('response_types_supported', response_types_supported))
        if grant_types_supported is not None:
            _form_params.append(('grant_types_supported', grant_types_supported))
        if token_endpoint_auth_methods_supported is not None:
            _form_params.append(('token_endpoint_auth_methods_supported', token_endpoint_auth_methods_supported))
        if end_session_endpoint is not None:
            _form_params.append(('end_session_endpoint', end_session_endpoint))
        if device_authorization_endpoint is not None:
            _form_params.append(('device_authorization_endpoint', device_authorization_endpoint))
        if request_scope_readonly is not None:
            _form_params.append(('request_scope_READONLY', request_scope_readonly))
        if request_scope_namespaces is not None:
            _form_params.append(('request_scope_NAMESPACES', request_scope_namespaces))
        if request_scope_jobs is not None:
            _form_params.append(('request_scope_JOBS', request_scope_jobs))
        if request_scope_users is not None:
            _form_params.append(('request_scope_USERS', request_scope_users))
        if request_scope_hypercube is not None:
            _form_params.append(('request_scope_HYPERCUBE', request_scope_hypercube))
        if request_scope_cleanup is not None:
            _form_params.append(('request_scope_CLEANUP', request_scope_cleanup))
        if request_scope_licenses is not None:
            _form_params.append(('request_scope_LICENSES', request_scope_licenses))
        if request_scope_usage is not None:
            _form_params.append(('request_scope_USAGE', request_scope_usage))
        if request_scope_auth is not None:
            _form_params.append(('request_scope_AUTH', request_scope_auth))
        if request_scope_configuration is not None:
            _form_params.append(('request_scope_CONFIGURATION', request_scope_configuration))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/oauth2-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_oidc_identity_provider(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        scopes: Annotated[List[StrictStr], Field(description="The scopes that will be requested from the OP")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access.")] = None,
        device_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        extra_client_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        uid: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]], Field(description="The claim that serves as the unique identifier for identifying users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Creates an identity provider of type OIDC

        The id token provided by the identity provider must be a valid JWT token where the audience matches the web_ui_client_id, the device_client_id or any of the extra_client_ids. Requires admin role.

        :param name: A unique string to identify the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param scopes: The scopes that will be requested from the OP (required)
        :type scopes: List[str]
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access.
        :type device_client_id: str
        :param device_client_secret: OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.
        :type device_client_secret: str
        :param extra_client_ids: Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens
        :type extra_client_ids: List[str]
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param uid: The claim that serves as the unique identifier for identifying users.
        :type uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_oidc_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            scopes=scopes,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            device_client_secret=device_client_secret,
            extra_client_ids=extra_client_ids,
            use_oidc_discover=use_oidc_discover,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_oidc_identity_provider_with_http_info(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        scopes: Annotated[List[StrictStr], Field(description="The scopes that will be requested from the OP")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access.")] = None,
        device_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        extra_client_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        uid: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]], Field(description="The claim that serves as the unique identifier for identifying users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Creates an identity provider of type OIDC

        The id token provided by the identity provider must be a valid JWT token where the audience matches the web_ui_client_id, the device_client_id or any of the extra_client_ids. Requires admin role.

        :param name: A unique string to identify the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param scopes: The scopes that will be requested from the OP (required)
        :type scopes: List[str]
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access.
        :type device_client_id: str
        :param device_client_secret: OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.
        :type device_client_secret: str
        :param extra_client_ids: Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens
        :type extra_client_ids: List[str]
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param uid: The claim that serves as the unique identifier for identifying users.
        :type uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_oidc_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            scopes=scopes,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            device_client_secret=device_client_secret,
            extra_client_ids=extra_client_ids,
            use_oidc_discover=use_oidc_discover,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_oidc_identity_provider_without_preload_content(
        self,
        name: Annotated[str, Field(strict=True, description="A unique string to identify the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        scopes: Annotated[List[StrictStr], Field(description="The scopes that will be requested from the OP")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access.")] = None,
        device_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        extra_client_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        uid: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]], Field(description="The claim that serves as the unique identifier for identifying users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates an identity provider of type OIDC

        The id token provided by the identity provider must be a valid JWT token where the audience matches the web_ui_client_id, the device_client_id or any of the extra_client_ids. Requires admin role.

        :param name: A unique string to identify the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param scopes: The scopes that will be requested from the OP (required)
        :type scopes: List[str]
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access.
        :type device_client_id: str
        :param device_client_secret: OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.
        :type device_client_secret: str
        :param extra_client_ids: Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens
        :type extra_client_ids: List[str]
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param uid: The claim that serves as the unique identifier for identifying users.
        :type uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_oidc_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            scopes=scopes,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            device_client_secret=device_client_secret,
            extra_client_ids=extra_client_ids,
            use_oidc_discover=use_oidc_discover,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_oidc_identity_provider_serialize(
        self,
        name,
        label,
        hidden,
        web_ui_client_id,
        issuer,
        scopes,
        web_ui_client_secret,
        device_client_id,
        device_client_secret,
        extra_client_ids,
        use_oidc_discover,
        authorization_endpoint,
        token_endpoint,
        jwks_uri,
        end_session_endpoint,
        device_authorization_endpoint,
        token_endpoint_auth_methods_supported,
        uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scopes': 'csv',
            'extra_client_ids': 'csv',
            'token_endpoint_auth_methods_supported': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if label is not None:
            _form_params.append(('label', label))
        if hidden is not None:
            _form_params.append(('hidden', hidden))
        if web_ui_client_id is not None:
            _form_params.append(('web_ui_client_id', web_ui_client_id))
        if web_ui_client_secret is not None:
            _form_params.append(('web_ui_client_secret', web_ui_client_secret))
        if device_client_id is not None:
            _form_params.append(('device_client_id', device_client_id))
        if device_client_secret is not None:
            _form_params.append(('device_client_secret', device_client_secret))
        if extra_client_ids is not None:
            _form_params.append(('extra_client_ids', extra_client_ids))
        if issuer is not None:
            _form_params.append(('issuer', issuer))
        if use_oidc_discover is not None:
            _form_params.append(('use_oidc_discover', use_oidc_discover))
        if authorization_endpoint is not None:
            _form_params.append(('authorization_endpoint', authorization_endpoint))
        if token_endpoint is not None:
            _form_params.append(('token_endpoint', token_endpoint))
        if jwks_uri is not None:
            _form_params.append(('jwks_uri', jwks_uri))
        if end_session_endpoint is not None:
            _form_params.append(('end_session_endpoint', end_session_endpoint))
        if device_authorization_endpoint is not None:
            _form_params.append(('device_authorization_endpoint', device_authorization_endpoint))
        if token_endpoint_auth_methods_supported is not None:
            _form_params.append(('token_endpoint_auth_methods_supported', token_endpoint_auth_methods_supported))
        if scopes is not None:
            _form_params.append(('scopes', scopes))
        if uid is not None:
            _form_params.append(('uid', uid))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/oidc-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_identity_provider(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Deletes the identity provider with the specified name

        Unused invitations that use this identity provider are considered invalid. Users using this identity provider can no longer sign in, and their identity provider must be updated before they can sign in again. All JWT tokens signed by this identity provider are considered invalid. Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_identity_provider_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_identity_provider_with_http_info(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Deletes the identity provider with the specified name

        Unused invitations that use this identity provider are considered invalid. Users using this identity provider can no longer sign in, and their identity provider must be updated before they can sign in again. All JWT tokens signed by this identity provider are considered invalid. Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_identity_provider_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_identity_provider_without_preload_content(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes the identity provider with the specified name

        Unused invitations that use this identity provider are considered invalid. Users using this identity provider can no longer sign in, and their identity provider must be updated before they can sign in again. All JWT tokens signed by this identity provider are considered invalid. Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_identity_provider_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_identity_provider_serialize(
        self,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/auth/providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_o_auth2_token_on_behalf(
        self,
        identity_provider_name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        grant_type: Annotated[Optional[StrictStr], Field(description="Grant type of the forwarded request")] = None,
        code: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=5000)]], Field(description="Code from the OAuth2 Server, required for authorization code flow")] = None,
        code_verifier: Annotated[Optional[Annotated[str, Field(min_length=43, strict=True, max_length=128)]], Field(description="PKCE code verifier, required for authorization code flow")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="Redirection URI used when initiating the request, required for authorization code flow")] = None,
        device_code: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=5000)]], Field(description="The device verification code, required for device flow")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ForwardedTokenResponse:
        """Sends a request on your behalf to the OAuth provider token endpoint with the client secret

        This endpoint is only for \"Authorization Code Flow\" and \"Device Code Flow\" flow. It works only with OAuth 2.0/OIDC providers with a client secret. It is not recommended to use this endpoint if you can register a public client. Token forwarding for Device Code Flow is only allowed for OIDC clients.

        :param identity_provider_name: Unique identifier of the identity provider. (required)
        :type identity_provider_name: str
        :param grant_type: Grant type of the forwarded request
        :type grant_type: str
        :param code: Code from the OAuth2 Server, required for authorization code flow
        :type code: str
        :param code_verifier: PKCE code verifier, required for authorization code flow
        :type code_verifier: str
        :param redirect_uri: Redirection URI used when initiating the request, required for authorization code flow
        :type redirect_uri: str
        :param device_code: The device verification code, required for device flow
        :type device_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_o_auth2_token_on_behalf_serialize(
            identity_provider_name=identity_provider_name,
            grant_type=grant_type,
            code=code,
            code_verifier=code_verifier,
            redirect_uri=redirect_uri,
            device_code=device_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ForwardedTokenResponse",
            '400': "BadInput",
            '401': "Message",
            '404': "NotFound",
            '428': "TokenForwardError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_o_auth2_token_on_behalf_with_http_info(
        self,
        identity_provider_name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        grant_type: Annotated[Optional[StrictStr], Field(description="Grant type of the forwarded request")] = None,
        code: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=5000)]], Field(description="Code from the OAuth2 Server, required for authorization code flow")] = None,
        code_verifier: Annotated[Optional[Annotated[str, Field(min_length=43, strict=True, max_length=128)]], Field(description="PKCE code verifier, required for authorization code flow")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="Redirection URI used when initiating the request, required for authorization code flow")] = None,
        device_code: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=5000)]], Field(description="The device verification code, required for device flow")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ForwardedTokenResponse]:
        """Sends a request on your behalf to the OAuth provider token endpoint with the client secret

        This endpoint is only for \"Authorization Code Flow\" and \"Device Code Flow\" flow. It works only with OAuth 2.0/OIDC providers with a client secret. It is not recommended to use this endpoint if you can register a public client. Token forwarding for Device Code Flow is only allowed for OIDC clients.

        :param identity_provider_name: Unique identifier of the identity provider. (required)
        :type identity_provider_name: str
        :param grant_type: Grant type of the forwarded request
        :type grant_type: str
        :param code: Code from the OAuth2 Server, required for authorization code flow
        :type code: str
        :param code_verifier: PKCE code verifier, required for authorization code flow
        :type code_verifier: str
        :param redirect_uri: Redirection URI used when initiating the request, required for authorization code flow
        :type redirect_uri: str
        :param device_code: The device verification code, required for device flow
        :type device_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_o_auth2_token_on_behalf_serialize(
            identity_provider_name=identity_provider_name,
            grant_type=grant_type,
            code=code,
            code_verifier=code_verifier,
            redirect_uri=redirect_uri,
            device_code=device_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ForwardedTokenResponse",
            '400': "BadInput",
            '401': "Message",
            '404': "NotFound",
            '428': "TokenForwardError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_o_auth2_token_on_behalf_without_preload_content(
        self,
        identity_provider_name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        grant_type: Annotated[Optional[StrictStr], Field(description="Grant type of the forwarded request")] = None,
        code: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=5000)]], Field(description="Code from the OAuth2 Server, required for authorization code flow")] = None,
        code_verifier: Annotated[Optional[Annotated[str, Field(min_length=43, strict=True, max_length=128)]], Field(description="PKCE code verifier, required for authorization code flow")] = None,
        redirect_uri: Annotated[Optional[StrictStr], Field(description="Redirection URI used when initiating the request, required for authorization code flow")] = None,
        device_code: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=5000)]], Field(description="The device verification code, required for device flow")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sends a request on your behalf to the OAuth provider token endpoint with the client secret

        This endpoint is only for \"Authorization Code Flow\" and \"Device Code Flow\" flow. It works only with OAuth 2.0/OIDC providers with a client secret. It is not recommended to use this endpoint if you can register a public client. Token forwarding for Device Code Flow is only allowed for OIDC clients.

        :param identity_provider_name: Unique identifier of the identity provider. (required)
        :type identity_provider_name: str
        :param grant_type: Grant type of the forwarded request
        :type grant_type: str
        :param code: Code from the OAuth2 Server, required for authorization code flow
        :type code: str
        :param code_verifier: PKCE code verifier, required for authorization code flow
        :type code_verifier: str
        :param redirect_uri: Redirection URI used when initiating the request, required for authorization code flow
        :type redirect_uri: str
        :param device_code: The device verification code, required for device flow
        :type device_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_o_auth2_token_on_behalf_serialize(
            identity_provider_name=identity_provider_name,
            grant_type=grant_type,
            code=code,
            code_verifier=code_verifier,
            redirect_uri=redirect_uri,
            device_code=device_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ForwardedTokenResponse",
            '400': "BadInput",
            '401': "Message",
            '404': "NotFound",
            '428': "TokenForwardError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_o_auth2_token_on_behalf_serialize(
        self,
        identity_provider_name,
        grant_type,
        code,
        code_verifier,
        redirect_uri,
        device_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if grant_type is not None:
            
            _query_params.append(('grant_type', grant_type))
            
        # process the header parameters
        # process the form parameters
        if identity_provider_name is not None:
            _form_params.append(('identity_provider_name', identity_provider_name))
        if code is not None:
            _form_params.append(('code', code))
        if code_verifier is not None:
            _form_params.append(('code_verifier', code_verifier))
        if redirect_uri is not None:
            _form_params.append(('redirect_uri', redirect_uri))
        if device_code is not None:
            _form_params.append(('device_code', device_code))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/oauth2-token',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_password_policy(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PasswordPolicy:
        """Get the current password policy for Engine managed users


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_password_policy_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PasswordPolicy",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_password_policy_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PasswordPolicy]:
        """Get the current password policy for Engine managed users


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_password_policy_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PasswordPolicy",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_password_policy_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the current password policy for Engine managed users


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_password_policy_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PasswordPolicy",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_password_policy_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/auth/password-policy',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invalidate_jwt_tokens(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Invalidates all of your JSON Web Tokens(JWTs)


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invalidate_jwt_tokens_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invalidate_jwt_tokens_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Invalidates all of your JSON Web Tokens(JWTs)


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invalidate_jwt_tokens_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invalidate_jwt_tokens_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Invalidates all of your JSON Web Tokens(JWTs)


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invalidate_jwt_tokens_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invalidate_jwt_tokens_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/logout',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_all_identity_providers(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[IdentityProvider]:
        """Lists the all identity providers supported by Engine

        Requires admin role.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_identity_providers_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProvider]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_all_identity_providers_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[IdentityProvider]]:
        """Lists the all identity providers supported by Engine

        Requires admin role.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_identity_providers_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProvider]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_all_identity_providers_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists the all identity providers supported by Engine

        Requires admin role.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_identity_providers_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProvider]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_all_identity_providers_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/auth/providers/all',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_identity_providers(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of the identity provider to display. If not specified, all visible identity providers are listed. To display a hidden identity provider, its name must be specified")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[IdentityProvider]:
        """Lists the visible identity providers that are supported by Engine

        If the name is specified, the identity provider is displayed, regardless of whether it is hidden or not.

        :param name: Name of the identity provider to display. If not specified, all visible identity providers are listed. To display a hidden identity provider, its name must be specified
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_identity_providers_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProvider]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_identity_providers_with_http_info(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of the identity provider to display. If not specified, all visible identity providers are listed. To display a hidden identity provider, its name must be specified")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[IdentityProvider]]:
        """Lists the visible identity providers that are supported by Engine

        If the name is specified, the identity provider is displayed, regardless of whether it is hidden or not.

        :param name: Name of the identity provider to display. If not specified, all visible identity providers are listed. To display a hidden identity provider, its name must be specified
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_identity_providers_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProvider]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_identity_providers_without_preload_content(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of the identity provider to display. If not specified, all visible identity providers are listed. To display a hidden identity provider, its name must be specified")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists the visible identity providers that are supported by Engine

        If the name is specified, the identity provider is displayed, regardless of whether it is hidden or not.

        :param name: Name of the identity provider to display. If not specified, all visible identity providers are listed. To display a hidden identity provider, its name must be specified
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_identity_providers_serialize(
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProvider]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_identity_providers_serialize(
        self,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/auth/providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_ldap_identity_providers(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a LDAP provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IdentityProviderLdap:
        """Lists the LDAP providers

        Requires admin role. `name` field can be used to display only the desired LDAP provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, host, port

        :param name: Name of a LDAP provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_ldap_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IdentityProviderLdap",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_ldap_identity_providers_with_http_info(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a LDAP provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IdentityProviderLdap]:
        """Lists the LDAP providers

        Requires admin role. `name` field can be used to display only the desired LDAP provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, host, port

        :param name: Name of a LDAP provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_ldap_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IdentityProviderLdap",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_ldap_identity_providers_without_preload_content(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a LDAP provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists the LDAP providers

        Requires admin role. `name` field can be used to display only the desired LDAP provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, host, port

        :param name: Name of a LDAP provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_ldap_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IdentityProviderLdap",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_ldap_identity_providers_serialize(
        self,
        name,
        x_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        if x_fields is not None:
            _header_params['X-Fields'] = x_fields
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/auth/ldap-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_o_auth2_identity_providers(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a OAuth2 provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[IdentityProviderOauth2WithSecret]:
        """Lists the OAuth2 providers

        Requires admin role, as it displays client secrets. `name` field can be used to display only the desired OAuth2 provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, scopes

        :param name: Name of a OAuth2 provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_o_auth2_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProviderOauth2WithSecret]",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_o_auth2_identity_providers_with_http_info(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a OAuth2 provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[IdentityProviderOauth2WithSecret]]:
        """Lists the OAuth2 providers

        Requires admin role, as it displays client secrets. `name` field can be used to display only the desired OAuth2 provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, scopes

        :param name: Name of a OAuth2 provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_o_auth2_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProviderOauth2WithSecret]",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_o_auth2_identity_providers_without_preload_content(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a OAuth2 provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists the OAuth2 providers

        Requires admin role, as it displays client secrets. `name` field can be used to display only the desired OAuth2 provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, scopes

        :param name: Name of a OAuth2 provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_o_auth2_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProviderOauth2WithSecret]",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_o_auth2_identity_providers_serialize(
        self,
        name,
        x_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        if x_fields is not None:
            _header_params['X-Fields'] = x_fields
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/auth/oauth2-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_oidc_identity_providers(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a OIDC provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[IdentityProviderOidcWithSecret]:
        """Lists the OIDC providers

        Requires admin role, as it displays client secrets. `name` field can be used to display only the desired OIDC provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, uid

        :param name: Name of a OIDC provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_oidc_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProviderOidcWithSecret]",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_oidc_identity_providers_with_http_info(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a OIDC provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[IdentityProviderOidcWithSecret]]:
        """Lists the OIDC providers

        Requires admin role, as it displays client secrets. `name` field can be used to display only the desired OIDC provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, uid

        :param name: Name of a OIDC provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_oidc_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProviderOidcWithSecret]",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_oidc_identity_providers_without_preload_content(
        self,
        name: Annotated[Optional[StrictStr], Field(description="Name of a OIDC provider to show")] = None,
        x_fields: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists the OIDC providers

        Requires admin role, as it displays client secrets. `name` field can be used to display only the desired OIDC provider. By default all fields are listed, you can use `X-Fields` to filter the fields. For example, X-Fields: name, label, uid

        :param name: Name of a OIDC provider to show
        :type name: str
        :param x_fields:
        :type x_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_oidc_identity_providers_serialize(
            name=name,
            x_fields=x_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentityProviderOidcWithSecret]",
            '400': "Message",
            '401': "Message",
            '403': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_oidc_identity_providers_serialize(
        self,
        name,
        x_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        if x_fields is not None:
            _header_params['X-Fields'] = x_fields
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/auth/oidc-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def login_with_ldap(
        self,
        provider_name: StrictStr,
        username: Annotated[StrictStr, Field(description="LDAP Username")],
        password: Annotated[StrictStr, Field(description="LDAP Password")],
        grant_type: Optional[StrictStr] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        access_scopes: Annotated[Optional[List[StrictStr]], Field(description="Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelAuthToken:
        """Creates a JSON Web Token(JWT) for authentication (username and password in request body)


        :param provider_name: (required)
        :type provider_name: str
        :param username: LDAP Username (required)
        :type username: str
        :param password: LDAP Password (required)
        :type password: str
        :param grant_type:
        :type grant_type: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param access_scopes: Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type access_scopes: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_with_ldap_serialize(
            provider_name=provider_name,
            username=username,
            password=password,
            grant_type=grant_type,
            scope=scope,
            expires_in=expires_in,
            access_scopes=access_scopes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '404': "NotFound",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def login_with_ldap_with_http_info(
        self,
        provider_name: StrictStr,
        username: Annotated[StrictStr, Field(description="LDAP Username")],
        password: Annotated[StrictStr, Field(description="LDAP Password")],
        grant_type: Optional[StrictStr] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        access_scopes: Annotated[Optional[List[StrictStr]], Field(description="Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelAuthToken]:
        """Creates a JSON Web Token(JWT) for authentication (username and password in request body)


        :param provider_name: (required)
        :type provider_name: str
        :param username: LDAP Username (required)
        :type username: str
        :param password: LDAP Password (required)
        :type password: str
        :param grant_type:
        :type grant_type: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param access_scopes: Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type access_scopes: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_with_ldap_serialize(
            provider_name=provider_name,
            username=username,
            password=password,
            grant_type=grant_type,
            scope=scope,
            expires_in=expires_in,
            access_scopes=access_scopes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '404': "NotFound",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def login_with_ldap_without_preload_content(
        self,
        provider_name: StrictStr,
        username: Annotated[StrictStr, Field(description="LDAP Username")],
        password: Annotated[StrictStr, Field(description="LDAP Password")],
        grant_type: Optional[StrictStr] = None,
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        access_scopes: Annotated[Optional[List[StrictStr]], Field(description="Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a JSON Web Token(JWT) for authentication (username and password in request body)


        :param provider_name: (required)
        :type provider_name: str
        :param username: LDAP Username (required)
        :type username: str
        :param password: LDAP Password (required)
        :type password: str
        :param grant_type:
        :type grant_type: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param access_scopes: Deprecated, please use `scope` instead. Access scopes. Possible values: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type access_scopes: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_with_ldap_serialize(
            provider_name=provider_name,
            username=username,
            password=password,
            grant_type=grant_type,
            scope=scope,
            expires_in=expires_in,
            access_scopes=access_scopes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
            '404': "NotFound",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _login_with_ldap_serialize(
        self,
        provider_name,
        username,
        password,
        grant_type,
        scope,
        expires_in,
        access_scopes,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'access_scopes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if provider_name is not None:
            _path_params['provider_name'] = provider_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if grant_type is not None:
            _form_params.append(('grant_type', grant_type))
        if username is not None:
            _form_params.append(('username', username))
        if password is not None:
            _form_params.append(('password', password))
        if scope is not None:
            _form_params.append(('scope', scope))
        if expires_in is not None:
            _form_params.append(('expires_in', expires_in))
        if access_scopes is not None:
            _form_params.append(('access_scopes', access_scopes))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/ldap-providers/{provider_name}/login',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def login_with_oidc(
        self,
        id_token: Annotated[str, Field(min_length=80, strict=True, max_length=2048, description="ID Token of the user")],
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelAuthToken:
        """Creates a JSON Web Token(JWT) for authentication in exchange for a valid ID token from your OIDC identity provider

        An ID token can only be used once to get an access token.

        :param id_token: ID Token of the user (required)
        :type id_token: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_with_oidc_serialize(
            id_token=id_token,
            scope=scope,
            expires_in=expires_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def login_with_oidc_with_http_info(
        self,
        id_token: Annotated[str, Field(min_length=80, strict=True, max_length=2048, description="ID Token of the user")],
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelAuthToken]:
        """Creates a JSON Web Token(JWT) for authentication in exchange for a valid ID token from your OIDC identity provider

        An ID token can only be used once to get an access token.

        :param id_token: ID Token of the user (required)
        :type id_token: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_with_oidc_serialize(
            id_token=id_token,
            scope=scope,
            expires_in=expires_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def login_with_oidc_without_preload_content(
        self,
        id_token: Annotated[str, Field(min_length=80, strict=True, max_length=2048, description="ID Token of the user")],
        scope: Annotated[Optional[StrictStr], Field(description="Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION")] = None,
        expires_in: Annotated[Optional[Annotated[int, Field(le=16070400, strict=True, ge=60)]], Field(description="Time (in seconds) when the token expires.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a JSON Web Token(JWT) for authentication in exchange for a valid ID token from your OIDC identity provider

        An ID token can only be used once to get an access token.

        :param id_token: ID Token of the user (required)
        :type id_token: str
        :param scope: Access scopes space-separated. Available scopes: READONLY NAMESPACES JOBS USERS HYPERCUBE CLEANUP LICENSES USAGE AUTH CONFIGURATION
        :type scope: str
        :param expires_in: Time (in seconds) when the token expires.
        :type expires_in: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_with_oidc_serialize(
            id_token=id_token,
            scope=scope,
            expires_in=expires_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelAuthToken",
            '400': "Message",
            '401': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _login_with_oidc_serialize(
        self,
        id_token,
        scope,
        expires_in,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if id_token is not None:
            _form_params.append(('id_token', id_token))
        if scope is not None:
            _form_params.append(('scope', scope))
        if expires_in is not None:
            _form_params.append(('expires_in', expires_in))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/auth/oidc-providers/login',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_ldap_identity_provider(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login tab name")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when all identity providers are listed?")],
        host: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="Host of the LDAP server excluding protocol and port")],
        port: Annotated[int, Field(le=65535, strict=True, ge=1, description="Port of the LDAP server. Examples: 389 and 636(for simple_tls)")],
        uid: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause.")],
        encryption: Annotated[StrictStr, Field(description="Encryption method")],
        base: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\"")],
        user_filter: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\"")],
        bind_dn: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"")] = None,
        password: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The password of the user who is used for binding")] = None,
        verify_certificates: Optional[StrictBool] = None,
        active_directory: Annotated[Optional[StrictBool], Field(description="Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Updates the identity provider of type LDAP with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login tab name (required)
        :type label: str
        :param hidden: Should the identity provider be listed when all identity providers are listed? (required)
        :type hidden: bool
        :param host: Host of the LDAP server excluding protocol and port (required)
        :type host: str
        :param port: Port of the LDAP server. Examples: 389 and 636(for simple_tls) (required)
        :type port: int
        :param uid: The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause. (required)
        :type uid: str
        :param encryption: Encryption method (required)
        :type encryption: str
        :param base: DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\" (required)
        :type base: str
        :param user_filter: LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\" (required)
        :type user_filter: str
        :param bind_dn: The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"
        :type bind_dn: str
        :param password: The password of the user who is used for binding
        :type password: str
        :param verify_certificates:
        :type verify_certificates: bool
        :param active_directory: Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used
        :type active_directory: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_ldap_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            host=host,
            port=port,
            uid=uid,
            encryption=encryption,
            base=base,
            user_filter=user_filter,
            bind_dn=bind_dn,
            password=password,
            verify_certificates=verify_certificates,
            active_directory=active_directory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_ldap_identity_provider_with_http_info(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login tab name")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when all identity providers are listed?")],
        host: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="Host of the LDAP server excluding protocol and port")],
        port: Annotated[int, Field(le=65535, strict=True, ge=1, description="Port of the LDAP server. Examples: 389 and 636(for simple_tls)")],
        uid: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause.")],
        encryption: Annotated[StrictStr, Field(description="Encryption method")],
        base: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\"")],
        user_filter: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\"")],
        bind_dn: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"")] = None,
        password: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The password of the user who is used for binding")] = None,
        verify_certificates: Optional[StrictBool] = None,
        active_directory: Annotated[Optional[StrictBool], Field(description="Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Updates the identity provider of type LDAP with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login tab name (required)
        :type label: str
        :param hidden: Should the identity provider be listed when all identity providers are listed? (required)
        :type hidden: bool
        :param host: Host of the LDAP server excluding protocol and port (required)
        :type host: str
        :param port: Port of the LDAP server. Examples: 389 and 636(for simple_tls) (required)
        :type port: int
        :param uid: The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause. (required)
        :type uid: str
        :param encryption: Encryption method (required)
        :type encryption: str
        :param base: DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\" (required)
        :type base: str
        :param user_filter: LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\" (required)
        :type user_filter: str
        :param bind_dn: The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"
        :type bind_dn: str
        :param password: The password of the user who is used for binding
        :type password: str
        :param verify_certificates:
        :type verify_certificates: bool
        :param active_directory: Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used
        :type active_directory: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_ldap_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            host=host,
            port=port,
            uid=uid,
            encryption=encryption,
            base=base,
            user_filter=user_filter,
            bind_dn=bind_dn,
            password=password,
            verify_certificates=verify_certificates,
            active_directory=active_directory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_ldap_identity_provider_without_preload_content(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login tab name")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when all identity providers are listed?")],
        host: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="Host of the LDAP server excluding protocol and port")],
        port: Annotated[int, Field(le=65535, strict=True, ge=1, description="Port of the LDAP server. Examples: 389 and 636(for simple_tls)")],
        uid: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause.")],
        encryption: Annotated[StrictStr, Field(description="Encryption method")],
        base: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\"")],
        user_filter: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\"")],
        bind_dn: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"")] = None,
        password: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="The password of the user who is used for binding")] = None,
        verify_certificates: Optional[StrictBool] = None,
        active_directory: Annotated[Optional[StrictBool], Field(description="Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates the identity provider of type LDAP with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login tab name (required)
        :type label: str
        :param hidden: Should the identity provider be listed when all identity providers are listed? (required)
        :type hidden: bool
        :param host: Host of the LDAP server excluding protocol and port (required)
        :type host: str
        :param port: Port of the LDAP server. Examples: 389 and 636(for simple_tls) (required)
        :type port: int
        :param uid: The LDAP attribute that is used as username. Examples: \\\"sAMAccountName\\\" for Active Directory, \\\"uid\\\" for OpenLDAP. This will be appended to user_filter with an \\\"&\\\" clause. (required)
        :type uid: str
        :param encryption: Encryption method (required)
        :type encryption: str
        :param base: DN of the base where users are located. Example for OpenLDAP: \\\"ou=users,dc=example,dc=com\\\" (required)
        :type base: str
        :param user_filter: LDAP user filter. Format can be found in RFC4515. Examples:\\\"(objectClass=User)\\\" or \\\"(memberOf=cn=gams-engine,ou=groups,dc=example,dc=com)\\\" or \\\"&((objectClass=User),(employeeType=developer))\\\" (required)
        :type user_filter: str
        :param bind_dn: The full DN of the user who is used for binding. Example for OpenLDAP: \\\"uid=admin,ou=users,dc=example,dc=org\\\". Example for Active Directory: \\\"EXAMPLE\\\\\\\\admin\\\"
        :type bind_dn: str
        :param password: The password of the user who is used for binding
        :type password: str
        :param verify_certificates:
        :type verify_certificates: bool
        :param active_directory: Is LDAP server an Active Directory LDAP server. For AD, NTLMv2 authentication is used
        :type active_directory: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_ldap_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            host=host,
            port=port,
            uid=uid,
            encryption=encryption,
            base=base,
            user_filter=user_filter,
            bind_dn=bind_dn,
            password=password,
            verify_certificates=verify_certificates,
            active_directory=active_directory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_ldap_identity_provider_serialize(
        self,
        name,
        label,
        hidden,
        host,
        port,
        uid,
        encryption,
        base,
        user_filter,
        bind_dn,
        password,
        verify_certificates,
        active_directory,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if label is not None:
            _form_params.append(('label', label))
        if hidden is not None:
            _form_params.append(('hidden', hidden))
        if host is not None:
            _form_params.append(('host', host))
        if port is not None:
            _form_params.append(('port', port))
        if uid is not None:
            _form_params.append(('uid', uid))
        if bind_dn is not None:
            _form_params.append(('bind_dn', bind_dn))
        if password is not None:
            _form_params.append(('password', password))
        if encryption is not None:
            _form_params.append(('encryption', encryption))
        if verify_certificates is not None:
            _form_params.append(('verify_certificates', verify_certificates))
        if active_directory is not None:
            _form_params.append(('active_directory', active_directory))
        if base is not None:
            _form_params.append(('base', base))
        if user_filter is not None:
            _form_params.append(('user_filter', user_filter))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/auth/ldap-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_o_auth2_identity_provider(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.")] = None,
        override_audience: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        use_oauth2_auth_server_metadata: Annotated[Optional[StrictBool], Field(description="Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        response_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).")] = None,
        grant_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        request_scope_readonly: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'READONLY' scope")] = None,
        request_scope_namespaces: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'NAMESPACES' scope")] = None,
        request_scope_jobs: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'JOBS' scope")] = None,
        request_scope_users: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USERS' scope")] = None,
        request_scope_hypercube: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'HYPERCUBE' scope")] = None,
        request_scope_cleanup: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CLEANUP' scope")] = None,
        request_scope_licenses: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'LICENSES' scope")] = None,
        request_scope_usage: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USAGE' scope")] = None,
        request_scope_auth: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'AUTH' scope")] = None,
        request_scope_configuration: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CONFIGURATION' scope")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Updates the identity provider of type OAuth2 with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.
        :type device_client_id: str
        :param override_audience: By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.
        :type override_audience: str
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param use_oauth2_auth_server_metadata: Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server
        :type use_oauth2_auth_server_metadata: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param response_types_supported: Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).
        :type response_types_supported: List[str]
        :param grant_types_supported: Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).
        :type grant_types_supported: List[str]
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param request_scope_readonly: Scope that the client should request from the OP to get 'READONLY' scope
        :type request_scope_readonly: str
        :param request_scope_namespaces: Scope that the client should request from the OP to get 'NAMESPACES' scope
        :type request_scope_namespaces: str
        :param request_scope_jobs: Scope that the client should request from the OP to get 'JOBS' scope
        :type request_scope_jobs: str
        :param request_scope_users: Scope that the client should request from the OP to get 'USERS' scope
        :type request_scope_users: str
        :param request_scope_hypercube: Scope that the client should request from the OP to get 'HYPERCUBE' scope
        :type request_scope_hypercube: str
        :param request_scope_cleanup: Scope that the client should request from the OP to get 'CLEANUP' scope
        :type request_scope_cleanup: str
        :param request_scope_licenses: Scope that the client should request from the OP to get 'LICENSES' scope
        :type request_scope_licenses: str
        :param request_scope_usage: Scope that the client should request from the OP to get 'USAGE' scope
        :type request_scope_usage: str
        :param request_scope_auth: Scope that the client should request from the OP to get 'AUTH' scope
        :type request_scope_auth: str
        :param request_scope_configuration: Scope that the client should request from the OP to get 'CONFIGURATION' scope
        :type request_scope_configuration: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_o_auth2_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            override_audience=override_audience,
            use_oidc_discover=use_oidc_discover,
            use_oauth2_auth_server_metadata=use_oauth2_auth_server_metadata,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            response_types_supported=response_types_supported,
            grant_types_supported=grant_types_supported,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            request_scope_readonly=request_scope_readonly,
            request_scope_namespaces=request_scope_namespaces,
            request_scope_jobs=request_scope_jobs,
            request_scope_users=request_scope_users,
            request_scope_hypercube=request_scope_hypercube,
            request_scope_cleanup=request_scope_cleanup,
            request_scope_licenses=request_scope_licenses,
            request_scope_usage=request_scope_usage,
            request_scope_auth=request_scope_auth,
            request_scope_configuration=request_scope_configuration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "BadInput",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_o_auth2_identity_provider_with_http_info(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.")] = None,
        override_audience: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        use_oauth2_auth_server_metadata: Annotated[Optional[StrictBool], Field(description="Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        response_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).")] = None,
        grant_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        request_scope_readonly: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'READONLY' scope")] = None,
        request_scope_namespaces: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'NAMESPACES' scope")] = None,
        request_scope_jobs: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'JOBS' scope")] = None,
        request_scope_users: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USERS' scope")] = None,
        request_scope_hypercube: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'HYPERCUBE' scope")] = None,
        request_scope_cleanup: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CLEANUP' scope")] = None,
        request_scope_licenses: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'LICENSES' scope")] = None,
        request_scope_usage: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USAGE' scope")] = None,
        request_scope_auth: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'AUTH' scope")] = None,
        request_scope_configuration: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CONFIGURATION' scope")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Updates the identity provider of type OAuth2 with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.
        :type device_client_id: str
        :param override_audience: By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.
        :type override_audience: str
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param use_oauth2_auth_server_metadata: Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server
        :type use_oauth2_auth_server_metadata: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param response_types_supported: Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).
        :type response_types_supported: List[str]
        :param grant_types_supported: Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).
        :type grant_types_supported: List[str]
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param request_scope_readonly: Scope that the client should request from the OP to get 'READONLY' scope
        :type request_scope_readonly: str
        :param request_scope_namespaces: Scope that the client should request from the OP to get 'NAMESPACES' scope
        :type request_scope_namespaces: str
        :param request_scope_jobs: Scope that the client should request from the OP to get 'JOBS' scope
        :type request_scope_jobs: str
        :param request_scope_users: Scope that the client should request from the OP to get 'USERS' scope
        :type request_scope_users: str
        :param request_scope_hypercube: Scope that the client should request from the OP to get 'HYPERCUBE' scope
        :type request_scope_hypercube: str
        :param request_scope_cleanup: Scope that the client should request from the OP to get 'CLEANUP' scope
        :type request_scope_cleanup: str
        :param request_scope_licenses: Scope that the client should request from the OP to get 'LICENSES' scope
        :type request_scope_licenses: str
        :param request_scope_usage: Scope that the client should request from the OP to get 'USAGE' scope
        :type request_scope_usage: str
        :param request_scope_auth: Scope that the client should request from the OP to get 'AUTH' scope
        :type request_scope_auth: str
        :param request_scope_configuration: Scope that the client should request from the OP to get 'CONFIGURATION' scope
        :type request_scope_configuration: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_o_auth2_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            override_audience=override_audience,
            use_oidc_discover=use_oidc_discover,
            use_oauth2_auth_server_metadata=use_oauth2_auth_server_metadata,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            response_types_supported=response_types_supported,
            grant_types_supported=grant_types_supported,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            request_scope_readonly=request_scope_readonly,
            request_scope_namespaces=request_scope_namespaces,
            request_scope_jobs=request_scope_jobs,
            request_scope_users=request_scope_users,
            request_scope_hypercube=request_scope_hypercube,
            request_scope_cleanup=request_scope_cleanup,
            request_scope_licenses=request_scope_licenses,
            request_scope_usage=request_scope_usage,
            request_scope_auth=request_scope_auth,
            request_scope_configuration=request_scope_configuration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "BadInput",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_o_auth2_identity_provider_without_preload_content(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.")] = None,
        override_audience: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        use_oauth2_auth_server_metadata: Annotated[Optional[StrictBool], Field(description="Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        response_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).")] = None,
        grant_types_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        request_scope_readonly: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'READONLY' scope")] = None,
        request_scope_namespaces: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'NAMESPACES' scope")] = None,
        request_scope_jobs: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'JOBS' scope")] = None,
        request_scope_users: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USERS' scope")] = None,
        request_scope_hypercube: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'HYPERCUBE' scope")] = None,
        request_scope_cleanup: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CLEANUP' scope")] = None,
        request_scope_licenses: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'LICENSES' scope")] = None,
        request_scope_usage: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'USAGE' scope")] = None,
        request_scope_auth: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'AUTH' scope")] = None,
        request_scope_configuration: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="Scope that the client should request from the OP to get 'CONFIGURATION' scope")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates the identity provider of type OAuth2 with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access. The client must be a public client.
        :type device_client_id: str
        :param override_audience: By default, JWT tokens are expected to have audience claim matching the hostname in the configuration. To change expected audience for this provider, you can provide override_audience. Please try to avoid this. Instead, set the hostname properly in the Engine configuration and in the authorization server.
        :type override_audience: str
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param use_oauth2_auth_server_metadata: Should OAuth 2.0 Authorization Server Metadata be used.Fetches information from issuer URL appended with /.well-known/oauth-authorization-server
        :type use_oauth2_auth_server_metadata: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param response_types_supported: Required unless discovery is used. Array containing a list of the OAuth 2.0 response_type values that this OP supports (ignored if discovery is used).
        :type response_types_supported: List[str]
        :param grant_types_supported: Array containing a list of the OAuth 2.0 Grant Type values that this OP supports (ignored if discovery is used).
        :type grant_types_supported: List[str]
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param request_scope_readonly: Scope that the client should request from the OP to get 'READONLY' scope
        :type request_scope_readonly: str
        :param request_scope_namespaces: Scope that the client should request from the OP to get 'NAMESPACES' scope
        :type request_scope_namespaces: str
        :param request_scope_jobs: Scope that the client should request from the OP to get 'JOBS' scope
        :type request_scope_jobs: str
        :param request_scope_users: Scope that the client should request from the OP to get 'USERS' scope
        :type request_scope_users: str
        :param request_scope_hypercube: Scope that the client should request from the OP to get 'HYPERCUBE' scope
        :type request_scope_hypercube: str
        :param request_scope_cleanup: Scope that the client should request from the OP to get 'CLEANUP' scope
        :type request_scope_cleanup: str
        :param request_scope_licenses: Scope that the client should request from the OP to get 'LICENSES' scope
        :type request_scope_licenses: str
        :param request_scope_usage: Scope that the client should request from the OP to get 'USAGE' scope
        :type request_scope_usage: str
        :param request_scope_auth: Scope that the client should request from the OP to get 'AUTH' scope
        :type request_scope_auth: str
        :param request_scope_configuration: Scope that the client should request from the OP to get 'CONFIGURATION' scope
        :type request_scope_configuration: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_o_auth2_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            override_audience=override_audience,
            use_oidc_discover=use_oidc_discover,
            use_oauth2_auth_server_metadata=use_oauth2_auth_server_metadata,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            response_types_supported=response_types_supported,
            grant_types_supported=grant_types_supported,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            request_scope_readonly=request_scope_readonly,
            request_scope_namespaces=request_scope_namespaces,
            request_scope_jobs=request_scope_jobs,
            request_scope_users=request_scope_users,
            request_scope_hypercube=request_scope_hypercube,
            request_scope_cleanup=request_scope_cleanup,
            request_scope_licenses=request_scope_licenses,
            request_scope_usage=request_scope_usage,
            request_scope_auth=request_scope_auth,
            request_scope_configuration=request_scope_configuration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "BadInput",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_o_auth2_identity_provider_serialize(
        self,
        name,
        label,
        hidden,
        web_ui_client_id,
        issuer,
        web_ui_client_secret,
        device_client_id,
        override_audience,
        use_oidc_discover,
        use_oauth2_auth_server_metadata,
        authorization_endpoint,
        token_endpoint,
        jwks_uri,
        response_types_supported,
        grant_types_supported,
        token_endpoint_auth_methods_supported,
        end_session_endpoint,
        device_authorization_endpoint,
        request_scope_readonly,
        request_scope_namespaces,
        request_scope_jobs,
        request_scope_users,
        request_scope_hypercube,
        request_scope_cleanup,
        request_scope_licenses,
        request_scope_usage,
        request_scope_auth,
        request_scope_configuration,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'response_types_supported': 'csv',
            'grant_types_supported': 'csv',
            'token_endpoint_auth_methods_supported': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if label is not None:
            _form_params.append(('label', label))
        if hidden is not None:
            _form_params.append(('hidden', hidden))
        if web_ui_client_id is not None:
            _form_params.append(('web_ui_client_id', web_ui_client_id))
        if web_ui_client_secret is not None:
            _form_params.append(('web_ui_client_secret', web_ui_client_secret))
        if device_client_id is not None:
            _form_params.append(('device_client_id', device_client_id))
        if issuer is not None:
            _form_params.append(('issuer', issuer))
        if override_audience is not None:
            _form_params.append(('override_audience', override_audience))
        if use_oidc_discover is not None:
            _form_params.append(('use_oidc_discover', use_oidc_discover))
        if use_oauth2_auth_server_metadata is not None:
            _form_params.append(('use_oauth2_auth_server_metadata', use_oauth2_auth_server_metadata))
        if authorization_endpoint is not None:
            _form_params.append(('authorization_endpoint', authorization_endpoint))
        if token_endpoint is not None:
            _form_params.append(('token_endpoint', token_endpoint))
        if jwks_uri is not None:
            _form_params.append(('jwks_uri', jwks_uri))
        if response_types_supported is not None:
            _form_params.append(('response_types_supported', response_types_supported))
        if grant_types_supported is not None:
            _form_params.append(('grant_types_supported', grant_types_supported))
        if token_endpoint_auth_methods_supported is not None:
            _form_params.append(('token_endpoint_auth_methods_supported', token_endpoint_auth_methods_supported))
        if end_session_endpoint is not None:
            _form_params.append(('end_session_endpoint', end_session_endpoint))
        if device_authorization_endpoint is not None:
            _form_params.append(('device_authorization_endpoint', device_authorization_endpoint))
        if request_scope_readonly is not None:
            _form_params.append(('request_scope_READONLY', request_scope_readonly))
        if request_scope_namespaces is not None:
            _form_params.append(('request_scope_NAMESPACES', request_scope_namespaces))
        if request_scope_jobs is not None:
            _form_params.append(('request_scope_JOBS', request_scope_jobs))
        if request_scope_users is not None:
            _form_params.append(('request_scope_USERS', request_scope_users))
        if request_scope_hypercube is not None:
            _form_params.append(('request_scope_HYPERCUBE', request_scope_hypercube))
        if request_scope_cleanup is not None:
            _form_params.append(('request_scope_CLEANUP', request_scope_cleanup))
        if request_scope_licenses is not None:
            _form_params.append(('request_scope_LICENSES', request_scope_licenses))
        if request_scope_usage is not None:
            _form_params.append(('request_scope_USAGE', request_scope_usage))
        if request_scope_auth is not None:
            _form_params.append(('request_scope_AUTH', request_scope_auth))
        if request_scope_configuration is not None:
            _form_params.append(('request_scope_CONFIGURATION', request_scope_configuration))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/auth/oauth2-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_oidc_identity_provider(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        scopes: Annotated[List[StrictStr], Field(description="The scopes that will be requested from the OP")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access.")] = None,
        device_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        extra_client_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        uid: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]], Field(description="The claim that serves as the unique identifier for identifying users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Updates the identity provider of type OIDC with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param scopes: The scopes that will be requested from the OP (required)
        :type scopes: List[str]
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access.
        :type device_client_id: str
        :param device_client_secret: OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.
        :type device_client_secret: str
        :param extra_client_ids: Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens
        :type extra_client_ids: List[str]
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param uid: The claim that serves as the unique identifier for identifying users.
        :type uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_oidc_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            scopes=scopes,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            device_client_secret=device_client_secret,
            extra_client_ids=extra_client_ids,
            use_oidc_discover=use_oidc_discover,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "BadInput",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_oidc_identity_provider_with_http_info(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        scopes: Annotated[List[StrictStr], Field(description="The scopes that will be requested from the OP")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access.")] = None,
        device_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        extra_client_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        uid: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]], Field(description="The claim that serves as the unique identifier for identifying users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Updates the identity provider of type OIDC with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param scopes: The scopes that will be requested from the OP (required)
        :type scopes: List[str]
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access.
        :type device_client_id: str
        :param device_client_secret: OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.
        :type device_client_secret: str
        :param extra_client_ids: Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens
        :type extra_client_ids: List[str]
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param uid: The claim that serves as the unique identifier for identifying users.
        :type uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_oidc_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            scopes=scopes,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            device_client_secret=device_client_secret,
            extra_client_ids=extra_client_ids,
            use_oidc_discover=use_oidc_discover,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "BadInput",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_oidc_identity_provider_without_preload_content(
        self,
        name: Annotated[str, Field(strict=True, description="Unique identifier of the identity provider.")],
        label: Annotated[str, Field(strict=True, description="Suggested login button string")],
        hidden: Annotated[StrictBool, Field(description="Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not.")],
        web_ui_client_id: Annotated[str, Field(min_length=1, strict=True, max_length=255, description="OAuth 2.0 client id that should be used by Engine UI while logging in")],
        issuer: Annotated[StrictStr, Field(description="URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier.")],
        scopes: Annotated[List[StrictStr], Field(description="The scopes that will be requested from the OP")],
        web_ui_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        device_client_id: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]], Field(description="OAuth 2.0 client ID, which should be used by clients that do not have browser access.")] = None,
        device_client_secret: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=512)]], Field(description="OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.")] = None,
        extra_client_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens")] = None,
        use_oidc_discover: Annotated[Optional[StrictBool], Field(description="Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration")] = None,
        authorization_endpoint: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).")] = None,
        token_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).")] = None,
        jwks_uri: Annotated[Optional[StrictStr], Field(description="Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).")] = None,
        end_session_endpoint: Annotated[Optional[StrictStr], Field(description="URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)")] = None,
        device_authorization_endpoint: Annotated[Optional[StrictStr], Field(description="URL of the authorization server's device authorization endpoint (ignored if discovery is used)")] = None,
        token_endpoint_auth_methods_supported: Annotated[Optional[List[StrictStr]], Field(description="Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).")] = None,
        uid: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]], Field(description="The claim that serves as the unique identifier for identifying users.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates the identity provider of type OIDC with the specified name

        Requires admin role.

        :param name: Unique identifier of the identity provider. (required)
        :type name: str
        :param label: Suggested login button string (required)
        :type label: str
        :param hidden: Should the identity provider be listed when identity providers are listed. Client secrets are never displayed whether the identity provider is hidden or not. (required)
        :type hidden: bool
        :param web_ui_client_id: OAuth 2.0 client id that should be used by Engine UI while logging in (required)
        :type web_ui_client_id: str
        :param issuer: URL using the https scheme with no query or fragment component that the OP asserts as its Issuer Identifier. (required)
        :type issuer: str
        :param scopes: The scopes that will be requested from the OP (required)
        :type scopes: List[str]
        :param web_ui_client_secret: OAuth 2.0 client secret that should be used by Engine UI while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret, as Engine UI is a single-page application and cannot store client secrets. However, if this is not possible, you can use a slightly modified version of the Authorization Code Flow and have the API send token requests with the secret on your behalf.
        :type web_ui_client_secret: str
        :param device_client_id: OAuth 2.0 client ID, which should be used by clients that do not have browser access.
        :type device_client_id: str
        :param device_client_secret: OAuth 2.0 client secret that should be used by devices while logging in. We recommend using a public OAuth 2.0 client and not specifying a secret.  However, if this is not possible, you can use a slightly modified version of the Device Code Flow and have the API send token requests with the secret on your behalf.
        :type device_client_secret: str
        :param extra_client_ids: Array of extra OAuth 2.0 client IDs from which the API accepts ID tokens
        :type extra_client_ids: List[str]
        :param use_oidc_discover: Should OpenID Connect Discovery be used. Fetches information from issuer URL appended with /.well-known/openid-configuration
        :type use_oidc_discover: bool
        :param authorization_endpoint: Required unless discovery is used. URL of the OP's OAuth 2.0 Authorization Endpoint (ignored if discovery is used).
        :type authorization_endpoint: str
        :param token_endpoint: URL of the OP's OAuth 2.0 Token Endpoint (ignored if discovery is used).
        :type token_endpoint: str
        :param jwks_uri: Required unless discovery is used. URL of the OP's JSON Web Key Set document (ignored if discovery is used).
        :type jwks_uri: str
        :param end_session_endpoint: URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP (ignored if discovery is used)
        :type end_session_endpoint: str
        :param device_authorization_endpoint: URL of the authorization server's device authorization endpoint (ignored if discovery is used)
        :type device_authorization_endpoint: str
        :param token_endpoint_auth_methods_supported: Array containing a list of client authentication methods supported by the OP's token endpoint (ignored if discovery is used).
        :type token_endpoint_auth_methods_supported: List[str]
        :param uid: The claim that serves as the unique identifier for identifying users.
        :type uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_oidc_identity_provider_serialize(
            name=name,
            label=label,
            hidden=hidden,
            web_ui_client_id=web_ui_client_id,
            issuer=issuer,
            scopes=scopes,
            web_ui_client_secret=web_ui_client_secret,
            device_client_id=device_client_id,
            device_client_secret=device_client_secret,
            extra_client_ids=extra_client_ids,
            use_oidc_discover=use_oidc_discover,
            authorization_endpoint=authorization_endpoint,
            token_endpoint=token_endpoint,
            jwks_uri=jwks_uri,
            end_session_endpoint=end_session_endpoint,
            device_authorization_endpoint=device_authorization_endpoint,
            token_endpoint_auth_methods_supported=token_endpoint_auth_methods_supported,
            uid=uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "BadInput",
            '401': "Message",
            '403': "Message",
            '404': "NotFound",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_oidc_identity_provider_serialize(
        self,
        name,
        label,
        hidden,
        web_ui_client_id,
        issuer,
        scopes,
        web_ui_client_secret,
        device_client_id,
        device_client_secret,
        extra_client_ids,
        use_oidc_discover,
        authorization_endpoint,
        token_endpoint,
        jwks_uri,
        end_session_endpoint,
        device_authorization_endpoint,
        token_endpoint_auth_methods_supported,
        uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'scopes': 'csv',
            'extra_client_ids': 'csv',
            'token_endpoint_auth_methods_supported': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if name is not None:
            _form_params.append(('name', name))
        if label is not None:
            _form_params.append(('label', label))
        if hidden is not None:
            _form_params.append(('hidden', hidden))
        if web_ui_client_id is not None:
            _form_params.append(('web_ui_client_id', web_ui_client_id))
        if web_ui_client_secret is not None:
            _form_params.append(('web_ui_client_secret', web_ui_client_secret))
        if device_client_id is not None:
            _form_params.append(('device_client_id', device_client_id))
        if device_client_secret is not None:
            _form_params.append(('device_client_secret', device_client_secret))
        if extra_client_ids is not None:
            _form_params.append(('extra_client_ids', extra_client_ids))
        if issuer is not None:
            _form_params.append(('issuer', issuer))
        if use_oidc_discover is not None:
            _form_params.append(('use_oidc_discover', use_oidc_discover))
        if authorization_endpoint is not None:
            _form_params.append(('authorization_endpoint', authorization_endpoint))
        if token_endpoint is not None:
            _form_params.append(('token_endpoint', token_endpoint))
        if jwks_uri is not None:
            _form_params.append(('jwks_uri', jwks_uri))
        if end_session_endpoint is not None:
            _form_params.append(('end_session_endpoint', end_session_endpoint))
        if device_authorization_endpoint is not None:
            _form_params.append(('device_authorization_endpoint', device_authorization_endpoint))
        if token_endpoint_auth_methods_supported is not None:
            _form_params.append(('token_endpoint_auth_methods_supported', token_endpoint_auth_methods_supported))
        if scopes is not None:
            _form_params.append(('scopes', scopes))
        if uid is not None:
            _form_params.append(('uid', uid))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/auth/oidc-providers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_password_policy(
        self,
        min_password_length: Annotated[int, Field(le=70, strict=True, ge=8)],
        must_include_uppercase: StrictBool,
        must_include_lowercase: StrictBool,
        must_include_number: StrictBool,
        must_include_special_char: StrictBool,
        not_in_popular_passwords: StrictBool,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Update the password policy for Engine managed users


        :param min_password_length: (required)
        :type min_password_length: int
        :param must_include_uppercase: (required)
        :type must_include_uppercase: bool
        :param must_include_lowercase: (required)
        :type must_include_lowercase: bool
        :param must_include_number: (required)
        :type must_include_number: bool
        :param must_include_special_char: (required)
        :type must_include_special_char: bool
        :param not_in_popular_passwords: (required)
        :type not_in_popular_passwords: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_password_policy_serialize(
            min_password_length=min_password_length,
            must_include_uppercase=must_include_uppercase,
            must_include_lowercase=must_include_lowercase,
            must_include_number=must_include_number,
            must_include_special_char=must_include_special_char,
            not_in_popular_passwords=not_in_popular_passwords,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_password_policy_with_http_info(
        self,
        min_password_length: Annotated[int, Field(le=70, strict=True, ge=8)],
        must_include_uppercase: StrictBool,
        must_include_lowercase: StrictBool,
        must_include_number: StrictBool,
        must_include_special_char: StrictBool,
        not_in_popular_passwords: StrictBool,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Update the password policy for Engine managed users


        :param min_password_length: (required)
        :type min_password_length: int
        :param must_include_uppercase: (required)
        :type must_include_uppercase: bool
        :param must_include_lowercase: (required)
        :type must_include_lowercase: bool
        :param must_include_number: (required)
        :type must_include_number: bool
        :param must_include_special_char: (required)
        :type must_include_special_char: bool
        :param not_in_popular_passwords: (required)
        :type not_in_popular_passwords: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_password_policy_serialize(
            min_password_length=min_password_length,
            must_include_uppercase=must_include_uppercase,
            must_include_lowercase=must_include_lowercase,
            must_include_number=must_include_number,
            must_include_special_char=must_include_special_char,
            not_in_popular_passwords=not_in_popular_passwords,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_password_policy_without_preload_content(
        self,
        min_password_length: Annotated[int, Field(le=70, strict=True, ge=8)],
        must_include_uppercase: StrictBool,
        must_include_lowercase: StrictBool,
        must_include_number: StrictBool,
        must_include_special_char: StrictBool,
        not_in_popular_passwords: StrictBool,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the password policy for Engine managed users


        :param min_password_length: (required)
        :type min_password_length: int
        :param must_include_uppercase: (required)
        :type must_include_uppercase: bool
        :param must_include_lowercase: (required)
        :type must_include_lowercase: bool
        :param must_include_number: (required)
        :type must_include_number: bool
        :param must_include_special_char: (required)
        :type must_include_special_char: bool
        :param not_in_popular_passwords: (required)
        :type not_in_popular_passwords: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_password_policy_serialize(
            min_password_length=min_password_length,
            must_include_uppercase=must_include_uppercase,
            must_include_lowercase=must_include_lowercase,
            must_include_number=must_include_number,
            must_include_special_char=must_include_special_char,
            not_in_popular_passwords=not_in_popular_passwords,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_password_policy_serialize(
        self,
        min_password_length,
        must_include_uppercase,
        must_include_lowercase,
        must_include_number,
        must_include_special_char,
        not_in_popular_passwords,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if min_password_length is not None:
            _form_params.append(('min_password_length', min_password_length))
        if must_include_uppercase is not None:
            _form_params.append(('must_include_uppercase', must_include_uppercase))
        if must_include_lowercase is not None:
            _form_params.append(('must_include_lowercase', must_include_lowercase))
        if must_include_number is not None:
            _form_params.append(('must_include_number', must_include_number))
        if must_include_special_char is not None:
            _form_params.append(('must_include_special_char', must_include_special_char))
        if not_in_popular_passwords is not None:
            _form_params.append(('not_in_popular_passwords', not_in_popular_passwords))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/auth/password-policy',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


