# coding: utf-8

"""
    GAMS Engine

    With GAMS Engine you can register and solve GAMS models. It has a namespace management system, so you can restrict your users to certain models.

    The version of the OpenAPI document: latest
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from gams.engine.models.hypercube_page import HypercubePage
from gams.engine.models.hypercube_token import HypercubeToken
from gams.engine.models.message import Message

from gams.engine.api_client import ApiClient, RequestSerialized
from gams.engine.api_response import ApiResponse
from gams.engine.rest import RESTResponseType


class HypercubeApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_hypercube(
        self,
        model: Annotated[StrictStr, Field(description="Name of the model")],
        namespace: Annotated[StrictStr, Field(description="Namespace containing(or will contain) the model")],
        hypercube_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Hypercube description file")],
        run: Annotated[Optional[StrictStr], Field(description="Name of the main gms file with its extension. Will use model + '.gms' if not provided.")] = None,
        inex_string: Annotated[Optional[StrictStr], Field(description="Optional JSON string to filter the contents of the result zip file (inex_file takes precedence if specified)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        dep_tokens: Annotated[Optional[List[StrictStr]], Field(description="Tokens of jobs on which this job depends. The order defines the order in which the results of dependent jobs are extracted.")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="Labels that will be attached to the job in key=value. Currently supported labels are: cpu_request, memory_request, workspace_request, node_selectors, tolerations, instance")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Human-readable tag to assign to job (at most 255 characters)")] = None,
        access_groups: Annotated[Optional[List[StrictStr]], Field(description="Labels of user groups that should be able to access this job.")] = None,
        priority: Annotated[Optional[StrictStr], Field(description="Job priority. Only available if job priorities feature is enabled. Possible values are: low, medium, high")] = None,
        stdout_filename: Optional[StrictStr] = None,
        model_data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing model files, if model is not registered")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="File containing data in zip")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional JSON file to filter the contents of the result zip file")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HypercubeToken:
        """Posts a Hypercube job

        If the model is a registered model, execute permission for the namespace is required. If model is a temporary model execute and write permission for the namespace is required. When the disk or volume quota reaches 80%, quota_warning is included in the response.

        :param model: Name of the model (required)
        :type model: str
        :param namespace: Namespace containing(or will contain) the model (required)
        :type namespace: str
        :param hypercube_file: Hypercube description file (required)
        :type hypercube_file: bytearray
        :param run: Name of the main gms file with its extension. Will use model + '.gms' if not provided.
        :type run: str
        :param inex_string: Optional JSON string to filter the contents of the result zip file (inex_file takes precedence if specified)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param dep_tokens: Tokens of jobs on which this job depends. The order defines the order in which the results of dependent jobs are extracted.
        :type dep_tokens: List[str]
        :param labels: Labels that will be attached to the job in key=value. Currently supported labels are: cpu_request, memory_request, workspace_request, node_selectors, tolerations, instance
        :type labels: List[str]
        :param tag: Human-readable tag to assign to job (at most 255 characters)
        :type tag: str
        :param access_groups: Labels of user groups that should be able to access this job.
        :type access_groups: List[str]
        :param priority: Job priority. Only available if job priorities feature is enabled. Possible values are: low, medium, high
        :type priority: str
        :param stdout_filename:
        :type stdout_filename: str
        :param model_data: Zip file containing model files, if model is not registered
        :type model_data: bytearray
        :param data: File containing data in zip
        :type data: bytearray
        :param inex_file: Optional JSON file to filter the contents of the result zip file
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_hypercube_serialize(
            model=model,
            namespace=namespace,
            hypercube_file=hypercube_file,
            run=run,
            inex_string=inex_string,
            arguments=arguments,
            dep_tokens=dep_tokens,
            labels=labels,
            tag=tag,
            access_groups=access_groups,
            priority=priority,
            stdout_filename=stdout_filename,
            model_data=model_data,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "HypercubeToken",
            '400': "Message",
            '402': "QuotaExceeded",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_hypercube_with_http_info(
        self,
        model: Annotated[StrictStr, Field(description="Name of the model")],
        namespace: Annotated[StrictStr, Field(description="Namespace containing(or will contain) the model")],
        hypercube_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Hypercube description file")],
        run: Annotated[Optional[StrictStr], Field(description="Name of the main gms file with its extension. Will use model + '.gms' if not provided.")] = None,
        inex_string: Annotated[Optional[StrictStr], Field(description="Optional JSON string to filter the contents of the result zip file (inex_file takes precedence if specified)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        dep_tokens: Annotated[Optional[List[StrictStr]], Field(description="Tokens of jobs on which this job depends. The order defines the order in which the results of dependent jobs are extracted.")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="Labels that will be attached to the job in key=value. Currently supported labels are: cpu_request, memory_request, workspace_request, node_selectors, tolerations, instance")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Human-readable tag to assign to job (at most 255 characters)")] = None,
        access_groups: Annotated[Optional[List[StrictStr]], Field(description="Labels of user groups that should be able to access this job.")] = None,
        priority: Annotated[Optional[StrictStr], Field(description="Job priority. Only available if job priorities feature is enabled. Possible values are: low, medium, high")] = None,
        stdout_filename: Optional[StrictStr] = None,
        model_data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing model files, if model is not registered")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="File containing data in zip")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional JSON file to filter the contents of the result zip file")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HypercubeToken]:
        """Posts a Hypercube job

        If the model is a registered model, execute permission for the namespace is required. If model is a temporary model execute and write permission for the namespace is required. When the disk or volume quota reaches 80%, quota_warning is included in the response.

        :param model: Name of the model (required)
        :type model: str
        :param namespace: Namespace containing(or will contain) the model (required)
        :type namespace: str
        :param hypercube_file: Hypercube description file (required)
        :type hypercube_file: bytearray
        :param run: Name of the main gms file with its extension. Will use model + '.gms' if not provided.
        :type run: str
        :param inex_string: Optional JSON string to filter the contents of the result zip file (inex_file takes precedence if specified)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param dep_tokens: Tokens of jobs on which this job depends. The order defines the order in which the results of dependent jobs are extracted.
        :type dep_tokens: List[str]
        :param labels: Labels that will be attached to the job in key=value. Currently supported labels are: cpu_request, memory_request, workspace_request, node_selectors, tolerations, instance
        :type labels: List[str]
        :param tag: Human-readable tag to assign to job (at most 255 characters)
        :type tag: str
        :param access_groups: Labels of user groups that should be able to access this job.
        :type access_groups: List[str]
        :param priority: Job priority. Only available if job priorities feature is enabled. Possible values are: low, medium, high
        :type priority: str
        :param stdout_filename:
        :type stdout_filename: str
        :param model_data: Zip file containing model files, if model is not registered
        :type model_data: bytearray
        :param data: File containing data in zip
        :type data: bytearray
        :param inex_file: Optional JSON file to filter the contents of the result zip file
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_hypercube_serialize(
            model=model,
            namespace=namespace,
            hypercube_file=hypercube_file,
            run=run,
            inex_string=inex_string,
            arguments=arguments,
            dep_tokens=dep_tokens,
            labels=labels,
            tag=tag,
            access_groups=access_groups,
            priority=priority,
            stdout_filename=stdout_filename,
            model_data=model_data,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "HypercubeToken",
            '400': "Message",
            '402': "QuotaExceeded",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_hypercube_without_preload_content(
        self,
        model: Annotated[StrictStr, Field(description="Name of the model")],
        namespace: Annotated[StrictStr, Field(description="Namespace containing(or will contain) the model")],
        hypercube_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Hypercube description file")],
        run: Annotated[Optional[StrictStr], Field(description="Name of the main gms file with its extension. Will use model + '.gms' if not provided.")] = None,
        inex_string: Annotated[Optional[StrictStr], Field(description="Optional JSON string to filter the contents of the result zip file (inex_file takes precedence if specified)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        dep_tokens: Annotated[Optional[List[StrictStr]], Field(description="Tokens of jobs on which this job depends. The order defines the order in which the results of dependent jobs are extracted.")] = None,
        labels: Annotated[Optional[List[StrictStr]], Field(description="Labels that will be attached to the job in key=value. Currently supported labels are: cpu_request, memory_request, workspace_request, node_selectors, tolerations, instance")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="Human-readable tag to assign to job (at most 255 characters)")] = None,
        access_groups: Annotated[Optional[List[StrictStr]], Field(description="Labels of user groups that should be able to access this job.")] = None,
        priority: Annotated[Optional[StrictStr], Field(description="Job priority. Only available if job priorities feature is enabled. Possible values are: low, medium, high")] = None,
        stdout_filename: Optional[StrictStr] = None,
        model_data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing model files, if model is not registered")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="File containing data in zip")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional JSON file to filter the contents of the result zip file")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Posts a Hypercube job

        If the model is a registered model, execute permission for the namespace is required. If model is a temporary model execute and write permission for the namespace is required. When the disk or volume quota reaches 80%, quota_warning is included in the response.

        :param model: Name of the model (required)
        :type model: str
        :param namespace: Namespace containing(or will contain) the model (required)
        :type namespace: str
        :param hypercube_file: Hypercube description file (required)
        :type hypercube_file: bytearray
        :param run: Name of the main gms file with its extension. Will use model + '.gms' if not provided.
        :type run: str
        :param inex_string: Optional JSON string to filter the contents of the result zip file (inex_file takes precedence if specified)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param dep_tokens: Tokens of jobs on which this job depends. The order defines the order in which the results of dependent jobs are extracted.
        :type dep_tokens: List[str]
        :param labels: Labels that will be attached to the job in key=value. Currently supported labels are: cpu_request, memory_request, workspace_request, node_selectors, tolerations, instance
        :type labels: List[str]
        :param tag: Human-readable tag to assign to job (at most 255 characters)
        :type tag: str
        :param access_groups: Labels of user groups that should be able to access this job.
        :type access_groups: List[str]
        :param priority: Job priority. Only available if job priorities feature is enabled. Possible values are: low, medium, high
        :type priority: str
        :param stdout_filename:
        :type stdout_filename: str
        :param model_data: Zip file containing model files, if model is not registered
        :type model_data: bytearray
        :param data: File containing data in zip
        :type data: bytearray
        :param inex_file: Optional JSON file to filter the contents of the result zip file
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_hypercube_serialize(
            model=model,
            namespace=namespace,
            hypercube_file=hypercube_file,
            run=run,
            inex_string=inex_string,
            arguments=arguments,
            dep_tokens=dep_tokens,
            labels=labels,
            tag=tag,
            access_groups=access_groups,
            priority=priority,
            stdout_filename=stdout_filename,
            model_data=model_data,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "HypercubeToken",
            '400': "Message",
            '402': "QuotaExceeded",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_hypercube_serialize(
        self,
        model,
        namespace,
        hypercube_file,
        run,
        inex_string,
        arguments,
        dep_tokens,
        labels,
        tag,
        access_groups,
        priority,
        stdout_filename,
        model_data,
        data,
        inex_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'arguments': 'multi',
            'dep_tokens': 'multi',
            'labels': 'multi',
            'access_groups': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if model is not None:
            
            _query_params.append(('model', model))
            
        if run is not None:
            
            _query_params.append(('run', run))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if inex_string is not None:
            
            _query_params.append(('inex_string', inex_string))
            
        if arguments is not None:
            
            _query_params.append(('arguments', arguments))
            
        if dep_tokens is not None:
            
            _query_params.append(('dep_tokens', dep_tokens))
            
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if access_groups is not None:
            
            _query_params.append(('access_groups', access_groups))
            
        if priority is not None:
            
            _query_params.append(('priority', priority))
            
        if stdout_filename is not None:
            
            _query_params.append(('stdout_filename', stdout_filename))
            
        # process the header parameters
        # process the form parameters
        if model_data is not None:
            _files['model_data'] = model_data
        if data is not None:
            _files['data'] = data
        if inex_file is not None:
            _files['inex_file'] = inex_file
        if hypercube_file is not None:
            _files['hypercube_file'] = hypercube_file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/hypercube/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_hypercube_zip(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Deletes the results of the Hypercube job

        Job must belong to the logged in user, an invitee of the logged in user, or logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_hypercube_zip_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_hypercube_zip_with_http_info(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Deletes the results of the Hypercube job

        Job must belong to the logged in user, an invitee of the logged in user, or logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_hypercube_zip_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_hypercube_zip_without_preload_content(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes the results of the Hypercube job

        Job must belong to the logged in user, an invitee of the logged in user, or logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_hypercube_zip_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_hypercube_zip_serialize(
        self,
        hypercube_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if hypercube_token is not None:
            _path_params['hypercube_token'] = hypercube_token
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/hypercube/{hypercube_token}/result',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_hypercube_zip(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Downloads Hypercube job result

        The job must belong to the logged in user, an invitee of the logged in user, or logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_hypercube_zip_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_hypercube_zip_with_http_info(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Downloads Hypercube job result

        The job must belong to the logged in user, an invitee of the logged in user, or logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_hypercube_zip_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_hypercube_zip_without_preload_content(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Downloads Hypercube job result

        The job must belong to the logged in user, an invitee of the logged in user, or logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_hypercube_zip_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_hypercube_zip_serialize(
        self,
        hypercube_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if hypercube_token is not None:
            _path_params['hypercube_token'] = hypercube_token
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/zip'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/hypercube/{hypercube_token}/result',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_hypercube_zip_info(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Gets md5 hash and file size information of Hypercube job result

        The job must belong to the logged in user, an invitee of the logged in user, or the logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_hypercube_zip_info_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_hypercube_zip_info_with_http_info(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Gets md5 hash and file size information of Hypercube job result

        The job must belong to the logged in user, an invitee of the logged in user, or the logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_hypercube_zip_info_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_hypercube_zip_info_without_preload_content(
        self,
        hypercube_token: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets md5 hash and file size information of Hypercube job result

        The job must belong to the logged in user, an invitee of the logged in user, or the logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_hypercube_zip_info_serialize(
            hypercube_token=hypercube_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '403': None,
            '404': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_hypercube_zip_info_serialize(
        self,
        hypercube_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if hypercube_token is not None:
            _path_params['hypercube_token'] = hypercube_token
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='HEAD',
            resource_path='/hypercube/{hypercube_token}/result',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def kill_hypercube(
        self,
        hypercube_token: StrictStr,
        hard_kill: Annotated[Optional[StrictBool], Field(description="Sends SIGKILL if true, SIGINT otherwise")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Terminates the unfinished jobs that belong to a Hypercube job

        Job must belong to the logged in user, an invitee of the logged in user, or the logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param hard_kill: Sends SIGKILL if true, SIGINT otherwise
        :type hard_kill: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_hypercube_serialize(
            hypercube_token=hypercube_token,
            hard_kill=hard_kill,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def kill_hypercube_with_http_info(
        self,
        hypercube_token: StrictStr,
        hard_kill: Annotated[Optional[StrictBool], Field(description="Sends SIGKILL if true, SIGINT otherwise")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Terminates the unfinished jobs that belong to a Hypercube job

        Job must belong to the logged in user, an invitee of the logged in user, or the logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param hard_kill: Sends SIGKILL if true, SIGINT otherwise
        :type hard_kill: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_hypercube_serialize(
            hypercube_token=hypercube_token,
            hard_kill=hard_kill,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def kill_hypercube_without_preload_content(
        self,
        hypercube_token: StrictStr,
        hard_kill: Annotated[Optional[StrictBool], Field(description="Sends SIGKILL if true, SIGINT otherwise")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Terminates the unfinished jobs that belong to a Hypercube job

        Job must belong to the logged in user, an invitee of the logged in user, or the logged in user must have admin role.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param hard_kill: Sends SIGKILL if true, SIGINT otherwise
        :type hard_kill: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._kill_hypercube_serialize(
            hypercube_token=hypercube_token,
            hard_kill=hard_kill,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _kill_hypercube_serialize(
        self,
        hypercube_token,
        hard_kill,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if hypercube_token is not None:
            _path_params['hypercube_token'] = hypercube_token
        # process the query parameters
        if hard_kill is not None:
            
            _query_params.append(('hard_kill', hard_kill))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/hypercube/{hypercube_token}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_hypercubes(
        self,
        hypercube_token: Annotated[Optional[StrictStr], Field(description="Hypercube token to filter")] = None,
        everyone: Annotated[Optional[StrictBool], Field(description="Can be set by admin/inviter; shows Hypercube submissions of everyone/invitees")] = None,
        page: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=1)]] = None,
        per_page: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None,
        x_fields: Optional[StrictStr] = None,
        order_by: Optional[StrictStr] = None,
        order_asc: Optional[StrictBool] = None,
        show_only_active: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HypercubePage:
        """Lists the Hypercube jobs sent by the user unless `everyone` flag is set

        If user has admin role and `everyone` flag is set, all Hypercube jobs are listed. If user is not inviter or admin and `everyone` flag is set, all visible Hypercube jobs (Hypercube jobs that were assigned to a user group that user is member of) are listed. If user is inviter and 'everyone' flag is set, Hypercube jobs of all invitees will be listed additionally.  If `page` is not one and there are no elements at that page, throws 404. Due to performance issues the fields `result_exists`, `dep_tokens`, `labels` and `access_groups` are only provided for queries for a single Hypercube job.  If `show_only_active` flag is set it only shows hypercube jobs that are not finished. `labels.resource_warning`, `labels.instance`, `labels.multiplier`, `access_groups` and `tag` fields are hidden by default for compatibility reasons, please use X-Fields header to get it. For example: X-Fields: \\*, labels{\\*}

        :param hypercube_token: Hypercube token to filter
        :type hypercube_token: UUID
        :param everyone: Can be set by admin/inviter; shows Hypercube submissions of everyone/invitees
        :type everyone: bool
        :param page:
        :type page: int
        :param per_page:
        :type per_page: int
        :param x_fields:
        :type x_fields: str
        :param order_by:
        :type order_by: str
        :param order_asc:
        :type order_asc: bool
        :param show_only_active:
        :type show_only_active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_hypercubes_serialize(
            hypercube_token=hypercube_token,
            everyone=everyone,
            page=page,
            per_page=per_page,
            x_fields=x_fields,
            order_by=order_by,
            order_asc=order_asc,
            show_only_active=show_only_active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HypercubePage",
            '400': "Message",
            '403': "Message",
            '404': None,
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_hypercubes_with_http_info(
        self,
        hypercube_token: Annotated[Optional[StrictStr], Field(description="Hypercube token to filter")] = None,
        everyone: Annotated[Optional[StrictBool], Field(description="Can be set by admin/inviter; shows Hypercube submissions of everyone/invitees")] = None,
        page: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=1)]] = None,
        per_page: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None,
        x_fields: Optional[StrictStr] = None,
        order_by: Optional[StrictStr] = None,
        order_asc: Optional[StrictBool] = None,
        show_only_active: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HypercubePage]:
        """Lists the Hypercube jobs sent by the user unless `everyone` flag is set

        If user has admin role and `everyone` flag is set, all Hypercube jobs are listed. If user is not inviter or admin and `everyone` flag is set, all visible Hypercube jobs (Hypercube jobs that were assigned to a user group that user is member of) are listed. If user is inviter and 'everyone' flag is set, Hypercube jobs of all invitees will be listed additionally.  If `page` is not one and there are no elements at that page, throws 404. Due to performance issues the fields `result_exists`, `dep_tokens`, `labels` and `access_groups` are only provided for queries for a single Hypercube job.  If `show_only_active` flag is set it only shows hypercube jobs that are not finished. `labels.resource_warning`, `labels.instance`, `labels.multiplier`, `access_groups` and `tag` fields are hidden by default for compatibility reasons, please use X-Fields header to get it. For example: X-Fields: \\*, labels{\\*}

        :param hypercube_token: Hypercube token to filter
        :type hypercube_token: UUID
        :param everyone: Can be set by admin/inviter; shows Hypercube submissions of everyone/invitees
        :type everyone: bool
        :param page:
        :type page: int
        :param per_page:
        :type per_page: int
        :param x_fields:
        :type x_fields: str
        :param order_by:
        :type order_by: str
        :param order_asc:
        :type order_asc: bool
        :param show_only_active:
        :type show_only_active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_hypercubes_serialize(
            hypercube_token=hypercube_token,
            everyone=everyone,
            page=page,
            per_page=per_page,
            x_fields=x_fields,
            order_by=order_by,
            order_asc=order_asc,
            show_only_active=show_only_active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HypercubePage",
            '400': "Message",
            '403': "Message",
            '404': None,
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_hypercubes_without_preload_content(
        self,
        hypercube_token: Annotated[Optional[StrictStr], Field(description="Hypercube token to filter")] = None,
        everyone: Annotated[Optional[StrictBool], Field(description="Can be set by admin/inviter; shows Hypercube submissions of everyone/invitees")] = None,
        page: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=1)]] = None,
        per_page: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None,
        x_fields: Optional[StrictStr] = None,
        order_by: Optional[StrictStr] = None,
        order_asc: Optional[StrictBool] = None,
        show_only_active: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists the Hypercube jobs sent by the user unless `everyone` flag is set

        If user has admin role and `everyone` flag is set, all Hypercube jobs are listed. If user is not inviter or admin and `everyone` flag is set, all visible Hypercube jobs (Hypercube jobs that were assigned to a user group that user is member of) are listed. If user is inviter and 'everyone' flag is set, Hypercube jobs of all invitees will be listed additionally.  If `page` is not one and there are no elements at that page, throws 404. Due to performance issues the fields `result_exists`, `dep_tokens`, `labels` and `access_groups` are only provided for queries for a single Hypercube job.  If `show_only_active` flag is set it only shows hypercube jobs that are not finished. `labels.resource_warning`, `labels.instance`, `labels.multiplier`, `access_groups` and `tag` fields are hidden by default for compatibility reasons, please use X-Fields header to get it. For example: X-Fields: \\*, labels{\\*}

        :param hypercube_token: Hypercube token to filter
        :type hypercube_token: UUID
        :param everyone: Can be set by admin/inviter; shows Hypercube submissions of everyone/invitees
        :type everyone: bool
        :param page:
        :type page: int
        :param per_page:
        :type per_page: int
        :param x_fields:
        :type x_fields: str
        :param order_by:
        :type order_by: str
        :param order_asc:
        :type order_asc: bool
        :param show_only_active:
        :type show_only_active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_hypercubes_serialize(
            hypercube_token=hypercube_token,
            everyone=everyone,
            page=page,
            per_page=per_page,
            x_fields=x_fields,
            order_by=order_by,
            order_asc=order_asc,
            show_only_active=show_only_active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HypercubePage",
            '400': "Message",
            '403': "Message",
            '404': None,
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_hypercubes_serialize(
        self,
        hypercube_token,
        everyone,
        page,
        per_page,
        x_fields,
        order_by,
        order_asc,
        show_only_active,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if hypercube_token is not None:
            
            _query_params.append(('hypercube_token', hypercube_token))
            
        if everyone is not None:
            
            _query_params.append(('everyone', everyone))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if per_page is not None:
            
            _query_params.append(('per_page', per_page))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if order_asc is not None:
            
            _query_params.append(('order_asc', order_asc))
            
        if show_only_active is not None:
            
            _query_params.append(('show_only_active', show_only_active))
            
        # process the header parameters
        if x_fields is not None:
            _header_params['X-Fields'] = x_fields
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/hypercube/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_hypercube_access_groups(
        self,
        hypercube_token: StrictStr,
        access_groups: Annotated[Optional[List[StrictStr]], Field(description="Labels of user groups that should be able to access this job.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Update access groups that can access a Hypercube job

        Can be queried via listHypercubes endpoint.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param access_groups: Labels of user groups that should be able to access this job.
        :type access_groups: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_hypercube_access_groups_serialize(
            hypercube_token=hypercube_token,
            access_groups=access_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_hypercube_access_groups_with_http_info(
        self,
        hypercube_token: StrictStr,
        access_groups: Annotated[Optional[List[StrictStr]], Field(description="Labels of user groups that should be able to access this job.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Update access groups that can access a Hypercube job

        Can be queried via listHypercubes endpoint.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param access_groups: Labels of user groups that should be able to access this job.
        :type access_groups: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_hypercube_access_groups_serialize(
            hypercube_token=hypercube_token,
            access_groups=access_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_hypercube_access_groups_without_preload_content(
        self,
        hypercube_token: StrictStr,
        access_groups: Annotated[Optional[List[StrictStr]], Field(description="Labels of user groups that should be able to access this job.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update access groups that can access a Hypercube job

        Can be queried via listHypercubes endpoint.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param access_groups: Labels of user groups that should be able to access this job.
        :type access_groups: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_hypercube_access_groups_serialize(
            hypercube_token=hypercube_token,
            access_groups=access_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_hypercube_access_groups_serialize(
        self,
        hypercube_token,
        access_groups,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'access_groups': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if hypercube_token is not None:
            _path_params['hypercube_token'] = hypercube_token
        # process the query parameters
        if access_groups is not None:
            
            _query_params.append(('access_groups', access_groups))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/hypercube/{hypercube_token}/access-groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_hypercube_tag(
        self,
        hypercube_token: StrictStr,
        tag: Annotated[str, Field(strict=True, description="Human-readable tag to assign to job (at most 255 characters)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Update human-readable tag of a Hypercube job

        Stored in `tag` field. Can be queried via listHypercubes endpoint.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param tag: Human-readable tag to assign to job (at most 255 characters) (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_hypercube_tag_serialize(
            hypercube_token=hypercube_token,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_hypercube_tag_with_http_info(
        self,
        hypercube_token: StrictStr,
        tag: Annotated[str, Field(strict=True, description="Human-readable tag to assign to job (at most 255 characters)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Update human-readable tag of a Hypercube job

        Stored in `tag` field. Can be queried via listHypercubes endpoint.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param tag: Human-readable tag to assign to job (at most 255 characters) (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_hypercube_tag_serialize(
            hypercube_token=hypercube_token,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_hypercube_tag_without_preload_content(
        self,
        hypercube_token: StrictStr,
        tag: Annotated[str, Field(strict=True, description="Human-readable tag to assign to job (at most 255 characters)")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update human-readable tag of a Hypercube job

        Stored in `tag` field. Can be queried via listHypercubes endpoint.

        :param hypercube_token: (required)
        :type hypercube_token: str
        :param tag: Human-readable tag to assign to job (at most 255 characters) (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_hypercube_tag_serialize(
            hypercube_token=hypercube_token,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '401': "Message",
            '403': "Message",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_hypercube_tag_serialize(
        self,
        hypercube_token,
        tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if hypercube_token is not None:
            _path_params['hypercube_token'] = hypercube_token
        # process the query parameters
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/hypercube/{hypercube_token}/tag',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


