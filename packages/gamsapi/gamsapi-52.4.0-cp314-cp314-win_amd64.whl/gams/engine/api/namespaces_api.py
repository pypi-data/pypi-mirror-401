# coding: utf-8

"""
    GAMS Engine

    With GAMS Engine you can register and solve GAMS models. It has a namespace management system, so you can restrict your users to certain models.

    The version of the OpenAPI document: latest
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from gams.engine.models.message import Message
from gams.engine.models.models import Models
from gams.engine.models.namespace import Namespace
from gams.engine.models.namespace_quota import NamespaceQuota
from gams.engine.models.namespace_with_permission import NamespaceWithPermission
from gams.engine.models.perm_and_username import PermAndUsername
from gams.engine.models.user_groups import UserGroups

from gams.engine.api_client import ApiClient, RequestSerialized
from gams.engine.api_response import ApiResponse
from gams.engine.rest import RESTResponseType


class NamespacesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_user_to_group(
        self,
        namespace: StrictStr,
        label: StrictStr,
        username: Annotated[StrictStr, Field(description="Username to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Adds a user to a group

        Inviters can add any invitees to a group they are a member of or that belongs to an invitee. Admins can add anyone to any group.

        :param namespace: (required)
        :type namespace: str
        :param label: (required)
        :type label: str
        :param username: Username to add (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_user_to_group_serialize(
            namespace=namespace,
            label=label,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_user_to_group_with_http_info(
        self,
        namespace: StrictStr,
        label: StrictStr,
        username: Annotated[StrictStr, Field(description="Username to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Adds a user to a group

        Inviters can add any invitees to a group they are a member of or that belongs to an invitee. Admins can add anyone to any group.

        :param namespace: (required)
        :type namespace: str
        :param label: (required)
        :type label: str
        :param username: Username to add (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_user_to_group_serialize(
            namespace=namespace,
            label=label,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_user_to_group_without_preload_content(
        self,
        namespace: StrictStr,
        label: StrictStr,
        username: Annotated[StrictStr, Field(description="Username to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Adds a user to a group

        Inviters can add any invitees to a group they are a member of or that belongs to an invitee. Admins can add anyone to any group.

        :param namespace: (required)
        :type namespace: str
        :param label: (required)
        :type label: str
        :param username: Username to add (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_user_to_group_serialize(
            namespace=namespace,
            label=label,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_user_to_group_serialize(
        self,
        namespace,
        label,
        username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if label is not None:
            _path_params['label'] = label
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if username is not None:
            _form_params.append(('username', username))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/namespaces/{namespace}/user-groups/{label}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_model(
        self,
        namespace: StrictStr,
        model: StrictStr,
        data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Zip file containing files of model")],
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Registers a new model in the given namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param data: Zip file containing files of model (required)
        :type data: bytearray
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_model_serialize(
            namespace=namespace,
            model=model,
            data=data,
            inex_string=inex_string,
            arguments=arguments,
            text_entries=text_entries,
            stream_entries=stream_entries,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '402': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_model_with_http_info(
        self,
        namespace: StrictStr,
        model: StrictStr,
        data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Zip file containing files of model")],
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Registers a new model in the given namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param data: Zip file containing files of model (required)
        :type data: bytearray
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_model_serialize(
            namespace=namespace,
            model=model,
            data=data,
            inex_string=inex_string,
            arguments=arguments,
            text_entries=text_entries,
            stream_entries=stream_entries,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '402': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_model_without_preload_content(
        self,
        namespace: StrictStr,
        model: StrictStr,
        data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Zip file containing files of model")],
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Registers a new model in the given namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param data: Zip file containing files of model (required)
        :type data: bytearray
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_model_serialize(
            namespace=namespace,
            model=model,
            data=data,
            inex_string=inex_string,
            arguments=arguments,
            text_entries=text_entries,
            stream_entries=stream_entries,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '402': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_model_serialize(
        self,
        namespace,
        model,
        data,
        inex_string,
        arguments,
        text_entries,
        stream_entries,
        run,
        protect_model_files,
        user_groups,
        inex_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'arguments': 'multi',
            'text_entries': 'multi',
            'stream_entries': 'multi',
            'user_groups': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if model is not None:
            _path_params['model'] = model
        # process the query parameters
        if inex_string is not None:
            
            _query_params.append(('inex_string', inex_string))
            
        if arguments is not None:
            
            _query_params.append(('arguments', arguments))
            
        if text_entries is not None:
            
            _query_params.append(('text_entries', text_entries))
            
        if stream_entries is not None:
            
            _query_params.append(('stream_entries', stream_entries))
            
        if run is not None:
            
            _query_params.append(('run', run))
            
        if protect_model_files is not None:
            
            _query_params.append(('protect_model_files', protect_model_files))
            
        if user_groups is not None:
            
            _query_params.append(('user_groups', user_groups))
            
        # process the header parameters
        # process the form parameters
        if data is not None:
            _files['data'] = data
        if inex_file is not None:
            _files['inex_file'] = inex_file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/namespaces/{namespace}/models/{model}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_model_deprecated(
        self,
        namespace: StrictStr,
        model: StrictStr,
        data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Zip file containing files of model")],
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """(Deprecated) Registers a new model in the given namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param data: Zip file containing files of model (required)
        :type data: bytearray
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._create_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            data=data,
            inex_string=inex_string,
            arguments=arguments,
            text_entries=text_entries,
            stream_entries=stream_entries,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '402': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_model_deprecated_with_http_info(
        self,
        namespace: StrictStr,
        model: StrictStr,
        data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Zip file containing files of model")],
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """(Deprecated) Registers a new model in the given namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param data: Zip file containing files of model (required)
        :type data: bytearray
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._create_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            data=data,
            inex_string=inex_string,
            arguments=arguments,
            text_entries=text_entries,
            stream_entries=stream_entries,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '402': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_model_deprecated_without_preload_content(
        self,
        namespace: StrictStr,
        model: StrictStr,
        data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="Zip file containing files of model")],
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Registers a new model in the given namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param data: Zip file containing files of model (required)
        :type data: bytearray
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._create_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            data=data,
            inex_string=inex_string,
            arguments=arguments,
            text_entries=text_entries,
            stream_entries=stream_entries,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '402': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_model_deprecated_serialize(
        self,
        namespace,
        model,
        data,
        inex_string,
        arguments,
        text_entries,
        stream_entries,
        run,
        protect_model_files,
        user_groups,
        inex_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'arguments': 'multi',
            'text_entries': 'multi',
            'stream_entries': 'multi',
            'user_groups': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if model is not None:
            _path_params['model'] = model
        # process the query parameters
        if inex_string is not None:
            
            _query_params.append(('inex_string', inex_string))
            
        if arguments is not None:
            
            _query_params.append(('arguments', arguments))
            
        if text_entries is not None:
            
            _query_params.append(('text_entries', text_entries))
            
        if stream_entries is not None:
            
            _query_params.append(('stream_entries', stream_entries))
            
        if run is not None:
            
            _query_params.append(('run', run))
            
        if protect_model_files is not None:
            
            _query_params.append(('protect_model_files', protect_model_files))
            
        if user_groups is not None:
            
            _query_params.append(('user_groups', user_groups))
            
        # process the header parameters
        # process the form parameters
        if data is not None:
            _files['data'] = data
        if inex_file is not None:
            _files['inex_file'] = inex_file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/namespaces/{namespace}/{model}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_namespace(
        self,
        namespace: StrictStr,
        disk_quota: Annotated[Optional[Annotated[int, Field(strict=True, gt=0)]], Field(description="disk quota in bytes")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Creates a namespace

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param disk_quota: disk quota in bytes
        :type disk_quota: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_namespace_serialize(
            namespace=namespace,
            disk_quota=disk_quota,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_namespace_with_http_info(
        self,
        namespace: StrictStr,
        disk_quota: Annotated[Optional[Annotated[int, Field(strict=True, gt=0)]], Field(description="disk quota in bytes")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Creates a namespace

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param disk_quota: disk quota in bytes
        :type disk_quota: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_namespace_serialize(
            namespace=namespace,
            disk_quota=disk_quota,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_namespace_without_preload_content(
        self,
        namespace: StrictStr,
        disk_quota: Annotated[Optional[Annotated[int, Field(strict=True, gt=0)]], Field(description="disk quota in bytes")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a namespace

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param disk_quota: disk quota in bytes
        :type disk_quota: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_namespace_serialize(
            namespace=namespace,
            disk_quota=disk_quota,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_namespace_serialize(
        self,
        namespace,
        disk_quota,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if disk_quota is not None:
            _form_params.append(('disk_quota', disk_quota))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/namespaces/{namespace}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_user_group(
        self,
        namespace: StrictStr,
        label: Annotated[str, Field(strict=True, description="Group label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Creates a new user group

        Requires admin role or inviter role with write permissions on the namespace.

        :param namespace: (required)
        :type namespace: str
        :param label: Group label (required)
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_group_serialize(
            namespace=namespace,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_user_group_with_http_info(
        self,
        namespace: StrictStr,
        label: Annotated[str, Field(strict=True, description="Group label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Creates a new user group

        Requires admin role or inviter role with write permissions on the namespace.

        :param namespace: (required)
        :type namespace: str
        :param label: Group label (required)
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_group_serialize(
            namespace=namespace,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_user_group_without_preload_content(
        self,
        namespace: StrictStr,
        label: Annotated[str, Field(strict=True, description="Group label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a new user group

        Requires admin role or inviter role with write permissions on the namespace.

        :param namespace: (required)
        :type namespace: str
        :param label: Group label (required)
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_group_serialize(
            namespace=namespace,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_user_group_serialize(
        self,
        namespace,
        label,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if label is not None:
            _form_params.append(('label', label))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/namespaces/{namespace}/user-groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_model(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Deletes a model registered in the namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_model_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_model_with_http_info(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Deletes a model registered in the namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_model_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_model_without_preload_content(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes a model registered in the namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_model_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_model_serialize(
        self,
        namespace,
        model,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if model is not None:
            _path_params['model'] = model
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/namespaces/{namespace}/models/{model}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_model_deprecated(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """(Deprecated) Deletes a model registered in the namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._delete_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_model_deprecated_with_http_info(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """(Deprecated) Deletes a model registered in the namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._delete_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_model_deprecated_without_preload_content(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Deletes a model registered in the namespace

        Requires write permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._delete_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_model_deprecated_serialize(
        self,
        namespace,
        model,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if model is not None:
            _path_params['model'] = model
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/namespaces/{namespace}/{model}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_namespace(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Deletes a namespace

        Models, permissions and results assigned to this namespace are deleted. If jobs are running in this namespace, they are aborted. Requires admin role.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_namespace_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_namespace_with_http_info(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Deletes a namespace

        Models, permissions and results assigned to this namespace are deleted. If jobs are running in this namespace, they are aborted. Requires admin role.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_namespace_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_namespace_without_preload_content(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes a namespace

        Models, permissions and results assigned to this namespace are deleted. If jobs are running in this namespace, they are aborted. Requires admin role.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_namespace_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_namespace_serialize(
        self,
        namespace,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/namespaces/{namespace}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_namespace_quota(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Deletes namespace disk quota

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_namespace_quota_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_namespace_quota_with_http_info(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Deletes namespace disk quota

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_namespace_quota_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_namespace_quota_without_preload_content(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes namespace disk quota

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_namespace_quota_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_namespace_quota_serialize(
        self,
        namespace,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/namespaces/{namespace}/disk-quota',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_user_group(
        self,
        namespace: StrictStr,
        label: Annotated[str, Field(strict=True, description="Group label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Deletes a user group

        Inviters with write permission to the namespace can delete their own groups as well as the groups of any invitees. Admins can delete any group.

        :param namespace: (required)
        :type namespace: str
        :param label: Group label (required)
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_group_serialize(
            namespace=namespace,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_user_group_with_http_info(
        self,
        namespace: StrictStr,
        label: Annotated[str, Field(strict=True, description="Group label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Deletes a user group

        Inviters with write permission to the namespace can delete their own groups as well as the groups of any invitees. Admins can delete any group.

        :param namespace: (required)
        :type namespace: str
        :param label: Group label (required)
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_group_serialize(
            namespace=namespace,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_user_group_without_preload_content(
        self,
        namespace: StrictStr,
        label: Annotated[str, Field(strict=True, description="Group label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deletes a user group

        Inviters with write permission to the namespace can delete their own groups as well as the groups of any invitees. Admins can delete any group.

        :param namespace: (required)
        :type namespace: str
        :param label: Group label (required)
        :type label: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_group_serialize(
            namespace=namespace,
            label=label,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_user_group_serialize(
        self,
        namespace,
        label,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        if label is not None:
            
            _query_params.append(('label', label))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/namespaces/{namespace}/user-groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_accessible_namespaces(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[NamespaceWithPermission]:
        """(Deprecated) Lists the namespaces where the user has a non-zero permission, along with that `permission` and `disk_quota`

        If the user does not have write permission, then the `disk_quota` is None. If the user has write permission but `disk_quota` is still None, it means namespace does not have any disk quota.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/permissions/me is deprecated.", DeprecationWarning)

        _param = self._get_accessible_namespaces_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NamespaceWithPermission]",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_accessible_namespaces_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[NamespaceWithPermission]]:
        """(Deprecated) Lists the namespaces where the user has a non-zero permission, along with that `permission` and `disk_quota`

        If the user does not have write permission, then the `disk_quota` is None. If the user has write permission but `disk_quota` is still None, it means namespace does not have any disk quota.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/permissions/me is deprecated.", DeprecationWarning)

        _param = self._get_accessible_namespaces_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NamespaceWithPermission]",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_accessible_namespaces_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Lists the namespaces where the user has a non-zero permission, along with that `permission` and `disk_quota`

        If the user does not have write permission, then the `disk_quota` is None. If the user has write permission but `disk_quota` is still None, it means namespace does not have any disk quota.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/permissions/me is deprecated.", DeprecationWarning)

        _param = self._get_accessible_namespaces_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NamespaceWithPermission]",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_accessible_namespaces_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/permissions/me',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_model(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Downloads model data

        Requires read permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_model_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_model_with_http_info(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Downloads model data

        Requires read permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_model_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_model_without_preload_content(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Downloads model data

        Requires read permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_model_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_model_serialize(
        self,
        namespace,
        model,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if model is not None:
            _path_params['model'] = model
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/{namespace}/models/{model}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_model_deprecated(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """(Deprecated) Downloads model data

        Requires read permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._get_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_model_deprecated_with_http_info(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """(Deprecated) Downloads model data

        Requires read permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._get_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_model_deprecated_without_preload_content(
        self,
        namespace: StrictStr,
        model: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Downloads model data

        Requires read permission.

        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._get_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_model_deprecated_serialize(
        self,
        namespace,
        model,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if model is not None:
            _path_params['model'] = model
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/{namespace}/{model}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_my_permissions(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PermAndUsername:
        """(Deprecated) Returns the permissions of the logged in user in the given namespace

        If user has admin role, it always returns 7.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/{namespace}/permissions/me is deprecated.", DeprecationWarning)

        _param = self._get_my_permissions_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PermAndUsername",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_my_permissions_with_http_info(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PermAndUsername]:
        """(Deprecated) Returns the permissions of the logged in user in the given namespace

        If user has admin role, it always returns 7.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/{namespace}/permissions/me is deprecated.", DeprecationWarning)

        _param = self._get_my_permissions_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PermAndUsername",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_my_permissions_without_preload_content(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Returns the permissions of the logged in user in the given namespace

        If user has admin role, it always returns 7.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /namespaces/{namespace}/permissions/me is deprecated.", DeprecationWarning)

        _param = self._get_my_permissions_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PermAndUsername",
            '404': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_my_permissions_serialize(
        self,
        namespace,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/{namespace}/permissions/me',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_namespace_quota(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NamespaceQuota:
        """Displays namespace disk quota

        Requires write permission

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_namespace_quota_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NamespaceQuota",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_namespace_quota_with_http_info(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NamespaceQuota]:
        """Displays namespace disk quota

        Requires write permission

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_namespace_quota_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NamespaceQuota",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_namespace_quota_without_preload_content(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Displays namespace disk quota

        Requires write permission

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_namespace_quota_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NamespaceQuota",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_namespace_quota_serialize(
        self,
        namespace,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/{namespace}/disk-quota',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_user_groups(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[UserGroups]:
        """Fetches user groups

        If user, fetches groups in which the user is a member. If inviter, fetches groups the inviter is a member of, as well as all groups of invitees. If admin, fetches all groups.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_groups_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserGroups]",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_user_groups_with_http_info(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[UserGroups]]:
        """Fetches user groups

        If user, fetches groups in which the user is a member. If inviter, fetches groups the inviter is a member of, as well as all groups of invitees. If admin, fetches all groups.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_groups_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserGroups]",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_user_groups_without_preload_content(
        self,
        namespace: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fetches user groups

        If user, fetches groups in which the user is a member. If inviter, fetches groups the inviter is a member of, as well as all groups of invitees. If admin, fetches all groups.

        :param namespace: (required)
        :type namespace: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_groups_serialize(
            namespace=namespace,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserGroups]",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_user_groups_serialize(
        self,
        namespace,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/{namespace}/user-groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_user_permission(
        self,
        namespace: StrictStr,
        username: Annotated[StrictStr, Field(description="Username")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PermAndUsername:
        """Gets permissions of the given user for the given namespace

        Admins can query all users, inviters can only query the invitees. Users can query themselves.

        :param namespace: (required)
        :type namespace: str
        :param username: Username (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_permission_serialize(
            namespace=namespace,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PermAndUsername",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_user_permission_with_http_info(
        self,
        namespace: StrictStr,
        username: Annotated[StrictStr, Field(description="Username")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PermAndUsername]:
        """Gets permissions of the given user for the given namespace

        Admins can query all users, inviters can only query the invitees. Users can query themselves.

        :param namespace: (required)
        :type namespace: str
        :param username: Username (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_permission_serialize(
            namespace=namespace,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PermAndUsername",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_user_permission_without_preload_content(
        self,
        namespace: StrictStr,
        username: Annotated[StrictStr, Field(description="Username")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets permissions of the given user for the given namespace

        Admins can query all users, inviters can only query the invitees. Users can query themselves.

        :param namespace: (required)
        :type namespace: str
        :param username: Username (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_permission_serialize(
            namespace=namespace,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PermAndUsername",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_user_permission_serialize(
        self,
        namespace,
        username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        if username is not None:
            
            _query_params.append(('username', username))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/{namespace}/permissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_models(
        self,
        namespace: StrictStr,
        x_fields: Optional[StrictStr] = None,
        model: Annotated[Optional[StrictStr], Field(description="Name of the model to filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Models]:
        """Lists the models in a namespace

        If the model argument is specified, the information about this model is displayed only if the model is registered in the namespace. Models that are not assigned to a user group are visible to anyone with any permission (read, write, and/or execute) in the namespace. Models assigned to one or more user groups are only visible if the user can see any of these user groups. `protect_model_files` field is hidden by default for compatibility reasons, please use X-Fields header to get it. For example: X-Fields: \\*

        :param namespace: (required)
        :type namespace: str
        :param x_fields:
        :type x_fields: str
        :param model: Name of the model to filter
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_models_serialize(
            namespace=namespace,
            x_fields=x_fields,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Models]",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_models_with_http_info(
        self,
        namespace: StrictStr,
        x_fields: Optional[StrictStr] = None,
        model: Annotated[Optional[StrictStr], Field(description="Name of the model to filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Models]]:
        """Lists the models in a namespace

        If the model argument is specified, the information about this model is displayed only if the model is registered in the namespace. Models that are not assigned to a user group are visible to anyone with any permission (read, write, and/or execute) in the namespace. Models assigned to one or more user groups are only visible if the user can see any of these user groups. `protect_model_files` field is hidden by default for compatibility reasons, please use X-Fields header to get it. For example: X-Fields: \\*

        :param namespace: (required)
        :type namespace: str
        :param x_fields:
        :type x_fields: str
        :param model: Name of the model to filter
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_models_serialize(
            namespace=namespace,
            x_fields=x_fields,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Models]",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_models_without_preload_content(
        self,
        namespace: StrictStr,
        x_fields: Optional[StrictStr] = None,
        model: Annotated[Optional[StrictStr], Field(description="Name of the model to filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists the models in a namespace

        If the model argument is specified, the information about this model is displayed only if the model is registered in the namespace. Models that are not assigned to a user group are visible to anyone with any permission (read, write, and/or execute) in the namespace. Models assigned to one or more user groups are only visible if the user can see any of these user groups. `protect_model_files` field is hidden by default for compatibility reasons, please use X-Fields header to get it. For example: X-Fields: \\*

        :param namespace: (required)
        :type namespace: str
        :param x_fields:
        :type x_fields: str
        :param model: Name of the model to filter
        :type model: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_models_serialize(
            namespace=namespace,
            x_fields=x_fields,
            model=model,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Models]",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_models_serialize(
        self,
        namespace,
        x_fields,
        model,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        if model is not None:
            
            _query_params.append(('model', model))
            
        # process the header parameters
        if x_fields is not None:
            _header_params['X-Fields'] = x_fields
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/{namespace}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_namespaces(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Namespace]:
        """Lists the namespaces

        You must have some permission on namespace to see it. Admins can see every namespace and every permission. Inviters can see namespaces for which they have permission, as well as the permissions of invitees. Users can see namespaces in which they have permissions, as well as the permissions for themselves.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_namespaces_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Namespace]",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_namespaces_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Namespace]]:
        """Lists the namespaces

        You must have some permission on namespace to see it. Admins can see every namespace and every permission. Inviters can see namespaces for which they have permission, as well as the permissions of invitees. Users can see namespaces in which they have permissions, as well as the permissions for themselves.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_namespaces_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Namespace]",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_namespaces_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists the namespaces

        You must have some permission on namespace to see it. Admins can see every namespace and every permission. Inviters can see namespaces for which they have permission, as well as the permissions of invitees. Users can see namespaces in which they have permissions, as well as the permissions for themselves.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_namespaces_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Namespace]",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_namespaces_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/namespaces/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_user_from_group(
        self,
        namespace: StrictStr,
        label: StrictStr,
        username: Annotated[StrictStr, Field(description="Username to remove")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Removes a user from a group

        Inviters can remove any invitees from a group they are a member of or that belongs to an invitee. Admins can remove anyone from any group.

        :param namespace: (required)
        :type namespace: str
        :param label: (required)
        :type label: str
        :param username: Username to remove (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_user_from_group_serialize(
            namespace=namespace,
            label=label,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_user_from_group_with_http_info(
        self,
        namespace: StrictStr,
        label: StrictStr,
        username: Annotated[StrictStr, Field(description="Username to remove")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Removes a user from a group

        Inviters can remove any invitees from a group they are a member of or that belongs to an invitee. Admins can remove anyone from any group.

        :param namespace: (required)
        :type namespace: str
        :param label: (required)
        :type label: str
        :param username: Username to remove (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_user_from_group_serialize(
            namespace=namespace,
            label=label,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_user_from_group_without_preload_content(
        self,
        namespace: StrictStr,
        label: StrictStr,
        username: Annotated[StrictStr, Field(description="Username to remove")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Removes a user from a group

        Inviters can remove any invitees from a group they are a member of or that belongs to an invitee. Admins can remove anyone from any group.

        :param namespace: (required)
        :type namespace: str
        :param label: (required)
        :type label: str
        :param username: Username to remove (required)
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_user_from_group_serialize(
            namespace=namespace,
            label=label,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '401': None,
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_user_from_group_serialize(
        self,
        namespace,
        label,
        username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if label is not None:
            _path_params['label'] = label
        # process the query parameters
        if username is not None:
            
            _query_params.append(('username', username))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/namespaces/{namespace}/user-groups/{label}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def replace_user_permission(
        self,
        namespace: StrictStr,
        username: Annotated[StrictStr, Field(description="Username")],
        permissions: Annotated[int, Field(le=7, strict=True, ge=0, description="4 - Read access to namespace 2 - Write access to namespace(delete, update, create) 1 - Execute model access to namespace  Sum to calculate permission")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Sets permissions of the given user for the given namespace

        Admins can grant all permissions, inviting persons can only grant the permissions they have. Requires admin or inviter role.

        :param namespace: (required)
        :type namespace: str
        :param username: Username (required)
        :type username: str
        :param permissions: 4 - Read access to namespace 2 - Write access to namespace(delete, update, create) 1 - Execute model access to namespace  Sum to calculate permission (required)
        :type permissions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_user_permission_serialize(
            namespace=namespace,
            username=username,
            permissions=permissions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replace_user_permission_with_http_info(
        self,
        namespace: StrictStr,
        username: Annotated[StrictStr, Field(description="Username")],
        permissions: Annotated[int, Field(le=7, strict=True, ge=0, description="4 - Read access to namespace 2 - Write access to namespace(delete, update, create) 1 - Execute model access to namespace  Sum to calculate permission")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Sets permissions of the given user for the given namespace

        Admins can grant all permissions, inviting persons can only grant the permissions they have. Requires admin or inviter role.

        :param namespace: (required)
        :type namespace: str
        :param username: Username (required)
        :type username: str
        :param permissions: 4 - Read access to namespace 2 - Write access to namespace(delete, update, create) 1 - Execute model access to namespace  Sum to calculate permission (required)
        :type permissions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_user_permission_serialize(
            namespace=namespace,
            username=username,
            permissions=permissions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def replace_user_permission_without_preload_content(
        self,
        namespace: StrictStr,
        username: Annotated[StrictStr, Field(description="Username")],
        permissions: Annotated[int, Field(le=7, strict=True, ge=0, description="4 - Read access to namespace 2 - Write access to namespace(delete, update, create) 1 - Execute model access to namespace  Sum to calculate permission")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sets permissions of the given user for the given namespace

        Admins can grant all permissions, inviting persons can only grant the permissions they have. Requires admin or inviter role.

        :param namespace: (required)
        :type namespace: str
        :param username: Username (required)
        :type username: str
        :param permissions: 4 - Read access to namespace 2 - Write access to namespace(delete, update, create) 1 - Execute model access to namespace  Sum to calculate permission (required)
        :type permissions: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._replace_user_permission_serialize(
            namespace=namespace,
            username=username,
            permissions=permissions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _replace_user_permission_serialize(
        self,
        namespace,
        username,
        permissions,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if username is not None:
            _form_params.append(('username', username))
        if permissions is not None:
            _form_params.append(('permissions', permissions))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/namespaces/{namespace}/permissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_model(
        self,
        namespace: StrictStr,
        model: StrictStr,
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        delete_inex_file: Annotated[Optional[StrictBool], Field(description="If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file")] = None,
        delete_arguments: Annotated[Optional[StrictBool], Field(description="If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments")] = None,
        delete_run: Annotated[Optional[StrictBool], Field(description="If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename")] = None,
        delete_user_groups: Annotated[Optional[StrictBool], Field(description="If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups")] = None,
        delete_text_entries: Annotated[Optional[StrictBool], Field(description="If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries")] = None,
        delete_stream_entries: Annotated[Optional[StrictBool], Field(description="If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing files of model")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Partially update registered models


        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param delete_inex_file: If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file
        :type delete_inex_file: bool
        :param delete_arguments: If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments
        :type delete_arguments: bool
        :param delete_run: If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename
        :type delete_run: bool
        :param delete_user_groups: If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups
        :type delete_user_groups: bool
        :param delete_text_entries: If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries
        :type delete_text_entries: bool
        :param delete_stream_entries: If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries
        :type delete_stream_entries: bool
        :param data: Zip file containing files of model
        :type data: bytearray
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_model_serialize(
            namespace=namespace,
            model=model,
            inex_string=inex_string,
            arguments=arguments,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            text_entries=text_entries,
            stream_entries=stream_entries,
            delete_inex_file=delete_inex_file,
            delete_arguments=delete_arguments,
            delete_run=delete_run,
            delete_user_groups=delete_user_groups,
            delete_text_entries=delete_text_entries,
            delete_stream_entries=delete_stream_entries,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '402': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_model_with_http_info(
        self,
        namespace: StrictStr,
        model: StrictStr,
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        delete_inex_file: Annotated[Optional[StrictBool], Field(description="If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file")] = None,
        delete_arguments: Annotated[Optional[StrictBool], Field(description="If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments")] = None,
        delete_run: Annotated[Optional[StrictBool], Field(description="If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename")] = None,
        delete_user_groups: Annotated[Optional[StrictBool], Field(description="If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups")] = None,
        delete_text_entries: Annotated[Optional[StrictBool], Field(description="If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries")] = None,
        delete_stream_entries: Annotated[Optional[StrictBool], Field(description="If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing files of model")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Partially update registered models


        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param delete_inex_file: If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file
        :type delete_inex_file: bool
        :param delete_arguments: If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments
        :type delete_arguments: bool
        :param delete_run: If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename
        :type delete_run: bool
        :param delete_user_groups: If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups
        :type delete_user_groups: bool
        :param delete_text_entries: If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries
        :type delete_text_entries: bool
        :param delete_stream_entries: If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries
        :type delete_stream_entries: bool
        :param data: Zip file containing files of model
        :type data: bytearray
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_model_serialize(
            namespace=namespace,
            model=model,
            inex_string=inex_string,
            arguments=arguments,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            text_entries=text_entries,
            stream_entries=stream_entries,
            delete_inex_file=delete_inex_file,
            delete_arguments=delete_arguments,
            delete_run=delete_run,
            delete_user_groups=delete_user_groups,
            delete_text_entries=delete_text_entries,
            delete_stream_entries=delete_stream_entries,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '402': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_model_without_preload_content(
        self,
        namespace: StrictStr,
        model: StrictStr,
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        delete_inex_file: Annotated[Optional[StrictBool], Field(description="If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file")] = None,
        delete_arguments: Annotated[Optional[StrictBool], Field(description="If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments")] = None,
        delete_run: Annotated[Optional[StrictBool], Field(description="If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename")] = None,
        delete_user_groups: Annotated[Optional[StrictBool], Field(description="If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups")] = None,
        delete_text_entries: Annotated[Optional[StrictBool], Field(description="If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries")] = None,
        delete_stream_entries: Annotated[Optional[StrictBool], Field(description="If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing files of model")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Partially update registered models


        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param delete_inex_file: If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file
        :type delete_inex_file: bool
        :param delete_arguments: If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments
        :type delete_arguments: bool
        :param delete_run: If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename
        :type delete_run: bool
        :param delete_user_groups: If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups
        :type delete_user_groups: bool
        :param delete_text_entries: If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries
        :type delete_text_entries: bool
        :param delete_stream_entries: If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries
        :type delete_stream_entries: bool
        :param data: Zip file containing files of model
        :type data: bytearray
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_model_serialize(
            namespace=namespace,
            model=model,
            inex_string=inex_string,
            arguments=arguments,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            text_entries=text_entries,
            stream_entries=stream_entries,
            delete_inex_file=delete_inex_file,
            delete_arguments=delete_arguments,
            delete_run=delete_run,
            delete_user_groups=delete_user_groups,
            delete_text_entries=delete_text_entries,
            delete_stream_entries=delete_stream_entries,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '402': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_model_serialize(
        self,
        namespace,
        model,
        inex_string,
        arguments,
        run,
        protect_model_files,
        user_groups,
        text_entries,
        stream_entries,
        delete_inex_file,
        delete_arguments,
        delete_run,
        delete_user_groups,
        delete_text_entries,
        delete_stream_entries,
        data,
        inex_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'arguments': 'multi',
            'user_groups': 'multi',
            'text_entries': 'multi',
            'stream_entries': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if model is not None:
            _path_params['model'] = model
        # process the query parameters
        if inex_string is not None:
            
            _query_params.append(('inex_string', inex_string))
            
        if arguments is not None:
            
            _query_params.append(('arguments', arguments))
            
        if run is not None:
            
            _query_params.append(('run', run))
            
        if protect_model_files is not None:
            
            _query_params.append(('protect_model_files', protect_model_files))
            
        if user_groups is not None:
            
            _query_params.append(('user_groups', user_groups))
            
        if text_entries is not None:
            
            _query_params.append(('text_entries', text_entries))
            
        if stream_entries is not None:
            
            _query_params.append(('stream_entries', stream_entries))
            
        if delete_inex_file is not None:
            
            _query_params.append(('delete_inex_file', delete_inex_file))
            
        if delete_arguments is not None:
            
            _query_params.append(('delete_arguments', delete_arguments))
            
        if delete_run is not None:
            
            _query_params.append(('delete_run', delete_run))
            
        if delete_user_groups is not None:
            
            _query_params.append(('delete_user_groups', delete_user_groups))
            
        if delete_text_entries is not None:
            
            _query_params.append(('delete_text_entries', delete_text_entries))
            
        if delete_stream_entries is not None:
            
            _query_params.append(('delete_stream_entries', delete_stream_entries))
            
        # process the header parameters
        # process the form parameters
        if data is not None:
            _files['data'] = data
        if inex_file is not None:
            _files['inex_file'] = inex_file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/namespaces/{namespace}/models/{model}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_model_deprecated(
        self,
        namespace: StrictStr,
        model: StrictStr,
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        delete_inex_file: Annotated[Optional[StrictBool], Field(description="If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file")] = None,
        delete_arguments: Annotated[Optional[StrictBool], Field(description="If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments")] = None,
        delete_run: Annotated[Optional[StrictBool], Field(description="If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename")] = None,
        delete_user_groups: Annotated[Optional[StrictBool], Field(description="If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups")] = None,
        delete_text_entries: Annotated[Optional[StrictBool], Field(description="If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries")] = None,
        delete_stream_entries: Annotated[Optional[StrictBool], Field(description="If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing files of model")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """(Deprecated) Partially update registered models


        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param delete_inex_file: If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file
        :type delete_inex_file: bool
        :param delete_arguments: If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments
        :type delete_arguments: bool
        :param delete_run: If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename
        :type delete_run: bool
        :param delete_user_groups: If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups
        :type delete_user_groups: bool
        :param delete_text_entries: If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries
        :type delete_text_entries: bool
        :param delete_stream_entries: If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries
        :type delete_stream_entries: bool
        :param data: Zip file containing files of model
        :type data: bytearray
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PATCH /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._update_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            inex_string=inex_string,
            arguments=arguments,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            text_entries=text_entries,
            stream_entries=stream_entries,
            delete_inex_file=delete_inex_file,
            delete_arguments=delete_arguments,
            delete_run=delete_run,
            delete_user_groups=delete_user_groups,
            delete_text_entries=delete_text_entries,
            delete_stream_entries=delete_stream_entries,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '402': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_model_deprecated_with_http_info(
        self,
        namespace: StrictStr,
        model: StrictStr,
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        delete_inex_file: Annotated[Optional[StrictBool], Field(description="If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file")] = None,
        delete_arguments: Annotated[Optional[StrictBool], Field(description="If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments")] = None,
        delete_run: Annotated[Optional[StrictBool], Field(description="If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename")] = None,
        delete_user_groups: Annotated[Optional[StrictBool], Field(description="If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups")] = None,
        delete_text_entries: Annotated[Optional[StrictBool], Field(description="If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries")] = None,
        delete_stream_entries: Annotated[Optional[StrictBool], Field(description="If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing files of model")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """(Deprecated) Partially update registered models


        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param delete_inex_file: If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file
        :type delete_inex_file: bool
        :param delete_arguments: If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments
        :type delete_arguments: bool
        :param delete_run: If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename
        :type delete_run: bool
        :param delete_user_groups: If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups
        :type delete_user_groups: bool
        :param delete_text_entries: If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries
        :type delete_text_entries: bool
        :param delete_stream_entries: If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries
        :type delete_stream_entries: bool
        :param data: Zip file containing files of model
        :type data: bytearray
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PATCH /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._update_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            inex_string=inex_string,
            arguments=arguments,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            text_entries=text_entries,
            stream_entries=stream_entries,
            delete_inex_file=delete_inex_file,
            delete_arguments=delete_arguments,
            delete_run=delete_run,
            delete_user_groups=delete_user_groups,
            delete_text_entries=delete_text_entries,
            delete_stream_entries=delete_stream_entries,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '402': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_model_deprecated_without_preload_content(
        self,
        namespace: StrictStr,
        model: StrictStr,
        inex_string: Annotated[Optional[StrictStr], Field(description="JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)")] = None,
        arguments: Annotated[Optional[List[StrictStr]], Field(description="Arguments that will be passed to GAMS call")] = None,
        run: Annotated[Optional[StrictStr], Field(description="Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.")] = None,
        protect_model_files: Annotated[Optional[StrictBool], Field(description="Whether to protect model files from being overwritten by data files.")] = None,
        user_groups: Annotated[Optional[List[StrictStr]], Field(description="Restrict access to specific user groups")] = None,
        text_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to store as text entries")] = None,
        stream_entries: Annotated[Optional[List[StrictStr]], Field(description="Files to stream during execution")] = None,
        delete_inex_file: Annotated[Optional[StrictBool], Field(description="If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file")] = None,
        delete_arguments: Annotated[Optional[StrictBool], Field(description="If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments")] = None,
        delete_run: Annotated[Optional[StrictBool], Field(description="If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename")] = None,
        delete_user_groups: Annotated[Optional[StrictBool], Field(description="If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups")] = None,
        delete_text_entries: Annotated[Optional[StrictBool], Field(description="If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries")] = None,
        delete_stream_entries: Annotated[Optional[StrictBool], Field(description="If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries")] = None,
        data: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Zip file containing files of model")] = None,
        inex_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="JSON file that describes which files will be included/excluded from results archive")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Partially update registered models


        :param namespace: (required)
        :type namespace: str
        :param model: (required)
        :type model: str
        :param inex_string: JSON string that describes which files will be included/excluded from results archive (if provided, inex_file takes precendence)
        :type inex_string: str
        :param arguments: Arguments that will be passed to GAMS call
        :type arguments: List[str]
        :param run: Main GMS file to run, please include file extension as well. Will use model + '.gms' if not provided.
        :type run: str
        :param protect_model_files: Whether to protect model files from being overwritten by data files.
        :type protect_model_files: bool
        :param user_groups: Restrict access to specific user groups
        :type user_groups: List[str]
        :param text_entries: Files to store as text entries
        :type text_entries: List[str]
        :param stream_entries: Files to stream during execution
        :type stream_entries: List[str]
        :param delete_inex_file: If `inex_file` is provided, setting this throws error, otherwise setting this to true deletes the inex file
        :type delete_inex_file: bool
        :param delete_arguments: If `arguments` is provided, setting this throws error, otherwise setting this deletes the arguments
        :type delete_arguments: bool
        :param delete_run: If `run` is provided, setting this throws error, otherwise setting this to true deletes the run filename
        :type delete_run: bool
        :param delete_user_groups: If `user_groups` is provided, setting this throws error, otherwise setting this deletes the user groups
        :type delete_user_groups: bool
        :param delete_text_entries: If `text_entries` is provided, setting this throws error, otherwise setting this deletes the text entries
        :type delete_text_entries: bool
        :param delete_stream_entries: If `stream_entries` is provided, setting this throws error, otherwise setting this deletes the stream entries
        :type delete_stream_entries: bool
        :param data: Zip file containing files of model
        :type data: bytearray
        :param inex_file: JSON file that describes which files will be included/excluded from results archive
        :type inex_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PATCH /namespaces/{namespace}/{model} is deprecated.", DeprecationWarning)

        _param = self._update_model_deprecated_serialize(
            namespace=namespace,
            model=model,
            inex_string=inex_string,
            arguments=arguments,
            run=run,
            protect_model_files=protect_model_files,
            user_groups=user_groups,
            text_entries=text_entries,
            stream_entries=stream_entries,
            delete_inex_file=delete_inex_file,
            delete_arguments=delete_arguments,
            delete_run=delete_run,
            delete_user_groups=delete_user_groups,
            delete_text_entries=delete_text_entries,
            delete_stream_entries=delete_stream_entries,
            data=data,
            inex_file=inex_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '402': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_model_deprecated_serialize(
        self,
        namespace,
        model,
        inex_string,
        arguments,
        run,
        protect_model_files,
        user_groups,
        text_entries,
        stream_entries,
        delete_inex_file,
        delete_arguments,
        delete_run,
        delete_user_groups,
        delete_text_entries,
        delete_stream_entries,
        data,
        inex_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'arguments': 'multi',
            'user_groups': 'multi',
            'text_entries': 'multi',
            'stream_entries': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if model is not None:
            _path_params['model'] = model
        # process the query parameters
        if inex_string is not None:
            
            _query_params.append(('inex_string', inex_string))
            
        if arguments is not None:
            
            _query_params.append(('arguments', arguments))
            
        if run is not None:
            
            _query_params.append(('run', run))
            
        if protect_model_files is not None:
            
            _query_params.append(('protect_model_files', protect_model_files))
            
        if user_groups is not None:
            
            _query_params.append(('user_groups', user_groups))
            
        if text_entries is not None:
            
            _query_params.append(('text_entries', text_entries))
            
        if stream_entries is not None:
            
            _query_params.append(('stream_entries', stream_entries))
            
        if delete_inex_file is not None:
            
            _query_params.append(('delete_inex_file', delete_inex_file))
            
        if delete_arguments is not None:
            
            _query_params.append(('delete_arguments', delete_arguments))
            
        if delete_run is not None:
            
            _query_params.append(('delete_run', delete_run))
            
        if delete_user_groups is not None:
            
            _query_params.append(('delete_user_groups', delete_user_groups))
            
        if delete_text_entries is not None:
            
            _query_params.append(('delete_text_entries', delete_text_entries))
            
        if delete_stream_entries is not None:
            
            _query_params.append(('delete_stream_entries', delete_stream_entries))
            
        # process the header parameters
        # process the form parameters
        if data is not None:
            _files['data'] = data
        if inex_file is not None:
            _files['inex_file'] = inex_file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/namespaces/{namespace}/{model}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_namespace_quota(
        self,
        namespace: StrictStr,
        disk_quota: Annotated[int, Field(strict=True, gt=0, description="disk quota in bytes")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Updates namespace disk quota

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param disk_quota: disk quota in bytes (required)
        :type disk_quota: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_namespace_quota_serialize(
            namespace=namespace,
            disk_quota=disk_quota,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_namespace_quota_with_http_info(
        self,
        namespace: StrictStr,
        disk_quota: Annotated[int, Field(strict=True, gt=0, description="disk quota in bytes")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Updates namespace disk quota

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param disk_quota: disk quota in bytes (required)
        :type disk_quota: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_namespace_quota_serialize(
            namespace=namespace,
            disk_quota=disk_quota,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_namespace_quota_without_preload_content(
        self,
        namespace: StrictStr,
        disk_quota: Annotated[int, Field(strict=True, gt=0, description="disk quota in bytes")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates namespace disk quota

        Requires admin role

        :param namespace: (required)
        :type namespace: str
        :param disk_quota: disk quota in bytes (required)
        :type disk_quota: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_namespace_quota_serialize(
            namespace=namespace,
            disk_quota=disk_quota,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Message",
            '400': "Message",
            '403': "Message",
            '404': "Message",
            '500': "Message",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_namespace_quota_serialize(
        self,
        namespace,
        disk_quota,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if disk_quota is not None:
            _form_params.append(('disk_quota', disk_quota))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'BasicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/namespaces/{namespace}/disk-quota',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


