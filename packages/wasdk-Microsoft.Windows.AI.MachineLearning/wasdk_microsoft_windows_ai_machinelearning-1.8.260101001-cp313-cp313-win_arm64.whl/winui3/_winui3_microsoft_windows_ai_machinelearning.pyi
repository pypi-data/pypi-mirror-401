# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel as windows_applicationmodel
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections

from winui3.microsoft.windows.ai.machinelearning import CatalogModelInstanceStatus, CatalogModelStatus, ExecutionProviderCertification, ExecutionProviderReadyResultState, ExecutionProviderReadyState

Self = typing.TypeVar('Self')

@typing.final
class CatalogModelInfo(winrt.system.Object):
    # Windows.Foundation.IAsyncOperationWithProgress`2<Microsoft.Windows.AI.MachineLearning.CatalogModelInstanceResult,System.Double> Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::GetInstanceAsync()
    def get_instance_async(self) -> windows_foundation.IAsyncOperationWithProgress[CatalogModelInstanceResult, winrt.system.Double]: ...
    # Windows.Foundation.IAsyncOperationWithProgress`2<Microsoft.Windows.AI.MachineLearning.CatalogModelInstanceResult,System.Double> Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::GetInstanceAsync(Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<System.String,System.String>>)
    def get_instance_async2(self, additional_headers: typing.Union[typing.Mapping[str, str], typing.Iterable[windows_foundation_collections.IKeyValuePair[str, str]]], /) -> windows_foundation.IAsyncOperationWithProgress[CatalogModelInstanceResult, winrt.system.Double]: ...
    # Microsoft.Windows.AI.MachineLearning.CatalogModelStatus Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::GetStatus()
    def get_status(self) -> CatalogModelStatus: ...
    # Windows.Foundation.Collections.IVectorView`1<System.String> Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_ExecutionProviders()
    @_property
    def execution_providers(self) -> typing.Sequence[str]: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_Id()
    @_property
    def id(self) -> str: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_License()
    @_property
    def license(self) -> str: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_LicenseText()
    @_property
    def license_text(self) -> str: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_LicenseUri()
    @_property
    def license_uri(self) -> str: ...
    # System.UInt64 Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_ModelSizeInBytes()
    @_property
    def model_size_in_bytes(self) -> winrt.system.UInt64: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_Name()
    @_property
    def name(self) -> str: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_Publisher()
    @_property
    def publisher(self) -> str: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_SourceId()
    @_property
    def source_id(self) -> str: ...
    # Windows.Foundation.Uri Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_Uri()
    @_property
    def uri(self) -> windows_foundation.Uri: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInfo::get_Version()
    @_property
    def version(self) -> str: ...

@typing.final
class CatalogModelInstance(winrt.system.Object, windows_foundation.IClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]], exc_value: typing.Optional[BaseException], traceback: typing.Optional[types.TracebackType]) -> None: ...
    # System.Void Microsoft.Windows.AI.MachineLearning.CatalogModelInstance::Close()
    def close(self) -> None: ...
    # Microsoft.Windows.AI.MachineLearning.CatalogModelInfo Microsoft.Windows.AI.MachineLearning.CatalogModelInstance::get_ModelInfo()
    @_property
    def model_info(self) -> CatalogModelInfo: ...
    # Windows.Foundation.Collections.IVectorView`1<System.String> Microsoft.Windows.AI.MachineLearning.CatalogModelInstance::get_ModelPaths()
    @_property
    def model_paths(self) -> typing.Sequence[str]: ...

@typing.final
class CatalogModelInstanceResult(winrt.system.Object):
    # Microsoft.Windows.AI.MachineLearning.CatalogModelInstance Microsoft.Windows.AI.MachineLearning.CatalogModelInstanceResult::GetInstance()
    def get_instance(self) -> CatalogModelInstance: ...
    # System.String Microsoft.Windows.AI.MachineLearning.CatalogModelInstanceResult::get_DiagnosticText()
    @_property
    def diagnostic_text(self) -> str: ...
    # Windows.Foundation.HResult Microsoft.Windows.AI.MachineLearning.CatalogModelInstanceResult::get_ExtendedError()
    @_property
    def extended_error(self) -> windows_foundation.HResult: ...
    # Microsoft.Windows.AI.MachineLearning.CatalogModelInstanceStatus Microsoft.Windows.AI.MachineLearning.CatalogModelInstanceResult::get_Status()
    @_property
    def status(self) -> CatalogModelInstanceStatus: ...

@typing.final
class ExecutionProvider(winrt.system.Object):
    # Windows.Foundation.IAsyncOperationWithProgress`2<Microsoft.Windows.AI.MachineLearning.ExecutionProviderReadyResult,System.Double> Microsoft.Windows.AI.MachineLearning.ExecutionProvider::EnsureReadyAsync()
    def ensure_ready_async(self) -> windows_foundation.IAsyncOperationWithProgress[ExecutionProviderReadyResult, winrt.system.Double]: ...
    # System.Boolean Microsoft.Windows.AI.MachineLearning.ExecutionProvider::TryRegister()
    def try_register(self) -> bool: ...
    # Microsoft.Windows.AI.MachineLearning.ExecutionProviderCertification Microsoft.Windows.AI.MachineLearning.ExecutionProvider::get_Certification()
    @_property
    def certification(self) -> ExecutionProviderCertification: ...
    # System.String Microsoft.Windows.AI.MachineLearning.ExecutionProvider::get_LibraryPath()
    @_property
    def library_path(self) -> str: ...
    # System.String Microsoft.Windows.AI.MachineLearning.ExecutionProvider::get_Name()
    @_property
    def name(self) -> str: ...
    # Windows.ApplicationModel.PackageId Microsoft.Windows.AI.MachineLearning.ExecutionProvider::get_PackageId()
    @_property
    def package_id(self) -> windows_applicationmodel.PackageId: ...
    # Microsoft.Windows.AI.MachineLearning.ExecutionProviderReadyState Microsoft.Windows.AI.MachineLearning.ExecutionProvider::get_ReadyState()
    @_property
    def ready_state(self) -> ExecutionProviderReadyState: ...

@typing.final
class ExecutionProviderCatalog_Static(winrt._winrt.IInspectable_Static):
    # Microsoft.Windows.AI.MachineLearning.ExecutionProviderCatalog Microsoft.Windows.AI.MachineLearning.ExecutionProviderCatalog::GetDefault()
    def get_default(cls) -> ExecutionProviderCatalog: ...

@typing.final
class ExecutionProviderCatalog(winrt.system.Object, metaclass=ExecutionProviderCatalog_Static):
    # Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Foundation.Collections.IVector`1<Microsoft.Windows.AI.MachineLearning.ExecutionProvider>,System.Double> Microsoft.Windows.AI.MachineLearning.ExecutionProviderCatalog::EnsureAndRegisterCertifiedAsync()
    def ensure_and_register_certified_async(self) -> windows_foundation.IAsyncOperationWithProgress[typing.MutableSequence[ExecutionProvider], winrt.system.Double]: ...
    # Microsoft.Windows.AI.MachineLearning.ExecutionProvider[] Microsoft.Windows.AI.MachineLearning.ExecutionProviderCatalog::FindAllProviders()
    def find_all_providers(self) -> winrt.system.Array[ExecutionProvider]: ...
    # Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Foundation.Collections.IVector`1<Microsoft.Windows.AI.MachineLearning.ExecutionProvider>,System.Double> Microsoft.Windows.AI.MachineLearning.ExecutionProviderCatalog::RegisterCertifiedAsync()
    def register_certified_async(self) -> windows_foundation.IAsyncOperationWithProgress[typing.MutableSequence[ExecutionProvider], winrt.system.Double]: ...

@typing.final
class ExecutionProviderReadyResult(winrt.system.Object):
    # System.String Microsoft.Windows.AI.MachineLearning.ExecutionProviderReadyResult::get_DiagnosticText()
    @_property
    def diagnostic_text(self) -> str: ...
    # Windows.Foundation.HResult Microsoft.Windows.AI.MachineLearning.ExecutionProviderReadyResult::get_ExtendedError()
    @_property
    def extended_error(self) -> windows_foundation.HResult: ...
    # Microsoft.Windows.AI.MachineLearning.ExecutionProviderReadyResultState Microsoft.Windows.AI.MachineLearning.ExecutionProviderReadyResult::get_Status()
    @_property
    def status(self) -> ExecutionProviderReadyResultState: ...

@typing.final
class ModelCatalog(winrt.system.Object):
    def __new__(cls: typing.Type[Self], sources: typing.Union[winrt.system.Array[ModelCatalogSource], winrt.system.ReadableBuffer]) -> Self: ...
    # Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<Microsoft.Windows.AI.MachineLearning.CatalogModelInfo>> Microsoft.Windows.AI.MachineLearning.ModelCatalog::FindAllModelsAsync()
    def find_all_models_async(self) -> windows_foundation.IAsyncOperation[typing.Sequence[CatalogModelInfo]]: ...
    # Windows.Foundation.IAsyncOperation`1<Microsoft.Windows.AI.MachineLearning.CatalogModelInfo> Microsoft.Windows.AI.MachineLearning.ModelCatalog::FindModelAsync(System.String)
    def find_model_async(self, id_or_name: str, /) -> windows_foundation.IAsyncOperation[CatalogModelInfo]: ...
    # Microsoft.Windows.AI.MachineLearning.CatalogModelInfo Microsoft.Windows.AI.MachineLearning.ModelCatalog::GetAvailableModel(System.String)
    def get_available_model(self, id_or_name: str, /) -> CatalogModelInfo: ...
    # Windows.Foundation.Collections.IVector`1<Microsoft.Windows.AI.MachineLearning.CatalogModelInfo> Microsoft.Windows.AI.MachineLearning.ModelCatalog::GetAvailableModels()
    def get_available_models(self) -> typing.MutableSequence[CatalogModelInfo]: ...
    # Windows.Foundation.Collections.IVector`1<System.String> Microsoft.Windows.AI.MachineLearning.ModelCatalog::get_ExecutionProviders()
    @_property
    def execution_providers(self) -> typing.MutableSequence[str]: ...
    # Windows.Foundation.Collections.IVector`1<Microsoft.Windows.AI.MachineLearning.ModelCatalogSource> Microsoft.Windows.AI.MachineLearning.ModelCatalog::get_Sources()
    @_property
    def sources(self) -> typing.MutableSequence[ModelCatalogSource]: ...

@typing.final
class ModelCatalogSource_Static(winrt._winrt.IInspectable_Static):
    # Windows.Foundation.IAsyncOperation`1<Microsoft.Windows.AI.MachineLearning.ModelCatalogSource> Microsoft.Windows.AI.MachineLearning.ModelCatalogSource::CreateFromUriAsync(Windows.Foundation.Uri)
    def create_from_uri_async(cls, location: windows_foundation.Uri, /) -> windows_foundation.IAsyncOperation[ModelCatalogSource]: ...
    # Windows.Foundation.IAsyncOperation`1<Microsoft.Windows.AI.MachineLearning.ModelCatalogSource> Microsoft.Windows.AI.MachineLearning.ModelCatalogSource::CreateFromUriAsync(Windows.Foundation.Uri,Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<System.String,System.String>>)
    def create_from_uri_async2(cls, location: windows_foundation.Uri, additional_headers: typing.Union[typing.Mapping[str, str], typing.Iterable[windows_foundation_collections.IKeyValuePair[str, str]]], /) -> windows_foundation.IAsyncOperation[ModelCatalogSource]: ...

@typing.final
class ModelCatalogSource(winrt.system.Object, metaclass=ModelCatalogSource_Static):
    # System.String Microsoft.Windows.AI.MachineLearning.ModelCatalogSource::get_Id()
    @_property
    def id(self) -> str: ...
    # Windows.Foundation.Uri Microsoft.Windows.AI.MachineLearning.ModelCatalogSource::get_Uri()
    @_property
    def uri(self) -> windows_foundation.Uri: ...

