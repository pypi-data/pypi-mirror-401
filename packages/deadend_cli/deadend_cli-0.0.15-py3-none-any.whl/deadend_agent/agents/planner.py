# Copyright (C) 2025 Yassine Bargach
# Licensed under the GNU Affero General Public License v3
# See LICENSE file for full license information.

"""Planning agent for orchestrating security research workflows.

This module implements an AI agent that analyzes targets, creates comprehensive
security assessment plans, and coordinates the execution of various security
testing tasks based on the target's characteristics and requirements.
"""

import uuid
from typing import List, Any
from deadend_agent.rag.database import EmbedderClient
from pydantic import BaseModel
from pydantic_ai import Tool
from pydantic_ai.usage import RunUsage, UsageLimits

from deadend_agent.agents.factory import AgentRunner
from deadend_agent.rag.db_cruds import RetrievalDatabaseConnector
from deadend_agent.models.registry import AIModel
from deadend_agent.utils.structures import RagDeps, Task
from deadend_agent.tools import webapp_code_rag
from deadend_prompts import render_agent_instructions,render_tool_description



class PlannerOutput(BaseModel):
    """Output model for planner agent operations.
    
    Contains the list of tasks generated by the planner agent for execution
    during security assessment workflows.
    
    Attributes:
        tasks: List of Task objects representing the security assessment plan.
    """
    tasks: List[Task]


class PlannerAgent(AgentRunner):
    """AI agent responsible for creating security assessment task plans.
    
    The planner agent analyzes target information and generates a comprehensive
    list of security testing tasks to guide the security assessment workflow.
    It uses code RAG to gather relevant information about the target application.
    """

    def __init__(
            self,
            model: AIModel,
            output_type: Any | None,
        ):
        """Initialize the planner agent.
        
        Args:
            model: The AI model to use for planning operations.
            output_type: The expected output type for agent responses.
        """
        tools_metadata = {
            "webapp_code_rag": render_tool_description("webapp_code_rag")
        } 
        self.instructions = render_agent_instructions(
            agent_name="planner",
            tools=tools_metadata
        )

        super().__init__(
            name="planner_agent",
            model=model,
            instructions=self.instructions,
            deps_type=RagDeps,
            output_type=output_type,
            tools=[Tool(webapp_code_rag, max_retries=5)]
        )

    async def run(
        self,
        prompt,
        deps,
        message_history,
        usage,
        usage_limits,
        deferred_tool_results=None,
    ):
        """Execute the planner agent to generate security assessment tasks.
        
        Args:
            prompt: The user's prompt or goal for the security assessment.
            deps: Dependencies required for the agent execution (RAG dependencies).
            message_history: Historical conversation context.
            usage: Current usage tracking information.
            usage_limits: Limits on resource usage.
            
        Returns:
            The generated planner output containing the task list.
        """
        return await super().run(
            prompt=prompt,
            deps=deps,
            message_history=message_history,
            usage=usage,
            usage_limits=usage_limits,
            deferred_tool_results=deferred_tool_results
        )

class Planner:
    """High-level planner for orchestrating security assessment workflows.
    
    The planner coordinates the overall security assessment process by managing
    information about the target, tracking tasks, and replanning when necessary.
    
    It receives the following information:
    - the target URL
    - web crawler results of the page
    - the authentication data if needed
    - API endpoints or OpenAPI specification file
    
    The planner manages this information and coordinates task execution:
    - Creates an initial plan of security testing tasks
    - Executes tasks sequentially by calling testing agents
    - Analyzes results using LLM and updates task status
    - Replans if necessary based on findings
    
    Attributes:
        target: The target URL to assess.
        api_spec: API specification or OpenAPI schema.
        tasks: List of planned security assessment tasks.
        agent: The PlannerAgent instance used for planning.
    """
    def __init__(self, model: AIModel, target: str, api_spec: str):
        """Initialize the planner with target information.
        
        Args:
            model: The AI model to use for planning.
            target: The target URL for security assessment.
            api_spec: API specification or OpenAPI schema for the target.
        """
        self.target = target
        self.api_spec = api_spec
        self.tasks = List[Task]

        self.agent = PlannerAgent(
            model=model,
            output_type=PlannerOutput,
        )

    async def run(self,
            prompt: str,
            message_history: str,
            usage: RunUsage,
            usage_limits: UsageLimits,
            embedder_client: EmbedderClient,
            rag: RetrievalDatabaseConnector,
            session_id: uuid.UUID
        ):
        """Execute the planning workflow to generate security assessment tasks.
        
        Args:
            prompt: The user's security assessment goal or objective.
            message_history: Historical conversation context.
            usage: Current resource usage tracking.
            usage_limits: Limits on resource consumption.
            openai: OpenAI client for LLM operations.
            rag: RAG database connector for information retrieval.
            session_id: Unique identifier for the current session.
            
        Returns:
            Planner output containing the generated task list for security assessment.
        """

        rag_deps = RagDeps(
            embedder_client=embedder_client,
            rag=rag,
            target=self.target,
            session_id=session_id
        )

        return await self.agent.run(
            prompt=prompt,
            deps=rag_deps,
            message_history=message_history,
            usage=usage,
            usage_limits=usage_limits
        )


