# Security Model

Codemode implements a defense-in-depth security architecture to safely execute untrusted code generated by AI agents. This document describes the security layers and mechanisms that protect your application.

## Security Principles

1. **Isolation First**: Code executes in isolated environments, never in the main application process
2. **Least Privilege**: Executed code has minimal permissions by default
3. **Explicit Access**: Only explicitly registered tools and resources are accessible
4. **Authentication Everywhere**: All communication channels require authentication
5. **Defense in Depth**: Multiple layers of security controls

## Isolation Architecture

### Container Isolation

The executor sidecar runs in a Docker container with restricted capabilities:

```yaml
# docker-compose.yml example
services:
  executor:
    image: codemode/executor:latest
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    read_only: true
    tmpfs:
      - /tmp:size=100M,mode=1777
```

**Container Security Features**:

| Feature | Description |
|---------|-------------|
| `no-new-privileges` | Prevents privilege escalation |
| `cap_drop: ALL` | Removes all Linux capabilities |
| `read_only` | Root filesystem is read-only |
| `tmpfs` | Ephemeral scratch space with size limits |

### Process Isolation

Within the container, code executes in a separate subprocess:

```
Executor Container
+------------------------------------------+
|  ExecutorService (gRPC Server)           |
|       |                                  |
|       v                                  |
|  CodeRunner                              |
|       |                                  |
|       +---> subprocess (python -c ...)   |
|             - Separate process           |
|             - Timeout enforced           |
|             - stdout/stderr captured     |
+------------------------------------------+
```

**Process Isolation Features**:

- Each execution runs in a fresh subprocess
- Subprocesses are killed on timeout
- No shared state between executions
- Process exit codes are captured and analyzed

### Network Isolation

The executor container can be configured with restricted network access:

```yaml
executor:
  network:
    mode: "none"        # No network access (default)
    # mode: "restricted"  # Allow specific domains only
    # allowed_domains:
    #   - "api.openai.com"
    #   - "*.github.com"
```

**Network Modes**:

| Mode | Description |
|------|-------------|
| `none` | No outbound network access (except gRPC to main app) |
| `restricted` | Allow-list based domain filtering |
| `all` | Full network access (not recommended for production) |

## Authentication

### API Key Authentication

All gRPC communication between components uses API key authentication:

```
Main App                           Executor Sidecar
    |                                     |
    |  Authorization: Bearer <api_key>    |
    +------------------------------------>|
    |                                     |
    |  Authorization: Bearer <api_key>    |
    |<------------------------------------+
    |                                     |
```

**Implementation**:

```python
# Client sends API key in metadata
metadata = [("authorization", f"Bearer {api_key}")]
response = stub.Execute(request, metadata=metadata)

# Server validates API key
metadata = dict(context.invocation_metadata())
if metadata.get("authorization") != f"Bearer {expected_key}":
    context.abort(grpc.StatusCode.UNAUTHENTICATED, "Invalid API key")
```

**Key Management**:

- API keys should be generated with sufficient entropy (32+ bytes)
- Keys should be rotated regularly
- Keys should be stored securely (environment variables, secrets manager)
- Different keys can be used for different environments

### Callback Authentication

When the executor sidecar calls back to the main application for tool access, it must authenticate:

```
Executor Sidecar                    Main App (ToolService)
    |                                     |
    | ToolCallRequest                     |
    | Authorization: Bearer <api_key>     |
    +------------------------------------>|
    |                                     | Validate API key
    |                                     |
    |            ToolCallResponse         |
    |<------------------------------------+
    |                                     |
```

This ensures that only authorized executor instances can invoke tools.

## TLS/mTLS Encryption

All gRPC communication supports TLS encryption with optional mutual authentication.

### TLS Modes

| Mode | Description |
|------|-------------|
| `disabled` | Insecure (development only) |
| `system` | Use system CA certificates |
| `custom` | Use custom CA and certificates |

### Basic TLS Configuration

```yaml
grpc:
  tls:
    enabled: true
    mode: "custom"
    ca_file: "/certs/ca.crt"
```

### Mutual TLS (mTLS)

For maximum security, enable client certificate authentication:

```yaml
# Client configuration
grpc:
  tls:
    enabled: true
    mode: "custom"
    ca_file: "/certs/ca.crt"
    client_cert_file: "/certs/client.crt"
    client_key_file: "/certs/client.key"

# Server configuration
grpc:
  tls:
    enabled: true
    mode: "custom"
    cert_file: "/certs/server.crt"
    key_file: "/certs/server.key"
    ca_file: "/certs/ca.crt"  # Enables client verification
```

**mTLS Benefits**:

- Verifies both client and server identities
- Prevents unauthorized services from connecting
- Suitable for zero-trust environments

## Code Execution Limits

### Timeout Enforcement

All code execution has timeout limits:

```python
# Configuration
executor:
  limits:
    code_timeout: 30  # Maximum execution time in seconds

# Enforcement in CodeRunner
try:
    stdout, stderr = await asyncio.wait_for(
        process.communicate(),
        timeout=timeout
    )
except TimeoutError:
    process.kill()
    await process.wait()
    # Return timeout error
```

### Code Length Limits

Maximum code length is enforced before execution:

```python
# Configuration
executor:
  limits:
    max_code_length: 10000  # Maximum 10KB

# Enforcement in SecurityValidator
if len(code) > self.max_code_length:
    return SecurityValidationResult.unsafe(
        violations=["max_length_exceeded"],
        reason=f"Code exceeds maximum length of {self.max_code_length} characters"
    )
```

### Memory Limits

Container-level memory limits prevent resource exhaustion:

```yaml
executor:
  limits:
    memory_limit: "512Mi"

# In Docker Compose
services:
  executor:
    deploy:
      resources:
        limits:
          memory: 512M
```

## Security Validation

### Blocked Patterns

The `SecurityValidator` blocks dangerous code patterns:

```python
BLOCKED_PATTERNS = {
    "__import__",
    "eval(",
    "exec(",
    "compile(",
    "open(",
    "__builtins__",
    "getattr(",
    "setattr(",
    "delattr(",
    "globals(",
    "locals(",
    # ... and more
}
```

### Blocked Imports

Dangerous module imports are blocked:

```python
BLOCKED_IMPORTS = {
    # Process spawning
    "subprocess",
    "os.system",
    "os.popen",
    "os.spawn",
    "os.exec",
    "multiprocessing",

    # Networking
    "socket",
    "urllib",
    "http.client",
    "ftplib",
    "telnetlib",
    "smtplib",

    # Low-level access
    "ctypes",
    "ssl",
    "pty",
    "signal",

    # ... and more
}
```

### Suspicious Pattern Detection

Additional heuristic checks detect potentially malicious code:

| Pattern | Reason |
|---------|--------|
| `while True:` | Potential infinite loop |
| Excessive function definitions | Possible obfuscation |
| Unicode escapes (`\x`, `\u`) | Encoding tricks |
| Very long strings (1000+ chars) | Embedded payloads |

### Validation Example

```python
from codemode.executor.security import SecurityValidator

validator = SecurityValidator()

# Safe code
result = validator.validate("result = 2 + 2")
assert result.is_safe == True

# Blocked pattern
result = validator.validate("eval('print(1)')")
assert result.is_safe == False
assert "eval(" in result.violations

# Blocked import
result = validator.validate("import subprocess")
assert result.is_safe == False
assert "subprocess" in result.violations
```

## Direct Execution Mode

For trusted environments, direct execution mode can be enabled with whitelisting:

```yaml
executor:
  execution:
    allow_direct_execution: true
    allowed_commands:
      - grep
      - cat
      - ls
      - head
      - tail
  filesystem:
    workspace:
      mount: "/workspace"
      readonly: true
    sandbox:
      mount: "/sandbox"
      readonly: false
```

**Security Controls for Direct Execution**:

| Control | Description |
|---------|-------------|
| `allowed_commands` | Whitelist of permitted system commands |
| `allowed_paths` | Whitelist of accessible filesystem paths |
| Path validation | Prevents path traversal attacks |
| Command validation | Blocks unauthorized commands |

## Security Checklist

### Development

- [ ] Use insecure gRPC only on localhost
- [ ] Use test API keys that differ from production
- [ ] Enable verbose logging for debugging

### Staging

- [ ] Enable TLS encryption
- [ ] Use staging-specific API keys
- [ ] Test with production-like security settings
- [ ] Verify timeout and limit enforcement

### Production

- [ ] Enable TLS/mTLS encryption
- [ ] Use strong, rotated API keys
- [ ] Set appropriate resource limits
- [ ] Configure network isolation
- [ ] Enable audit logging
- [ ] Monitor for security violations
- [ ] Regular security reviews

## Threat Model

### Mitigated Threats

| Threat | Mitigation |
|--------|------------|
| Code injection in main app | Process isolation in container |
| Arbitrary file access | Read-only filesystem, path whitelisting |
| Network exfiltration | Network isolation modes |
| Resource exhaustion | Timeout, memory, and code length limits |
| Privilege escalation | Container security options |
| Man-in-the-middle | TLS/mTLS encryption |
| Unauthorized tool access | API key authentication |

### Residual Risks

| Risk | Mitigation Strategy |
|------|---------------------|
| Container escape vulnerabilities | Keep Docker/runtime updated |
| Denial of service via many requests | Rate limiting at infrastructure level |
| Side-channel attacks | Consider dedicated executor instances |
| Supply chain attacks | Verify container images, use pinned versions |

## Security Incident Response

If you discover a security vulnerability in Codemode:

1. Do not disclose publicly
2. Report via GitHub Security Advisories
3. Include reproduction steps if possible
4. We will respond within 48 hours
