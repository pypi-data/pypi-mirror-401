<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 7.4.7 and Furo 2024.08.06 -->
        <title>chainalysis.orm.select - Data Solutions Python SDK 0.7.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Data Solutions Python SDK 0.7.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">Data Solutions Python SDK 0.7.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../modules.html">chainalysis</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of chainalysis</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../chainalysis.html">chainalysis package</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of chainalysis package</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../chainalysis.orm.html">chainalysis.orm package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../chainalysis.sql.html">chainalysis.sql package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../chainalysis.utils.html">chainalysis.utils package</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for chainalysis.orm.select</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">sqlalchemy</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Column</span><span class="p">,</span>
    <span class="n">ColumnCollection</span><span class="p">,</span>
    <span class="n">ColumnExpressionArgument</span><span class="p">,</span>
    <span class="n">Subquery</span><span class="p">,</span>
    <span class="n">Table</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">chainalysis.exceptions</span> <span class="kn">import</span> <span class="n">ValueException</span>
<span class="kn">from</span> <span class="nn">chainalysis.sql.analytical</span> <span class="kn">import</span> <span class="n">Analytical</span>
<span class="kn">from</span> <span class="nn">chainalysis.sql.transactional</span> <span class="kn">import</span> <span class="n">Transactional</span>


<div class="viewcode-block" id="Select">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select">[docs]</a>
<span class="k">class</span> <span class="nc">Select</span><span class="p">(</span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">Select</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select is an abstract base class that represents an interface</span>
<span class="sd">    for an Object Relational Mapper (ORM) which queries a chain-specific</span>
<span class="sd">    table within Data Solutions.</span>

<span class="sd">    Select provides the structure for constructing and executing SQL queries</span>
<span class="sd">    using functions. Child classes must implement methods to retrieve</span>
<span class="sd">    tables and execute queries, which will return the appropriate result type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Select.__init__">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">chain_table_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new Select.</span>

<span class="sd">        :param api_key: The API key for the Data Solutions API.</span>
<span class="sd">        :type api_key: str</span>
<span class="sd">        :param chain_table_name: The chain and table name formatted as &#39;chain.table&#39;.</span>
<span class="sd">        :type chain_table_name: str</span>
<span class="sd">        :raises ValueException: If the table name is not formatted correctly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chain_table_name_split</span> <span class="o">=</span> <span class="n">chain_table_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_table_name_split</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValueException</span><span class="p">(</span>
                <span class="s2">&quot;Table must be formatted as &#39;chain.table&#39;. Check your input.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">api_key</span> <span class="o">=</span> <span class="n">api_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_table</span><span class="p">(</span>
            <span class="n">chain_table_name_split</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">chain_table_name_split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnCollection</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the columns of the table.</span>

<span class="sd">        :return: A collection of column objects associated with the table.</span>
<span class="sd">        :rtype: ColumnCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">c</span>

<div class="viewcode-block" id="Select.with_columns">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.with_columns">[docs]</a>
    <span class="k">def</span> <span class="nf">with_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select specific columns from the table for querying.</span>

<span class="sd">        Note: All columns are selected by default.</span>
<span class="sd">        Use this method to select specific columns.</span>

<span class="sd">        :param columns: The columns to be selected.</span>
<span class="sd">        :type columns: Column</span>
<span class="sd">        :return: A Select instance with the selected columns.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            select_query = query_1.with_columns(query_1.c.column1, query_1.c.column2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT &quot;chain.table1&quot;.column1, &quot;chain.table1&quot;.column2</span>
<span class="sd">            FROM &quot;chain.table1&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_only_columns</span><span class="p">(</span><span class="o">*</span><span class="n">columns</span><span class="p">)</span></div>


    <span class="c1"># Overriding select methods</span>

<div class="viewcode-block" id="Select.where">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.where">[docs]</a>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">whereclauses</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Select with the given expression</span>
<span class="sd">        added to its WHERE clause, joined to the existing clause via AND, if any.</span>

<span class="sd">        :param whereclauses: The WHERE clauses to apply.</span>
<span class="sd">        :type whereclauses: ColumnExpressionArgument[bool]</span>
<span class="sd">        :return: A new Select with the WHERE clause applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            where_query = query_1.where(query_1.c.column1 == 1)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT *</span>
<span class="sd">            FROM &quot;chain.table1&quot;</span>
<span class="sd">            WHERE &quot;chain.table1&quot;.column1 = 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">*</span><span class="n">whereclauses</span><span class="p">)</span></div>


<div class="viewcode-block" id="Select.limit">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.limit">[docs]</a>
    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Select with the given LIMIT clause applied.</span>

<span class="sd">        :param limit: The number of rows to limit the result set to.</span>
<span class="sd">        :type limit: int</span>
<span class="sd">        :return: A new Select with the LIMIT clause applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            limit_query = query_1.limit(10)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT * FROM &quot;chain.table1&quot;</span>
<span class="sd">            LIMIT 10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span></div>


<div class="viewcode-block" id="Select.group_by">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.group_by">[docs]</a>
    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Select with the given expression(s) added to its GROUP BY clause.</span>

<span class="sd">        :param columns: The columns to group by.</span>
<span class="sd">        :type columns: Column</span>
<span class="sd">        :return: A new Select with the GROUP BY clause applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            group_by_query = query_1.group_by(query_1.c.column1, query_1.c.column2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT *</span>
<span class="sd">            FROM &quot;chain.table1&quot;</span>
<span class="sd">            GROUP BY &quot;chain.table1&quot;.column1, &quot;chain.table1&quot;.column2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="o">*</span><span class="n">columns</span><span class="p">)</span></div>


<div class="viewcode-block" id="Select.having">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.having">[docs]</a>
    <span class="k">def</span> <span class="nf">having</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">having</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Select with the given expression added to its HAVING clause</span>
<span class="sd">        joined to the existing clause via AND, if any.</span>

<span class="sd">        :param having: The HAVING clauses to apply.</span>
<span class="sd">        :type having: ColumnExpressionArgument[bool]</span>
<span class="sd">        :return: A new Select with the HAVING clause applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            having_query = query_1.group_by(query_1.c.column1).having(query_1.c.column1 == 1)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT *</span>
<span class="sd">            FROM &quot;chain.table1&quot;</span>
<span class="sd">            GROUP BY &quot;chain.table1&quot;.column1</span>
<span class="sd">            HAVING &quot;chain.table1&quot;.column1 = 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">having</span><span class="p">(</span><span class="o">*</span><span class="n">having</span><span class="p">)</span></div>


<div class="viewcode-block" id="Select.order_by">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.order_by">[docs]</a>
    <span class="k">def</span> <span class="nf">order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Select with the given list of ORDER BY criteria applied.</span>

<span class="sd">        :param clauses: The ORDER BY criteria to apply.</span>
<span class="sd">        :type clauses: Column</span>
<span class="sd">        :return: A new Select with the ORDER BY criteria applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            order_by_query = query_1.order_by(query_1.c.column1, query_1.c.column2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT *</span>
<span class="sd">            FROM &quot;chain.table1&quot;</span>
<span class="sd">            ORDER BY &quot;chain.table1&quot;.column1, &quot;chain.table1&quot;.column2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">)</span></div>


<div class="viewcode-block" id="Select.join">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.join">[docs]</a>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span>
        <span class="n">onclause</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">isouter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a SQL JOIN against this Select object&#39;s criterion</span>
<span class="sd">        and apply generatively, returning the newly resulting Select.</span>

<span class="sd">        :param target: The target table to join.</span>
<span class="sd">        :type target: Table</span>
<span class="sd">        :param onclause: The ON clause to apply. If omitted, an ON clause is generated automatically based on the ForeignKey linkages between the two tables, if one can be unambiguously determined, otherwise an error is raised.</span>
<span class="sd">        :type onclause: ColumnExpressionArgument, optional</span>
<span class="sd">        :param isouter: Whether to apply an outer join.</span>
<span class="sd">        :type isouter: bool, optional</span>
<span class="sd">        :param full: Whether to apply a full join.</span>
<span class="sd">        :type full: bool, optional</span>
<span class="sd">        :return: A new Select with the join operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            join_query = query_1.join(query_2.table, query_1.c.column1 == query_2.c.column1)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT &quot;chain.table1&quot;.column1, &quot;chain.table1&quot;.column2, &quot;chain.table1&quot;.column3</span>
<span class="sd">            FROM &quot;chain.table1&quot; JOIN &quot;chain.table2&quot;</span>
<span class="sd">            ON &quot;chain.table1&quot;.column1 = &quot;chain.table2&quot;.column1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">onclause</span><span class="o">=</span><span class="n">onclause</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouter</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span></div>


<div class="viewcode-block" id="Select.outerjoin">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.outerjoin">[docs]</a>
    <span class="k">def</span> <span class="nf">outerjoin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span>
        <span class="n">onclause</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a SQL LEFT OUTER JOIN against this Select object&#39;s criterion</span>
<span class="sd">        and apply generatively, returning the newly resulting Select.</span>

<span class="sd">        :param target: The target table to join.</span>
<span class="sd">        :type target: Table</span>
<span class="sd">        :param onclause: The ON clause to apply.</span>
<span class="sd">        :type onclause: ColumnExpressionArgument</span>
<span class="sd">        :param full: Whether to apply a full join.</span>
<span class="sd">        :type full: bool, optional</span>
<span class="sd">        :return: A new Select with the outer join operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            outerjoin_query = query_1.outerjoin(query_2.table, query_1.c.column1 == query_2.c.column1)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT &quot;chain.table1&quot;.column1, &quot;chain.table1&quot;.column2, &quot;chain.table1&quot;.column3</span>
<span class="sd">            FROM &quot;chain.table1&quot; LEFT OUTER JOIN &quot;chain.table2&quot;</span>
<span class="sd">            ON &quot;chain.table1&quot;.column1 = &quot;chain.table2&quot;.column1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span></div>


<div class="viewcode-block" id="Select.outerjoin_from">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.outerjoin_from">[docs]</a>
    <span class="k">def</span> <span class="nf">outerjoin_from</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">from_</span><span class="p">:</span> <span class="n">Column</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span>
        <span class="n">onclause</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a SQL LEFT OUTER JOIN against this Select object&#39;s criterion</span>
<span class="sd">        and apply generatively, returning the newly resulting Select.</span>

<span class="sd">        :param from_: The table to join from.</span>
<span class="sd">        :type from_: Table</span>
<span class="sd">        :param target: The target table to join.</span>
<span class="sd">        :type target: Table</span>
<span class="sd">        :param onclause: The ON clause to apply.</span>
<span class="sd">        :type onclause: ColumnExpressionArgument</span>
<span class="sd">        :param full: Whether to apply a full join.</span>
<span class="sd">        :type full: bool, optional</span>
<span class="sd">        :return: A new Select with the outer join operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            outerjoin_from_query = query_1.outerjoin_from(query_1.table, query_2.table, query_1.c.column1 == query_2.c.column1)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT *</span>
<span class="sd">            FROM &quot;chain.table1&quot; LEFT OUTER JOIN &quot;chain.table2&quot;</span>
<span class="sd">            ON &quot;chain.table1&quot;.column1 = &quot;chain.table2&quot;.column1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">outerjoin_from</span><span class="p">(</span><span class="n">from_</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">onclause</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span></div>


<div class="viewcode-block" id="Select.distinct">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.distinct">[docs]</a>
    <span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Select which will apply DISTINCT operation applied.</span>

<span class="sd">        :return: A new subquery with the DISTINCT operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            distinct_query = query_1.distinct()</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT DISTINCT *</span>
<span class="sd">            FROM &quot;chain.table1&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span></div>


<div class="viewcode-block" id="Select.exists">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.exists">[docs]</a>
    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new subquery which will apply an EXISTS clause to the SELECT statement overall.</span>

<span class="sd">        :return: A new subquery with the EXISTS operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            query_1 = query_1.where(query_1.c.column1 == 1)</span>
<span class="sd">            exists_query = query_1.exists()</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            EXISTS (SELECT * FROM &quot;chain.table1&quot; WHERE &quot;chain.table1&quot;.column1 = 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span></div>


<div class="viewcode-block" id="Select.alias">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.alias">[docs]</a>
    <span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Select object with the given name as an alias.</span>

<span class="sd">        :param name: The name of the alias.</span>
<span class="sd">        :type name: str, optional</span>
<span class="sd">        :return: A new Select with the alias applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            alias_query = query_1.alias(name=&quot;alias&quot;)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table1&quot; AS alias</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


    <span class="c1"># Overriding compound select methods</span>

<div class="viewcode-block" id="Select.union">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.union">[docs]</a>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Select&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SQL UNION alias of this Select against the</span>
<span class="sd">        given selectables provided as positional arguments.</span>

<span class="sd">        A union is the set of all rows returned by either the left or right</span>
<span class="sd">        selectables. If a row is present in both selectables, it will appear</span>
<span class="sd">        in the result set only once.</span>

<span class="sd">        :param other: One or more Selects with which to union.</span>
<span class="sd">        :type other: Select</span>
<span class="sd">        :return: A new Select with the union operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            union_query = query_1.union(query_2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT anon_1.column1</span>
<span class="sd">            FROM (SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table1&quot; UNION SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table1&quot; UNION SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table2&quot;) AS anon_1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">())</span></div>


<div class="viewcode-block" id="Select.union_all">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.union_all">[docs]</a>
    <span class="k">def</span> <span class="nf">union_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Select&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SQL UNION ALL alias of this Select against</span>
<span class="sd">        the given selectables provided as positional arguments.</span>

<span class="sd">        :param other: One or more Selects with which to union all.</span>
<span class="sd">        :type other: Select</span>
<span class="sd">        :return: A new Select with the union all operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            union_all_query = query_1.union_all(query_2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT anon_1.column1</span>
<span class="sd">            FROM (SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table2&quot; UNION ALL SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table2&quot; UNION ALL SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table1&quot;) AS anon_1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">())</span></div>


<div class="viewcode-block" id="Select.except_">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.except_">[docs]</a>
    <span class="k">def</span> <span class="nf">except_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Select&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SQL EXCEPT alias of this Select against the</span>
<span class="sd">        given selectables provided as positional arguments.</span>

<span class="sd">        :param other: One or more Select with which to except.</span>
<span class="sd">        :type other: Select</span>
<span class="sd">        :return: A new Select with the except operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            except_query = query_1.except_(query_2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT *</span>
<span class="sd">            FROM (SELECT anon_1.column1 AS column1</span>
<span class="sd">            FROM (SELECT &quot;chain.table&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table&quot; EXCEPT SELECT &quot;chain.table&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table&quot; EXCEPT SELECT &quot;chain.table&quot;.column2 AS column2</span>
<span class="sd">            FROM &quot;chain.table&quot;) AS anon_1) AS anon_1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">except_</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">())</span></div>


<div class="viewcode-block" id="Select.except_all">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.except_all">[docs]</a>
    <span class="k">def</span> <span class="nf">except_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Select&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SQL EXCEPT ALL alias of this Select against the</span>
<span class="sd">        given selectables provided as positional arguments.</span>

<span class="sd">        :param other: One or more Selects with which to except all.</span>
<span class="sd">        :type other: Select</span>
<span class="sd">        :return: A new Select with the except all operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            except_all_query = query_1.except_all(query_2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">            SELECT *</span>
<span class="sd">            FROM (SELECT &quot;chain.name&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.name&quot; EXCEPT ALL SELECT &quot;chain.name&quot;.column2 AS column2</span>
<span class="sd">            FROM &quot;chain.name&quot;) AS anon_1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">except_all</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">())</span></div>


<div class="viewcode-block" id="Select.intersect">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.intersect">[docs]</a>
    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Select&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SQL INTERSECT alias of this Select against the</span>
<span class="sd">        given selectables provided as positional arguments.</span>

<span class="sd">        :param other: One or more Selects with which to intersect.</span>
<span class="sd">        :type other: Select</span>
<span class="sd">        :return: A new Select with the intersect operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            intersect_query = query_1.intersect(query_2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT anon_1.column1</span>
<span class="sd">            FROM (SELECT &quot;chain.table&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table&quot; INTERSECT SELECT &quot;chain.table&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table&quot; INTERSECT SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table2&quot;) AS anon_1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">())</span></div>


<div class="viewcode-block" id="Select.intersect_all">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.intersect_all">[docs]</a>
    <span class="k">def</span> <span class="nf">intersect_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Select&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SQL INTERSECT ALL alias of this Select against</span>
<span class="sd">        the given selectables provided as positional arguments.</span>

<span class="sd">        :param other: One or more Selects with which to intersect all.</span>
<span class="sd">        :type other: Select</span>
<span class="sd">        :return: A new Select with the intersect all operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            intersect_all_query = query_1.intersect_all(query_2)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT anon_1.column1</span>
<span class="sd">            FROM (SELECT &quot;chain.table&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table&quot; INTERSECT ALL SELECT &quot;chain.table&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table&quot; INTERSECT ALL SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table2&quot;) AS anon_1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">intersect_all</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">())</span></div>


<div class="viewcode-block" id="Select.lateral">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.lateral">[docs]</a>
    <span class="k">def</span> <span class="nf">lateral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Select&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SQL LATERAL alias of this Select against</span>
<span class="sd">        the given selectables provided as positional arguments.</span>

<span class="sd">        :param name: The name of the lateral selection.</span>
<span class="sd">        :type name: str, optional</span>
<span class="sd">        :return: A new Select with the lateral operation applied.</span>
<span class="sd">        :rtype: Select</span>

<span class="sd">        E.g.::</span>

<span class="sd">            lateral_query = query_1.lateral(name=&quot;alias&quot;)</span>

<span class="sd">        The resulting SQL query will be:</span>

<span class="sd">        .. code-block:: sql</span>

<span class="sd">            SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table1&quot; LATERAL AS alias</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_columns</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">lateral</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">())</span></div>


<div class="viewcode-block" id="Select.sql">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.sql">[docs]</a>
    <span class="k">def</span> <span class="nf">sql</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile the query into a raw SQL string.</span>

<span class="sd">        :return: The compiled SQL query as a string.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;literal_binds&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span><span class="o">.</span><span class="n">string</span></div>


<div class="viewcode-block" id="Select.get_table">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.get_table">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="n">table</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Table</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a SQLAlchemy Table object for the given chain and table name.</span>

<span class="sd">        :param chain: The chain name.</span>
<span class="sd">        :param table: The table name.</span>
<span class="sd">        :return: A SQLAlchemy Table object.</span>
<span class="sd">        :rtype: Table</span>
<span class="sd">        :raises ValueException: If the chain or table does not exist in the database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;get_table method must be implemented by child classes.&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Select.execute">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.Select.execute">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Transactional</span><span class="p">,</span> <span class="n">Analytical</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the query and create a Transactional or Analytical object.</span>

<span class="sd">        :return: Transactional or Analytical object.</span>
<span class="sd">        :rtype: Union[Transactional, Analytical]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Execute method must be implemented by child classes.&quot;</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="union">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.union">[docs]</a>
<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">:</span> <span class="n">Select</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an SQL UNION of all the given Selects provided as</span>
<span class="sd">    positional arguments.</span>

<span class="sd">    :param selects: A list of Selects to union.</span>
<span class="sd">    :type selects: Select</span>
<span class="sd">    :return: A new Select with the union operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import union</span>

<span class="sd">        union_query = union(table1, table2)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table1&quot; UNION SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table2&quot;,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">)</span></div>



<div class="viewcode-block" id="union_all">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.union_all">[docs]</a>
<span class="k">def</span> <span class="nf">union_all</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">:</span> <span class="n">Select</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an UNION ALL of multiple Selects.</span>

<span class="sd">    :param selects: A list of Selects to union all.</span>
<span class="sd">    :type selects: Select</span>
<span class="sd">    :return: A new Select with the union all operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import union_all</span>

<span class="sd">        union_all_query = union_all(query_1, query_2)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table1&quot; UNION ALL SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table2&quot;,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">)</span></div>



<div class="viewcode-block" id="except_">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.except_">[docs]</a>
<span class="k">def</span> <span class="nf">except_</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">:</span> <span class="n">Select</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an SQL EXCEPT of all the given Selects provided as</span>
<span class="sd">    positional arguments.</span>

<span class="sd">    :param selects: A list of Selects to except.</span>
<span class="sd">    :type selects: Select</span>
<span class="sd">    :return: A new Select with the except operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import except_</span>

<span class="sd">        except_query = except_(query_1, query_2)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table1&quot; EXCEPT SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table2&quot;,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">except_</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">)</span></div>



<div class="viewcode-block" id="except_all">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.except_all">[docs]</a>
<span class="k">def</span> <span class="nf">except_all</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">:</span> <span class="n">Select</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an SQL EXCEPT ALL of all the given Selects provided as</span>
<span class="sd">    positional arguments.</span>

<span class="sd">    :param selects: A list of Selects to except all.</span>
<span class="sd">    :type selects: Select</span>
<span class="sd">    :return: A new Select with the except all operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import except_all</span>

<span class="sd">        except_all_query = except_all(query_1, query_2)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table1&quot; EXCEPT ALL SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table2&quot;,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">except_all</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">)</span></div>



<div class="viewcode-block" id="intersect">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.intersect">[docs]</a>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">:</span> <span class="n">Select</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an SQL INTERSECT of all the given Selects provided as</span>
<span class="sd">    positional arguments.</span>

<span class="sd">    :param selects: A list of Selects to intersect.</span>
<span class="sd">    :type selects: Select</span>
<span class="sd">    :return: A new Select with the intersect operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import intersect</span>

<span class="sd">        query = intersect(table1, table2)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table1&quot; INTERSECT SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table2&quot;,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">)</span></div>



<div class="viewcode-block" id="intersect_all">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.intersect_all">[docs]</a>
<span class="k">def</span> <span class="nf">intersect_all</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">:</span> <span class="n">Select</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an SQL INTERSECT ALL of all the given Selects provided as</span>
<span class="sd">    positional arguments.</span>

<span class="sd">    :param selects: A list of Selects to intersect all.</span>
<span class="sd">    :type selects: Select</span>
<span class="sd">    :return: A new Selects with the intersect all operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import intersect_all</span>

<span class="sd">        query = intersect_all(table1, table2)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table1&quot; INTERSECT ALL SELECT &quot;chain.table2&quot;.column1 AS column1</span>
<span class="sd">        FROM &quot;chain.table2&quot;,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">intersect_all</span><span class="p">(</span><span class="o">*</span><span class="n">selects</span><span class="p">)</span></div>



<div class="viewcode-block" id="lateral">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.lateral">[docs]</a>
<span class="k">def</span> <span class="nf">lateral</span><span class="p">(</span><span class="n">select</span><span class="p">:</span> <span class="n">Select</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an SQL LATERAL of this Select</span>

<span class="sd">    :param select: A Select to lateral.</span>
<span class="sd">    :type select: Select</span>
<span class="sd">    :param name: The name of the lateral Select.</span>
<span class="sd">    :type name: str, optional</span>
<span class="sd">    :return: A new Select with the lateral operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">            from chainalysis.data_solutions_table import lateral</span>

<span class="sd">            query = lateral(table1, name=&quot;alias&quot;)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">            SELECT &quot;chain.table1&quot;.column1 AS column1</span>
<span class="sd">            FROM &quot;chain.table1&quot; LATERAL AS alias</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">lateral</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>



<div class="viewcode-block" id="join">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.join">[docs]</a>
<span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span>
    <span class="n">onclause</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">isouter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">full</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new Select object, joining two tables.</span>

<span class="sd">    :param left: The left table to join.</span>
<span class="sd">    :type left: Table</span>
<span class="sd">    :param right: The right table to join.</span>
<span class="sd">    :type right: Table</span>
<span class="sd">    :param onclause: The ON clause to apply.</span>
<span class="sd">    :type onclause: ColumnExpressionArgument, optional</span>
<span class="sd">    :param isouter: Whether to apply an outer join.</span>
<span class="sd">    :type isouter: bool, optional</span>
<span class="sd">    :param full: Whether to apply a full join.</span>
<span class="sd">    :type full: bool, optional</span>
<span class="sd">    :return: A new Select with the join operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import join</span>

<span class="sd">        join_query = join(query_1.table, query_2.table_2, table1.c.column1 == table2.c.column1)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT *</span>
<span class="sd">        FROM &quot;chain.table1&quot;</span>
<span class="sd">        JOIN &quot;chain.table2&quot; ON &quot;chain.table1&quot;.column1 = &quot;chain.table2&quot;.column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="o">=</span><span class="n">onclause</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouter</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span></div>



<div class="viewcode-block" id="outerjoin">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.outerjoin">[docs]</a>
<span class="k">def</span> <span class="nf">outerjoin</span><span class="p">(</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Table</span><span class="p">,</span>
    <span class="n">onclause</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new Select object, joining two tables with a LEFT OUTER JOIN.</span>

<span class="sd">    :param left: The left table to join.</span>
<span class="sd">    :type left: Table</span>
<span class="sd">    :param right: The right table to join.</span>
<span class="sd">    :type right: Table</span>
<span class="sd">    :param onclause: The ON clause to apply.</span>
<span class="sd">    :type onclause: ColumnExpressionArgument</span>
<span class="sd">    :param full: Whether to apply a full join.</span>
<span class="sd">    :type full: bool, optional</span>
<span class="sd">    :return: A new Select with the outer join operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import outerjoin</span>

<span class="sd">        outerjoin_query = outerjoin(</span>
<span class="sd">            left=query_1.table,</span>
<span class="sd">            right=query_2.table,</span>
<span class="sd">            onclause=query_1.c.column1 == query_2.c.column1</span>
<span class="sd">        )</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">            SELECT *</span>
<span class="sd">            FROM &quot;chain.table1&quot;</span>
<span class="sd">            LEFT OUTER JOIN &quot;chain.table2&quot;</span>
<span class="sd">            ON &quot;chain.table1&quot;.column1 = &quot;chain.table2&quot;.column1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">onclause</span><span class="o">=</span><span class="n">onclause</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span></div>



<div class="viewcode-block" id="distinct">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.distinct">[docs]</a>
<span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="n">column</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an column-expression-level DISTINCT clause.</span>

<span class="sd">    :param column: The column to apply DISTINCT to.</span>
<span class="sd">    :type column: Column</span>
<span class="sd">    :return: A new Select with the DISTINCT operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import distinct</span>

<span class="sd">        distinct_query = distinct(query_1)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT DISTINCT *</span>
<span class="sd">        FROM &quot;chain.table1&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="n">column</span><span class="p">)</span></div>



<div class="viewcode-block" id="exists">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.exists">[docs]</a>
<span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="n">select</span><span class="p">:</span> <span class="n">Select</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subquery</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an EXISTS clause.</span>

<span class="sd">    :return: A new Select with the EXISTS operation applied.</span>
<span class="sd">    :rtype: Select</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import exists</span>

<span class="sd">        stmt = query.with_columns().where(query.c.column1 == 1)</span>
<span class="sd">        exists_query = exists(stmt)</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        EXISTS (SELECT * FROM &quot;chain.table1&quot; WHERE &quot;chain.table1&quot;.column1 = 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">select</span><span class="p">)</span></div>



<div class="viewcode-block" id="and_">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.and_">[docs]</a>
<span class="k">def</span> <span class="nf">and_</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnExpressionArgument</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a conjunction of expressions joined by an AND.</span>

<span class="sd">    :param clauses: The expressions to join.</span>
<span class="sd">    :type clauses: ColumnExpressionArgument</span>
<span class="sd">    :return: A new conjunction of expressions.</span>
<span class="sd">    :rtype: ColumnExpressionArgument</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import and_</span>

<span class="sd">        and_query = query_1.where(</span>
<span class="sd">            and_(</span>
<span class="sd">                query_1.c.column1 == 1,</span>
<span class="sd">                query_1.c.column2 == 2</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT * FROM &quot;chain.table1&quot;</span>
<span class="sd">        WHERE &quot;chain.table1&quot;.column1 = 1 AND &quot;chain.table1&quot;.column2 = 2</span>

<span class="sd">    Python&#39;s &amp; operator can also be used to create an AND clause::</span>

<span class="sd">        and_query = (query_1.c.column1 == 1) &amp; (query_1.c.column2 == 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">)</span></div>



<div class="viewcode-block" id="or_">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.or_">[docs]</a>
<span class="k">def</span> <span class="nf">or_</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnExpressionArgument</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a conjunction of expressions joined by an OR.</span>

<span class="sd">    :param clauses: The expressions to join.</span>
<span class="sd">    :type clauses: ColumnExpressionArgument</span>
<span class="sd">    :return: A new conjunction of expressions.</span>
<span class="sd">    :rtype: ColumnExpressionArgument</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import or_</span>

<span class="sd">        or_query = query_1.where(</span>
<span class="sd">            or_(</span>
<span class="sd">                query_1.c.column1 == 1,</span>
<span class="sd">                query_1.c.column2 == 2</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT * FROM &quot;chain.table1&quot;</span>
<span class="sd">        WHERE &quot;chain.table1&quot;.column1 = 1 OR &quot;chain.table1&quot;.column2 = 2</span>

<span class="sd">    Python&#39;s | operator can also be used to create an OR clause::</span>

<span class="sd">        or_query = (query_1.c.column1 == 1) | (query_1.c.column2 == 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">or_</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">)</span></div>



<div class="viewcode-block" id="not_">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.not_">[docs]</a>
<span class="k">def</span> <span class="nf">not_</span><span class="p">(</span><span class="n">clause</span><span class="p">:</span> <span class="n">ColumnExpressionArgument</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnExpressionArgument</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a negation of a clause.</span>

<span class="sd">    :param clause: The clause to negate.</span>
<span class="sd">    :type clause: ColumnExpressionArgument</span>
<span class="sd">    :return: A new negated clause.</span>
<span class="sd">    :rtype: ColumnExpressionArgument</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import not_</span>

<span class="sd">        not_query = query_1.where(not_(query_1.c.column1 == 1))</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT * FROM &quot;chain.table1&quot;</span>
<span class="sd">        WHERE NOT &quot;chain.table1&quot;.column1 = 1</span>

<span class="sd">    Python&#39;s ~ operator can also be used to negate a clause::</span>

<span class="sd">        not_query = ~(query_1.c.column1 == 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">not_</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span></div>



<div class="viewcode-block" id="between">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.between">[docs]</a>
<span class="k">def</span> <span class="nf">between</span><span class="p">(</span>
    <span class="n">column</span><span class="p">:</span> <span class="n">Column</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">symmetric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnExpressionArgument</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a BETWEEN predicate clause.</span>

<span class="sd">    :param column: The column to apply the BETWEEN clause to.</span>
<span class="sd">    :type column: Column</span>
<span class="sd">    :param lower_bound: The lower bound of the BETWEEN clause.</span>
<span class="sd">    :type lower_bound: Any</span>
<span class="sd">    :param upper_bound: The upper bound of the BETWEEN clause.</span>
<span class="sd">    :type upper_bound: Any</span>
<span class="sd">    :param symmetric: Whether to apply a symmetric BETWEEN clause.</span>
<span class="sd">    :type symmetric: bool, optional</span>
<span class="sd">    :return: A new BETWEEN clause.</span>
<span class="sd">    :rtype: ColumnExpressionArgument</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import between</span>

<span class="sd">        between_query = query_1.where(between(query_1.c.column1, 1, 10))</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT * FROM &quot;chain.table1&quot;</span>
<span class="sd">        WHERE &quot;chain.table1&quot;.column1 BETWEEN 1 AND 10</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">symmetric</span><span class="p">)</span></div>



<div class="viewcode-block" id="case">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.case">[docs]</a>
<span class="k">def</span> <span class="nf">case</span><span class="p">(</span>
    <span class="o">*</span><span class="n">whens</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">else_</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnExpressionArgument</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a CASE expression.</span>

<span class="sd">    :param whens: The WHEN clauses to apply.</span>
<span class="sd">    :type whens: Any</span>
<span class="sd">    :param value: The value to compare.</span>
<span class="sd">    :type value: Any, optional</span>
<span class="sd">    :param else_: The ELSE clause to apply.</span>
<span class="sd">    :return: A new CASE expression.</span>
<span class="sd">    :rtype: ColumnExpressionArgument</span>

<span class="sd">    E.g. using whens::</span>

<span class="sd">        from chainalysis.data_solutions_table import case</span>

<span class="sd">        case_query = query_1.with_columns(</span>
<span class="sd">            case(</span>
<span class="sd">                (query_1.c.column1 == 1, &quot;one&quot;),</span>
<span class="sd">                (query_1.c.column2 == 2, &quot;two&quot;),</span>
<span class="sd">                else_=&quot;three&quot;</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT</span>
<span class="sd">            CASE</span>
<span class="sd">                WHEN &quot;chain.table1&quot;.column1 = 1 THEN &#39;one&#39;</span>
<span class="sd">                WHEN &quot;chain.table1&quot;.column2 = 2 THEN &#39;two&#39;</span>
<span class="sd">                ELSE &#39;three&#39;</span>
<span class="sd">            END</span>

<span class="sd">    E.g. using value::</span>

<span class="sd">        from chainalysis.data_solutions_table import case</span>

<span class="sd">        case_query = query_1.with_columns(</span>
<span class="sd">            case(</span>
<span class="sd">                {</span>
<span class="sd">                    query_1.c.column1: &quot;one&quot;,</span>
<span class="sd">                    query_1.c.column2: &quot;two&quot;</span>
<span class="sd">                },</span>
<span class="sd">                value=query_1.c.column1,</span>
<span class="sd">                else_=&quot;three&quot;</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT</span>
<span class="sd">            CASE &quot;chain.table1&quot;.column1</span>
<span class="sd">                WHEN &quot;chain.table1&quot;.column1 THEN &#39;one&#39;</span>
<span class="sd">                WHEN &quot;chain.table1&quot;.column2 THEN &#39;two&#39;</span>
<span class="sd">                ELSE &#39;three&#39;</span>
<span class="sd">            END</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">case</span><span class="p">(</span><span class="o">*</span><span class="n">whens</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">else_</span><span class="o">=</span><span class="n">else_</span><span class="p">)</span></div>



<div class="viewcode-block" id="literal">
<a class="viewcode-back" href="../../../chainalysis.orm.html#chainalysis.orm.select.literal">[docs]</a>
<span class="k">def</span> <span class="nf">literal</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnExpressionArgument</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a literal clause, bound to a bind parameter.</span>

<span class="sd">    :param value: The value to bind.</span>
<span class="sd">    :type value: Any</span>
<span class="sd">    :return: A new literal clause.</span>
<span class="sd">    :rtype: ColumnExpressionArgument</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from chainalysis.data_solutions_table import literal</span>

<span class="sd">        literal_query = query_1.with_columns(</span>
<span class="sd">            query_1.c.column1,</span>
<span class="sd">            literal(1).label(&quot;one&quot;)</span>
<span class="sd">        )</span>

<span class="sd">    The resulting SQL query will be:</span>

<span class="sd">    .. code-block:: sql</span>

<span class="sd">        SELECT &quot;chain.table&quot;.column1, 1 AS one</span>
<span class="sd">        FROM &quot;chain.table&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>



<span class="n">func</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">func</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Rah Tarar, Kurt Bugbee
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=fe7df9b0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    </body>
</html>