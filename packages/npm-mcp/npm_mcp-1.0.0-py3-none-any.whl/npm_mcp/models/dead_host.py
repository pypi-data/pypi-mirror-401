"""
DeadHost Pydantic model for Nginx Proxy Manager.

This module defines the DeadHost model representing 404/catch-all handler
configurations in Nginx Proxy Manager.
"""

from datetime import datetime
from typing import Any

from pydantic import BaseModel, Field, field_validator


class DeadHost(BaseModel):
    """
    Pydantic model for Nginx Proxy Manager Dead Host.

    A dead host serves as a 404 handler or catch-all configuration for
    domain names that don't have specific proxy host configurations.

    Attributes:
        id: Unique identifier (auto-generated by NPM)
        created_on: Timestamp when the dead host was created
        modified_on: Timestamp when the dead host was last modified
        domain_names: List of domain names for this 404 handler
        certificate_id: ID of SSL certificate (if SSL is used)
        ssl_forced: Whether to force SSL (redirect HTTP to HTTPS)
        hsts_enabled: Whether to enable HTTP Strict Transport Security
        hsts_subdomains: Whether to include subdomains in HSTS
        http2_support: Whether to enable HTTP/2 support
        advanced_config: Custom Nginx configuration
        enabled: Whether this dead host is enabled
        meta: Additional metadata as key-value pairs

    Example:
        >>> # Simple 404 handler
        >>> dead_host = DeadHost(
        ...     domain_names=["404.example.com"],
        ... )
        >>> dead_host.enabled
        True

        >>> # 404 handler with SSL
        >>> dead_host = DeadHost(
        ...     domain_names=["*.example.com"],
        ...     certificate_id=10,
        ...     ssl_forced=True,
        ... )
        >>> dead_host.certificate_id
        10

        >>> # Custom 404 page configuration
        >>> dead_host = DeadHost(
        ...     domain_names=["404.example.com"],
        ...     advanced_config="error_page 404 /404.html;",
        ... )
        >>> "404" in dead_host.advanced_config
        True
    """

    # Identifiers
    id: int | None = None
    created_on: datetime | None = None
    modified_on: datetime | None = None

    # Domain configuration
    domain_names: list[str] = Field(..., min_length=1)

    # SSL/TLS configuration
    certificate_id: int | None = None
    ssl_forced: bool = False
    hsts_enabled: bool = False
    hsts_subdomains: bool = False

    # Feature flags
    http2_support: bool = False

    # Advanced configuration
    advanced_config: str | None = None

    # Status
    enabled: bool = True

    # Metadata
    meta: dict[str, Any] = Field(default_factory=dict)

    @field_validator("domain_names")
    @classmethod
    def validate_domain_names(cls, v: list[str]) -> list[str]:
        """
        Validate that domain_names is not empty.

        Args:
            v: List of domain names

        Returns:
            Validated list of domain names

        Raises:
            ValueError: If domain_names is empty
        """
        if not v:
            msg = "domain_names cannot be empty"
            raise ValueError(msg)
        return v

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "domain_names": ["404.example.com"],
                },
                {
                    "domain_names": ["*.example.com"],
                    "certificate_id": 10,
                    "ssl_forced": True,
                },
            ]
        }
    }
