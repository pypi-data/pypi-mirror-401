"""
gstaichi_python
"""
from __future__ import annotations
import numpy
import typing
__all__: list[str] = ['ADJOINT', 'ADJOINT_CHECKBIT', 'AOS', 'ASTBuilder', 'Arch', 'AutodiffMode', 'Axis', 'Benchmark', 'BinaryOpType', 'BitStructType', 'BitStructTypeBuilder', 'BoundaryMode', 'CC', 'CE', 'CF', 'CGd', 'CGf', 'CLAMP', 'CUCG', 'CV', 'Cell', 'CompileConfig', 'CompileResult', 'CompiledKernelData', 'Config', 'ConvType', 'CuSparseMatrix', 'CuSparseSolver', 'DUAL', 'DataTypeCxx', 'DataType_f16', 'DataType_f32', 'DataType_f64', 'DataType_gen', 'DataType_i16', 'DataType_i32', 'DataType_i64', 'DataType_i8', 'DataType_u1', 'DataType_u16', 'DataType_u32', 'DataType_u64', 'DataType_u8', 'DataType_unknown', 'DebugInfo', 'DeviceAllocation', 'DeviceCapability', 'DeviceCapabilityConfig', 'EC', 'EE', 'EF', 'EV', 'Edge', 'EigenSparseSolverfloat32LDLTAMD', 'EigenSparseSolverfloat32LDLTCOLAMD', 'EigenSparseSolverfloat32LLTAMD', 'EigenSparseSolverfloat32LLTCOLAMD', 'EigenSparseSolverfloat32LUAMD', 'EigenSparseSolverfloat32LUCOLAMD', 'EigenSparseSolverfloat64LDLTAMD', 'EigenSparseSolverfloat64LDLTCOLAMD', 'EigenSparseSolverfloat64LLTAMD', 'EigenSparseSolverfloat64LLTCOLAMD', 'EigenSparseSolverfloat64LUAMD', 'EigenSparseSolverfloat64LUCOLAMD', 'ExprCxx', 'ExprGroup', 'Extension', 'FC', 'FE', 'FF', 'FORWARD', 'FV', 'Face', 'Format', 'Function', 'FunctionKey', 'GsTaichiAssertionError', 'GsTaichiIndexError', 'GsTaichiRuntimeError', 'GsTaichiSyntaxError', 'GsTaichiTypeError', 'HackedSignalRegister', 'InternalOp', 'KernelCxx', 'KernelLaunchContext', 'KernelProfileTracedRecord', 'KernelProfilerQueryResult', 'Layout', 'Mesh', 'MeshElementType', 'MeshPtr', 'MeshRelationType', 'MeshTopology', 'NONE', 'NULL', 'NdarrayCxx', 'Operation', 'PRIMAL', 'Program', 'REVERSE', 'SNodeAccessFlag', 'SNodeCxx', 'SNodeGradType', 'SNodeRegistry', 'SNodeTreeCxx', 'SNodeType', 'SOA', 'SparseMatrix', 'SparseMatrixBuilder', 'SparseSolver', 'Stmt', 'Task', 'Tetrahedron', 'Triangle', 'Type', 'TypeFactory', 'UNSAFE', 'UnaryOpType', 'VALIDATION', 'VC', 'VE', 'VF', 'VV', 'Vector2d', 'Vector2f', 'Vector2i', 'Vector3d', 'Vector3f', 'Vector3i', 'Vector4d', 'Vector4f', 'Vector4i', 'Vertex', 'abs', 'acos', 'add', 'adstack', 'amdgpu', 'arch_from_name', 'arch_name', 'arch_uses_llvm', 'arm64', 'asin', 'assertion', 'atan2', 'bit_and', 'bit_not', 'bit_or', 'bit_sar', 'bit_shl', 'bit_shr', 'bit_struct', 'bit_xor', 'bitmasked', 'bits_cast', 'block_local', 'bls', 'cast_bits', 'cast_value', 'ceil', 'clear_profile_info', 'clz', 'cmp_eq', 'cmp_ge', 'cmp_gt', 'cmp_le', 'cmp_lt', 'cmp_ne', 'cos', 'create_benchmark', 'create_initialized_benchmark', 'create_initialized_task', 'create_mesh', 'create_task', 'critical', 'cuda', 'dColMajor_EigenSparseMatrix', 'dRowMajor_EigenSparseMatrix', 'data64', 'data_type_name', 'data_type_size', 'debug', 'default_compile_config', 'dense', 'div', 'dynamic', 'element_order', 'element_type_name', 'error', 'exp', 'expr_abs', 'expr_acos', 'expr_add', 'expr_asin', 'expr_assume_in_range', 'expr_atan2', 'expr_atomic_add', 'expr_atomic_bit_and', 'expr_atomic_bit_or', 'expr_atomic_bit_xor', 'expr_atomic_max', 'expr_atomic_min', 'expr_atomic_mul', 'expr_atomic_sub', 'expr_bit_and', 'expr_bit_not', 'expr_bit_or', 'expr_bit_sar', 'expr_bit_shl', 'expr_bit_shr', 'expr_bit_xor', 'expr_ceil', 'expr_clz', 'expr_cmp_eq', 'expr_cmp_ge', 'expr_cmp_gt', 'expr_cmp_le', 'expr_cmp_lt', 'expr_cmp_ne', 'expr_cos', 'expr_div', 'expr_exp', 'expr_field', 'expr_floor', 'expr_floordiv', 'expr_frexp', 'expr_ifte', 'expr_inv', 'expr_log', 'expr_logic_not', 'expr_logical_and', 'expr_logical_or', 'expr_loop_unique', 'expr_matrix_field', 'expr_max', 'expr_min', 'expr_mod', 'expr_mul', 'expr_neg', 'expr_popcnt', 'expr_pow', 'expr_rcp', 'expr_round', 'expr_rsqrt', 'expr_select', 'expr_sin', 'expr_sqrt', 'expr_sub', 'expr_tan', 'expr_tanh', 'expr_truediv', 'extfunc', 'fColMajor_EigenSparseMatrix', 'fRowMajor_EigenSparseMatrix', 'finalize_snode_tree', 'floor', 'floordiv', 'flush_log', 'frexp', 'from_end_element_order', 'g2r', 'get_commit_hash', 'get_default_float_size', 'get_external_tensor_dim', 'get_external_tensor_element_dim', 'get_external_tensor_element_shape', 'get_external_tensor_element_type', 'get_external_tensor_needs_grad', 'get_external_tensor_real_func_args', 'get_external_tensor_shape_along_axis', 'get_llvm_target_support', 'get_max_num_indices', 'get_num_elements', 'get_python_package_dir', 'get_relation_access', 'get_relation_size', 'get_repo_dir', 'get_type_factory_instance', 'get_version_major', 'get_version_minor', 'get_version_patch', 'get_version_string', 'hash', 'host_arch', 'info', 'insert_internal_func_call', 'inv', 'inverse_relation', 'is_extension_supported', 'is_integral', 'is_quant', 'is_real', 'is_signed', 'is_tensor', 'is_unsigned', 'js', 'l2g', 'l2r', 'libdevice_path', 'log', 'logging_effective', 'logic_not', 'make_arg_load_expr', 'make_binary_op_expr', 'make_const_expr_bool', 'make_const_expr_fp', 'make_const_expr_int', 'make_cucg_solver', 'make_cusparse_solver', 'make_double_cg_solver', 'make_external_tensor_expr', 'make_external_tensor_grad_expr', 'make_float_cg_solver', 'make_frontend_assign_stmt', 'make_get_element_expr', 'make_global_load_stmt', 'make_global_store_stmt', 'make_rand_expr', 'make_reference', 'make_sparse_solver', 'make_unary_op_expr', 'max', 'mesh', 'mesh_local', 'metal', 'min', 'mod', 'mul', 'neg', 'opencl', 'place', 'pointer', 'pop_python_print_buffer', 'popcnt', 'pow', 'print_all_units', 'print_profile_info', 'promoted_type', 'quant', 'quant_array', 'quant_basic', 'query_int64', 'rcp', 'read_only', 'relation_by_orders', 'reserved', 'reset_default_compile_config', 'root', 'round', 'rsqrt', 'set_core_state_python_imported', 'set_core_trigger_gdb_when_crash', 'set_index_mapping', 'set_lib_dir', 'set_logging_level', 'set_logging_level_default', 'set_num_elements', 'set_num_patches', 'set_owned_offset', 'set_patch_max_element_num', 'set_python_package_dir', 'set_relation_dynamic', 'set_relation_fixed', 'set_tmp_dir', 'set_total_offset', 'set_vulkan_visible_device', 'sgn', 'sin', 'sparse', 'spirv_has_atomic_float', 'spirv_has_atomic_float16', 'spirv_has_atomic_float16_add', 'spirv_has_atomic_float16_minmax', 'spirv_has_atomic_float64', 'spirv_has_atomic_float64_add', 'spirv_has_atomic_float64_minmax', 'spirv_has_atomic_float_add', 'spirv_has_atomic_float_minmax', 'spirv_has_atomic_int64', 'spirv_has_float16', 'spirv_has_float64', 'spirv_has_int16', 'spirv_has_int64', 'spirv_has_int8', 'spirv_has_no_integer_wrap_decoration', 'spirv_has_non_semantic_info', 'spirv_has_physical_storage_buffer', 'spirv_has_shader_clock', 'spirv_has_subgroup_arithmetic', 'spirv_has_subgroup_ballot', 'spirv_has_subgroup_basic', 'spirv_has_subgroup_vote', 'spirv_has_variable_ptr', 'spirv_version', 'sqrt', 'start_memory_monitoring', 'sub', 'subscript_with_multiple_indices', 'tan', 'tanh', 'test_cpp_exception', 'test_logging', 'test_printf', 'test_raise_error', 'test_threading', 'test_throw', 'to_end_element_order', 'toggle_python_print_buffer', 'trace', 'trigger_crash', 'trigger_sig_fpe', 'truediv', 'undefined', 'value_cast', 'vulkan', 'wait_for_debugger', 'warn', 'with_amdgpu', 'with_cuda', 'with_metal', 'with_vulkan', 'x64']
class ASTBuilder:
    def begin_frontend_if(self, arg0: ..., arg1: DebugInfo) -> None:
        ...
    def begin_frontend_if_false(self) -> None:
        ...
    def begin_frontend_if_true(self) -> None:
        ...
    def begin_frontend_mesh_for(self, arg0: ..., arg1: ..., arg2: ..., arg3: DebugInfo) -> None:
        ...
    def begin_frontend_range_for(self, arg0: ..., arg1: ..., arg2: ..., arg3: DebugInfo) -> None:
        ...
    def begin_frontend_struct_for_on_external_tensor(self, arg0: ..., arg1: ..., arg2: DebugInfo) -> None:
        ...
    def begin_frontend_struct_for_on_snode(self, arg0: ..., arg1: ..., arg2: DebugInfo) -> None:
        ...
    def begin_frontend_while(self, arg0: ..., arg1: DebugInfo) -> None:
        ...
    def begin_func(self, arg0: str) -> None:
        ...
    def bit_vectorize(self) -> None:
        ...
    def block_dim(self, arg0: int) -> None:
        ...
    def create_assert_stmt(self, arg0: ..., arg1: str, arg2: list[...], arg3: DebugInfo) -> None:
        ...
    def create_kernel_exprgroup_return(self, arg0: ..., arg1: DebugInfo) -> None:
        ...
    def create_print(self, arg0: list[... | str], arg1: list[str | None], arg2: DebugInfo) -> None:
        ...
    def end_frontend_mesh_for(self) -> None:
        ...
    def end_frontend_range_for(self) -> None:
        ...
    def end_frontend_struct_for(self) -> None:
        ...
    def end_func(self, arg0: str) -> None:
        ...
    def expand_exprs(self, arg0: list[...]) -> list[...]:
        ...
    def expr_alloca(self, arg0: DebugInfo) -> ...:
        ...
    def expr_alloca_shared_array(self, arg0: tuple[int, ...], arg1: DataTypeCxx, arg2: DebugInfo) -> ...:
        ...
    def expr_assign(self, arg0: ..., arg1: ..., arg2: DebugInfo) -> None:
        ...
    def expr_snode_append(self, arg0: ..., arg1: ..., arg2: list[...]) -> ...:
        ...
    def expr_snode_get_addr(self, arg0: ..., arg1: ...) -> ...:
        ...
    def expr_snode_is_active(self, arg0: ..., arg1: ...) -> ...:
        ...
    def expr_snode_length(self, arg0: ..., arg1: ...) -> ...:
        ...
    def expr_subscript(self, arg0: ..., arg1: ..., arg2: DebugInfo) -> ...:
        ...
    def expr_var(self, arg0: ..., arg1: DebugInfo) -> ...:
        ...
    def insert_activate(self, arg0: ..., arg1: ..., arg2: DebugInfo) -> None:
        ...
    def insert_break_stmt(self, arg0: DebugInfo) -> None:
        ...
    def insert_continue_stmt(self, arg0: DebugInfo) -> None:
        ...
    def insert_deactivate(self, arg0: ..., arg1: ..., arg2: DebugInfo) -> None:
        ...
    def insert_expr_stmt(self, arg0: ...) -> None:
        ...
    def insert_external_func_call(self, arg0: int, arg1: str, arg2: str, arg3: str, arg4: ..., arg5: ..., arg6: DebugInfo) -> None:
        ...
    def insert_func_call(self, arg0: ..., arg1: ..., arg2: DebugInfo) -> ... | None:
        ...
    def insert_patch_idx_expr(self, arg0: DebugInfo) -> ...:
        ...
    def insert_snode_access_flag(self, arg0: SNodeAccessFlag, arg1: ...) -> None:
        ...
    def insert_thread_idx_expr(self) -> ...:
        ...
    def make_id_expr(self, arg0: str) -> ...:
        ...
    def make_matrix_expr(self, arg0: tuple[int, ...], arg1: DataTypeCxx, arg2: list[...], arg3: DebugInfo) -> ...:
        ...
    def mesh_index_conversion(self, arg0: ..., arg1: ..., arg2: ..., arg3: ..., arg4: DebugInfo) -> ...:
        ...
    def parallelize(self, arg0: int) -> None:
        ...
    def pop_scope(self) -> None:
        ...
    def reset_snode_access_flag(self) -> None:
        ...
    def sifakis_svd_f32(self, arg0: ..., arg1: int) -> tuple[..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ...]:
        ...
    def sifakis_svd_f64(self, arg0: ..., arg1: int) -> tuple[..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ..., ...]:
        ...
    def stop_grad(self, arg0: ...) -> None:
        ...
    def strictly_serialize(self) -> None:
        ...
class Arch:
    """
    Members:
    
      x64
    
      arm64
    
      js
    
      cuda
    
      metal
    
      opencl
    
      amdgpu
    
      vulkan
    """
    __members__: typing.ClassVar[dict[str, Arch]]  # value = {'x64': <Arch.x64: 0>, 'arm64': <Arch.arm64: 1>, 'js': <Arch.js: 2>, 'cuda': <Arch.cuda: 3>, 'metal': <Arch.metal: 4>, 'opencl': <Arch.opencl: 5>, 'amdgpu': <Arch.amdgpu: 6>, 'vulkan': <Arch.vulkan: 7>}
    amdgpu: typing.ClassVar[Arch]  # value = <Arch.amdgpu: 6>
    arm64: typing.ClassVar[Arch]  # value = <Arch.arm64: 1>
    cuda: typing.ClassVar[Arch]  # value = <Arch.cuda: 3>
    js: typing.ClassVar[Arch]  # value = <Arch.js: 2>
    metal: typing.ClassVar[Arch]  # value = <Arch.metal: 4>
    opencl: typing.ClassVar[Arch]  # value = <Arch.opencl: 5>
    vulkan: typing.ClassVar[Arch]  # value = <Arch.vulkan: 7>
    x64: typing.ClassVar[Arch]  # value = <Arch.x64: 0>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class AutodiffMode:
    """
    Members:
    
      NONE
    
      VALIDATION
    
      FORWARD
    
      REVERSE
    """
    FORWARD: typing.ClassVar[AutodiffMode]  # value = <AutodiffMode.FORWARD: 0>
    NONE: typing.ClassVar[AutodiffMode]  # value = <AutodiffMode.NONE: 2>
    REVERSE: typing.ClassVar[AutodiffMode]  # value = <AutodiffMode.REVERSE: 1>
    VALIDATION: typing.ClassVar[AutodiffMode]  # value = <AutodiffMode.VALIDATION: 3>
    __members__: typing.ClassVar[dict[str, AutodiffMode]]  # value = {'NONE': <AutodiffMode.NONE: 2>, 'VALIDATION': <AutodiffMode.VALIDATION: 3>, 'FORWARD': <AutodiffMode.FORWARD: 0>, 'REVERSE': <AutodiffMode.REVERSE: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Axis:
    def __init__(self, arg0: int) -> None:
        ...
class Benchmark:
    def initialize(self, arg0: Config) -> None:
        ...
    def run(self, arg0: int) -> float:
        ...
    def test(self) -> bool:
        ...
class BinaryOpType:
    """
    Members:
    
      mul
    
      add
    
      sub
    
      truediv
    
      floordiv
    
      div
    
      mod
    
      max
    
      min
    
      bit_and
    
      bit_or
    
      bit_xor
    
      bit_shl
    
      bit_shr
    
      bit_sar
    
      cmp_lt
    
      cmp_le
    
      cmp_gt
    
      cmp_ge
    
      cmp_eq
    
      cmp_ne
    
      atan2
    
      pow
    
      undefined
    """
    __members__: typing.ClassVar[dict[str, BinaryOpType]]  # value = {'mul': <BinaryOpType.mul: 0>, 'add': <BinaryOpType.add: 1>, 'sub': <BinaryOpType.sub: 2>, 'truediv': <BinaryOpType.truediv: 3>, 'floordiv': <BinaryOpType.floordiv: 4>, 'div': <BinaryOpType.div: 5>, 'mod': <BinaryOpType.mod: 6>, 'max': <BinaryOpType.max: 7>, 'min': <BinaryOpType.min: 8>, 'bit_and': <BinaryOpType.bit_and: 9>, 'bit_or': <BinaryOpType.bit_or: 10>, 'bit_xor': <BinaryOpType.bit_xor: 11>, 'bit_shl': <BinaryOpType.bit_shl: 12>, 'bit_shr': <BinaryOpType.bit_shr: 13>, 'bit_sar': <BinaryOpType.bit_sar: 14>, 'cmp_lt': <BinaryOpType.cmp_lt: 15>, 'cmp_le': <BinaryOpType.cmp_le: 16>, 'cmp_gt': <BinaryOpType.cmp_gt: 17>, 'cmp_ge': <BinaryOpType.cmp_ge: 18>, 'cmp_eq': <BinaryOpType.cmp_eq: 19>, 'cmp_ne': <BinaryOpType.cmp_ne: 20>, 'atan2': <BinaryOpType.atan2: 21>, 'pow': <BinaryOpType.pow: 22>, 'undefined': <BinaryOpType.undefined: 23>}
    add: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.add: 1>
    atan2: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.atan2: 21>
    bit_and: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.bit_and: 9>
    bit_or: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.bit_or: 10>
    bit_sar: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.bit_sar: 14>
    bit_shl: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.bit_shl: 12>
    bit_shr: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.bit_shr: 13>
    bit_xor: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.bit_xor: 11>
    cmp_eq: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.cmp_eq: 19>
    cmp_ge: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.cmp_ge: 18>
    cmp_gt: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.cmp_gt: 17>
    cmp_le: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.cmp_le: 16>
    cmp_lt: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.cmp_lt: 15>
    cmp_ne: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.cmp_ne: 20>
    div: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.div: 5>
    floordiv: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.floordiv: 4>
    max: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.max: 7>
    min: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.min: 8>
    mod: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.mod: 6>
    mul: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.mul: 0>
    pow: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.pow: 22>
    sub: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.sub: 2>
    truediv: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.truediv: 3>
    undefined: typing.ClassVar[BinaryOpType]  # value = <BinaryOpType.undefined: 23>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class BitStructType:
    pass
class BitStructTypeBuilder:
    def __init__(self, arg0: int) -> None:
        ...
    def add_member(self, arg0: Type) -> int:
        ...
    def begin_placing_shared_exponent(self) -> None:
        ...
    def build(self) -> BitStructType:
        ...
    def end_placing_shared_exponent(self) -> None:
        ...
class BoundaryMode:
    """
    Members:
    
      UNSAFE
    
      CLAMP
    """
    CLAMP: typing.ClassVar[BoundaryMode]  # value = <BoundaryMode.CLAMP: 1>
    UNSAFE: typing.ClassVar[BoundaryMode]  # value = <BoundaryMode.UNSAFE: 0>
    __members__: typing.ClassVar[dict[str, BoundaryMode]]  # value = {'UNSAFE': <BoundaryMode.UNSAFE: 0>, 'CLAMP': <BoundaryMode.CLAMP: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CGd:
    def __init__(self, arg0: SparseMatrix, arg1: int, arg2: float, arg3: bool) -> None:
        ...
    def get_x(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def is_success(self) -> bool:
        ...
    def set_b(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def set_b_ndarray(self, arg0: Program, arg1: NdarrayCxx) -> None:
        ...
    def set_x(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def set_x_ndarray(self, arg0: Program, arg1: NdarrayCxx) -> None:
        ...
    def solve(self) -> None:
        ...
class CGf:
    def __init__(self, arg0: SparseMatrix, arg1: int, arg2: float, arg3: bool) -> None:
        ...
    def get_x(self) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def is_success(self) -> bool:
        ...
    def set_b(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> None:
        ...
    def set_b_ndarray(self, arg0: Program, arg1: NdarrayCxx) -> None:
        ...
    def set_x(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> None:
        ...
    def set_x_ndarray(self, arg0: Program, arg1: NdarrayCxx) -> None:
        ...
    def solve(self) -> None:
        ...
class CUCG:
    def solve(self, arg0: Program, arg1: NdarrayCxx, arg2: NdarrayCxx) -> None:
        ...
class CompileConfig:
    ad_stack_experimental_enabled: bool
    ad_stack_size: int
    advanced_optimization: bool
    arch: Arch
    auto_mesh_local_default_occupacy: int
    cache_loop_invariant_global_vars: bool
    cfg_optimization: bool
    check_out_of_bound: bool
    cpu_block_dim_adaptive: bool
    cpu_max_num_threads: int
    cuda_stack_limit: int
    debug: bool
    debug_dump_path: str
    default_cpu_block_dim: int
    default_fp: DataTypeCxx
    default_gpu_block_dim: int
    default_ip: DataTypeCxx
    default_up: DataTypeCxx
    demote_dense_struct_fors: bool
    demote_no_access_mesh_fors: bool
    detect_read_only: bool
    device_memory_GB: float
    device_memory_fraction: float
    experimental_auto_mesh_local: bool
    fast_math: bool
    flatten_if: bool
    force_scalarize_matrix: bool
    gpu_max_reg: int
    half2_vectorization: bool
    kernel_profiler: bool
    lower_access: bool
    make_block_local: bool
    make_cpu_multithreading_loop: bool
    make_mesh_block_local: bool
    make_thread_local: bool
    max_block_dim: int
    mesh_localize_all_attr_mappings: bool
    mesh_localize_from_end_mapping: bool
    mesh_localize_to_end_mapping: bool
    move_loop_invariant_outside_if: bool
    num_compile_threads: int
    offline_cache: bool
    offline_cache_cleaning_factor: float
    offline_cache_cleaning_policy: str
    offline_cache_file_path: str
    offline_cache_max_size_of_files: int
    opt_level: int
    optimize_mesh_reordered_mapping: bool
    print_accessor_ir: bool
    print_ir: bool
    print_ir_dbg_info: bool
    print_kernel_amdgcn: bool
    print_kernel_asm: bool
    print_kernel_llvm_ir: bool
    print_kernel_llvm_ir_optimized: bool
    print_preprocessed_ir: bool
    print_struct_llvm_ir: bool
    quant_opt_atomic_demotion: bool
    quant_opt_store_fusion: bool
    raise_on_templated_floats: bool
    random_seed: int
    real_matrix_scalarize: bool
    saturating_grid_dim: int
    simplify_after_lower_access: bool
    simplify_before_lower_access: bool
    timeline: bool
    use_llvm: bool
    verbose: bool
    verbose_kernel_launches: bool
    vk_api_version: str
    def __init__(self) -> None:
        ...
class CompileResult:
    @property
    def cache_hit(self) -> bool:
        ...
    @property
    def cache_key(self) -> str:
        ...
    @property
    def compiled_kernel_data(self) -> CompiledKernelData:
        ...
class CompiledKernelData:
    def _debug_dump_to_string(self) -> str:
        ...
class Config:
    pass
class ConvType:
    """
    Members:
    
      l2g
    
      l2r
    
      g2r
    """
    __members__: typing.ClassVar[dict[str, ConvType]]  # value = {'l2g': <ConvType.l2g: 0>, 'l2r': <ConvType.l2r: 1>, 'g2r': <ConvType.g2r: 2>}
    g2r: typing.ClassVar[ConvType]  # value = <ConvType.g2r: 2>
    l2g: typing.ClassVar[ConvType]  # value = <ConvType.l2g: 0>
    l2r: typing.ClassVar[ConvType]  # value = <ConvType.l2r: 1>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CuSparseMatrix(SparseMatrix):
    def __add__(self, arg0: CuSparseMatrix) -> SparseMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: DataTypeCxx) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CuSparseMatrix) -> None:
        ...
    def __mul__(self, arg0: float) -> SparseMatrix:
        ...
    def __rmul__(self, arg0: float) -> SparseMatrix:
        ...
    def __sub__(self, arg0: CuSparseMatrix) -> SparseMatrix:
        ...
    def get_element(self, arg0: int, arg1: int) -> float:
        ...
    def matmul(self, arg0: CuSparseMatrix) -> SparseMatrix:
        ...
    def spmv(self, arg0: Program, arg1: NdarrayCxx, arg2: NdarrayCxx) -> None:
        ...
    def to_string(self) -> str:
        ...
    def transpose(self) -> SparseMatrix:
        ...
class CuSparseSolver(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class DataTypeCxx:
    def __call__(self, *args, **kwargs) -> None:
        ...
    def __eq__(self, arg0: DataTypeCxx) -> bool:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self, arg0: ...) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
    def element_type(self) -> DataTypeCxx:
        ...
    def get_ptr(self) -> ...:
        ...
    def ptr_removed(self) -> DataTypeCxx:
        ...
    def shape(self) -> tuple[int, ...]:
        ...
    def to_string(self) -> str:
        ...
class DebugInfo:
    src_loc: ...
    tb: str
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
class DeviceAllocation:
    def __init__(self, device: int, alloc_id: int) -> None:
        ...
    @property
    def alloc_id(self) -> int:
        ...
    @property
    def device(self) -> ...:
        ...
class DeviceCapability:
    """
    Members:
    
      reserved
    
      spirv_version
    
      spirv_has_int8
    
      spirv_has_int16
    
      spirv_has_int64
    
      spirv_has_float16
    
      spirv_has_float64
    
      spirv_has_atomic_int64
    
      spirv_has_atomic_float16
    
      spirv_has_atomic_float16_add
    
      spirv_has_atomic_float16_minmax
    
      spirv_has_atomic_float
    
      spirv_has_atomic_float_add
    
      spirv_has_atomic_float_minmax
    
      spirv_has_atomic_float64
    
      spirv_has_atomic_float64_add
    
      spirv_has_atomic_float64_minmax
    
      spirv_has_variable_ptr
    
      spirv_has_physical_storage_buffer
    
      spirv_has_subgroup_basic
    
      spirv_has_subgroup_vote
    
      spirv_has_subgroup_arithmetic
    
      spirv_has_subgroup_ballot
    
      spirv_has_non_semantic_info
    
      spirv_has_no_integer_wrap_decoration
    
      spirv_has_shader_clock
    """
    __members__: typing.ClassVar[dict[str, DeviceCapability]]  # value = {'reserved': <DeviceCapability.reserved: 0>, 'spirv_version': <DeviceCapability.spirv_version: 1>, 'spirv_has_int8': <DeviceCapability.spirv_has_int8: 2>, 'spirv_has_int16': <DeviceCapability.spirv_has_int16: 3>, 'spirv_has_int64': <DeviceCapability.spirv_has_int64: 4>, 'spirv_has_float16': <DeviceCapability.spirv_has_float16: 5>, 'spirv_has_float64': <DeviceCapability.spirv_has_float64: 6>, 'spirv_has_atomic_int64': <DeviceCapability.spirv_has_atomic_int64: 7>, 'spirv_has_atomic_float16': <DeviceCapability.spirv_has_atomic_float16: 8>, 'spirv_has_atomic_float16_add': <DeviceCapability.spirv_has_atomic_float16_add: 9>, 'spirv_has_atomic_float16_minmax': <DeviceCapability.spirv_has_atomic_float16_minmax: 10>, 'spirv_has_atomic_float': <DeviceCapability.spirv_has_atomic_float: 11>, 'spirv_has_atomic_float_add': <DeviceCapability.spirv_has_atomic_float_add: 12>, 'spirv_has_atomic_float_minmax': <DeviceCapability.spirv_has_atomic_float_minmax: 13>, 'spirv_has_atomic_float64': <DeviceCapability.spirv_has_atomic_float64: 14>, 'spirv_has_atomic_float64_add': <DeviceCapability.spirv_has_atomic_float64_add: 15>, 'spirv_has_atomic_float64_minmax': <DeviceCapability.spirv_has_atomic_float64_minmax: 16>, 'spirv_has_variable_ptr': <DeviceCapability.spirv_has_variable_ptr: 17>, 'spirv_has_physical_storage_buffer': <DeviceCapability.spirv_has_physical_storage_buffer: 18>, 'spirv_has_subgroup_basic': <DeviceCapability.spirv_has_subgroup_basic: 19>, 'spirv_has_subgroup_vote': <DeviceCapability.spirv_has_subgroup_vote: 20>, 'spirv_has_subgroup_arithmetic': <DeviceCapability.spirv_has_subgroup_arithmetic: 21>, 'spirv_has_subgroup_ballot': <DeviceCapability.spirv_has_subgroup_ballot: 22>, 'spirv_has_non_semantic_info': <DeviceCapability.spirv_has_non_semantic_info: 23>, 'spirv_has_no_integer_wrap_decoration': <DeviceCapability.spirv_has_no_integer_wrap_decoration: 24>, 'spirv_has_shader_clock': <DeviceCapability.spirv_has_shader_clock: 25>}
    reserved: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.reserved: 0>
    spirv_has_atomic_float: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float: 11>
    spirv_has_atomic_float16: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float16: 8>
    spirv_has_atomic_float16_add: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float16_add: 9>
    spirv_has_atomic_float16_minmax: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float16_minmax: 10>
    spirv_has_atomic_float64: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float64: 14>
    spirv_has_atomic_float64_add: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float64_add: 15>
    spirv_has_atomic_float64_minmax: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float64_minmax: 16>
    spirv_has_atomic_float_add: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float_add: 12>
    spirv_has_atomic_float_minmax: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_float_minmax: 13>
    spirv_has_atomic_int64: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_atomic_int64: 7>
    spirv_has_float16: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_float16: 5>
    spirv_has_float64: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_float64: 6>
    spirv_has_int16: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_int16: 3>
    spirv_has_int64: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_int64: 4>
    spirv_has_int8: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_int8: 2>
    spirv_has_no_integer_wrap_decoration: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_no_integer_wrap_decoration: 24>
    spirv_has_non_semantic_info: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_non_semantic_info: 23>
    spirv_has_physical_storage_buffer: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_physical_storage_buffer: 18>
    spirv_has_shader_clock: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_shader_clock: 25>
    spirv_has_subgroup_arithmetic: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_subgroup_arithmetic: 21>
    spirv_has_subgroup_ballot: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_subgroup_ballot: 22>
    spirv_has_subgroup_basic: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_subgroup_basic: 19>
    spirv_has_subgroup_vote: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_subgroup_vote: 20>
    spirv_has_variable_ptr: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_has_variable_ptr: 17>
    spirv_version: typing.ClassVar[DeviceCapability]  # value = <DeviceCapability.spirv_version: 1>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class DeviceCapabilityConfig:
    def get(self, arg0: DeviceCapability) -> int:
        ...
class EigenSparseSolverfloat32LDLTAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat32LDLTCOLAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat32LLTAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat32LLTCOLAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat32LUAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat32LUCOLAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat64LDLTAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat64LDLTCOLAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat64LLTAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat64LLTCOLAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat64LUAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class EigenSparseSolverfloat64LUCOLAMD(SparseSolver):
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
    def solve(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def solve_rf(self, arg0: Program, arg1: SparseMatrix, arg2: NdarrayCxx, arg3: NdarrayCxx) -> None:
        ...
class ExprCxx:
    def get_dbg_info(self) -> DebugInfo:
        ...
    def get_dt(self) -> ...:
        ...
    def get_dynamic_index_stride(self) -> int:
        ...
    def get_dynamic_indexable(self) -> bool:
        ...
    def get_expr_name(self) -> str:
        ...
    def get_raw_address(self) -> int:
        ...
    def get_ret_type(self) -> DataTypeCxx:
        ...
    def get_rvalue_type(self) -> DataTypeCxx:
        ...
    def get_shape(self) -> tuple[int, ...] | None:
        ...
    def get_underlying_ptr_address(self) -> int:
        ...
    def is_external_tensor_expr(self) -> bool:
        ...
    def is_index_expr(self) -> bool:
        ...
    def is_lvalue(self) -> bool:
        ...
    def is_primal(self) -> bool:
        ...
    def is_struct(self) -> bool:
        ...
    def is_tensor(self) -> bool:
        ...
    def set_adjoint(self, arg0: ExprCxx) -> None:
        ...
    def set_adjoint_checkbit(self, arg0: ExprCxx) -> None:
        ...
    def set_dbg_info(self, arg0: DebugInfo) -> None:
        ...
    def set_dual(self, arg0: ExprCxx) -> None:
        ...
    def set_dynamic_index_stride(self, arg0: int) -> None:
        ...
    def set_grad_type(self, arg0: SNodeGradType) -> None:
        ...
    def set_name(self, arg0: str) -> None:
        ...
    def snode(self) -> SNodeCxx:
        ...
    def type_check(self, arg0: CompileConfig) -> None:
        ...
class ExprGroup:
    def __init__(self) -> None:
        ...
    def push_back(self, arg0: ExprCxx) -> None:
        ...
    def size(self) -> int:
        ...
class Extension:
    """
    Members:
    
      sparse
    
      quant
    
      mesh
    
      quant_basic
    
      data64
    
      adstack
    
      bls
    
      assertion
    
      extfunc
    """
    __members__: typing.ClassVar[dict[str, Extension]]  # value = {'sparse': <Extension.sparse: 0>, 'quant': <Extension.quant: 1>, 'mesh': <Extension.mesh: 2>, 'quant_basic': <Extension.quant_basic: 3>, 'data64': <Extension.data64: 4>, 'adstack': <Extension.adstack: 5>, 'bls': <Extension.bls: 6>, 'assertion': <Extension.assertion: 7>, 'extfunc': <Extension.extfunc: 8>}
    adstack: typing.ClassVar[Extension]  # value = <Extension.adstack: 5>
    assertion: typing.ClassVar[Extension]  # value = <Extension.assertion: 7>
    bls: typing.ClassVar[Extension]  # value = <Extension.bls: 6>
    data64: typing.ClassVar[Extension]  # value = <Extension.data64: 4>
    extfunc: typing.ClassVar[Extension]  # value = <Extension.extfunc: 8>
    mesh: typing.ClassVar[Extension]  # value = <Extension.mesh: 2>
    quant: typing.ClassVar[Extension]  # value = <Extension.quant: 1>
    quant_basic: typing.ClassVar[Extension]  # value = <Extension.quant_basic: 3>
    sparse: typing.ClassVar[Extension]  # value = <Extension.sparse: 0>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Format:
    """
    Members:
    
      unknown
    
      r8
    
      rg8
    
      rgba8
    
      rgba8srgb
    
      bgra8
    
      bgra8srgb
    
      r8u
    
      rg8u
    
      rgba8u
    
      r8i
    
      rg8i
    
      rgba8i
    
      r16
    
      rg16
    
      rgb16
    
      rgba16
    
      r16u
    
      rg16u
    
      rgb16u
    
      rgba16u
    
      r16i
    
      rg16i
    
      rgb16i
    
      rgba16i
    
      r16f
    
      rg16f
    
      rgb16f
    
      rgba16f
    
      r32u
    
      rg32u
    
      rgb32u
    
      rgba32u
    
      r32i
    
      rg32i
    
      rgb32i
    
      rgba32i
    
      r32f
    
      rg32f
    
      rgb32f
    
      rgba32f
    
      depth16
    
      depth24stencil8
    
      depth32f
    """
    __members__: typing.ClassVar[dict[str, Format]]  # value = {'unknown': <Format.unknown: 0>, 'r8': <Format.r8: 1>, 'rg8': <Format.rg8: 2>, 'rgba8': <Format.rgba8: 3>, 'rgba8srgb': <Format.rgba8srgb: 4>, 'bgra8': <Format.bgra8: 5>, 'bgra8srgb': <Format.bgra8srgb: 6>, 'r8u': <Format.r8u: 7>, 'rg8u': <Format.rg8u: 8>, 'rgba8u': <Format.rgba8u: 9>, 'r8i': <Format.r8i: 10>, 'rg8i': <Format.rg8i: 11>, 'rgba8i': <Format.rgba8i: 12>, 'r16': <Format.r16: 13>, 'rg16': <Format.rg16: 14>, 'rgb16': <Format.rgb16: 15>, 'rgba16': <Format.rgba16: 16>, 'r16u': <Format.r16u: 17>, 'rg16u': <Format.rg16u: 18>, 'rgb16u': <Format.rgb16u: 19>, 'rgba16u': <Format.rgba16u: 20>, 'r16i': <Format.r16i: 21>, 'rg16i': <Format.rg16i: 22>, 'rgb16i': <Format.rgb16i: 23>, 'rgba16i': <Format.rgba16i: 24>, 'r16f': <Format.r16f: 25>, 'rg16f': <Format.rg16f: 26>, 'rgb16f': <Format.rgb16f: 27>, 'rgba16f': <Format.rgba16f: 28>, 'r32u': <Format.r32u: 29>, 'rg32u': <Format.rg32u: 30>, 'rgb32u': <Format.rgb32u: 31>, 'rgba32u': <Format.rgba32u: 32>, 'r32i': <Format.r32i: 33>, 'rg32i': <Format.rg32i: 34>, 'rgb32i': <Format.rgb32i: 35>, 'rgba32i': <Format.rgba32i: 36>, 'r32f': <Format.r32f: 37>, 'rg32f': <Format.rg32f: 38>, 'rgb32f': <Format.rgb32f: 39>, 'rgba32f': <Format.rgba32f: 40>, 'depth16': <Format.depth16: 41>, 'depth24stencil8': <Format.depth24stencil8: 42>, 'depth32f': <Format.depth32f: 43>}
    bgra8: typing.ClassVar[Format]  # value = <Format.bgra8: 5>
    bgra8srgb: typing.ClassVar[Format]  # value = <Format.bgra8srgb: 6>
    depth16: typing.ClassVar[Format]  # value = <Format.depth16: 41>
    depth24stencil8: typing.ClassVar[Format]  # value = <Format.depth24stencil8: 42>
    depth32f: typing.ClassVar[Format]  # value = <Format.depth32f: 43>
    r16: typing.ClassVar[Format]  # value = <Format.r16: 13>
    r16f: typing.ClassVar[Format]  # value = <Format.r16f: 25>
    r16i: typing.ClassVar[Format]  # value = <Format.r16i: 21>
    r16u: typing.ClassVar[Format]  # value = <Format.r16u: 17>
    r32f: typing.ClassVar[Format]  # value = <Format.r32f: 37>
    r32i: typing.ClassVar[Format]  # value = <Format.r32i: 33>
    r32u: typing.ClassVar[Format]  # value = <Format.r32u: 29>
    r8: typing.ClassVar[Format]  # value = <Format.r8: 1>
    r8i: typing.ClassVar[Format]  # value = <Format.r8i: 10>
    r8u: typing.ClassVar[Format]  # value = <Format.r8u: 7>
    rg16: typing.ClassVar[Format]  # value = <Format.rg16: 14>
    rg16f: typing.ClassVar[Format]  # value = <Format.rg16f: 26>
    rg16i: typing.ClassVar[Format]  # value = <Format.rg16i: 22>
    rg16u: typing.ClassVar[Format]  # value = <Format.rg16u: 18>
    rg32f: typing.ClassVar[Format]  # value = <Format.rg32f: 38>
    rg32i: typing.ClassVar[Format]  # value = <Format.rg32i: 34>
    rg32u: typing.ClassVar[Format]  # value = <Format.rg32u: 30>
    rg8: typing.ClassVar[Format]  # value = <Format.rg8: 2>
    rg8i: typing.ClassVar[Format]  # value = <Format.rg8i: 11>
    rg8u: typing.ClassVar[Format]  # value = <Format.rg8u: 8>
    rgb16: typing.ClassVar[Format]  # value = <Format.rgb16: 15>
    rgb16f: typing.ClassVar[Format]  # value = <Format.rgb16f: 27>
    rgb16i: typing.ClassVar[Format]  # value = <Format.rgb16i: 23>
    rgb16u: typing.ClassVar[Format]  # value = <Format.rgb16u: 19>
    rgb32f: typing.ClassVar[Format]  # value = <Format.rgb32f: 39>
    rgb32i: typing.ClassVar[Format]  # value = <Format.rgb32i: 35>
    rgb32u: typing.ClassVar[Format]  # value = <Format.rgb32u: 31>
    rgba16: typing.ClassVar[Format]  # value = <Format.rgba16: 16>
    rgba16f: typing.ClassVar[Format]  # value = <Format.rgba16f: 28>
    rgba16i: typing.ClassVar[Format]  # value = <Format.rgba16i: 24>
    rgba16u: typing.ClassVar[Format]  # value = <Format.rgba16u: 20>
    rgba32f: typing.ClassVar[Format]  # value = <Format.rgba32f: 40>
    rgba32i: typing.ClassVar[Format]  # value = <Format.rgba32i: 36>
    rgba32u: typing.ClassVar[Format]  # value = <Format.rgba32u: 32>
    rgba8: typing.ClassVar[Format]  # value = <Format.rgba8: 3>
    rgba8i: typing.ClassVar[Format]  # value = <Format.rgba8i: 12>
    rgba8srgb: typing.ClassVar[Format]  # value = <Format.rgba8srgb: 4>
    rgba8u: typing.ClassVar[Format]  # value = <Format.rgba8u: 9>
    unknown: typing.ClassVar[Format]  # value = <Format.unknown: 0>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Function:
    def ast_builder(self) -> ASTBuilder:
        ...
    def finalize_params(self) -> None:
        ...
    def finalize_rets(self) -> None:
        ...
    def insert_arr_param(self, arg0: DataTypeCxx, arg1: int, arg2: tuple[int, ...], arg3: str) -> tuple[int, ...]:
        ...
    def insert_ndarray_param(self, arg0: DataTypeCxx, arg1: int, arg2: str, arg3: bool) -> tuple[int, ...]:
        ...
    def insert_pointer_param(self, arg0: DataTypeCxx, arg1: str) -> tuple[int, ...]:
        ...
    def insert_ret(self, arg0: DataTypeCxx) -> int:
        ...
    def insert_scalar_param(self, arg0: DataTypeCxx, arg1: str) -> tuple[int, ...]:
        ...
    def set_function_body(self, arg0: typing.Callable[[], None]) -> None:
        ...
class FunctionKey:
    def __init__(self, arg0: str, arg1: int, arg2: int) -> None:
        ...
    @property
    def instance_id(self) -> int:
        ...
class GsTaichiAssertionError(AssertionError):
    pass
class GsTaichiIndexError(IndexError):
    pass
class GsTaichiRuntimeError(RuntimeError):
    pass
class GsTaichiSyntaxError(SyntaxError):
    pass
class GsTaichiTypeError(TypeError):
    pass
class HackedSignalRegister:
    def __init__(self) -> None:
        ...
class InternalOp:
    amdgpu_clock_i64: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    block_barrier: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    block_barrier_and_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    block_barrier_count_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    block_barrier_or_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    composite_extract_0: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    composite_extract_1: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    composite_extract_2: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    composite_extract_3: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cpu_clock_i64: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_active_mask: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_all_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_any_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_ballot_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_clock_i64: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_match_all_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_match_any_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_shfl_down_sync_f32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_shfl_down_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_shfl_sync_f32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_shfl_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_shfl_up_sync_f32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_shfl_up_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_shfl_xor_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    cuda_uni_sync_i32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    do_nothing: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    grid_memfence: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    insert_triplet_f32: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    insert_triplet_f64: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    linear_thread_idx: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    localInvocationId: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    refresh_counter: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    spirv_clock_i64: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupAdd: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupAnd: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupBarrier: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupBroadcast: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupElect: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupInclusiveAdd: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupInclusiveAnd: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupInclusiveMax: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupInclusiveMin: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupInclusiveMul: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupInclusiveOr: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupInclusiveXor: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupInvocationId: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupMax: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupMemoryBarrier: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupMin: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupMul: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupOr: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupSize: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    subgroupXor: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    test_active_mask: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    test_internal_func_args: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    test_list_manager: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    test_node_allocator: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    test_node_allocator_gc_cpu: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    test_shfl: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    test_stack: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    vkGlobalThreadIdx: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    warp_barrier: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    workgroupBarrier: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
    workgroupMemoryBarrier: typing.ClassVar[Operation]  # value = <gstaichi._lib.core.gstaichi_python.Operation object>
class KernelCxx:
    def ast_builder(self) -> ASTBuilder:
        ...
    def finalize_params(self) -> None:
        ...
    def finalize_rets(self) -> None:
        ...
    def insert_arr_param(self, arg0: DataTypeCxx, arg1: int, arg2: tuple[int, ...], arg3: str) -> tuple[int, ...]:
        ...
    def insert_ndarray_param(self, arg0: DataTypeCxx, arg1: int, arg2: str, arg3: bool) -> tuple[int, ...]:
        ...
    def insert_pointer_param(self, arg0: DataTypeCxx, arg1: str) -> tuple[int, ...]:
        ...
    def insert_ret(self, arg0: DataTypeCxx) -> int:
        ...
    def insert_scalar_param(self, arg0: DataTypeCxx, arg1: str) -> tuple[int, ...]:
        ...
    def make_launch_context(self) -> KernelLaunchContext:
        ...
    def no_activate(self, arg0: SNodeCxx) -> None:
        ...
    def to_string(self) -> str:
        ...
class KernelLaunchContext:
    def copy(self, arg0: KernelLaunchContext) -> None:
        ...
    def get_struct_ret_float(self, arg0: tuple[int, ...]) -> float:
        ...
    def get_struct_ret_int(self, arg0: tuple[int, ...]) -> int:
        ...
    def get_struct_ret_uint(self, arg0: tuple[int, ...]) -> int:
        ...
    def set_arg_external_array_with_shape(self, arg0: int, arg1: int, arg2: int, arg3: tuple[int, ...], arg4: int) -> None:
        ...
    def set_arg_float(self, arg0: int, arg1: float) -> None:
        ...
    def set_arg_int(self, arg0: int, arg1: int) -> None:
        ...
    def set_arg_ndarray(self, arg0: tuple[int, ...], arg1: Ndarray) -> None:
        ...
    def set_arg_ndarray_with_grad(self, arg0: int, arg1: NdarrayCxx, arg2: NdarrayCxx) -> None:
        ...
    def set_arg_uint(self, arg0: int, arg1: int) -> None:
        ...
    def set_args_float(self, arg0: tuple[int, ...], arg1: list[float]) -> None:
        ...
    def set_args_int(self, arg0: tuple[int, ...], arg1: tuple[int, ...]) -> None:
        ...
    def set_args_ndarray(self, arg0: tuple[int, ...], arg1: list[NdarrayCxx]) -> None:
        ...
    def set_args_ndarray_with_grad(self, arg0: tuple[int, ...], arg1: list[NdarrayCxx], arg2: list[NdarrayCxx]) -> None:
        ...
    def set_args_uint(self, arg0: tuple[int, ...], arg1: tuple[int, ...]) -> None:
        ...
    def set_struct_arg_float(self, arg0: tuple[int, ...], arg1: float) -> None:
        ...
    def set_struct_arg_int(self, arg0: tuple[int, ...], arg1: int) -> None:
        ...
    def set_struct_arg_uint(self, arg0: tuple[int, ...], arg1: int) -> None:
        ...
class KernelProfileTracedRecord:
    active_blocks_per_multiprocessor: int
    base_time: float
    block_size: int
    grid_size: int
    kernel_time: float
    metric_values: list[float]
    name: str
    register_per_thread: int
    shared_mem_per_block: int
class KernelProfilerQueryResult:
    avg: float
    counter: int
    max: float
    min: float
class Layout:
    """
    Members:
    
      AOS
    
      SOA
    
      NULL
    """
    AOS: typing.ClassVar[Layout]  # value = <Layout.AOS: 0>
    NULL: typing.ClassVar[Layout]  # value = <Layout.NULL: 2>
    SOA: typing.ClassVar[Layout]  # value = <Layout.SOA: 1>
    __members__: typing.ClassVar[dict[str, Layout]]  # value = {'AOS': <Layout.AOS: 0>, 'SOA': <Layout.SOA: 1>, 'NULL': <Layout.NULL: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Mesh:
    pass
class MeshElementType:
    """
    Members:
    
      Vertex
    
      Edge
    
      Face
    
      Cell
    """
    Cell: typing.ClassVar[MeshElementType]  # value = <MeshElementType.Cell: 3>
    Edge: typing.ClassVar[MeshElementType]  # value = <MeshElementType.Edge: 1>
    Face: typing.ClassVar[MeshElementType]  # value = <MeshElementType.Face: 2>
    Vertex: typing.ClassVar[MeshElementType]  # value = <MeshElementType.Vertex: 0>
    __members__: typing.ClassVar[dict[str, MeshElementType]]  # value = {'Vertex': <MeshElementType.Vertex: 0>, 'Edge': <MeshElementType.Edge: 1>, 'Face': <MeshElementType.Face: 2>, 'Cell': <MeshElementType.Cell: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class MeshPtr:
    pass
class MeshRelationType:
    """
    Members:
    
      VV
    
      VE
    
      VF
    
      VC
    
      EV
    
      EE
    
      EF
    
      EC
    
      FV
    
      FE
    
      FF
    
      FC
    
      CV
    
      CE
    
      CF
    
      CC
    """
    CC: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.CC: 15>
    CE: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.CE: 13>
    CF: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.CF: 14>
    CV: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.CV: 12>
    EC: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.EC: 7>
    EE: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.EE: 5>
    EF: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.EF: 6>
    EV: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.EV: 4>
    FC: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.FC: 11>
    FE: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.FE: 9>
    FF: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.FF: 10>
    FV: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.FV: 8>
    VC: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.VC: 3>
    VE: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.VE: 1>
    VF: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.VF: 2>
    VV: typing.ClassVar[MeshRelationType]  # value = <MeshRelationType.VV: 0>
    __members__: typing.ClassVar[dict[str, MeshRelationType]]  # value = {'VV': <MeshRelationType.VV: 0>, 'VE': <MeshRelationType.VE: 1>, 'VF': <MeshRelationType.VF: 2>, 'VC': <MeshRelationType.VC: 3>, 'EV': <MeshRelationType.EV: 4>, 'EE': <MeshRelationType.EE: 5>, 'EF': <MeshRelationType.EF: 6>, 'EC': <MeshRelationType.EC: 7>, 'FV': <MeshRelationType.FV: 8>, 'FE': <MeshRelationType.FE: 9>, 'FF': <MeshRelationType.FF: 10>, 'FC': <MeshRelationType.FC: 11>, 'CV': <MeshRelationType.CV: 12>, 'CE': <MeshRelationType.CE: 13>, 'CF': <MeshRelationType.CF: 14>, 'CC': <MeshRelationType.CC: 15>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class MeshTopology:
    """
    Members:
    
      Triangle
    
      Tetrahedron
    """
    Tetrahedron: typing.ClassVar[MeshTopology]  # value = <MeshTopology.Tetrahedron: 4>
    Triangle: typing.ClassVar[MeshTopology]  # value = <MeshTopology.Triangle: 3>
    __members__: typing.ClassVar[dict[str, MeshTopology]]  # value = {'Triangle': <MeshTopology.Triangle: 3>, 'Tetrahedron': <MeshTopology.Tetrahedron: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class NdarrayCxx:
    def device_allocation(self) -> DeviceAllocation:
        ...
    def device_allocation_ptr(self) -> int:
        ...
    def element_data_type(self) -> DataTypeCxx:
        ...
    def element_shape(self) -> tuple[int, ...]:
        ...
    def element_size(self) -> int:
        ...
    def nelement(self) -> int:
        ...
    def read_float(self, arg0: tuple[int, ...]) -> float:
        ...
    def read_int(self, arg0: tuple[int, ...]) -> int:
        ...
    def read_uint(self, arg0: tuple[int, ...]) -> int:
        ...
    def total_shape(self) -> tuple[int, ...]:
        ...
    def write_float(self, arg0: tuple[int, ...], arg1: float) -> None:
        ...
    def write_int(self, arg0: tuple[int, ...], arg1: int) -> None:
        ...
    @property
    def dtype(self) -> DataTypeCxx:
        ...
    @property
    def shape(self) -> tuple[int, ...]:
        ...
class Operation:
    pass
class Program:
    def __init__(self) -> None:
        ...
    def _get_num_ndarrays(self) -> int:
        ...
    def clear_kernel_profiler(self) -> None:
        ...
    def compile_kernel(self, arg0: CompileConfig, arg1: DeviceCapabilityConfig, arg2: ...) -> ...:
        ...
    def config(self) -> CompileConfig:
        ...
    def create_function(self, arg0: ...) -> Function:
        ...
    def create_kernel(self, arg0: typing.Callable[[...], None], arg1: str, arg2: AutodiffMode) -> KernelCxx:
        ...
    def create_ndarray(self, dt: DataTypeCxx, shape: tuple[int, ...], layout: Layout = ..., zero_fill: bool = False, dbg_info: DebugInfo = ...) -> ...:
        ...
    def create_sparse_matrix(self, arg0: int, arg1: int, arg2: DataTypeCxx, arg3: str) -> ...:
        ...
    def delete_ndarray(self, arg0: ...) -> None:
        ...
    def dump_cache_data_to_disk(self) -> None:
        ...
    def field_to_dlpack(self, arg0: ..., arg1: int, arg2: int, arg3: int) -> capsule:
        ...
    def fill_float(self, arg0: ..., arg1: float) -> None:
        ...
    def fill_int(self, arg0: ..., arg1: int) -> None:
        ...
    def fill_uint(self, arg0: ..., arg1: int) -> None:
        ...
    def finalize(self) -> None:
        ...
    def get_device_caps(self) -> DeviceCapabilityConfig:
        ...
    def get_graphics_device(self) -> ...:
        ...
    def get_kernel_profiler_device_name(self) -> str:
        ...
    def get_kernel_profiler_records(self) -> list[KernelProfileTracedRecord]:
        ...
    def get_ndarray_data_ptr_as_int(self, arg0: ...) -> int:
        ...
    def get_snode_num_dynamically_allocated(self, arg0: ...) -> int:
        ...
    def get_snode_root(self, arg0: int) -> ...:
        ...
    def get_snode_tree_size(self) -> int:
        ...
    def get_total_compilation_time(self) -> float:
        ...
    def kernel_profiler_total_time(self) -> float:
        ...
    def launch_kernel(self, arg0: CompiledKernelData, arg1: ...) -> None:
        ...
    def load_fast_cache(self, arg0: str, arg1: str, arg2: CompileConfig, arg3: DeviceCapabilityConfig) -> CompiledKernelData:
        ...
    def make_id_expr(self, arg0: str) -> ...:
        ...
    def make_sparse_matrix_from_ndarray(self, arg0: ..., arg1: ...) -> None:
        ...
    def materialize_runtime(self) -> None:
        ...
    def ndarray_to_dlpack(self, arg0: typing.Any, arg1: ...) -> capsule:
        ...
    def print_memory_profiler_info(self) -> None:
        ...
    def query_kernel_profile_info(self, arg0: str) -> KernelProfilerQueryResult:
        ...
    def reinit_kernel_profiler_with_metrics(self, arg0: list[str]) -> bool:
        ...
    def set_kernel_profiler_toolkit(self, arg0: str) -> bool:
        ...
    def sync_kernel_profiler(self) -> None:
        ...
    def synchronize(self) -> None:
        ...
    def timeline_clear(self) -> None:
        ...
    def timeline_save(self, arg0: str) -> None:
        ...
    def update_kernel_profiler(self) -> None:
        ...
class SNodeAccessFlag:
    """
    Members:
    
      block_local
    
      read_only
    
      mesh_local
    """
    __members__: typing.ClassVar[dict[str, SNodeAccessFlag]]  # value = {'block_local': <SNodeAccessFlag.block_local: 0>, 'read_only': <SNodeAccessFlag.read_only: 1>, 'mesh_local': <SNodeAccessFlag.mesh_local: 2>}
    block_local: typing.ClassVar[SNodeAccessFlag]  # value = <SNodeAccessFlag.block_local: 0>
    mesh_local: typing.ClassVar[SNodeAccessFlag]  # value = <SNodeAccessFlag.mesh_local: 2>
    read_only: typing.ClassVar[SNodeAccessFlag]  # value = <SNodeAccessFlag.read_only: 1>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SNodeCxx:
    parent: SNodeCxx
    def __init__(self) -> None:
        ...
    def allocate_adjoint_checkbit(self) -> None:
        ...
    def bit_struct(self, arg0: ..., arg1: DebugInfo) -> SNodeCxx:
        ...
    def bitmasked(self, arg0: list[Axis], arg1: tuple[int, ...], arg2: DebugInfo) -> SNodeCxx:
        ...
    def data_type(self) -> DataTypeCxx:
        ...
    def dense(self, arg0: list[Axis], arg1: tuple[int, ...], arg2: DebugInfo) -> SNodeCxx:
        ...
    def dynamic(self, arg0: Axis, arg1: int, arg2: int, arg3: DebugInfo) -> SNodeCxx:
        ...
    def get_ch(self, arg0: int) -> SNodeCxx:
        ...
    def get_expr(self) -> ...:
        ...
    def get_num_ch(self) -> int:
        ...
    def get_physical_index_position(self) -> tuple[int, ...]:
        ...
    def get_shape_along_axis(self, arg0: int) -> int:
        ...
    def get_snode_grad_type(self) -> SNodeGradType:
        ...
    def get_snode_tree_id(self) -> int:
        ...
    def has_adjoint(self) -> bool:
        ...
    def has_adjoint_checkbit(self) -> bool:
        ...
    def has_dual(self) -> bool:
        ...
    def hash(self, arg0: list[Axis], arg1: tuple[int, ...], arg2: DebugInfo) -> SNodeCxx:
        ...
    def is_place(self) -> bool:
        ...
    def is_primal(self) -> bool:
        ...
    def lazy_dual(self) -> None:
        ...
    def lazy_grad(self) -> None:
        ...
    def name(self) -> str:
        ...
    def num_active_indices(self) -> int:
        ...
    def place(self, arg0: ..., arg1: tuple[int, ...], arg2: int) -> None:
        ...
    def pointer(self, arg0: list[Axis], arg1: tuple[int, ...], arg2: DebugInfo) -> SNodeCxx:
        ...
    def quant_array(self, arg0: list[Axis], arg1: tuple[int, ...], arg2: int, arg3: DebugInfo) -> SNodeCxx:
        ...
    def read_float(self, arg0: tuple[int, ...]) -> float:
        ...
    def read_int(self, arg0: tuple[int, ...]) -> int:
        ...
    def read_uint(self, arg0: tuple[int, ...]) -> int:
        ...
    def write_float(self, arg0: tuple[int, ...], arg1: float) -> None:
        ...
    def write_int(self, arg0: tuple[int, ...], arg1: int) -> None:
        ...
    def write_uint(self, arg0: tuple[int, ...], arg1: int) -> None:
        ...
    @property
    def cell_size_bytes(self) -> int:
        ...
    @property
    def id(self) -> int:
        ...
    @property
    def offset(self) -> tuple[int, ...]:
        ...
    @property
    def offset_bytes_in_parent_cell(self) -> int:
        ...
    @property
    def type(self) -> SNodeType:
        ...
class SNodeGradType:
    """
    Members:
    
      PRIMAL
    
      ADJOINT
    
      DUAL
    
      ADJOINT_CHECKBIT
    """
    ADJOINT: typing.ClassVar[SNodeGradType]  # value = <SNodeGradType.ADJOINT: 1>
    ADJOINT_CHECKBIT: typing.ClassVar[SNodeGradType]  # value = <SNodeGradType.ADJOINT_CHECKBIT: 3>
    DUAL: typing.ClassVar[SNodeGradType]  # value = <SNodeGradType.DUAL: 2>
    PRIMAL: typing.ClassVar[SNodeGradType]  # value = <SNodeGradType.PRIMAL: 0>
    __members__: typing.ClassVar[dict[str, SNodeGradType]]  # value = {'PRIMAL': <SNodeGradType.PRIMAL: 0>, 'ADJOINT': <SNodeGradType.ADJOINT: 1>, 'DUAL': <SNodeGradType.DUAL: 2>, 'ADJOINT_CHECKBIT': <SNodeGradType.ADJOINT_CHECKBIT: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SNodeRegistry:
    def __init__(self) -> None:
        ...
    def create_root(self, arg0: Program) -> SNodeCxx:
        ...
class SNodeTreeCxx:
    def destroy_snode_tree(self, arg0: Program) -> None:
        ...
    def id(self) -> int:
        ...
class SNodeType:
    """
    Members:
    
      root
    
      dense
    
      dynamic
    
      pointer
    
      bitmasked
    
      hash
    
      place
    
      bit_struct
    
      quant_array
    
      undefined
    """
    __members__: typing.ClassVar[dict[str, SNodeType]]  # value = {'root': <SNodeType.root: 0>, 'dense': <SNodeType.dense: 1>, 'dynamic': <SNodeType.dynamic: 2>, 'pointer': <SNodeType.pointer: 3>, 'bitmasked': <SNodeType.bitmasked: 4>, 'hash': <SNodeType.hash: 5>, 'place': <SNodeType.place: 6>, 'bit_struct': <SNodeType.bit_struct: 7>, 'quant_array': <SNodeType.quant_array: 8>, 'undefined': <SNodeType.undefined: 9>}
    bit_struct: typing.ClassVar[SNodeType]  # value = <SNodeType.bit_struct: 7>
    bitmasked: typing.ClassVar[SNodeType]  # value = <SNodeType.bitmasked: 4>
    dense: typing.ClassVar[SNodeType]  # value = <SNodeType.dense: 1>
    dynamic: typing.ClassVar[SNodeType]  # value = <SNodeType.dynamic: 2>
    hash: typing.ClassVar[SNodeType]  # value = <SNodeType.hash: 5>
    place: typing.ClassVar[SNodeType]  # value = <SNodeType.place: 6>
    pointer: typing.ClassVar[SNodeType]  # value = <SNodeType.pointer: 3>
    quant_array: typing.ClassVar[SNodeType]  # value = <SNodeType.quant_array: 8>
    root: typing.ClassVar[SNodeType]  # value = <SNodeType.root: 0>
    undefined: typing.ClassVar[SNodeType]  # value = <SNodeType.undefined: 9>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SparseMatrix:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, rows: int, cols: int, dt: DataTypeCxx = ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: SparseMatrix) -> None:
        ...
    def get_data_type(self) -> DataTypeCxx:
        ...
    def get_element(self, arg0: int, arg1: int) -> float:
        ...
    def mmwrite(self, arg0: str) -> None:
        ...
    def num_cols(self) -> int:
        ...
    def num_rows(self) -> int:
        ...
    def set_element(self, arg0: int, arg1: int, arg2: float) -> None:
        ...
    def to_string(self) -> str:
        ...
class SparseMatrixBuilder:
    def __init__(self, rows: int, cols: int, max_num_triplets: int, dt: DataTypeCxx = ..., storage_format: str = 'col_major') -> None:
        ...
    def build(self) -> ...:
        ...
    def build_cuda(self) -> ...:
        ...
    def create_ndarray(self, arg0: Program) -> None:
        ...
    def delete_ndarray(self, arg0: Program) -> None:
        ...
    def get_addr(self) -> int:
        ...
    def get_ndarray_data_ptr(self) -> int:
        ...
    def print_triplets_cuda(self) -> None:
        ...
    def print_triplets_eigen(self) -> None:
        ...
class SparseSolver:
    def analyze_pattern(self, arg0: SparseMatrix) -> None:
        ...
    def compute(self, arg0: SparseMatrix) -> bool:
        ...
    def factorize(self, arg0: SparseMatrix) -> None:
        ...
    def info(self) -> bool:
        ...
class Stmt:
    pass
class Task:
    def initialize(self, arg0: Config) -> None:
        ...
    def run(self, arg0: list[str]) -> str:
        ...
class Type:
    def to_string(self) -> str:
        ...
class TypeFactory:
    def get_ndarray_struct_type(self, dt: DataTypeCxx, ndim: int, needs_grad: bool) -> Type:
        ...
    def get_quant_fixed_type(self, digits_type: Type, compute_type: Type, scale: float) -> Type:
        ...
    def get_quant_float_type(self, digits_type: Type, exponent_type: Type, compute_type: Type) -> Type:
        ...
    def get_quant_int_type(self, num_bits: int, is_signed: bool, compute_type: Type) -> Type:
        ...
    def get_struct_type(self, arg0: list[tuple[DataTypeCxx, str]]) -> DataTypeCxx:
        ...
    def get_tensor_type(self, shape: tuple[int, ...], element_type: DataType) -> DataTypeCxx:
        ...
class UnaryOpType:
    """
    Members:
    
      neg
    
      sqrt
    
      round
    
      floor
    
      frexp
    
      ceil
    
      cast_value
    
      cast_bits
    
      abs
    
      sgn
    
      sin
    
      asin
    
      cos
    
      acos
    
      tan
    
      tanh
    
      inv
    
      rcp
    
      exp
    
      log
    
      popcnt
    
      clz
    
      rsqrt
    
      bit_not
    
      logic_not
    
      undefined
    """
    __members__: typing.ClassVar[dict[str, UnaryOpType]]  # value = {'neg': <UnaryOpType.neg: 0>, 'sqrt': <UnaryOpType.sqrt: 1>, 'round': <UnaryOpType.round: 2>, 'floor': <UnaryOpType.floor: 3>, 'frexp': <UnaryOpType.frexp: 4>, 'ceil': <UnaryOpType.ceil: 5>, 'cast_value': <UnaryOpType.cast_value: 6>, 'cast_bits': <UnaryOpType.cast_bits: 7>, 'abs': <UnaryOpType.abs: 8>, 'sgn': <UnaryOpType.sgn: 9>, 'sin': <UnaryOpType.sin: 10>, 'asin': <UnaryOpType.asin: 11>, 'cos': <UnaryOpType.cos: 12>, 'acos': <UnaryOpType.acos: 13>, 'tan': <UnaryOpType.tan: 14>, 'tanh': <UnaryOpType.tanh: 15>, 'inv': <UnaryOpType.inv: 16>, 'rcp': <UnaryOpType.rcp: 17>, 'exp': <UnaryOpType.exp: 18>, 'log': <UnaryOpType.log: 19>, 'popcnt': <UnaryOpType.popcnt: 20>, 'clz': <UnaryOpType.clz: 21>, 'rsqrt': <UnaryOpType.rsqrt: 22>, 'bit_not': <UnaryOpType.bit_not: 23>, 'logic_not': <UnaryOpType.logic_not: 24>, 'undefined': <UnaryOpType.undefined: 25>}
    abs: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.abs: 8>
    acos: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.acos: 13>
    asin: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.asin: 11>
    bit_not: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.bit_not: 23>
    cast_bits: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.cast_bits: 7>
    cast_value: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.cast_value: 6>
    ceil: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.ceil: 5>
    clz: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.clz: 21>
    cos: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.cos: 12>
    exp: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.exp: 18>
    floor: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.floor: 3>
    frexp: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.frexp: 4>
    inv: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.inv: 16>
    log: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.log: 19>
    logic_not: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.logic_not: 24>
    neg: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.neg: 0>
    popcnt: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.popcnt: 20>
    rcp: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.rcp: 17>
    round: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.round: 2>
    rsqrt: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.rsqrt: 22>
    sgn: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.sgn: 9>
    sin: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.sin: 10>
    sqrt: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.sqrt: 1>
    tan: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.tan: 14>
    tanh: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.tanh: 15>
    undefined: typing.ClassVar[UnaryOpType]  # value = <UnaryOpType.undefined: 25>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Vector2d:
    x: float
    y: float
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    def __len__(self) -> int:
        ...
class Vector2f:
    x: float
    y: float
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    def __len__(self) -> int:
        ...
class Vector2i:
    x: int
    y: int
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def __len__(self) -> int:
        ...
class Vector3d:
    x: float
    y: float
    z: float
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    def __len__(self) -> int:
        ...
class Vector3f:
    x: float
    y: float
    z: float
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    def __len__(self) -> int:
        ...
class Vector3i:
    x: int
    y: int
    z: int
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def __len__(self) -> int:
        ...
class Vector4d:
    w: float
    x: float
    y: float
    z: float
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    def __len__(self) -> int:
        ...
class Vector4f:
    w: float
    x: float
    y: float
    z: float
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    def __len__(self) -> int:
        ...
class Vector4i:
    w: int
    x: int
    y: int
    z: int
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def __len__(self) -> int:
        ...
class dColMajor_EigenSparseMatrix(SparseMatrix):
    def __add__(self, arg0: dColMajor_EigenSparseMatrix) -> dColMajor_EigenSparseMatrix:
        ...
    def __iadd__(self, arg0: dColMajor_EigenSparseMatrix) -> dColMajor_EigenSparseMatrix:
        ...
    def __imul__(self, arg0: float) -> dColMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: DataTypeCxx) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: dColMajor_EigenSparseMatrix) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: scipy.sparse.csc_matrix) -> None:
        ...
    def __isub__(self, arg0: dColMajor_EigenSparseMatrix) -> dColMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> dColMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: dColMajor_EigenSparseMatrix) -> dColMajor_EigenSparseMatrix:
        ...
    def __rmul__(self, arg0: float) -> dColMajor_EigenSparseMatrix:
        ...
    def __sub__(self, arg0: dColMajor_EigenSparseMatrix) -> dColMajor_EigenSparseMatrix:
        ...
    def get_element(self, arg0: int, arg1: int) -> float:
        ...
    def mat_vec_mul(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def matmul(self, arg0: dColMajor_EigenSparseMatrix) -> dColMajor_EigenSparseMatrix:
        ...
    def set_element(self, arg0: int, arg1: int, arg2: float) -> None:
        ...
    def spmv(self, arg0: Program, arg1: NdarrayCxx, arg2: NdarrayCxx) -> None:
        ...
    def transpose(self) -> dColMajor_EigenSparseMatrix:
        ...
class dRowMajor_EigenSparseMatrix(SparseMatrix):
    def __add__(self, arg0: dRowMajor_EigenSparseMatrix) -> dRowMajor_EigenSparseMatrix:
        ...
    def __iadd__(self, arg0: dRowMajor_EigenSparseMatrix) -> dRowMajor_EigenSparseMatrix:
        ...
    def __imul__(self, arg0: float) -> dRowMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: DataTypeCxx) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: dRowMajor_EigenSparseMatrix) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: scipy.sparse.csr_matrix) -> None:
        ...
    def __isub__(self, arg0: dRowMajor_EigenSparseMatrix) -> dRowMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> dRowMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: dRowMajor_EigenSparseMatrix) -> dRowMajor_EigenSparseMatrix:
        ...
    def __rmul__(self, arg0: float) -> dRowMajor_EigenSparseMatrix:
        ...
    def __sub__(self, arg0: dRowMajor_EigenSparseMatrix) -> dRowMajor_EigenSparseMatrix:
        ...
    def get_element(self, arg0: int, arg1: int) -> float:
        ...
    def mat_vec_mul(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def matmul(self, arg0: dRowMajor_EigenSparseMatrix) -> dRowMajor_EigenSparseMatrix:
        ...
    def set_element(self, arg0: int, arg1: int, arg2: float) -> None:
        ...
    def spmv(self, arg0: Program, arg1: NdarrayCxx, arg2: NdarrayCxx) -> None:
        ...
    def transpose(self) -> dRowMajor_EigenSparseMatrix:
        ...
class fColMajor_EigenSparseMatrix(SparseMatrix):
    def __add__(self, arg0: fColMajor_EigenSparseMatrix) -> fColMajor_EigenSparseMatrix:
        ...
    def __iadd__(self, arg0: fColMajor_EigenSparseMatrix) -> fColMajor_EigenSparseMatrix:
        ...
    def __imul__(self, arg0: float) -> fColMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: DataTypeCxx) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: fColMajor_EigenSparseMatrix) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: scipy.sparse.csc_matrix) -> None:
        ...
    def __isub__(self, arg0: fColMajor_EigenSparseMatrix) -> fColMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> fColMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: fColMajor_EigenSparseMatrix) -> fColMajor_EigenSparseMatrix:
        ...
    def __rmul__(self, arg0: float) -> fColMajor_EigenSparseMatrix:
        ...
    def __sub__(self, arg0: fColMajor_EigenSparseMatrix) -> fColMajor_EigenSparseMatrix:
        ...
    def get_element(self, arg0: int, arg1: int) -> float:
        ...
    def mat_vec_mul(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def matmul(self, arg0: fColMajor_EigenSparseMatrix) -> fColMajor_EigenSparseMatrix:
        ...
    def set_element(self, arg0: int, arg1: int, arg2: float) -> None:
        ...
    def spmv(self, arg0: Program, arg1: NdarrayCxx, arg2: NdarrayCxx) -> None:
        ...
    def transpose(self) -> fColMajor_EigenSparseMatrix:
        ...
class fRowMajor_EigenSparseMatrix(SparseMatrix):
    def __add__(self, arg0: fRowMajor_EigenSparseMatrix) -> fRowMajor_EigenSparseMatrix:
        ...
    def __iadd__(self, arg0: fRowMajor_EigenSparseMatrix) -> fRowMajor_EigenSparseMatrix:
        ...
    def __imul__(self, arg0: float) -> fRowMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: DataTypeCxx) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: fRowMajor_EigenSparseMatrix) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: scipy.sparse.csr_matrix) -> None:
        ...
    def __isub__(self, arg0: fRowMajor_EigenSparseMatrix) -> fRowMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> fRowMajor_EigenSparseMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: fRowMajor_EigenSparseMatrix) -> fRowMajor_EigenSparseMatrix:
        ...
    def __rmul__(self, arg0: float) -> fRowMajor_EigenSparseMatrix:
        ...
    def __sub__(self, arg0: fRowMajor_EigenSparseMatrix) -> fRowMajor_EigenSparseMatrix:
        ...
    def get_element(self, arg0: int, arg1: int) -> float:
        ...
    def mat_vec_mul(self, arg0: numpy.ndarray[numpy.float32[m, 1]]) -> numpy.ndarray[numpy.float32[m, 1]]:
        ...
    def matmul(self, arg0: fRowMajor_EigenSparseMatrix) -> fRowMajor_EigenSparseMatrix:
        ...
    def set_element(self, arg0: int, arg1: int, arg2: float) -> None:
        ...
    def spmv(self, arg0: Program, arg1: NdarrayCxx, arg2: NdarrayCxx) -> None:
        ...
    def transpose(self) -> fRowMajor_EigenSparseMatrix:
        ...
def arch_from_name(arg0: str) -> Arch:
    ...
def arch_name(arg0: Arch) -> str:
    ...
def arch_uses_llvm(arg0: Arch) -> bool:
    ...
def bits_cast(arg0: ExprCxx, arg1: DataTypeCxx) -> ExprCxx:
    ...
def clear_profile_info() -> None:
    ...
def create_benchmark(arg0: str) -> ...:
    ...
def create_initialized_benchmark(arg0: str, arg1: ...) -> ...:
    ...
def create_initialized_task(arg0: str, arg1: ...) -> ...:
    ...
def create_mesh() -> MeshPtr:
    ...
def create_task(arg0: str) -> ...:
    ...
def critical(arg0: str) -> None:
    ...
def data_type_name(arg0: DataTypeCxx) -> str:
    ...
def data_type_size(arg0: DataTypeCxx) -> int:
    ...
def debug(arg0: str) -> None:
    ...
def default_compile_config() -> CompileConfig:
    ...
def element_order(arg0: MeshElementType) -> int:
    ...
def element_type_name(arg0: MeshElementType) -> str:
    ...
def error(arg0: str) -> None:
    ...
def expr_abs(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_acos(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_add(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_asin(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_assume_in_range(arg0: ExprCxx, arg1: ExprCxx, arg2: int, arg3: int, arg4: DebugInfo) -> ExprCxx:
    ...
def expr_atan2(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_atomic_add(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_atomic_bit_and(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_atomic_bit_or(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_atomic_bit_xor(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_atomic_max(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_atomic_min(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_atomic_mul(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_atomic_sub(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_bit_and(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_bit_not(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_bit_or(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_bit_sar(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_bit_shl(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_bit_shr(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_bit_xor(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_ceil(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_clz(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_cmp_eq(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_cmp_ge(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_cmp_gt(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_cmp_le(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_cmp_lt(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_cmp_ne(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_cos(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_div(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_exp(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_field(arg0: ExprCxx, arg1: DataTypeCxx) -> ExprCxx:
    ...
def expr_floor(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_floordiv(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_frexp(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_ifte(arg0: ExprCxx, arg1: ExprCxx, arg2: ExprCxx) -> ExprCxx:
    ...
def expr_inv(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_log(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_logic_not(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_logical_and(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_logical_or(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_loop_unique(arg0: ExprCxx, arg1: list[SNodeCxx], arg2: DebugInfo) -> ExprCxx:
    ...
def expr_matrix_field(arg0: list[ExprCxx], arg1: tuple[int, ...]) -> ExprCxx:
    ...
def expr_max(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_min(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_mod(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_mul(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_neg(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_popcnt(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_pow(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_rcp(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_round(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_rsqrt(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_select(arg0: ExprCxx, arg1: ExprCxx, arg2: ExprCxx) -> ExprCxx:
    ...
def expr_sin(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_sqrt(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_sub(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def expr_tan(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_tanh(arg0: ExprCxx) -> ExprCxx:
    ...
def expr_truediv(arg0: ExprCxx, arg1: ExprCxx) -> ExprCxx:
    ...
def finalize_snode_tree(arg0: SNodeRegistry, arg1: SNodeCxx, arg2: Program, arg3: bool) -> SNodeTreeCxx:
    ...
def flush_log() -> None:
    ...
def from_end_element_order(arg0: MeshRelationType) -> int:
    ...
def get_commit_hash() -> str:
    ...
def get_default_float_size() -> int:
    ...
def get_external_tensor_dim(arg0: ExprCxx) -> int:
    ...
def get_external_tensor_element_dim(arg0: ExprCxx) -> int:
    ...
def get_external_tensor_element_shape(arg0: ExprCxx) -> tuple[int, ...]:
    ...
def get_external_tensor_element_type(arg0: ExprCxx) -> DataTypeCxx:
    ...
def get_external_tensor_needs_grad(arg0: ExprCxx) -> bool:
    ...
def get_external_tensor_real_func_args(arg0: ExprCxx, arg1: DebugInfo) -> list[ExprCxx]:
    ...
def get_external_tensor_shape_along_axis(arg0: ExprCxx, arg1: int, arg2: DebugInfo) -> ExprCxx:
    ...
def get_llvm_target_support() -> str:
    ...
def get_max_num_indices() -> int:
    ...
def get_num_elements(arg0: MeshPtr, arg1: MeshElementType) -> int:
    ...
def get_python_package_dir() -> str:
    ...
def get_relation_access(arg0: ..., arg1: ExprCxx, arg2: ..., arg3: ExprCxx, arg4: DebugInfo) -> ExprCxx:
    ...
def get_relation_size(arg0: ..., arg1: ExprCxx, arg2: ..., arg3: DebugInfo) -> ExprCxx:
    ...
def get_repo_dir() -> str:
    ...
def get_type_factory_instance() -> TypeFactory:
    ...
def get_version_major() -> int:
    ...
def get_version_minor() -> int:
    ...
def get_version_patch() -> int:
    ...
def get_version_string() -> str:
    ...
def host_arch() -> Arch:
    ...
def info(arg0: str) -> None:
    ...
def insert_internal_func_call(arg0: ..., arg1: ExprGroup) -> ExprCxx:
    ...
def inverse_relation(arg0: MeshRelationType) -> MeshRelationType:
    ...
def is_extension_supported(arg0: Arch, arg1: Extension) -> bool:
    ...
def is_integral(arg0: DataTypeCxx) -> bool:
    ...
def is_quant(arg0: DataTypeCxx) -> bool:
    ...
def is_real(arg0: DataTypeCxx) -> bool:
    ...
def is_signed(arg0: DataTypeCxx) -> bool:
    ...
def is_tensor(arg0: DataTypeCxx) -> bool:
    ...
def is_unsigned(arg0: DataTypeCxx) -> bool:
    ...
def libdevice_path() -> str:
    ...
def logging_effective(arg0: str) -> bool:
    ...
def make_arg_load_expr(arg_id: tuple[int, ...], dt: DataTypeCxx, is_ptr: bool = False, create_load: bool = True, dbg_info: DebugInfo = ...) -> ExprCxx:
    ...
def make_binary_op_expr(arg0: BinaryOpType, arg1: ExprCxx, arg2: ExprCxx) -> ExprCxx:
    ...
def make_const_expr_bool(arg0: DataType, arg1: bool | np.bool_) -> ExprCxx:
    ...
def make_const_expr_fp(arg0: DataType, arg1: float | np.floating) -> ExprCxx:
    ...
def make_const_expr_int(arg0: DataType, arg1: int | np.int32 | np.int64) -> ExprCxx:
    ...
def make_cucg_solver(arg0: SparseMatrix, arg1: int, arg2: float, arg3: bool) -> CUCG:
    ...
def make_cusparse_solver(arg0: DataTypeCxx, arg1: str, arg2: str) -> SparseSolver:
    ...
def make_double_cg_solver(arg0: SparseMatrix, arg1: int, arg2: float, arg3: bool) -> CGd:
    ...
def make_external_tensor_expr(arg0: DataTypeCxx, arg1: int, arg2: tuple[int, ...], arg3: bool, arg4: BoundaryMode) -> ExprCxx:
    ...
def make_external_tensor_grad_expr(arg0: ExprCxx) -> ExprCxx:
    ...
def make_float_cg_solver(arg0: SparseMatrix, arg1: int, arg2: float, arg3: bool) -> CGf:
    ...
def make_frontend_assign_stmt(arg0: ExprCxx, arg1: ExprCxx, arg2: DebugInfo) -> Stmt:
    ...
def make_get_element_expr(arg0: Expr, arg1: tuple[int, ...], arg2: DebugInfo) -> ExprCxx:
    ...
def make_global_load_stmt(arg0: Stmt) -> Stmt:
    ...
def make_global_store_stmt(arg0: Stmt, arg1: Stmt) -> Stmt:
    ...
def make_rand_expr(arg0: DataTypeCxx, arg1: DebugInfo) -> ExprCxx:
    ...
def make_reference(arg0: ExprCxx, arg1: DebugInfo) -> ExprCxx:
    ...
def make_sparse_solver(arg0: DataTypeCxx, arg1: str, arg2: str) -> SparseSolver:
    ...
def make_unary_op_expr(arg0: UnaryOpType, arg1: ExprCxx) -> ExprCxx:
    ...
def pop_python_print_buffer() -> str:
    ...
def print_all_units() -> None:
    ...
def print_profile_info() -> None:
    ...
def promoted_type(arg0: DataTypeCxx, arg1: DataTypeCxx) -> DataTypeCxx:
    ...
def query_int64(arg0: str) -> int:
    ...
def relation_by_orders(arg0: int, arg1: int) -> MeshRelationType:
    ...
def reset_default_compile_config() -> None:
    ...
def set_core_state_python_imported(arg0: bool) -> None:
    ...
def set_core_trigger_gdb_when_crash(arg0: bool) -> None:
    ...
def set_index_mapping(arg0: MeshPtr, arg1: MeshElementType, arg2: ConvType, arg3: SNodeCxx) -> None:
    ...
def set_lib_dir(arg0: str) -> None:
    ...
def set_logging_level(arg0: str) -> None:
    ...
def set_logging_level_default() -> None:
    ...
def set_num_elements(arg0: MeshPtr, arg1: MeshElementType, arg2: int) -> None:
    ...
def set_num_patches(arg0: MeshPtr, arg1: int) -> None:
    ...
def set_owned_offset(arg0: MeshPtr, arg1: MeshElementType, arg2: SNodeCxx) -> None:
    ...
def set_patch_max_element_num(arg0: MeshPtr, arg1: MeshElementType, arg2: int) -> None:
    ...
def set_python_package_dir(arg0: str) -> None:
    ...
def set_relation_dynamic(arg0: MeshPtr, arg1: MeshRelationType, arg2: SNodeCxx, arg3: SNodeCxx, arg4: SNodeCxx) -> None:
    ...
def set_relation_fixed(arg0: MeshPtr, arg1: MeshRelationType, arg2: SNodeCxx) -> None:
    ...
def set_tmp_dir(arg0: str) -> None:
    ...
def set_total_offset(arg0: MeshPtr, arg1: MeshElementType, arg2: SNodeCxx) -> None:
    ...
def set_vulkan_visible_device(arg0: str) -> None:
    ...
def start_memory_monitoring(arg0: str, arg1: int, arg2: float) -> None:
    ...
def subscript_with_multiple_indices(arg0: ExprCxx, arg1: list[ExprGroup], arg2: tuple[int, ...], arg3: DebugInfo) -> ExprCxx:
    ...
def test_cpp_exception() -> None:
    ...
def test_logging() -> None:
    ...
def test_printf() -> None:
    ...
def test_raise_error() -> None:
    ...
def test_threading() -> bool:
    ...
@typing.overload
def test_throw() -> None:
    ...
@typing.overload
def test_throw() -> None:
    ...
def to_end_element_order(arg0: MeshRelationType) -> int:
    ...
def toggle_python_print_buffer(arg0: bool) -> None:
    ...
def trace(arg0: str) -> None:
    ...
def trigger_crash() -> None:
    ...
def trigger_sig_fpe() -> int:
    ...
def value_cast(arg0: ExprCxx, arg1: DataTypeCxx) -> ExprCxx:
    ...
def wait_for_debugger() -> None:
    ...
def warn(arg0: str) -> None:
    ...
def with_amdgpu() -> bool:
    ...
def with_cuda() -> bool:
    ...
def with_metal() -> bool:
    ...
def with_vulkan() -> bool:
    ...
ADJOINT: SNodeGradType  # value = <SNodeGradType.ADJOINT: 1>
ADJOINT_CHECKBIT: SNodeGradType  # value = <SNodeGradType.ADJOINT_CHECKBIT: 3>
AOS: Layout  # value = <Layout.AOS: 0>
CC: MeshRelationType  # value = <MeshRelationType.CC: 15>
CE: MeshRelationType  # value = <MeshRelationType.CE: 13>
CF: MeshRelationType  # value = <MeshRelationType.CF: 14>
CLAMP: BoundaryMode  # value = <BoundaryMode.CLAMP: 1>
CV: MeshRelationType  # value = <MeshRelationType.CV: 12>
Cell: MeshElementType  # value = <MeshElementType.Cell: 3>
DUAL: SNodeGradType  # value = <SNodeGradType.DUAL: 2>
DataType_f16: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_f32: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_f64: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_gen: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_i16: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_i32: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_i64: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_i8: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_u1: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_u16: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_u32: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_u64: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_u8: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
DataType_unknown: DataTypeCxx  # value = <gstaichi._lib.core.gstaichi_python.DataTypeCxx object>
EC: MeshRelationType  # value = <MeshRelationType.EC: 7>
EE: MeshRelationType  # value = <MeshRelationType.EE: 5>
EF: MeshRelationType  # value = <MeshRelationType.EF: 6>
EV: MeshRelationType  # value = <MeshRelationType.EV: 4>
Edge: MeshElementType  # value = <MeshElementType.Edge: 1>
FC: MeshRelationType  # value = <MeshRelationType.FC: 11>
FE: MeshRelationType  # value = <MeshRelationType.FE: 9>
FF: MeshRelationType  # value = <MeshRelationType.FF: 10>
FORWARD: AutodiffMode  # value = <AutodiffMode.FORWARD: 0>
FV: MeshRelationType  # value = <MeshRelationType.FV: 8>
Face: MeshElementType  # value = <MeshElementType.Face: 2>
NONE: AutodiffMode  # value = <AutodiffMode.NONE: 2>
NULL: Layout  # value = <Layout.NULL: 2>
PRIMAL: SNodeGradType  # value = <SNodeGradType.PRIMAL: 0>
REVERSE: AutodiffMode  # value = <AutodiffMode.REVERSE: 1>
SOA: Layout  # value = <Layout.SOA: 1>
Tetrahedron: MeshTopology  # value = <MeshTopology.Tetrahedron: 4>
Triangle: MeshTopology  # value = <MeshTopology.Triangle: 3>
UNSAFE: BoundaryMode  # value = <BoundaryMode.UNSAFE: 0>
VALIDATION: AutodiffMode  # value = <AutodiffMode.VALIDATION: 3>
VC: MeshRelationType  # value = <MeshRelationType.VC: 3>
VE: MeshRelationType  # value = <MeshRelationType.VE: 1>
VF: MeshRelationType  # value = <MeshRelationType.VF: 2>
VV: MeshRelationType  # value = <MeshRelationType.VV: 0>
Vertex: MeshElementType  # value = <MeshElementType.Vertex: 0>
abs: UnaryOpType  # value = <UnaryOpType.abs: 8>
acos: UnaryOpType  # value = <UnaryOpType.acos: 13>
add: BinaryOpType  # value = <BinaryOpType.add: 1>
adstack: Extension  # value = <Extension.adstack: 5>
amdgpu: Arch  # value = <Arch.amdgpu: 6>
arm64: Arch  # value = <Arch.arm64: 1>
asin: UnaryOpType  # value = <UnaryOpType.asin: 11>
assertion: Extension  # value = <Extension.assertion: 7>
atan2: BinaryOpType  # value = <BinaryOpType.atan2: 21>
bit_and: BinaryOpType  # value = <BinaryOpType.bit_and: 9>
bit_not: UnaryOpType  # value = <UnaryOpType.bit_not: 23>
bit_or: BinaryOpType  # value = <BinaryOpType.bit_or: 10>
bit_sar: BinaryOpType  # value = <BinaryOpType.bit_sar: 14>
bit_shl: BinaryOpType  # value = <BinaryOpType.bit_shl: 12>
bit_shr: BinaryOpType  # value = <BinaryOpType.bit_shr: 13>
bit_struct: SNodeType  # value = <SNodeType.bit_struct: 7>
bit_xor: BinaryOpType  # value = <BinaryOpType.bit_xor: 11>
bitmasked: SNodeType  # value = <SNodeType.bitmasked: 4>
block_local: SNodeAccessFlag  # value = <SNodeAccessFlag.block_local: 0>
bls: Extension  # value = <Extension.bls: 6>
cast_bits: UnaryOpType  # value = <UnaryOpType.cast_bits: 7>
cast_value: UnaryOpType  # value = <UnaryOpType.cast_value: 6>
ceil: UnaryOpType  # value = <UnaryOpType.ceil: 5>
clz: UnaryOpType  # value = <UnaryOpType.clz: 21>
cmp_eq: BinaryOpType  # value = <BinaryOpType.cmp_eq: 19>
cmp_ge: BinaryOpType  # value = <BinaryOpType.cmp_ge: 18>
cmp_gt: BinaryOpType  # value = <BinaryOpType.cmp_gt: 17>
cmp_le: BinaryOpType  # value = <BinaryOpType.cmp_le: 16>
cmp_lt: BinaryOpType  # value = <BinaryOpType.cmp_lt: 15>
cmp_ne: BinaryOpType  # value = <BinaryOpType.cmp_ne: 20>
cos: UnaryOpType  # value = <UnaryOpType.cos: 12>
cuda: Arch  # value = <Arch.cuda: 3>
data64: Extension  # value = <Extension.data64: 4>
dense: SNodeType  # value = <SNodeType.dense: 1>
div: BinaryOpType  # value = <BinaryOpType.div: 5>
dynamic: SNodeType  # value = <SNodeType.dynamic: 2>
exp: UnaryOpType  # value = <UnaryOpType.exp: 18>
extfunc: Extension  # value = <Extension.extfunc: 8>
floor: UnaryOpType  # value = <UnaryOpType.floor: 3>
floordiv: BinaryOpType  # value = <BinaryOpType.floordiv: 4>
frexp: UnaryOpType  # value = <UnaryOpType.frexp: 4>
g2r: ConvType  # value = <ConvType.g2r: 2>
hash: SNodeType  # value = <SNodeType.hash: 5>
inv: UnaryOpType  # value = <UnaryOpType.inv: 16>
js: Arch  # value = <Arch.js: 2>
l2g: ConvType  # value = <ConvType.l2g: 0>
l2r: ConvType  # value = <ConvType.l2r: 1>
log: UnaryOpType  # value = <UnaryOpType.log: 19>
logic_not: UnaryOpType  # value = <UnaryOpType.logic_not: 24>
max: BinaryOpType  # value = <BinaryOpType.max: 7>
mesh: Extension  # value = <Extension.mesh: 2>
mesh_local: SNodeAccessFlag  # value = <SNodeAccessFlag.mesh_local: 2>
metal: Arch  # value = <Arch.metal: 4>
min: BinaryOpType  # value = <BinaryOpType.min: 8>
mod: BinaryOpType  # value = <BinaryOpType.mod: 6>
mul: BinaryOpType  # value = <BinaryOpType.mul: 0>
neg: UnaryOpType  # value = <UnaryOpType.neg: 0>
opencl: Arch  # value = <Arch.opencl: 5>
place: SNodeType  # value = <SNodeType.place: 6>
pointer: SNodeType  # value = <SNodeType.pointer: 3>
popcnt: UnaryOpType  # value = <UnaryOpType.popcnt: 20>
pow: BinaryOpType  # value = <BinaryOpType.pow: 22>
quant: Extension  # value = <Extension.quant: 1>
quant_array: SNodeType  # value = <SNodeType.quant_array: 8>
quant_basic: Extension  # value = <Extension.quant_basic: 3>
rcp: UnaryOpType  # value = <UnaryOpType.rcp: 17>
read_only: SNodeAccessFlag  # value = <SNodeAccessFlag.read_only: 1>
reserved: DeviceCapability  # value = <DeviceCapability.reserved: 0>
root: SNodeType  # value = <SNodeType.root: 0>
round: UnaryOpType  # value = <UnaryOpType.round: 2>
rsqrt: UnaryOpType  # value = <UnaryOpType.rsqrt: 22>
sgn: UnaryOpType  # value = <UnaryOpType.sgn: 9>
sin: UnaryOpType  # value = <UnaryOpType.sin: 10>
sparse: Extension  # value = <Extension.sparse: 0>
spirv_has_atomic_float: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float: 11>
spirv_has_atomic_float16: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float16: 8>
spirv_has_atomic_float16_add: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float16_add: 9>
spirv_has_atomic_float16_minmax: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float16_minmax: 10>
spirv_has_atomic_float64: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float64: 14>
spirv_has_atomic_float64_add: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float64_add: 15>
spirv_has_atomic_float64_minmax: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float64_minmax: 16>
spirv_has_atomic_float_add: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float_add: 12>
spirv_has_atomic_float_minmax: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_float_minmax: 13>
spirv_has_atomic_int64: DeviceCapability  # value = <DeviceCapability.spirv_has_atomic_int64: 7>
spirv_has_float16: DeviceCapability  # value = <DeviceCapability.spirv_has_float16: 5>
spirv_has_float64: DeviceCapability  # value = <DeviceCapability.spirv_has_float64: 6>
spirv_has_int16: DeviceCapability  # value = <DeviceCapability.spirv_has_int16: 3>
spirv_has_int64: DeviceCapability  # value = <DeviceCapability.spirv_has_int64: 4>
spirv_has_int8: DeviceCapability  # value = <DeviceCapability.spirv_has_int8: 2>
spirv_has_no_integer_wrap_decoration: DeviceCapability  # value = <DeviceCapability.spirv_has_no_integer_wrap_decoration: 24>
spirv_has_non_semantic_info: DeviceCapability  # value = <DeviceCapability.spirv_has_non_semantic_info: 23>
spirv_has_physical_storage_buffer: DeviceCapability  # value = <DeviceCapability.spirv_has_physical_storage_buffer: 18>
spirv_has_shader_clock: DeviceCapability  # value = <DeviceCapability.spirv_has_shader_clock: 25>
spirv_has_subgroup_arithmetic: DeviceCapability  # value = <DeviceCapability.spirv_has_subgroup_arithmetic: 21>
spirv_has_subgroup_ballot: DeviceCapability  # value = <DeviceCapability.spirv_has_subgroup_ballot: 22>
spirv_has_subgroup_basic: DeviceCapability  # value = <DeviceCapability.spirv_has_subgroup_basic: 19>
spirv_has_subgroup_vote: DeviceCapability  # value = <DeviceCapability.spirv_has_subgroup_vote: 20>
spirv_has_variable_ptr: DeviceCapability  # value = <DeviceCapability.spirv_has_variable_ptr: 17>
spirv_version: DeviceCapability  # value = <DeviceCapability.spirv_version: 1>
sqrt: UnaryOpType  # value = <UnaryOpType.sqrt: 1>
sub: BinaryOpType  # value = <BinaryOpType.sub: 2>
tan: UnaryOpType  # value = <UnaryOpType.tan: 14>
tanh: UnaryOpType  # value = <UnaryOpType.tanh: 15>
truediv: BinaryOpType  # value = <BinaryOpType.truediv: 3>
undefined: UnaryOpType  # value = <UnaryOpType.undefined: 25>
vulkan: Arch  # value = <Arch.vulkan: 7>
x64: Arch  # value = <Arch.x64: 0>
