---
alwaysApply: true
---
# Documentation Practices: NO SUMMARY DOCUMENTS

## ⚠️ CRITICAL RULE: NEVER CREATE SUMMARY DOCUMENTS

**NEVER create standalone summary `.md` files** documenting implementation changes, fixes, refactorings, or feature additions. These waste tokens and are never read.

❌ **DO NOT CREATE FILES LIKE**:
- `FIX_SUMMARY.md`
- `IMPLEMENTATION_SUMMARY.md`
- `REFACTORING_COMPLETE.md`
- `FEATURE_IMPLEMENTATION.md`
- `CHANGES_SUMMARY.md`
- Any other standalone documentation of completed work

## Instead: Four-Part Documentation Strategy

All information from implementation sessions must flow into these four locations:

### 1. **Chat Summary** (Immediate Communication)

At the end of each implementation session, provide a **structured summary in the chat** with these sections:

```markdown
## Implementation Summary

### What Was Changed
- Brief list of files modified and their changes
- High-level description of the fix/feature

### Why These Changes Were Needed
- Root cause of the issue (if a fix)
- Rationale for the design decision (if a feature)
- Problems with previous implementation (if a refactoring)

### Alternatives Considered
- What other approaches were evaluated
- Why they were rejected
- Trade-offs of the chosen approach

### Testing
- New testcases added (with file paths)
- Existing testcases updated (with file paths)
- Edge cases now covered

### Documentation Updates
- Architecture docs updated (with file paths)
- User guide sections updated (with file paths)
- API docstrings updated (with file/class/method references)

### Other Changes
- Configuration changes
- Dependencies added/removed
- Breaking changes (if any)
```

**This chat summary is the ONLY place for quick, session-level documentation.**

---

### 2. **Architecture Documentation** (Historical + Technical)

Location: `concurry/docs/architecture/`

**When to Update**: For ANY architectural change, design decision, or significant refactoring.

**What to Include**:
1. **Current Implementation**: How the system works now
2. **Historical Context**: Previous implementations and their issues
3. **Why the Change**: What problems were encountered
4. **Example Code**: For each approach (previous and current)
5. **Trade-offs**: Pros and cons of the design

**Format Example**:

```markdown
## Feature: Worker Submission Queue

### Current Implementation (Version 3 - October 2025)

[Detailed explanation of current approach]

**Example:**
```python
# Current implementation code
```

**Why This Works:**
- Reason 1
- Reason 2

---

### Previous Implementation (Version 2 - September 2025)

**Approach:**
[Description of previous approach]

**Example:**
```python
# Previous implementation code
```

**Issues Encountered:**
1. Race condition when stop() called during submission
2. Semaphore not released if worker stopped
3. Futures could be returned after pool stopped

**Why It Failed:**
[Detailed explanation]

---

### Initial Implementation (Version 1 - August 2025)

[Similar structure]
```

**Key Files**:
- `docs/architecture/workers.md` - Worker system architecture
- `docs/architecture/synchronization.md` - wait()/gather() and futures
- `docs/architecture/limits.md` - Rate limiting and resource limits
- `docs/architecture/retries.md` - Retry logic and configuration
- `docs/architecture/configuration.md` - Global config system
- `docs/architecture/task-worker.md` - TaskWorker specifics

**Create NEW architecture docs** when implementing completely new subsystems.

---

### 3. **User Guide + API Docstrings** (User-Facing Behavior)

Location: `concurry/docs/user-guide/` and module docstrings

**When to Update**: ONLY when user-facing behavior changes.

**DO Update When**:
- ✅ New public API added
- ✅ Public API signature changed
- ✅ New parameters or options available
- ✅ Default behavior changed
- ✅ New execution mode added
- ✅ New feature users can interact with

**DO NOT Update When**:
- ❌ Backend implementation fixed (no behavior change)
- ❌ Internal refactoring (same external API)
- ❌ Performance optimization (no API change)
- ❌ Bug fix that restores expected behavior

**User Guide Structure**:
```markdown
## Feature Name

### Overview
Brief description of what the feature does and when to use it.

### Basic Usage
```python
# Minimal working example
```

### Common Patterns
```python
# Pattern 1: Common use case
```

```python
# Pattern 2: Another common use case
```

### Advanced Usage
```python
# Complex example with all options
```

### Configuration
- List of relevant config keys (reference, not full docs)
- Link to API docs for details

### Troubleshooting
Common issues and solutions.
```

**API Docstrings**:
- Include parameter descriptions
- Reference config keys for defaults (e.g., "Defaults to `global_config.defaults.worker_timeout`")
- Provide usage examples
- Document exceptions raised
- **NEVER hardcode default values in docstrings**

**Global Config Defaults**:
- ❌ DO NOT document all config keys in user guide
- ✅ DO mention relevant config keys in context
- ✅ Full config documentation belongs in API reference

---

### 4. **Testcases** (Executable Edge Case Documentation)

Location: `concurry/tests/` (in appropriate subdirectories)

**When to Add**: Whenever novel edge cases are discovered or tested during implementation.

**Requirements for ALL New Testcases**:

#### 1. Test All Execution Modes

```python
def test_feature_name(self, worker_mode):
    """
    Test [what is being tested] across all execution modes.
    
    This test verifies [specific behavior] when [conditions].
    
    Steps:
    1. Create worker with [configuration]
    2. Submit [number] tasks with [characteristics]
    3. Call [operation] under [conditions]
    4. Verify [expected outcomes]
    5. Clean up resources
    
    Edge cases covered:
    - [Edge case 1]
    - [Edge case 2]
    """
    w = MyWorker.options(mode=worker_mode).init()
    
    # Test implementation
    
    w.stop()
```

**NEVER skip modes just because test would fail** - fix the implementation instead.

Only skip when feature is fundamentally unsupported:
```python
def test_pool_feature(self, worker_mode):
    """Test feature requiring multiple workers."""
    if worker_mode in ("sync", "asyncio"):
        pytest.skip("Sync and asyncio modes only support max_workers=1")
    
    # Pool-specific test
```

#### 2. Detailed Docstrings

Every test must have a docstring with:
1. **What** is being tested (one-line summary)
2. **Why** this test exists (what scenario/edge case)
3. **Steps** taken in the test (numbered list)
4. **Expected outcome** (what should happen)
5. **Edge cases** covered (if applicable)

**Example** (from `test_stop_race_condition.py`):

```python
def test_pool_stop_with_all_workers_busy(self, pool_mode):
    """
    Test stopping pool when all workers are busy and queue is full.
    
    This test verifies correct behavior when stop() is called while:
    - All workers have tasks in their queues
    - All workers are actively processing
    - Additional tasks are submitted after queue is full
    
    Steps:
    1. Create pool with 3 workers, max_queued_tasks=2, round-robin balancing
    2. Submit 6 tasks to fill all worker queues (3 workers × 2 queue = 6 tasks)
    3. Wait briefly for tasks to start processing
    4. Submit 3 more tasks (returns immediately with futures)
    5. Call stop() on the pool while tasks are in flight
    6. Verify pending futures are cancelled or completed
    7. Verify pool statistics reflect stopped state
    
    Edge cases:
    - Tasks in queue when stop() called
    - Tasks actively executing when stop() called
    - Futures returned but not yet queued when stop() called
    """
    # Test implementation
```

#### 3. Test File Organization

```
tests/
├── core/
│   ├── worker/
│   │   ├── test_worker_basic.py          # Basic worker operations
│   │   ├── test_worker_pools.py          # Pool-specific tests
│   │   ├── test_stop_race_condition.py   # Stop() edge cases
│   │   └── test_submission_queue.py      # Submission queue tests
│   ├── future/
│   │   └── test_futures.py
│   ├── synchronization/
│   │   ├── test_wait.py
│   │   └── test_gather.py
│   └── limits/
│       ├── test_limits.py
│       └── test_limitpool.py
├── integration/
│   └── test_worker_retry.py              # Integration tests
└── test_global_config.py
```

---

## Decision Matrix: Where Does Information Go?

| Information Type | Chat Summary | Architecture Docs | User Guide | API Docstrings | Testcases |
|-----------------|--------------|-------------------|------------|----------------|-----------|
| Files modified | ✅ | ❌ | ❌ | ❌ | ❌ |
| Root cause of bug | ✅ | ✅ (if architectural) | ❌ | ❌ | ❌ |
| Previous failed approaches | ✅ | ✅ | ❌ | ❌ | ❌ |
| Design rationale | ✅ | ✅ | ❌ | ❌ | ❌ |
| System architecture | ❌ | ✅ | ❌ | ❌ | ❌ |
| Historical implementations | ❌ | ✅ | ❌ | ❌ | ❌ |
| Why change was needed | ✅ | ✅ | ❌ | ❌ | ❌ |
| Example code (technical) | ❌ | ✅ | ❌ | ❌ | ❌ |
| User-facing API | ❌ | ❌ | ✅ | ✅ | ❌ |
| Usage examples | ❌ | ❌ | ✅ | ✅ | ❌ |
| Parameters/options | ❌ | ❌ | ✅ (summary) | ✅ (detailed) | ❌ |
| Config keys | ✅ | ❌ | ✅ (reference) | ✅ (as defaults) | ❌ |
| Edge cases discovered | ✅ | ❌ | ❌ | ❌ | ✅ |
| Test coverage added | ✅ | ❌ | ❌ | ❌ | ✅ |
| Breaking changes | ✅ | ✅ | ✅ | ✅ | ✅ |

---

## Example: Correct Documentation Flow

**Scenario**: Fixed race condition in worker stop() method (backend-only bug fix)

**1. Chat Summary** (✅ Always provide):
```markdown
## Implementation Summary
### What Was Changed
- Modified `src/concurry/core/worker/thread_worker.py`
- Added lock acquisition before checking stopped flag

### Why
- Race condition: stop() could be called during task submission
- Futures could be returned after worker stopped

### Alternatives Considered
- Atomic flag check: Rejected (complexity)
- Queue timeout: Rejected (performance)

### Testing & Documentation
- Updated `tests/core/worker/test_stop_race_condition.py`
- Updated `docs/architecture/workers.md` Section 4.3
- User guide: No changes (internal fix)
```

**2. Architecture Docs** (✅ Updated `docs/architecture/workers.md`):
- Document previous implementation and why it failed
- Document current implementation and why it works

**3. User Guide** (❌ No update needed - internal fix, no behavior change)

**4. Testcases** (✅ Added `test_worker_stop_during_submission()`)

**5. Summary .md File** (❌ NEVER CREATE)

---

## Common Mistakes to Avoid

❌ **Creating summary .md files** → ✅ Use chat summary + update architecture docs
❌ **Not updating architecture docs** → ✅ Document what was broken and why fix works  
❌ **Updating user guide for internal changes** → ✅ Only update if external behavior changes
❌ **Brief testcase docstrings** → ✅ Include what/why/steps/edge cases
❌ **Hardcoding defaults in docstrings** → ✅ Reference `global_config.defaults.key_name`

---

## Checklist: End of Implementation Session

Before completing any implementation session, verify:

- [ ] **Chat summary provided** with all required sections
- [ ] **Architecture docs updated** (if architectural change)
- [ ] **User guide updated** (if user-facing behavior changed)
- [ ] **API docstrings updated** (if parameters/behavior changed)
- [ ] **Testcases added** for novel edge cases discovered
- [ ] **Test docstrings detailed** with steps and edge cases
- [ ] **All tests pass** across all execution modes
- [ ] **NO summary .md files created**

---

## Why This Matters

**The Problem with Summary Documents**:
1. Token waste (large files in context)
2. Never read by user
3. Clutter repository
4. Duplicate information
5. Become stale quickly
6. Hard to find relevant info later

**The Solution - Four-Part Strategy**:
1. **Chat**: Immediate communication to user
2. **Architecture**: Permanent technical record with history
3. **User Guide**: User-facing behavior and examples
4. **Testcases**: Executable edge case documentation

This ensures:
- ✅ No duplication
- ✅ Information in right place
- ✅ Easy to find later
- ✅ Stays up-to-date
- ✅ Minimal token usage
- ✅ Maximum value

---

## Quick Reference

| You Need To... | Use This |
|----------------|----------|
| Communicate to user what was done | Chat summary |
| Document design decisions | Architecture docs |
| Explain historical approaches | Architecture docs |
| Show technical implementation details | Architecture docs |
| Explain user-facing features | User guide |
| Document API parameters | API docstrings |
| Document edge cases | Testcases with detailed docstrings |
| Reference config defaults | API docstrings (config key reference) |
| List breaking changes | Chat + Architecture + User Guide |

**Remember**: If you're about to create a `.md` file that documents completed work → **STOP** → Use the four-part strategy instead.
