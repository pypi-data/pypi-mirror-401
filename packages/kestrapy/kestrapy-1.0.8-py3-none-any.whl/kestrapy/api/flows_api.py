# coding: utf-8

"""
    Kestra EE

    All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.

    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501
# Custom imports
import requests
import sseclient
import json
from typing import Generator


import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated
from kestrapy.models.bulk_response import BulkResponse
from kestrapy.models.concurrency_limit import ConcurrencyLimit
from kestrapy.models.flow import Flow
from kestrapy.models.flow_controller_task_validation_type import FlowControllerTaskValidationType
from kestrapy.models.flow_graph import FlowGraph
from kestrapy.models.flow_interface import FlowInterface
from kestrapy.models.flow_topology_graph import FlowTopologyGraph
from kestrapy.models.flow_with_source import FlowWithSource
from kestrapy.models.id_with_namespace import IdWithNamespace
from kestrapy.models.paged_results_concurrency_limit import PagedResultsConcurrencyLimit
from kestrapy.models.paged_results_flow import PagedResultsFlow
from kestrapy.models.paged_results_search_result_flow import PagedResultsSearchResultFlow
from kestrapy.models.query_filter import QueryFilter
from kestrapy.models.task import Task
from kestrapy.models.validate_constraint_violation import ValidateConstraintViolation

from kestrapy.api_client import ApiClient, RequestSerialized
from kestrapy.api_response import ApiResponse
from kestrapy.rest import RESTResponseType


class FlowsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def bulk_update_flows(
        self,
        delete: Annotated[StrictBool, Field(description="If missing flow should be deleted")],
        allow_namespace_child: Annotated[StrictBool, Field(description="If namespace child should are allowed to be updated")],
        tenant: StrictStr,
        namespace: Annotated[Optional[StrictStr], Field(description="The namespace where to update flows")] = None,
        body: Annotated[Optional[StrictStr], Field(description="A list of flows source code splitted with \"---\"")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[FlowInterface]:
        """Update from multiples yaml sources

        All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`

        :param delete: If missing flow should be deleted (required)
        :type delete: bool
                :param allow_namespace_child: If namespace child should are allowed to be updated (required)
        :type allow_namespace_child: bool
                :param tenant: (required)
        :type tenant: str
                :param namespace: The namespace where to update flows
        :type namespace: str
                :param body: A list of flows source code splitted with \"---\"
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._bulk_update_flows_serialize(
            delete=delete,
            allow_namespace_child=allow_namespace_child,
            tenant=tenant,
            namespace=namespace,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowInterface]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bulk_update_flows_with_http_info(
        self,
        delete: Annotated[StrictBool, Field(description="If missing flow should be deleted")],
        allow_namespace_child: Annotated[StrictBool, Field(description="If namespace child should are allowed to be updated")],
        tenant: StrictStr,
        namespace: Annotated[Optional[StrictStr], Field(description="The namespace where to update flows")] = None,
        body: Annotated[Optional[StrictStr], Field(description="A list of flows source code splitted with \"---\"")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[FlowInterface]]:
        """Update from multiples yaml sources

        All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`

        :param delete: If missing flow should be deleted (required)
        :type delete: bool
                :param allow_namespace_child: If namespace child should are allowed to be updated (required)
        :type allow_namespace_child: bool
                :param tenant: (required)
        :type tenant: str
                :param namespace: The namespace where to update flows
        :type namespace: str
                :param body: A list of flows source code splitted with \"---\"
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._bulk_update_flows_serialize(
            delete=delete,
            allow_namespace_child=allow_namespace_child,
            tenant=tenant,
            namespace=namespace,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowInterface]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _bulk_update_flows_serialize(
        self,
        delete,
        allow_namespace_child,
        tenant,
        namespace,
        body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if delete is not None:
            
            _query_params.append(('delete', delete))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if allow_namespace_child is not None:
            
            _query_params.append(('allowNamespaceChild', allow_namespace_child))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/x-yaml'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def create_flow(
        self,
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The flow source code")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowWithSource:
        """Create a flow from yaml source


        :param tenant: (required)
        :type tenant: str
                :param body: The flow source code (required)
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._create_flow_serialize(
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowWithSource",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_flow_with_http_info(
        self,
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The flow source code")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowWithSource]:
        """Create a flow from yaml source


        :param tenant: (required)
        :type tenant: str
                :param body: The flow source code (required)
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._create_flow_serialize(
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowWithSource",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _create_flow_serialize(
        self,
        tenant,
        body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/x-yaml'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def delete_flow(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> None:
        """Delete a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_flow_serialize(
            namespace=namespace,
            id=id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_flow_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[None]:
        """Delete a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_flow_serialize(
            namespace=namespace,
            id=id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _delete_flow_serialize(
        self,
        namespace,
        id,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter





        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def delete_flows_by_ids(
        self,
        tenant: StrictStr,
        id_with_namespace: Annotated[List[IdWithNamespace], Field(description="A list of tuple flow ID and namespace as flow identifiers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Delete flows by their IDs.


        :param tenant: (required)
        :type tenant: str
                :param id_with_namespace: A list of tuple flow ID and namespace as flow identifiers (required)
        :type id_with_namespace: List[IdWithNamespace]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_flows_by_ids_serialize(
            tenant=tenant,
            id_with_namespace=id_with_namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_flows_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        id_with_namespace: Annotated[List[IdWithNamespace], Field(description="A list of tuple flow ID and namespace as flow identifiers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Delete flows by their IDs.


        :param tenant: (required)
        :type tenant: str
                :param id_with_namespace: A list of tuple flow ID and namespace as flow identifiers (required)
        :type id_with_namespace: List[IdWithNamespace]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_flows_by_ids_serialize(
            tenant=tenant,
            id_with_namespace=id_with_namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _delete_flows_by_ids_serialize(
        self,
        tenant,
        id_with_namespace,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'IdWithNamespace': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if id_with_namespace is not None:
            _body_params = id_with_namespace



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/flows/delete/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def delete_flows_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Delete flows returned by the query parameters.


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_flows_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_flows_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Delete flows returned by the query parameters.


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_flows_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _delete_flows_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/flows/delete/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def delete_revisions(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        revisions: Annotated[List[StrictInt], Field(min_length=1)],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> None:
        """Delete revisions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param revisions: (required)
        :type revisions: List[int]
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_revisions_serialize(
            namespace=namespace,
            id=id,
            revisions=revisions,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_revisions_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        revisions: Annotated[List[StrictInt], Field(min_length=1)],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[None]:
        """Delete revisions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param revisions: (required)
        :type revisions: List[int]
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_revisions_serialize(
            namespace=namespace,
            id=id,
            revisions=revisions,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _delete_revisions_serialize(
        self,
        namespace,
        id,
        revisions,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'revisions': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if revisions is not None:
            
            _query_params.append(('revisions', revisions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter





        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}/revisions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def disable_flows_by_ids(
        self,
        tenant: StrictStr,
        id_with_namespace: Annotated[List[IdWithNamespace], Field(description="A list of tuple flow ID and namespace as flow identifiers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Disable flows by their IDs.


        :param tenant: (required)
        :type tenant: str
                :param id_with_namespace: A list of tuple flow ID and namespace as flow identifiers (required)
        :type id_with_namespace: List[IdWithNamespace]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._disable_flows_by_ids_serialize(
            tenant=tenant,
            id_with_namespace=id_with_namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def disable_flows_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        id_with_namespace: Annotated[List[IdWithNamespace], Field(description="A list of tuple flow ID and namespace as flow identifiers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Disable flows by their IDs.


        :param tenant: (required)
        :type tenant: str
                :param id_with_namespace: A list of tuple flow ID and namespace as flow identifiers (required)
        :type id_with_namespace: List[IdWithNamespace]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._disable_flows_by_ids_serialize(
            tenant=tenant,
            id_with_namespace=id_with_namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _disable_flows_by_ids_serialize(
        self,
        tenant,
        id_with_namespace,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'IdWithNamespace': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if id_with_namespace is not None:
            _body_params = id_with_namespace



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/disable/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def disable_flows_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Disable flows returned by the query parameters.


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._disable_flows_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def disable_flows_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Disable flows returned by the query parameters.


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._disable_flows_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _disable_flows_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/disable/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def enable_flows_by_ids(
        self,
        tenant: StrictStr,
        id_with_namespace: Annotated[List[IdWithNamespace], Field(description="A list of tuple flow ID and namespace as flow identifiers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Enable flows by their IDs.


        :param tenant: (required)
        :type tenant: str
                :param id_with_namespace: A list of tuple flow ID and namespace as flow identifiers (required)
        :type id_with_namespace: List[IdWithNamespace]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._enable_flows_by_ids_serialize(
            tenant=tenant,
            id_with_namespace=id_with_namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def enable_flows_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        id_with_namespace: Annotated[List[IdWithNamespace], Field(description="A list of tuple flow ID and namespace as flow identifiers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Enable flows by their IDs.


        :param tenant: (required)
        :type tenant: str
                :param id_with_namespace: A list of tuple flow ID and namespace as flow identifiers (required)
        :type id_with_namespace: List[IdWithNamespace]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._enable_flows_by_ids_serialize(
            tenant=tenant,
            id_with_namespace=id_with_namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _enable_flows_by_ids_serialize(
        self,
        tenant,
        id_with_namespace,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'IdWithNamespace': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if id_with_namespace is not None:
            _body_params = id_with_namespace



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/enable/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def enable_flows_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Enable flows returned by the query parameters.


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._enable_flows_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def enable_flows_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Enable flows returned by the query parameters.


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._enable_flows_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _enable_flows_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/enable/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def export_flows(
        self,
        filters: Annotated[List[QueryFilter], Field(description="A list of filters")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[object]:
        """Export all flows as a streamed CSV file


        :param filters: A list of filters (required)
        :type filters: List[QueryFilter]
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._export_flows_serialize(
            filters=filters,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_flows_with_http_info(
        self,
        filters: Annotated[List[QueryFilter], Field(description="A list of filters")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[object]]:
        """Export all flows as a streamed CSV file


        :param filters: A list of filters (required)
        :type filters: List[QueryFilter]
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._export_flows_serialize(
            filters=filters,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _export_flows_serialize(
        self,
        filters,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/csv'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/export/by-query/csv',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def export_flows_by_ids(
        self,
        tenant: StrictStr,
        id_with_namespace: Annotated[List[IdWithNamespace], Field(description="A list of tuple flow ID and namespace as flow identifiers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> bytearray:
        """Export flows as a ZIP archive of yaml sources.


        :param tenant: (required)
        :type tenant: str
                :param id_with_namespace: A list of tuple flow ID and namespace as flow identifiers (required)
        :type id_with_namespace: List[IdWithNamespace]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._export_flows_by_ids_serialize(
            tenant=tenant,
            id_with_namespace=id_with_namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_flows_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        id_with_namespace: Annotated[List[IdWithNamespace], Field(description="A list of tuple flow ID and namespace as flow identifiers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[bytearray]:
        """Export flows as a ZIP archive of yaml sources.


        :param tenant: (required)
        :type tenant: str
                :param id_with_namespace: A list of tuple flow ID and namespace as flow identifiers (required)
        :type id_with_namespace: List[IdWithNamespace]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._export_flows_by_ids_serialize(
            tenant=tenant,
            id_with_namespace=id_with_namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _export_flows_by_ids_serialize(
        self,
        tenant,
        id_with_namespace,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'IdWithNamespace': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if id_with_namespace is not None:
            _body_params = id_with_namespace



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/octet-stream'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/export/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def export_flows_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> bytearray:
        """Export flows as a ZIP archive of yaml sources.


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._export_flows_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_flows_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[bytearray]:
        """Export flows as a ZIP archive of yaml sources.


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._export_flows_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _export_flows_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/octet-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/export/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def flow(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        source: Annotated[StrictBool, Field(description="Include the source code")],
        allow_deleted: Annotated[StrictBool, Field(description="Get flow even if deleted")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="Get latest revision by default")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowWithSource:
        """Get a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param source: Include the source code (required)
        :type source: bool
                :param allow_deleted: Get flow even if deleted (required)
        :type allow_deleted: bool
                :param tenant: (required)
        :type tenant: str
                :param revision: Get latest revision by default
        :type revision: int
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_serialize(
            namespace=namespace,
            id=id,
            source=source,
            allow_deleted=allow_deleted,
            tenant=tenant,
            revision=revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowWithSource",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def flow_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        source: Annotated[StrictBool, Field(description="Include the source code")],
        allow_deleted: Annotated[StrictBool, Field(description="Get flow even if deleted")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="Get latest revision by default")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowWithSource]:
        """Get a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param source: Include the source code (required)
        :type source: bool
                :param allow_deleted: Get flow even if deleted (required)
        :type allow_deleted: bool
                :param tenant: (required)
        :type tenant: str
                :param revision: Get latest revision by default
        :type revision: int
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_serialize(
            namespace=namespace,
            id=id,
            source=source,
            allow_deleted=allow_deleted,
            tenant=tenant,
            revision=revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowWithSource",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _flow_serialize(
        self,
        namespace,
        id,
        source,
        allow_deleted,
        tenant,
        revision,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if source is not None:
            
            _query_params.append(('source', source))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        if allow_deleted is not None:
            
            _query_params.append(('allowDeleted', allow_deleted))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def flow_dependencies(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        destination_only: Annotated[StrictBool, Field(description="If true, list only destination dependencies, otherwise list also source dependencies")],
        expand_all: Annotated[StrictBool, Field(description="If true, expand all dependencies recursively")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowTopologyGraph:
        """Get flow dependencies


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param destination_only: If true, list only destination dependencies, otherwise list also source dependencies (required)
        :type destination_only: bool
                :param expand_all: If true, expand all dependencies recursively (required)
        :type expand_all: bool
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_dependencies_serialize(
            namespace=namespace,
            id=id,
            destination_only=destination_only,
            expand_all=expand_all,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowTopologyGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def flow_dependencies_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        destination_only: Annotated[StrictBool, Field(description="If true, list only destination dependencies, otherwise list also source dependencies")],
        expand_all: Annotated[StrictBool, Field(description="If true, expand all dependencies recursively")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowTopologyGraph]:
        """Get flow dependencies


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param destination_only: If true, list only destination dependencies, otherwise list also source dependencies (required)
        :type destination_only: bool
                :param expand_all: If true, expand all dependencies recursively (required)
        :type expand_all: bool
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_dependencies_serialize(
            namespace=namespace,
            id=id,
            destination_only=destination_only,
            expand_all=expand_all,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowTopologyGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _flow_dependencies_serialize(
        self,
        namespace,
        id,
        destination_only,
        expand_all,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if destination_only is not None:
            
            _query_params.append(('destinationOnly', destination_only))
            
        if expand_all is not None:
            
            _query_params.append(('expandAll', expand_all))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}/dependencies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def flow_dependencies_from_namespace(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        destination_only: Annotated[StrictBool, Field(description="if true, list only destination dependencies, otherwise list also source dependencies")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowTopologyGraph:
        """Retrieve flow dependencies


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param destination_only: if true, list only destination dependencies, otherwise list also source dependencies (required)
        :type destination_only: bool
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_dependencies_from_namespace_serialize(
            namespace=namespace,
            destination_only=destination_only,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowTopologyGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def flow_dependencies_from_namespace_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        destination_only: Annotated[StrictBool, Field(description="if true, list only destination dependencies, otherwise list also source dependencies")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowTopologyGraph]:
        """Retrieve flow dependencies


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param destination_only: if true, list only destination dependencies, otherwise list also source dependencies (required)
        :type destination_only: bool
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_dependencies_from_namespace_serialize(
            namespace=namespace,
            destination_only=destination_only,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowTopologyGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _flow_dependencies_from_namespace_serialize(
        self,
        namespace,
        destination_only,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if destination_only is not None:
            
            _query_params.append(('destinationOnly', destination_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/namespaces/{namespace}/dependencies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def generate_flow_graph(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowGraph:
        """Generate a graph for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param tenant: (required)
        :type tenant: str
                :param revision: The flow revision
        :type revision: int
                :param subflows: The subflow tasks to display
        :type subflows: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._generate_flow_graph_serialize(
            namespace=namespace,
            id=id,
            tenant=tenant,
            revision=revision,
            subflows=subflows,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def generate_flow_graph_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowGraph]:
        """Generate a graph for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param tenant: (required)
        :type tenant: str
                :param revision: The flow revision
        :type revision: int
                :param subflows: The subflow tasks to display
        :type subflows: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._generate_flow_graph_serialize(
            namespace=namespace,
            id=id,
            tenant=tenant,
            revision=revision,
            subflows=subflows,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _generate_flow_graph_serialize(
        self,
        namespace,
        id,
        tenant,
        revision,
        subflows,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'subflows': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        if subflows is not None:
            
            _query_params.append(('subflows', subflows))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}/graph',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def generate_flow_graph_from_source(
        self,
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The flow source code")],
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowGraph:
        """Generate a graph for a flow source


        :param tenant: (required)
        :type tenant: str
                :param body: The flow source code (required)
        :type body: str
                :param subflows: The subflow tasks to display
        :type subflows: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._generate_flow_graph_from_source_serialize(
            tenant=tenant,
            body=body,
            subflows=subflows,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def generate_flow_graph_from_source_with_http_info(
        self,
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The flow source code")],
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowGraph]:
        """Generate a graph for a flow source


        :param tenant: (required)
        :type tenant: str
                :param body: The flow source code (required)
        :type body: str
                :param subflows: The subflow tasks to display
        :type subflows: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._generate_flow_graph_from_source_serialize(
            tenant=tenant,
            body=body,
            subflows=subflows,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _generate_flow_graph_from_source_serialize(
        self,
        tenant,
        body,
        subflows,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'subflows': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if subflows is not None:
            
            _query_params.append(('subflows', subflows))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/x-yaml'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/graph',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def import_flows(
        self,
        fail_on_error: Annotated[StrictBool, Field(description="If should fail on invalid flows")],
        tenant: StrictStr,
        file_upload: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The file to import, can be a ZIP archive or a multi-objects YAML file")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[str]:
        """    Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn't be imported is returned. 


        :param fail_on_error: If should fail on invalid flows (required)
        :type fail_on_error: bool
                :param tenant: (required)
        :type tenant: str
                :param file_upload: The file to import, can be a ZIP archive or a multi-objects YAML file
        :type file_upload: bytearray
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._import_flows_serialize(
            fail_on_error=fail_on_error,
            tenant=tenant,
            file_upload=file_upload,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def import_flows_with_http_info(
        self,
        fail_on_error: Annotated[StrictBool, Field(description="If should fail on invalid flows")],
        tenant: StrictStr,
        file_upload: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The file to import, can be a ZIP archive or a multi-objects YAML file")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[str]]:
        """    Import flows as a ZIP archive of yaml sources or a multi-objects YAML file.     When sending a Yaml that contains one or more flows, a list of index is returned.     When sending a ZIP archive, a list of files that couldn't be imported is returned. 


        :param fail_on_error: If should fail on invalid flows (required)
        :type fail_on_error: bool
                :param tenant: (required)
        :type tenant: str
                :param file_upload: The file to import, can be a ZIP archive or a multi-objects YAML file
        :type file_upload: bytearray
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._import_flows_serialize(
            fail_on_error=fail_on_error,
            tenant=tenant,
            file_upload=file_upload,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _import_flows_serialize(
        self,
        fail_on_error,
        tenant,
        file_upload,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if fail_on_error is not None:
            
            _query_params.append(('failOnError', fail_on_error))
            
        # process the header parameters
        # process the form parameters
        if file_upload is not None:
            _files['fileUpload'] = file_upload
                    # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'multipart/form-data'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/import',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def list_distinct_namespaces(
        self,
        tenant: StrictStr,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[str]:
        """List all distinct namespaces


        :param tenant: (required)
        :type tenant: str
                :param q: A string filter
        :type q: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._list_distinct_namespaces_serialize(
            tenant=tenant,
            q=q,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_distinct_namespaces_with_http_info(
        self,
        tenant: StrictStr,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[str]]:
        """List all distinct namespaces


        :param tenant: (required)
        :type tenant: str
                :param q: A string filter
        :type q: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._list_distinct_namespaces_serialize(
            tenant=tenant,
            q=q,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _list_distinct_namespaces_serialize(
        self,
        tenant,
        q,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/distinct-namespaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def list_flow_revisions(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        allow_delete: StrictBool,
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[FlowWithSource]:
        """Get revisions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param allow_delete: (required)
        :type allow_delete: bool
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._list_flow_revisions_serialize(
            namespace=namespace,
            id=id,
            allow_delete=allow_delete,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowWithSource]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_flow_revisions_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        allow_delete: StrictBool,
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[FlowWithSource]]:
        """Get revisions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param allow_delete: (required)
        :type allow_delete: bool
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._list_flow_revisions_serialize(
            namespace=namespace,
            id=id,
            allow_delete=allow_delete,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowWithSource]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _list_flow_revisions_serialize(
        self,
        namespace,
        id,
        allow_delete,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if allow_delete is not None:
            
            _query_params.append(('allowDelete', allow_delete))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}/revisions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def list_flows_by_namespace(
        self,
        namespace: Annotated[StrictStr, Field(description="Namespace to filter flows")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[Flow]:
        """Retrieve all flows from a given namespace


        :param namespace: Namespace to filter flows (required)
        :type namespace: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._list_flows_by_namespace_serialize(
            namespace=namespace,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Flow]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_flows_by_namespace_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="Namespace to filter flows")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[Flow]]:
        """Retrieve all flows from a given namespace


        :param namespace: Namespace to filter flows (required)
        :type namespace: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._list_flows_by_namespace_serialize(
            namespace=namespace,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Flow]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _list_flows_by_namespace_serialize(
        self,
        namespace,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/{namespace}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def search_concurrency_limits(
        self,
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> PagedResultsConcurrencyLimit:
        """Search for flow concurrency limits


        :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_concurrency_limits_serialize(
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsConcurrencyLimit",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_concurrency_limits_with_http_info(
        self,
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[PagedResultsConcurrencyLimit]:
        """Search for flow concurrency limits


        :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_concurrency_limits_serialize(
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsConcurrencyLimit",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _search_concurrency_limits_serialize(
        self,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/concurrency-limit/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def search_flows(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> PagedResultsFlow:
        """Search for flows


        :param page: The current page (required)
        :type page: int
                :param size: The current page size (required)
        :type size: int
                :param tenant: (required)
        :type tenant: str
                :param sort: The sort of current page
        :type sort: List[str]
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_flows_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsFlow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_flows_with_http_info(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[PagedResultsFlow]:
        """Search for flows


        :param page: The current page (required)
        :type page: int
                :param size: The current page size (required)
        :type size: int
                :param tenant: (required)
        :type tenant: str
                :param sort: The sort of current page
        :type sort: List[str]
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_flows_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsFlow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _search_flows_serialize(
        self,
        page,
        size,
        tenant,
        sort,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'csv',
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def search_flows_by_source_code(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> PagedResultsSearchResultFlow:
        """Search for flows source code


        :param page: The current page (required)
        :type page: int
                :param size: The current page size (required)
        :type size: int
                :param tenant: (required)
        :type tenant: str
                :param sort: The sort of current page
        :type sort: List[str]
                :param q: A string filter
        :type q: str
                :param namespace: A namespace filter prefix
        :type namespace: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_flows_by_source_code_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            q=q,
            namespace=namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsSearchResultFlow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_flows_by_source_code_with_http_info(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        q: Annotated[Optional[StrictStr], Field(description="A string filter")] = None,
        namespace: Annotated[Optional[StrictStr], Field(description="A namespace filter prefix")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[PagedResultsSearchResultFlow]:
        """Search for flows source code


        :param page: The current page (required)
        :type page: int
                :param size: The current page size (required)
        :type size: int
                :param tenant: (required)
        :type tenant: str
                :param sort: The sort of current page
        :type sort: List[str]
                :param q: A string filter
        :type q: str
                :param namespace: A namespace filter prefix
        :type namespace: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_flows_by_source_code_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            q=q,
            namespace=namespace,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsSearchResultFlow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _search_flows_by_source_code_serialize(
        self,
        page,
        size,
        tenant,
        sort,
        q,
        namespace,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/source',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def task_from_flow(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        task_id: Annotated[StrictStr, Field(description="The task id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Task:
        """Get a flow task


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param task_id: The task id (required)
        :type task_id: str
                :param tenant: (required)
        :type tenant: str
                :param revision: The flow revision
        :type revision: int
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._task_from_flow_serialize(
            namespace=namespace,
            id=id,
            task_id=task_id,
            tenant=tenant,
            revision=revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Task",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def task_from_flow_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        task_id: Annotated[StrictStr, Field(description="The task id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Task]:
        """Get a flow task


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param task_id: The task id (required)
        :type task_id: str
                :param tenant: (required)
        :type tenant: str
                :param revision: The flow revision
        :type revision: int
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._task_from_flow_serialize(
            namespace=namespace,
            id=id,
            task_id=task_id,
            tenant=tenant,
            revision=revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Task",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _task_from_flow_serialize(
        self,
        namespace,
        id,
        task_id,
        tenant,
        revision,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if task_id is not None:
            _path_params['taskId'] = task_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}/tasks/{taskId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def update_concurrency_limit(
        self,
        flow_id: StrictStr,
        namespace: StrictStr,
        tenant: StrictStr,
        concurrency_limit: ConcurrencyLimit,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ConcurrencyLimit:
        """Update a flow concurrency limit


        :param flow_id: (required)
        :type flow_id: str
                :param namespace: (required)
        :type namespace: str
                :param tenant: (required)
        :type tenant: str
                :param concurrency_limit: (required)
        :type concurrency_limit: ConcurrencyLimit
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_concurrency_limit_serialize(
            flow_id=flow_id,
            namespace=namespace,
            tenant=tenant,
            concurrency_limit=concurrency_limit,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConcurrencyLimit",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_concurrency_limit_with_http_info(
        self,
        flow_id: StrictStr,
        namespace: StrictStr,
        tenant: StrictStr,
        concurrency_limit: ConcurrencyLimit,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[ConcurrencyLimit]:
        """Update a flow concurrency limit


        :param flow_id: (required)
        :type flow_id: str
                :param namespace: (required)
        :type namespace: str
                :param tenant: (required)
        :type tenant: str
                :param concurrency_limit: (required)
        :type concurrency_limit: ConcurrencyLimit
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_concurrency_limit_serialize(
            flow_id=flow_id,
            namespace=namespace,
            tenant=tenant,
            concurrency_limit=concurrency_limit,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConcurrencyLimit",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _update_concurrency_limit_serialize(
        self,
        flow_id,
        namespace,
        tenant,
        concurrency_limit,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if flow_id is not None:
            _path_params['flowId'] = flow_id
        if namespace is not None:
            _path_params['namespace'] = namespace
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if concurrency_limit is not None:
            _body_params = concurrency_limit



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v1/{tenant}/concurrency-limit/{namespace}/{flowId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def update_flow(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The flow source code")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowWithSource:
        """Update a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param tenant: (required)
        :type tenant: str
                :param body: The flow source code (required)
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_flow_serialize(
            namespace=namespace,
            id=id,
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowWithSource",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_flow_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="The flow source code")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowWithSource]:
        """Update a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param tenant: (required)
        :type tenant: str
                :param body: The flow source code (required)
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_flow_serialize(
            namespace=namespace,
            id=id,
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowWithSource",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _update_flow_serialize(
        self,
        namespace,
        id,
        tenant,
        body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/x-yaml'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def update_flows_in_namespace(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        delete: Annotated[StrictBool, Field(description="If missing flow should be deleted")],
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="A list of flows source code")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[FlowInterface]:
        """Update a complete namespace from yaml source

        All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`

        :param namespace: The flow namespace (required)
        :type namespace: str
                :param delete: If missing flow should be deleted (required)
        :type delete: bool
                :param tenant: (required)
        :type tenant: str
                :param body: A list of flows source code (required)
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_flows_in_namespace_serialize(
            namespace=namespace,
            delete=delete,
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowInterface]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_flows_in_namespace_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        delete: Annotated[StrictBool, Field(description="If missing flow should be deleted")],
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="A list of flows source code")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[FlowInterface]]:
        """Update a complete namespace from yaml source

        All flow will be created / updated for this namespace. Flow that already created but not in `flows` will be deleted if the query delete is `true`

        :param namespace: The flow namespace (required)
        :type namespace: str
                :param delete: If missing flow should be deleted (required)
        :type delete: bool
                :param tenant: (required)
        :type tenant: str
                :param body: A list of flows source code (required)
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_flows_in_namespace_serialize(
            namespace=namespace,
            delete=delete,
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FlowInterface]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _update_flows_in_namespace_serialize(
        self,
        namespace,
        delete,
        tenant,
        body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if delete is not None:
            
            _query_params.append(('delete', delete))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/x-yaml'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/{namespace}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def update_task(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        task_id: Annotated[StrictStr, Field(description="The task id")],
        tenant: StrictStr,
        task: Annotated[Task, Field(description="The task")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Flow:
        """(Deprecated) Update a single task on a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param task_id: The task id (required)
        :type task_id: str
                :param tenant: (required)
        :type tenant: str
                :param task: The task (required)
        :type task: Task
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501
        warnings.warn("PATCH /api/v1/{tenant}/flows/{namespace}/{id}/{taskId} is deprecated.", DeprecationWarning)

        _param = self._update_task_serialize(
            namespace=namespace,
            id=id,
            task_id=task_id,
            tenant=tenant,
            task=task,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Flow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        task_id: Annotated[StrictStr, Field(description="The task id")],
        tenant: StrictStr,
        task: Annotated[Task, Field(description="The task")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Flow]:
        """(Deprecated) Update a single task on a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param task_id: The task id (required)
        :type task_id: str
                :param tenant: (required)
        :type tenant: str
                :param task: The task (required)
        :type task: Task
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501
        warnings.warn("PATCH /api/v1/{tenant}/flows/{namespace}/{id}/{taskId} is deprecated.", DeprecationWarning)

        _param = self._update_task_serialize(
            namespace=namespace,
            id=id,
            task_id=task_id,
            tenant=tenant,
            task=task,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Flow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _update_task_serialize(
        self,
        namespace,
        id,
        task_id,
        tenant,
        task,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if task_id is not None:
            _path_params['taskId'] = task_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if task is not None:
            _body_params = task



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v1/{tenant}/flows/{namespace}/{id}/{taskId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def validate_flows(
        self,
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="A list of flows source code in a single string")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[ValidateConstraintViolation]:
        """Validate a list of flows


        :param tenant: (required)
        :type tenant: str
                :param body: A list of flows source code in a single string (required)
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._validate_flows_serialize(
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ValidateConstraintViolation]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_flows_with_http_info(
        self,
        tenant: StrictStr,
        body: Annotated[StrictStr, Field(description="A list of flows source code in a single string")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[ValidateConstraintViolation]]:
        """Validate a list of flows


        :param tenant: (required)
        :type tenant: str
                :param body: A list of flows source code in a single string (required)
        :type body: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._validate_flows_serialize(
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ValidateConstraintViolation]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _validate_flows_serialize(
        self,
        tenant,
        body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/x-yaml'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/validate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def validate_task(
        self,
        section: Annotated[FlowControllerTaskValidationType, Field(description="The type of task")],
        tenant: StrictStr,
        body: Annotated[Dict[str, Any], Field(description="A task definition that can be from tasks or triggers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ValidateConstraintViolation:
        """Validate a task


        :param section: The type of task (required)
        :type section: FlowControllerTaskValidationType
                :param tenant: (required)
        :type tenant: str
                :param body: A task definition that can be from tasks or triggers (required)
        :type body: object
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._validate_task_serialize(
            section=section,
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ValidateConstraintViolation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_task_with_http_info(
        self,
        section: Annotated[FlowControllerTaskValidationType, Field(description="The type of task")],
        tenant: StrictStr,
        body: Annotated[Dict[str, Any], Field(description="A task definition that can be from tasks or triggers")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[ValidateConstraintViolation]:
        """Validate a task


        :param section: The type of task (required)
        :type section: FlowControllerTaskValidationType
                :param tenant: (required)
        :type tenant: str
                :param body: A task definition that can be from tasks or triggers (required)
        :type body: object
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._validate_task_serialize(
            section=section,
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ValidateConstraintViolation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _validate_task_serialize(
        self,
        section,
        tenant,
        body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if section is not None:
            
            _query_params.append(('section', section.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/x-yaml', 
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/validate/task',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def validate_trigger(
        self,
        tenant: StrictStr,
        body: Annotated[Dict[str, Any], Field(description="The trigger")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ValidateConstraintViolation:
        """Validate trigger


        :param tenant: (required)
        :type tenant: str
                :param body: The trigger (required)
        :type body: object
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._validate_trigger_serialize(
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ValidateConstraintViolation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_trigger_with_http_info(
        self,
        tenant: StrictStr,
        body: Annotated[Dict[str, Any], Field(description="The trigger")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[ValidateConstraintViolation]:
        """Validate trigger


        :param tenant: (required)
        :type tenant: str
                :param body: The trigger (required)
        :type body: object
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._validate_trigger_serialize(
            tenant=tenant,
            body=body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ValidateConstraintViolation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _validate_trigger_serialize(
        self,
        tenant,
        body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/flows/validate/trigger',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )




