# coding: utf-8

"""
    Kestra EE

    All API operations, except for Superadmin-only endpoints, require a tenant identifier in the HTTP path.<br/> Endpoints designated as Superadmin-only are not tenant-scoped.

    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501
# Custom imports
import requests
import sseclient
import json
from typing import Generator


import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated
from kestrapy.models.bulk_response import BulkResponse
from kestrapy.models.event_execution import EventExecution
from kestrapy.models.event_execution_status_event import EventExecutionStatusEvent
from kestrapy.models.execution import Execution
from kestrapy.models.execution_controller_execution_response import ExecutionControllerExecutionResponse
from kestrapy.models.execution_controller_last_execution_response import ExecutionControllerLastExecutionResponse
from kestrapy.models.execution_controller_set_labels_by_ids_request import ExecutionControllerSetLabelsByIdsRequest
from kestrapy.models.execution_controller_state_request import ExecutionControllerStateRequest
from kestrapy.models.execution_controller_webhook_response import ExecutionControllerWebhookResponse
from kestrapy.models.execution_repository_interface_flow_filter import ExecutionRepositoryInterfaceFlowFilter
from kestrapy.models.file_metas import FileMetas
from kestrapy.models.flow_for_execution import FlowForExecution
from kestrapy.models.flow_graph import FlowGraph
from kestrapy.models.label import Label
from kestrapy.models.paged_results_execution import PagedResultsExecution
from kestrapy.models.query_filter import QueryFilter
from kestrapy.models.state_type import StateType

from kestrapy.api_client import ApiClient, RequestSerialized
from kestrapy.api_response import ApiResponse
from kestrapy.rest import RESTResponseType


class ExecutionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def create_execution(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        wait: Annotated[StrictBool, Field(description="If the server will wait the end of the execution")],
        tenant: StrictStr,
        labels: Annotated[Optional[List[StrictStr]], Field(description="The labels as a list of 'key:value'")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        schedule_date: Annotated[Optional[datetime], Field(description="Schedule the flow on a specific date")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        kind: Annotated[Optional[Any], Field(description="Specific execution kind")] = None,
        additional_form_datas: Optional[Dict[str, Any]] = None,
        additional_files: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ExecutionControllerExecutionResponse:
        """Create a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param wait: If the server will wait the end of the execution (required)
        :type wait: bool
                :param tenant: (required)
        :type tenant: str
                :param labels: The labels as a list of 'key:value'
        :type labels: List[str]
                :param revision: The flow revision or latest if null
        :type revision: int
                :param schedule_date: Schedule the flow on a specific date
        :type schedule_date: datetime
                :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
                :param kind: Specific execution kind
        :type kind: ExecutionKind
        ,
        :param additional_form_datas: for HTTP methods that accept
                                     multipart form data, this
                                     dictionary contains the form
                                     parameters and their values.
        :param additional_files: for HTTP methods that accept
                      multipart form data, this
                      dictionary contains the form
                      file parameters and their values.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._create_execution_serialize(
            namespace=namespace,
            id=id,
            wait=wait,
            tenant=tenant,
            labels=labels,
            revision=revision,
            schedule_date=schedule_date,
            breakpoints=breakpoints,
            kind=kind,
            additional_form_datas=additional_form_datas,
            additional_files=additional_files
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerExecutionResponse",
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_execution_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        wait: Annotated[StrictBool, Field(description="If the server will wait the end of the execution")],
        tenant: StrictStr,
        labels: Annotated[Optional[List[StrictStr]], Field(description="The labels as a list of 'key:value'")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision or latest if null")] = None,
        schedule_date: Annotated[Optional[datetime], Field(description="Schedule the flow on a specific date")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        kind: Annotated[Optional[Any], Field(description="Specific execution kind")] = None,
        additional_form_datas: Optional[Dict[str, Any]] = None,
        additional_files: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[ExecutionControllerExecutionResponse]:
        """Create a new execution for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param wait: If the server will wait the end of the execution (required)
        :type wait: bool
                :param tenant: (required)
        :type tenant: str
                :param labels: The labels as a list of 'key:value'
        :type labels: List[str]
                :param revision: The flow revision or latest if null
        :type revision: int
                :param schedule_date: Schedule the flow on a specific date
        :type schedule_date: datetime
                :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
                :param kind: Specific execution kind
        :type kind: ExecutionKind
        ,
        :param additional_form_datas: for HTTP methods that accept
                                     multipart form data, this
                                     dictionary contains the form
                                     parameters and their values.
        :param additional_files: for HTTP methods that accept
                      multipart form data, this
                      dictionary contains the form
                      file parameters and their values.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._create_execution_serialize(
            namespace=namespace,
            id=id,
            wait=wait,
            tenant=tenant,
            labels=labels,
            revision=revision,
            schedule_date=schedule_date,
            breakpoints=breakpoints,
            kind=kind,
            additional_form_datas=additional_form_datas,
            additional_files=additional_files
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerExecutionResponse",
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _create_execution_serialize(
        self,
        namespace,
        id,
        wait,
        tenant,
        labels,
        revision,
        schedule_date,
        breakpoints,
        kind,
        additional_form_datas,
        additional_files
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'labels': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if labels is not None:
            
            _query_params.append(('labels', labels))
            
        if wait is not None:
            
            _query_params.append(('wait', wait))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        if schedule_date is not None:
            if isinstance(schedule_date, datetime):
                _query_params.append(
                    (
                        'scheduleDate',
                        schedule_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('scheduleDate', schedule_date))
            
        if breakpoints is not None:
            
            _query_params.append(('breakpoints', breakpoints))
            
        if kind is not None:
            
            _query_params.append(('kind', kind.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # process multipart form data
        if additional_form_datas is not None:
            for key, value in additional_form_datas.items():
                if isinstance(value, (list, tuple)):
                    _form_params.extend([(key, v) for v in value])
                else:
                    _form_params.append((key, value))
        # process files
        if additional_files is not None:
            for key, value in additional_files.items():
                _files[key] = value



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'multipart/form-data'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{namespace}/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def delete_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        delete_logs: Annotated[Optional[StrictBool], Field(description="Whether to delete execution logs")] = None,
        delete_metrics: Annotated[Optional[StrictBool], Field(description="Whether to delete execution metrics")] = None,
        delete_storage: Annotated[Optional[StrictBool], Field(description="Whether to delete execution files in the internal storage")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> None:
        """Delete an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param delete_logs: Whether to delete execution logs
        :type delete_logs: bool
                :param delete_metrics: Whether to delete execution metrics
        :type delete_metrics: bool
                :param delete_storage: Whether to delete execution files in the internal storage
        :type delete_storage: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        delete_logs: Annotated[Optional[StrictBool], Field(description="Whether to delete execution logs")] = None,
        delete_metrics: Annotated[Optional[StrictBool], Field(description="Whether to delete execution metrics")] = None,
        delete_storage: Annotated[Optional[StrictBool], Field(description="Whether to delete execution files in the internal storage")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[None]:
        """Delete an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param delete_logs: Whether to delete execution logs
        :type delete_logs: bool
                :param delete_metrics: Whether to delete execution metrics
        :type delete_metrics: bool
                :param delete_storage: Whether to delete execution files in the internal storage
        :type delete_storage: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _delete_execution_serialize(
        self,
        execution_id,
        tenant,
        delete_logs,
        delete_metrics,
        delete_storage,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if delete_logs is not None:
            
            _query_params.append(('deleteLogs', delete_logs))
            
        if delete_metrics is not None:
            
            _query_params.append(('deleteMetrics', delete_metrics))
            
        if delete_storage is not None:
            
            _query_params.append(('deleteStorage', delete_storage))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter





        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/{executionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def delete_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The execution id")],
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        delete_logs: Annotated[Optional[StrictBool], Field(description="Whether to delete execution logs")] = None,
        delete_metrics: Annotated[Optional[StrictBool], Field(description="Whether to delete execution metrics")] = None,
        delete_storage: Annotated[Optional[StrictBool], Field(description="Whether to delete execution files in the internal storage")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Delete a list of executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The execution id (required)
        :type request_body: List[str]
                :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
                :param delete_logs: Whether to delete execution logs
        :type delete_logs: bool
                :param delete_metrics: Whether to delete execution metrics
        :type delete_metrics: bool
                :param delete_storage: Whether to delete execution files in the internal storage
        :type delete_storage: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            include_non_terminated=include_non_terminated,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The execution id")],
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        delete_logs: Annotated[Optional[StrictBool], Field(description="Whether to delete execution logs")] = None,
        delete_metrics: Annotated[Optional[StrictBool], Field(description="Whether to delete execution metrics")] = None,
        delete_storage: Annotated[Optional[StrictBool], Field(description="Whether to delete execution files in the internal storage")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Delete a list of executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The execution id (required)
        :type request_body: List[str]
                :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
                :param delete_logs: Whether to delete execution logs
        :type delete_logs: bool
                :param delete_metrics: Whether to delete execution metrics
        :type delete_metrics: bool
                :param delete_storage: Whether to delete execution files in the internal storage
        :type delete_storage: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            include_non_terminated=include_non_terminated,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _delete_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
        include_non_terminated,
        delete_logs,
        delete_metrics,
        delete_storage,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if include_non_terminated is not None:
            
            _query_params.append(('includeNonTerminated', include_non_terminated))
            
        if delete_logs is not None:
            
            _query_params.append(('deleteLogs', delete_logs))
            
        if delete_metrics is not None:
            
            _query_params.append(('deleteMetrics', delete_metrics))
            
        if delete_storage is not None:
            
            _query_params.append(('deleteStorage', delete_storage))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def delete_executions_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        delete_logs: Annotated[Optional[StrictBool], Field(description="Whether to delete execution logs")] = None,
        delete_metrics: Annotated[Optional[StrictBool], Field(description="Whether to delete execution metrics")] = None,
        delete_storage: Annotated[Optional[StrictBool], Field(description="Whether to delete execution files in the internal storage")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Delete executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
                :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
                :param delete_logs: Whether to delete execution logs
        :type delete_logs: bool
                :param delete_metrics: Whether to delete execution metrics
        :type delete_metrics: bool
                :param delete_storage: Whether to delete execution files in the internal storage
        :type delete_storage: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
            include_non_terminated=include_non_terminated,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        include_non_terminated: Annotated[Optional[StrictBool], Field(description="Whether to delete non-terminated executions")] = None,
        delete_logs: Annotated[Optional[StrictBool], Field(description="Whether to delete execution logs")] = None,
        delete_metrics: Annotated[Optional[StrictBool], Field(description="Whether to delete execution metrics")] = None,
        delete_storage: Annotated[Optional[StrictBool], Field(description="Whether to delete execution files in the internal storage")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Delete executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
                :param include_non_terminated: Whether to delete non-terminated executions
        :type include_non_terminated: bool
                :param delete_logs: Whether to delete execution logs
        :type delete_logs: bool
                :param delete_metrics: Whether to delete execution metrics
        :type delete_metrics: bool
                :param delete_storage: Whether to delete execution files in the internal storage
        :type delete_storage: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._delete_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
            include_non_terminated=include_non_terminated,
            delete_logs=delete_logs,
            delete_metrics=delete_metrics,
            delete_storage=delete_storage,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _delete_executions_by_query_serialize(
        self,
        tenant,
        filters,
        include_non_terminated,
        delete_logs,
        delete_metrics,
        delete_storage,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if include_non_terminated is not None:
            
            _query_params.append(('includeNonTerminated', include_non_terminated))
            
        if delete_logs is not None:
            
            _query_params.append(('deleteLogs', delete_logs))
            
        if delete_metrics is not None:
            
            _query_params.append(('deleteMetrics', delete_metrics))
            
        if delete_storage is not None:
            
            _query_params.append(('deleteStorage', delete_storage))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def download_file_from_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> bytearray:
        """Download file for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param path: The internal storage uri (required)
        :type path: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._download_file_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_file_from_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[bytearray]:
        """Download file for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param path: The internal storage uri (required)
        :type path: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._download_file_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _download_file_from_execution_serialize(
        self,
        execution_id,
        path,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if path is not None:
            
            _query_params.append(('path', path))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/octet-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/file',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Execution:
        """Get an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Execution]:
        """Get an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _execution_serialize(
        self,
        execution_id,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def execution_flow_graph(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowGraph:
        """Generate a graph for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param subflows: The subflow tasks to display
        :type subflows: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._execution_flow_graph_serialize(
            execution_id=execution_id,
            tenant=tenant,
            subflows=subflows,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def execution_flow_graph_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        subflows: Annotated[Optional[List[StrictStr]], Field(description="The subflow tasks to display")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowGraph]:
        """Generate a graph for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param subflows: The subflow tasks to display
        :type subflows: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._execution_flow_graph_serialize(
            execution_id=execution_id,
            tenant=tenant,
            subflows=subflows,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowGraph",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _execution_flow_graph_serialize(
        self,
        execution_id,
        tenant,
        subflows,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'subflows': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if subflows is not None:
            
            _query_params.append(('subflows', subflows))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/graph',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def export_executions(
        self,
        filters: Annotated[List[QueryFilter], Field(description="A list of filters")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[object]:
        """Export all executions as a streamed CSV file


        :param filters: A list of filters (required)
        :type filters: List[QueryFilter]
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._export_executions_serialize(
            filters=filters,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_executions_with_http_info(
        self,
        filters: Annotated[List[QueryFilter], Field(description="A list of filters")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[object]]:
        """Export all executions as a streamed CSV file


        :param filters: A list of filters (required)
        :type filters: List[QueryFilter]
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._export_executions_serialize(
            filters=filters,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _export_executions_serialize(
        self,
        filters,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/csv'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/export/by-query/csv',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def file_metadatas_from_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FileMetas:
        """Get file meta information for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param path: The internal storage uri (required)
        :type path: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._file_metadatas_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileMetas",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def file_metadatas_from_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        path: Annotated[StrictStr, Field(description="The internal storage uri")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FileMetas]:
        """Get file meta information for an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param path: The internal storage uri (required)
        :type path: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._file_metadatas_from_execution_serialize(
            execution_id=execution_id,
            path=path,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileMetas",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _file_metadatas_from_execution_serialize(
        self,
        execution_id,
        path,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if path is not None:
            
            _query_params.append(('path', path))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/file/metas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def flow_from_execution(
        self,
        namespace: Annotated[StrictStr, Field(description="The namespace of the flow")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowForExecution:
        """Get flow information's for an execution


        :param namespace: The namespace of the flow (required)
        :type namespace: str
                :param flow_id: The flow id (required)
        :type flow_id: str
                :param tenant: (required)
        :type tenant: str
                :param revision: The flow revision
        :type revision: int
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_from_execution_serialize(
            namespace=namespace,
            flow_id=flow_id,
            tenant=tenant,
            revision=revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def flow_from_execution_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The namespace of the flow")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowForExecution]:
        """Get flow information's for an execution


        :param namespace: The namespace of the flow (required)
        :type namespace: str
                :param flow_id: The flow id (required)
        :type flow_id: str
                :param tenant: (required)
        :type tenant: str
                :param revision: The flow revision
        :type revision: int
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_from_execution_serialize(
            namespace=namespace,
            flow_id=flow_id,
            tenant=tenant,
            revision=revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _flow_from_execution_serialize(
        self,
        namespace,
        flow_id,
        tenant,
        revision,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if flow_id is not None:
            _path_params['flowId'] = flow_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/flows/{namespace}/{flowId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def flow_from_execution_by_id(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution that you want flow informations")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> FlowForExecution:
        """Get flow information's for an execution


        :param execution_id: The execution that you want flow informations (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_from_execution_by_id_serialize(
            execution_id=execution_id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def flow_from_execution_by_id_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution that you want flow informations")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[FlowForExecution]:
        """Get flow information's for an execution


        :param execution_id: The execution that you want flow informations (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._flow_from_execution_by_id_serialize(
            execution_id=execution_id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlowForExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _flow_from_execution_by_id_serialize(
        self,
        execution_id,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/flow',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )






    def _follow_dependencies_executions_serialize(
        self,
        execution_id,
        destination_only,
        expand_all,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if destination_only is not None:
            
            _query_params.append(('destinationOnly', destination_only))
            
        if expand_all is not None:
            
            _query_params.append(('expandAll', expand_all))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/event-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/follow-dependencies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )



    @validate_call
    def follow_dependencies_executions(
            self,
            execution_id: Annotated[StrictStr, Field(description="The execution id")],
            tenant: StrictStr,
            destination_only: Annotated[Optional[StrictBool], Field(description="If true, list only destination dependencies, otherwise list also source dependencies")] = None,
            expand_all: Annotated[Optional[StrictBool], Field(description="If true, expand all dependencies recursively")] = None,
            _request_timeout: Optional[Union[float, Tuple[float, float]]] = None,
    ) -> Generator[Dict[str, Any], None, None]:
        """
        Follow an execution using SSE.

        This method establishes a persistent connection and yields
        EventExecution objects as they are streamed from the server,
        allowing to follow an execution in realtime.
        """

        _method, final_url, header_params, _body, _post_params = self._follow_dependencies_executions_serialize(
            execution_id=execution_id,
            tenant=tenant,
            destination_only=destination_only,
            expand_all=expand_all
        )

        header_params['Accept'] = 'text/event-stream'

        try:
            response = requests.get(
                final_url,
                headers=header_params,
                stream=True,
                timeout=_request_timeout
            )

            response.raise_for_status()

            client = sseclient.SSEClient(response)

            for event in client.events():
                if event.data is None or event.data == "":
                    continue

                yield json.loads(event.data)

        except requests.exceptions.RequestException as e:
            print(f"SSE connection failed: {e}")
            raise e



    def _follow_execution_serialize(
        self,
        execution_id,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/event-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/{executionId}/follow',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )

    @validate_call
    def follow_execution(
            self,
            execution_id: Annotated[StrictStr, Field(description="The execution id")],
            tenant: StrictStr,
            _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Generator[Dict[str, Any], None, None]:
        """
        Follow an execution using SSE.

        This method establishes a persistent connection and yields
        EventExecution objects as they are streamed from the server,
        allowing to follow an execution in realtime.
        """

        _method, final_url, header_params, _body, _post_params = self._follow_execution_serialize(
            execution_id=execution_id,
            tenant=tenant
        )

        header_params['Accept'] = 'text/event-stream'

        try:
            response = requests.get(
                final_url,
                headers=header_params,
                stream=True,
                timeout=_request_timeout
            )

            response.raise_for_status()

            client = sseclient.SSEClient(response)

            for event in client.events():
                if event.data is None or event.data == "":
                    continue

                yield json.loads(event.data)

        except requests.exceptions.RequestException as e:
            print(f"SSE connection failed: {e}")
            raise e




    @validate_call
    def force_run_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Force run a list of executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._force_run_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def force_run_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Force run a list of executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._force_run_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _force_run_by_ids_serialize(
        self,
        tenant,
        request_body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/force-run/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def force_run_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Execution:
        """Force run an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._force_run_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def force_run_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Execution]:
        """Force run an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._force_run_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _force_run_execution_serialize(
        self,
        execution_id,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/force-run',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def force_run_executions_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Force run executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._force_run_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def force_run_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Force run executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._force_run_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _force_run_executions_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/force-run/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def kill_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        is_on_kill_cascade: Annotated[StrictBool, Field(description="Specifies whether killing the execution also kill all subflow executions.")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Kill an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param is_on_kill_cascade: Specifies whether killing the execution also kill all subflow executions. (required)
        :type is_on_kill_cascade: bool
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._kill_execution_serialize(
            execution_id=execution_id,
            is_on_kill_cascade=is_on_kill_cascade,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '202': None,
            '404': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def kill_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        is_on_kill_cascade: Annotated[StrictBool, Field(description="Specifies whether killing the execution also kill all subflow executions.")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Kill an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param is_on_kill_cascade: Specifies whether killing the execution also kill all subflow executions. (required)
        :type is_on_kill_cascade: bool
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._kill_execution_serialize(
            execution_id=execution_id,
            is_on_kill_cascade=is_on_kill_cascade,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '202': None,
            '404': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _kill_execution_serialize(
        self,
        execution_id,
        is_on_kill_cascade,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if is_on_kill_cascade is not None:
            
            _query_params.append(('isOnKillCascade', is_on_kill_cascade))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/{executionId}/kill',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def kill_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Kill a list of executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._kill_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def kill_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Kill a list of executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._kill_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _kill_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/kill/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def kill_executions_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Kill executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._kill_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def kill_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Kill executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._kill_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _kill_executions_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/{tenant}/executions/kill/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def latest_executions(
        self,
        tenant: StrictStr,
        execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> List[ExecutionControllerLastExecutionResponse]:
        """Get the latest execution for given flows


        :param tenant: (required)
        :type tenant: str
                :param execution_repository_interface_flow_filter: (required)
        :type execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._latest_executions_serialize(
            tenant=tenant,
            execution_repository_interface_flow_filter=execution_repository_interface_flow_filter,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExecutionControllerLastExecutionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def latest_executions_with_http_info(
        self,
        tenant: StrictStr,
        execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[List[ExecutionControllerLastExecutionResponse]]:
        """Get the latest execution for given flows


        :param tenant: (required)
        :type tenant: str
                :param execution_repository_interface_flow_filter: (required)
        :type execution_repository_interface_flow_filter: List[ExecutionRepositoryInterfaceFlowFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._latest_executions_serialize(
            tenant=tenant,
            execution_repository_interface_flow_filter=execution_repository_interface_flow_filter,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExecutionControllerLastExecutionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _latest_executions_serialize(
        self,
        tenant,
        execution_repository_interface_flow_filter,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ExecutionRepositoryInterfaceFlowFilter': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if execution_repository_interface_flow_filter is not None:
            _body_params = execution_repository_interface_flow_filter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/latest',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def pause_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> None:
        """Pause a running execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._pause_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '204': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pause_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[None]:
        """Pause a running execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._pause_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '204': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _pause_execution_serialize(
        self,
        execution_id,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter





        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/pause',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def pause_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Pause a list of running executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._pause_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pause_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Pause a list of running executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._pause_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _pause_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/pause/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def pause_executions_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Pause executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._pause_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pause_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Pause executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._pause_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _pause_executions_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/pause/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def replay_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Execution:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param task_run_id: The taskrun id
        :type task_run_id: str
                :param revision: The flow revision to use for new execution
        :type revision: int
                :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._replay_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replay_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Execution]:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param task_run_id: The taskrun id
        :type task_run_id: str
                :param revision: The flow revision to use for new execution
        :type revision: int
                :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._replay_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _replay_execution_serialize(
        self,
        execution_id,
        tenant,
        task_run_id,
        revision,
        breakpoints,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if task_run_id is not None:
            
            _query_params.append(('taskRunId', task_run_id))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        if breakpoints is not None:
            
            _query_params.append(('breakpoints', breakpoints))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/replay',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def replay_execution_withinputs(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        additional_form_datas: Optional[Dict[str, Any]] = None,
        additional_files: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Execution:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param task_run_id: The taskrun id
        :type task_run_id: str
                :param revision: The flow revision to use for new execution
        :type revision: int
                :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        ,
        :param additional_form_datas: for HTTP methods that accept
                                     multipart form data, this
                                     dictionary contains the form
                                     parameters and their values.
        :param additional_files: for HTTP methods that accept
                      multipart form data, this
                      dictionary contains the form
                      file parameters and their values.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._replay_execution_withinputs_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
            additional_form_datas=additional_form_datas,
            additional_files=additional_files
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replay_execution_withinputs_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="the original execution id to clone")],
        tenant: StrictStr,
        task_run_id: Annotated[Optional[StrictStr], Field(description="The taskrun id")] = None,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        breakpoints: Annotated[Optional[StrictStr], Field(description="Set a list of breakpoints at specific tasks 'id.value', separated by a coma.")] = None,
        additional_form_datas: Optional[Dict[str, Any]] = None,
        additional_files: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Execution]:
        """Create a new execution from an old one and start it from a specified task run id


        :param execution_id: the original execution id to clone (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param task_run_id: The taskrun id
        :type task_run_id: str
                :param revision: The flow revision to use for new execution
        :type revision: int
                :param breakpoints: Set a list of breakpoints at specific tasks 'id.value', separated by a coma.
        :type breakpoints: str
        ,
        :param additional_form_datas: for HTTP methods that accept
                                     multipart form data, this
                                     dictionary contains the form
                                     parameters and their values.
        :param additional_files: for HTTP methods that accept
                      multipart form data, this
                      dictionary contains the form
                      file parameters and their values.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._replay_execution_withinputs_serialize(
            execution_id=execution_id,
            tenant=tenant,
            task_run_id=task_run_id,
            revision=revision,
            breakpoints=breakpoints,
            additional_form_datas=additional_form_datas,
            additional_files=additional_files
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _replay_execution_withinputs_serialize(
        self,
        execution_id,
        tenant,
        task_run_id,
        revision,
        breakpoints,
        additional_form_datas,
        additional_files
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if task_run_id is not None:
            
            _query_params.append(('taskRunId', task_run_id))
            
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        if breakpoints is not None:
            
            _query_params.append(('breakpoints', breakpoints))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # process multipart form data
        if additional_form_datas is not None:
            for key, value in additional_form_datas.items():
                if isinstance(value, (list, tuple)):
                    _form_params.extend([(key, v) for v in value])
                else:
                    _form_params.append((key, value))
        # process files
        if additional_files is not None:
            for key, value in additional_files.items():
                _files[key] = value



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'multipart/form-data'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/replay-with-inputs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def replay_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Create new executions from old ones. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
                :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._replay_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            latest_revision=latest_revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replay_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Create new executions from old ones. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
                :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._replay_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
            latest_revision=latest_revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _replay_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
        latest_revision,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if latest_revision is not None:
            
            _query_params.append(('latestRevision', latest_revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/replay/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def replay_executions_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Create new executions from old ones filter by query parameters. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
                :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._replay_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
            latest_revision=latest_revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def replay_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        latest_revision: Annotated[Optional[StrictBool], Field(description="If latest revision should be used")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Create new executions from old ones filter by query parameters. Keep the flow revision


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
                :param latest_revision: If latest revision should be used
        :type latest_revision: bool
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._replay_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
            latest_revision=latest_revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _replay_executions_by_query_serialize(
        self,
        tenant,
        filters,
        latest_revision,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if latest_revision is not None:
            
            _query_params.append(('latestRevision', latest_revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/replay/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def restart_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Execution:
        """Restart a new execution from an old one


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param revision: The flow revision to use for new execution
        :type revision: int
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._restart_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            revision=revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def restart_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        revision: Annotated[Optional[StrictInt], Field(description="The flow revision to use for new execution")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Execution]:
        """Restart a new execution from an old one


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param revision: The flow revision to use for new execution
        :type revision: int
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._restart_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            revision=revision,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _restart_execution_serialize(
        self,
        execution_id,
        tenant,
        revision,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if revision is not None:
            
            _query_params.append(('revision', revision))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/restart',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def restart_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Restart a list of executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._restart_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def restart_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Restart a list of executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._restart_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _restart_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/restart/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def restart_executions_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Restart executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._restart_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def restart_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Restart executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._restart_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _restart_executions_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/restart/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def resume_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        additional_form_datas: Optional[Dict[str, Any]] = None,
        additional_files: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Resume a paused execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param additional_form_datas: for HTTP methods that accept
                                     multipart form data, this
                                     dictionary contains the form
                                     parameters and their values.
        :param additional_files: for HTTP methods that accept
                      multipart form data, this
                      dictionary contains the form
                      file parameters and their values.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._resume_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            additional_form_datas=additional_form_datas,
            additional_files=additional_files
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '204': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        additional_form_datas: Optional[Dict[str, Any]] = None,
        additional_files: Optional[Dict[str, Any]] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Resume a paused execution.


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param additional_form_datas: for HTTP methods that accept
                                     multipart form data, this
                                     dictionary contains the form
                                     parameters and their values.
        :param additional_files: for HTTP methods that accept
                      multipart form data, this
                      dictionary contains the form
                      file parameters and their values.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._resume_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            additional_form_datas=additional_form_datas,
            additional_files=additional_files
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '204': None,
            '409': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _resume_execution_serialize(
        self,
        execution_id,
        tenant,
        additional_form_datas,
        additional_files
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # process multipart form data
        if additional_form_datas is not None:
            for key, value in additional_form_datas.items():
                if isinstance(value, (list, tuple)):
                    _form_params.extend([(key, v) for v in value])
                else:
                    _form_params.append((key, value))
        # process files
        if additional_files is not None:
            for key, value in additional_files.items():
                _files[key] = value



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'multipart/form-data'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/resume',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def resume_executions_by_ids(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Resume a list of paused executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._resume_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Resume a list of paused executions


        :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._resume_executions_by_ids_serialize(
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _resume_executions_by_ids_serialize(
        self,
        tenant,
        request_body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/resume/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def resume_executions_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Resume executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._resume_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resume_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Resume executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._resume_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _resume_executions_by_query_serialize(
        self,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/resume/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def search_executions(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> PagedResultsExecution:
        """Search for executions


        :param page: The current page (required)
        :type page: int
                :param size: The current page size (required)
        :type size: int
                :param tenant: (required)
        :type tenant: str
                :param sort: The sort of current page
        :type sort: List[str]
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_executions_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_executions_with_http_info(
        self,
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        sort: Annotated[Optional[List[StrictStr]], Field(description="The sort of current page")] = None,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[PagedResultsExecution]:
        """Search for executions


        :param page: The current page (required)
        :type page: int
                :param size: The current page size (required)
        :type size: int
                :param tenant: (required)
        :type tenant: str
                :param sort: The sort of current page
        :type sort: List[str]
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_executions_serialize(
            page=page,
            size=size,
            tenant=tenant,
            sort=sort,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _search_executions_serialize(
        self,
        page,
        size,
        tenant,
        sort,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'csv',
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def search_executions_by_flow_id(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> PagedResultsExecution:
        """Search for executions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param flow_id: The flow id (required)
        :type flow_id: str
                :param page: The current page (required)
        :type page: int
                :param size: The current page size (required)
        :type size: int
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_executions_by_flow_id_serialize(
            namespace=namespace,
            flow_id=flow_id,
            page=page,
            size=size,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_executions_by_flow_id_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        flow_id: Annotated[StrictStr, Field(description="The flow id")],
        page: Annotated[int, Field(strict=True, ge=1, description="The current page")],
        size: Annotated[int, Field(strict=True, ge=1, description="The current page size")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[PagedResultsExecution]:
        """Search for executions for a flow


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param flow_id: The flow id (required)
        :type flow_id: str
                :param page: The current page (required)
        :type page: int
                :param size: The current page size (required)
        :type size: int
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._search_executions_by_flow_id_serialize(
            namespace=namespace,
            flow_id=flow_id,
            page=page,
            size=size,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PagedResultsExecution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _search_executions_by_flow_id_serialize(
        self,
        namespace,
        flow_id,
        page,
        size,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        if flow_id is not None:
            
            _query_params.append(('flowId', flow_id))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def set_labels_on_terminated_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Add or update labels of a terminated execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param label: The labels to add to the execution (required)
        :type label: List[Label]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._set_labels_on_terminated_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            label=label,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_labels_on_terminated_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Add or update labels of a terminated execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param label: The labels to add to the execution (required)
        :type label: List[Label]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._set_labels_on_terminated_execution_serialize(
            execution_id=execution_id,
            tenant=tenant,
            label=label,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _set_labels_on_terminated_execution_serialize(
        self,
        execution_id,
        tenant,
        label,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Label': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if label is not None:
            _body_params = label



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/labels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def set_labels_on_terminated_executions_by_ids(
        self,
        tenant: StrictStr,
        execution_controller_set_labels_by_ids_request: Annotated[ExecutionControllerSetLabelsByIdsRequest, Field(description="The request containing a list of labels and a list of executions")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Set labels on a list of executions


        :param tenant: (required)
        :type tenant: str
                :param execution_controller_set_labels_by_ids_request: The request containing a list of labels and a list of executions (required)
        :type execution_controller_set_labels_by_ids_request: ExecutionControllerSetLabelsByIdsRequest
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_ids_serialize(
            tenant=tenant,
            execution_controller_set_labels_by_ids_request=execution_controller_set_labels_by_ids_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_labels_on_terminated_executions_by_ids_with_http_info(
        self,
        tenant: StrictStr,
        execution_controller_set_labels_by_ids_request: Annotated[ExecutionControllerSetLabelsByIdsRequest, Field(description="The request containing a list of labels and a list of executions")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Set labels on a list of executions


        :param tenant: (required)
        :type tenant: str
                :param execution_controller_set_labels_by_ids_request: The request containing a list of labels and a list of executions (required)
        :type execution_controller_set_labels_by_ids_request: ExecutionControllerSetLabelsByIdsRequest
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_ids_serialize(
            tenant=tenant,
            execution_controller_set_labels_by_ids_request=execution_controller_set_labels_by_ids_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _set_labels_on_terminated_executions_by_ids_serialize(
        self,
        tenant,
        execution_controller_set_labels_by_ids_request,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if execution_controller_set_labels_by_ids_request is not None:
            _body_params = execution_controller_set_labels_by_ids_request



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/labels/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def set_labels_on_terminated_executions_by_query(
        self,
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Set label on executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param label: The labels to add to the execution (required)
        :type label: List[Label]
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_query_serialize(
            tenant=tenant,
            label=label,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_labels_on_terminated_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        label: Annotated[List[Label], Field(description="The labels to add to the execution")],
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Set label on executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param label: The labels to add to the execution (required)
        :type label: List[Label]
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._set_labels_on_terminated_executions_by_query_serialize(
            tenant=tenant,
            label=label,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _set_labels_on_terminated_executions_by_query_serialize(
        self,
        tenant,
        label,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Label': '',
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if label is not None:
            _body_params = label



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/labels/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def trigger_execution_by_get_webhook(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ExecutionControllerWebhookResponse:
        """Trigger a new execution by GET webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param key: The webhook trigger uid (required)
        :type key: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._trigger_execution_by_get_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trigger_execution_by_get_webhook_with_http_info(
        self,
        namespace: Annotated[StrictStr, Field(description="The flow namespace")],
        id: Annotated[StrictStr, Field(description="The flow id")],
        key: Annotated[StrictStr, Field(description="The webhook trigger uid")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[ExecutionControllerWebhookResponse]:
        """Trigger a new execution by GET webhook trigger


        :param namespace: The flow namespace (required)
        :type namespace: str
                :param id: The flow id (required)
        :type id: str
                :param key: The webhook trigger uid (required)
        :type key: str
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._trigger_execution_by_get_webhook_serialize(
            namespace=namespace,
            id=id,
            key=key,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExecutionControllerWebhookResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _trigger_execution_by_get_webhook_serialize(
        self,
        namespace,
        id,
        key,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if namespace is not None:
            _path_params['namespace'] = namespace
        if id is not None:
            _path_params['id'] = id
        if key is not None:
            _path_params['key'] = key
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/{tenant}/executions/webhook/{namespace}/{id}/{key}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def unqueue_execution(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        state: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Execution:
        """Unqueue an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param state: The new state of the execution (required)
        :type state: StateType
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._unqueue_execution_serialize(
            execution_id=execution_id,
            state=state,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def unqueue_execution_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        state: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Execution]:
        """Unqueue an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param state: The new state of the execution (required)
        :type state: StateType
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._unqueue_execution_serialize(
            execution_id=execution_id,
            state=state,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _unqueue_execution_serialize(
        self,
        execution_id,
        state,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if state is not None:
            
            _query_params.append(('state', state.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/unqueue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def unqueue_executions_by_ids(
        self,
        state: Annotated[StateType, Field(description="The new state of the unqueued executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Unqueue a list of executions


        :param state: The new state of the unqueued executions (required)
        :type state: StateType
                :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._unqueue_executions_by_ids_serialize(
            state=state,
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def unqueue_executions_by_ids_with_http_info(
        self,
        state: Annotated[StateType, Field(description="The new state of the unqueued executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Unqueue a list of executions


        :param state: The new state of the unqueued executions (required)
        :type state: StateType
                :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._unqueue_executions_by_ids_serialize(
            state=state,
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _unqueue_executions_by_ids_serialize(
        self,
        state,
        tenant,
        request_body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if state is not None:
            
            _query_params.append(('state', state.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/unqueue/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def unqueue_executions_by_query(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        new_state: Annotated[Optional[Any], Field(description="The new state of the unqueued executions")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> object:
        """Unqueue executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
                :param new_state: The new state of the unqueued executions
        :type new_state: StateType
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._unqueue_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
            new_state=new_state,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def unqueue_executions_by_query_with_http_info(
        self,
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        new_state: Annotated[Optional[Any], Field(description="The new state of the unqueued executions")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[object]:
        """Unqueue executions filter by query parameters


        :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
                :param new_state: The new state of the unqueued executions
        :type new_state: StateType
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._unqueue_executions_by_query_serialize(
            tenant=tenant,
            filters=filters,
            new_state=new_state,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _unqueue_executions_by_query_serialize(
        self,
        tenant,
        filters,
        new_state,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if new_state is not None:
            
            _query_params.append(('newState', new_state.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/unqueue/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def update_execution_status(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        status: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Execution:
        """Change the state of an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param status: The new state of the execution (required)
        :type status: StateType
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_execution_status_serialize(
            execution_id=execution_id,
            status=status,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_execution_status_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        status: Annotated[StateType, Field(description="The new state of the execution")],
        tenant: StrictStr,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Execution]:
        """Change the state of an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param status: The new state of the execution (required)
        :type status: StateType
                :param tenant: (required)
        :type tenant: str
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_execution_status_serialize(
            execution_id=execution_id,
            status=status,
            tenant=tenant,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _update_execution_status_serialize(
        self,
        execution_id,
        status,
        tenant,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/change-status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def update_executions_status_by_ids(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Change executions state by id


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
                :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_executions_status_by_ids_serialize(
            new_status=new_status,
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_executions_status_by_ids_with_http_info(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        request_body: Annotated[List[StrictStr], Field(description="The list of executions id")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Change executions state by id


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
                :param tenant: (required)
        :type tenant: str
                :param request_body: The list of executions id (required)
        :type request_body: List[str]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_executions_status_by_ids_serialize(
            new_status=new_status,
            tenant=tenant,
            request_body=request_body,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _update_executions_status_by_ids_serialize(
        self,
        new_status,
        tenant,
        request_body,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if new_status is not None:
            
            _query_params.append(('newStatus', new_status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/change-status/by-ids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def update_executions_status_by_query(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> BulkResponse:
        """Change executions state by query parameters


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
                :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_executions_status_by_query_serialize(
            new_status=new_status,
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_executions_status_by_query_with_http_info(
        self,
        new_status: Annotated[StateType, Field(description="The new state of the executions")],
        tenant: StrictStr,
        filters: Annotated[Optional[List[QueryFilter]], Field(description="Filters")] = None,
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[BulkResponse]:
        """Change executions state by query parameters


        :param new_status: The new state of the executions (required)
        :type new_status: StateType
                :param tenant: (required)
        :type tenant: str
                :param filters: Filters
        :type filters: List[QueryFilter]
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_executions_status_by_query_serialize(
            new_status=new_status,
            tenant=tenant,
            filters=filters,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BulkResponse",
            '422': "BulkErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _update_executions_status_by_query_serialize(
        self,
        new_status,
        tenant,
        filters,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'filters': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if new_status is not None:
            
            _query_params.append(('newStatus', new_status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/change-status/by-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )





    @validate_call
    def update_task_run_state(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        execution_controller_state_request: Annotated[ExecutionControllerStateRequest, Field(description="the taskRun id and state to apply")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> Execution:
        """Change state for a taskrun in an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param execution_controller_state_request: the taskRun id and state to apply (required)
        :type execution_controller_state_request: ExecutionControllerStateRequest
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_task_run_state_serialize(
            execution_id=execution_id,
            tenant=tenant,
            execution_controller_state_request=execution_controller_state_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_run_state_with_http_info(
        self,
        execution_id: Annotated[StrictStr, Field(description="The execution id")],
        tenant: StrictStr,
        execution_controller_state_request: Annotated[ExecutionControllerStateRequest, Field(description="the taskRun id and state to apply")],
        _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
        Annotated[StrictFloat, Field(gt=0)],
        Annotated[StrictFloat, Field(gt=0)]
        ]
        ] = None
    ) -> ApiResponse[Execution]:
        """Change state for a taskrun in an execution


        :param execution_id: The execution id (required)
        :type execution_id: str
                :param tenant: (required)
        :type tenant: str
                :param execution_controller_state_request: the taskRun id and state to apply (required)
        :type execution_controller_state_request: ExecutionControllerStateRequest
        ,
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        """ # noqa: E501

        _param = self._update_task_run_state_serialize(
            execution_id=execution_id,
            tenant=tenant,
            execution_controller_state_request=execution_controller_state_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Execution",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    def _update_task_run_state_serialize(
        self,
        execution_id,
        tenant,
        execution_controller_state_request,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if execution_id is not None:
            _path_params['executionId'] = execution_id
        if tenant is not None:
            _path_params['tenant'] = tenant
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if execution_controller_state_request is not None:
            _body_params = execution_controller_state_request



        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`

        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/{tenant}/executions/{executionId}/state',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )




