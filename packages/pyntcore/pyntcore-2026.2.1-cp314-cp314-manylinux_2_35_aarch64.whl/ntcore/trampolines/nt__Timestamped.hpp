// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <ntcore_cpp_types.h>

// from extra_includes
#include <src/nt_type_caster.h>

#include <pybind11/stl.h>
#include <wpi_span_type_caster.h>
#include <wpystruct.h>

namespace swgen {

using namespace nt;

template <typename T>
struct bind_nt__Timestamped {
  py::class_<typename nt::Timestamped<T>, py::smart_holder> cls_Timestamped;

  py::module &m;
  std::string clsName;
  bind_nt__Timestamped(py::module &m, const char * clsName) :
    cls_Timestamped(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_Timestamped.doc() = 
      "Timestamped value.\n"
      "@ingroup ntcore_cpp_handle_api";
    cls_Timestamped.def(py::init<>()
      , release_gil()
    );
    cls_Timestamped.def(py::init<int64_t, int64_t, T>()
      , py::arg("time"), py::arg("serverTime"), py::arg("value")
      , release_gil()
    );
    cls_Timestamped.def_readwrite("time", &nt::Timestamped<T>::time, py::doc("Time in local time base."));
    cls_Timestamped.def_readwrite("serverTime", &nt::Timestamped<T>::serverTime, py::doc("Time in server time base.  May be 0 or 1 for locally set values."));
    cls_Timestamped.def_readwrite("value", &nt::Timestamped<T>::value, py::doc("Value."));
    cls_Timestamped
      ;
      // capture class name by value
      auto clsname = clsName;
      cls_Timestamped.def("__repr__", [clsname](const Timestamped<T>& self) -> py::str {
        return py::str("{}(time={}, serverTime={}, value={!r})")
          .format(clsname, self.time, self.serverTime, self.value);
      })
    ;
    if (set_doc) {
      cls_Timestamped.doc() = set_doc;
    }
    if (add_doc) {
      cls_Timestamped.doc() = py::cast<std::string>(cls_Timestamped.doc()) + add_doc;
    }
  }
}; // struct bind_nt__Timestamped

}; // namespace swgen
