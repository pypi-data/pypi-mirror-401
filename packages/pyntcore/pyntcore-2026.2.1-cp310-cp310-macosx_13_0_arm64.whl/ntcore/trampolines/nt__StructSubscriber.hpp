// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <networktables/StructTopic.h>

#include <trampolines/nt__Subscriber.hpp>

namespace nt {

template <typename T, typename I, typename CfgBase = swgen::EmptyTrampolineCfg>
struct PyTrampolineCfg_StructSubscriber :
  nt::PyTrampolineCfg_Subscriber<
  CfgBase
  >
{
  using Base = nt::StructSubscriber<T, I>;
};

template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
using PyTrampolineBase_StructSubscriber =
  nt::PyTrampoline_Subscriber<
    PyTrampolineBase
    , PyTrampolineCfg>
;

template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
struct PyTrampoline_StructSubscriber : PyTrampolineBase_StructSubscriber<PyTrampolineBase, T, I, PyTrampolineCfg> {
  using PyTrampolineBase_StructSubscriber<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_StructSubscriber;
  using TopicType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TopicType;
  using ValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ValueType;
  using ParamType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ParamType;
  using TimestampedValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TimestampedValueType;
};

}; // namespace nt

#include <pybind11/stl.h>
#include <wpi_json_type_caster.h>
#include <wpystruct.h>

namespace swgen {

using namespace nt;

template <typename T, typename I>
struct bind_nt__StructSubscriber {
  using TopicType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TopicType;
  using ValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ValueType;
  using ParamType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ParamType;
  using TimestampedValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TimestampedValueType;
  struct StructSubscriber_Trampoline : nt::PyTrampoline_StructSubscriber<typename nt::StructSubscriber<T, I>, T, I, typename nt::PyTrampolineCfg_StructSubscriber<T, I>>, py::trampoline_self_life_support {
      using RpyBase = nt::PyTrampoline_StructSubscriber<typename nt::StructSubscriber<T, I>, T, I, typename nt::PyTrampolineCfg_StructSubscriber<T, I>>;
      using RpyBase::RpyBase;
  };
  static_assert(std::is_abstract<StructSubscriber_Trampoline>::value == false, "nt::StructSubscriber<T, I> " SEMIWRAP_BAD_TRAMPOLINE);
  py::class_<typename nt::StructSubscriber<T, I>, py::smart_holder, StructSubscriber_Trampoline, nt::Subscriber> cls_StructSubscriber;

  py::module &m;
  std::string clsName;
  bind_nt__StructSubscriber(py::module &m, const char * clsName) :
    cls_StructSubscriber(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_StructSubscriber.doc() = "NetworkTables struct-encoded value subscriber.";
    cls_StructSubscriber.def("get", static_cast<ValueType (nt::StructSubscriber<T, I>::*)() const>(&nt::StructSubscriber<T, I>::Get)
      , release_gil()
      , py::doc(
      "Get the last published value.\n"
      "If no value has been published or the value cannot be unpacked, returns the\n"
      "stored default value.\n"
      "\n"
      ":returns: value")
    );
    cls_StructSubscriber.def("get", static_cast<ValueType (nt::StructSubscriber<T, I>::*)(const T&) const>(&nt::StructSubscriber<T, I>::Get)
      , py::arg("defaultValue")
      , release_gil()
      , py::doc(
      "Get the last published value.\n"
      "If no value has been published or the value cannot be unpacked, returns the\n"
      "passed defaultValue.\n"
      "\n"
      ":param defaultValue: default value to return if no value has been published\n"
      "\n"
      ":returns: value")
    );
    cls_StructSubscriber.def("getAtomic", static_cast<TimestampedValueType (nt::StructSubscriber<T, I>::*)() const>(&nt::StructSubscriber<T, I>::GetAtomic)
      , release_gil()
      , py::doc(
      "Get the last published value along with its timestamp\n"
      "If no value has been published or the value cannot be unpacked, returns the\n"
      "stored default value and a timestamp of 0.\n"
      "\n"
      ":returns: timestamped value")
    );
    cls_StructSubscriber.def("getAtomic", static_cast<TimestampedValueType (nt::StructSubscriber<T, I>::*)(const T&) const>(&nt::StructSubscriber<T, I>::GetAtomic)
      , py::arg("defaultValue")
      , release_gil()
      , py::doc(
      "Get the last published value along with its timestamp.\n"
      "If no value has been published or the value cannot be unpacked, returns the\n"
      "passed defaultValue and a timestamp of 0.\n"
      "\n"
      ":param defaultValue: default value to return if no value has been published\n"
      "\n"
      ":returns: timestamped value")
    );
    cls_StructSubscriber.def("readQueue", &nt::StructSubscriber<T, I>::ReadQueue
      , release_gil()
      , py::doc(
      "Get an array of all valid value changes since the last call to ReadQueue.\n"
      "Also provides a timestamp for each value. Values that cannot be unpacked\n"
      "are dropped.\n"
      "\n"
      ".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
      "   depth.\n"
      "\n"
      ":returns: Array of timestamped values; empty array if no valid new changes\n"
      "          have been published since the previous call.")
    );
    cls_StructSubscriber.def("getTopic", &nt::StructSubscriber<T, I>::GetTopic
      , release_gil()
      , py::doc(
      "Get the corresponding topic.\n"
      "\n"
      ":returns: Topic")
    );
    cls_StructSubscriber
      .def("close", [](nt::StructSubscriber<T, I> *self) {
        py::gil_scoped_release release;
        *self = nt::StructSubscriber<T, I>();
      }, py::doc("Destroys the subscriber"))
      .def("__enter__", [](nt::StructSubscriber<T, I> *self) {
        return self;
      })
      .def("__exit__", [](nt::StructSubscriber<T, I> *self, py::args args) {
        py::gil_scoped_release release;
        *self = nt::StructSubscriber<T, I>();
      })
    ;
    if (set_doc) {
      cls_StructSubscriber.doc() = set_doc;
    }
    if (add_doc) {
      cls_StructSubscriber.doc() = py::cast<std::string>(cls_StructSubscriber.doc()) + add_doc;
    }
  }
}; // struct bind_nt__StructSubscriber

}; // namespace swgen
