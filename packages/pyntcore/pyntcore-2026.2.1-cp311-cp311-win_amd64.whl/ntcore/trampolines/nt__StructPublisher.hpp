// This file is autogenerated. DO NOT EDIT

#pragma once
#include <semiwrap.h>

// wrapped header

#include <networktables/StructTopic.h>

#include <trampolines/nt__Publisher.hpp>

namespace nt {

template <typename T, typename I, typename CfgBase = swgen::EmptyTrampolineCfg>
struct PyTrampolineCfg_StructPublisher :
  nt::PyTrampolineCfg_Publisher<
  CfgBase
  >
{
  using Base = nt::StructPublisher<T, I>;
};

template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
using PyTrampolineBase_StructPublisher =
  nt::PyTrampoline_Publisher<
    PyTrampolineBase
    , PyTrampolineCfg>
;

template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
struct PyTrampoline_StructPublisher : PyTrampolineBase_StructPublisher<PyTrampolineBase, T, I, PyTrampolineCfg> {
  using PyTrampolineBase_StructPublisher<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_StructPublisher;
  using TopicType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TopicType;
  using ValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ValueType;
  using ParamType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ParamType;
  using TimestampedValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TimestampedValueType;
};

}; // namespace nt

#include <pybind11\stl.h>
#include <wpi_json_type_caster.h>
#include <wpystruct.h>

namespace swgen {

using namespace nt;

template <typename T, typename I>
struct bind_nt__StructPublisher {
  using TopicType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TopicType;
  using ValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ValueType;
  using ParamType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ParamType;
  using TimestampedValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TimestampedValueType;
  struct StructPublisher_Trampoline : nt::PyTrampoline_StructPublisher<typename nt::StructPublisher<T, I>, T, I, typename nt::PyTrampolineCfg_StructPublisher<T, I>>, py::trampoline_self_life_support {
      using RpyBase = nt::PyTrampoline_StructPublisher<typename nt::StructPublisher<T, I>, T, I, typename nt::PyTrampolineCfg_StructPublisher<T, I>>;
      using RpyBase::RpyBase;
  };
  static_assert(std::is_abstract<StructPublisher_Trampoline>::value == false, "nt::StructPublisher<T, I> " SEMIWRAP_BAD_TRAMPOLINE);
  py::class_<typename nt::StructPublisher<T, I>, py::smart_holder, StructPublisher_Trampoline, nt::Publisher> cls_StructPublisher;

  py::module &m;
  std::string clsName;
  bind_nt__StructPublisher(py::module &m, const char * clsName) :
    cls_StructPublisher(m, clsName),
    m(m),
    clsName(clsName) {
  }

  void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
    cls_StructPublisher.doc() = "NetworkTables struct-encoded value publisher.";
    cls_StructPublisher.def("set", &nt::StructPublisher<T, I>::Set
      , py::arg("value"), py::arg("time") = 0
      , release_gil()
      , py::doc(
      "Publish a new value.\n"
      "\n"
      ":param value: value to publish\n"
      ":param time:  timestamp; 0 indicates current NT time should be used")
    );
    cls_StructPublisher.def("setDefault", &nt::StructPublisher<T, I>::SetDefault
      , py::arg("value")
      , release_gil()
      , py::doc(
      "Publish a default value.\n"
      "On reconnect, a default value will never be used in preference to a\n"
      "published value.\n"
      "\n"
      ":param value: value")
    );
    cls_StructPublisher.def("getTopic", &nt::StructPublisher<T, I>::GetTopic
      , release_gil()
      , py::doc(
      "Get the corresponding topic.\n"
      "\n"
      ":returns: Topic")
    );
    cls_StructPublisher
      .def("close", [](nt::StructPublisher<T, I> *self) {
        py::gil_scoped_release release;
        *self = nt::StructPublisher<T, I>();
      }, py::doc("Destroys the publisher"))
      .def("__enter__", [](nt::StructPublisher<T, I> *self) {
        return self;
      })
      .def("__exit__", [](nt::StructPublisher<T, I> *self, py::args args) {
        py::gil_scoped_release release;
        *self = nt::StructPublisher<T, I>();
      })
    ;
    if (set_doc) {
      cls_StructPublisher.doc() = set_doc;
    }
    if (add_doc) {
      cls_StructPublisher.doc() = py::cast<std::string>(cls_StructPublisher.doc()) + add_doc;
    }
  }
}; // struct bind_nt__StructPublisher

}; // namespace swgen
