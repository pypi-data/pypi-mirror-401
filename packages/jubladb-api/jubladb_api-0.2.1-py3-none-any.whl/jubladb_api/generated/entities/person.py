# DO NOT EDIT THIS FILE, it is auto-generated!
import jubladb_api.core.metamodel_classes
import jubladb_api.core.base_entity
import jubladb_api.generated.entities.keys

import datetime

import typing

# @formatter:off


class Person(jubladb_api.core.base_entity.BaseEntity):
    def __init__(
        self,
        id_: int,
        first_name: str,
        last_name: str,
        nickname: str | None,
        company_name: str | None,
        company: bool,
        email: str,
        address: str,
        address_care_of: str | None,
        street: str,
        housenumber: str,
        postbox: str | None,
        zip_code: str,
        town: str,
        country: str,
        primary_group_id: int,
        gender: str,
        birthday: datetime.date,
        picture: str,
        updated_at: datetime.datetime,
        additional_information: str | None,
        language: str,
        primary_group: jubladb_api.generated.entities.keys.GroupKey | None,
        layer_group: jubladb_api.generated.entities.keys.GroupKey | None,
        roles: list[jubladb_api.generated.entities.keys.RoleKey] | None,
        phone_numbers: list[jubladb_api.generated.entities.keys.PhoneNumberKey] | None,
        social_accounts: (
            list[jubladb_api.generated.entities.keys.SocialAccountKey] | None
        ),
        additional_emails: (
            list[jubladb_api.generated.entities.keys.AdditionalEmailKey] | None
        ),
    ):
        super().__init__(id_)

        self._first_name = first_name
        self._last_name = last_name
        self._nickname = nickname
        self._company_name = company_name
        self._company = company
        self._email = email
        self._address = address
        self._address_care_of = address_care_of
        self._street = street
        self._housenumber = housenumber
        self._postbox = postbox
        self._zip_code = zip_code
        self._town = town
        self._country = country
        self._primary_group_id = primary_group_id
        self._gender = gender
        self._birthday = birthday
        self._picture = picture
        self._updated_at = updated_at
        self._additional_information = additional_information
        self._language = language

        self._primary_group = primary_group
        self._layer_group = layer_group
        self._roles = roles
        self._phone_numbers = phone_numbers
        self._social_accounts = social_accounts
        self._additional_emails = additional_emails

    @property
    def first_name(self) -> str:
        return self._first_name

    @property
    def last_name(self) -> str:
        return self._last_name

    @property
    def nickname(self) -> str | None:
        return self._nickname

    @property
    def company_name(self) -> str | None:
        return self._company_name

    @property
    def company(self) -> bool:
        return self._company

    @property
    def email(self) -> str:
        return self._email

    @property
    def address(self) -> str:
        return self._address

    @property
    def address_care_of(self) -> str | None:
        return self._address_care_of

    @property
    def street(self) -> str:
        return self._street

    @property
    def housenumber(self) -> str:
        return self._housenumber

    @property
    def postbox(self) -> str | None:
        return self._postbox

    @property
    def zip_code(self) -> str:
        return self._zip_code

    @property
    def town(self) -> str:
        return self._town

    @property
    def country(self) -> str:
        return self._country

    @property
    def primary_group_id(self) -> int:
        return self._primary_group_id

    @property
    def gender(self) -> str:
        return self._gender

    @property
    def birthday(self) -> datetime.date:
        return self._birthday

    @property
    def picture(self) -> str:
        return self._picture

    @property
    def updated_at(self) -> datetime.datetime:
        return self._updated_at

    @property
    def additional_information(self) -> str | None:
        return self._additional_information

    @property
    def language(self) -> str:
        return self._language

    @property
    def primary_group(self) -> jubladb_api.generated.entities.keys.GroupKey:
        if self._primary_group is None:
            raise ValueError("Relation primary_group is not included")
        return self._primary_group

    @property
    def layer_group(self) -> jubladb_api.generated.entities.keys.GroupKey:
        if self._layer_group is None:
            raise ValueError("Relation layer_group is not included")
        return self._layer_group

    @property
    def roles(self) -> list[jubladb_api.generated.entities.keys.RoleKey]:
        if self._roles is None:
            raise ValueError("Relation roles is not included")
        return self._roles

    @property
    def phone_numbers(self) -> list[jubladb_api.generated.entities.keys.PhoneNumberKey]:
        if self._phone_numbers is None:
            raise ValueError("Relation phone_numbers is not included")
        return self._phone_numbers

    @property
    def social_accounts(
        self,
    ) -> list[jubladb_api.generated.entities.keys.SocialAccountKey]:
        if self._social_accounts is None:
            raise ValueError("Relation social_accounts is not included")
        return self._social_accounts

    @property
    def additional_emails(
        self,
    ) -> list[jubladb_api.generated.entities.keys.AdditionalEmailKey]:
        if self._additional_emails is None:
            raise ValueError("Relation additional_emails is not included")
        return self._additional_emails

    @property
    def key(self) -> jubladb_api.generated.entities.keys.PersonKey:
        return jubladb_api.generated.entities.keys.PersonKey(self._id)

    @property
    def meta(self) -> jubladb_api.core.metamodel_classes.Entity:
        return jubladb_api.generated.metamodel.ENTITIES["person"]

    def is_relation_loaded(
        self,
        relation_name: typing.Literal[
            "primary_group",
            "layer_group",
            "roles",
            "phone_numbers",
            "social_accounts",
            "additional_emails",
        ],
    ) -> bool:

        if relation_name == "primary_group":
            return self._primary_group is not None

        elif relation_name == "layer_group":
            return self._layer_group is not None

        elif relation_name == "roles":
            return self._roles is not None

        elif relation_name == "phone_numbers":
            return self._phone_numbers is not None

        elif relation_name == "social_accounts":
            return self._social_accounts is not None

        elif relation_name == "additional_emails":
            return self._additional_emails is not None

        else:
            raise ValueError(f"relation {relation_name} does not exist on person")

    @classmethod
    def from_json(cls, json_data: dict):
        if json_data.get("type", None) != "people":
            raise ValueError("Invalid data type")
        return cls(
            id_=cls._access_id(json_data),
            first_name=cls._access_data_attribute(
                json_data,
                "first_name",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            last_name=cls._access_data_attribute(
                json_data,
                "last_name",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            nickname=cls._access_data_attribute(
                json_data,
                "nickname",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
                optional=True,
            ),
            company_name=cls._access_data_attribute(
                json_data,
                "company_name",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
                optional=True,
            ),
            company=cls._access_data_attribute(
                json_data,
                "company",
                jubladb_api.core.metamodel_classes.AttributeType.BOOLEAN,
            ),
            email=cls._access_data_attribute(
                json_data,
                "email",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            address=cls._access_data_attribute(
                json_data,
                "address",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            address_care_of=cls._access_data_attribute(
                json_data,
                "address_care_of",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
                optional=True,
            ),
            street=cls._access_data_attribute(
                json_data,
                "street",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            housenumber=cls._access_data_attribute(
                json_data,
                "housenumber",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            postbox=cls._access_data_attribute(
                json_data,
                "postbox",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
                optional=True,
            ),
            zip_code=cls._access_data_attribute(
                json_data,
                "zip_code",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            town=cls._access_data_attribute(
                json_data,
                "town",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            country=cls._access_data_attribute(
                json_data,
                "country",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            primary_group_id=cls._access_data_attribute(
                json_data,
                "primary_group_id",
                jubladb_api.core.metamodel_classes.AttributeType.INTEGER,
            ),
            gender=cls._access_data_attribute(
                json_data,
                "gender",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            birthday=cls._access_data_attribute(
                json_data,
                "birthday",
                jubladb_api.core.metamodel_classes.AttributeType.DATE,
            ),
            picture=cls._access_data_attribute(
                json_data,
                "picture",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            updated_at=cls._access_data_attribute(
                json_data,
                "updated_at",
                jubladb_api.core.metamodel_classes.AttributeType.DATETIME,
            ),
            additional_information=cls._access_data_attribute(
                json_data,
                "additional_information",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
                optional=True,
            ),
            language=cls._access_data_attribute(
                json_data,
                "language",
                jubladb_api.core.metamodel_classes.AttributeType.STRING,
            ),
            primary_group=cls._create_single_relation_key(
                json_data,
                "primary_group",
                "groups",
                jubladb_api.generated.entities.keys.GroupKey,
            ),
            layer_group=cls._create_single_relation_key(
                json_data,
                "layer_group",
                "groups",
                jubladb_api.generated.entities.keys.GroupKey,
            ),
            roles=cls._create_many_relation_keys(
                json_data, "roles", "roles", jubladb_api.generated.entities.keys.RoleKey
            ),
            phone_numbers=cls._create_many_relation_keys(
                json_data,
                "phone_numbers",
                "phone_numbers",
                jubladb_api.generated.entities.keys.PhoneNumberKey,
            ),
            social_accounts=cls._create_many_relation_keys(
                json_data,
                "social_accounts",
                "social_accounts",
                jubladb_api.generated.entities.keys.SocialAccountKey,
            ),
            additional_emails=cls._create_many_relation_keys(
                json_data,
                "additional_emails",
                "additional_emails",
                jubladb_api.generated.entities.keys.AdditionalEmailKey,
            ),
        )


# @formatter:on
