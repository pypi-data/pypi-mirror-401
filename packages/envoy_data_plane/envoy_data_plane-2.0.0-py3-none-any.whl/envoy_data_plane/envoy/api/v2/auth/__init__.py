# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/api/v2/auth/cert.proto, envoy/api/v2/auth/common.proto, envoy/api/v2/auth/secret.proto, envoy/api/v2/auth/tls.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "CertificateValidationContext",
    "CertificateValidationContextTrustChainVerification",
    "CommonTlsContext",
    "CommonTlsContextCombinedCertificateValidationContext",
    "DownstreamTlsContext",
    "GenericSecret",
    "PrivateKeyProvider",
    "SdsSecretConfig",
    "Secret",
    "TlsCertificate",
    "TlsParameters",
    "TlsParametersTlsProtocol",
    "TlsSessionTicketKeys",
    "UpstreamTlsContext",
)

import datetime
import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class CertificateValidationContextTrustChainVerification(betterproto2.Enum):
    """
    Peer certificate verification mode.
    """

    VERIFY_TRUST_CHAIN = 0
    """
    Perform default certificate verification (e.g., against CA / verification lists)
    """

    ACCEPT_UNTRUSTED = 1
    """
    Connections where the certificate fails verification will be permitted.
    For HTTP connections, the result of certificate verification can be used in route matching. (
    see :ref:`validated <envoy_api_field_route.RouteMatch.TlsContextMatchOptions.validated>` ).
    """


class TlsParametersTlsProtocol(betterproto2.Enum):
    TLS_AUTO = 0
    """
    Envoy will choose the optimal TLS version.
    """

    TLSv1_0 = 1
    """
    TLS 1.0
    """

    TLSv1_1 = 2
    """
    TLS 1.1
    """

    TLSv1_2 = 3
    """
    TLS 1.2
    """

    TLSv1_3 = 4
    """
    TLS 1.3
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CertificateValidationContext(betterproto2.Message):
    """
    [#next-free-field: 11]
    """

    trusted_ca: "_core__.DataSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    TLS certificate data containing certificate authority certificates to use in verifying
    a presented peer certificate (e.g. server certificate for clusters or client certificate
    for listeners). If not specified and a peer certificate is presented it will not be
    verified. By default, a client certificate is optional, unless one of the additional
    options (:ref:`require_client_certificate
    <envoy_api_field_auth.DownstreamTlsContext.require_client_certificate>`,
    :ref:`verify_certificate_spki
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`,
    :ref:`verify_certificate_hash
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`, or
    :ref:`match_subject_alt_names
    <envoy_api_field_auth.CertificateValidationContext.match_subject_alt_names>`) is also
    specified.

    It can optionally contain certificate revocation lists, in which case Envoy will verify
    that the presented peer certificate has not been revoked by one of the included CRLs.

    See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
    system CA locations.
    """

    verify_certificate_spki: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
    SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
    matches one of the specified values.

    A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
    can be generated with the following command:

    .. code-block:: bash

      $ openssl x509 -in path/to/client.crt -noout -pubkey
        | openssl pkey -pubin -outform DER
        | openssl dgst -sha256 -binary
        | openssl enc -base64
      NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=

    This is the format used in HTTP Public Key Pinning.

    When both:
    :ref:`verify_certificate_hash
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
    :ref:`verify_certificate_spki
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
    a hash matching value from either of the lists will result in the certificate being accepted.

    .. attention::

      This option is preferred over :ref:`verify_certificate_hash
      <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`,
      because SPKI is tied to a private key, so it doesn't change when the certificate
      is renewed using the same private key.
    """

    verify_certificate_hash: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )
    """
    An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
    the SHA-256 of the DER-encoded presented certificate matches one of the specified values.

    A hex-encoded SHA-256 of the certificate can be generated with the following command:

    .. code-block:: bash

      $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
      df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a

    A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
    can be generated with the following command:

    .. code-block:: bash

      $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
      DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A

    Both of those formats are acceptable.

    When both:
    :ref:`verify_certificate_hash
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
    :ref:`verify_certificate_spki
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
    a hash matching value from either of the lists will result in the certificate being accepted.
    """

    verify_subject_alt_name: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )
    """
    An optional list of Subject Alternative Names. If specified, Envoy will verify that the
    Subject Alternative Name of the presented certificate matches one of the specified values.

    .. attention::

      Subject Alternative Names are easily spoofable and verifying only them is insecure,
      therefore this option must be used together with :ref:`trusted_ca
      <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
    """

    match_subject_alt_names: "list[___type__matcher__.StringMatcher]" = (
        betterproto2.field(9, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    An optional list of Subject Alternative name matchers. Envoy will verify that the
    Subject Alternative Name of the presented certificate matches one of the specified matches.

    When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
    configured with exact match type in the :ref:`string matcher <envoy_api_msg_type.matcher.StringMatcher>`.
    For example if the certificate has "\\*.example.com" as DNS SAN entry, to allow only "api.example.com",
    it should be configured as shown below.

    .. code-block:: yaml

     match_subject_alt_names:
       exact: "api.example.com"

    .. attention::

      Subject Alternative Names are easily spoofable and verifying only them is insecure,
      therefore this option must be used together with :ref:`trusted_ca
      <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
    """

    require_ocsp_staple: "bool | None" = betterproto2.field(
        5,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
    """

    require_signed_certificate_timestamp: "bool | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    [#not-implemented-hide:] Must present signed certificate time-stamp.
    """

    crl: "_core__.DataSource | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An optional `certificate revocation list
    <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
    (in PEM format). If specified, Envoy will verify that the presented peer
    certificate has not been revoked by this CRL. If this DataSource contains
    multiple CRLs, all of them will be used.
    """

    allow_expired_certificate: "bool" = betterproto2.field(8, betterproto2.TYPE_BOOL)
    """
    If specified, Envoy will not reject expired certificates.
    """

    trust_chain_verification: "CertificateValidationContextTrustChainVerification" = (
        betterproto2.field(
            10,
            betterproto2.TYPE_ENUM,
            default_factory=lambda: CertificateValidationContextTrustChainVerification(
                0
            ),
        )
    )
    """
    Certificate trust chain verification mode.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("verify_subject_alt_name"):
            warnings.warn(
                "CertificateValidationContext.verify_subject_alt_name is deprecated",
                DeprecationWarning,
            )


default_message_pool.register_message(
    "envoy.api.v2.auth", "CertificateValidationContext", CertificateValidationContext
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CommonTlsContext(betterproto2.Message):
    """
    TLS context shared by both client and server TLS contexts.
    [#next-free-field: 9]

    Oneofs:
        - validation_context_type:
    """

    tls_params: "TlsParameters | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    TLS protocol versions, cipher suites etc.
    """

    tls_certificates: "list[TlsCertificate]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
    same context to allow both RSA and ECDSA certificates.

    Only a single TLS certificate is supported in client contexts. In server contexts, the first
    RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
    used for clients that support ECDSA.
    """

    tls_certificate_sds_secret_configs: "list[SdsSecretConfig]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Configs for fetching TLS certificates via SDS API.
    """

    validation_context: "CertificateValidationContext | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="validation_context_type"
    )
    """
    How to validate peer certificates.
    """

    validation_context_sds_secret_config: "SdsSecretConfig | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="validation_context_type"
    )
    """
    Config for fetching validation context via SDS API.
    """

    combined_validation_context: "CommonTlsContextCombinedCertificateValidationContext | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="validation_context_type"
    )
    """
    Combined certificate validation context holds a default CertificateValidationContext
    and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
    and default CertificateValidationContext are merged into a new CertificateValidationContext
    for validation. This merge is done by Message::MergeFrom(), so dynamic
    CertificateValidationContext overwrites singular fields in default
    CertificateValidationContext, and concatenates repeated fields to default
    CertificateValidationContext, and logical OR is applied to boolean fields.
    """

    alpn_protocols: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Supplies the list of ALPN protocols that the listener should expose. In
    practice this is likely to be set to one of two values (see the
    :ref:`codec_type
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type>`
    parameter in the HTTP connection manager for more information):

    * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
    * "http/1.1" If the listener is only going to support HTTP/1.1.

    There is no default for this parameter. If empty, Envoy will not expose ALPN.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.api.v2.auth", "CommonTlsContext", CommonTlsContext
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CommonTlsContextCombinedCertificateValidationContext(betterproto2.Message):
    default_validation_context: "CertificateValidationContext | None" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    How to validate peer certificates.
    """

    validation_context_sds_secret_config: "SdsSecretConfig | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Config for fetching validation context via SDS API.
    """


default_message_pool.register_message(
    "envoy.api.v2.auth",
    "CommonTlsContext.CombinedCertificateValidationContext",
    CommonTlsContextCombinedCertificateValidationContext,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DownstreamTlsContext(betterproto2.Message):
    """
    [#next-free-field: 8]

    Oneofs:
        - session_ticket_keys_type:
    """

    common_tls_context: "CommonTlsContext | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common TLS context settings.
    """

    require_client_certificate: "bool | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    If specified, Envoy will reject connections without a valid client
    certificate.
    """

    require_sni: "bool | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.BoolValue,
        optional=True,
    )
    """
    If specified, Envoy will reject connections without a valid and matching SNI.
    [#not-implemented-hide:]
    """

    session_ticket_keys: "TlsSessionTicketKeys | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="session_ticket_keys_type"
    )
    """
    TLS session ticket key settings.
    """

    session_ticket_keys_sds_secret_config: "SdsSecretConfig | None" = (
        betterproto2.field(
            5,
            betterproto2.TYPE_MESSAGE,
            optional=True,
            group="session_ticket_keys_type",
        )
    )
    """
    Config for fetching TLS session ticket keys via SDS API.
    """

    disable_stateless_session_resumption: "bool | None" = betterproto2.field(
        7, betterproto2.TYPE_BOOL, optional=True, group="session_ticket_keys_type"
    )
    """
    Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
    server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
    If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
    the keys specified through either :ref:`session_ticket_keys <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`
    or :ref:`session_ticket_keys_sds_secret_config <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
    If this config is set to false and no keys are explicitly configured, the TLS server will issue
    TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
    implication that sessions cannot be resumed across hot restarts or on different hosts.
    """

    session_timeout: "datetime.timedelta | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    If specified, ``session_timeout`` will change the maximum lifetime (in seconds) of the TLS session.
    Currently this value is used as a hint for the `TLS session ticket lifetime (for TLSv1.2) <https://tools.ietf.org/html/rfc5077#section-5.6>`_.
    Only seconds can be specified (fractional seconds are ignored).
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.api.v2.auth", "DownstreamTlsContext", DownstreamTlsContext
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GenericSecret(betterproto2.Message):
    """
    [#protodoc-title: Secrets configuration]
    """

    secret: "_core__.DataSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Secret of generic type and is available to filters.
    """


default_message_pool.register_message(
    "envoy.api.v2.auth", "GenericSecret", GenericSecret
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PrivateKeyProvider(betterproto2.Message):
    """
    BoringSSL private key method configuration. The private key methods are used for external
    (potentially asynchronous) signing and decryption operations. Some use cases for private key
    methods would be TPM support and TLS acceleration.

    Oneofs:
        - config_type: Private key method provider specific configuration.
    """

    provider_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Private key method provider name. The name must match a
    supported private key method provider type.
    """

    config: "____google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    typed_config: "____google__protobuf__.Any | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="config_type"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("config"):
            warnings.warn("PrivateKeyProvider.config is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.api.v2.auth", "PrivateKeyProvider", PrivateKeyProvider
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SdsSecretConfig(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
    When both name and config are specified, then secret can be fetched and/or reloaded via
    SDS. When only name is specified, then secret will be loaded from static resources.
    """

    sds_config: "_core__.ConfigSource | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "envoy.api.v2.auth", "SdsSecretConfig", SdsSecretConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Secret(betterproto2.Message):
    """
    [#next-free-field: 6]

    Oneofs:
        - type:
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
    """

    tls_certificate: "TlsCertificate | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )

    session_ticket_keys: "TlsSessionTicketKeys | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )

    validation_context: "CertificateValidationContext | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )

    generic_secret: "GenericSecret | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="type"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.api.v2.auth", "Secret", Secret)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TlsCertificate(betterproto2.Message):
    """
    [#next-free-field: 7]
    """

    certificate_chain: "_core__.DataSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The TLS certificate chain.
    """

    private_key: "_core__.DataSource | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The TLS private key.
    """

    private_key_provider: "PrivateKeyProvider | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    BoringSSL private key method provider. This is an alternative to :ref:`private_key
    <envoy_api_field_auth.TlsCertificate.private_key>` field. This can't be
    marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key
    <envoy_api_field_auth.TlsCertificate.private_key>` and
    :ref:`private_key_provider
    <envoy_api_field_auth.TlsCertificate.private_key_provider>` fields will result in an
    error.
    """

    password: "_core__.DataSource | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The password to decrypt the TLS private key. If this field is not set, it is assumed that the
    TLS private key is not password encrypted.
    """

    ocsp_staple: "_core__.DataSource | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:]
    """

    signed_certificate_timestamp: "list[_core__.DataSource]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    [#not-implemented-hide:]
    """


default_message_pool.register_message(
    "envoy.api.v2.auth", "TlsCertificate", TlsCertificate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TlsParameters(betterproto2.Message):
    """
    [#protodoc-title: Common TLS configuration]
    """

    tls_minimum_protocol_version: "TlsParametersTlsProtocol" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: TlsParametersTlsProtocol(0)
    )
    """
    Minimum TLS protocol version. By default, it's ``TLSv1_2`` for both clients and servers.
    """

    tls_maximum_protocol_version: "TlsParametersTlsProtocol" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TlsParametersTlsProtocol(0)
    )
    """
    Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
    servers.
    """

    cipher_suites: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    If specified, the TLS listener will only support the specified `cipher list
    <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
    when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3). If not
    specified, the default list will be used.

    In non-FIPS builds, the default cipher list is:

    .. code-block:: none

      [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
      [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
      ECDHE-ECDSA-AES128-SHA
      ECDHE-RSA-AES128-SHA
      AES128-GCM-SHA256
      AES128-SHA
      ECDHE-ECDSA-AES256-GCM-SHA384
      ECDHE-RSA-AES256-GCM-SHA384
      ECDHE-ECDSA-AES256-SHA
      ECDHE-RSA-AES256-SHA
      AES256-GCM-SHA384
      AES256-SHA

    In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default cipher list is:

    .. code-block:: none

      ECDHE-ECDSA-AES128-GCM-SHA256
      ECDHE-RSA-AES128-GCM-SHA256
      ECDHE-ECDSA-AES128-SHA
      ECDHE-RSA-AES128-SHA
      AES128-GCM-SHA256
      AES128-SHA
      ECDHE-ECDSA-AES256-GCM-SHA384
      ECDHE-RSA-AES256-GCM-SHA384
      ECDHE-ECDSA-AES256-SHA
      ECDHE-RSA-AES256-SHA
      AES256-GCM-SHA384
      AES256-SHA
    """

    ecdh_curves: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )
    """
    If specified, the TLS connection will only support the specified ECDH
    curves. If not specified, the default curves will be used.

    In non-FIPS builds, the default curves are:

    .. code-block:: none

      X25519
      P-256

    In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default curve is:

    .. code-block:: none

      P-256
    """


default_message_pool.register_message(
    "envoy.api.v2.auth", "TlsParameters", TlsParameters
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TlsSessionTicketKeys(betterproto2.Message):
    keys: "list[_core__.DataSource]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Keys for encrypting and decrypting TLS session tickets. The
    first key in the array contains the key to encrypt all new sessions created by this context.
    All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
    by, for example, putting the new key first, and the previous key second.

    If :ref:`session_ticket_keys <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`
    is not specified, the TLS library will still support resuming sessions via tickets, but it will
    use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
    or on different hosts.

    Each key must contain exactly 80 bytes of cryptographically-secure random data. For
    example, the output of ``openssl rand 80``.

    .. attention::

      Using this feature has serious security considerations and risks. Improper handling of keys
      may result in loss of secrecy in connections, even if ciphers supporting perfect forward
      secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
      discussion. To minimize the risk, you must:

      * Keep the session ticket keys at least as secure as your TLS certificate private keys
      * Rotate session ticket keys at least daily, and preferably hourly
      * Always generate keys using a cryptographically-secure random data source
    """


default_message_pool.register_message(
    "envoy.api.v2.auth", "TlsSessionTicketKeys", TlsSessionTicketKeys
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UpstreamTlsContext(betterproto2.Message):
    """
    [#protodoc-title: TLS transport socket]
    [#extension: envoy.transport_sockets.tls]
    The TLS contexts below provide the transport socket configuration for upstream/downstream TLS.
    """

    common_tls_context: "CommonTlsContext | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common TLS context settings.

    .. attention::

      Server certificate verification is not enabled by default. Configure
      :ref:`trusted_ca<envoy_api_field_auth.CertificateValidationContext.trusted_ca>` to enable
      verification.
    """

    sni: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    SNI string to use when creating TLS backend connections.
    """

    allow_renegotiation: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    If true, server-initiated TLS renegotiation will be allowed.

    .. attention::

      TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
    """

    max_session_keys: "int | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
    for TLSv1.2 and older) to store for the purpose of session resumption.

    Defaults to 1, setting this to 0 disables session resumption.
    """


default_message_pool.register_message(
    "envoy.api.v2.auth", "UpstreamTlsContext", UpstreamTlsContext
)


from .....google import protobuf as ____google__protobuf__
from ....type import matcher as ___type__matcher__
from .. import core as _core__
