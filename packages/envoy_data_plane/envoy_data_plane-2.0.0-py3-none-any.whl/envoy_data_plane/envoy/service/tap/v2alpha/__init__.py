# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/tap/v2alpha/common.proto, envoy/service/tap/v2alpha/tap.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "FilePerTapSink",
    "HttpHeadersMatch",
    "MatchPredicate",
    "MatchPredicateMatchSet",
    "OutputConfig",
    "OutputSink",
    "OutputSinkFormat",
    "StreamTapsRequest",
    "StreamTapsRequestIdentifier",
    "StreamTapsResponse",
    "StreamingAdminSink",
    "StreamingGrpcSink",
    "TapConfig",
    "TapSinkServiceAsyncStub",
    "TapSinkServiceBase",
    "TapSinkServiceSyncStub",
)

import typing
from collections.abc import AsyncIterable, AsyncIterator, Iterable
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class OutputSinkFormat(betterproto2.Enum):
    """
    Output format. All output is in the form of one or more :ref:`TraceWrapper
    <envoy_api_msg_data.tap.v2alpha.TraceWrapper>` messages. This enumeration indicates
    how those messages are written. Note that not all sinks support all output formats. See
    individual sink documentation for more information.
    """

    JSON_BODY_AS_BYTES = 0
    """
    Each message will be written as JSON. Any :ref:`body <envoy_api_msg_data.tap.v2alpha.Body>`
    data will be present in the :ref:`as_bytes
    <envoy_api_field_data.tap.v2alpha.Body.as_bytes>` field. This means that body data will be
    base64 encoded as per the `proto3 JSON mappings
    <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
    """

    JSON_BODY_AS_STRING = 1
    """
    Each message will be written as JSON. Any :ref:`body <envoy_api_msg_data.tap.v2alpha.Body>`
    data will be present in the :ref:`as_string
    <envoy_api_field_data.tap.v2alpha.Body.as_string>` field. This means that body data will be
    string encoded as per the `proto3 JSON mappings
    <https://developers.google.com/protocol-buffers/docs/proto3#json>`_. This format type is
    useful when it is known that that body is human readable (e.g., JSON over HTTP) and the
    user wishes to view it directly without being forced to base64 decode the body.
    """

    PROTO_BINARY = 2
    """
    Binary proto format. Note that binary proto is not self-delimiting. If a sink writes
    multiple binary messages without any length information the data stream will not be
    useful. However, for certain sinks that are self-delimiting (e.g., one message per file)
    this output format makes consumption simpler.
    """

    PROTO_BINARY_LENGTH_DELIMITED = 3
    """
    Messages are written as a sequence tuples, where each tuple is the message length encoded
    as a `protobuf 32-bit varint
    <https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream>`_
    followed by the binary message. The messages can be read back using the language specific
    protobuf coded stream implementation to obtain the message length and the message.
    """

    PROTO_TEXT = 4
    """
    Text proto format.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class FilePerTapSink(betterproto2.Message):
    """
    The file per tap sink outputs a discrete file for every tapped stream.
    """

    path_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Path prefix. The output file will be of the form <path_prefix>_<id>.pb, where <id> is an
    identifier distinguishing the recorded trace for stream instances (the Envoy
    connection ID, HTTP stream ID, etc.).
    """


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "FilePerTapSink", FilePerTapSink
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpHeadersMatch(betterproto2.Message):
    """
    HTTP headers match configuration.
    """

    headers: "list[___api__v2__route__.HeaderMatcher]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    HTTP headers to match.
    """


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "HttpHeadersMatch", HttpHeadersMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatchPredicate(betterproto2.Message):
    """
    Tap match configuration. This is a recursive structure which allows complex nested match
    configurations to be built using various logical operators.
    [#next-free-field: 9]

    Oneofs:
        - rule:
    """

    or_match: "MatchPredicateMatchSet | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set that describes a logical OR. If any member of the set matches, the match configuration
    matches.
    """

    and_match: "MatchPredicateMatchSet | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set that describes a logical AND. If all members of the set match, the match configuration
    matches.
    """

    not_match: "MatchPredicate | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A negation match. The match configuration will match if the negated match condition matches.
    """

    any_match: "bool | None" = betterproto2.field(
        4, betterproto2.TYPE_BOOL, optional=True, group="rule"
    )
    """
    The match configuration will always match.
    """

    http_request_headers_match: "HttpHeadersMatch | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP request headers match configuration.
    """

    http_request_trailers_match: "HttpHeadersMatch | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP request trailers match configuration.
    """

    http_response_headers_match: "HttpHeadersMatch | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP response headers match configuration.
    """

    http_response_trailers_match: "HttpHeadersMatch | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP response trailers match configuration.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "MatchPredicate", MatchPredicate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatchPredicateMatchSet(betterproto2.Message):
    """
    A set of match configurations used for logical operations.
    """

    rules: "list[MatchPredicate]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of rules that make up the set.
    """


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "MatchPredicate.MatchSet", MatchPredicateMatchSet
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class OutputConfig(betterproto2.Message):
    """
    Tap output configuration.
    """

    sinks: "list[OutputSink]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Output sinks for tap data. Currently a single sink is allowed in the list. Once multiple
    sink types are supported this constraint will be relaxed.
    """

    max_buffered_rx_bytes: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    For buffered tapping, the maximum amount of received body that will be buffered prior to
    truncation. If truncation occurs, the :ref:`truncated
    <envoy_api_field_data.tap.v2alpha.Body.truncated>` field will be set. If not specified, the
    default is 1KiB.
    """

    max_buffered_tx_bytes: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    For buffered tapping, the maximum amount of transmitted body that will be buffered prior to
    truncation. If truncation occurs, the :ref:`truncated
    <envoy_api_field_data.tap.v2alpha.Body.truncated>` field will be set. If not specified, the
    default is 1KiB.
    """

    streaming: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Indicates whether taps produce a single buffered message per tap, or multiple streamed
    messages per tap in the emitted :ref:`TraceWrapper
    <envoy_api_msg_data.tap.v2alpha.TraceWrapper>` messages. Note that streamed tapping does not
    mean that no buffering takes place. Buffering may be required if data is processed before a
    match can be determined. See the HTTP tap filter :ref:`streaming
    <config_http_filters_tap_streaming>` documentation for more information.
    """


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "OutputConfig", OutputConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class OutputSink(betterproto2.Message):
    """
    Tap output sink configuration.

    Oneofs:
        - output_sink_type:
    """

    format: "OutputSinkFormat" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: OutputSinkFormat(0)
    )
    """
    Sink output format.
    """

    streaming_admin: "StreamingAdminSink | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="output_sink_type"
    )
    """
    Tap output will be streamed out the :http:post:`/tap` admin endpoint.

    .. attention::

      It is only allowed to specify the streaming admin output sink if the tap is being
      configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
      been configured to receive tap configuration from some other source (e.g., static
      file, XDS, etc.) configuring the streaming admin output type will fail.
    """

    file_per_tap: "FilePerTapSink | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="output_sink_type"
    )
    """
    Tap output will be written to a file per tap sink.
    """

    streaming_grpc: "StreamingGrpcSink | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="output_sink_type"
    )
    """
    [#not-implemented-hide:]
    GrpcService to stream data to. The format argument must be PROTO_BINARY.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "OutputSink", OutputSink
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamingAdminSink(betterproto2.Message):
    """
    Streaming admin sink configuration.
    """

    pass


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "StreamingAdminSink", StreamingAdminSink
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamingGrpcSink(betterproto2.Message):
    """
    [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
    server.
    """

    tap_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Opaque identifier, that will be sent back to the streaming grpc server.
    """

    grpc_service: "___api__v2__core__.GrpcService | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The gRPC server that hosts the Tap Sink Service.
    """


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "StreamingGrpcSink", StreamingGrpcSink
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamTapsRequest(betterproto2.Message):
    """
    [#not-implemented-hide:] Stream message for the Tap API. Envoy will open a stream to the server
    and stream taps without ever expecting a response.
    """

    identifier: "StreamTapsRequestIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Identifier data effectively is a structured metadata. As a performance optimization this will
    only be sent in the first message on the stream.
    """

    trace_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )
    """
    The trace id. this can be used to merge together a streaming trace. Note that the trace_id
    is not guaranteed to be spatially or temporally unique.
    """

    trace: "___data__tap__v2alpha__.TraceWrapper | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The trace data.
    """


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "StreamTapsRequest", StreamTapsRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamTapsRequestIdentifier(betterproto2.Message):
    node: "___api__v2__core__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node sending taps over the stream.
    """

    tap_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The opaque identifier that was set in the :ref:`output config
    <envoy_api_field_service.tap.v2alpha.StreamingGrpcSink.tap_id>`.
    """


default_message_pool.register_message(
    "envoy.service.tap.v2alpha",
    "StreamTapsRequest.Identifier",
    StreamTapsRequestIdentifier,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamTapsResponse(betterproto2.Message):
    """
    [#not-implemented-hide:]
    """

    pass


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "StreamTapsResponse", StreamTapsResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TapConfig(betterproto2.Message):
    """
    [#protodoc-title: Common tap configuration]

    Tap configuration.

    [#comment:TODO(mattklein123): Rate limiting]
    """

    match_config: "MatchPredicate | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The match configuration. If the configuration matches the data source being tapped, a tap will
    occur, with the result written to the configured output.
    """

    output_config: "OutputConfig | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The tap output configuration. If a match configuration matches a data source being tapped,
    a tap will occur and the data will be written to the configured output.
    """

    tap_enabled: "___api__v2__core__.RuntimeFractionalPercent | None" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    [#not-implemented-hide:] Specify if Tap matching is enabled. The % of requests\\connections for
    which the tap matching is enabled. When not enabled, the request\\connection will not be
    recorded.

    .. note::

      This field defaults to 100/:ref:`HUNDRED
      <envoy_api_enum_type.FractionalPercent.DenominatorType>`.
    """


default_message_pool.register_message(
    "envoy.service.tap.v2alpha", "TapConfig", TapConfig
)


class TapSinkServiceSyncStub:
    """
    [#protodoc-title: Tap Sink Service]

    [#not-implemented-hide:] A tap service to receive incoming taps. Envoy will call
    StreamTaps to deliver captured taps to the server
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_taps(
        self, messages: "Iterable[StreamTapsRequest]"
    ) -> "StreamTapsResponse":
        """
        Envoy will connect and send StreamTapsRequest messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect.
        """

        return self._channel.stream_unary(
            "/envoy.service.tap.v2alpha.TapSinkService/StreamTaps",
            StreamTapsRequest.SerializeToString,
            StreamTapsResponse.FromString,
        )(iter(messages))


class TapSinkServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Tap Sink Service]

    [#not-implemented-hide:] A tap service to receive incoming taps. Envoy will call
    StreamTaps to deliver captured taps to the server
    """

    async def stream_taps(
        self,
        messages: "AsyncIterable[StreamTapsRequest] | Iterable[StreamTapsRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "StreamTapsResponse":
        """
        Envoy will connect and send StreamTapsRequest messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect.
        """

        return await self._stream_unary(
            "/envoy.service.tap.v2alpha.TapSinkService/StreamTaps",
            messages,
            StreamTapsRequest,
            StreamTapsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from .....google import protobuf as ____google__protobuf__
from ....api.v2 import core as ___api__v2__core__
from ....api.v2 import route as ___api__v2__route__
from ....data.tap import v2alpha as ___data__tap__v2alpha__


class TapSinkServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Tap Sink Service]

    [#not-implemented-hide:] A tap service to receive incoming taps. Envoy will call
    StreamTaps to deliver captured taps to the server
    """

    async def stream_taps(
        self, messages: "AsyncIterator[StreamTapsRequest]"
    ) -> "StreamTapsResponse":
        """
        Envoy will connect and send StreamTapsRequest messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_taps(
        self, stream: "grpclib.server.Stream[StreamTapsRequest, StreamTapsResponse]"
    ) -> None:
        request = stream.__aiter__()
        response = await self.stream_taps(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.tap.v2alpha.TapSinkService/StreamTaps": grpclib.const.Handler(
                self.__rpc_stream_taps,
                grpclib.const.Cardinality.STREAM_UNARY,
                StreamTapsRequest,
                StreamTapsResponse,
            ),
        }
