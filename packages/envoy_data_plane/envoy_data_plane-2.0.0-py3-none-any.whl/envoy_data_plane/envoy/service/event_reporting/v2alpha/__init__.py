# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/event_reporting/v2alpha/event_reporting_service.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "EventReportingServiceAsyncStub",
    "EventReportingServiceBase",
    "EventReportingServiceSyncStub",
    "StreamEventsRequest",
    "StreamEventsRequestIdentifier",
    "StreamEventsResponse",
)

from collections.abc import AsyncIterable, AsyncIterator, Iterable, Iterator
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamEventsRequest(betterproto2.Message):
    """
    [#not-implemented-hide:]
    An events envoy sends to the management server.
    """

    identifier: "StreamEventsRequestIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Identifier data that will only be sent in the first message on the stream. This is effectively
    structured metadata and is a performance optimization.
    """

    events: "list[____google__protobuf__.Any]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Batch of events. When the stream is already active, it will be the events occurred
    since the last message had been sent. If the server receives unknown event type, it should
    silently ignore it.

    The following events are supported:

    * :ref:`HealthCheckEvent <envoy_api_msg_data.core.v2alpha.HealthCheckEvent>`
    * :ref:`OutlierDetectionEvent <envoy_api_msg_data.cluster.v2alpha.OutlierDetectionEvent>`
    """


default_message_pool.register_message(
    "envoy.service.event_reporting.v2alpha", "StreamEventsRequest", StreamEventsRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamEventsRequestIdentifier(betterproto2.Message):
    node: "___api__v2__core__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node sending the event messages over the stream.
    """


default_message_pool.register_message(
    "envoy.service.event_reporting.v2alpha",
    "StreamEventsRequest.Identifier",
    StreamEventsRequestIdentifier,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamEventsResponse(betterproto2.Message):
    """
    [#not-implemented-hide:]
    The management server may send envoy a StreamEventsResponse to tell which events the server
    is interested in. In future, with aggregated event reporting service, this message will
    contain, for example, clusters the envoy should send events for, or event types the server
    wants to process.
    """

    pass


default_message_pool.register_message(
    "envoy.service.event_reporting.v2alpha",
    "StreamEventsResponse",
    StreamEventsResponse,
)


class EventReportingServiceSyncStub:
    """
    [#protodoc-title: gRPC Event Reporting Service]

    [#not-implemented-hide:]
    Service for streaming different types of events from Envoy to a server. The examples of
    such events may be health check or outlier detection events.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_events(
        self, messages: "Iterable[StreamEventsRequest]"
    ) -> "Iterator[StreamEventsResponse]":
        """
        Envoy will connect and send StreamEventsRequest messages forever.
        The management server may send StreamEventsResponse to configure event stream. See below.
        This API is designed for high throughput with the expectation that it might be lossy.
        """

        yield from self._channel.stream_stream(
            "/envoy.service.event_reporting.v2alpha.EventReportingService/StreamEvents",
            StreamEventsRequest.SerializeToString,
            StreamEventsResponse.FromString,
        )(iter(messages))


class EventReportingServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: gRPC Event Reporting Service]

    [#not-implemented-hide:]
    Service for streaming different types of events from Envoy to a server. The examples of
    such events may be health check or outlier detection events.
    """

    async def stream_events(
        self,
        messages: "AsyncIterable[StreamEventsRequest] | Iterable[StreamEventsRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[StreamEventsResponse]":
        """
        Envoy will connect and send StreamEventsRequest messages forever.
        The management server may send StreamEventsResponse to configure event stream. See below.
        This API is designed for high throughput with the expectation that it might be lossy.
        """

        async for response in self._stream_stream(
            "/envoy.service.event_reporting.v2alpha.EventReportingService/StreamEvents",
            messages,
            StreamEventsRequest,
            StreamEventsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


from .....google import protobuf as ____google__protobuf__
from ....api.v2 import core as ___api__v2__core__


class EventReportingServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: gRPC Event Reporting Service]

    [#not-implemented-hide:]
    Service for streaming different types of events from Envoy to a server. The examples of
    such events may be health check or outlier detection events.
    """

    async def stream_events(
        self, messages: "AsyncIterator[StreamEventsRequest]"
    ) -> "AsyncIterator[StreamEventsResponse]":
        """
        Envoy will connect and send StreamEventsRequest messages forever.
        The management server may send StreamEventsResponse to configure event stream. See below.
        This API is designed for high throughput with the expectation that it might be lossy.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield StreamEventsResponse()

    async def __rpc_stream_events(
        self, stream: "grpclib.server.Stream[StreamEventsRequest, StreamEventsResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_events,
            stream,
            request,
        )

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.event_reporting.v2alpha.EventReportingService/StreamEvents": grpclib.const.Handler(
                self.__rpc_stream_events,
                grpclib.const.Cardinality.STREAM_STREAM,
                StreamEventsRequest,
                StreamEventsResponse,
            ),
        }
