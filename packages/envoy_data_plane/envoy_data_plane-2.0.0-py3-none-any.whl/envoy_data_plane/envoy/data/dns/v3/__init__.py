# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/data/dns/v3/dns_table.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "DnsTable",
    "DnsTableAddressList",
    "DnsTableDnsEndpoint",
    "DnsTableDnsService",
    "DnsTableDnsServiceList",
    "DnsTableDnsServiceProtocol",
    "DnsTableDnsServiceTarget",
    "DnsTableDnsVirtualDomain",
)

import datetime
import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsTable(betterproto2.Message):
    """
    [#protodoc-title: DNS Filter Table Data]
    :ref:`DNS Filter config overview <config_udp_listener_filters_dns_filter>`.

    This message contains the configuration for the DNS Filter if populated
    from the control plane
    """

    external_retry_count: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        1, betterproto2.TYPE_UINT32
    )
    """
    Control how many times Envoy makes an attempt to forward a query to an external DNS server
    """

    virtual_domains: "list[DnsTableDnsVirtualDomain]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Fully qualified domain names for which Envoy will respond to DNS queries. By leaving this
    list empty, Envoy will forward all queries to external resolvers
    """

    known_suffixes: "list[___type__matcher__v3__.StringMatcher]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    This field is deprecated and no longer used in Envoy. The filter's behavior has changed
    internally to use a different data structure allowing the filter to determine whether a
    query is for known domain without the use of this field.

    This field serves to help Envoy determine whether it can authoritatively answer a query
    for a name matching a suffix in this list. If the query name does not match a suffix in
    this list, Envoy will forward the query to an upstream DNS server
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("known_suffixes"):
            warnings.warn("DnsTable.known_suffixes is deprecated", DeprecationWarning)


default_message_pool.register_message("envoy.data.dns.v3", "DnsTable", DnsTable)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsTableAddressList(betterproto2.Message):
    """
    This message contains a list of IP addresses returned for a query for a known name
    """

    address: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        1, betterproto2.TYPE_STRING, repeated=True
    )
    """
    This field contains a well formed IP address that is returned in the answer for a
    name query. The address field can be an IPv4 or IPv6 address. Address family
    detection is done automatically when Envoy parses the string. Since this field is
    repeated, Envoy will return as many entries from this list in the DNS response while
    keeping the response under 512 bytes
    """


default_message_pool.register_message(
    "envoy.data.dns.v3", "DnsTable.AddressList", DnsTableAddressList
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsTableDnsEndpoint(betterproto2.Message):
    """


    Oneofs:
        - endpoint_config:
    """

    address_list: "DnsTableAddressList | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="endpoint_config"
    )
    """
    Define a list of addresses to return for the specified endpoint
    """

    cluster_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="endpoint_config"
    )
    """
    Define a cluster whose addresses are returned for the specified endpoint
    """

    service_list: "DnsTableDnsServiceList | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="endpoint_config"
    )
    """
    Define a DNS Service List for the specified endpoint
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.data.dns.v3", "DnsTable.DnsEndpoint", DnsTableDnsEndpoint
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsTableDnsService(betterproto2.Message):
    """
    This message defines a service selection record returned for a service query in a domain
    """

    service_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the service without the protocol or domain name
    """

    protocol: "DnsTableDnsServiceProtocol | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The service protocol. This can be specified as a string or the numeric value of the protocol
    """

    ttl: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The service entry time to live. This is independent from the DNS Answer record TTL
    """

    targets: "list[DnsTableDnsServiceTarget]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of targets hosting the service
    """


default_message_pool.register_message(
    "envoy.data.dns.v3", "DnsTable.DnsService", DnsTableDnsService
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsTableDnsServiceList(betterproto2.Message):
    """
    Define a list of service records for a given service
    """

    services: "list[DnsTableDnsService]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.data.dns.v3", "DnsTable.DnsServiceList", DnsTableDnsServiceList
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsTableDnsServiceProtocol(betterproto2.Message):
    """
    Specify the service protocol using a numeric or string value

    Oneofs:
        - protocol_config:
    """

    number: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)] | None" = (
        betterproto2.field(
            1, betterproto2.TYPE_UINT32, optional=True, group="protocol_config"
        )
    )
    """
    Specify the protocol number for the service. Envoy will try to resolve the number to
    the protocol name. For example, 6 will resolve to "tcp". Refer to:
    https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
    for protocol names and numbers
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="protocol_config"
    )
    """
    Specify the protocol name for the service.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.data.dns.v3", "DnsTable.DnsServiceProtocol", DnsTableDnsServiceProtocol
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsTableDnsServiceTarget(betterproto2.Message):
    """
    Specify the target for a given DNS service
    [#next-free-field: 6]

    Oneofs:
        - endpoint_type: Specify the name of the endpoint for the Service. The name is a hostname or a cluster
    """

    host_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="endpoint_type"
    )
    """
    Use a resolvable hostname as the endpoint for a service.
    """

    cluster_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="endpoint_type"
    )
    """
    Use a cluster name as the endpoint for a service.
    """

    priority: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )
    """
    The priority of the service record target
    """

    weight: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(4, betterproto2.TYPE_UINT32)
    )
    """
    The weight of the service record target
    """

    port: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(5, betterproto2.TYPE_UINT32)
    )
    """
    The port to which the service is bound. This value is optional if the target is a
    cluster. Setting port to zero in this case makes the filter use the port value
    from the cluster host
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.data.dns.v3", "DnsTable.DnsServiceTarget", DnsTableDnsServiceTarget
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DnsTableDnsVirtualDomain(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    A domain name for which Envoy will respond to query requests.
    Wildcard records are supported on the first label only, e.g. ``*.example.com`` or ``*.subdomain.example.com``.
    Names such as ``*example.com``, ``subdomain.*.example.com``, ``*subdomain.example.com``, etc
    are not valid wildcard names and asterisk will be interpreted as a literal ``*`` character.
    Wildcard records match subdomains on any levels, e.g. ``*.example.com`` will match
    ``foo.example.com``, ``bar.foo.example.com``, ``baz.bar.foo.example.com``, etc. In case there are multiple
    wildcard records, the longest wildcard match will be used, e.g. if there are wildcard records for
    ``*.example.com`` and ``*.foo.example.com`` and the query is for ``bar.foo.example.com``, the latter will be used.
    Specific records will always take precedence over wildcard records.
    """

    endpoint: "DnsTableDnsEndpoint | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The configuration containing the method to determine the address of this endpoint
    """

    answer_ttl: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    Sets the TTL in DNS answers from Envoy returned to the client. The default TTL is 300s
    """


default_message_pool.register_message(
    "envoy.data.dns.v3", "DnsTable.DnsVirtualDomain", DnsTableDnsVirtualDomain
)


from .....google import protobuf as ____google__protobuf__
from ....type.matcher import v3 as ___type__matcher__v3__
