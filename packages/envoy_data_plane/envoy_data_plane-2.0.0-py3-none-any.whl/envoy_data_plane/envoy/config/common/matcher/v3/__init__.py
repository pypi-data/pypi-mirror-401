# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/common/matcher/v3/matcher.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "HttpGenericBodyMatch",
    "HttpGenericBodyMatchGenericTextMatch",
    "HttpHeadersMatch",
    "MatchPredicate",
    "MatchPredicateMatchSet",
    "Matcher",
    "MatcherMatcherList",
    "MatcherMatcherListFieldMatcher",
    "MatcherMatcherListPredicate",
    "MatcherMatcherListPredicatePredicateList",
    "MatcherMatcherListPredicateSinglePredicate",
    "MatcherMatcherTree",
    "MatcherMatcherTreeMatchMap",
    "MatcherOnMatch",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from ......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpGenericBodyMatch(betterproto2.Message):
    """
    HTTP generic body match configuration.
    List of text strings and hex strings to be located in HTTP body.
    All specified strings must be found in the HTTP body for positive match.
    The search may be limited to specified number of bytes from the body start.

    .. attention::

      Searching for patterns in HTTP body is potentially CPU-intensive. For each specified pattern, HTTP body is scanned byte by byte to find a match.
      If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
      to scan only part of the HTTP body.
    """

    bytes_limit: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
    """

    patterns: "list[HttpGenericBodyMatchGenericTextMatch]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of patterns to match.
    """


default_message_pool.register_message(
    "envoy.config.common.matcher.v3", "HttpGenericBodyMatch", HttpGenericBodyMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpGenericBodyMatchGenericTextMatch(betterproto2.Message):
    """


    Oneofs:
        - rule:
    """

    string_match: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="rule"
    )
    """
    Text string to be located in HTTP body.
    """

    binary_match: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True, group="rule"
    )
    """
    Sequence of bytes to be located in HTTP body.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.common.matcher.v3",
    "HttpGenericBodyMatch.GenericTextMatch",
    HttpGenericBodyMatchGenericTextMatch,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpHeadersMatch(betterproto2.Message):
    """
    HTTP headers match configuration.
    """

    headers: "list[___route__v3__.HeaderMatcher]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    HTTP headers to match.
    """


default_message_pool.register_message(
    "envoy.config.common.matcher.v3", "HttpHeadersMatch", HttpHeadersMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Matcher(betterproto2.Message):
    """
    [#protodoc-title: Unified Matcher API]

    A matcher, which may traverse a matching tree in order to result in a match action.
    During matching, the tree will be traversed until a match is found, or if no match
    is found the action specified by the most specific on_no_match will be evaluated.
    As an on_no_match might result in another matching tree being evaluated, this process
    might repeat several times until the final OnMatch (or no match) is decided.

    .. note::
      Please use the syntactically equivalent :ref:`matching API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`

    Oneofs:
        - matcher_type:
    """

    matcher_list: "MatcherMatcherList | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="matcher_type"
    )
    """
    A linear list of matchers to evaluate.
    """

    matcher_tree: "MatcherMatcherTree | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="matcher_type"
    )
    """
    A match tree to evaluate.
    """

    on_no_match: "MatcherOnMatch | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional ``OnMatch`` to use if the matcher failed.
    If specified, the ``OnMatch`` is used, and the matcher is considered
    to have matched.
    If not specified, the matcher is considered not to have matched.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.common.matcher.v3", "Matcher", Matcher
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherList(betterproto2.Message):
    """
    A linear list of field matchers.
    The field matchers are evaluated in order, and the first match
    wins.
    """

    matchers: "list[MatcherMatcherListFieldMatcher]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of matchers. First match wins.
    """


default_message_pool.register_message(
    "envoy.config.common.matcher.v3", "Matcher.MatcherList", MatcherMatcherList
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherListFieldMatcher(betterproto2.Message):
    """
    An individual matcher.
    """

    predicate: "MatcherMatcherListPredicate | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Determines if the match succeeds.
    """

    on_match: "MatcherOnMatch | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    What to do if the match succeeds.
    """


default_message_pool.register_message(
    "envoy.config.common.matcher.v3",
    "Matcher.MatcherList.FieldMatcher",
    MatcherMatcherListFieldMatcher,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherListPredicate(betterproto2.Message):
    """
    Predicate to determine if a match is successful.

    Oneofs:
        - match_type:
    """

    single_predicate: "MatcherMatcherListPredicateSinglePredicate | None" = (
        betterproto2.field(
            1, betterproto2.TYPE_MESSAGE, optional=True, group="match_type"
        )
    )
    """
    A single predicate to evaluate.
    """

    or_matcher: "MatcherMatcherListPredicatePredicateList | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="match_type"
    )
    """
    A list of predicates to be OR-ed together.
    """

    and_matcher: "MatcherMatcherListPredicatePredicateList | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="match_type"
    )
    """
    A list of predicates to be AND-ed together.
    """

    not_matcher: "MatcherMatcherListPredicate | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="match_type"
    )
    """
    The inverse of a predicate
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.common.matcher.v3",
    "Matcher.MatcherList.Predicate",
    MatcherMatcherListPredicate,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherListPredicatePredicateList(betterproto2.Message):
    """
    A list of two or more matchers. Used to allow using a list within a oneof.
    """

    predicate: "list[MatcherMatcherListPredicate]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.common.matcher.v3",
    "Matcher.MatcherList.Predicate.PredicateList",
    MatcherMatcherListPredicatePredicateList,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherListPredicateSinglePredicate(betterproto2.Message):
    """
    Predicate for a single input field.

    Oneofs:
        - matcher:
    """

    input: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Protocol-specific specification of input field to match on.
    [#extension-category: envoy.matching.common_inputs]
    """

    value_match: "____type__matcher__v3__.StringMatcher | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="matcher"
    )
    """
    Built-in string matcher.
    """

    custom_match: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="matcher"
    )
    """
    Extension for custom matching logic.
    [#extension-category: envoy.matching.input_matchers]
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.common.matcher.v3",
    "Matcher.MatcherList.Predicate.SinglePredicate",
    MatcherMatcherListPredicateSinglePredicate,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherTree(betterproto2.Message):
    """


    Oneofs:
        - tree_type: Exact or prefix match maps in which to look up the input value.
            If the lookup succeeds, the match is considered successful, and
            the corresponding OnMatch is used.
    """

    input: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Protocol-specific specification of input field to match on.
    """

    exact_match_map: "MatcherMatcherTreeMatchMap | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="tree_type"
    )

    prefix_match_map: "MatcherMatcherTreeMatchMap | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="tree_type"
    )
    """
    Longest matching prefix wins.
    """

    custom_match: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="tree_type"
    )
    """
    Extension for custom matching logic.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.common.matcher.v3", "Matcher.MatcherTree", MatcherMatcherTree
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherMatcherTreeMatchMap(betterproto2.Message):
    """
    A map of configured matchers. Used to allow using a map within a oneof.
    """

    map: "dict[str, MatcherOnMatch]" = betterproto2.field(
        1,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )


default_message_pool.register_message(
    "envoy.config.common.matcher.v3",
    "Matcher.MatcherTree.MatchMap",
    MatcherMatcherTreeMatchMap,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatcherOnMatch(betterproto2.Message):
    """
    What to do if a match is successful.

    Oneofs:
        - on_match:
    """

    matcher: "Matcher | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="on_match"
    )
    """
    Nested matcher to evaluate.
    If the nested matcher does not match and does not specify
    on_no_match, then this matcher is considered not to have
    matched, even if a predicate at this level or above returned
    true.
    """

    action: "___core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="on_match"
    )
    """
    Protocol-specific action to take.
    """

    keep_matching: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    If true, the action will be taken but the caller will behave as if no
    match was found. This applies both to actions directly encoded in the
    action field and to actions returned from a nested matcher tree in the
    matcher field. A subsequent matcher on_no_match action will be used
    instead.

    This field is not supported in all contexts in which the matcher API is
    used. If this field is set in a context in which it's not supported,
    the resource will be rejected.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.common.matcher.v3", "Matcher.OnMatch", MatcherOnMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatchPredicate(betterproto2.Message):
    """
    Match configuration. This is a recursive structure which allows complex nested match
    configurations to be built using various logical operators.
    [#next-free-field: 11]

    Oneofs:
        - rule:
    """

    or_match: "MatchPredicateMatchSet | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set that describes a logical OR. If any member of the set matches, the match configuration
    matches.
    """

    and_match: "MatchPredicateMatchSet | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set that describes a logical AND. If all members of the set match, the match configuration
    matches.
    """

    not_match: "MatchPredicate | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A negation match. The match configuration will match if the negated match condition matches.
    """

    any_match: "bool | None" = betterproto2.field(
        4, betterproto2.TYPE_BOOL, optional=True, group="rule"
    )
    """
    The match configuration will always match.
    """

    http_request_headers_match: "HttpHeadersMatch | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP request headers match configuration.
    """

    http_request_trailers_match: "HttpHeadersMatch | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP request trailers match configuration.
    """

    http_response_headers_match: "HttpHeadersMatch | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP response headers match configuration.
    """

    http_response_trailers_match: "HttpHeadersMatch | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP response trailers match configuration.
    """

    http_request_generic_body_match: "HttpGenericBodyMatch | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP request generic body match configuration.
    """

    http_response_generic_body_match: "HttpGenericBodyMatch | None" = (
        betterproto2.field(10, betterproto2.TYPE_MESSAGE, optional=True, group="rule")
    )
    """
    HTTP response generic body match configuration.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.common.matcher.v3", "MatchPredicate", MatchPredicate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatchPredicateMatchSet(betterproto2.Message):
    """
    A set of match configurations used for logical operations.
    """

    rules: "list[MatchPredicate]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of rules that make up the set.
    """


default_message_pool.register_message(
    "envoy.config.common.matcher.v3", "MatchPredicate.MatchSet", MatchPredicateMatchSet
)


from .....type.matcher import v3 as ____type__matcher__v3__
from ....core import v3 as ___core__v3__
from ....route import v3 as ___route__v3__
