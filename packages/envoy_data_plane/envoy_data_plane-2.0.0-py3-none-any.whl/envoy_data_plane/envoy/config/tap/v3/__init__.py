# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/tap/v3/common.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "BufferedAdminSink",
    "FilePerTapSink",
    "HttpGenericBodyMatch",
    "HttpGenericBodyMatchGenericTextMatch",
    "HttpHeadersMatch",
    "MatchPredicate",
    "MatchPredicateMatchSet",
    "OutputConfig",
    "OutputSink",
    "OutputSinkFormat",
    "StreamingAdminSink",
    "StreamingGrpcSink",
    "TapConfig",
)

import datetime
import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class OutputSinkFormat(betterproto2.Enum):
    """
    Output format. All output is in the form of one or more :ref:`TraceWrapper
    <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. This enumeration indicates
    how those messages are written. Note that not all sinks support all output formats. See
    individual sink documentation for more information.
    """

    JSON_BODY_AS_BYTES = 0
    """
    Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
    data will be present in the :ref:`as_bytes
    <envoy_v3_api_field_data.tap.v3.Body.as_bytes>` field. This means that body data will be
    base64 encoded as per the `proto3 JSON mappings
    <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
    """

    JSON_BODY_AS_STRING = 1
    """
    Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
    data will be present in the :ref:`as_string
    <envoy_v3_api_field_data.tap.v3.Body.as_string>` field. This means that body data will be
    string encoded as per the `proto3 JSON mappings
    <https://developers.google.com/protocol-buffers/docs/proto3#json>`_. This format type is
    useful when it is known that that body is human readable (e.g., JSON over HTTP) and the
    user wishes to view it directly without being forced to base64 decode the body.
    """

    PROTO_BINARY = 2
    """
    Binary proto format. Note that binary proto is not self-delimiting. If a sink writes
    multiple binary messages without any length information the data stream will not be
    useful. However, for certain sinks that are self-delimiting (e.g., one message per file)
    this output format makes consumption simpler.
    """

    PROTO_BINARY_LENGTH_DELIMITED = 3
    """
    Messages are written as a sequence tuples, where each tuple is the message length encoded
    as a `protobuf 32-bit varint
    <https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream>`_
    followed by the binary message. The messages can be read back using the language specific
    protobuf coded stream implementation to obtain the message length and the message.
    """

    PROTO_TEXT = 4
    """
    Text proto format.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BufferedAdminSink(betterproto2.Message):
    """
    BufferedAdminSink configures a tap output to collect traces without returning them until
    one of multiple criteria are satisfied.
    Similar to StreamingAdminSink, it is only allowed to specify the buffered admin output
    sink if the tap is being configured from the ``/tap`` admin endpoint.
    """

    max_traces: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )
    """
    Stop collecting traces when the specified number are collected.
    If other criteria for ending collection are reached first, this value will not be used.
    """

    timeout: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    Acts as a fallback to prevent the client from waiting for long periods of time.
    After timeout has occurred, a buffer flush will be triggered, returning the traces buffered so far.
    This may result in returning fewer traces than were requested, and in the case that no traces are
    buffered during this time, no traces will be returned.
    Specifying 0 for the timeout value (or not specifying a value at all) indicates an infinite timeout.
    """


default_message_pool.register_message(
    "envoy.config.tap.v3", "BufferedAdminSink", BufferedAdminSink
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class FilePerTapSink(betterproto2.Message):
    """
    The file per tap sink outputs a discrete file for every tapped stream.
    """

    path_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Path prefix. The output file will be of the form <path_prefix>_<id>.pb, where <id> is an
    identifier distinguishing the recorded trace for stream instances (the Envoy
    connection ID, HTTP stream ID, etc.).
    """


default_message_pool.register_message(
    "envoy.config.tap.v3", "FilePerTapSink", FilePerTapSink
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpGenericBodyMatch(betterproto2.Message):
    """
    HTTP generic body match configuration.
    List of text strings and hex strings to be located in HTTP body.
    All specified strings must be found in the HTTP body for positive match.
    The search may be limited to specified number of bytes from the body start.

    .. attention::

      Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
      If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
      to scan only part of the http body.
    """

    bytes_limit: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
    """

    patterns: "list[HttpGenericBodyMatchGenericTextMatch]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of patterns to match.
    """


default_message_pool.register_message(
    "envoy.config.tap.v3", "HttpGenericBodyMatch", HttpGenericBodyMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpGenericBodyMatchGenericTextMatch(betterproto2.Message):
    """


    Oneofs:
        - rule:
    """

    string_match: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="rule"
    )
    """
    Text string to be located in HTTP body.
    """

    binary_match: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True, group="rule"
    )
    """
    Sequence of bytes to be located in HTTP body.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.tap.v3",
    "HttpGenericBodyMatch.GenericTextMatch",
    HttpGenericBodyMatchGenericTextMatch,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpHeadersMatch(betterproto2.Message):
    """
    HTTP headers match configuration.
    """

    headers: "list[__route__v3__.HeaderMatcher]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    HTTP headers to match.
    """


default_message_pool.register_message(
    "envoy.config.tap.v3", "HttpHeadersMatch", HttpHeadersMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatchPredicate(betterproto2.Message):
    """
    Tap match configuration. This is a recursive structure which allows complex nested match
    configurations to be built using various logical operators.
    [#next-free-field: 11]

    Oneofs:
        - rule:
    """

    or_match: "MatchPredicateMatchSet | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set that describes a logical OR. If any member of the set matches, the match configuration
    matches.
    """

    and_match: "MatchPredicateMatchSet | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set that describes a logical AND. If all members of the set match, the match configuration
    matches.
    """

    not_match: "MatchPredicate | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A negation match. The match configuration will match if the negated match condition matches.
    """

    any_match: "bool | None" = betterproto2.field(
        4, betterproto2.TYPE_BOOL, optional=True, group="rule"
    )
    """
    The match configuration will always match.
    """

    http_request_headers_match: "HttpHeadersMatch | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP request headers match configuration.
    """

    http_request_trailers_match: "HttpHeadersMatch | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP request trailers match configuration.
    """

    http_response_headers_match: "HttpHeadersMatch | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP response headers match configuration.
    """

    http_response_trailers_match: "HttpHeadersMatch | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP response trailers match configuration.
    """

    http_request_generic_body_match: "HttpGenericBodyMatch | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    HTTP request generic body match configuration.
    """

    http_response_generic_body_match: "HttpGenericBodyMatch | None" = (
        betterproto2.field(10, betterproto2.TYPE_MESSAGE, optional=True, group="rule")
    )
    """
    HTTP response generic body match configuration.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.tap.v3", "MatchPredicate", MatchPredicate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MatchPredicateMatchSet(betterproto2.Message):
    """
    A set of match configurations used for logical operations.
    """

    rules: "list[MatchPredicate]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of rules that make up the set.
    """


default_message_pool.register_message(
    "envoy.config.tap.v3", "MatchPredicate.MatchSet", MatchPredicateMatchSet
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class OutputConfig(betterproto2.Message):
    """
    Tap output configuration.
    [#next-free-field: 6]
    """

    sinks: "list[OutputSink]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Output sinks for tap data. Currently a single sink is allowed in the list. Once multiple
    sink types are supported this constraint will be relaxed.
    """

    max_buffered_rx_bytes: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    For buffered tapping, the maximum amount of received body that will be buffered prior to
    truncation. If truncation occurs, the :ref:`truncated
    <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
    default is 1KiB.
    """

    max_buffered_tx_bytes: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    For buffered tapping, the maximum amount of transmitted body that will be buffered prior to
    truncation. If truncation occurs, the :ref:`truncated
    <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
    default is 1KiB.
    """

    streaming: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Indicates whether taps produce a single buffered message per tap, or multiple streamed
    messages per tap in the emitted :ref:`TraceWrapper
    <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. Note that streamed tapping does not
    mean that no buffering takes place. Buffering may be required if data is processed before a
    match can be determined. See the HTTP tap filter :ref:`streaming
    <config_http_filters_tap_streaming>` documentation for more information.
    """

    min_streamed_sent_bytes: "int | None" = betterproto2.field(
        5,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Tapped messages will be sent on each read/write event for streamed tapping by default.
    But this behavior could be controlled by setting this field.
    If set then the tapped messages will be send once the threshold is reached.
    This could be used to avoid high frequent sending.
    """


default_message_pool.register_message(
    "envoy.config.tap.v3", "OutputConfig", OutputConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class OutputSink(betterproto2.Message):
    """
    Tap output sink configuration.
    [#next-free-field: 7]

    Oneofs:
        - output_sink_type:
    """

    format: "OutputSinkFormat" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: OutputSinkFormat(0)
    )
    """
    Sink output format.
    """

    streaming_admin: "StreamingAdminSink | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="output_sink_type"
    )
    """
    Tap output will be streamed out the :http:post:`/tap` admin endpoint.

    .. attention::

      It is only allowed to specify the streaming admin output sink if the tap is being
      configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
      been configured to receive tap configuration from some other source (e.g., static
      file, XDS, etc.) configuring the streaming admin output type will fail.
    """

    file_per_tap: "FilePerTapSink | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="output_sink_type"
    )
    """
    Tap output will be written to a file per tap sink.
    """

    streaming_grpc: "StreamingGrpcSink | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="output_sink_type"
    )
    """
    [#not-implemented-hide:]
    GrpcService to stream data to. The format argument must be PROTO_BINARY.
    [#comment: TODO(samflattery): remove cleanup in uber_per_filter.cc once implemented]
    """

    buffered_admin: "BufferedAdminSink | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="output_sink_type"
    )
    """
    Tap output will be buffered in a single block before flushing to the :http:post:`/tap` admin endpoint

    .. attention::

      It is only allowed to specify the buffered admin output sink if the tap is being
      configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
      been configured to receive tap configuration from some other source (e.g., static
      file, XDS, etc.) configuring the buffered admin output type will fail.
    """

    custom_sink: "__core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="output_sink_type"
    )
    """
    Tap output filter will be defined by an extension type
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.tap.v3", "OutputSink", OutputSink)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamingAdminSink(betterproto2.Message):
    """
    Streaming admin sink configuration.
    """

    pass


default_message_pool.register_message(
    "envoy.config.tap.v3", "StreamingAdminSink", StreamingAdminSink
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamingGrpcSink(betterproto2.Message):
    """
    [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
    server.
    """

    tap_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Opaque identifier, that will be sent back to the streaming grpc server.
    """

    grpc_service: "__core__v3__.GrpcService | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The gRPC server that hosts the Tap Sink Service.
    """


default_message_pool.register_message(
    "envoy.config.tap.v3", "StreamingGrpcSink", StreamingGrpcSink
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TapConfig(betterproto2.Message):
    """
    [#protodoc-title: Tap common configuration]

    Tap configuration.

    [#comment:TODO(mattklein123): Rate limiting]
    """

    match_config: "MatchPredicate | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The match configuration. If the configuration matches the data source being tapped, a tap will
    occur, with the result written to the configured output.
    Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
    :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
    are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
    """

    match: "__common__matcher__v3__.MatchPredicate | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The match configuration. If the configuration matches the data source being tapped, a tap will
    occur, with the result written to the configured output.
    Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
    :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
    are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
    """

    output_config: "OutputConfig | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The tap output configuration. If a match configuration matches a data source being tapped,
    a tap will occur and the data will be written to the configured output.
    """

    tap_enabled: "__core__v3__.RuntimeFractionalPercent | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:] Specify if Tap matching is enabled. The % of requests\\connections for
    which the tap matching is enabled. When not enabled, the request\\connection will not be
    recorded.

    .. note::

      This field defaults to 100/:ref:`HUNDRED
      <envoy_v3_api_enum_type.v3.FractionalPercent.DenominatorType>`.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("match_config"):
            warnings.warn("TapConfig.match_config is deprecated", DeprecationWarning)


default_message_pool.register_message("envoy.config.tap.v3", "TapConfig", TapConfig)


from .....google import protobuf as ____google__protobuf__
from ...common.matcher import v3 as __common__matcher__v3__
from ...core import v3 as __core__v3__
from ...route import v3 as __route__v3__
