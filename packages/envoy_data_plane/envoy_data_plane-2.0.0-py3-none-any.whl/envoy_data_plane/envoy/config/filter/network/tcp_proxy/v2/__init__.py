# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/filter/network/tcp_proxy/v2/tcp_proxy.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "TcpProxy",
    "TcpProxyDeprecatedV1",
    "TcpProxyDeprecatedV1TcpRoute",
    "TcpProxyTunnelingConfig",
    "TcpProxyWeightedCluster",
    "TcpProxyWeightedClusterClusterWeight",
)

import datetime
import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxy(betterproto2.Message):
    """
    [#protodoc-title: TCP Proxy]
    TCP Proxy :ref:`configuration overview <config_network_filters_tcp_proxy>`.
    [#extension: envoy.filters.network.tcp_proxy]

    [#next-free-field: 13]

    Oneofs:
        - cluster_specifier:
    """

    stat_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The prefix to use when emitting :ref:`statistics
    <config_network_filters_tcp_proxy_stats>`.
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="cluster_specifier"
    )
    """
    The upstream cluster to connect to.
    """

    weighted_clusters: "TcpProxyWeightedCluster | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="cluster_specifier"
    )
    """
    Multiple upstream clusters can be specified for a given route. The
    request is routed to one of the upstream clusters based on weights
    assigned to each cluster.
    """

    metadata_match: "_____api__v2__core__.Metadata | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional endpoint metadata match criteria. Only endpoints in the upstream
    cluster with metadata matching that set in metadata_match will be
    considered. The filter name should be specified as *envoy.lb*.
    """

    idle_timeout: "datetime.timedelta | None" = betterproto2.field(
        8,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    The idle timeout for connections managed by the TCP proxy filter. The idle timeout
    is defined as the period in which there are no bytes sent or received on either
    the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
    to 0s, the timeout will be disabled.

    .. warning::
      Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
      FIN packets, etc.
    """

    downstream_idle_timeout: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
    filter. The idle timeout is defined as the period in which there is no
    active traffic. If not set, there is no idle timeout. When the idle timeout
    is reached the connection will be closed. The distinction between
    downstream_idle_timeout/upstream_idle_timeout provides a means to set
    timeout based on the last byte sent on the downstream/upstream connection.
    """

    upstream_idle_timeout: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.Duration,
        optional=True,
    )
    """
    [#not-implemented-hide:]
    """

    access_log: "list[___accesslog__v2__.AccessLog]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Configuration for :ref:`access logs <arch_overview_access_logs>`
    emitted by the this tcp_proxy.
    """

    deprecated_v1: "TcpProxyDeprecatedV1 | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:] Deprecated.
    """

    max_connect_attempts: "int | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The maximum number of unsuccessful connection attempts that will be made before
    giving up. If the parameter is not specified, 1 connection attempt will be made.
    """

    hash_policy: "list[_____type__.HashPolicy]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
    load balancing algorithms will select a host randomly. Currently the number of hash policies is
    limited to 1.
    """

    tunneling_config: "TcpProxyTunnelingConfig | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:] feature in progress
    If set, this configures tunneling, e.g. configuration options to tunnel multiple TCP
    payloads over a shared HTTP/2 tunnel. If this message is absent, the payload
    will be proxied upstream as per usual.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("deprecated_v1"):
            warnings.warn("TcpProxy.deprecated_v1 is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.filter.network.tcp_proxy.v2", "TcpProxy", TcpProxy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyDeprecatedV1(betterproto2.Message):
    """
    [#not-implemented-hide:] Deprecated.
    TCP Proxy filter configuration using V1 format.
    """

    routes: "list[TcpProxyDeprecatedV1TcpRoute]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The route table for the filter. All filter instances must have a route
    table, even if it is empty.
    """

    def __post_init__(self) -> None:
        warnings.warn("TcpProxyDeprecatedV1 is deprecated", DeprecationWarning)
        super().__post_init__()


default_message_pool.register_message(
    "envoy.config.filter.network.tcp_proxy.v2",
    "TcpProxy.DeprecatedV1",
    TcpProxyDeprecatedV1,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyDeprecatedV1TcpRoute(betterproto2.Message):
    """
    A TCP proxy route consists of a set of optional L4 criteria and the
    name of a cluster. If a downstream connection matches all the
    specified criteria, the cluster in the route is used for the
    corresponding upstream connection. Routes are tried in the order
    specified until a match is found. If no match is found, the connection
    is closed. A route with no criteria is valid and always produces a
    match.
    [#next-free-field: 6]
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The cluster to connect to when a the downstream network connection
    matches the specified criteria.
    """

    destination_ip_list: "list[_____api__v2__core__.CidrRange]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    An optional list of IP address subnets in the form
    “ip_address/xx”. The criteria is satisfied if the destination IP
    address of the downstream connection is contained in at least one of
    the specified subnets. If the parameter is not specified or the list
    is empty, the destination IP address is ignored. The destination IP
    address of the downstream connection might be different from the
    addresses on which the proxy is listening if the connection has been
    redirected.
    """

    destination_ports: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    An optional string containing a comma-separated list of port numbers
    or ranges. The criteria is satisfied if the destination port of the
    downstream connection is contained in at least one of the specified
    ranges. If the parameter is not specified, the destination port is
    ignored. The destination port address of the downstream connection
    might be different from the port on which the proxy is listening if
    the connection has been redirected.
    """

    source_ip_list: "list[_____api__v2__core__.CidrRange]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    An optional list of IP address subnets in the form
    “ip_address/xx”. The criteria is satisfied if the source IP address
    of the downstream connection is contained in at least one of the
    specified subnets. If the parameter is not specified or the list is
    empty, the source IP address is ignored.
    """

    source_ports: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    An optional string containing a comma-separated list of port numbers
    or ranges. The criteria is satisfied if the source port of the
    downstream connection is contained in at least one of the specified
    ranges. If the parameter is not specified, the source port is
    ignored.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.tcp_proxy.v2",
    "TcpProxy.DeprecatedV1.TCPRoute",
    TcpProxyDeprecatedV1TcpRoute,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyTunnelingConfig(betterproto2.Message):
    """
    Configuration for tunneling TCP over other transports or application layers.
    Currently, only HTTP/2 is supported. When other options exist, HTTP/2 will
    remain the default.
    """

    hostname: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The hostname to send in the synthesized CONNECT headers to the upstream proxy.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.tcp_proxy.v2",
    "TcpProxy.TunnelingConfig",
    TcpProxyTunnelingConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyWeightedCluster(betterproto2.Message):
    """
    Allows for specification of multiple upstream clusters along with weights
    that indicate the percentage of traffic to be forwarded to each cluster.
    The router selects an upstream cluster based on these weights.
    """

    clusters: "list[TcpProxyWeightedClusterClusterWeight]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies one or more upstream clusters associated with the route.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.tcp_proxy.v2",
    "TcpProxy.WeightedCluster",
    TcpProxyWeightedCluster,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TcpProxyWeightedClusterClusterWeight(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Name of the upstream cluster.
    """

    weight: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )
    """
    When a request matches the route, the choice of an upstream cluster is
    determined by its weight. The sum of weights across all entries in the
    clusters array determines the total weight.
    """

    metadata_match: "_____api__v2__core__.Metadata | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
    in the upstream cluster with metadata matching what is set in this field will be considered
    for load balancing. Note that this will be merged with what's provided in
    :ref:`TcpProxy.metadata_match
    <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.metadata_match>`, with values
    here taking precedence. The filter name should be specified as *envoy.lb*.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.tcp_proxy.v2",
    "TcpProxy.WeightedCluster.ClusterWeight",
    TcpProxyWeightedClusterClusterWeight,
)


from .......google import protobuf as ______google__protobuf__
from ...... import type as _____type__
from ......api.v2 import core as _____api__v2__core__
from ....accesslog import v2 as ___accesslog__v2__
