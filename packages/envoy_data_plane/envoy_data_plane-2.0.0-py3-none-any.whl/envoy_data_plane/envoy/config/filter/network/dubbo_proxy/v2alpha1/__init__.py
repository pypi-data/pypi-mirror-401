# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/filter/network/dubbo_proxy/v2alpha1/dubbo_proxy.proto, envoy/config/filter/network/dubbo_proxy/v2alpha1/route.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "DubboFilter",
    "DubboProxy",
    "MethodMatch",
    "MethodMatchParameterMatchSpecifier",
    "ProtocolType",
    "Route",
    "RouteAction",
    "RouteConfiguration",
    "RouteMatch",
    "SerializationType",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ProtocolType(betterproto2.Enum):
    """
    [#protodoc-title: Dubbo Proxy]
    Dubbo Proxy :ref:`configuration overview <config_network_filters_dubbo_proxy>`.
    [#extension: envoy.filters.network.dubbo_proxy]

    Dubbo Protocol types supported by Envoy.
    """

    Dubbo = 0
    """
    the default protocol.
    """


class SerializationType(betterproto2.Enum):
    """
    Dubbo Serialization types supported by Envoy.
    """

    Hessian2 = 0
    """
    the default serialization protocol.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DubboFilter(betterproto2.Message):
    """
    DubboFilter configures a Dubbo filter.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the filter to instantiate. The name must match a supported
    filter.
    """

    config: "______google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Filter specific configuration which depends on the filter being
    instantiated. See the supported filters for further documentation.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.dubbo_proxy.v2alpha1", "DubboFilter", DubboFilter
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DubboProxy(betterproto2.Message):
    """
    [#next-free-field: 6]
    """

    stat_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The human readable prefix to use when emitting statistics.
    """

    protocol_type: "ProtocolType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: ProtocolType(0)
    )
    """
    Configure the protocol used.
    """

    serialization_type: "SerializationType" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: SerializationType(0)
    )
    """
    Configure the serialization protocol used.
    """

    route_config: "list[RouteConfiguration]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The route table for the connection manager is static and is specified in this property.
    """

    dubbo_filters: "list[DubboFilter]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of individual Dubbo filters that make up the filter chain for requests made to the
    Dubbo proxy. Order matters as the filters are processed sequentially. For backwards
    compatibility, if no dubbo_filters are specified, a default Dubbo router filter
    (`envoy.filters.dubbo.router`) is used.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.dubbo_proxy.v2alpha1", "DubboProxy", DubboProxy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MethodMatch(betterproto2.Message):
    name: "_____type__matcher__.StringMatcher | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The name of the method.
    """

    params_match: "dict[int, MethodMatchParameterMatchSpecifier]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_UINT32, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Method parameter definition.
    The key is the parameter index, starting from 0.
    The value is the parameter matching type.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.dubbo_proxy.v2alpha1", "MethodMatch", MethodMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MethodMatchParameterMatchSpecifier(betterproto2.Message):
    """
    The parameter matching type.

    Oneofs:
        - parameter_match_specifier:
    """

    exact_match: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True, group="parameter_match_specifier"
    )
    """
    If specified, header match will be performed based on the value of the header.
    """

    range_match: "_____type__.Int64Range | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="parameter_match_specifier"
    )
    """
    If specified, header match will be performed based on range.
    The rule will match if the request header value is within this range.
    The entire request header value must represent an integer in base 10 notation: consisting
    of an optional plus or minus sign followed by a sequence of digits. The rule will not match
    if the header value does not represent an integer. Match will fail for empty values,
    floating point numbers or if only a subsequence of the header value is an integer.

    Examples:

    * For range [-10,0), route will match for header value -1, but not for 0,
      "somestring", 10.9, "-1somestring"
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.filter.network.dubbo_proxy.v2alpha1",
    "MethodMatch.ParameterMatchSpecifier",
    MethodMatchParameterMatchSpecifier,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Route(betterproto2.Message):
    match: "RouteMatch | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Route matching parameters.
    """

    route: "RouteAction | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Route request to some upstream cluster.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.dubbo_proxy.v2alpha1", "Route", Route
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RouteAction(betterproto2.Message):
    """


    Oneofs:
        - cluster_specifier:
    """

    cluster: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="cluster_specifier"
    )
    """
    Indicates the upstream cluster to which the request should be routed.
    """

    weighted_clusters: "_____api__v2__route__.WeightedCluster | None" = (
        betterproto2.field(
            2, betterproto2.TYPE_MESSAGE, optional=True, group="cluster_specifier"
        )
    )
    """
    Multiple upstream clusters can be specified for a given route. The
    request is routed to one of the upstream clusters based on weights
    assigned to each cluster.
    Currently ClusterWeight only supports the name and weight fields.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.filter.network.dubbo_proxy.v2alpha1", "RouteAction", RouteAction
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RouteConfiguration(betterproto2.Message):
    """
    [#protodoc-title: Dubbo Proxy Route Configuration]
    Dubbo Proxy :ref:`configuration overview <config_network_filters_dubbo_proxy>`.

    [#next-free-field: 6]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the route configuration. Reserved for future use in asynchronous route discovery.
    """

    interface: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The interface name of the service.
    """

    group: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    Which group does the interface belong to.
    """

    version: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    The version number of the interface.
    """

    routes: "list[Route]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of routes that will be matched, in order, against incoming requests. The first route
    that matches will be used.
    """


default_message_pool.register_message(
    "envoy.config.filter.network.dubbo_proxy.v2alpha1",
    "RouteConfiguration",
    RouteConfiguration,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RouteMatch(betterproto2.Message):
    method: "MethodMatch | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Method level routing matching.
    """

    headers: "list[_____api__v2__route__.HeaderMatcher]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a set of headers that the route should match on. The router will check the requestâ€™s
    headers against all the specified headers in the route config. A match will happen if all the
    headers in the route are present in the request with the same values (or based on presence if
    the value field is not in the config).
    """


default_message_pool.register_message(
    "envoy.config.filter.network.dubbo_proxy.v2alpha1", "RouteMatch", RouteMatch
)


from .......google import protobuf as ______google__protobuf__
from ...... import type as _____type__
from ......api.v2 import route as _____api__v2__route__
from ......type import matcher as _____type__matcher__
