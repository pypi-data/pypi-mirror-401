# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/rbac/v2/rbac.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Permission",
    "PermissionSet",
    "Policy",
    "Principal",
    "PrincipalAuthenticated",
    "PrincipalSet",
    "Rbac",
    "RbacAction",
)

import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class RbacAction(betterproto2.Enum):
    """
    Should we do safe-list or block-list style access control?
    """

    ALLOW = 0
    """
    The policies grant access to principals. The rest is denied. This is safe-list style
    access control. This is the default type.
    """

    DENY = 1
    """
    The policies deny access to principals. The rest is allowed. This is block-list style
    access control.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Permission(betterproto2.Message):
    """
    Permission defines an action (or actions) that a principal can take.
    [#next-free-field: 11]

    Oneofs:
        - rule:
    """

    and_rules: "PermissionSet | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set of rules that all must match in order to define the action.
    """

    or_rules: "PermissionSet | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set of rules where at least one must match in order to define the action.
    """

    any: "bool | None" = betterproto2.field(
        3, betterproto2.TYPE_BOOL, optional=True, group="rule"
    )
    """
    When any is set, it matches any action.
    """

    header: "___api__v2__route__.HeaderMatcher | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    available for HTTP request.
    Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    field if you want to match the URL path without the query and fragment string.
    """

    url_path: "___type__matcher__.PathMatcher | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A URL path on the incoming HTTP request. Only available for HTTP.
    """

    destination_ip: "___api__v2__core__.CidrRange | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A CIDR block that describes the destination IP.
    """

    destination_port: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)] | None" = betterproto2.field(
        6, betterproto2.TYPE_UINT32, optional=True, group="rule"
    )
    """
    A port number that describes the destination port connecting to.
    """

    metadata: "___type__matcher__.MetadataMatcher | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    Metadata that describes additional information about the action.
    """

    not_rule: "Permission | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    Negates matching the provided permission. For instance, if the value of `not_rule` would
    match, this permission would not match. Conversely, if the value of `not_rule` would not
    match, this permission would match.
    """

    requested_server_name: "___type__matcher__.StringMatcher | None" = (
        betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True, group="rule")
    )
    """
    The request server from the client's connection request. This is
    typically TLS SNI.

    .. attention::

      The behavior of this field may be affected by how Envoy is configured
      as explained below.

      * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
        filter is not added, and if a `FilterChainMatch` is not defined for
        the :ref:`server name <envoy_api_field_listener.FilterChainMatch.server_names>`,
        a TLS connection's requested SNI server name will be treated as if it
        wasn't present.

      * A :ref:`listener filter <arch_overview_listener_filters>` may
        overwrite a connection's requested server name within Envoy.

    Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
    setup SNI.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.rbac.v2", "Permission", Permission)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PermissionSet(betterproto2.Message):
    """
    Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
    each are applied with the associated behavior.
    """

    rules: "list[Permission]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.rbac.v2", "Permission.Set", PermissionSet
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Policy(betterproto2.Message):
    """
    Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
    and only if at least one of its permissions match the action taking place AND at least one of its
    principals match the downstream AND the condition is true if specified.
    """

    permissions: "list[Permission]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Required. The set of permissions that define a role. Each permission is matched with OR
    semantics. To match all actions for this policy, a single Permission with the `any` field set
    to true should be used.
    """

    principals: "list[Principal]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Required. The set of principals that are assigned/denied the role based on “action”. Each
    principal is matched with OR semantics. To match all downstreams for this policy, a single
    Principal with the `any` field set to true should be used.
    """

    condition: "____google__api__expr__v1alpha1__.Expr | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An optional symbolic expression specifying an access control
    :ref:`condition <arch_overview_condition>`. The condition is combined
    with the permissions and the principals as a clause with AND semantics.
    """


default_message_pool.register_message("envoy.config.rbac.v2", "Policy", Policy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Principal(betterproto2.Message):
    """
    Principal defines an identity or a group of identities for a downstream subject.
    [#next-free-field: 12]

    Oneofs:
        - identifier:
    """

    and_ids: "PrincipalSet | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A set of identifiers that all must match in order to define the downstream.
    """

    or_ids: "PrincipalSet | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A set of identifiers at least one must match in order to define the downstream.
    """

    any: "bool | None" = betterproto2.field(
        3, betterproto2.TYPE_BOOL, optional=True, group="identifier"
    )
    """
    When any is set, it matches any downstream.
    """

    authenticated: "PrincipalAuthenticated | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    Authenticated attributes that identify the downstream.
    """

    source_ip: "___api__v2__core__.CidrRange | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A CIDR block that describes the downstream IP.
    This address will honor proxy protocol, but will not honor XFF.
    """

    direct_remote_ip: "___api__v2__core__.CidrRange | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A CIDR block that describes the downstream remote/origin address.
    Note: This is always the physical peer even if the
    :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>` is inferred
    from for example the x-forwarder-for header, proxy protocol, etc.
    """

    remote_ip: "___api__v2__core__.CidrRange | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A CIDR block that describes the downstream remote/origin address.
    Note: This may not be the physical peer and could be different from the
    :ref:`direct_remote_ip <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>`.
    E.g, if the remote ip is inferred from for example the x-forwarder-for header,
    proxy protocol, etc.
    """

    header: "___api__v2__route__.HeaderMatcher | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    available for HTTP request.
    Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    field if you want to match the URL path without the query and fragment string.
    """

    url_path: "___type__matcher__.PathMatcher | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A URL path on the incoming HTTP request. Only available for HTTP.
    """

    metadata: "___type__matcher__.MetadataMatcher | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    Metadata that describes additional information about the principal.
    """

    not_id: "Principal | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    Negates matching the provided principal. For instance, if the value of `not_id` would match,
    this principal would not match. Conversely, if the value of `not_id` would not match, this
    principal would match.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("source_ip"):
            warnings.warn("Principal.source_ip is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.rbac.v2", "Principal", Principal)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PrincipalAuthenticated(betterproto2.Message):
    """
    Authentication attributes for a downstream.
    """

    principal_name: "___type__matcher__.StringMatcher | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The name of the principal. If set, The URI SAN or DNS SAN in that order is used from the
    certificate, otherwise the subject field is used. If unset, it applies to any user that is
    authenticated.
    """


default_message_pool.register_message(
    "envoy.config.rbac.v2", "Principal.Authenticated", PrincipalAuthenticated
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PrincipalSet(betterproto2.Message):
    """
    Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
    each are applied with the associated behavior.
    """

    ids: "list[Principal]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.rbac.v2", "Principal.Set", PrincipalSet
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Rbac(betterproto2.Message):
    """
    [#protodoc-title: Role Based Access Control (RBAC)]

    Role Based Access Control (RBAC) provides service-level and method-level access control for a
    service. RBAC policies are additive. The policies are examined in order. A request is allowed
    once a matching policy is found (suppose the `action` is ALLOW).

    Here is an example of RBAC configuration. It has two policies:

    * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
      does "cluster.local/ns/default/sa/superuser".

    * Any user can read ("GET") the service at paths with prefix "/products", so long as the
      destination port is either 80 or 443.

     .. code-block:: yaml

      action: ALLOW
      policies:
        "service-admin":
          permissions:
            - any: true
          principals:
            - authenticated:
                principal_name:
                  exact: "cluster.local/ns/default/sa/admin"
            - authenticated:
                principal_name:
                  exact: "cluster.local/ns/default/sa/superuser"
        "product-viewer":
          permissions:
              - and_rules:
                  rules:
                    - header: { name: ":method", exact_match: "GET" }
                    - url_path:
                        path: { prefix: "/products" }
                    - or_rules:
                        rules:
                          - destination_port: 80
                          - destination_port: 443
          principals:
            - any: true
    """

    action: "RbacAction" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: RbacAction(0)
    )
    """
    The action to take if a policy matches. The request is allowed if and only if:

      * `action` is "ALLOWED" and at least one policy matches
      * `action` is "DENY" and none of the policies match
    """

    policies: "dict[str, Policy]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Maps from policy name to policy. A match occurs when at least one policy matches the request.
    """


default_message_pool.register_message("envoy.config.rbac.v2", "RBAC", Rbac)


from .....google.api.expr import v1alpha1 as ____google__api__expr__v1alpha1__
from ....api.v2 import core as ___api__v2__core__
from ....api.v2 import route as ___api__v2__route__
from ....type import matcher as ___type__matcher__
