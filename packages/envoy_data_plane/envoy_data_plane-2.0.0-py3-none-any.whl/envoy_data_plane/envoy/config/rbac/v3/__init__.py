# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/rbac/v3/rbac.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Action",
    "MetadataSource",
    "Permission",
    "PermissionSet",
    "Policy",
    "Principal",
    "PrincipalAuthenticated",
    "PrincipalSet",
    "Rbac",
    "RbacAction",
    "RbacAuditLoggingOptions",
    "RbacAuditLoggingOptionsAuditCondition",
    "RbacAuditLoggingOptionsAuditLoggerConfig",
    "SourcedMetadata",
)

import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class MetadataSource(betterproto2.Enum):
    """
    [#protodoc-title: Role Based Access Control (RBAC)]
    """

    DYNAMIC = 0
    """
    Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
    """

    ROUTE = 1
    """
    Query :ref:`route metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`
    """


class RbacAction(betterproto2.Enum):
    """
    Should we do safe-list or block-list style access control?
    """

    ALLOW = 0
    """
    The policies grant access to principals. The rest are denied. This is safe-list style
    access control. This is the default type.
    """

    DENY = 1
    """
    The policies deny access to principals. The rest are allowed. This is block-list style
    access control.
    """

    LOG = 2
    """
    The policies set the ``access_log_hint`` dynamic metadata key based on if requests match.
    All requests are allowed.
    """


class RbacAuditLoggingOptionsAuditCondition(betterproto2.Enum):
    """
    Deny and allow here refer to RBAC decisions, not actions.
    """

    NONE = 0
    """
    Never audit.
    """

    ON_DENY = 1
    """
    Audit when RBAC denies the request.
    """

    ON_ALLOW = 2
    """
    Audit when RBAC allows the request.
    """

    ON_DENY_AND_ALLOW = 3
    """
    Audit whether RBAC allows or denies the request.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Action(betterproto2.Message):
    """
    Action defines the result of allowance or denial when a request matches the matcher.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name indicates the policy name.
    """

    action: "RbacAction" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: RbacAction(0)
    )
    """
    The action to take if the matcher matches. Every action either allows or denies a request,
    and can also carry out action-specific operations.

    **Actions:**

     * ``ALLOW``: If the request gets matched on ALLOW, it is permitted.
     * ``DENY``: If the request gets matched on DENY, it is not permitted.
     * ``LOG``: If the request gets matched on LOG, it is permitted. Besides, the
       dynamic metadata key ``access_log_hint`` under the shared key namespace
       ``envoy.common`` will be set to the value ``true``.
     * If the request cannot get matched, it will fallback to ``DENY``.

    **Log behavior:**

     If the RBAC matcher contains at least one LOG action, the dynamic
     metadata key ``access_log_hint`` will be set based on if the request
     get matched on the LOG action.
    """


default_message_pool.register_message("envoy.config.rbac.v3", "Action", Action)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Permission(betterproto2.Message):
    """
    Permission defines an action (or actions) that a principal can take.
    [#next-free-field: 15]

    Oneofs:
        - rule:
    """

    and_rules: "PermissionSet | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set of rules that all must match in order to define the action.
    """

    or_rules: "PermissionSet | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A set of rules where at least one must match in order to define the action.
    """

    any: "bool | None" = betterproto2.field(
        3, betterproto2.TYPE_BOOL, optional=True, group="rule"
    )
    """
    When any is set, it matches any action.
    """

    header: "__route__v3__.HeaderMatcher | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A header (or pseudo-header such as ``:path`` or ``:method``) on the incoming HTTP request. Only available
    for HTTP request.

    .. note::

      The pseudo-header ``:path`` includes the query and fragment string. Use the ``url_path`` field if you
      want to match the URL path without the query and fragment string.
    """

    url_path: "___type__matcher__v3__.PathMatcher | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A URL path on the incoming HTTP request. Only available for HTTP.
    """

    destination_ip: "__core__v3__.CidrRange | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A CIDR block that describes the destination IP.
    """

    destination_port: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)] | None" = betterproto2.field(
        6, betterproto2.TYPE_UINT32, optional=True, group="rule"
    )
    """
    A port number that describes the destination port connecting to.
    """

    destination_port_range: "___type__v3__.Int32Range | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    A port number range that describes a range of destination ports connecting to.
    """

    metadata: "___type__matcher__v3__.MetadataMatcher | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    Metadata that describes additional information about the action. This field is deprecated; please use
    :ref:`sourced_metadata<envoy_v3_api_field_config.rbac.v3.Permission.sourced_metadata>` instead.
    """

    not_rule: "Permission | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    Negates matching the provided permission. For instance, if the value of
    ``not_rule`` would match, this permission would not match. Conversely, if
    the value of ``not_rule`` would not match, this permission would match.
    """

    requested_server_name: "___type__matcher__v3__.StringMatcher | None" = (
        betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True, group="rule")
    )
    """
    The request server from the client's connection request. This is typically TLS SNI.

    .. attention::

      The behavior of this field may be affected by how Envoy is configured
      as explained below.

      * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
        filter is not added, and if a ``FilterChainMatch`` is not defined for
        the :ref:`server name
        <envoy_v3_api_field_config.listener.v3.FilterChainMatch.server_names>`,
        a TLS connection's requested SNI server name will be treated as if it
        wasn't present.

      * A :ref:`listener filter <arch_overview_listener_filters>` may
        overwrite a connection's requested server name within Envoy.

    Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn how to setup SNI.
    """

    matcher: "__core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    Extension for configuring custom matchers for RBAC.
    [#extension-category: envoy.rbac.matchers]
    """

    uri_template: "__core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    URI template path matching.
    [#extension-category: envoy.path.match]
    """

    sourced_metadata: "SourcedMetadata | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True, group="rule"
    )
    """
    Matches against metadata from either dynamic state or route configuration. Preferred over the
    ``metadata`` field as it provides more flexibility in metadata source selection.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("metadata"):
            warnings.warn("Permission.metadata is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.rbac.v3", "Permission", Permission)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PermissionSet(betterproto2.Message):
    """
    Used in the ``and_rules`` and ``or_rules`` fields in the ``rule`` oneof. Depending on the context,
    each are applied with the associated behavior.
    """

    rules: "list[Permission]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.rbac.v3", "Permission.Set", PermissionSet
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Policy(betterproto2.Message):
    """
    Policy specifies a role and the principals that are assigned/denied the role.
    A policy matches if and only if at least one of its permissions match the
    action taking place AND at least one of its principals match the downstream
    AND the condition is true if specified.
    """

    permissions: "list[Permission]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Required. The set of permissions that define a role. Each permission is
    matched with OR semantics. To match all actions for this policy, a single
    Permission with the ``any`` field set to true should be used.
    """

    principals: "list[Principal]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Required. The set of principals that are assigned/denied the role based on
    “action”. Each principal is matched with OR semantics. To match all
    downstreams for this policy, a single Principal with the ``any`` field set to
    true should be used.
    """

    condition: "____google__api__expr__v1alpha1__.Expr | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An optional symbolic expression specifying an access control
    :ref:`condition <arch_overview_condition>`. The condition is combined
    with the permissions and the principals as a clause with AND semantics.
    Only be used when checked_condition is not used.
    """

    checked_condition: "____google__api__expr__v1alpha1__.CheckedExpr | None" = (
        betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    [#not-implemented-hide:]
    An optional symbolic expression that has been successfully type checked.
    Only be used when condition is not used.
    """


default_message_pool.register_message("envoy.config.rbac.v3", "Policy", Policy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Principal(betterproto2.Message):
    """
    Principal defines an identity or a group of identities for a downstream
    subject.
    [#next-free-field: 15]

    Oneofs:
        - identifier:
    """

    and_ids: "PrincipalSet | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A set of identifiers that all must match in order to define the downstream.
    """

    or_ids: "PrincipalSet | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A set of identifiers at least one must match in order to define the downstream.
    """

    any: "bool | None" = betterproto2.field(
        3, betterproto2.TYPE_BOOL, optional=True, group="identifier"
    )
    """
    When any is set, it matches any downstream.
    """

    authenticated: "PrincipalAuthenticated | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    Authenticated attributes that identify the downstream.
    It is recommended to NOT use this field, but instead use
    :ref:`MTlsAuthenticated <envoy_v3_api_msg_extensions.rbac.principals.mtls_authenticated.v3.Config>`,
    configured via :ref:`custom <envoy_v3_api_field_config.rbac.v3.Principal.custom>`,
    which should be used for most use cases due to its improved security.
    """

    source_ip: "__core__v3__.CidrRange | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A CIDR block that describes the downstream IP.
    This address will honor proxy protocol, but will not honor XFF.

    This field is deprecated; either use :ref:`remote_ip
    <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` for the same
    behavior, or use
    :ref:`direct_remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`.
    """

    direct_remote_ip: "__core__v3__.CidrRange | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A CIDR block that describes the downstream remote/origin address.

    .. note::

      This is always the physical peer even if the
      :ref:`remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` is inferred from the
      x-forwarder-for header, the proxy protocol, etc.
    """

    remote_ip: "__core__v3__.CidrRange | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A CIDR block that describes the downstream remote/origin address.

    .. note::

      This may not be the physical peer and could be different from the :ref:`direct_remote_ip
      <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`. E.g, if the remote ip is inferred from
      the x-forwarder-for header, the proxy protocol, etc.
    """

    header: "__route__v3__.HeaderMatcher | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A header (or pseudo-header such as ``:path`` or ``:method``) on the incoming HTTP request. Only available
    for HTTP request.

    .. note::

      The pseudo-header ``:path`` includes the query and fragment string. Use the ``url_path`` field if you
      want to match the URL path without the query and fragment string.
    """

    url_path: "___type__matcher__v3__.PathMatcher | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    A URL path on the incoming HTTP request. Only available for HTTP.
    """

    metadata: "___type__matcher__v3__.MetadataMatcher | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    Metadata that describes additional information about the principal. This field is deprecated; please use
    :ref:`sourced_metadata<envoy_v3_api_field_config.rbac.v3.Principal.sourced_metadata>` instead.
    """

    filter_state: "___type__matcher__v3__.FilterStateMatcher | None" = (
        betterproto2.field(
            12, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
        )
    )
    """
    Identifies the principal using a filter state object.
    """

    not_id: "Principal | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    Negates matching the provided principal. For instance, if the value of
    ``not_id`` would match, this principal would not match. Conversely, if the
    value of ``not_id`` would not match, this principal would match.
    """

    sourced_metadata: "SourcedMetadata | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    Matches against metadata from either dynamic state or route configuration. Preferred over the
    ``metadata`` field as it provides more flexibility in metadata source selection.
    """

    custom: "__core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True, group="identifier"
    )
    """
    Extension for configuring custom principals for RBAC.
    [#extension-category: envoy.rbac.principals]
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("source_ip"):
            warnings.warn("Principal.source_ip is deprecated", DeprecationWarning)
        if self.is_set("metadata"):
            warnings.warn("Principal.metadata is deprecated", DeprecationWarning)

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.config.rbac.v3", "Principal", Principal)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PrincipalAuthenticated(betterproto2.Message):
    """
    Authentication attributes for a downstream.
    It is recommended to NOT use this type, but instead use
    :ref:`MTlsAuthenticated <envoy_v3_api_msg_extensions.rbac.principals.mtls_authenticated.v3.Config>`,
    configured via :ref:`custom <envoy_v3_api_field_config.rbac.v3.Principal.custom>`,
    which should be used for most use cases due to its improved security.
    """

    principal_name: "___type__matcher__v3__.StringMatcher | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The name of the principal. If set, The URI SAN or DNS SAN in that order
    is used from the certificate, otherwise the subject field is used. If
    unset, it applies to any user that is allowed by the downstream TLS configuration.
    If :ref:`require_client_certificate <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate>`
    is false or :ref:`trust_chain_verification <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trust_chain_verification>`
    is set to :ref:`ACCEPT_UNTRUSTED <envoy_v3_api_enum_value_extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification.ACCEPT_UNTRUSTED>`,
    then no authentication is required.
    """


default_message_pool.register_message(
    "envoy.config.rbac.v3", "Principal.Authenticated", PrincipalAuthenticated
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PrincipalSet(betterproto2.Message):
    """
    Used in the ``and_ids`` and ``or_ids`` fields in the ``identifier`` oneof.
    Depending on the context, each are applied with the associated behavior.
    """

    ids: "list[Principal]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.rbac.v3", "Principal.Set", PrincipalSet
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Rbac(betterproto2.Message):
    """
    Role Based Access Control (RBAC) provides service-level and method-level access control for a
    service. Requests are allowed or denied based on the ``action`` and whether a matching policy is
    found. For instance, if the action is ALLOW and a matching policy is found the request should be
    allowed.

    RBAC can also be used to make access logging decisions by communicating with access loggers
    through dynamic metadata. When the action is LOG and at least one policy matches, the
    ``access_log_hint`` value in the shared key namespace 'envoy.common' is set to ``true`` indicating
    the request should be logged.

    Here is an example of RBAC configuration. It has two policies:

    * Service account ``cluster.local/ns/default/sa/admin`` has full access to the service, and so
      does "cluster.local/ns/default/sa/superuser".

    * Any user can read (``GET``) the service at paths with prefix ``/products``, so long as the
      destination port is either 80 or 443.

     .. code-block:: yaml

      action: ALLOW
      policies:
        "service-admin":
          permissions:
            - any: true
          principals:
            - authenticated:
                principal_name:
                  exact: "cluster.local/ns/default/sa/admin"
            - authenticated:
                principal_name:
                  exact: "cluster.local/ns/default/sa/superuser"
        "product-viewer":
          permissions:
              - and_rules:
                  rules:
                    - header:
                        name: ":method"
                        string_match:
                          exact: "GET"
                    - url_path:
                        path: { prefix: "/products" }
                    - or_rules:
                        rules:
                          - destination_port: 80
                          - destination_port: 443
          principals:
            - any: true
    """

    action: "RbacAction" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: RbacAction(0)
    )
    """
    The action to take if a policy matches. Every action either allows or denies a request,
    and can also carry out action-specific operations.

    Actions:

     * ``ALLOW``: Allows the request if and only if there is a policy that matches
       the request.
     * ``DENY``: Allows the request if and only if there are no policies that
       match the request.
     * ``LOG``: Allows all requests. If at least one policy matches, the dynamic
       metadata key ``access_log_hint`` is set to the value ``true`` under the shared
       key namespace ``envoy.common``. If no policies match, it is set to ``false``.
       Other actions do not modify this key.
    """

    policies: "dict[str, Policy]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Maps from policy name to policy. A match occurs when at least one policy matches the request.
    The policies are evaluated in lexicographic order of the policy name.
    """

    audit_logging_options: "RbacAuditLoggingOptions | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Audit logging options that include the condition for audit logging to happen
    and audit logger configurations.

    [#not-implemented-hide:]
    """


default_message_pool.register_message("envoy.config.rbac.v3", "RBAC", Rbac)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RbacAuditLoggingOptions(betterproto2.Message):
    audit_condition: "RbacAuditLoggingOptionsAuditCondition" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: RbacAuditLoggingOptionsAuditCondition(0),
    )
    """
    Condition for the audit logging to happen.
    If this condition is met, all the audit loggers configured here will be invoked.

    [#not-implemented-hide:]
    """

    logger_configs: "list[RbacAuditLoggingOptionsAuditLoggerConfig]" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Configurations for RBAC-based authorization audit loggers.

    [#not-implemented-hide:]
    """


default_message_pool.register_message(
    "envoy.config.rbac.v3", "RBAC.AuditLoggingOptions", RbacAuditLoggingOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RbacAuditLoggingOptionsAuditLoggerConfig(betterproto2.Message):
    """
    [#not-implemented-hide:]
    """

    audit_logger: "__core__v3__.TypedExtensionConfig | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Typed logger configuration.

    [#extension-category: envoy.rbac.audit_loggers]
    """

    is_optional: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    If true, when the logger is not supported, the data plane will not NACK but simply ignore it.
    """


default_message_pool.register_message(
    "envoy.config.rbac.v3",
    "RBAC.AuditLoggingOptions.AuditLoggerConfig",
    RbacAuditLoggingOptionsAuditLoggerConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SourcedMetadata(betterproto2.Message):
    """
    SourcedMetadata enables matching against metadata from different sources in the request processing
    pipeline. It extends the base MetadataMatcher functionality by allowing specification of where the
    metadata should be sourced from, rather than only matching against dynamic metadata.

    The matcher can be configured to look up metadata from:

    * Dynamic metadata: Runtime metadata added by filters during request processing
    * Route metadata: Static metadata configured on the route entry
    """

    metadata_matcher: "___type__matcher__v3__.MetadataMatcher | None" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Metadata matcher configuration that defines what metadata to match against. This includes the filter name,
    metadata key path, and expected value.
    """

    metadata_source: "MetadataSource" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: MetadataSource(0)
    )
    """
    Specifies which metadata source should be used for matching. If not set,
    defaults to DYNAMIC (dynamic metadata). Set to ROUTE to match against
    static metadata configured on the route entry.
    """


default_message_pool.register_message(
    "envoy.config.rbac.v3", "SourcedMetadata", SourcedMetadata
)


from .....google.api.expr import v1alpha1 as ____google__api__expr__v1alpha1__
from ....type import v3 as ___type__v3__
from ....type.matcher import v3 as ___type__matcher__v3__
from ...core import v3 as __core__v3__
from ...route import v3 as __route__v3__
