# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/matching/common_inputs/network/v3/network_inputs.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "ApplicationProtocolInput",
    "DestinationIpInput",
    "DestinationPortInput",
    "DirectSourceIpInput",
    "DynamicMetadataInput",
    "DynamicMetadataInputPathSegment",
    "FilterStateInput",
    "NetworkNamespaceInput",
    "ServerNameInput",
    "SourceIpInput",
    "SourcePortInput",
    "SourceTypeInput",
    "TransportProtocolInput",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ApplicationProtocolInput(betterproto2.Message):
    """
    List of quoted and comma-separated requested application protocols. The list consists of a
    single negotiated application protocol once the network stream is established.

    Examples:

    * ``'h2','http/1.1'``
    * ``'h2c'``

    Suggested values in the list include:

    * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
      <config_listener_filters_tls_inspector>` and :ref:`envoy.filters.listener.http_inspector
      <config_listener_filters_http_inspector>`,
    * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
    * ``h2c`` - set by :ref:`envoy.filters.listener.http_inspector <config_listener_filters_http_inspector>`

    .. attention::

      Currently, :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
      application protocol detection based on the requested
      `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.

      However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
      and matching on values other than ``h2`` is going to lead to a lot of false negatives,
      unless all connecting clients are known to use ALPN.
    [#extension: envoy.matching.inputs.application_protocol]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "ApplicationProtocolInput",
    ApplicationProtocolInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DestinationIpInput(betterproto2.Message):
    """
    [#protodoc-title: Common network matching inputs]

    Specifies that matching should be performed by the destination IP address.
    [#extension: envoy.matching.inputs.destination_ip]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "DestinationIPInput",
    DestinationIpInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DestinationPortInput(betterproto2.Message):
    """
    Specifies that matching should be performed by the destination port.
    [#extension: envoy.matching.inputs.destination_port]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "DestinationPortInput",
    DestinationPortInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DirectSourceIpInput(betterproto2.Message):
    """
    Input that matches by the directly connected source IP address (this
    will only be different from the source IP address when using a listener
    filter that overrides the source address, such as the :ref:`Proxy Protocol
    listener filter <config_listener_filters_proxy_protocol>`).
    [#extension: envoy.matching.inputs.direct_source_ip]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "DirectSourceIPInput",
    DirectSourceIpInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DynamicMetadataInput(betterproto2.Message):
    """
    Input that matches dynamic metadata by key.
    DynamicMetadataInput provides a general interface using ``filter`` and ``path`` to retrieve value from
    :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`.

    For example, for the following Metadata:

    .. code-block:: yaml

       filter_metadata:
         envoy.xxx:
           prop:
             foo: bar
             xyz:
               hello: envoy

    The following DynamicMetadataInput will retrieve a string value "bar" from the Metadata.

    .. code-block:: yaml

       filter: envoy.xxx
       path:
       - key: prop
       - key: foo

    [#extension: envoy.matching.inputs.dynamic_metadata]
    """

    filter: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The filter name to retrieve the Struct from the Metadata.
    """

    path: "list[DynamicMetadataInputPathSegment]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The path to retrieve the Value from the Struct.
    """


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "DynamicMetadataInput",
    DynamicMetadataInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DynamicMetadataInputPathSegment(betterproto2.Message):
    """
    Specifies the segment in a path to retrieve value from Metadata.
    Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
    if the segment key refers to a list, it has to be the last segment in a path.

    Oneofs:
        - segment:
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="segment"
    )
    """
    If specified, use the key to retrieve the value in a Struct.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "DynamicMetadataInput.PathSegment",
    DynamicMetadataInputPathSegment,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class FilterStateInput(betterproto2.Message):
    """
    Input that matches by a specific filter state key.
    The value of the provided filter state key will be the raw string representation of the filter state object
    [#extension: envoy.matching.inputs.filter_state]
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "FilterStateInput",
    FilterStateInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class NetworkNamespaceInput(betterproto2.Message):
    """
    Input that matches by the network namespace of the listener address.
    This input returns the network namespace filepath that was used to create the listening socket.
    On Linux systems, this corresponds to the ``network_namespace_filepath`` field in the
    :ref:`SocketAddress <envoy_v3_api_msg_config.core.v3.SocketAddress>` configuration.

    .. note::

      This input is only meaningful on Linux systems where network namespaces are supported.
      On other platforms, this input will always return an empty value.

    [#extension: envoy.matching.inputs.network_namespace]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "NetworkNamespaceInput",
    NetworkNamespaceInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ServerNameInput(betterproto2.Message):
    """
    Input that matches by the requested server name (e.g. SNI in TLS).

    :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides the requested server name based on SNI,
    when TLS protocol is detected.
    [#extension: envoy.matching.inputs.server_name]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "ServerNameInput",
    ServerNameInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SourceIpInput(betterproto2.Message):
    """
    Specifies that matching should be performed by the source IP address.
    [#extension: envoy.matching.inputs.source_ip]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3", "SourceIPInput", SourceIpInput
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SourcePortInput(betterproto2.Message):
    """
    Specifies that matching should be performed by the source port.
    [#extension: envoy.matching.inputs.source_port]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "SourcePortInput",
    SourcePortInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SourceTypeInput(betterproto2.Message):
    """
    Input that matches by the source IP type.
    Specifies the source IP match type. The values include:

    * ``local`` - matches a connection originating from the same host,
    [#extension: envoy.matching.inputs.source_type]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "SourceTypeInput",
    SourceTypeInput,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TransportProtocolInput(betterproto2.Message):
    """
    Input that matches by the transport protocol.

    Suggested values include:

    * ``raw_buffer`` - default, used when no transport protocol is detected,
    * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
      when TLS protocol is detected.
    [#extension: envoy.matching.inputs.transport_protocol]
    """

    pass


default_message_pool.register_message(
    "envoy.extensions.matching.common_inputs.network.v3",
    "TransportProtocolInput",
    TransportProtocolInput,
)
