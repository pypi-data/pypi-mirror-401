# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/filters/http/json_to_metadata/v3/json_to_metadata.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "JsonToMetadata",
    "JsonToMetadataKeyValuePair",
    "JsonToMetadataMatchRules",
    "JsonToMetadataRule",
    "JsonToMetadataSelector",
    "JsonToMetadataValueType",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class JsonToMetadataValueType(betterproto2.Enum):
    PROTOBUF_VALUE = 0
    """
    The value is a serialized `protobuf.Value
    <https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto#L62>`_.
    """

    STRING = 1

    NUMBER = 2


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class JsonToMetadata(betterproto2.Message):
    """
    [#protodoc-title: Json-To-Metadata Filter]

    The configuration for transforming json body into metadata. This is useful
    for matching load balancer subsets, logging, etc.

    Json to Metadata :ref:`configuration overview <config_http_filters_json_to_metadata>`.
    [#extension: envoy.filters.http.json_to_metadata]
    """

    request_rules: "JsonToMetadataMatchRules | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    At least one of request_rules and response_rules must be provided.
    Rules to match json body of requests.
    """

    response_rules: "JsonToMetadataMatchRules | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Rules to match json body of responses.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.http.json_to_metadata.v3",
    "JsonToMetadata",
    JsonToMetadata,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class JsonToMetadataKeyValuePair(betterproto2.Message):
    """
    [#next-free-field: 6]

    Oneofs:
        - value_type:
    """

    metadata_namespace: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The namespace — if this is empty, the filter's namespace will be used.
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The key to use within the namespace.
    """

    value: "______google__protobuf__.Value | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="value_type"
    )
    """
    The value to pair with the given key.

    When used for on_present case, if value is non-empty it'll be used instead
    of the the value of the JSON key. If both are empty, the the value of the
    JSON key is used as-is.

    When used for on_missing/on_error case, a non-empty value
    must be provided.

    It ignores ValueType, i.e., not type casting.
    """

    type: "JsonToMetadataValueType" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: JsonToMetadataValueType(0)
    )
    """
    The value's type — defaults to protobuf.Value.
    """

    preserve_existing_metadata_value: "bool" = betterproto2.field(
        5, betterproto2.TYPE_BOOL
    )
    """
    False if we want to overwrite the existing metadata value. Default to false.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.http.json_to_metadata.v3",
    "JsonToMetadata.KeyValuePair",
    JsonToMetadataKeyValuePair,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class JsonToMetadataMatchRules(betterproto2.Message):
    rules: "list[JsonToMetadataRule]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of rules to apply.
    """

    allow_content_types: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Allowed content-type for json to metadata transformation.
    Default to ``{"application/json"}``.

    Set ``allow_empty_content_type`` if empty/missing content-type header
    is allowed.
    """

    allow_empty_content_type: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    Allowed empty content-type for json to metadata transformation.
    Default to false.
    """

    allow_content_types_regex: "_____type__matcher__v3__.RegexMatcher | None" = (
        betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Allowed content-type by regex match for json to metadata transformation.
    This can be used in parallel with ``allow_content_types``.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.http.json_to_metadata.v3",
    "JsonToMetadata.MatchRules",
    JsonToMetadataMatchRules,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class JsonToMetadataRule(betterproto2.Message):
    """
    A Rule defines what metadata to apply when a key-value is present, missing in the json
    or fail to parse the payload.
    """

    selectors: "list[JsonToMetadataSelector]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies that a match will be performed on the value of a property.
    Here's an example to match on 1 in {"foo": {"bar": 1}, "bar": 2}

    selectors:
    - key: foo
    - key: bar
    """

    on_present: "JsonToMetadataKeyValuePair | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If the attribute is present, apply this metadata KeyValuePair.
    """

    on_missing: "JsonToMetadataKeyValuePair | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If the attribute is missing, apply this metadata KeyValuePair.

    The value in the KeyValuePair must be set.
    """

    on_error: "JsonToMetadataKeyValuePair | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If the body is too large or fail to parse or content-type is mismatched, apply this metadata KeyValuePair.

    The value in the KeyValuePair must be set.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.http.json_to_metadata.v3",
    "JsonToMetadata.Rule",
    JsonToMetadataRule,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class JsonToMetadataSelector(betterproto2.Message):
    """


    Oneofs:
        - selector:
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="selector"
    )
    """
    key to match
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.http.json_to_metadata.v3",
    "JsonToMetadata.Selector",
    JsonToMetadataSelector,
)


from .......google import protobuf as ______google__protobuf__
from ......type.matcher import v3 as _____type__matcher__v3__
