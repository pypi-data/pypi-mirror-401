# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/filters/http/file_system_buffer/v3/file_system_buffer.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "BufferBehavior",
    "BufferBehaviorBypass",
    "BufferBehaviorFullyBuffer",
    "BufferBehaviorFullyBufferAndAlwaysInjectContentLength",
    "BufferBehaviorInjectContentLengthIfNecessary",
    "BufferBehaviorStreamWhenPossible",
    "FileSystemBufferFilterConfig",
    "StreamConfig",
)


import betterproto2
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BufferBehavior(betterproto2.Message):
    """
    [#protodoc-title: FileSystemBufferFilterConfig]
    [#extension: envoy.filters.http.file_system_buffer]

    The behavior of the filter for a stream.
    [#next-free-field: 6]

    Oneofs:
        - behavior:
    """

    stream_when_possible: "BufferBehaviorStreamWhenPossible | None" = (
        betterproto2.field(
            1, betterproto2.TYPE_MESSAGE, optional=True, group="behavior"
        )
    )
    """
    Don't inject ``content-length`` header.
    Output immediately, buffer only if output is slower than input.
    """

    bypass: "BufferBehaviorBypass | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="behavior"
    )
    """
    Never buffer, do nothing.
    """

    inject_content_length_if_necessary: "BufferBehaviorInjectContentLengthIfNecessary | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="behavior"
    )
    """
    If ``content-length`` is not present, buffer the entire input,
    inject ``content-length`` header, then output.
    If ``content-length`` is already present, act like ``stream_when_possible``.
    """

    fully_buffer_and_always_inject_content_length: "BufferBehaviorFullyBufferAndAlwaysInjectContentLength | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="behavior"
    )
    """
    Always buffer the entire input, and inject ``content-length``,
    overwriting any provided content-length header.
    """

    fully_buffer: "BufferBehaviorFullyBuffer | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="behavior"
    )
    """
    Always buffer the entire input, do not modify ``content-length``.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.filters.http.file_system_buffer.v3",
    "BufferBehavior",
    BufferBehavior,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BufferBehaviorBypass(betterproto2.Message):
    pass


default_message_pool.register_message(
    "envoy.extensions.filters.http.file_system_buffer.v3",
    "BufferBehavior.Bypass",
    BufferBehaviorBypass,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BufferBehaviorFullyBuffer(betterproto2.Message):
    pass


default_message_pool.register_message(
    "envoy.extensions.filters.http.file_system_buffer.v3",
    "BufferBehavior.FullyBuffer",
    BufferBehaviorFullyBuffer,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BufferBehaviorFullyBufferAndAlwaysInjectContentLength(betterproto2.Message):
    pass


default_message_pool.register_message(
    "envoy.extensions.filters.http.file_system_buffer.v3",
    "BufferBehavior.FullyBufferAndAlwaysInjectContentLength",
    BufferBehaviorFullyBufferAndAlwaysInjectContentLength,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BufferBehaviorInjectContentLengthIfNecessary(betterproto2.Message):
    pass


default_message_pool.register_message(
    "envoy.extensions.filters.http.file_system_buffer.v3",
    "BufferBehavior.InjectContentLengthIfNecessary",
    BufferBehaviorInjectContentLengthIfNecessary,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BufferBehaviorStreamWhenPossible(betterproto2.Message):
    pass


default_message_pool.register_message(
    "envoy.extensions.filters.http.file_system_buffer.v3",
    "BufferBehavior.StreamWhenPossible",
    BufferBehaviorStreamWhenPossible,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class FileSystemBufferFilterConfig(betterproto2.Message):
    """
    A :ref:`file system buffer <config_http_filters_file_system_buffer>` filter configuration.

    Route-specific configs override only the fields they explicitly include; unset
    fields inherit from the vhost or listener-level config, or, if never set,
    and not required, use a default value.
    """

    manager_config: "____common__async_files__v3__.AsyncFileManagerConfig | None" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    A configuration for an AsyncFileManager.

    If unset in route, vhost and listener, and the behavior is not ``bypass``
    in both directions, an Internal Server Error response will be sent.
    """

    storage_buffer_path: "str | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.StringValue,
        optional=True,
    )
    """
    An optional path to which the unlinked files should be written - this may
    determine which physical storage device will be used.

    If unset in route, vhost and listener, will use the environment variable
    ``TMPDIR``, or, if that's also unset, will use ``/tmp``.
    """

    request: "StreamConfig | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional configuration for how to buffer (or not) requests.
    If unset in route, vhost and listener, ``StreamConfig`` default values will be used
    (with behavior ``stream_when_possible``)
    """

    response: "StreamConfig | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional configuration for how to buffer (or not) responses.
    If unset in route, vhost and listener, ``StreamConfig`` default values will be used
    (with behavior ``stream_when_possible``)
    """


default_message_pool.register_message(
    "envoy.extensions.filters.http.file_system_buffer.v3",
    "FileSystemBufferFilterConfig",
    FileSystemBufferFilterConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamConfig(betterproto2.Message):
    """
    The configuration for one direction of the filter behavior.
    """

    behavior: "BufferBehavior | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Whether to bypass / stream / fully buffer / etc.
    If unset in route, vhost and listener config, the default is ``stream_when_possible``.
    """

    memory_buffer_bytes_limit: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    The amount stored in the memory buffer before buffering to disk.
    If unset in route, vhost and listener config, defaults to a hardcoded value of 1MiB
    """

    storage_buffer_bytes_limit: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    The maximum storage (excluding memory) to be buffered in this filter.
    If unset in route, vhost and listener config, defaults to a hardcoded value of 32MiB
    """

    storage_buffer_queue_high_watermark_bytes: "int | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ______google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    The maximum amount that can be queued for writing to storage, above which the
    source is requested to pause. If unset, defaults to the same value as
    ``memory_buffer_bytes_limit``.

    For example, assuming the recipient is not consuming data at all, if
    ``memory_buffer_bytes_limit`` was 32MiB, and ``storage_buffer_queue_high_watermark_bytes``
    was 64MiB, and the filesystem is backed up so writes are not occurring promptly,
    then:

    * Any request less than 32MiB will eventually pass through without ever attempting
      to write to disk.
    * Any request with over 32MiB buffered will start trying to write to disk.
      If it reaches (32+64)MiB buffered in memory (write to disk isn't keeping up), a high
      watermark signal is sent to the source.
    * Any stream whose total size exceeds
      ``memory_buffer_bytes_limit + storage_buffer_bytes_limit`` will provoke an error.
      (Note, if the recipient *is* consuming data then it is possible for such an
      oversized request to pass through the buffer filter, provided the recipient
      isn't consuming data too slowly.)

    The low watermark signal is sent when the memory buffer is at size
    ``memory_buffer_bytes_limit + (storage_buffer_queue_high_watermark_bytes / 2)``.
    """


default_message_pool.register_message(
    "envoy.extensions.filters.http.file_system_buffer.v3", "StreamConfig", StreamConfig
)


from .......google import protobuf as ______google__protobuf__
from .....common.async_files import v3 as ____common__async_files__v3__
