# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/type/v3/hash_policy.proto, envoy/type/v3/http.proto, envoy/type/v3/http_status.proto, envoy/type/v3/percent.proto, envoy/type/v3/range.proto, envoy/type/v3/ratelimit_strategy.proto, envoy/type/v3/ratelimit_unit.proto, envoy/type/v3/semantic_version.proto, envoy/type/v3/token_bucket.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "CodecClientType",
    "DoubleRange",
    "FractionalPercent",
    "FractionalPercentDenominatorType",
    "HashPolicy",
    "HashPolicyFilterState",
    "HashPolicySourceIp",
    "HttpStatus",
    "Int32Range",
    "Int64Range",
    "Percent",
    "RateLimitStrategy",
    "RateLimitStrategyBlanketRule",
    "RateLimitStrategyRequestsPerTimeUnit",
    "RateLimitUnit",
    "SemanticVersion",
    "StatusCode",
    "TokenBucket",
)

import datetime
import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from ....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class CodecClientType(betterproto2.Enum):
    """
    [#protodoc-title: HTTP]
    """

    HTTP1 = 0

    HTTP2 = 1

    HTTP3 = 2
    """
    [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
    caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
    to distinguish HTTP1 and HTTP2 traffic.
    """


class FractionalPercentDenominatorType(betterproto2.Enum):
    """
    Fraction percentages support several fixed denominator values.
    """

    HUNDRED = 0
    """
    100.

    **Example**: 1/100 = 1%.
    """

    TEN_THOUSAND = 1
    """
    10,000.

    **Example**: 1/10000 = 0.01%.
    """

    MILLION = 2
    """
    1,000,000.

    **Example**: 1/1000000 = 0.0001%.
    """


class RateLimitStrategyBlanketRule(betterproto2.Enum):
    """
    Choose between allow all and deny all.
    """

    ALLOW_ALL = 0

    DENY_ALL = 1


class RateLimitUnit(betterproto2.Enum):
    """
    [#protodoc-title: Ratelimit Time Unit]

    Identifies the unit of of time for rate limit.
    """

    UNKNOWN = 0
    """
    The time unit is not known.
    """

    SECOND = 1
    """
    The time unit representing a second.
    """

    MINUTE = 2
    """
    The time unit representing a minute.
    """

    HOUR = 3
    """
    The time unit representing an hour.
    """

    DAY = 4
    """
    The time unit representing a day.
    """

    MONTH = 5
    """
    The time unit representing a month.
    """

    YEAR = 6
    """
    The time unit representing a year.
    """


class StatusCode(betterproto2.Enum):
    """
    [#protodoc-title: HTTP status codes]

    HTTP response codes supported in Envoy.
    For more details: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
    """

    Empty = 0
    """
    Empty - This code not part of the HTTP status code specification, but it is needed for proto
    `enum` type.
    """

    Continue = 100
    """
    Continue - ``100`` status code.
    """

    OK = 200
    """
    OK - ``200`` status code.
    """

    Created = 201
    """
    Created - ``201`` status code.
    """

    Accepted = 202
    """
    Accepted - ``202`` status code.
    """

    NonAuthoritativeInformation = 203
    """
    NonAuthoritativeInformation - ``203`` status code.
    """

    NoContent = 204
    """
    NoContent - ``204`` status code.
    """

    ResetContent = 205
    """
    ResetContent - ``205`` status code.
    """

    PartialContent = 206
    """
    PartialContent - ``206`` status code.
    """

    MultiStatus = 207
    """
    MultiStatus - ``207`` status code.
    """

    AlreadyReported = 208
    """
    AlreadyReported - ``208`` status code.
    """

    IMUsed = 226
    """
    IMUsed - ``226`` status code.
    """

    MultipleChoices = 300
    """
    MultipleChoices - ``300`` status code.
    """

    MovedPermanently = 301
    """
    MovedPermanently - ``301`` status code.
    """

    Found = 302
    """
    Found - ``302`` status code.
    """

    SeeOther = 303
    """
    SeeOther - ``303`` status code.
    """

    NotModified = 304
    """
    NotModified - ``304`` status code.
    """

    UseProxy = 305
    """
    UseProxy - ``305`` status code.
    """

    TemporaryRedirect = 307
    """
    TemporaryRedirect - ``307`` status code.
    """

    PermanentRedirect = 308
    """
    PermanentRedirect - ``308`` status code.
    """

    BadRequest = 400
    """
    BadRequest - ``400`` status code.
    """

    Unauthorized = 401
    """
    Unauthorized - ``401`` status code.
    """

    PaymentRequired = 402
    """
    PaymentRequired - ``402`` status code.
    """

    Forbidden = 403
    """
    Forbidden - ``403`` status code.
    """

    NotFound = 404
    """
    NotFound - ``404`` status code.
    """

    MethodNotAllowed = 405
    """
    MethodNotAllowed - ``405`` status code.
    """

    NotAcceptable = 406
    """
    NotAcceptable - ``406`` status code.
    """

    ProxyAuthenticationRequired = 407
    """
    ProxyAuthenticationRequired - ``407`` status code.
    """

    RequestTimeout = 408
    """
    RequestTimeout - ``408`` status code.
    """

    Conflict = 409
    """
    Conflict - ``409`` status code.
    """

    Gone = 410
    """
    Gone - ``410`` status code.
    """

    LengthRequired = 411
    """
    LengthRequired - ``411`` status code.
    """

    PreconditionFailed = 412
    """
    PreconditionFailed - ``412`` status code.
    """

    PayloadTooLarge = 413
    """
    PayloadTooLarge - ``413`` status code.
    """

    URITooLong = 414
    """
    URITooLong - ``414`` status code.
    """

    UnsupportedMediaType = 415
    """
    UnsupportedMediaType - ``415`` status code.
    """

    RangeNotSatisfiable = 416
    """
    RangeNotSatisfiable - ``416`` status code.
    """

    ExpectationFailed = 417
    """
    ExpectationFailed - ``417`` status code.
    """

    MisdirectedRequest = 421
    """
    MisdirectedRequest - ``421`` status code.
    """

    UnprocessableEntity = 422
    """
    UnprocessableEntity - ``422`` status code.
    """

    Locked = 423
    """
    Locked - ``423`` status code.
    """

    FailedDependency = 424
    """
    FailedDependency - ``424`` status code.
    """

    UpgradeRequired = 426
    """
    UpgradeRequired - ``426`` status code.
    """

    PreconditionRequired = 428
    """
    PreconditionRequired - ``428`` status code.
    """

    TooManyRequests = 429
    """
    TooManyRequests - ``429`` status code.
    """

    RequestHeaderFieldsTooLarge = 431
    """
    RequestHeaderFieldsTooLarge - ``431`` status code.
    """

    InternalServerError = 500
    """
    InternalServerError - ``500`` status code.
    """

    NotImplemented = 501
    """
    NotImplemented - ``501`` status code.
    """

    BadGateway = 502
    """
    BadGateway - ``502`` status code.
    """

    ServiceUnavailable = 503
    """
    ServiceUnavailable - ``503`` status code.
    """

    GatewayTimeout = 504
    """
    GatewayTimeout - ``504`` status code.
    """

    HTTPVersionNotSupported = 505
    """
    HTTPVersionNotSupported - ``505`` status code.
    """

    VariantAlsoNegotiates = 506
    """
    VariantAlsoNegotiates - ``506`` status code.
    """

    InsufficientStorage = 507
    """
    InsufficientStorage - ``507`` status code.
    """

    LoopDetected = 508
    """
    LoopDetected - ``508`` status code.
    """

    NotExtended = 510
    """
    NotExtended - ``510`` status code.
    """

    NetworkAuthenticationRequired = 511
    """
    NetworkAuthenticationRequired - ``511`` status code.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DoubleRange(betterproto2.Message):
    """
    Specifies the double start and end of the range using half-open interval semantics [start,
    end).
    """

    start: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)
    """
    start of the range (inclusive)
    """

    end: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    end of the range (exclusive)
    """


default_message_pool.register_message("envoy.type.v3", "DoubleRange", DoubleRange)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class FractionalPercent(betterproto2.Message):
    """
    A fractional percentage is used in cases in which for performance reasons performing floating
    point to integer conversions during randomness calculations is undesirable. The message includes
    both a numerator and denominator that together determine the final fractional value.

    * **Example**: 1/100 = 1%.
    * **Example**: 3/10000 = 0.03%.
    """

    numerator: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    Specifies the numerator. Defaults to 0.
    """

    denominator: "FractionalPercentDenominatorType" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: FractionalPercentDenominatorType(0),
    )
    """
    Specifies the denominator. If the denominator specified is less than the numerator, the final
    fractional percentage is capped at 1 (100%).
    """


default_message_pool.register_message(
    "envoy.type.v3", "FractionalPercent", FractionalPercent
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HashPolicy(betterproto2.Message):
    """
    [#protodoc-title: Hash Policy]

    Specifies the hash policy

    Oneofs:
        - policy_specifier:
    """

    source_ip: "HashPolicySourceIp | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="policy_specifier"
    )

    filter_state: "HashPolicyFilterState | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="policy_specifier"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.type.v3", "HashPolicy", HashPolicy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HashPolicyFilterState(betterproto2.Message):
    """
    An Object in the :ref:`filterState <arch_overview_data_sharing_between_filters>` will be used
    to compute the hash used by hash-based load balancing algorithms.
    """

    key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the Object in the filterState, which is an Envoy::Hashable object. If there is no
    data associated with the key, or the stored object is not Envoy::Hashable, no hash will be
    produced.
    """


default_message_pool.register_message(
    "envoy.type.v3", "HashPolicy.FilterState", HashPolicyFilterState
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HashPolicySourceIp(betterproto2.Message):
    """
    The source IP will be used to compute the hash used by hash-based load balancing
    algorithms.
    """

    pass


default_message_pool.register_message(
    "envoy.type.v3", "HashPolicy.SourceIp", HashPolicySourceIp
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpStatus(betterproto2.Message):
    """
    HTTP status.
    """

    code: "StatusCode" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: StatusCode(0)
    )
    """
    Supplies HTTP response code.
    """


default_message_pool.register_message("envoy.type.v3", "HttpStatus", HttpStatus)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Int32Range(betterproto2.Message):
    """
    Specifies the int32 start and end of the range using half-open interval semantics [start,
    end).
    """

    start: "typing.Annotated[int, pydantic.Field(ge=-2**31, le=2**31 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_INT32)
    )
    """
    start of the range (inclusive)
    """

    end: "typing.Annotated[int, pydantic.Field(ge=-2**31, le=2**31 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_INT32)
    )
    """
    end of the range (exclusive)
    """


default_message_pool.register_message("envoy.type.v3", "Int32Range", Int32Range)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Int64Range(betterproto2.Message):
    """
    [#protodoc-title: Range]

    Specifies the int64 start and end of the range using half-open interval semantics [start,
    end).
    """

    start: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_INT64)
    )
    """
    start of the range (inclusive)
    """

    end: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_INT64)
    )
    """
    end of the range (exclusive)
    """


default_message_pool.register_message("envoy.type.v3", "Int64Range", Int64Range)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Percent(betterproto2.Message):
    """
    [#protodoc-title: Percent]

    Identifies a percentage, in the range [0.0, 100.0].
    """

    value: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("envoy.type.v3", "Percent", Percent)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitStrategy(betterproto2.Message):
    """
    [#protodoc-title: Rate Limit Strategies]

    Oneofs:
        - strategy:
    """

    blanket_rule: "RateLimitStrategyBlanketRule | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True, group="strategy"
    )
    """
    Allow or Deny the requests.
    If unset, allow all.
    """

    requests_per_time_unit: "RateLimitStrategyRequestsPerTimeUnit | None" = (
        betterproto2.field(
            2, betterproto2.TYPE_MESSAGE, optional=True, group="strategy"
        )
    )
    """
    Best-effort limit of the number of requests per time unit, f.e. requests per second.
    Does not prescribe any specific rate limiting algorithm, see :ref:`RequestsPerTimeUnit
    <envoy_v3_api_msg_type.v3.RateLimitStrategy.RequestsPerTimeUnit>` for details.
    """

    token_bucket: "TokenBucket | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="strategy"
    )
    """
    Limit the requests by consuming tokens from the Token Bucket.
    Allow the same number of requests as the number of tokens available in
    the token bucket.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.type.v3", "RateLimitStrategy", RateLimitStrategy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitStrategyRequestsPerTimeUnit(betterproto2.Message):
    """
    Best-effort limit of the number of requests per time unit.

    Allows to specify the desired requests per second (RPS, QPS), requests per minute (QPM, RPM),
    etc., without specifying a rate limiting algorithm implementation.

    ``RequestsPerTimeUnit`` strategy does not demand any specific rate limiting algorithm to be
    used (in contrast to the :ref:`TokenBucket <envoy_v3_api_msg_type.v3.TokenBucket>`,
    for example). It implies that the implementation details of rate limiting algorithm are
    irrelevant as long as the configured number of "requests per time unit" is achieved.

    Note that the ``TokenBucket`` is still a valid implementation of the ``RequestsPerTimeUnit``
    strategy, and may be chosen to enforce the rate limit. However, there's no guarantee it will be
    the ``TokenBucket`` in particular, and not the Leaky Bucket, the Sliding Window, or any other
    rate limiting algorithm that fulfills the requirements.
    """

    requests_per_time_unit: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        1, betterproto2.TYPE_UINT64
    )
    """
    The desired number of requests per :ref:`time_unit
    <envoy_v3_api_field_type.v3.RateLimitStrategy.RequestsPerTimeUnit.time_unit>` to allow.
    If set to ``0``, deny all (equivalent to ``BlanketRule.DENY_ALL``).

    .. note::
      Note that the algorithm implementation determines the course of action for the requests
      over the limit. As long as the ``requests_per_time_unit`` converges on the desired value,
      it's allowed to treat this field as a soft-limit: allow bursts, redistribute the allowance
      over time, etc.
    """

    time_unit: "RateLimitUnit" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: RateLimitUnit(0)
    )
    """
    The unit of time. Ignored when :ref:`requests_per_time_unit
    <envoy_v3_api_field_type.v3.RateLimitStrategy.RequestsPerTimeUnit.requests_per_time_unit>`
    is ``0`` (deny all).
    """


default_message_pool.register_message(
    "envoy.type.v3",
    "RateLimitStrategy.RequestsPerTimeUnit",
    RateLimitStrategyRequestsPerTimeUnit,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SemanticVersion(betterproto2.Message):
    """
    [#protodoc-title: Semantic version]

    Envoy uses SemVer (https://semver.org/). Major/minor versions indicate
    expected behaviors and APIs, the patch version field is used only
    for security fixes and can be generally ignored.
    """

    major_number: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )

    minor_number: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )

    patch: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )


default_message_pool.register_message(
    "envoy.type.v3", "SemanticVersion", SemanticVersion
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TokenBucket(betterproto2.Message):
    """
    [#protodoc-title: Token bucket]

    Configures a token bucket, typically used for rate limiting.
    """

    max_tokens: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    The maximum tokens that the bucket can hold. This is also the number of tokens that the bucket
    initially contains.
    """

    tokens_per_fill: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The number of tokens added to the bucket during each fill interval. If not specified, defaults
    to a single token.
    """

    fill_interval: "datetime.timedelta | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    The fill interval that tokens are added to the bucket. During each fill interval
    ``tokens_per_fill`` are added to the bucket. The bucket will never contain more than
    ``max_tokens`` tokens.
    """


default_message_pool.register_message("envoy.type.v3", "TokenBucket", TokenBucket)


from ....google import protobuf as ___google__protobuf__
