# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: io/prometheus/client/metrics.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Bucket",
    "BucketSpan",
    "Counter",
    "Exemplar",
    "Gauge",
    "Histogram",
    "LabelPair",
    "Metric",
    "MetricFamily",
    "MetricType",
    "Quantile",
    "Summary",
    "Untyped",
)

import datetime
import typing

import betterproto2
import pydantic
from pydantic.dataclasses import dataclass

from ....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class MetricType(betterproto2.Enum):
    COUNTER = 0
    """
    COUNTER must use the Metric field "counter".
    """

    GAUGE = 1
    """
    GAUGE must use the Metric field "gauge".
    """

    SUMMARY = 2
    """
    SUMMARY must use the Metric field "summary".
    """

    UNTYPED = 3
    """
    UNTYPED must use the Metric field "untyped".
    """

    HISTOGRAM = 4
    """
    HISTOGRAM must use the Metric field "histogram".
    """

    GAUGE_HISTOGRAM = 5
    """
    GAUGE_HISTOGRAM must use the Metric field "histogram".
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Bucket(betterproto2.Message):
    """
    A Bucket of a conventional histogram, each of which is treated as
    an individual counter-like time series by Prometheus.
    """

    cumulative_count: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )
    """
    Cumulative in increasing order.
    """

    cumulative_count_float: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Overrides cumulative_count if > 0.
    """

    upper_bound: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Inclusive.
    """

    exemplar: "Exemplar | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("io.prometheus.client", "Bucket", Bucket)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BucketSpan(betterproto2.Message):
    """
    A BucketSpan defines a number of consecutive buckets in a native
    histogram with their offset. Logically, it would be more
    straightforward to include the bucket counts in the Span. However,
    the protobuf representation is more compact in the way the data is
    structured here (with all the buckets in a single array separate
    from the Spans).
    """

    offset: "typing.Annotated[int, pydantic.Field(ge=-2**31, le=2**31 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_SINT32)
    )
    """
    Gap to previous span, or starting point for 1st span (which can be negative).
    """

    length: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )
    """
    Length of consecutive buckets.
    """


default_message_pool.register_message("io.prometheus.client", "BucketSpan", BucketSpan)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Counter(betterproto2.Message):
    value: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)

    exemplar: "Exemplar | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    created_timestamp: "datetime.datetime | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )


default_message_pool.register_message("io.prometheus.client", "Counter", Counter)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Exemplar(betterproto2.Message):
    label: "list[LabelPair]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    value: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)

    timestamp: "datetime.datetime | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )
    """
    OpenMetrics-style.
    """


default_message_pool.register_message("io.prometheus.client", "Exemplar", Exemplar)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Gauge(betterproto2.Message):
    value: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("io.prometheus.client", "Gauge", Gauge)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Histogram(betterproto2.Message):
    sample_count: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )

    sample_count_float: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    Overrides sample_count if > 0.
    """

    sample_sum: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)

    bucket: "list[Bucket]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Buckets for the conventional histogram.

    Ordered in increasing order of upper_bound, +Inf bucket is optional.
    """

    created_timestamp: "datetime.datetime | None" = betterproto2.field(
        15,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )

    schema: "typing.Annotated[int, pydantic.Field(ge=-2**31, le=2**31 - 1)]" = (
        betterproto2.field(5, betterproto2.TYPE_SINT32)
    )
    """
    Everything below here is for native histograms (formerly known as sparse histograms).

    schema defines the bucket schema. Currently, valid numbers are -4 <= n <= 8.
    They are all for base-2 bucket schemas, where 1 is a bucket boundary in each case, and
    then each power of two is divided into 2^n logarithmic buckets.
    Or in other words, each bucket boundary is the previous boundary times 2^(2^-n).
    In the future, more bucket schemas may be added using numbers < -4 or > 8.
    """

    zero_threshold: "float" = betterproto2.field(6, betterproto2.TYPE_DOUBLE)
    """
    Breadth of the zero bucket.
    """

    zero_count: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(7, betterproto2.TYPE_UINT64)
    )
    """
    Count in zero bucket.
    """

    zero_count_float: "float" = betterproto2.field(8, betterproto2.TYPE_DOUBLE)
    """
    Overrides sb_zero_count if > 0.
    """

    negative_span: "list[BucketSpan]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Negative buckets for the native histogram.
    """

    negative_delta: "list[typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]]" = betterproto2.field(
        10, betterproto2.TYPE_SINT64, repeated=True
    )
    """
    Use either "negative_delta" or "negative_count", the former for
    regular histograms with integer counts, the latter for float
    histograms.

    Count delta of each bucket compared to previous one (or to zero for 1st bucket).
    """

    negative_count: "list[float]" = betterproto2.field(
        11, betterproto2.TYPE_DOUBLE, repeated=True
    )
    """
    Absolute count of each bucket.
    """

    positive_span: "list[BucketSpan]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Positive buckets for the native histogram.
    Use a no-op span (offset 0, length 0) for a native histogram without any
    observations yet and with a zero_threshold of 0. Otherwise, it would be
    indistinguishable from a classic histogram.
    """

    positive_delta: "list[typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]]" = betterproto2.field(
        13, betterproto2.TYPE_SINT64, repeated=True
    )
    """
    Use either "positive_delta" or "positive_count", the former for
    regular histograms with integer counts, the latter for float
    histograms.

    Count delta of each bucket compared to previous one (or to zero for 1st bucket).
    """

    positive_count: "list[float]" = betterproto2.field(
        14, betterproto2.TYPE_DOUBLE, repeated=True
    )
    """
    Absolute count of each bucket.
    """

    exemplars: "list[Exemplar]" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Only used for native histograms. These exemplars MUST have a timestamp.
    """


default_message_pool.register_message("io.prometheus.client", "Histogram", Histogram)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LabelPair(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )


default_message_pool.register_message("io.prometheus.client", "LabelPair", LabelPair)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Metric(betterproto2.Message):
    label: "list[LabelPair]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    gauge: "Gauge | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    counter: "Counter | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    summary: "Summary | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    untyped: "Untyped | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )

    histogram: "Histogram | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )

    timestamp_ms: "typing.Annotated[int, pydantic.Field(ge=-2**63, le=2**63 - 1)]" = (
        betterproto2.field(6, betterproto2.TYPE_INT64)
    )


default_message_pool.register_message("io.prometheus.client", "Metric", Metric)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class MetricFamily(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    help: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    type: "MetricType" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: MetricType(0)
    )

    metric: "list[Metric]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )

    unit: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "io.prometheus.client", "MetricFamily", MetricFamily
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Quantile(betterproto2.Message):
    quantile: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)

    value: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("io.prometheus.client", "Quantile", Quantile)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Summary(betterproto2.Message):
    sample_count: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )

    sample_sum: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)

    quantile: "list[Quantile]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    created_timestamp: "datetime.datetime | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )


default_message_pool.register_message("io.prometheus.client", "Summary", Summary)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Untyped(betterproto2.Message):
    value: "float" = betterproto2.field(1, betterproto2.TYPE_DOUBLE)


default_message_pool.register_message("io.prometheus.client", "Untyped", Untyped)


from ....google import protobuf as ___google__protobuf__
