# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: xds/core/v3/authority.proto, xds/core/v3/cidr.proto, xds/core/v3/collection_entry.proto, xds/core/v3/context_params.proto, xds/core/v3/extension.proto, xds/core/v3/resource_locator.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Authority",
    "CidrRange",
    "CollectionEntry",
    "CollectionEntryInlineEntry",
    "ContextParams",
    "ResourceLocator",
    "ResourceLocatorDirective",
    "ResourceLocatorScheme",
    "TypedExtensionConfig",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from ....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ResourceLocatorScheme(betterproto2.Enum):
    XDSTP = 0

    HTTP = 1

    FILE = 2


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Authority(betterproto2.Message):
    """
    xDS authority information.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )


default_message_pool.register_message("xds.core.v3", "Authority", Authority)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CidrRange(betterproto2.Message):
    """
    CidrRange specifies an IP Address and a prefix length to construct
    the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
    """

    address_prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
    """

    prefix_len: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Length of prefix, e.g. 0, 32. Defaults to 0 when unset.
    """


default_message_pool.register_message("xds.core.v3", "CidrRange", CidrRange)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CollectionEntry(betterproto2.Message):
    """
    xDS collection resource wrapper. This encapsulates a xDS resource when
    appearing inside a list collection resource. List collection resources are
    regular Resource messages of type:

    .. code-block:: proto

      message <T>Collection {
        repeated CollectionEntry resources = 1;
      }

    Oneofs:
        - resource_specifier:
    """

    locator: "ResourceLocator | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="resource_specifier"
    )
    """
    A resource locator describing how the member resource is to be located.
    """

    inline_entry: "CollectionEntryInlineEntry | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="resource_specifier"
    )
    """
    The resource is inlined in the list collection.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("xds.core.v3", "CollectionEntry", CollectionEntry)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CollectionEntryInlineEntry(betterproto2.Message):
    """
    Inlined resource entry.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Optional name to describe the inlined resource. Resource names must match
    ``[a-zA-Z0-9_-\\./]+`` (TODO(htuch): turn this into a PGV constraint once
    finalized, probably should be a RFC3986 pchar). This name allows
    reference via the #entry directive in ResourceLocator.
    """

    version: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The resource's logical version. It is illegal to have the same named xDS
    resource name at a given version with different resource payloads.
    """

    resource: "___google__protobuf__.Any | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The resource payload, including type URL.
    """


default_message_pool.register_message(
    "xds.core.v3", "CollectionEntry.InlineEntry", CollectionEntryInlineEntry
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ContextParams(betterproto2.Message):
    """
    Additional parameters that can be used to select resource variants. These include any
    global context parameters, per-resource type client feature capabilities and per-resource
    type functional attributes. All per-resource type attributes will be `xds.resource.`
    prefixed and some of these are documented below:

    `xds.resource.listening_address`: The value is "IP:port" (e.g. "10.1.1.3:8080") which is
      the listening address of a Listener. Used in a Listener resource query.
    """

    params: "dict[str, str]" = betterproto2.field(
        1,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )


default_message_pool.register_message("xds.core.v3", "ContextParams", ContextParams)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ResourceLocator(betterproto2.Message):
    """
    xDS resource locators identify a xDS resource name and instruct the
    data-plane load balancer on how the resource may be located.

    Resource locators have a canonical xdstp:// URI representation:

      xdstp://{authority}/{type_url}/{id}?{context_params}{#directive,*}

    where context_params take the form of URI query parameters.

    Resource locators have a similar canonical http:// URI representation:

      http://{authority}/{type_url}/{id}?{context_params}{#directive,*}

    Resource locators also have a simplified file:// URI representation:

      file:///{id}{#directive,*}

    Oneofs:
        - context_param_specifier:
    """

    scheme: "ResourceLocatorScheme" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ResourceLocatorScheme(0)
    )
    """
    URI scheme.
    """

    id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Opaque identifier for the resource. Any '/' will not be escaped during URI
    encoding and will form part of the URI path. This may end
    with ‘*’ for glob collection references.
    """

    authority: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    Logical authority for resource (not necessarily transport network address).
    Authorities are opaque in the xDS API, data-plane load balancers will map
    them to concrete network transports such as an xDS management server, e.g.
    via envoy.config.core.v3.ConfigSource.
    """

    resource_type: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    Fully qualified resource type (as in type URL without types.googleapis.com/
    prefix).
    """

    exact_context: "ContextParams | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="context_param_specifier"
    )
    """
    Additional parameters that can be used to select resource variants.
    Matches must be exact, i.e. all context parameters must match exactly and
    there must be no additional context parameters set on the matched
    resource.
    """

    directives: "list[ResourceLocatorDirective]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of directives that appear in the xDS resource locator #fragment.

    When encoding to URI form, directives are percent encoded with comma
    separation.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("xds.core.v3", "ResourceLocator", ResourceLocator)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ResourceLocatorDirective(betterproto2.Message):
    """
    Directives provide information to data-plane load balancers on how xDS
    resource names are to be interpreted and potentially further resolved. For
    example, they may provide alternative resource locators for when primary
    resolution fails. Directives are not part of resource names and do not
    appear in a xDS transport discovery request.

    When encoding to URIs, directives take the form:

    <directive name>=<string representation of directive value>

    For example, we can have alt=xdstp://foo/bar or entry=some%20thing. Each
    directive value type may have its own string encoding, in the case of
    ResourceLocator there is a recursive URI encoding.

    Percent encoding applies to the URI encoding of the directive value.
    Multiple directives are comma-separated, so the reserved characters that
    require percent encoding in a directive value are [',', '#', '[', ']',
    '%']. These are the RFC3986 fragment reserved characters with the addition
    of the xDS scheme specific ','. See
    https://tools.ietf.org/html/rfc3986#page-49 for further details on URI ABNF
    and reserved characters.

    Oneofs:
        - directive:
    """

    alt: "ResourceLocator | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="directive"
    )
    """
    An alternative resource locator for fallback if the resource is
    unavailable. For example, take the resource locator:

      xdstp://foo/some-type/some-route-table#alt=xdstp://bar/some-type/another-route-table

    If the data-plane load balancer is unable to reach `foo` to fetch the
    resource, it will fallback to `bar`. Alternative resources do not need
    to have equivalent content, but they should be functional substitutes.
    """

    entry: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="directive"
    )
    """
    List collections support inlining of resources via the entry field in
    Resource. These inlined Resource objects may have an optional name
    field specified. When specified, the entry directive allows
    ResourceLocator to directly reference these inlined resources, e.g.
    xdstp://.../foo#entry=bar.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "xds.core.v3", "ResourceLocator.Directive", ResourceLocatorDirective
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TypedExtensionConfig(betterproto2.Message):
    """
    Message type for extension configuration.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of an extension. This is not used to select the extension, instead
    it serves the role of an opaque identifier.
    """

    typed_config: "___google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The typed config for the extension. The type URL will be used to identify
    the extension. In the case that the type URL is *xds.type.v3.TypedStruct*
    (or, for historical reasons, *udpa.type.v1.TypedStruct*), the inner type
    URL of *TypedStruct* will be utilized. See the
    :ref:`extension configuration overview
    <config_overview_extension_configuration>` for further details.
    """


default_message_pool.register_message(
    "xds.core.v3", "TypedExtensionConfig", TypedExtensionConfig
)


from ....google import protobuf as ___google__protobuf__
