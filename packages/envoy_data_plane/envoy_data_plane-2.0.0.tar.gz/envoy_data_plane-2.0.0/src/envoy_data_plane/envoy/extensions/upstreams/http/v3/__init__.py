# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/upstreams/http/v3/http_protocol_options.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "HttpProtocolOptions",
    "HttpProtocolOptionsAutoHttpConfig",
    "HttpProtocolOptionsExplicitHttpConfig",
    "HttpProtocolOptionsOutlierDetection",
    "HttpProtocolOptionsUseDownstreamHttpConfig",
)


import betterproto2
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from ......message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpProtocolOptions(betterproto2.Message):
    """
    [#protodoc-title: HTTP Protocol Options]
    [#extension: envoy.upstreams.http.http_protocol_options]

    HttpProtocolOptions specifies Http upstream protocol options. This object
    is used in
    :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
    keyed by the name ``envoy.extensions.upstreams.http.v3.HttpProtocolOptions``.

    This controls what protocol(s) should be used for upstream and how said protocol(s) are configured.

    This replaces the prior pattern of explicit protocol configuration directly
    in the cluster. So a configuration like this, explicitly configuring the use of HTTP/2 upstream:

    .. code::

      clusters:
        - name: some_service
          connect_timeout: 5s
          upstream_http_protocol_options:
            auto_sni: true
          common_http_protocol_options:
            idle_timeout: 1s
          http2_protocol_options:
            max_concurrent_streams: 100
           .... [further cluster config]

    Would now look like this:

    .. code::

      clusters:
        - name: some_service
          connect_timeout: 5s
          typed_extension_protocol_options:
            envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
              "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
              upstream_http_protocol_options:
                auto_sni: true
              common_http_protocol_options:
                idle_timeout: 1s
              explicit_http_config:
                http2_protocol_options:
                  max_concurrent_streams: 100
           .... [further cluster config]
    [#next-free-field: 9]

    Oneofs:
        - upstream_protocol_options: This controls the actual protocol to be used upstream.
    """

    common_http_protocol_options: "____config__core__v3__.HttpProtocolOptions | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This contains options common across HTTP/1 and HTTP/2
    """

    upstream_http_protocol_options: "____config__core__v3__.UpstreamHttpProtocolOptions | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This contains common protocol options which are only applied upstream.
    """

    explicit_http_config: "HttpProtocolOptionsExplicitHttpConfig | None" = (
        betterproto2.field(
            3,
            betterproto2.TYPE_MESSAGE,
            optional=True,
            group="upstream_protocol_options",
        )
    )
    """
    To explicitly configure either HTTP/1 or HTTP/2 (but not both!) use ``explicit_http_config``.
    """

    use_downstream_protocol_config: "HttpProtocolOptionsUseDownstreamHttpConfig | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="upstream_protocol_options"
    )
    """
    This allows switching on protocol based on what protocol the downstream
    connection used.
    """

    auto_config: "HttpProtocolOptionsAutoHttpConfig | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="upstream_protocol_options"
    )
    """
    This allows switching on protocol based on ALPN
    """

    http_filters: "list[___filters__network__http_connection_manager__v3__.HttpFilter]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional HTTP filters for the upstream HTTP filter chain.

    .. note::
      Upstream HTTP filters are currently in alpha.

    These filters will be applied for all HTTP streams which flow through this
    cluster. Unlike downstream HTTP filters, they will *not* be applied to terminated CONNECT requests.

    If using upstream HTTP filters, please be aware that local errors sent by
    upstream HTTP filters will not trigger retries, and local errors sent by
    upstream HTTP filters will count as a final response if hedging is configured.
    [#extension-category: envoy.filters.http.upstream]
    """

    header_validation_config: "____config__core__v3__.TypedExtensionConfig | None" = (
        betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Configuration options for Unified Header Validation (UHV).
    UHV is an extensible mechanism for checking validity of HTTP responses.

    [#comment:TODO(yanavlasov): Make it a link to the default header validator doc when it becomes visible.]
    Leaving this field unspecified, selects the default header validator ``envoy.http.header_validators.envoy_default``.

    [#not-implemented-hide:]
    [#extension-category: envoy.http.header_validators]
    """

    outlier_detection: "HttpProtocolOptionsOutlierDetection | None" = (
        betterproto2.field(8, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Defines http specific outlier detection parameters.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.upstreams.http.v3", "HttpProtocolOptions", HttpProtocolOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpProtocolOptionsAutoHttpConfig(betterproto2.Message):
    """
    If this is used, the cluster can use either HTTP/1 or HTTP/2, and will use whichever
    protocol is negotiated by ALPN with the upstream.
    Clusters configured with ``AutoHttpConfig`` will use the highest available
    protocol; HTTP/2 if supported, otherwise HTTP/1.
    If the upstream does not support ALPN, ``AutoHttpConfig`` will fail over to HTTP/1.
    This can only be used with transport sockets which support ALPN. Using a
    transport socket which does not support ALPN will result in configuration
    failure. The transport layer may be configured with custom ALPN, but the default ALPN
    for the cluster (or if custom ALPN fails) will be "h2,http/1.1".
    """

    http_protocol_options: "____config__core__v3__.Http1ProtocolOptions | None" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    )

    http2_protocol_options: "____config__core__v3__.Http2ProtocolOptions | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )

    http3_protocol_options: "____config__core__v3__.Http3ProtocolOptions | None" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Unlike HTTP/1 and HTTP/2, HTTP/3 will not be configured unless it is
    present, and (soon) only if there is an indication of server side
    support.
    See :ref:`here <arch_overview_http3_upstream>` for more information on
    when HTTP/3 will be used, and when Envoy will fail over to TCP.

    .. warning::
      QUIC upstream support is currently not ready for internet use.
      Please see :ref:`here <arch_overview_http3>` for details.
    """

    alternate_protocols_cache_options: "____config__core__v3__.AlternateProtocolsCacheOptions | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The presence of alternate protocols cache options causes the use of the
    alternate protocols cache, which is responsible for parsing and caching
    HTTP Alt-Svc headers. This enables the use of HTTP/3 for origins that
    advertise supporting it.

    .. note::
      This is required when HTTP/3 is enabled.
    """


default_message_pool.register_message(
    "envoy.extensions.upstreams.http.v3",
    "HttpProtocolOptions.AutoHttpConfig",
    HttpProtocolOptionsAutoHttpConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpProtocolOptionsExplicitHttpConfig(betterproto2.Message):
    """
    If this is used, the cluster will only operate on one of the possible upstream protocols.
    Note that HTTP/2 or above should generally be used for upstream gRPC clusters.

    Oneofs:
        - protocol_config:
    """

    http_protocol_options: "____config__core__v3__.Http1ProtocolOptions | None" = (
        betterproto2.field(
            1, betterproto2.TYPE_MESSAGE, optional=True, group="protocol_config"
        )
    )

    http2_protocol_options: "____config__core__v3__.Http2ProtocolOptions | None" = (
        betterproto2.field(
            2, betterproto2.TYPE_MESSAGE, optional=True, group="protocol_config"
        )
    )

    http3_protocol_options: "____config__core__v3__.Http3ProtocolOptions | None" = (
        betterproto2.field(
            3, betterproto2.TYPE_MESSAGE, optional=True, group="protocol_config"
        )
    )
    """
    .. warning::
      QUIC upstream support is currently not ready for internet use.
      Please see :ref:`here <arch_overview_http3>` for details.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.extensions.upstreams.http.v3",
    "HttpProtocolOptions.ExplicitHttpConfig",
    HttpProtocolOptionsExplicitHttpConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpProtocolOptionsOutlierDetection(betterproto2.Message):
    error_matcher: "____config__common__matcher__v3__.MatchPredicate | None" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    If specified, only responses matching the matcher will be treated by outlier detection as errors.
    If not specified, only 5xx codes are treated by outlier detection as errors.
    """


default_message_pool.register_message(
    "envoy.extensions.upstreams.http.v3",
    "HttpProtocolOptions.OutlierDetection",
    HttpProtocolOptionsOutlierDetection,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class HttpProtocolOptionsUseDownstreamHttpConfig(betterproto2.Message):
    """
    If this is used, the cluster can use either of the configured protocols, and
    will use whichever protocol was used by the downstream connection.

    If HTTP/3 is configured for downstream and not configured for upstream,
    HTTP/3 requests will fail over to HTTP/2.
    """

    http_protocol_options: "____config__core__v3__.Http1ProtocolOptions | None" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    )

    http2_protocol_options: "____config__core__v3__.Http2ProtocolOptions | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )

    http3_protocol_options: "____config__core__v3__.Http3ProtocolOptions | None" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    .. warning::
      QUIC upstream support is currently not ready for internet use.
      Please see :ref:`here <arch_overview_http3>` for details.
    """


default_message_pool.register_message(
    "envoy.extensions.upstreams.http.v3",
    "HttpProtocolOptions.UseDownstreamHttpConfig",
    HttpProtocolOptionsUseDownstreamHttpConfig,
)


from .....config.common.matcher import v3 as ____config__common__matcher__v3__
from .....config.core import v3 as ____config__core__v3__
from ....filters.network.http_connection_manager import (
    v3 as ___filters__network__http_connection_manager__v3__,
)
