# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/rate_limit_quota/v3/rlqs.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "BucketId",
    "RateLimitQuotaResponse",
    "RateLimitQuotaResponseBucketAction",
    "RateLimitQuotaResponseBucketActionAbandonAction",
    "RateLimitQuotaResponseBucketActionQuotaAssignmentAction",
    "RateLimitQuotaServiceAsyncStub",
    "RateLimitQuotaServiceBase",
    "RateLimitQuotaServiceSyncStub",
    "RateLimitQuotaUsageReports",
    "RateLimitQuotaUsageReportsBucketQuotaUsage",
)

import datetime
import typing
from collections.abc import AsyncIterable, AsyncIterator, Iterable, Iterator
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BucketId(betterproto2.Message):
    """
    The identifier for the bucket. Used to match the bucket between the control plane (RLQS server),
    and the data plane (RLQS client), f.e.:

    * the data plane sends a usage report for requests matched into the bucket with ``BucketId``
      to the control plane
    * the control plane sends an assignment for the bucket with ``BucketId`` to the data plane
      Bucket ID.

    Example:

    .. validated-code-block:: yaml
      :type-name: envoy.service.rate_limit_quota.v3.BucketId

      bucket:
        name: my_bucket
        env: staging

    .. note::
      The order of ``BucketId`` keys do not matter. Buckets ``{ a: 'A', b: 'B' }`` and
      ``{ b: 'B', a: 'A' }`` are identical.
    """

    bucket: "dict[str, str]" = betterproto2.field(
        1,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )


default_message_pool.register_message(
    "envoy.service.rate_limit_quota.v3", "BucketId", BucketId
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitQuotaResponse(betterproto2.Message):
    bucket_action: "list[RateLimitQuotaResponseBucketAction]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    An ordered list of actions to be applied to the buckets. The actions are applied in the
    given order, from top to bottom.
    """


default_message_pool.register_message(
    "envoy.service.rate_limit_quota.v3",
    "RateLimitQuotaResponse",
    RateLimitQuotaResponse,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitQuotaResponseBucketAction(betterproto2.Message):
    """
    Commands the data plane to apply one of the actions to the bucket with the
    :ref:`bucket_id <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.

    Oneofs:
        - bucket_action:
    """

    bucket_id: "BucketId | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ``BucketId`` for which request the action is applied.
    """

    quota_assignment_action: "RateLimitQuotaResponseBucketActionQuotaAssignmentAction | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="bucket_action"
    )
    """
    Apply the quota assignment to the bucket.

    Commands the data plane to apply a rate limiting strategy to the bucket.
    The process of applying and expiring the rate limiting strategy is detailed in the
    :ref:`QuotaAssignmentAction
    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`
    message.
    """

    abandon_action: "RateLimitQuotaResponseBucketActionAbandonAction | None" = (
        betterproto2.field(
            3, betterproto2.TYPE_MESSAGE, optional=True, group="bucket_action"
        )
    )
    """
    Abandon the bucket.

    Commands the data plane to abandon the bucket.
    The process of abandoning the bucket is described in the :ref:`AbandonAction
    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
    message.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.service.rate_limit_quota.v3",
    "RateLimitQuotaResponse.BucketAction",
    RateLimitQuotaResponseBucketAction,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitQuotaResponseBucketActionAbandonAction(betterproto2.Message):
    """
    Abandon action for the bucket. Indicates that the RLQS server will no longer be
    sending updates for the given :ref:`bucket_id
    <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.

    If no requests are reported for a bucket, after some time the server considers the bucket
    inactive. The server stops tracking the bucket, and instructs the the data plane to abandon
    the bucket via this message.

    **Abandoning the assignment**

    The data plane is to erase the bucket (including its usage data) from the memory.
    It should stop tracking the bucket, and stop reporting its usage. This effectively resets
    the data plane to the state prior to matching the first request into the bucket.

    **Restarting the subscription**

    If a new request is matched into a bucket previously abandoned, the data plane must behave
    as if it has never tracked the bucket, and it's the first request matched into it:

    1. The process of :ref:`subscription and reporting
       <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.reporting_interval>`
       starts from the beginning.

    2. The bucket transitions to the :ref:`"no assignment"
       <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.no_assignment_behavior>`
       state.

    3. Once the new assignment is received, it's applied per
       "Applying the first assignment to the bucket" section of the :ref:`QuotaAssignmentAction
       <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`.
    """

    pass


default_message_pool.register_message(
    "envoy.service.rate_limit_quota.v3",
    "RateLimitQuotaResponse.BucketAction.AbandonAction",
    RateLimitQuotaResponseBucketActionAbandonAction,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitQuotaResponseBucketActionQuotaAssignmentAction(betterproto2.Message):
    """
    Quota assignment for the bucket. Configures the rate limiting strategy and the duration
    for the given :ref:`bucket_id
    <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.bucket_id>`.

    **Applying the first assignment to the bucket**

    Once the data plane receives the ``QuotaAssignmentAction``, it must send the current usage
    report for the bucket, and start rate limiting requests matched into the bucket
    using the strategy configured in the :ref:`rate_limit_strategy
    <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.rate_limit_strategy>`
    field. The assignment becomes bucket's ``active`` assignment.

    **Expiring the assignment**

    The duration of the assignment defined in the :ref:`assignment_time_to_live
    <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.assignment_time_to_live>`
    field. When the duration runs off, the assignment is ``expired``, and no longer ``active``.
    The data plane should stop applying the rate limiting strategy to the bucket, and transition
    the bucket to the "expired assignment" state. This activates the behavior configured in the
    :ref:`expired_assignment_behavior <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.expired_assignment_behavior>`
    field.

    **Replacing the assignment**

    * If the rate limiting strategy is different from bucket's ``active`` assignment, or
      the current bucket assignment is ``expired``, the data plane must immediately
      end the current assignment, report the bucket usage, and apply the new assignment.
      The new assignment becomes bucket's ``active`` assignment.
    * If the rate limiting strategy is the same as the bucket's ``active`` (not ``expired``)
      assignment, the data plane should extend the duration of the ``active`` assignment
      for the duration of the new assignment provided in the :ref:`assignment_time_to_live
      <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction.assignment_time_to_live>`
      field. The ``active`` assignment is considered unchanged.
    """

    assignment_time_to_live: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    A duration after which the assignment is be considered ``expired``. The process of the
    expiration is described :ref:`above
    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`.

    * If unset, the assignment has no expiration date.
    * If set to ``0``, the assignment expires immediately, forcing the client into the
      :ref:`"expired assignment"
      <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
      state. This may be used by the RLQS server in cases when it needs clients to proactively
      fall back to the pre-configured :ref:`ExpiredAssignmentBehavior
      <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior>`,
      f.e. before the server going into restart.

    .. attention::
      Note that :ref:`expiring
      <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction>`
      the assignment is not the same as :ref:`abandoning
      <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
      the assignment. While expiring the assignment just transitions the bucket to
      the "expired assignment" state; abandoning the assignment completely erases
      the bucket from the data plane memory, and stops the usage reports.
    """

    rate_limit_strategy: "___type__v3__.RateLimitStrategy | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configures the local rate limiter for the request matched to the bucket.
    If not set, allow all requests.
    """


default_message_pool.register_message(
    "envoy.service.rate_limit_quota.v3",
    "RateLimitQuotaResponse.BucketAction.QuotaAssignmentAction",
    RateLimitQuotaResponseBucketActionQuotaAssignmentAction,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitQuotaUsageReports(betterproto2.Message):
    domain: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    All quota requests must specify the domain. This enables sharing the quota
    server between different applications without fear of overlap.
    E.g., "envoy".

    Should only be provided in the first report, all subsequent messages on the same
    stream are considered to be in the same domain. In case the domain needs to be
    changes, close the stream, and reopen a new one with the different domain.
    """

    bucket_quota_usages: "list[RateLimitQuotaUsageReportsBucketQuotaUsage]" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    A list of quota usage reports. The list is processed by the RLQS server in the same order
    it's provided by the client.
    """


default_message_pool.register_message(
    "envoy.service.rate_limit_quota.v3",
    "RateLimitQuotaUsageReports",
    RateLimitQuotaUsageReports,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RateLimitQuotaUsageReportsBucketQuotaUsage(betterproto2.Message):
    """
    The usage report for a bucket.

    .. note::
      Note that the first report sent for a ``BucketId`` indicates to the RLQS server that
      the RLQS client is subscribing for the future assignments for this ``BucketId``.
    """

    bucket_id: "BucketId | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    ``BucketId`` for which request quota usage is reported.
    """

    time_elapsed: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    Time elapsed since the last report.
    """

    num_requests_allowed: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        3, betterproto2.TYPE_UINT64
    )
    """
    Requests the data plane has allowed through.
    """

    num_requests_denied: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(4, betterproto2.TYPE_UINT64)
    )
    """
    Requests throttled.
    """


default_message_pool.register_message(
    "envoy.service.rate_limit_quota.v3",
    "RateLimitQuotaUsageReports.BucketQuotaUsage",
    RateLimitQuotaUsageReportsBucketQuotaUsage,
)


class RateLimitQuotaServiceSyncStub:
    """
    [#protodoc-title: Rate Limit Quota Service (RLQS)]

    The Rate Limit Quota Service (RLQS) is a Envoy global rate limiting service that allows to
    delegate rate limit decisions to a remote service. The service will aggregate the usage reports
    from multiple data plane instances, and distribute Rate Limit Assignments to each instance
    based on its business logic. The logic is outside of the scope of the protocol API.

    The protocol is designed as a streaming-first API. It utilizes watch-like subscription model.
    The data plane groups requests into Quota Buckets as directed by the filter config,
    and periodically reports them to the RLQS server along with the Bucket identifier, :ref:`BucketId
    <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>`. Once RLQS server has collected enough
    reports to make a decision, it'll send back the assignment with the rate limiting instructions.

    The first report sent by the data plane is interpreted by the RLQS server as a "watch" request,
    indicating that the data plane instance is interested in receiving further updates for the
    ``BucketId``. From then on, RLQS server may push assignments to this instance at will, even if
    the instance is not sending usage reports. It's the responsibility of the RLQS server
    to determine when the data plane instance didn't send ``BucketId`` reports for too long,
    and to respond with the :ref:`AbandonAction
    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`,
    indicating that the server has now stopped sending quota assignments for the ``BucketId`` bucket,
    and the data plane instance should :ref:`abandon
    <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.abandon_action>`
    it.

    If for any reason the RLQS client doesn't receive the initial assignment for the reported bucket,
    in order to prevent memory exhaustion, the data plane will limit the time such bucket
    is retained. The exact time to wait for the initial assignment is chosen by the filter,
    and may vary based on the implementation.
    Once the duration ends, the data plane will stop reporting bucket usage, reject any enqueued
    requests, and purge the bucket from the memory. Subsequent requests matched into the bucket
    will re-initialize the bucket in the "no assignment" state, restarting the reports.

    Refer to Rate Limit Quota :ref:`configuration overview <config_http_filters_rate_limit_quota>`
    for further details.

    Defines the Rate Limit Quota Service (RLQS).
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_rate_limit_quotas(
        self, messages: "Iterable[RateLimitQuotaUsageReports]"
    ) -> "Iterator[RateLimitQuotaResponse]":
        """
        Main communication channel: the data plane sends usage reports to the RLQS server,
        and the server asynchronously responding with the assignments.
        """

        yield from self._channel.stream_stream(
            "/envoy.service.rate_limit_quota.v3.RateLimitQuotaService/StreamRateLimitQuotas",
            RateLimitQuotaUsageReports.SerializeToString,
            RateLimitQuotaResponse.FromString,
        )(iter(messages))


class RateLimitQuotaServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Rate Limit Quota Service (RLQS)]

    The Rate Limit Quota Service (RLQS) is a Envoy global rate limiting service that allows to
    delegate rate limit decisions to a remote service. The service will aggregate the usage reports
    from multiple data plane instances, and distribute Rate Limit Assignments to each instance
    based on its business logic. The logic is outside of the scope of the protocol API.

    The protocol is designed as a streaming-first API. It utilizes watch-like subscription model.
    The data plane groups requests into Quota Buckets as directed by the filter config,
    and periodically reports them to the RLQS server along with the Bucket identifier, :ref:`BucketId
    <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>`. Once RLQS server has collected enough
    reports to make a decision, it'll send back the assignment with the rate limiting instructions.

    The first report sent by the data plane is interpreted by the RLQS server as a "watch" request,
    indicating that the data plane instance is interested in receiving further updates for the
    ``BucketId``. From then on, RLQS server may push assignments to this instance at will, even if
    the instance is not sending usage reports. It's the responsibility of the RLQS server
    to determine when the data plane instance didn't send ``BucketId`` reports for too long,
    and to respond with the :ref:`AbandonAction
    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`,
    indicating that the server has now stopped sending quota assignments for the ``BucketId`` bucket,
    and the data plane instance should :ref:`abandon
    <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.abandon_action>`
    it.

    If for any reason the RLQS client doesn't receive the initial assignment for the reported bucket,
    in order to prevent memory exhaustion, the data plane will limit the time such bucket
    is retained. The exact time to wait for the initial assignment is chosen by the filter,
    and may vary based on the implementation.
    Once the duration ends, the data plane will stop reporting bucket usage, reject any enqueued
    requests, and purge the bucket from the memory. Subsequent requests matched into the bucket
    will re-initialize the bucket in the "no assignment" state, restarting the reports.

    Refer to Rate Limit Quota :ref:`configuration overview <config_http_filters_rate_limit_quota>`
    for further details.

    Defines the Rate Limit Quota Service (RLQS).
    """

    async def stream_rate_limit_quotas(
        self,
        messages: "AsyncIterable[RateLimitQuotaUsageReports] | Iterable[RateLimitQuotaUsageReports]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[RateLimitQuotaResponse]":
        """
        Main communication channel: the data plane sends usage reports to the RLQS server,
        and the server asynchronously responding with the assignments.
        """

        async for response in self._stream_stream(
            "/envoy.service.rate_limit_quota.v3.RateLimitQuotaService/StreamRateLimitQuotas",
            messages,
            RateLimitQuotaUsageReports,
            RateLimitQuotaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


from .....google import protobuf as ____google__protobuf__
from ....type import v3 as ___type__v3__


class RateLimitQuotaServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Rate Limit Quota Service (RLQS)]

    The Rate Limit Quota Service (RLQS) is a Envoy global rate limiting service that allows to
    delegate rate limit decisions to a remote service. The service will aggregate the usage reports
    from multiple data plane instances, and distribute Rate Limit Assignments to each instance
    based on its business logic. The logic is outside of the scope of the protocol API.

    The protocol is designed as a streaming-first API. It utilizes watch-like subscription model.
    The data plane groups requests into Quota Buckets as directed by the filter config,
    and periodically reports them to the RLQS server along with the Bucket identifier, :ref:`BucketId
    <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>`. Once RLQS server has collected enough
    reports to make a decision, it'll send back the assignment with the rate limiting instructions.

    The first report sent by the data plane is interpreted by the RLQS server as a "watch" request,
    indicating that the data plane instance is interested in receiving further updates for the
    ``BucketId``. From then on, RLQS server may push assignments to this instance at will, even if
    the instance is not sending usage reports. It's the responsibility of the RLQS server
    to determine when the data plane instance didn't send ``BucketId`` reports for too long,
    and to respond with the :ref:`AbandonAction
    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`,
    indicating that the server has now stopped sending quota assignments for the ``BucketId`` bucket,
    and the data plane instance should :ref:`abandon
    <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.abandon_action>`
    it.

    If for any reason the RLQS client doesn't receive the initial assignment for the reported bucket,
    in order to prevent memory exhaustion, the data plane will limit the time such bucket
    is retained. The exact time to wait for the initial assignment is chosen by the filter,
    and may vary based on the implementation.
    Once the duration ends, the data plane will stop reporting bucket usage, reject any enqueued
    requests, and purge the bucket from the memory. Subsequent requests matched into the bucket
    will re-initialize the bucket in the "no assignment" state, restarting the reports.

    Refer to Rate Limit Quota :ref:`configuration overview <config_http_filters_rate_limit_quota>`
    for further details.

    Defines the Rate Limit Quota Service (RLQS).
    """

    async def stream_rate_limit_quotas(
        self, messages: "AsyncIterator[RateLimitQuotaUsageReports]"
    ) -> "AsyncIterator[RateLimitQuotaResponse]":
        """
        Main communication channel: the data plane sends usage reports to the RLQS server,
        and the server asynchronously responding with the assignments.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield RateLimitQuotaResponse()

    async def __rpc_stream_rate_limit_quotas(
        self,
        stream: "grpclib.server.Stream[RateLimitQuotaUsageReports, RateLimitQuotaResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_rate_limit_quotas,
            stream,
            request,
        )

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.rate_limit_quota.v3.RateLimitQuotaService/StreamRateLimitQuotas": grpclib.const.Handler(
                self.__rpc_stream_rate_limit_quotas,
                grpclib.const.Cardinality.STREAM_STREAM,
                RateLimitQuotaUsageReports,
                RateLimitQuotaResponse,
            ),
        }
