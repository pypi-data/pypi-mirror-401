# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/tap/v3/tap.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "StreamTapsRequest",
    "StreamTapsRequestIdentifier",
    "StreamTapsResponse",
    "TapSinkServiceAsyncStub",
    "TapSinkServiceBase",
    "TapSinkServiceSyncStub",
)

import typing
from collections.abc import AsyncIterable, AsyncIterator, Iterable
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamTapsRequest(betterproto2.Message):
    """
    [#not-implemented-hide:] Stream message for the Tap API. Envoy will open a stream to the server
    and stream taps without ever expecting a response.
    """

    identifier: "StreamTapsRequestIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Identifier data effectively is a structured metadata. As a performance optimization this will
    only be sent in the first message on the stream.
    """

    trace_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )
    """
    The trace id. this can be used to merge together a streaming trace. Note that the trace_id
    is not guaranteed to be spatially or temporally unique.
    """

    trace: "___data__tap__v3__.TraceWrapper | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The trace data.
    """


default_message_pool.register_message(
    "envoy.service.tap.v3", "StreamTapsRequest", StreamTapsRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamTapsRequestIdentifier(betterproto2.Message):
    node: "___config__core__v3__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node sending taps over the stream.
    """

    tap_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The opaque identifier that was set in the :ref:`output config
    <envoy_v3_api_field_config.tap.v3.StreamingGrpcSink.tap_id>`.
    """


default_message_pool.register_message(
    "envoy.service.tap.v3", "StreamTapsRequest.Identifier", StreamTapsRequestIdentifier
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StreamTapsResponse(betterproto2.Message):
    """
    [#not-implemented-hide:]
    """

    pass


default_message_pool.register_message(
    "envoy.service.tap.v3", "StreamTapsResponse", StreamTapsResponse
)


class TapSinkServiceSyncStub:
    """
    [#protodoc-title: Tap sink service]

    [#not-implemented-hide:] A tap service to receive incoming taps. Envoy will call
    StreamTaps to deliver captured taps to the server
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_taps(
        self, messages: "Iterable[StreamTapsRequest]"
    ) -> "StreamTapsResponse":
        """
        Envoy will connect and send StreamTapsRequest messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect.
        """

        return self._channel.stream_unary(
            "/envoy.service.tap.v3.TapSinkService/StreamTaps",
            StreamTapsRequest.SerializeToString,
            StreamTapsResponse.FromString,
        )(iter(messages))


class TapSinkServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Tap sink service]

    [#not-implemented-hide:] A tap service to receive incoming taps. Envoy will call
    StreamTaps to deliver captured taps to the server
    """

    async def stream_taps(
        self,
        messages: "AsyncIterable[StreamTapsRequest] | Iterable[StreamTapsRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "StreamTapsResponse":
        """
        Envoy will connect and send StreamTapsRequest messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect.
        """

        return await self._stream_unary(
            "/envoy.service.tap.v3.TapSinkService/StreamTaps",
            messages,
            StreamTapsRequest,
            StreamTapsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from ....config.core import v3 as ___config__core__v3__
from ....data.tap import v3 as ___data__tap__v3__


class TapSinkServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Tap sink service]

    [#not-implemented-hide:] A tap service to receive incoming taps. Envoy will call
    StreamTaps to deliver captured taps to the server
    """

    async def stream_taps(
        self, messages: "AsyncIterator[StreamTapsRequest]"
    ) -> "StreamTapsResponse":
        """
        Envoy will connect and send StreamTapsRequest messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_taps(
        self, stream: "grpclib.server.Stream[StreamTapsRequest, StreamTapsResponse]"
    ) -> None:
        request = stream.__aiter__()
        response = await self.stream_taps(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.service.tap.v3.TapSinkService/StreamTaps": grpclib.const.Handler(
                self.__rpc_stream_taps,
                grpclib.const.Cardinality.STREAM_UNARY,
                StreamTapsRequest,
                StreamTapsResponse,
            ),
        }
