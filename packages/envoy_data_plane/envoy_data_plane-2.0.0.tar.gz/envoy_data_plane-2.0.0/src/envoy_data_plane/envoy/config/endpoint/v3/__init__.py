# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/endpoint/v3/endpoint.proto, envoy/config/endpoint/v3/endpoint_components.proto, envoy/config/endpoint/v3/load_report.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "ClusterLoadAssignment",
    "ClusterLoadAssignmentPolicy",
    "ClusterLoadAssignmentPolicyDropOverload",
    "ClusterStats",
    "ClusterStatsDroppedRequests",
    "Endpoint",
    "EndpointAdditionalAddress",
    "EndpointHealthCheckConfig",
    "EndpointLoadMetricStats",
    "LbEndpoint",
    "LbEndpointCollection",
    "LedsClusterLocalityConfig",
    "LocalityLbEndpoints",
    "LocalityLbEndpointsLbEndpointList",
    "UnnamedEndpointLoadMetricStats",
    "UpstreamEndpointStats",
    "UpstreamLocalityStats",
)

import datetime
import typing
import warnings

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLoadAssignment(betterproto2.Message):
    """
    [#protodoc-title: Endpoint configuration]
    Endpoint discovery :ref:`architecture overview <arch_overview_service_discovery_types_eds>`

    Each route from RDS will map to a single cluster or traffic split across
    clusters using weights expressed in the RDS WeightedCluster.

    With EDS, each cluster is treated independently from a LB perspective, with
    LB taking place between the Localities within a cluster and at a finer
    granularity between the hosts within a locality. The percentage of traffic
    for each endpoint is determined by both its load_balancing_weight, and the
    load_balancing_weight of its locality. First, a locality will be selected,
    then an endpoint within that locality will be chose based on its weight.
    [#next-free-field: 6]
    """

    cluster_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Name of the cluster. This will be the :ref:`service_name
    <envoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.service_name>` value if specified
    in the cluster :ref:`EdsClusterConfig
    <envoy_v3_api_msg_config.cluster.v3.Cluster.EdsClusterConfig>`.
    """

    endpoints: "list[LocalityLbEndpoints]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of endpoints to load balance to.
    """

    named_endpoints: "dict[str, Endpoint]" = betterproto2.field(
        5,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Map of named endpoints that can be referenced in LocalityLbEndpoints.
    [#not-implemented-hide:]
    """

    policy: "ClusterLoadAssignmentPolicy | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Load balancing policy settings.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "ClusterLoadAssignment", ClusterLoadAssignment
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLoadAssignmentPolicy(betterproto2.Message):
    """
    Load balancing policy settings.
    [#next-free-field: 7]
    """

    drop_overloads: "list[ClusterLoadAssignmentPolicyDropOverload]" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Action to trim the overall incoming traffic to protect the upstream
    hosts. This action allows protection in case the hosts are unable to
    recover from an outage, or unable to autoscale or unable to handle
    incoming traffic volume for any reason.

    At the client each category is applied one after the other to generate
    the 'actual' drop percentage on all outgoing traffic. For example:

    .. code-block:: json

     { "drop_overloads": [
         { "category": "throttle", "drop_percentage": 60 }
         { "category": "lb", "drop_percentage": 50 }
     ]}

    The actual drop percentages applied to the traffic at the clients will be
       "throttle"_drop = 60%
       "lb"_drop = 20%  // 50% of the remaining 'actual' load, which is 40%.
       actual_outgoing_load = 20% // remaining after applying all categories.

    Envoy supports only one element and will NACK if more than one element is present.
    Other xDS-capable data planes will not necessarily have this limitation.

    In Envoy, this ``drop_overloads`` config can be overridden by a runtime key
    "load_balancing_policy.drop_overload_limit" setting. This runtime key can be set to
    any integer number between 0 and 100. 0 means drop 0%. 100 means drop 100%.
    When both ``drop_overloads`` config and "load_balancing_policy.drop_overload_limit"
    setting are in place, the min of these two wins.
    """

    overprovisioning_factor: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Priority levels and localities are considered overprovisioned with this
    factor (in percentage). This means that we don't consider a priority
    level or locality unhealthy until the fraction of healthy hosts
    multiplied by the overprovisioning factor drops below 100.
    With the default value 140(1.4), Envoy doesn't consider a priority level
    or a locality unhealthy until their percentage of healthy hosts drops
    below 72%. For example:

    .. code-block:: json

     { "overprovisioning_factor": 100 }

    Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>` and
    :ref:`localities <arch_overview_load_balancing_locality_weighted_lb>`.
    """

    endpoint_stale_after: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The max time until which the endpoints from this assignment can be used.
    If no new assignments are received before this time expires the endpoints
    are considered stale and should be marked unhealthy.
    Defaults to 0 which means endpoints never go stale.
    """

    weighted_priority_health: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    If true, use the :ref:`load balancing weight
    <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.load_balancing_weight>` of healthy and unhealthy
    hosts to determine the health of the priority level. If false, use the number of healthy and unhealthy hosts
    to determine the health of the priority level, or in other words assume each host has a weight of 1 for
    this calculation.

    .. note::
      This is not currently implemented for
      :ref:`locality weighted load balancing <arch_overview_load_balancing_locality_weighted_lb>`.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3",
    "ClusterLoadAssignment.Policy",
    ClusterLoadAssignmentPolicy,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLoadAssignmentPolicyDropOverload(betterproto2.Message):
    category: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Identifier for the policy specifying the drop.
    """

    drop_percentage: "___type__v3__.FractionalPercent | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Percentage of traffic that should be dropped for the category.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3",
    "ClusterLoadAssignment.Policy.DropOverload",
    ClusterLoadAssignmentPolicyDropOverload,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterStats(betterproto2.Message):
    """
    Per cluster load stats. Envoy reports these stats a management server in a
    :ref:`LoadStatsRequest<envoy_v3_api_msg_service.load_stats.v3.LoadStatsRequest>`
    Next ID: 7
    [#next-free-field: 7]
    """

    cluster_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the cluster.
    """

    cluster_service_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        6, betterproto2.TYPE_STRING
    )
    """
    The eds_cluster_config service_name of the cluster.
    It's possible that two clusters send the same service_name to EDS,
    in that case, the management server is supposed to do aggregation on the load reports.
    """

    upstream_locality_stats: "list[UpstreamLocalityStats]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Need at least one.
    """

    total_dropped_requests: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        3, betterproto2.TYPE_UINT64
    )
    """
    Cluster-level stats such as total_successful_requests may be computed by
    summing upstream_locality_stats. In addition, below there are additional
    cluster-wide stats.

    The total number of dropped requests. This covers requests
    deliberately dropped by the drop_overload policy and circuit breaking.
    """

    dropped_requests: "list[ClusterStatsDroppedRequests]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Information about deliberately dropped requests for each category specified
    in the DropOverload policy.
    """

    load_report_interval: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    Period over which the actual load report occurred. This will be guaranteed to include every
    request reported. Due to system load and delays between the ``LoadStatsRequest`` sent from Envoy
    and the ``LoadStatsResponse`` message sent from the management server, this may be longer than
    the requested load reporting interval in the ``LoadStatsResponse``.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "ClusterStats", ClusterStats
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterStatsDroppedRequests(betterproto2.Message):
    category: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Identifier for the policy specifying the drop.
    """

    dropped_count: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )
    """
    Total number of deliberately dropped requests for the category.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3",
    "ClusterStats.DroppedRequests",
    ClusterStatsDroppedRequests,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Endpoint(betterproto2.Message):
    """
    [#protodoc-title: Endpoints]

    Upstream host identifier.
    """

    address: "__core__v3__.Address | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The upstream host address.

    .. attention::

      The form of host address depends on the given cluster type. For STATIC or EDS,
      it is expected to be a direct IP address (or something resolvable by the
      specified :ref:`resolver <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`
      in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
      and will be resolved via DNS.
    """

    health_check_config: "EndpointHealthCheckConfig | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The optional health check configuration is used as configuration for the
    health checker to contact the health checked host.

    .. attention::

      This takes into effect only for upstream clusters with
      :ref:`active health checking <arch_overview_health_checking>` enabled.
    """

    hostname: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    The hostname associated with this endpoint. This hostname is not used for routing or address
    resolution. If provided, it will be associated with the endpoint, and can be used for features
    that require a hostname, like
    :ref:`auto_host_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`.
    """

    additional_addresses: "list[EndpointAdditionalAddress]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    An ordered list of addresses that together with ``address`` comprise the
    list of addresses for an endpoint. The address given in the ``address`` is
    prepended to this list. It is assumed that the list must already be
    sorted by preference order of the addresses. This will only be supported
    for STATIC and EDS clusters.
    """


default_message_pool.register_message("envoy.config.endpoint.v3", "Endpoint", Endpoint)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EndpointAdditionalAddress(betterproto2.Message):
    address: "__core__v3__.Address | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional address that is associated with the endpoint.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "Endpoint.AdditionalAddress", EndpointAdditionalAddress
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EndpointHealthCheckConfig(betterproto2.Message):
    """
    The optional health check configuration.
    """

    port_value: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    Optional alternative health check port value.

    By default the health check address port of an upstream host is the same
    as the host's serving address port. This provides an alternative health
    check port. Setting this with a non-zero value allows an upstream host
    to have different health check address port.
    """

    hostname: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    By default, the host header for L7 health checks is controlled by cluster level configuration
    (see: :ref:`host <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.host>` and
    :ref:`authority <envoy_v3_api_field_config.core.v3.HealthCheck.GrpcHealthCheck.authority>`). Setting this
    to a non-empty value allows overriding the cluster level configuration for a specific
    endpoint.
    """

    address: "__core__v3__.Address | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional alternative health check host address.

    .. attention::

      The form of the health check host address is expected to be a direct IP address.
    """

    disable_active_health_check: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Optional flag to control if perform active health check for this endpoint.
    Active health check is enabled by default if there is a health checker.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "Endpoint.HealthCheckConfig", EndpointHealthCheckConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EndpointLoadMetricStats(betterproto2.Message):
    metric_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Name of the metric; may be empty.
    """

    num_requests_finished_with_metric: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        2, betterproto2.TYPE_UINT64
    )
    """
    Number of calls that finished and included this metric.
    """

    total_metric_value: "float" = betterproto2.field(3, betterproto2.TYPE_DOUBLE)
    """
    Sum of metric values across all calls that finished with this metric for
    load_reporting_interval.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "EndpointLoadMetricStats", EndpointLoadMetricStats
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LbEndpoint(betterproto2.Message):
    """
    An Endpoint that Envoy can route traffic to.
    [#next-free-field: 6]

    Oneofs:
        - host_identifier: Upstream host identifier or a named reference.
    """

    endpoint: "Endpoint | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="host_identifier"
    )

    endpoint_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True, group="host_identifier"
    )
    """
    [#not-implemented-hide:]
    """

    health_status: "__core__v3__.HealthStatus" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: __core__v3__.HealthStatus(0)
    )
    """
    Optional health status when known and supplied by EDS server.
    """

    metadata: "__core__v3__.Metadata | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The endpoint metadata specifies values that may be used by the load
    balancer to select endpoints in a cluster for a given request. The filter
    name should be specified as ``envoy.lb``. An example boolean key-value pair
    is ``canary``, providing the optional canary status of the upstream host.
    This may be matched against in a route's
    :ref:`RouteAction <envoy_v3_api_msg_config.route.v3.RouteAction>` metadata_match field
    to subset the endpoints considered in cluster load balancing.
    """

    load_balancing_weight: "int | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The optional load balancing weight of the upstream host; at least 1.
    Envoy uses the load balancing weight in some of the built in load
    balancers. The load balancing weight for an endpoint is divided by the sum
    of the weights of all endpoints in the endpoint's locality to produce a
    percentage of traffic for the endpoint. This percentage is then further
    weighted by the endpoint's locality's load balancing weight from
    LocalityLbEndpoints. If unspecified, will be treated as 1. The sum
    of the weights of all endpoints in the endpoint's locality must not
    exceed uint32_t maximal value (4294967295).
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "LbEndpoint", LbEndpoint
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LbEndpointCollection(betterproto2.Message):
    """
    LbEndpoint list collection. Entries are `LbEndpoint` resources or references.
    [#not-implemented-hide:]
    """

    entries: "____xds__core__v3__.CollectionEntry | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "LbEndpointCollection", LbEndpointCollection
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LedsClusterLocalityConfig(betterproto2.Message):
    """
    A configuration for an LEDS collection.
    """

    leds_config: "__core__v3__.ConfigSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configuration for the source of LEDS updates for a Locality.
    """

    leds_collection_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The name of the LbEndpoint collection resource.

    If the name ends in ``/*``, it indicates an LbEndpoint glob collection,
    which is supported only in the xDS incremental protocol variants.
    Otherwise, it indicates an LbEndpointCollection list collection.

    Envoy currently supports only glob collections.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "LedsClusterLocalityConfig", LedsClusterLocalityConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LocalityLbEndpoints(betterproto2.Message):
    """
    A group of endpoints belonging to a Locality.
    One can have multiple LocalityLbEndpoints for a locality, but only if
    they have different priorities.
    [#next-free-field: 10]

    Oneofs:
        - lb_config:
    """

    locality: "__core__v3__.Locality | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Identifies location of where the upstream hosts run.
    """

    metadata: "__core__v3__.Metadata | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Metadata to provide additional information about the locality endpoints in aggregate.
    """

    lb_endpoints: "list[LbEndpoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The group of endpoints belonging to the locality specified.
    This is ignored if :ref:`leds_cluster_locality_config
    <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.leds_cluster_locality_config>` is set.
    """

    load_balancer_endpoints: "LocalityLbEndpointsLbEndpointList | None" = (
        betterproto2.field(
            7, betterproto2.TYPE_MESSAGE, optional=True, group="lb_config"
        )
    )
    """
    [#not-implemented-hide:]
    Not implemented and deprecated.
    """

    leds_cluster_locality_config: "LedsClusterLocalityConfig | None" = (
        betterproto2.field(
            8, betterproto2.TYPE_MESSAGE, optional=True, group="lb_config"
        )
    )
    """
    LEDS Configuration for the current locality.
    If this is set, the :ref:`lb_endpoints
    <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.lb_endpoints>`
    field is ignored.
    """

    load_balancing_weight: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
    balancing weight for a locality is divided by the sum of the weights of all
    localities  at the same priority level to produce the effective percentage
    of traffic for the locality. The sum of the weights of all localities at
    the same priority level must not exceed uint32_t maximal value (4294967295).

    Locality weights are only considered when :ref:`locality weighted load
    balancing <arch_overview_load_balancing_locality_weighted_lb>` is
    configured. These weights are ignored otherwise. If no weights are
    specified when locality weighted load balancing is enabled, the locality is
    assigned no load.
    """

    priority: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(5, betterproto2.TYPE_UINT32)
    )
    """
    Optional: the priority for this LocalityLbEndpoints. If unspecified this will
    default to the highest priority (0).

    Under usual circumstances, Envoy will only select endpoints for the highest
    priority (0). In the event that enough endpoints for a particular priority are
    unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
    next highest priority group. Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>`.

    Priorities should range from 0 (highest) to N (lowest) without skipping.
    """

    proximity: "int | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Optional: Per locality proximity value which indicates how close this
    locality is from the source locality. This value only provides ordering
    information (lower the value, closer it is to the source locality).
    This will be consumed by load balancing schemes that need proximity order
    to determine where to route the requests.
    [#not-implemented-hide:]
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("load_balancer_endpoints"):
            warnings.warn(
                "LocalityLbEndpoints.load_balancer_endpoints is deprecated",
                DeprecationWarning,
            )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "LocalityLbEndpoints", LocalityLbEndpoints
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LocalityLbEndpointsLbEndpointList(betterproto2.Message):
    """
    [#not-implemented-hide:]
    A list of endpoints of a specific locality.
    """

    lb_endpoints: "list[LbEndpoint]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.config.endpoint.v3",
    "LocalityLbEndpoints.LbEndpointList",
    LocalityLbEndpointsLbEndpointList,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UnnamedEndpointLoadMetricStats(betterproto2.Message):
    """
    Same as EndpointLoadMetricStats, except without the metric_name field.
    """

    num_requests_finished_with_metric: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        1, betterproto2.TYPE_UINT64
    )
    """
    Number of calls that finished and included this metric.
    """

    total_metric_value: "float" = betterproto2.field(2, betterproto2.TYPE_DOUBLE)
    """
    Sum of metric values across all calls that finished with this metric for
    load_reporting_interval.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3",
    "UnnamedEndpointLoadMetricStats",
    UnnamedEndpointLoadMetricStats,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UpstreamEndpointStats(betterproto2.Message):
    """
    [#next-free-field: 8]
    """

    address: "__core__v3__.Address | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Upstream host address.
    """

    metadata: "____google__protobuf__.Struct | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Opaque and implementation dependent metadata of the
    endpoint. Envoy will pass this directly to the management server.
    """

    total_successful_requests: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        2, betterproto2.TYPE_UINT64
    )
    """
    The total number of requests successfully completed by the endpoints in the
    locality. These include non-5xx responses for HTTP, where errors
    originate at the client and the endpoint responded successfully. For gRPC,
    the grpc-status values are those not covered by total_error_requests below.
    """

    total_requests_in_progress: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        3, betterproto2.TYPE_UINT64
    )
    """
    The total number of unfinished requests for this endpoint.
    """

    total_error_requests: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        4, betterproto2.TYPE_UINT64
    )
    """
    The total number of requests that failed due to errors at the endpoint.
    For HTTP these are responses with 5xx status codes and for gRPC the
    grpc-status values:

      - DeadlineExceeded
      - Unimplemented
      - Internal
      - Unavailable
      - Unknown
      - DataLoss
    """

    total_issued_requests: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        7, betterproto2.TYPE_UINT64
    )
    """
    The total number of requests that were issued to this endpoint
    since the last report. A single TCP connection, HTTP or gRPC
    request or stream is counted as one request.
    """

    load_metric_stats: "list[EndpointLoadMetricStats]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Stats for multi-dimensional load balancing.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "UpstreamEndpointStats", UpstreamEndpointStats
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UpstreamLocalityStats(betterproto2.Message):
    """
    [#protodoc-title: Load Report]

    These are stats Envoy reports to the management server at a frequency defined by
    :ref:`LoadStatsResponse.load_reporting_interval<envoy_v3_api_field_service.load_stats.v3.LoadStatsResponse.load_reporting_interval>`.
    Stats per upstream region/zone and optionally per subzone.
    [#next-free-field: 15]
    """

    locality: "__core__v3__.Locality | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Name of zone, region and optionally endpoint group these metrics were
    collected from. Zone and region names could be empty if unknown.
    """

    total_successful_requests: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        2, betterproto2.TYPE_UINT64
    )
    """
    The total number of requests successfully completed by the endpoints in the
    locality.
    """

    total_requests_in_progress: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        3, betterproto2.TYPE_UINT64
    )
    """
    The total number of unfinished requests. A request can be an HTTP request
    or a TCP connection for a TCP connection pool.
    """

    total_error_requests: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        4, betterproto2.TYPE_UINT64
    )
    """
    The total number of requests that failed due to errors at the endpoint,
    aggregated over all endpoints in the locality.
    """

    total_issued_requests: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        8, betterproto2.TYPE_UINT64
    )
    """
    The total number of requests that were issued by this Envoy since
    the last report. This information is aggregated over all the
    upstream endpoints in the locality. A request can be an HTTP request
    or a TCP connection for a TCP connection pool.
    """

    total_active_connections: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        9, betterproto2.TYPE_UINT64
    )
    """
    The total number of connections in an established state at the time of the
    report. This field is aggregated over all the upstream endpoints in the
    locality.
    In Envoy, this information may be based on ``upstream_cx_active metric``.
    [#not-implemented-hide:]
    """

    total_new_connections: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        10, betterproto2.TYPE_UINT64
    )
    """
    The total number of connections opened since the last report.
    This field is aggregated over all the upstream endpoints in the locality.
    In Envoy, this information may be based on ``upstream_cx_total`` metric
    compared to itself between start and end of an interval, i.e.
    ``upstream_cx_total``(now) - ``upstream_cx_total``(now -
    load_report_interval).
    [#not-implemented-hide:]
    """

    total_fail_connections: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        11, betterproto2.TYPE_UINT64
    )
    """
    The total number of connection failures since the last report.
    This field is aggregated over all the upstream endpoints in the locality.
    In Envoy, this information may be based on ``upstream_cx_connect_fail``
    metric compared to itself between start and end of an interval, i.e.
    ``upstream_cx_connect_fail``(now) - ``upstream_cx_connect_fail``(now -
    load_report_interval).
    [#not-implemented-hide:]
    """

    cpu_utilization: "UnnamedEndpointLoadMetricStats | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    CPU utilization stats for multi-dimensional load balancing.
    This typically comes from endpoint metrics reported via ORCA.
    """

    mem_utilization: "UnnamedEndpointLoadMetricStats | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Memory utilization for multi-dimensional load balancing.
    This typically comes from endpoint metrics reported via ORCA.
    """

    application_utilization: "UnnamedEndpointLoadMetricStats | None" = (
        betterproto2.field(14, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Blended application-defined utilization for multi-dimensional load balancing.
    This typically comes from endpoint metrics reported via ORCA.
    """

    load_metric_stats: "list[EndpointLoadMetricStats]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Named stats for multi-dimensional load balancing.
    These typically come from endpoint metrics reported via ORCA.
    """

    upstream_endpoint_stats: "list[UpstreamEndpointStats]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Endpoint granularity stats information for this locality. This information
    is populated if the Server requests it by setting
    :ref:`LoadStatsResponse.report_endpoint_granularity<envoy_v3_api_field_service.load_stats.v3.LoadStatsResponse.report_endpoint_granularity>`.
    """

    priority: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(6, betterproto2.TYPE_UINT32)
    )
    """
    [#not-implemented-hide:] The priority of the endpoint group these metrics
    were collected from.
    """


default_message_pool.register_message(
    "envoy.config.endpoint.v3", "UpstreamLocalityStats", UpstreamLocalityStats
)


from .....google import protobuf as ____google__protobuf__
from .....xds.core import v3 as ____xds__core__v3__
from ....type import v3 as ___type__v3__
from ...core import v3 as __core__v3__
