# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/api/v2/cds.proto, envoy/api/v2/cluster.proto, envoy/api/v2/discovery.proto, envoy/api/v2/eds.proto, envoy/api/v2/endpoint.proto, envoy/api/v2/lds.proto, envoy/api/v2/listener.proto, envoy/api/v2/rds.proto, envoy/api/v2/route.proto, envoy/api/v2/scoped_route.proto, envoy/api/v2/srds.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "CdsDummy",
    "Cluster",
    "ClusterClusterProtocolSelection",
    "ClusterCommonLbConfig",
    "ClusterCommonLbConfigConsistentHashingLbConfig",
    "ClusterCommonLbConfigLocalityWeightedLbConfig",
    "ClusterCommonLbConfigZoneAwareLbConfig",
    "ClusterCustomClusterType",
    "ClusterDiscoveryServiceAsyncStub",
    "ClusterDiscoveryServiceBase",
    "ClusterDiscoveryServiceSyncStub",
    "ClusterDiscoveryType",
    "ClusterDnsLookupFamily",
    "ClusterEdsClusterConfig",
    "ClusterLbPolicy",
    "ClusterLbSubsetConfig",
    "ClusterLbSubsetConfigLbSubsetFallbackPolicy",
    "ClusterLbSubsetConfigLbSubsetSelector",
    "ClusterLbSubsetConfigLbSubsetSelectorLbSubsetSelectorFallbackPolicy",
    "ClusterLeastRequestLbConfig",
    "ClusterLoadAssignment",
    "ClusterLoadAssignmentPolicy",
    "ClusterLoadAssignmentPolicyDropOverload",
    "ClusterOriginalDstLbConfig",
    "ClusterRefreshRate",
    "ClusterRingHashLbConfig",
    "ClusterRingHashLbConfigHashFunction",
    "ClusterTransportSocketMatch",
    "DeltaDiscoveryRequest",
    "DeltaDiscoveryResponse",
    "DiscoveryRequest",
    "DiscoveryResponse",
    "EdsDummy",
    "EndpointDiscoveryServiceAsyncStub",
    "EndpointDiscoveryServiceBase",
    "EndpointDiscoveryServiceSyncStub",
    "LdsDummy",
    "Listener",
    "ListenerConnectionBalanceConfig",
    "ListenerConnectionBalanceConfigExactBalance",
    "ListenerDeprecatedV1",
    "ListenerDiscoveryServiceAsyncStub",
    "ListenerDiscoveryServiceBase",
    "ListenerDiscoveryServiceSyncStub",
    "ListenerDrainType",
    "LoadBalancingPolicy",
    "LoadBalancingPolicyPolicy",
    "RdsDummy",
    "Resource",
    "RouteConfiguration",
    "RouteDiscoveryServiceAsyncStub",
    "RouteDiscoveryServiceBase",
    "RouteDiscoveryServiceSyncStub",
    "ScopedRouteConfiguration",
    "ScopedRouteConfigurationKey",
    "ScopedRouteConfigurationKeyFragment",
    "ScopedRoutesDiscoveryServiceAsyncStub",
    "ScopedRoutesDiscoveryServiceBase",
    "ScopedRoutesDiscoveryServiceSyncStub",
    "SrdsDummy",
    "UpstreamBindConfig",
    "UpstreamConnectionOptions",
    "Vhds",
    "VirtualHostDiscoveryServiceAsyncStub",
    "VirtualHostDiscoveryServiceBase",
    "VirtualHostDiscoveryServiceSyncStub",
)

import datetime
import typing
import warnings
from collections.abc import AsyncIterable, AsyncIterator, Iterable, Iterator
from typing import TYPE_CHECKING

import betterproto2
import grpc
import grpclib
import pydantic
from betterproto2 import grpclib as betterproto2_grpclib
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from ....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpclib.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ClusterClusterProtocolSelection(betterproto2.Enum):
    USE_CONFIGURED_PROTOCOL = 0
    """
    Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
    If :ref:`http2_protocol_options <envoy_api_field_Cluster.http2_protocol_options>` are
    present, HTTP2 will be used, otherwise HTTP1.1 will be used.
    """

    USE_DOWNSTREAM_PROTOCOL = 1
    """
    Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
    """


class ClusterDiscoveryType(betterproto2.Enum):
    """
    Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
    for an explanation on each type.
    """

    STATIC = 0
    """
    Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
    for an explanation.
    """

    STRICT_DNS = 1
    """
    Refer to the :ref:`strict DNS discovery
    type<arch_overview_service_discovery_types_strict_dns>`
    for an explanation.
    """

    LOGICAL_DNS = 2
    """
    Refer to the :ref:`logical DNS discovery
    type<arch_overview_service_discovery_types_logical_dns>`
    for an explanation.
    """

    EDS = 3
    """
    Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
    for an explanation.
    """

    ORIGINAL_DST = 4
    """
    Refer to the :ref:`original destination discovery
    type<arch_overview_service_discovery_types_original_destination>`
    for an explanation.
    """


class ClusterDnsLookupFamily(betterproto2.Enum):
    """
    When V4_ONLY is selected, the DNS resolver will only perform a lookup for
    addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
    only perform a lookup for addresses in the IPv6 family. If AUTO is
    specified, the DNS resolver will first perform a lookup for addresses in
    the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
    For cluster types other than
    :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
    :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    this setting is
    ignored.
    """

    AUTO = 0

    V4_ONLY = 1

    V6_ONLY = 2


class ClusterLbPolicy(betterproto2.Enum):
    """
    Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
    overview section for information on each type.
    """

    ROUND_ROBIN = 0
    """
    Refer to the :ref:`round robin load balancing
    policy<arch_overview_load_balancing_types_round_robin>`
    for an explanation.
    """

    LEAST_REQUEST = 1
    """
    Refer to the :ref:`least request load balancing
    policy<arch_overview_load_balancing_types_least_request>`
    for an explanation.
    """

    RING_HASH = 2
    """
    Refer to the :ref:`ring hash load balancing
    policy<arch_overview_load_balancing_types_ring_hash>`
    for an explanation.
    """

    RANDOM = 3
    """
    Refer to the :ref:`random load balancing
    policy<arch_overview_load_balancing_types_random>`
    for an explanation.
    """

    ORIGINAL_DST_LB = 4
    """
    Refer to the :ref:`original destination load balancing
    policy<arch_overview_load_balancing_types_original_destination>`
    for an explanation.

    .. attention::

      **This load balancing policy is deprecated**. Use CLUSTER_PROVIDED instead.
    """

    MAGLEV = 5
    """
    Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
    for an explanation.
    """

    CLUSTER_PROVIDED = 6
    """
    This load balancer type must be specified if the configured cluster provides a cluster
    specific load balancer. Consult the configured cluster's documentation for whether to set
    this option or not.
    """

    LOAD_BALANCING_POLICY_CONFIG = 7
    """
    [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
    <envoy_api_field_Cluster.load_balancing_policy>` field to determine the LB policy.
    [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
    and instead using the new load_balancing_policy field as the one and only mechanism for
    configuring this.]
    """


class ClusterLbSubsetConfigLbSubsetFallbackPolicy(betterproto2.Enum):
    """
    If NO_FALLBACK is selected, a result
    equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
    any cluster endpoint may be returned (subject to policy, health checks,
    etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
    endpoints matching the values from the default_subset field.
    """

    NO_FALLBACK = 0

    ANY_ENDPOINT = 1

    DEFAULT_SUBSET = 2


class ClusterLbSubsetConfigLbSubsetSelectorLbSubsetSelectorFallbackPolicy(
    betterproto2.Enum
):
    """
    Allows to override top level fallback policy per selector.
    """

    NOT_DEFINED = 0
    """
    If NOT_DEFINED top level config fallback policy is used instead.
    """

    NO_FALLBACK = 1
    """
    If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
    """

    ANY_ENDPOINT = 2
    """
    If ANY_ENDPOINT is selected, any cluster endpoint may be returned
    (subject to policy, health checks, etc).
    """

    DEFAULT_SUBSET = 3
    """
    If DEFAULT_SUBSET is selected, load balancing is performed over the
    endpoints matching the values from the default_subset field.
    """

    KEYS_SUBSET = 4
    """
    If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
    keys reduced to
    :ref:`fallback_keys_subset<envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
    It allows for a fallback to a different, less specific selector if some of the keys of
    the selector are considered optional.
    """


class ClusterRingHashLbConfigHashFunction(betterproto2.Enum):
    """
    The hash function used to hash hosts onto the ketama ring.
    """

    XX_HASH = 0
    """
    Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
    """

    MURMUR_HASH_2 = 1
    """
    Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
    std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
    on Linux and not macOS.
    """


class ListenerDrainType(betterproto2.Enum):
    DEFAULT = 0
    """
    Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
    filter), listener removal/modification, and hot restart.
    """

    MODIFY_ONLY = 1
    """
    Drain in response to listener removal/modification and hot restart. This setting does not
    include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
    and egress listeners.
    """


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
    """

    pass


default_message_pool.register_message("envoy.api.v2", "CdsDummy", CdsDummy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Cluster(betterproto2.Message):
    """
    [#protodoc-title: Cluster configuration]

    Configuration for a single upstream cluster.
    [#next-free-field: 48]

    Oneofs:
        - cluster_discovery_type:
        - lb_config: Optional configuration for the load balancing algorithm selected by
            LbPolicy. Currently only
            :ref:`RING_HASH<envoy_api_enum_value_Cluster.LbPolicy.RING_HASH>` and
            :ref:`LEAST_REQUEST<envoy_api_enum_value_Cluster.LbPolicy.LEAST_REQUEST>`
            has additional configuration options.
            Specifying ring_hash_lb_config or least_request_lb_config without setting the corresponding
            LbPolicy will generate an error at runtime.
    """

    transport_socket_matches: "list[ClusterTransportSocketMatch]" = betterproto2.field(
        43, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Configuration to use different transport sockets for different endpoints.
    The entry of *envoy.transport_socket_match* in the
    :ref:`LbEndpoint.Metadata <envoy_api_field_endpoint.LbEndpoint.metadata>`
    is used to match against the transport sockets as they appear in the list. The first
    :ref:`match <envoy_api_msg_Cluster.TransportSocketMatch>` is used.
    For example, with the following match

    .. code-block:: yaml

     transport_socket_matches:
     - name: "enableMTLS"
       match:
         acceptMTLS: true
       transport_socket:
         name: envoy.transport_sockets.tls
         config: { ... } # tls socket configuration
     - name: "defaultToPlaintext"
       match: {}
       transport_socket:
         name: envoy.transport_sockets.raw_buffer

    Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
    having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.

    If a :ref:`socket match <envoy_api_msg_Cluster.TransportSocketMatch>` with empty match
    criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
    socket match in case above.

    If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
    *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
    *transport_socket* specified in this cluster.

    This field allows gradual and flexible transport socket configuration changes.

    The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
    an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
    "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
    has "acceptPlaintext": "true" metadata information.

    Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
    traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
    *TransportSocketMatch* in this field. Other client Envoys receive CDS without
    *transport_socket_match* set, and still send plain text traffic to the same cluster.

    [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Supplies the name of the cluster which must be unique across all clusters.
    The cluster name is used when emitting
    :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
    <envoy_api_field_Cluster.alt_stat_name>` is not provided.
    Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
    """

    alt_stat_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        28, betterproto2.TYPE_STRING
    )
    """
    An optional alternative to the cluster name to be used while emitting stats.
    Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
    confused with :ref:`Router Filter Header
    <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
    """

    type: "ClusterDiscoveryType | None" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, optional=True, group="cluster_discovery_type"
    )
    """
    The :ref:`service discovery type <arch_overview_service_discovery_types>`
    to use for resolving the cluster.
    """

    cluster_type: "ClusterCustomClusterType | None" = betterproto2.field(
        38, betterproto2.TYPE_MESSAGE, optional=True, group="cluster_discovery_type"
    )
    """
    The custom cluster type.
    """

    eds_cluster_config: "ClusterEdsClusterConfig | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configuration to use for EDS updates for the Cluster.
    """

    connect_timeout: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    The timeout for new network connections to hosts in the cluster.
    """

    per_connection_buffer_limit_bytes: "int | None" = betterproto2.field(
        5,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Soft limit on size of the cluster’s connections read and write buffers. If
    unspecified, an implementation defined default is applied (1MiB).
    """

    lb_policy: "ClusterLbPolicy" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: ClusterLbPolicy(0)
    )
    """
    The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
    when picking a host in the cluster.
    """

    hosts: "list[core.Address]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    If the service discovery type is
    :ref:`STATIC<envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    then hosts is required.

    .. attention::

      **This field is deprecated**. Set the
      :ref:`load_assignment<envoy_api_field_Cluster.load_assignment>` field instead.
    """

    load_assignment: "ClusterLoadAssignment | None" = betterproto2.field(
        33, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Setting this is required for specifying members of
    :ref:`STATIC<envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
    This field supersedes the *hosts* field in the v2 API.

    .. attention::

      Setting this allows non-EDS cluster types to contain embedded EDS equivalent
      :ref:`endpoint assignments<envoy_api_msg_ClusterLoadAssignment>`.
    """

    health_checks: "list[core.HealthCheck]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Optional :ref:`active health checking <arch_overview_health_checking>`
    configuration for the cluster. If no
    configuration is specified no health checking will be done and all cluster
    members will be considered healthy at all times.
    """

    max_requests_per_connection: "int | None" = betterproto2.field(
        9,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Optional maximum requests for a single upstream connection. This parameter
    is respected by both the HTTP/1.1 and HTTP/2 connection pool
    implementations. If not specified, there is no limit. Setting this
    parameter to 1 will effectively disable keep alive.
    """

    circuit_breakers: "cluster.CircuitBreakers | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
    """

    tls_context: "auth.UpstreamTlsContext | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The TLS configuration for connections to the upstream cluster.

    .. attention::

      **This field is deprecated**. Use `transport_socket` with name `tls` instead. If both are
      set, `transport_socket` takes priority.
    """

    upstream_http_protocol_options: "core.UpstreamHttpProtocolOptions | None" = (
        betterproto2.field(46, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    HTTP protocol options that are applied only to upstream HTTP connections.
    These options apply to all HTTP versions.
    """

    common_http_protocol_options: "core.HttpProtocolOptions | None" = (
        betterproto2.field(29, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Additional options when handling HTTP requests upstream. These options will be applicable to
    both HTTP1 and HTTP2 requests.
    """

    http_protocol_options: "core.Http1ProtocolOptions | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Additional options when handling HTTP1 requests.
    """

    http2_protocol_options: "core.Http2ProtocolOptions | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Even if default HTTP2 protocol options are desired, this field must be
    set so that Envoy will assume that the upstream supports HTTP/2 when
    making new HTTP connection pool connections. Currently, Envoy only
    supports prior knowledge for upstream connections. Even if TLS is used
    with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
    connections to happen over plain text.
    """

    extension_protocol_options: "dict[str, ___google__protobuf__.Struct]" = (
        betterproto2.field(
            35,
            betterproto2.TYPE_MAP,
            map_meta=betterproto2.map_meta(
                betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
            ),
        )
    )
    """
    The extension_protocol_options field is used to provide extension-specific protocol options
    for upstream connections. The key should match the extension filter name, such as
    "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
    specific options.
    """

    typed_extension_protocol_options: "dict[str, ___google__protobuf__.Any]" = (
        betterproto2.field(
            36,
            betterproto2.TYPE_MAP,
            map_meta=betterproto2.map_meta(
                betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
            ),
        )
    )
    """
    The extension_protocol_options field is used to provide extension-specific protocol options
    for upstream connections. The key should match the extension filter name, such as
    "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
    specific options.
    """

    dns_refresh_rate: "datetime.timedelta | None" = betterproto2.field(
        16,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    If the DNS refresh rate is specified and the cluster type is either
    :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    this value is used as the cluster’s DNS refresh
    rate. The value configured must be at least 1ms. If this setting is not specified, the
    value defaults to 5000ms. For cluster types other than
    :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    and :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    this setting is ignored.
    """

    dns_failure_refresh_rate: "ClusterRefreshRate | None" = betterproto2.field(
        44, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If the DNS failure refresh rate is specified and the cluster type is either
    :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
    not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
    other than :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
    :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
    ignored.
    """

    respect_dns_ttl: "bool" = betterproto2.field(39, betterproto2.TYPE_BOOL)
    """
    Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
    cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
    resolution.
    """

    dns_lookup_family: "ClusterDnsLookupFamily" = betterproto2.field(
        17, betterproto2.TYPE_ENUM, default_factory=lambda: ClusterDnsLookupFamily(0)
    )
    """
    The DNS IP address resolution policy. If this setting is not specified, the
    value defaults to
    :ref:`AUTO<envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO>`.
    """

    dns_resolvers: "list[core.Address]" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    If DNS resolvers are specified and the cluster type is either
    :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    or :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    this value is used to specify the cluster’s dns resolvers.
    If this setting is not specified, the value defaults to the default
    resolver, which uses /etc/resolv.conf for configuration. For cluster types
    other than
    :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    and :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    this setting is ignored.
    Setting this value causes failure if the
    ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
    server startup. Apple's API only allows overriding DNS resolvers via system settings.
    """

    use_tcp_for_dns_lookups: "bool" = betterproto2.field(45, betterproto2.TYPE_BOOL)
    """
    [#next-major-version: Reconcile DNS options in a single message.]
    Always use TCP queries instead of UDP queries for DNS lookups.
    Setting this value causes failure if the
    ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
    server startup. Apple' API only uses UDP for DNS resolution.
    """

    outlier_detection: "cluster.OutlierDetection | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If specified, outlier detection will be enabled for this upstream cluster.
    Each of the configuration values can be overridden via
    :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
    """

    cleanup_interval: "datetime.timedelta | None" = betterproto2.field(
        20,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    The interval for removing stale hosts from a cluster type
    :ref:`ORIGINAL_DST<envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`.
    Hosts are considered stale if they have not been used
    as upstream destinations during this interval. New hosts are added
    to original destination clusters on demand as new connections are
    redirected to Envoy, causing the number of hosts in the cluster to
    grow over time. Hosts that are not stale (they are actively used as
    destinations) are kept in the cluster, which allows connections to
    them remain open, saving the latency that would otherwise be spent
    on opening new connections. If this setting is not specified, the
    value defaults to 5000ms. For cluster types other than
    :ref:`ORIGINAL_DST<envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`
    this setting is ignored.
    """

    upstream_bind_config: "core.BindConfig | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional configuration used to bind newly established upstream connections.
    This overrides any bind_config specified in the bootstrap proto.
    If the address and port are empty, no bind will be performed.
    """

    lb_subset_config: "ClusterLbSubsetConfig | None" = betterproto2.field(
        22, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configuration for load balancing subsetting.
    """

    ring_hash_lb_config: "ClusterRingHashLbConfig | None" = betterproto2.field(
        23, betterproto2.TYPE_MESSAGE, optional=True, group="lb_config"
    )
    """
    Optional configuration for the Ring Hash load balancing policy.
    """

    original_dst_lb_config: "ClusterOriginalDstLbConfig | None" = betterproto2.field(
        34, betterproto2.TYPE_MESSAGE, optional=True, group="lb_config"
    )
    """
    Optional configuration for the Original Destination load balancing policy.
    """

    least_request_lb_config: "ClusterLeastRequestLbConfig | None" = betterproto2.field(
        37, betterproto2.TYPE_MESSAGE, optional=True, group="lb_config"
    )
    """
    Optional configuration for the LeastRequest load balancing policy.
    """

    common_lb_config: "ClusterCommonLbConfig | None" = betterproto2.field(
        27, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common configuration for all load balancer implementations.
    """

    transport_socket: "core.TransportSocket | None" = betterproto2.field(
        24, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional custom transport socket implementation to use for upstream connections.
    To setup TLS, set a transport socket with name `tls` and
    :ref:`UpstreamTlsContexts <envoy_api_msg_auth.UpstreamTlsContext>` in the `typed_config`.
    If no transport socket configuration is specified, new connections
    will be set up with plaintext.
    """

    metadata: "core.Metadata | None" = betterproto2.field(
        25, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The Metadata field can be used to provide additional information about the
    cluster. It can be used for stats, logging, and varying filter behavior.
    Fields should use reverse DNS notation to denote which entity within Envoy
    will need the information. For instance, if the metadata is intended for
    the Router filter, the filter name should be specified as *envoy.filters.http.router*.
    """

    protocol_selection: "ClusterClusterProtocolSelection" = betterproto2.field(
        26,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ClusterClusterProtocolSelection(0),
    )
    """
    Determines how Envoy selects the protocol used to speak to upstream hosts.
    """

    upstream_connection_options: "UpstreamConnectionOptions | None" = (
        betterproto2.field(30, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Optional options for upstream connections.
    """

    close_connections_on_host_health_failure: "bool" = betterproto2.field(
        31, betterproto2.TYPE_BOOL
    )
    """
    If an upstream host becomes unhealthy (as determined by the configured health checks
    or outlier detection), immediately close all connections to the failed host.

    .. note::

      This is currently only supported for connections created by tcp_proxy.

    .. note::

      The current implementation of this feature closes all connections immediately when
      the unhealthy status is detected. If there are a large number of connections open
      to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
      time exclusively closing these connections, and not processing any other traffic.
    """

    drain_connections_on_host_removal: "bool" = betterproto2.field(
        32, betterproto2.TYPE_BOOL
    )
    """
    If set to true, Envoy will ignore the health value of a host when processing its removal
    from service discovery. This means that if active health checking is used, Envoy will *not*
    wait for the endpoint to go unhealthy before removing it.
    """

    filters: "list[cluster.Filter]" = betterproto2.field(
        40, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    An (optional) network filter chain, listed in the order the filters should be applied.
    The chain will be applied to all outgoing connections that Envoy makes to the upstream
    servers of this cluster.
    """

    load_balancing_policy: "LoadBalancingPolicy | None" = betterproto2.field(
        41, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
    :ref:`lb_policy<envoy_api_field_Cluster.lb_policy>` field has the value
    :ref:`LOAD_BALANCING_POLICY_CONFIG<envoy_api_enum_value_Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG>`.
    """

    lrs_server: "core.ConfigSource | None" = betterproto2.field(
        42, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:]
    If present, tells the client where to send load reports via LRS. If not present, the
    client will fall back to a client-side default, which may be either (a) don't send any
    load reports or (b) send load reports for all clusters to a single default server
    (which may be configured in the bootstrap file).

    Note that if multiple clusters point to the same LRS server, the client may choose to
    create a separate stream for each cluster or it may choose to coalesce the data for
    multiple clusters onto a single stream. Either way, the client must make sure to send
    the data for any given cluster on no more than one stream.

    [#next-major-version: In the v3 API, we should consider restructuring this somehow,
    maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
    from the LRS stream here.]
    """

    track_timeout_budgets: "bool" = betterproto2.field(47, betterproto2.TYPE_BOOL)
    """
    If track_timeout_budgets is true, the :ref:`timeout budget histograms
    <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
    request. These show what percentage of a request's per try and global timeout was used. A value
    of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
    of 100 would indicate that the request took the entirety of the timeout given to it.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("hosts"):
            warnings.warn("Cluster.hosts is deprecated", DeprecationWarning)
        if self.is_set("tls_context"):
            warnings.warn("Cluster.tls_context is deprecated", DeprecationWarning)
        if self.is_set("extension_protocol_options"):
            warnings.warn(
                "Cluster.extension_protocol_options is deprecated", DeprecationWarning
            )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("envoy.api.v2", "Cluster", Cluster)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterCommonLbConfig(betterproto2.Message):
    """
    Common configuration for all load balancer implementations.
    [#next-free-field: 8]

    Oneofs:
        - locality_config_specifier:
    """

    healthy_panic_threshold: "__type__.Percent | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
    If not specified, the default is 50%.
    To disable panic mode, set to 0%.

    .. note::
      The specified percent will be truncated to the nearest 1%.
    """

    zone_aware_lb_config: "ClusterCommonLbConfigZoneAwareLbConfig | None" = (
        betterproto2.field(
            2,
            betterproto2.TYPE_MESSAGE,
            optional=True,
            group="locality_config_specifier",
        )
    )

    locality_weighted_lb_config: "ClusterCommonLbConfigLocalityWeightedLbConfig | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="locality_config_specifier"
    )

    update_merge_window: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    If set, all health check/weight/metadata updates that happen within this duration will be
    merged and delivered in one shot when the duration expires. The start of the duration is when
    the first update happens. This is useful for big clusters, with potentially noisy deploys
    that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
    or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
    cluster). Please always keep in mind that the use of sandbox technologies may change this
    behavior.

    If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
    window to 0.

    Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
    because merging those updates isn't currently safe. See
    https://github.com/envoyproxy/envoy/pull/3941.
    """

    ignore_new_hosts_until_first_hc: "bool" = betterproto2.field(
        5, betterproto2.TYPE_BOOL
    )
    """
    If set to true, Envoy will not consider new hosts when computing load balancing weights until
    they have been health checked for the first time. This will have no effect unless
    active health checking is also configured.

    Ignoring a host means that for any load balancing calculations that adjust weights based
    on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
    panic mode) Envoy will exclude these hosts in the denominator.

    For example, with hosts in two priorities P0 and P1, where P0 looks like
    {healthy, unhealthy (new), unhealthy (new)}
    and where P1 looks like
    {healthy, healthy}
    all traffic will still hit P0, as 1 / (3 - 2) = 1.

    Enabling this will allow scaling up the number of hosts for a given cluster without entering
    panic mode or triggering priority spillover, assuming the hosts pass the first health check.

    If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
    contribute to the calculation when deciding whether panic mode is enabled or not.
    """

    close_connections_on_host_set_change: "bool" = betterproto2.field(
        6, betterproto2.TYPE_BOOL
    )
    """
    If set to `true`, the cluster manager will drain all existing
    connections to upstream hosts whenever hosts are added or removed from the cluster.
    """

    consistent_hashing_lb_config: "ClusterCommonLbConfigConsistentHashingLbConfig | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.CommonLbConfig", ClusterCommonLbConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterCommonLbConfigConsistentHashingLbConfig(betterproto2.Message):
    """
    Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
    """

    use_hostname_for_hashing: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    If set to `true`, the cluster will use hostname instead of the resolved
    address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
    """


default_message_pool.register_message(
    "envoy.api.v2",
    "Cluster.CommonLbConfig.ConsistentHashingLbConfig",
    ClusterCommonLbConfigConsistentHashingLbConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterCommonLbConfigLocalityWeightedLbConfig(betterproto2.Message):
    """
    Configuration for :ref:`locality weighted load balancing
    <arch_overview_load_balancing_locality_weighted_lb>`
    """

    pass


default_message_pool.register_message(
    "envoy.api.v2",
    "Cluster.CommonLbConfig.LocalityWeightedLbConfig",
    ClusterCommonLbConfigLocalityWeightedLbConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterCommonLbConfigZoneAwareLbConfig(betterproto2.Message):
    """
    Configuration for :ref:`zone aware routing
    <arch_overview_load_balancing_zone_aware_routing>`.
    """

    routing_enabled: "__type__.Percent | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configures percentage of requests that will be considered for zone aware routing
    if zone aware routing is configured. If not specified, the default is 100%.
    * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
    * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
    """

    min_cluster_size: "int | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    Configures minimum upstream cluster size required for zone aware routing
    If upstream cluster size is less than specified, zone aware routing is not performed
    even if zone aware routing is configured. If not specified, the default is 6.
    * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
    * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
    """

    fail_traffic_on_panic: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
    mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
    requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
    failing service.
    """


default_message_pool.register_message(
    "envoy.api.v2",
    "Cluster.CommonLbConfig.ZoneAwareLbConfig",
    ClusterCommonLbConfigZoneAwareLbConfig,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterCustomClusterType(betterproto2.Message):
    """
    Extended cluster type.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The type of the cluster to instantiate. The name must match a supported cluster type.
    """

    typed_config: "___google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Cluster specific configuration which depends on the cluster being instantiated.
    See the supported cluster for further documentation.
    """


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.CustomClusterType", ClusterCustomClusterType
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterEdsClusterConfig(betterproto2.Message):
    """
    Only valid when discovery type is EDS.
    """

    eds_config: "core.ConfigSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configuration for the source of EDS updates for this Cluster.
    """

    service_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Optional alternative to cluster name to present to EDS. This does not
    have the same restrictions as cluster name, i.e. it may be arbitrary
    length.
    """


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.EdsClusterConfig", ClusterEdsClusterConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLbSubsetConfig(betterproto2.Message):
    """
    Optionally divide the endpoints in this cluster into subsets defined by
    endpoint metadata and selected by route and weighted cluster metadata.
    [#next-free-field: 8]
    """

    fallback_policy: "ClusterLbSubsetConfigLbSubsetFallbackPolicy" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ClusterLbSubsetConfigLbSubsetFallbackPolicy(0),
    )
    """
    The behavior used when no endpoint subset matches the selected route's
    metadata. The value defaults to
    :ref:`NO_FALLBACK<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
    """

    default_subset: "___google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Specifies the default subset of endpoints used during fallback if
    fallback_policy is
    :ref:`DEFAULT_SUBSET<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
    Each field in default_subset is
    compared to the matching LbEndpoint.Metadata under the *envoy.lb*
    namespace. It is valid for no hosts to match, in which case the behavior
    is the same as a fallback_policy of
    :ref:`NO_FALLBACK<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
    """

    subset_selectors: "list[ClusterLbSubsetConfigLbSubsetSelector]" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    For each entry, LbEndpoint.Metadata's
    *envoy.lb* namespace is traversed and a subset is created for each unique
    combination of key and value. For example:

    .. code-block:: json

      { "subset_selectors": [
          { "keys": [ "version" ] },
          { "keys": [ "stage", "hardware_type" ] }
      ]}

    A subset is matched when the metadata from the selected route and
    weighted cluster contains the same keys and values as the subset's
    metadata. The same host may appear in multiple subsets.
    """

    locality_weight_aware: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    If true, routing to subsets will take into account the localities and locality weights of the
    endpoints when making the routing decision.

    There are some potential pitfalls associated with enabling this feature, as the resulting
    traffic split after applying both a subset match and locality weights might be undesirable.

    Consider for example a situation in which you have 50/50 split across two localities X/Y
    which have 100 hosts each without subsetting. If the subset LB results in X having only 1
    host selected but Y having 100, then a lot more load is being dumped on the single host in X
    than originally anticipated in the load balancing assignment delivered via EDS.
    """

    scale_locality_weight: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    When used with locality_weight_aware, scales the weight of each locality by the ratio
    of hosts in the subset vs hosts in the original subset. This aims to even out the load
    going to an individual locality if said locality is disproportionately affected by the
    subset predicate.
    """

    panic_mode_any: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    If true, when a fallback policy is configured and its corresponding subset fails to find
    a host this will cause any host to be selected instead.

    This is useful when using the default subset as the fallback policy, given the default
    subset might become empty. With this option enabled, if that happens the LB will attempt
    to select a host from the entire cluster.
    """

    list_as_any: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)
    """
    If true, metadata specified for a metadata key will be matched against the corresponding
    endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
    and any of the elements in the list matches the criteria.
    """


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.LbSubsetConfig", ClusterLbSubsetConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLbSubsetConfigLbSubsetSelector(betterproto2.Message):
    """
    Specifications for subsets.
    """

    keys: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        1, betterproto2.TYPE_STRING, repeated=True
    )
    """
    List of keys to match with the weighted cluster metadata.
    """

    fallback_policy: "ClusterLbSubsetConfigLbSubsetSelectorLbSubsetSelectorFallbackPolicy" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ClusterLbSubsetConfigLbSubsetSelectorLbSubsetSelectorFallbackPolicy(
            0
        ),
    )
    """
    The behavior used when no endpoint subset matches the selected route's
    metadata.
    """

    fallback_keys_subset: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Subset of
    :ref:`keys<envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
    :ref:`KEYS_SUBSET<envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
    fallback policy.
    It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
    For any other fallback policy the parameter is not used and should not be set.
    Only values also present in
    :ref:`keys<envoy_api_field_Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
    `fallback_keys_subset` cannot be equal to `keys`.
    """


default_message_pool.register_message(
    "envoy.api.v2",
    "Cluster.LbSubsetConfig.LbSubsetSelector",
    ClusterLbSubsetConfigLbSubsetSelector,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLeastRequestLbConfig(betterproto2.Message):
    """
    Specific configuration for the LeastRequest load balancing policy.
    """

    choice_count: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    The number of random healthy hosts from which the host with the fewest active requests will
    be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
    """


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.LeastRequestLbConfig", ClusterLeastRequestLbConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterOriginalDstLbConfig(betterproto2.Message):
    """
    Specific configuration for the
    :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
    load balancing policy.
    """

    use_http_header: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    When true, :ref:`x-envoy-original-dst-host
    <config_http_conn_man_headers_x-envoy-original-dst-host>` can be used to override destination
    address.

    .. attention::

      This header isn't sanitized by default, so enabling this feature allows HTTP clients to
      route traffic to arbitrary hosts and/or ports, which may have serious security
      consequences.

    .. note::

      If the header appears multiple times only the first value is used.
    """


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.OriginalDstLbConfig", ClusterOriginalDstLbConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterRefreshRate(betterproto2.Message):
    base_interval: "datetime.timedelta | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    Specifies the base interval between refreshes. This parameter is required and must be greater
    than zero and less than
    :ref:`max_interval <envoy_api_field_Cluster.RefreshRate.max_interval>`.
    """

    max_interval: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    Specifies the maximum interval between refreshes. This parameter is optional, but must be
    greater than or equal to the
    :ref:`base_interval <envoy_api_field_Cluster.RefreshRate.base_interval>`  if set. The default
    is 10 times the :ref:`base_interval <envoy_api_field_Cluster.RefreshRate.base_interval>`.
    """


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.RefreshRate", ClusterRefreshRate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterRingHashLbConfig(betterproto2.Message):
    """
    Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
    load balancing policy.
    """

    minimum_ring_size: "int | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
    provided host) the better the request distribution will reflect the desired weights. Defaults
    to 1024 entries, and limited to 8M entries. See also
    :ref:`maximum_ring_size<envoy_api_field_Cluster.RingHashLbConfig.maximum_ring_size>`.
    """

    hash_function: "ClusterRingHashLbConfigHashFunction" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ClusterRingHashLbConfigHashFunction(0),
    )
    """
    The hash function used to hash hosts onto the ketama ring. The value defaults to
    :ref:`XX_HASH<envoy_api_enum_value_Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
    """

    maximum_ring_size: "int | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt64Value,
        optional=True,
    )
    """
    Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
    to further constrain resource use. See also
    :ref:`minimum_ring_size<envoy_api_field_Cluster.RingHashLbConfig.minimum_ring_size>`.
    """


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.RingHashLbConfig", ClusterRingHashLbConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterTransportSocketMatch(betterproto2.Message):
    """
    TransportSocketMatch specifies what transport socket config will be used
    when the match conditions are satisfied.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the match, used in stats generation.
    """

    match: "___google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional endpoint metadata match criteria.
    The connection to the endpoint with metadata matching what is set in this field
    will use the transport socket configuration specified here.
    The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
    against the values specified in this field.
    """

    transport_socket: "core.TransportSocket | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The configuration of the transport socket.
    """


default_message_pool.register_message(
    "envoy.api.v2", "Cluster.TransportSocketMatch", ClusterTransportSocketMatch
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLoadAssignment(betterproto2.Message):
    """
    [#protodoc-title: Endpoint configuration]
    Endpoint discovery :ref:`architecture overview <arch_overview_service_discovery_types_eds>`

    Each route from RDS will map to a single cluster or traffic split across
    clusters using weights expressed in the RDS WeightedCluster.

    With EDS, each cluster is treated independently from a LB perspective, with
    LB taking place between the Localities within a cluster and at a finer
    granularity between the hosts within a locality. The percentage of traffic
    for each endpoint is determined by both its load_balancing_weight, and the
    load_balancing_weight of its locality. First, a locality will be selected,
    then an endpoint within that locality will be chose based on its weight.
    [#next-free-field: 6]
    """

    cluster_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Name of the cluster. This will be the :ref:`service_name
    <envoy_api_field_Cluster.EdsClusterConfig.service_name>` value if specified
    in the cluster :ref:`EdsClusterConfig
    <envoy_api_msg_Cluster.EdsClusterConfig>`.
    """

    endpoints: "list[endpoint.LocalityLbEndpoints]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of endpoints to load balance to.
    """

    named_endpoints: "dict[str, endpoint.Endpoint]" = betterproto2.field(
        5,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE
        ),
    )
    """
    Map of named endpoints that can be referenced in LocalityLbEndpoints.
    [#not-implemented-hide:]
    """

    policy: "ClusterLoadAssignmentPolicy | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Load balancing policy settings.
    """


default_message_pool.register_message(
    "envoy.api.v2", "ClusterLoadAssignment", ClusterLoadAssignment
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLoadAssignmentPolicy(betterproto2.Message):
    """
    Load balancing policy settings.
    [#next-free-field: 6]
    """

    drop_overloads: "list[ClusterLoadAssignmentPolicyDropOverload]" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Action to trim the overall incoming traffic to protect the upstream
    hosts. This action allows protection in case the hosts are unable to
    recover from an outage, or unable to autoscale or unable to handle
    incoming traffic volume for any reason.

    At the client each category is applied one after the other to generate
    the 'actual' drop percentage on all outgoing traffic. For example:

    .. code-block:: json

     { "drop_overloads": [
         { "category": "throttle", "drop_percentage": 60 }
         { "category": "lb", "drop_percentage": 50 }
     ]}

    The actual drop percentages applied to the traffic at the clients will be
       "throttle"_drop = 60%
       "lb"_drop = 20%  // 50% of the remaining 'actual' load, which is 40%.
       actual_outgoing_load = 20% // remaining after applying all categories.
    [#not-implemented-hide:]
    """

    overprovisioning_factor: "int | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Priority levels and localities are considered overprovisioned with this
    factor (in percentage). This means that we don't consider a priority
    level or locality unhealthy until the percentage of healthy hosts
    multiplied by the overprovisioning factor drops below 100.
    With the default value 140(1.4), Envoy doesn't consider a priority level
    or a locality unhealthy until their percentage of healthy hosts drops
    below 72%. For example:

    .. code-block:: json

     { "overprovisioning_factor": 100 }

    Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>` and
    :ref:`localities <arch_overview_load_balancing_locality_weighted_lb>`.
    """

    endpoint_stale_after: "datetime.timedelta | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    The max time until which the endpoints from this assignment can be used.
    If no new assignments are received before this time expires the endpoints
    are considered stale and should be marked unhealthy.
    Defaults to 0 which means endpoints never go stale.
    """

    disable_overprovisioning: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    The flag to disable overprovisioning. If it is set to true,
    :ref:`overprovisioning factor
    <arch_overview_load_balancing_overprovisioning_factor>` will be ignored
    and Envoy will not perform graceful failover between priority levels or
    localities as endpoints become unhealthy. Otherwise Envoy will perform
    graceful failover as :ref:`overprovisioning factor
    <arch_overview_load_balancing_overprovisioning_factor>` suggests.
    [#not-implemented-hide:]
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("disable_overprovisioning"):
            warnings.warn(
                "ClusterLoadAssignmentPolicy.disable_overprovisioning is deprecated",
                DeprecationWarning,
            )


default_message_pool.register_message(
    "envoy.api.v2", "ClusterLoadAssignment.Policy", ClusterLoadAssignmentPolicy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ClusterLoadAssignmentPolicyDropOverload(betterproto2.Message):
    """
    [#not-implemented-hide:]
    """

    category: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Identifier for the policy specifying the drop.
    """

    drop_percentage: "__type__.FractionalPercent | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Percentage of traffic that should be dropped for the category.
    """


default_message_pool.register_message(
    "envoy.api.v2",
    "ClusterLoadAssignment.Policy.DropOverload",
    ClusterLoadAssignmentPolicyDropOverload,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DeltaDiscoveryRequest(betterproto2.Message):
    """
    DeltaDiscoveryRequest and DeltaDiscoveryResponse are used in a new gRPC
    endpoint for Delta xDS.

    With Delta xDS, the DeltaDiscoveryResponses do not need to include a full
    snapshot of the tracked resources. Instead, DeltaDiscoveryResponses are a
    diff to the state of a xDS client.
    In Delta XDS there are per-resource versions, which allow tracking state at
    the resource granularity.
    An xDS Delta session is always in the context of a gRPC bidirectional
    stream. This allows the xDS server to keep track of the state of xDS clients
    connected to it.

    In Delta xDS the nonce field is required and used to pair
    DeltaDiscoveryResponse to a DeltaDiscoveryRequest ACK or NACK.
    Optionally, a response message level system_version_info is present for
    debugging purposes only.

    DeltaDiscoveryRequest plays two independent roles. Any DeltaDiscoveryRequest
    can be either or both of: [1] informing the server of what resources the
    client has gained/lost interest in (using resource_names_subscribe and
    resource_names_unsubscribe), or [2] (N)ACKing an earlier resource update from
    the server (using response_nonce, with presence of error_detail making it a NACK).
    Additionally, the first message (for a given type_url) of a reconnected gRPC stream
    has a third role: informing the server of the resources (and their versions)
    that the client already possesses, using the initial_resource_versions field.

    As with state-of-the-world, when multiple resource types are multiplexed (ADS),
    all requests/acknowledgments/updates are logically walled off by type_url:
    a Cluster ACK exists in a completely separate world from a prior Route NACK.
    In particular, initial_resource_versions being sent at the "start" of every
    gRPC stream actually entails a message for each type_url, each with its own
    initial_resource_versions.
    [#next-free-field: 8]
    """

    node: "core.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node making the request.
    """

    type_url: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Type of the resource that is being requested, e.g.
    "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment".
    """

    resource_names_subscribe: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    DeltaDiscoveryRequests allow the client to add or remove individual
    resources to the set of tracked resources in the context of a stream.
    All resource names in the resource_names_subscribe list are added to the
    set of tracked resources and all resource names in the resource_names_unsubscribe
    list are removed from the set of tracked resources.

    *Unlike* state-of-the-world xDS, an empty resource_names_subscribe or
    resource_names_unsubscribe list simply means that no resources are to be
    added or removed to the resource list.
    *Like* state-of-the-world xDS, the server must send updates for all tracked
    resources, but can also send updates for resources the client has not subscribed to.

    NOTE: the server must respond with all resources listed in resource_names_subscribe,
    even if it believes the client has the most recent version of them. The reason:
    the client may have dropped them, but then regained interest before it had a chance
    to send the unsubscribe message. See DeltaSubscriptionStateTest.RemoveThenAdd.

    These two fields can be set in any DeltaDiscoveryRequest, including ACKs
    and initial_resource_versions.

    A list of Resource names to add to the list of tracked resources.
    """

    resource_names_unsubscribe: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )
    """
    A list of Resource names to remove from the list of tracked resources.
    """

    initial_resource_versions: "dict[str, str]" = betterproto2.field(
        5,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )
    """
    Informs the server of the versions of the resources the xDS client knows of, to enable the
    client to continue the same logical xDS session even in the face of gRPC stream reconnection.
    It will not be populated: [1] in the very first stream of a session, since the client will
    not yet have any resources,  [2] in any message after the first in a stream (for a given
    type_url), since the server will already be correctly tracking the client's state.
    (In ADS, the first message *of each type_url* of a reconnected stream populates this map.)
    The map's keys are names of xDS resources known to the xDS client.
    The map's values are opaque resource versions.
    """

    response_nonce: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        6, betterproto2.TYPE_STRING
    )
    """
    When the DeltaDiscoveryRequest is a ACK or NACK message in response
    to a previous DeltaDiscoveryResponse, the response_nonce must be the
    nonce in the DeltaDiscoveryResponse.
    Otherwise (unlike in DiscoveryRequest) response_nonce must be omitted.
    """

    error_detail: "___google__rpc__.Status | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_DiscoveryResponse>`
    failed to update configuration. The *message* field in *error_details*
    provides the Envoy internal exception related to the failure.
    """


default_message_pool.register_message(
    "envoy.api.v2", "DeltaDiscoveryRequest", DeltaDiscoveryRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DeltaDiscoveryResponse(betterproto2.Message):
    """
    [#next-free-field: 7]
    """

    system_version_info: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The version of the response data (used for debugging).
    """

    resources: "list[Resource]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The response resources. These are typed resources, whose types must match
    the type_url field.
    """

    type_url: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    field id 3 IS available!

    Type URL for resources. Identifies the xDS API when muxing over ADS.
    Must be consistent with the type_url in the Any within 'resources' if 'resources' is non-empty.
    """

    removed_resources: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        6, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Resources names of resources that have be deleted and to be removed from the xDS Client.
    Removed resources for missing resources can be ignored.
    """

    nonce: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    The nonce provides a way for DeltaDiscoveryRequests to uniquely
    reference a DeltaDiscoveryResponse when (N)ACKing. The nonce is required.
    """


default_message_pool.register_message(
    "envoy.api.v2", "DeltaDiscoveryResponse", DeltaDiscoveryResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DiscoveryRequest(betterproto2.Message):
    """
    [#protodoc-title: Common discovery API components]

    A DiscoveryRequest requests a set of versioned resources of the same type for
    a given Envoy node on some API.
    [#next-free-field: 7]
    """

    version_info: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The version_info provided in the request messages will be the version_info
    received with the most recent successfully processed response or empty on
    the first request. It is expected that no new request is sent after a
    response is received until the Envoy instance is ready to ACK/NACK the new
    configuration. ACK/NACK takes place by returning the new API config version
    as applied or the previous API config version respectively. Each type_url
    (see below) has an independent version associated with it.
    """

    node: "core.Node | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node making the request.
    """

    resource_names: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    List of resources to subscribe to, e.g. list of cluster names or a route
    configuration name. If this is empty, all resources for the API are
    returned. LDS/CDS may have empty resource_names, which will cause all
    resources for the Envoy instance to be returned. The LDS and CDS responses
    will then imply a number of resources that need to be fetched via EDS/RDS,
    which will be explicitly enumerated in resource_names.
    """

    type_url: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    Type of the resource that is being requested, e.g.
    "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment". This is implicit
    in requests made via singleton xDS APIs such as CDS, LDS, etc. but is
    required for ADS.
    """

    response_nonce: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    nonce corresponding to DiscoveryResponse being ACK/NACKed. See above
    discussion on version_info and the DiscoveryResponse nonce comment. This
    may be empty only if 1) this is a non-persistent-stream xDS such as HTTP,
    or 2) the client has not yet accepted an update in this xDS stream (unlike
    delta, where it is populated only for new explicit ACKs).
    """

    error_detail: "___google__rpc__.Status | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_DiscoveryResponse>`
    failed to update configuration. The *message* field in *error_details* provides the Envoy
    internal exception related to the failure. It is only intended for consumption during manual
    debugging, the string provided is not guaranteed to be stable across Envoy versions.
    """


default_message_pool.register_message(
    "envoy.api.v2", "DiscoveryRequest", DiscoveryRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DiscoveryResponse(betterproto2.Message):
    """
    [#next-free-field: 7]
    """

    version_info: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The version of the response data.
    """

    resources: "list[___google__protobuf__.Any]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The response resources. These resources are typed and depend on the API being called.
    """

    canary: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    [#not-implemented-hide:]
    Canary is used to support two Envoy command line flags:

    * --terminate-on-canary-transition-failure. When set, Envoy is able to
      terminate if it detects that configuration is stuck at canary. Consider
      this example sequence of updates:
      - Management server applies a canary config successfully.
      - Management server rolls back to a production config.
      - Envoy rejects the new production config.
      Since there is no sensible way to continue receiving configuration
      updates, Envoy will then terminate and apply production config from a
      clean slate.
    * --dry-run-canary. When set, a canary response will never be applied, only
      validated via a dry run.
    """

    type_url: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    Type URL for resources. Identifies the xDS API when muxing over ADS.
    Must be consistent with the type_url in the 'resources' repeated Any (if non-empty).
    """

    nonce: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )
    """
    For gRPC based subscriptions, the nonce provides a way to explicitly ack a
    specific DiscoveryResponse in a following DiscoveryRequest. Additional
    messages may have been sent by Envoy to the management server for the
    previous version on the stream prior to this DiscoveryResponse, that were
    unprocessed at response send time. The nonce allows the management server
    to ignore any further DiscoveryRequests for the previous version until a
    DiscoveryRequest bearing the nonce. The nonce is optional and is not
    required for non-stream based xDS implementations.
    """

    control_plane: "core.ControlPlane | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:]
    The control plane instance that sent the response.
    """


default_message_pool.register_message(
    "envoy.api.v2", "DiscoveryResponse", DiscoveryResponse
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
    """

    pass


default_message_pool.register_message("envoy.api.v2", "EdsDummy", EdsDummy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
    """

    pass


default_message_pool.register_message("envoy.api.v2", "LdsDummy", LdsDummy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Listener(betterproto2.Message):
    """
    [#protodoc-title: Listener configuration]
    Listener :ref:`configuration overview <config_listeners>`

    [#next-free-field: 23]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The unique name by which this listener is known. If no name is provided,
    Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
    updated or removed via :ref:`LDS <config_listeners_lds>` a unique name must be provided.
    """

    address: "core.Address | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The address that the listener should listen on. In general, the address must be unique, though
    that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
    Linux as the actual port will be allocated by the OS.
    """

    filter_chains: "list[listener.FilterChain]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of filter chains to consider for this listener. The
    :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` with the most specific
    :ref:`FilterChainMatch <envoy_api_msg_listener.FilterChainMatch>` criteria is used on a
    connection.

    Example using SNI for filter chain selection can be found in the
    :ref:`FAQ entry <faq_how_to_setup_sni>`.
    """

    use_original_dst: "bool | None" = betterproto2.field(
        4,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.BoolValue,
        optional=True,
    )
    """
    If a connection is redirected using *iptables*, the port on which the proxy
    receives it might be different from the original destination address. When this flag is set to
    true, the listener hands off redirected connections to the listener associated with the
    original destination address. If there is no listener associated with the original destination
    address, the connection is handled by the listener that receives it. Defaults to false.

    .. attention::

      This field is deprecated. Use :ref:`an original_dst <config_listener_filters_original_dst>`
      :ref:`listener filter <envoy_api_field_Listener.listener_filters>` instead.

      Note that hand off to another listener is *NOT* performed without this flag. Once
      :ref:`FilterChainMatch <envoy_api_msg_listener.FilterChainMatch>` is implemented this flag
      will be removed, as filter chain matching can be used to select a filter chain based on the
      restored destination address.
    """

    per_connection_buffer_limit_bytes: "int | None" = betterproto2.field(
        5,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Soft limit on size of the listener’s new connection read and write buffers.
    If unspecified, an implementation defined default is applied (1MiB).
    """

    metadata: "core.Metadata | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Listener metadata.
    """

    deprecated_v1: "ListenerDeprecatedV1 | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    [#not-implemented-hide:]
    """

    drain_type: "ListenerDrainType" = betterproto2.field(
        8, betterproto2.TYPE_ENUM, default_factory=lambda: ListenerDrainType(0)
    )
    """
    The type of draining to perform at a listener-wide level.
    """

    listener_filters: "list[listener.ListenerFilter]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Listener filters have the opportunity to manipulate and augment the connection metadata that
    is used in connection filter chain matching, for example. These filters are run before any in
    :ref:`filter_chains <envoy_api_field_Listener.filter_chains>`. Order matters as the
    filters are processed sequentially right after a socket has been accepted by the listener, and
    before a connection is created.
    UDP Listener filters can be specified when the protocol in the listener socket address in
    :ref:`protocol <envoy_api_field_core.SocketAddress.protocol>` is :ref:`UDP
    <envoy_api_enum_value_core.SocketAddress.Protocol.UDP>`.
    UDP listeners currently support a single filter.
    """

    listener_filters_timeout: "datetime.timedelta | None" = betterproto2.field(
        15,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    The timeout to wait for all listener filters to complete operation. If the timeout is reached,
    the accepted socket is closed without a connection being created unless
    `continue_on_listener_filters_timeout` is set to true. Specify 0 to disable the
    timeout. If not specified, a default timeout of 15s is used.
    """

    continue_on_listener_filters_timeout: "bool" = betterproto2.field(
        17, betterproto2.TYPE_BOOL
    )
    """
    Whether a connection should be created when listener filters timeout. Default is false.

    .. attention::

      Some listener filters, such as :ref:`Proxy Protocol filter
      <config_listener_filters_proxy_protocol>`, should not be used with this option. It will cause
      unexpected behavior when a connection is created.
    """

    transparent: "bool | None" = betterproto2.field(
        10,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Whether the listener should be set as a transparent socket.
    When this flag is set to true, connections can be redirected to the listener using an
    *iptables* *TPROXY* target, in which case the original source and destination addresses and
    ports are preserved on accepted connections. This flag should be used in combination with
    :ref:`an original_dst <config_listener_filters_original_dst>` :ref:`listener filter
    <envoy_api_field_Listener.listener_filters>` to mark the connections' local addresses as
    "restored." This can be used to hand off each redirected connection to another listener
    associated with the connection's destination address. Direct connections to the socket without
    using *TPROXY* cannot be distinguished from connections redirected using *TPROXY* and are
    therefore treated as if they were redirected.
    When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
    Setting this flag requires Envoy to run with the *CAP_NET_ADMIN* capability.
    When this flag is not set (default), the socket is not modified, i.e. the transparent option
    is neither set nor reset.
    """

    freebind: "bool | None" = betterproto2.field(
        11,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Whether the listener should set the *IP_FREEBIND* socket option. When this
    flag is set to true, listeners can be bound to an IP address that is not
    configured on the system running Envoy. When this flag is set to false, the
    option *IP_FREEBIND* is disabled on the socket. When this flag is not set
    (default), the socket is not modified, i.e. the option is neither enabled
    nor disabled.
    """

    socket_options: "list[core.SocketOption]" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Additional socket options that may not be present in Envoy source code or
    precompiled binaries.
    """

    tcp_fast_open_queue_length: "int | None" = betterproto2.field(
        12,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.UInt32Value,
        optional=True,
    )
    """
    Whether the listener should accept TCP Fast Open (TFO) connections.
    When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
    the socket, with a queue length of the specified size
    (see `details in RFC7413 <https://tools.ietf.org/html/rfc7413#section-5.1>`_).
    When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
    When this flag is not set (default), the socket is not modified,
    i.e. the option is neither enabled nor disabled.

    On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
    TCP_FASTOPEN.
    See `ip-sysctl.txt <https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>`_.

    On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
    To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
    """

    traffic_direction: "core.TrafficDirection" = betterproto2.field(
        16, betterproto2.TYPE_ENUM, default_factory=lambda: core.TrafficDirection(0)
    )
    """
    Specifies the intended direction of the traffic relative to the local Envoy.
    This property is required on Windows for listeners using the original destination filter,
    see :ref:`Original Destination <config_listener_filters_original_dst>`.
    """

    udp_listener_config: "listener.UdpListenerConfig | None" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If the protocol in the listener socket address in :ref:`protocol
    <envoy_api_field_core.SocketAddress.protocol>` is :ref:`UDP
    <envoy_api_enum_value_core.SocketAddress.Protocol.UDP>`, this field specifies the actual udp
    listener to create, i.e. :ref:`udp_listener_name
    <envoy_api_field_listener.UdpListenerConfig.udp_listener_name>` = "raw_udp_listener" for
    creating a packet-oriented UDP listener. If not present, treat it as "raw_udp_listener".
    """

    api_listener: "__config__listener__v2__.ApiListener | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Used to represent an API listener, which is used in non-proxy clients. The type of API
    exposed to the non-proxy application depends on the type of API listener.
    When this field is set, no other field except for :ref:`name<envoy_api_field_Listener.name>`
    should be set.

    .. note::

     Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     not LDS.

    [#next-major-version: In the v3 API, instead of this messy approach where the socket
    listener fields are directly in the top-level Listener message and the API listener types
    are in the ApiListener message, the socket listener messages should be in their own message,
    and the top-level Listener should essentially be a oneof that selects between the
    socket listener and the various types of API listener. That way, a given Listener message
    can structurally only contain the fields of the relevant type.]
    """

    connection_balance_config: "ListenerConnectionBalanceConfig | None" = (
        betterproto2.field(20, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    The listener's connection balancer configuration, currently only applicable to TCP listeners.
    If no configuration is specified, Envoy will not attempt to balance active connections between
    worker threads.
    """

    reuse_port: "bool" = betterproto2.field(21, betterproto2.TYPE_BOOL)
    """
    When this flag is set to true, listeners set the *SO_REUSEPORT* socket option and
    create one socket for each worker thread. This makes inbound connections
    distribute among worker threads roughly evenly in cases where there are a high number
    of connections. When this flag is set to false, all worker threads share one socket.

    Before Linux v4.19-rc1, new TCP connections may be rejected during hot restart
    (see `3rd paragraph in 'soreuseport' commit message
    <https://github.com/torvalds/linux/commit/c617f398edd4db2b8567a28e89>`_).
    This issue was fixed by `tcp: Avoid TCP syncookie rejected by SO_REUSEPORT socket
    <https://github.com/torvalds/linux/commit/40a1227ea845a37ab197dd1caffb60b047fa36b1>`_.
    """

    access_log: "list[__config__filter__accesslog__v2__.AccessLog]" = (
        betterproto2.field(22, betterproto2.TYPE_MESSAGE, repeated=True)
    )
    """
    Configuration for :ref:`access logs <arch_overview_access_logs>`
    emitted by this listener.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("use_original_dst"):
            warnings.warn("Listener.use_original_dst is deprecated", DeprecationWarning)


default_message_pool.register_message("envoy.api.v2", "Listener", Listener)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ListenerConnectionBalanceConfig(betterproto2.Message):
    """
    Configuration for listener connection balancing.

    Oneofs:
        - balance_type:
    """

    exact_balance: "ListenerConnectionBalanceConfigExactBalance | None" = (
        betterproto2.field(
            1, betterproto2.TYPE_MESSAGE, optional=True, group="balance_type"
        )
    )
    """
    If specified, the listener will use the exact connection balancer.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.api.v2", "Listener.ConnectionBalanceConfig", ListenerConnectionBalanceConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ListenerConnectionBalanceConfigExactBalance(betterproto2.Message):
    """
    A connection balancer implementation that does exact balancing. This means that a lock is
    held during balancing so that connection counts are nearly exactly balanced between worker
    threads. This is "nearly" exact in the sense that a connection might close in parallel thus
    making the counts incorrect, but this should be rectified on the next accept. This balancer
    sacrifices accept throughput for accuracy and should be used when there are a small number of
    connections that rarely cycle (e.g., service mesh gRPC egress).
    """

    pass


default_message_pool.register_message(
    "envoy.api.v2",
    "Listener.ConnectionBalanceConfig.ExactBalance",
    ListenerConnectionBalanceConfigExactBalance,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ListenerDeprecatedV1(betterproto2.Message):
    """
    [#not-implemented-hide:]
    """

    bind_to_port: "bool | None" = betterproto2.field(
        1,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.BoolValue,
        optional=True,
    )
    """
    Whether the listener should bind to the port. A listener that doesn't
    bind can only receive connections redirected from other listeners that
    set use_original_dst parameter to true. Default is true.

    This is deprecated in v2, all Listeners will bind to their port. An
    additional filter chain must be created for every original destination
    port this listener may redirect to in v2, with the original port
    specified in the FilterChainMatch destination_port field.

    [#comment:TODO(PiotrSikora): Remove this once verified that we no longer need it.]
    """


default_message_pool.register_message(
    "envoy.api.v2", "Listener.DeprecatedV1", ListenerDeprecatedV1
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LoadBalancingPolicy(betterproto2.Message):
    """
    [#not-implemented-hide:] Extensible load balancing policy configuration.

    Every LB policy defined via this mechanism will be identified via a unique name using reverse
    DNS notation. If the policy needs configuration parameters, it must define a message for its
    own configuration, which will be stored in the config field. The name of the policy will tell
    clients which type of message they should expect to see in the config field.

    Note that there are cases where it is useful to be able to independently select LB policies
    for choosing a locality and for choosing an endpoint within that locality. For example, a
    given deployment may always use the same policy to choose the locality, but for choosing the
    endpoint within the locality, some clusters may use weighted-round-robin, while others may
    use some sort of session-based balancing.

    This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
    child LB policy for each locality. For each request, the parent chooses the locality and then
    delegates to the child policy for that locality to choose the endpoint within the locality.

    To facilitate this, the config message for the top-level LB policy may include a field of
    type LoadBalancingPolicy that specifies the child policy.
    """

    policies: "list[LoadBalancingPolicyPolicy]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Each client will iterate over the list in order and stop at the first policy that it
    supports. This provides a mechanism for starting to use new LB policies that are not yet
    supported by all clients.
    """


default_message_pool.register_message(
    "envoy.api.v2", "LoadBalancingPolicy", LoadBalancingPolicy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class LoadBalancingPolicyPolicy(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    Required. The name of the LB policy.
    """

    config: "___google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional config for the LB policy.
    No more than one of these two fields may be populated.
    """

    typed_config: "___google__protobuf__.Any | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("config"):
            warnings.warn(
                "LoadBalancingPolicyPolicy.config is deprecated", DeprecationWarning
            )


default_message_pool.register_message(
    "envoy.api.v2", "LoadBalancingPolicy.Policy", LoadBalancingPolicyPolicy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
    """

    pass


default_message_pool.register_message("envoy.api.v2", "RdsDummy", RdsDummy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Resource(betterproto2.Message):
    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )
    """
    The resource's name, to distinguish it from others of the same type of resource.
    """

    aliases: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )
    """
    The aliases are a list of other names that this resource can go by.
    """

    version: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The resource level version. It allows xDS to track the state of individual
    resources.
    """

    resource: "___google__protobuf__.Any | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The resource being tracked.
    """


default_message_pool.register_message("envoy.api.v2", "Resource", Resource)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RouteConfiguration(betterproto2.Message):
    """
    [#protodoc-title: HTTP route configuration]
    * Routing :ref:`architecture overview <arch_overview_http_routing>`
    * HTTP :ref:`router filter <config_http_filters_router>`

    [#next-free-field: 11]
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name of the route configuration. For example, it might match
    :ref:`route_config_name
    <envoy_api_field_config.filter.network.http_connection_manager.v2.Rds.route_config_name>` in
    :ref:`envoy_api_msg_config.filter.network.http_connection_manager.v2.Rds`.
    """

    virtual_hosts: "list[route.VirtualHost]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    An array of virtual hosts that make up the route table.
    """

    vhds: "Vhds | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An array of virtual hosts will be dynamically loaded via the VHDS API.
    Both *virtual_hosts* and *vhds* fields will be used when present. *virtual_hosts* can be used
    for a base routing table or for infrequently changing virtual hosts. *vhds* is used for
    on-demand discovery of virtual hosts. The contents of these two fields will be merged to
    generate a routing table for a given RouteConfiguration, with *vhds* derived configuration
    taking precedence.
    """

    internal_only_headers: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Optionally specifies a list of HTTP headers that the connection manager
    will consider to be internal only. If they are found on external requests they will be cleaned
    prior to filter invocation. See :ref:`config_http_conn_man_headers_x-envoy-internal` for more
    information.
    """

    response_headers_to_add: "list[core.HeaderValueOption]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a list of HTTP headers that should be added to each response that
    the connection manager encodes. Headers specified at this level are applied
    after headers from any enclosed :ref:`envoy_api_msg_route.VirtualHost` or
    :ref:`envoy_api_msg_route.RouteAction`. For more information, including details on
    header value syntax, see the documentation on :ref:`custom request headers
    <config_http_conn_man_headers_custom_request_headers>`.
    """

    response_headers_to_remove: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        5, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Specifies a list of HTTP headers that should be removed from each response
    that the connection manager encodes.
    """

    request_headers_to_add: "list[core.HeaderValueOption]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Specifies a list of HTTP headers that should be added to each request
    routed by the HTTP connection manager. Headers specified at this level are
    applied after headers from any enclosed :ref:`envoy_api_msg_route.VirtualHost` or
    :ref:`envoy_api_msg_route.RouteAction`. For more information, including details on
    header value syntax, see the documentation on :ref:`custom request headers
    <config_http_conn_man_headers_custom_request_headers>`.
    """

    request_headers_to_remove: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        8, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Specifies a list of HTTP headers that should be removed from each request
    routed by the HTTP connection manager.
    """

    most_specific_header_mutations_wins: "bool" = betterproto2.field(
        10, betterproto2.TYPE_BOOL
    )
    """
    By default, headers that should be added/removed are evaluated from most to least specific:

    * route level
    * virtual host level
    * connection manager level

    To allow setting overrides at the route or virtual host level, this order can be reversed
    by setting this option to true. Defaults to false.

    [#next-major-version: In the v3 API, this will default to true.]
    """

    validate_clusters: "bool | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.BoolValue,
        optional=True,
    )
    """
    An optional boolean that specifies whether the clusters that the route
    table refers to will be validated by the cluster manager. If set to true
    and a route refers to a non-existent cluster, the route table will not
    load. If set to false and a route refers to a non-existent cluster, the
    route table will load and the router filter will return a 404 if the route
    is selected at runtime. This setting defaults to true if the route table
    is statically defined via the :ref:`route_config
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.route_config>`
    option. This setting default to false if the route table is loaded dynamically via the
    :ref:`rds
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.rds>`
    option. Users may wish to override the default behavior in certain cases (for example when
    using CDS with a static route table).
    """


default_message_pool.register_message(
    "envoy.api.v2", "RouteConfiguration", RouteConfiguration
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ScopedRouteConfiguration(betterproto2.Message):
    """
    [#protodoc-title: HTTP scoped routing configuration]
    * Routing :ref:`architecture overview <arch_overview_http_routing>`

    Specifies a routing scope, which associates a
    :ref:`Key<envoy_api_msg_ScopedRouteConfiguration.Key>` to a
    :ref:`envoy_api_msg_RouteConfiguration` (identified by its resource name).

    The HTTP connection manager builds up a table consisting of these Key to
    RouteConfiguration mappings, and looks up the RouteConfiguration to use per
    request according to the algorithm specified in the
    :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`
    assigned to the HttpConnectionManager.

    For example, with the following configurations (in YAML):

    HttpConnectionManager config:

    .. code::

      ...
      scoped_routes:
        name: foo-scoped-routes
        scope_key_builder:
          fragments:
            - header_value_extractor:
                name: X-Route-Selector
                element_separator: ","
                element:
                  separator: =
                  key: vip

    ScopedRouteConfiguration resources (specified statically via
    :ref:`scoped_route_configurations_list<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scoped_route_configurations_list>`
    or obtained dynamically via SRDS):

    .. code::

     (1)
      name: route-scope1
      route_configuration_name: route-config1
      key:
         fragments:
           - string_key: 172.10.10.20

     (2)
      name: route-scope2
      route_configuration_name: route-config2
      key:
        fragments:
          - string_key: 172.20.20.30

    A request from a client such as:

    .. code::

        GET / HTTP/1.1
        Host: foo.com
        X-Route-Selector: vip=172.10.10.20

    would result in the routing table defined by the `route-config1`
    RouteConfiguration being assigned to the HTTP request/stream.
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )
    """
    The name assigned to the routing scope.
    """

    route_configuration_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    The resource name to use for a :ref:`envoy_api_msg_DiscoveryRequest` to an
    RDS server to fetch the :ref:`envoy_api_msg_RouteConfiguration` associated
    with this scope.
    """

    key: "ScopedRouteConfigurationKey | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The key to match against.
    """


default_message_pool.register_message(
    "envoy.api.v2", "ScopedRouteConfiguration", ScopedRouteConfiguration
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ScopedRouteConfigurationKey(betterproto2.Message):
    """
    Specifies a key which is matched against the output of the
    :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`
    specified in the HttpConnectionManager. The matching is done per HTTP
    request and is dependent on the order of the fragments contained in the
    Key.
    """

    fragments: "list[ScopedRouteConfigurationKeyFragment]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The ordered set of fragments to match against. The order must match the
    fragments in the corresponding
    :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`.
    """


default_message_pool.register_message(
    "envoy.api.v2", "ScopedRouteConfiguration.Key", ScopedRouteConfigurationKey
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ScopedRouteConfigurationKeyFragment(betterproto2.Message):
    """


    Oneofs:
        - type:
    """

    string_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="type"
    )
    """
    A string to match against.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "envoy.api.v2",
    "ScopedRouteConfiguration.Key.Fragment",
    ScopedRouteConfigurationKeyFragment,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SrdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
    """

    pass


default_message_pool.register_message("envoy.api.v2", "SrdsDummy", SrdsDummy)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UpstreamBindConfig(betterproto2.Message):
    """
    An extensible structure containing the address Envoy should bind to when
    establishing upstream connections.
    """

    source_address: "core.Address | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The address Envoy should bind to when establishing upstream connections.
    """


default_message_pool.register_message(
    "envoy.api.v2", "UpstreamBindConfig", UpstreamBindConfig
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class UpstreamConnectionOptions(betterproto2.Message):
    tcp_keepalive: "core.TcpKeepalive | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    """


default_message_pool.register_message(
    "envoy.api.v2", "UpstreamConnectionOptions", UpstreamConnectionOptions
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Vhds(betterproto2.Message):
    config_source: "core.ConfigSource | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Configuration source specifier for VHDS.
    """


default_message_pool.register_message("envoy.api.v2", "Vhds", Vhds)


class ClusterDiscoveryServiceSyncStub:
    """
    [#protodoc-title: CDS]

    Return list of all clusters this proxy will load balance to.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_clusters(
        self, messages: "Iterable[DiscoveryRequest]"
    ) -> "Iterator[DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.ClusterDiscoveryService/StreamClusters",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_clusters(
        self, messages: "Iterable[DeltaDiscoveryRequest]"
    ) -> "Iterator[DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.ClusterDiscoveryService/DeltaClusters",
            DeltaDiscoveryRequest.SerializeToString,
            DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_clusters(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.api.v2.ClusterDiscoveryService/FetchClusters",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(message)


class ClusterDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: CDS]

    Return list of all clusters this proxy will load balance to.
    """

    async def stream_clusters(
        self,
        messages: "AsyncIterable[DiscoveryRequest] | Iterable[DiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.ClusterDiscoveryService/StreamClusters",
            messages,
            DiscoveryRequest,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delta_clusters(
        self,
        messages: "AsyncIterable[DeltaDiscoveryRequest] | Iterable[DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.ClusterDiscoveryService/DeltaClusters",
            messages,
            DeltaDiscoveryRequest,
            DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_clusters(
        self,
        message: "DiscoveryRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "DiscoveryResponse":
        return await self._unary_unary(
            "/envoy.api.v2.ClusterDiscoveryService/FetchClusters",
            message,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class EndpointDiscoveryServiceSyncStub:
    """
    [#protodoc-title: EDS]
    Endpoint discovery :ref:`architecture overview <arch_overview_service_discovery_types_eds>`
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_endpoints(
        self, messages: "Iterable[DiscoveryRequest]"
    ) -> "Iterator[DiscoveryResponse]":
        """
        The resource_names field in DiscoveryRequest specifies a list of clusters
        to subscribe to updates for.
        """

        yield from self._channel.stream_stream(
            "/envoy.api.v2.EndpointDiscoveryService/StreamEndpoints",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_endpoints(
        self, messages: "Iterable[DeltaDiscoveryRequest]"
    ) -> "Iterator[DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.EndpointDiscoveryService/DeltaEndpoints",
            DeltaDiscoveryRequest.SerializeToString,
            DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_endpoints(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.api.v2.EndpointDiscoveryService/FetchEndpoints",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(message)


class EndpointDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: EDS]
    Endpoint discovery :ref:`architecture overview <arch_overview_service_discovery_types_eds>`
    """

    async def stream_endpoints(
        self,
        messages: "AsyncIterable[DiscoveryRequest] | Iterable[DiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DiscoveryResponse]":
        """
        The resource_names field in DiscoveryRequest specifies a list of clusters
        to subscribe to updates for.
        """

        async for response in self._stream_stream(
            "/envoy.api.v2.EndpointDiscoveryService/StreamEndpoints",
            messages,
            DiscoveryRequest,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delta_endpoints(
        self,
        messages: "AsyncIterable[DeltaDiscoveryRequest] | Iterable[DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.EndpointDiscoveryService/DeltaEndpoints",
            messages,
            DeltaDiscoveryRequest,
            DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_endpoints(
        self,
        message: "DiscoveryRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "DiscoveryResponse":
        return await self._unary_unary(
            "/envoy.api.v2.EndpointDiscoveryService/FetchEndpoints",
            message,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ListenerDiscoveryServiceSyncStub:
    """
    [#protodoc-title: Listener]
    Listener :ref:`configuration overview <config_listeners>`

    The Envoy instance initiates an RPC at startup to discover a list of
    listeners. Updates are delivered via streaming from the LDS server and
    consist of a complete update of all listeners. Existing connections will be
    allowed to drain from listeners that are no longer present.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def delta_listeners(
        self, messages: "Iterable[DeltaDiscoveryRequest]"
    ) -> "Iterator[DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.ListenerDiscoveryService/DeltaListeners",
            DeltaDiscoveryRequest.SerializeToString,
            DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def stream_listeners(
        self, messages: "Iterable[DiscoveryRequest]"
    ) -> "Iterator[DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.ListenerDiscoveryService/StreamListeners",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_listeners(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.api.v2.ListenerDiscoveryService/FetchListeners",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(message)


class ListenerDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: Listener]
    Listener :ref:`configuration overview <config_listeners>`

    The Envoy instance initiates an RPC at startup to discover a list of
    listeners. Updates are delivered via streaming from the LDS server and
    consist of a complete update of all listeners. Existing connections will be
    allowed to drain from listeners that are no longer present.
    """

    async def delta_listeners(
        self,
        messages: "AsyncIterable[DeltaDiscoveryRequest] | Iterable[DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.ListenerDiscoveryService/DeltaListeners",
            messages,
            DeltaDiscoveryRequest,
            DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def stream_listeners(
        self,
        messages: "AsyncIterable[DiscoveryRequest] | Iterable[DiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.ListenerDiscoveryService/StreamListeners",
            messages,
            DiscoveryRequest,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_listeners(
        self,
        message: "DiscoveryRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "DiscoveryResponse":
        return await self._unary_unary(
            "/envoy.api.v2.ListenerDiscoveryService/FetchListeners",
            message,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class RouteDiscoveryServiceSyncStub:
    """
    [#protodoc-title: RDS]

    The resource_names field in DiscoveryRequest specifies a route configuration.
    This allows an Envoy configuration with multiple HTTP listeners (and
    associated HTTP connection manager filters) to use different route
    configurations. Each listener will bind its HTTP connection manager filter to
    a route table via this identifier.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_routes(
        self, messages: "Iterable[DiscoveryRequest]"
    ) -> "Iterator[DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.RouteDiscoveryService/StreamRoutes",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_routes(
        self, messages: "Iterable[DeltaDiscoveryRequest]"
    ) -> "Iterator[DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.RouteDiscoveryService/DeltaRoutes",
            DeltaDiscoveryRequest.SerializeToString,
            DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_routes(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.api.v2.RouteDiscoveryService/FetchRoutes",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(message)


class RouteDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: RDS]

    The resource_names field in DiscoveryRequest specifies a route configuration.
    This allows an Envoy configuration with multiple HTTP listeners (and
    associated HTTP connection manager filters) to use different route
    configurations. Each listener will bind its HTTP connection manager filter to
    a route table via this identifier.
    """

    async def stream_routes(
        self,
        messages: "AsyncIterable[DiscoveryRequest] | Iterable[DiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.RouteDiscoveryService/StreamRoutes",
            messages,
            DiscoveryRequest,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delta_routes(
        self,
        messages: "AsyncIterable[DeltaDiscoveryRequest] | Iterable[DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.RouteDiscoveryService/DeltaRoutes",
            messages,
            DeltaDiscoveryRequest,
            DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_routes(
        self,
        message: "DiscoveryRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "DiscoveryResponse":
        return await self._unary_unary(
            "/envoy.api.v2.RouteDiscoveryService/FetchRoutes",
            message,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ScopedRoutesDiscoveryServiceSyncStub:
    """
    [#protodoc-title: SRDS]
    * Routing :ref:`architecture overview <arch_overview_http_routing>`

    The Scoped Routes Discovery Service (SRDS) API distributes
    :ref:`ScopedRouteConfiguration<envoy_api_msg.ScopedRouteConfiguration>`
    resources. Each ScopedRouteConfiguration resource represents a "routing
    scope" containing a mapping that allows the HTTP connection manager to
    dynamically assign a routing table (specified via a
    :ref:`RouteConfiguration<envoy_api_msg_RouteConfiguration>` message) to each
    HTTP request.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_scoped_routes(
        self, messages: "Iterable[DiscoveryRequest]"
    ) -> "Iterator[DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.ScopedRoutesDiscoveryService/StreamScopedRoutes",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_scoped_routes(
        self, messages: "Iterable[DeltaDiscoveryRequest]"
    ) -> "Iterator[DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.ScopedRoutesDiscoveryService/DeltaScopedRoutes",
            DeltaDiscoveryRequest.SerializeToString,
            DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_scoped_routes(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.api.v2.ScopedRoutesDiscoveryService/FetchScopedRoutes",
            DiscoveryRequest.SerializeToString,
            DiscoveryResponse.FromString,
        )(message)


class ScopedRoutesDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    [#protodoc-title: SRDS]
    * Routing :ref:`architecture overview <arch_overview_http_routing>`

    The Scoped Routes Discovery Service (SRDS) API distributes
    :ref:`ScopedRouteConfiguration<envoy_api_msg.ScopedRouteConfiguration>`
    resources. Each ScopedRouteConfiguration resource represents a "routing
    scope" containing a mapping that allows the HTTP connection manager to
    dynamically assign a routing table (specified via a
    :ref:`RouteConfiguration<envoy_api_msg_RouteConfiguration>` message) to each
    HTTP request.
    """

    async def stream_scoped_routes(
        self,
        messages: "AsyncIterable[DiscoveryRequest] | Iterable[DiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.ScopedRoutesDiscoveryService/StreamScopedRoutes",
            messages,
            DiscoveryRequest,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delta_scoped_routes(
        self,
        messages: "AsyncIterable[DeltaDiscoveryRequest] | Iterable[DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.ScopedRoutesDiscoveryService/DeltaScopedRoutes",
            messages,
            DeltaDiscoveryRequest,
            DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def fetch_scoped_routes(
        self,
        message: "DiscoveryRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "DiscoveryResponse":
        return await self._unary_unary(
            "/envoy.api.v2.ScopedRoutesDiscoveryService/FetchScopedRoutes",
            message,
            DiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class VirtualHostDiscoveryServiceSyncStub:
    """
    Virtual Host Discovery Service (VHDS) is used to dynamically update the list of virtual hosts for
    a given RouteConfiguration. If VHDS is configured a virtual host list update will be triggered
    during the processing of an HTTP request if a route for the request cannot be resolved. The
    :ref:`resource_names_subscribe <envoy_api_field_DeltaDiscoveryRequest.resource_names_subscribe>`
    field contains a list of virtual host names or aliases to track. The contents of an alias would
    be the contents of a *host* or *authority* header used to make an http request. An xDS server
    will match an alias to a virtual host based on the content of :ref:`domains'
    <envoy_api_field_route.VirtualHost.domains>` field. The *resource_names_unsubscribe* field
    contains a list of virtual host names that have been :ref:`unsubscribed
    <xds_protocol_unsubscribe>` from the routing table associated with the RouteConfiguration.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def delta_virtual_hosts(
        self, messages: "Iterable[DeltaDiscoveryRequest]"
    ) -> "Iterator[DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.api.v2.VirtualHostDiscoveryService/DeltaVirtualHosts",
            DeltaDiscoveryRequest.SerializeToString,
            DeltaDiscoveryResponse.FromString,
        )(iter(messages))


class VirtualHostDiscoveryServiceAsyncStub(betterproto2_grpclib.ServiceStub):
    """
    Virtual Host Discovery Service (VHDS) is used to dynamically update the list of virtual hosts for
    a given RouteConfiguration. If VHDS is configured a virtual host list update will be triggered
    during the processing of an HTTP request if a route for the request cannot be resolved. The
    :ref:`resource_names_subscribe <envoy_api_field_DeltaDiscoveryRequest.resource_names_subscribe>`
    field contains a list of virtual host names or aliases to track. The contents of an alias would
    be the contents of a *host* or *authority* header used to make an http request. An xDS server
    will match an alias to a virtual host based on the content of :ref:`domains'
    <envoy_api_field_route.VirtualHost.domains>` field. The *resource_names_unsubscribe* field
    contains a list of virtual host names that have been :ref:`unsubscribed
    <xds_protocol_unsubscribe>` from the routing table associated with the RouteConfiguration.
    """

    async def delta_virtual_hosts(
        self,
        messages: "AsyncIterable[DeltaDiscoveryRequest] | Iterable[DeltaDiscoveryRequest]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        async for response in self._stream_stream(
            "/envoy.api.v2.VirtualHostDiscoveryService/DeltaVirtualHosts",
            messages,
            DeltaDiscoveryRequest,
            DeltaDiscoveryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


from ....google import protobuf as ___google__protobuf__
from ....google import rpc as ___google__rpc__
from ... import type as __type__
from ...config.filter.accesslog import v2 as __config__filter__accesslog__v2__
from ...config.listener import v2 as __config__listener__v2__
from . import auth, cluster, core, endpoint, listener, route


class ClusterDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: CDS]

    Return list of all clusters this proxy will load balance to.
    """

    async def stream_clusters(
        self, messages: "AsyncIterator[DiscoveryRequest]"
    ) -> "AsyncIterator[DiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DiscoveryResponse()

    async def delta_clusters(
        self, messages: "AsyncIterator[DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeltaDiscoveryResponse()

    async def fetch_clusters(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_clusters(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_clusters,
            stream,
            request,
        )

    async def __rpc_delta_clusters(
        self,
        stream: "grpclib.server.Stream[DeltaDiscoveryRequest, DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_clusters,
            stream,
            request,
        )

    async def __rpc_fetch_clusters(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_clusters(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.api.v2.ClusterDiscoveryService/StreamClusters": grpclib.const.Handler(
                self.__rpc_stream_clusters,
                grpclib.const.Cardinality.STREAM_STREAM,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
            "/envoy.api.v2.ClusterDiscoveryService/DeltaClusters": grpclib.const.Handler(
                self.__rpc_delta_clusters,
                grpclib.const.Cardinality.STREAM_STREAM,
                DeltaDiscoveryRequest,
                DeltaDiscoveryResponse,
            ),
            "/envoy.api.v2.ClusterDiscoveryService/FetchClusters": grpclib.const.Handler(
                self.__rpc_fetch_clusters,
                grpclib.const.Cardinality.UNARY_UNARY,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
        }


class EndpointDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: EDS]
    Endpoint discovery :ref:`architecture overview <arch_overview_service_discovery_types_eds>`
    """

    async def stream_endpoints(
        self, messages: "AsyncIterator[DiscoveryRequest]"
    ) -> "AsyncIterator[DiscoveryResponse]":
        """
        The resource_names field in DiscoveryRequest specifies a list of clusters
        to subscribe to updates for.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DiscoveryResponse()

    async def delta_endpoints(
        self, messages: "AsyncIterator[DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeltaDiscoveryResponse()

    async def fetch_endpoints(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_endpoints(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_endpoints,
            stream,
            request,
        )

    async def __rpc_delta_endpoints(
        self,
        stream: "grpclib.server.Stream[DeltaDiscoveryRequest, DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_endpoints,
            stream,
            request,
        )

    async def __rpc_fetch_endpoints(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_endpoints(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.api.v2.EndpointDiscoveryService/StreamEndpoints": grpclib.const.Handler(
                self.__rpc_stream_endpoints,
                grpclib.const.Cardinality.STREAM_STREAM,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
            "/envoy.api.v2.EndpointDiscoveryService/DeltaEndpoints": grpclib.const.Handler(
                self.__rpc_delta_endpoints,
                grpclib.const.Cardinality.STREAM_STREAM,
                DeltaDiscoveryRequest,
                DeltaDiscoveryResponse,
            ),
            "/envoy.api.v2.EndpointDiscoveryService/FetchEndpoints": grpclib.const.Handler(
                self.__rpc_fetch_endpoints,
                grpclib.const.Cardinality.UNARY_UNARY,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
        }


class ListenerDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: Listener]
    Listener :ref:`configuration overview <config_listeners>`

    The Envoy instance initiates an RPC at startup to discover a list of
    listeners. Updates are delivered via streaming from the LDS server and
    consist of a complete update of all listeners. Existing connections will be
    allowed to drain from listeners that are no longer present.
    """

    async def delta_listeners(
        self, messages: "AsyncIterator[DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeltaDiscoveryResponse()

    async def stream_listeners(
        self, messages: "AsyncIterator[DiscoveryRequest]"
    ) -> "AsyncIterator[DiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DiscoveryResponse()

    async def fetch_listeners(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_delta_listeners(
        self,
        stream: "grpclib.server.Stream[DeltaDiscoveryRequest, DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_listeners,
            stream,
            request,
        )

    async def __rpc_stream_listeners(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_listeners,
            stream,
            request,
        )

    async def __rpc_fetch_listeners(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_listeners(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.api.v2.ListenerDiscoveryService/DeltaListeners": grpclib.const.Handler(
                self.__rpc_delta_listeners,
                grpclib.const.Cardinality.STREAM_STREAM,
                DeltaDiscoveryRequest,
                DeltaDiscoveryResponse,
            ),
            "/envoy.api.v2.ListenerDiscoveryService/StreamListeners": grpclib.const.Handler(
                self.__rpc_stream_listeners,
                grpclib.const.Cardinality.STREAM_STREAM,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
            "/envoy.api.v2.ListenerDiscoveryService/FetchListeners": grpclib.const.Handler(
                self.__rpc_fetch_listeners,
                grpclib.const.Cardinality.UNARY_UNARY,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
        }


class RouteDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: RDS]

    The resource_names field in DiscoveryRequest specifies a route configuration.
    This allows an Envoy configuration with multiple HTTP listeners (and
    associated HTTP connection manager filters) to use different route
    configurations. Each listener will bind its HTTP connection manager filter to
    a route table via this identifier.
    """

    async def stream_routes(
        self, messages: "AsyncIterator[DiscoveryRequest]"
    ) -> "AsyncIterator[DiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DiscoveryResponse()

    async def delta_routes(
        self, messages: "AsyncIterator[DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeltaDiscoveryResponse()

    async def fetch_routes(self, message: "DiscoveryRequest") -> "DiscoveryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_routes(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_routes,
            stream,
            request,
        )

    async def __rpc_delta_routes(
        self,
        stream: "grpclib.server.Stream[DeltaDiscoveryRequest, DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_routes,
            stream,
            request,
        )

    async def __rpc_fetch_routes(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_routes(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.api.v2.RouteDiscoveryService/StreamRoutes": grpclib.const.Handler(
                self.__rpc_stream_routes,
                grpclib.const.Cardinality.STREAM_STREAM,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
            "/envoy.api.v2.RouteDiscoveryService/DeltaRoutes": grpclib.const.Handler(
                self.__rpc_delta_routes,
                grpclib.const.Cardinality.STREAM_STREAM,
                DeltaDiscoveryRequest,
                DeltaDiscoveryResponse,
            ),
            "/envoy.api.v2.RouteDiscoveryService/FetchRoutes": grpclib.const.Handler(
                self.__rpc_fetch_routes,
                grpclib.const.Cardinality.UNARY_UNARY,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
        }


class ScopedRoutesDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    [#protodoc-title: SRDS]
    * Routing :ref:`architecture overview <arch_overview_http_routing>`

    The Scoped Routes Discovery Service (SRDS) API distributes
    :ref:`ScopedRouteConfiguration<envoy_api_msg.ScopedRouteConfiguration>`
    resources. Each ScopedRouteConfiguration resource represents a "routing
    scope" containing a mapping that allows the HTTP connection manager to
    dynamically assign a routing table (specified via a
    :ref:`RouteConfiguration<envoy_api_msg_RouteConfiguration>` message) to each
    HTTP request.
    """

    async def stream_scoped_routes(
        self, messages: "AsyncIterator[DiscoveryRequest]"
    ) -> "AsyncIterator[DiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DiscoveryResponse()

    async def delta_scoped_routes(
        self, messages: "AsyncIterator[DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeltaDiscoveryResponse()

    async def fetch_scoped_routes(
        self, message: "DiscoveryRequest"
    ) -> "DiscoveryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_scoped_routes(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.stream_scoped_routes,
            stream,
            request,
        )

    async def __rpc_delta_scoped_routes(
        self,
        stream: "grpclib.server.Stream[DeltaDiscoveryRequest, DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_scoped_routes,
            stream,
            request,
        )

    async def __rpc_fetch_scoped_routes(
        self, stream: "grpclib.server.Stream[DiscoveryRequest, DiscoveryResponse]"
    ) -> None:
        request = await stream.recv_message()
        assert request is not None
        response = await self.fetch_scoped_routes(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.api.v2.ScopedRoutesDiscoveryService/StreamScopedRoutes": grpclib.const.Handler(
                self.__rpc_stream_scoped_routes,
                grpclib.const.Cardinality.STREAM_STREAM,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
            "/envoy.api.v2.ScopedRoutesDiscoveryService/DeltaScopedRoutes": grpclib.const.Handler(
                self.__rpc_delta_scoped_routes,
                grpclib.const.Cardinality.STREAM_STREAM,
                DeltaDiscoveryRequest,
                DeltaDiscoveryResponse,
            ),
            "/envoy.api.v2.ScopedRoutesDiscoveryService/FetchScopedRoutes": grpclib.const.Handler(
                self.__rpc_fetch_scoped_routes,
                grpclib.const.Cardinality.UNARY_UNARY,
                DiscoveryRequest,
                DiscoveryResponse,
            ),
        }


class VirtualHostDiscoveryServiceBase(betterproto2_grpclib.ServiceBase):
    """
    Virtual Host Discovery Service (VHDS) is used to dynamically update the list of virtual hosts for
    a given RouteConfiguration. If VHDS is configured a virtual host list update will be triggered
    during the processing of an HTTP request if a route for the request cannot be resolved. The
    :ref:`resource_names_subscribe <envoy_api_field_DeltaDiscoveryRequest.resource_names_subscribe>`
    field contains a list of virtual host names or aliases to track. The contents of an alias would
    be the contents of a *host* or *authority* header used to make an http request. An xDS server
    will match an alias to a virtual host based on the content of :ref:`domains'
    <envoy_api_field_route.VirtualHost.domains>` field. The *resource_names_unsubscribe* field
    contains a list of virtual host names that have been :ref:`unsubscribed
    <xds_protocol_unsubscribe>` from the routing table associated with the RouteConfiguration.
    """

    async def delta_virtual_hosts(
        self, messages: "AsyncIterator[DeltaDiscoveryRequest]"
    ) -> "AsyncIterator[DeltaDiscoveryResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DeltaDiscoveryResponse()

    async def __rpc_delta_virtual_hosts(
        self,
        stream: "grpclib.server.Stream[DeltaDiscoveryRequest, DeltaDiscoveryResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.delta_virtual_hosts,
            stream,
            request,
        )

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/envoy.api.v2.VirtualHostDiscoveryService/DeltaVirtualHosts": grpclib.const.Handler(
                self.__rpc_delta_virtual_hosts,
                grpclib.const.Cardinality.STREAM_STREAM,
                DeltaDiscoveryRequest,
                DeltaDiscoveryResponse,
            ),
        }
