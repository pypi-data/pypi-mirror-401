/*####################################################################################
# Generated by Acuity
# Original model: #TFLMZSP_REPLACE_MODEL_NAME#
#
####################################################################################*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "model.h"

#include "tflm_zsp_wrap.h"
#include "model_data.h"





#define TFLM_ZSP_TENSOR_CNT  #TFLMZSP_REPLACE_TENSORS_CNT#
#define TFLM_ZSP_CONST_TENSOR_CNT  #TFLMZSP_REPLACE_CONST_TENSORS_CNT#
#define TFLM_ZSP_NORM_TENSOR_CNT  #TFLMZSP_REPLACE_NORMAL_TENSORS_CNT#
#define TFLM_ZSP_NODE_CNT  #TFLMZSP_REPLACE_NODE_CNT#
#define TFLM_ZSP_GRAPH_INPUT_CNT  #TFLMZSP_REPLACE_GRAPH_INPUT_CNT#
#define TFLM_ZSP_GRAPH_OUTPUT_CNT  #TFLMZSP_REPLACE_GRAPH_OUTPUT_CNT#





#define NEW_TFLM_ZSP_CONST_TENSOR(tid, tens_dim, tens_type, const_data)        \
	const_tensor[tid] = malloc(sizeof(TFLMZSP_Tensor));        \
	memset(const_tensor[tid], 0, sizeof(TFLMZSP_Tensor));        \
	const_tensor[tid]->dim.size = tens_dim.size;        \
	memcpy(const_tensor[tid]->dim.data, tens_dim.data, tens_dim.size*sizeof(int));        \
	const_tensor[tid]->type = tens_type;        \
	const_tensor[tid]->is_const = 1;             \
	const_tensor[tid]->data = const_data;


#define NEW_TFLM_ZSP_NORMAL_TENSOR(tid, tens_dim, tens_type)        \
	{int tmp_size = 1;        \
	norm_tensor[tid] = malloc(sizeof(TFLMZSP_Tensor));        \
	memset(norm_tensor[tid], 0, sizeof(TFLMZSP_Tensor));        \
	norm_tensor[tid]->dim.size = tens_dim.size;        \
	memcpy(norm_tensor[tid]->dim.data, tens_dim.data, tens_dim.size*sizeof(int));        \
	norm_tensor[tid]->type = tens_type;        \
	norm_tensor[tid]->is_const = 0;                                           \
	for(i = 0; i < tens_dim.size; i++) {tmp_size *=  tens_dim.data[i];}        \
	norm_tensor[tid]->data = (void *)malloc(tmp_size*get_tensor_size_by_type(tens_type));}


#define NEW_TFLM_ZSP_NORMAL_TENSOR_ALIGN_C_TO_4(tid, tens_dim, tens_type)        \
	{int tmp_size = 1;        \
	norm_tensor[tid] = malloc(sizeof(TFLMZSP_Tensor));        \
	memset(norm_tensor[tid], 0, sizeof(TFLMZSP_Tensor));        \
	norm_tensor[tid]->dim.size = tens_dim.size;        \
	memcpy(norm_tensor[tid]->dim.data, tens_dim.data, tens_dim.size*sizeof(int));        \
	norm_tensor[tid]->type = tens_type;        \
	norm_tensor[tid]->is_const = 0;                                           \
	if(tens_dim.size == 4) {tmp_size *= ((3+tens_dim.data[3])/4*4); tens_dim.size = 3;}        \
	for(i = 0; i < tens_dim.size; i++) {tmp_size *=  tens_dim.data[i];}        \
	norm_tensor[tid]->data = (void *)malloc(tmp_size*get_tensor_size_by_type(tens_type));}




#define NEW_TFLM_ZSP_NODE(nid, node_name, num_in, num_out)        \
	node[nid] = malloc(sizeof(TFLMZSP_Node));        \
	memset(node[nid], 0, sizeof(TFLMZSP_Node));        \
	strcpy(node[nid]->name, node_name);        \
	node[nid]->num_inputs = num_in;        \
	node[nid]->num_outputs = num_out;

#define INIT_TFLM_ZSP_GRAPH(graph, num_in, num_out, num_node, num_tens)        \
	memset(graph, 0, sizeof(TFLMZSP_Graph));        \
	graph->num_inputs = num_in;        \
	graph->num_outputs = num_out;        \
	graph->num_nodes = num_node;        \
	graph->num_tensors = num_tens;        \
	for(i = 0; i < TFLM_ZSP_CONST_TENSOR_CNT; i++) {        \
		graph->tensors[i] = const_tensor[i];        \
	}        \
	for(i = 0; i < TFLM_ZSP_NORM_TENSOR_CNT; i++) {        \
		graph->tensors[i+TFLM_ZSP_CONST_TENSOR_CNT] = norm_tensor[i];        \
	}        \
	for(i = 0; i < graph->num_nodes; i++) {        \
		graph->nodes[i] = node[i];        \
	}




#define INIT_TFLM_ZSP_NODE_PARAM_BUILTIN(nid, param_name, value)        \
	node[nid]->params.builtin.param_name = value;


#define INIT_TFLM_ZSP_NODE_PARAM_USERDATA(nid, param_name, value)        \
	node[nid]->params.userdata.param_name = value;





//TODO: how to handle TFLMZSP_String/TFLMZSP_Resource/TFLMZSP_Variant ?
int get_tensor_size_by_type(int type)
{
	int bytes = 0;
	switch(type) {
		case TFLMZSP_Float32:
		case TFLMZSP_Int32:
		case TFLMZSP_UInt32:
			bytes = 4;
			break;
		case TFLMZSP_UInt8:
		case TFLMZSP_Int8:
		case TFLMZSP_Bool:
			bytes = 1;
			break;
		case TFLMZSP_Int64:
		case TFLMZSP_UInt64:
		case TFLMZSP_Float64:
		case TFLMZSP_Complex64:
			bytes = 8;
			break;
		case TFLMZSP_Int16:
		case TFLMZSP_UInt16:
		case TFLMZSP_Float16:
			bytes = 2;
			break;
		case TFLMZSP_Complex128:
			bytes = 16;
			break;
		default:
			break;
	}
	return bytes;
}



int tflm_zsp_get_graph_input_size(TFLMZSP_Graph_PTR graph, int input_index)
{
	int size = 1;
	int i;
	TFLMZSP_Tensor_PTR input = graph->inputs[input_index];
	for(i = 0; i < input->dim.size; i++) {size *=  input->dim.data[i];}
	size *= get_tensor_size_by_type(input->type);
	return size;
}


int tflm_zsp_get_graph_output_size(TFLMZSP_Graph_PTR graph, int output_index)
{
	int size = 1;
	int i;
	TFLMZSP_Tensor_PTR output = graph->outputs[output_index];
	for(i = 0; i < output->dim.size; i++) {size *=  output->dim.data[i];}
	size *= get_tensor_size_by_type(output->type);
	return size;
}



int tflm_zsp_create_graph(TFLMZSP_Graph_PTR *graph)
{
	int i;

	/*************** define tensors ****************/
	#TFLMZSP_REPLACE_DEFINE_CONST_TENSORS#
	#TFLMZSP_REPLACE_DEFINE_NORMAL_TENSORS#
	TFLMZSP_DimParam dim;


	#TFLMZSP_REPLACE_INIT_NORMAL_TENSORS#




	#TFLMZSP_REPLACE_INIT_CONST_TENSORS#






	/*************** define nodes ****************/
	TFLMZSP_Node_PTR node[TFLM_ZSP_NODE_CNT];
	#TFLMZSP_REPLACE_INIT_NODES#





	/*************** define connections ****************/
	#TFLMZSP_REPLACE_CREATE_CONNECTIONS#





	/*************** define graph ****************/
	TFLMZSP_Graph_PTR graph_local = malloc(sizeof(TFLMZSP_Graph));
	INIT_TFLM_ZSP_GRAPH(graph_local, TFLM_ZSP_GRAPH_INPUT_CNT, TFLM_ZSP_GRAPH_OUTPUT_CNT, TFLM_ZSP_NODE_CNT, TFLM_ZSP_TENSOR_CNT);

	#TFLMZSP_REPLACE_DEFINE_GRAPH_IO#


	*graph = graph_local;
	return 0;
}



#TFLMZSP_REPLACE_DEFINE_WRAP_FUNC_MAPS#







void tflm_zsp_destroy_graph(TFLMZSP_Graph_PTR* graph)
{
	int i;
	TFLMZSP_Graph_PTR graph_local = *graph;

	for (i = 0; i < graph_local->num_nodes; i++)
	{
		if (graph_local->nodes[i] != NULL)
		{
			free(graph_local->nodes[i]);
		}
	}

	for (i = 0; i < graph_local->num_tensors; i++)
	{
		if(graph_local->tensors[i] != NULL)
		{
			if (graph_local->tensors[i]->data != NULL && !graph_local->tensors[i]->is_const)
			{
				free(graph_local->tensors[i]->data);
			}
			free(graph_local->tensors[i]);
		}
	}

	free(graph_local);
	*graph = NULL;
}




int tflm_zsp_process_graph(TFLMZSP_Graph_PTR graph)
{
	int i;
	int ret = 0;
	void *tmp_buf = malloc(1*1024*1024);

	for (i = 0; i < graph->num_nodes; i++) {
		ret = map_wraps[graph->nodes[i]->idx_func].func(graph->nodes[i], tmp_buf);
		if(ret) {
			printf("Error! tflm zsp node %s process failed!\n", graph->nodes[i]->name);
			return -1;
		}
	}


	free(tmp_buf);

	return ret;
}







