# v3.4 → v3.5 迁移指南

> **框架版本**: df-test-framework v3.4.0 → v3.5.0
> **更新日期**: 2025-11-07
> **迁移难度**: ⭐⭐⭐ 中等（配置结构调整）

---

## 📊 概述

v3.5.0是一个**完全重构的版本，不向后兼容v3.4**。主要变更包括：

### 重大变更
1. **移除所有向后兼容代码** - 全新设计，无历史包袱
2. **Pydantic配置回归声明式** - 移除HTTPConfigBuilder抽象层
3. **配置化拦截器系统** - 零代码配置HTTP拦截器
4. **Profile环境配置** - 支持.env.{profile}自动加载
5. **运行时配置覆盖** - with_overrides()实现测试隔离

### 升级收益
- ✅ 更简洁的配置代码（减少20-30%代码量）
- ✅ 零代码拦截器配置（无需手写拦截逻辑）
- ✅ 完整的可观测性集成
- ✅ 灵活的环境配置管理

---

## 🚨 兼容性说明

**不兼容项**:
1. HTTPConfigBuilder已移除 - 回归Pydantic声明式配置
2. 拦截器配置方式变更 - 不再使用model_validator手动配置
3. Settings字段继承规则变更 - Optional字段优先级调整

**建议**: 一次性完成迁移，不要尝试混合使用v3.4和v3.5代码

---

## 📋 迁移步骤

### Step 1: 更新依赖版本

#### pyproject.toml

```toml
[project]
dependencies = [
    "df-test-framework>=3.5.0",  # 更新版本
    # 其他依赖...
]
```

#### 重新安装

```bash
uv pip install --upgrade df-test-framework
```

---

### Step 2: 重构settings.py

这是最关键的一步！v3.5.0的配置方式与v3.4完全不同。

#### v3.4.0 配置方式（旧）

```python
# ❌ v3.4方式 - 不再推荐
from pydantic import Field, model_validator
from df_test_framework.infrastructure.config import HTTPConfigBuilder

class ProjectSettings(FrameworkSettings):
    @model_validator(mode='after')
    def setup_http_interceptors(self) -> 'ProjectSettings':
        """手动配置拦截器"""
        if not self.http.interceptors:
            # 使用Builder模式配置
            builder = HTTPConfigBuilder(base_url=self.http.base_url)
            builder.add_signature_interceptor(...)
            builder.add_bearer_token_interceptor(...)
            self.http = builder.build()
        return self
```

#### v3.5.0 配置方式（新）

```python
# ✅ v3.5方式 - 推荐
import os
from pydantic import Field, model_validator
from typing import Self
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

from df_test_framework import (
    FrameworkSettings,
    HTTPConfig,
)
from df_test_framework.infrastructure.config import (
    SignatureInterceptorConfig,
    BearerTokenInterceptorConfig,
)

def _create_http_config() -> HTTPConfig:
    """创建HTTP配置（包含拦截器）"""
    return HTTPConfig(
        base_url=os.getenv("APP_HTTP__BASE_URL", "https://api.test.com"),
        timeout=int(os.getenv("APP_HTTP__TIMEOUT", "30")),
        interceptors=[
            # 签名拦截器
            SignatureInterceptorConfig(
                type="signature",
                enabled=True,
                priority=10,
                algorithm="md5",
                secret=os.getenv("APP_SECRET", "default_secret"),
                header_name="X-Sign",
                include_paths=["/api/**"],
                exclude_paths=["/health"],
                include_query_params=True,
                include_json_body=True,
            ),
            # Bearer Token拦截器
            BearerTokenInterceptorConfig(
                type="bearer_token",
                enabled=True,
                priority=20,
                token_source="login",
                login_url="/admin/auth/login",
                login_credentials={
                    "username": os.getenv("ADMIN_USERNAME", "admin"),
                    "password": os.getenv("ADMIN_PASSWORD", "admin123"),
                },
                token_field_path="data.token",
                header_name="Authorization",
                token_prefix="Bearer",
                include_paths=["/admin/**"],
            ),
        ]
    )

class ProjectSettings(FrameworkSettings):
    """v3.5.0声明式配置"""

    @model_validator(mode='after')
    def _setup_interceptors(self) -> Self:
        """设置HTTP拦截器"""
        self.http = _create_http_config()
        return self
```

**关键变更点**:
1. ❌ 移除HTTPConfigBuilder - 直接创建HTTPConfig
2. ✅ 使用model_validator(mode='after') - 确保配置正确执行
3. ✅ 添加load_dotenv() - 确保环境变量加载
4. ✅ 拦截器配置完全声明式 - 无需手写逻辑

---

### Step 3: 配置HTTP拦截器

v3.5.0提供三种内置拦截器：

#### 3.1 签名拦截器

```python
SignatureInterceptorConfig(
    type="signature",
    enabled=True,
    priority=10,  # 优先级，数字越小越先执行
    algorithm="md5",  # 支持: md5, sha256, hmac-sha256
    secret="your_secret_key",
    header_name="X-Sign",  # 签名Header名称
    include_paths=["/api/**", "/v1/**"],  # 路径匹配
    exclude_paths=["/health", "/actuator/**"],  # 排除路径
    include_query_params=True,  # 包含URL参数
    include_json_body=True,  # 包含JSON body
)
```

#### 3.2 Bearer Token拦截器

```python
BearerTokenInterceptorConfig(
    type="bearer_token",
    enabled=True,
    priority=20,
    token_source="login",  # 自动登录获取token
    login_url="/admin/auth/login",
    login_credentials={
        "username": "admin",
        "password": "admin123",
    },
    token_field_path="data.token",  # Token在响应中的路径
    header_name="Authorization",
    token_prefix="Bearer",  # 或 "Token"
    include_paths=["/admin/**"],
)
```

#### 3.3 路径模式匹配

支持通配符和正则表达式：

```python
include_paths=[
    "/api/**",           # 匹配 /api/任意路径
    "/v1/users/*",       # 匹配 /v1/users/单层路径
    r"^/orders/\d+$",    # 正则：匹配 /orders/123
]
```

---

### Step 4: 配置Profile环境

v3.5.0支持按环境加载不同的配置文件。

#### 4.1 创建环境配置文件

```bash
# 项目根目录
.env              # 基础配置
.env.dev          # 开发环境
.env.test         # 测试环境
.env.staging      # 预发布环境
.env.prod         # 生产环境
.env.local        # 本地覆盖（不提交git）
```

#### 4.2 配置加载优先级

```
.env → .env.{profile} → .env.local → 环境变量 → 代码默认值
```

#### 4.3 使用Profile

```bash
# 方式1: 环境变量
ENV=dev pytest

# 方式2: Bootstrap参数（代码中）
runtime = (
    Bootstrap()
    .with_settings(ProjectSettings, profile="dev")
    .build()
    .run()
)
```

---

### Step 5: 使用with_overrides实现测试隔离

v3.5.0提供运行时配置覆盖功能。

#### 5.1 基本用法

```python
def test_with_custom_timeout(runtime_ctx):
    """演示运行时配置覆盖"""
    # 创建临时上下文，修改超时时间
    test_ctx = runtime_ctx.with_overrides({
        "http.timeout": 5,
        "http.max_retries": 1,
    })

    # 使用临时配置的client
    client = test_ctx.http_client()
    response = client.get("/api/test")

    # 原始runtime_ctx不受影响（不可变设计）
    assert runtime_ctx.settings.http.timeout == 30  # 仍然是30
```

#### 5.2 嵌套配置覆盖

```python
test_ctx = runtime_ctx.with_overrides({
    "http": {
        "timeout": 10,
        "base_url": "http://mock.local"
    }
})
```

#### 5.3 点号路径语法

```python
test_ctx = runtime_ctx.with_overrides({
    "http.timeout": 5,          # 等同于 {"http": {"timeout": 5}}
    "http.base_url": "..."      # 支持嵌套访问
})
```

---

### Step 6: 删除不必要的文件

v3.5.0使用框架自动Bootstrap，可以删除手动创建的bootstrap文件。

#### 可以删除的文件

```bash
# 如果存在以下文件，可以删除
src/your_project/config/bootstrap.py
src/your_project/config/__init__.py  # 移除bootstrap导入
```

#### 框架自动配置

通过`pytest.ini`配置：

```ini
[pytest]
df_settings_class = your_project.config.settings.YourSettings
```

框架会自动：
1. 加载settings类
2. 创建RuntimeContext
3. 注册providers
4. 提供fixtures（runtime, http_client, database等）

---

## 📝 完整迁移示例

基于gift-card-test项目的实际迁移案例。

### 迁移前（v3.4）

```python
# src/gift_card_test/config/settings.py (v3.4)
from pydantic import model_validator
from df_test_framework.infrastructure.config import HTTPConfigBuilder

class GiftCardSettings(FrameworkSettings):
    business: BusinessConfig = Field(default_factory=BusinessConfig)

    @model_validator(mode='after')
    def setup_http_interceptors(self) -> 'GiftCardSettings':
        """手动配置拦截器"""
        if not self.http.interceptors:
            auth = self.business.auth
            # 使用Builder...
            builder = HTTPConfigBuilder(...)
            self.http = builder.build()
        return self
```

### 迁移后（v3.5）

```python
# src/gift_card_test/config/settings.py (v3.5)
import os
from dotenv import load_dotenv
load_dotenv()

def _create_http_config() -> HTTPConfig:
    return HTTPConfig(
        base_url=os.getenv("APP_HTTP__BASE_URL", "https://api.test.com"),
        timeout=int(os.getenv("APP_HTTP__TIMEOUT", "30")),
        interceptors=[
            SignatureInterceptorConfig(
                type="signature",
                enabled=True,
                priority=10,
                algorithm="md5",
                secret=os.getenv("APP_BUSINESS__APP_SECRET", "..."),
                header_name="X-Sign",
                include_paths=["/master/**", "/h5/**"],
                exclude_paths=["/health"],
                include_query_params=True,
                include_json_body=True,
            ),
            BearerTokenInterceptorConfig(
                type="bearer_token",
                enabled=True,
                priority=20,
                token_source="login",
                login_url="/admin/auth/login",
                login_credentials={
                    "username": os.getenv("BUSINESS_ADMIN_USERNAME", "admin"),
                    "password": os.getenv("BUSINESS_ADMIN_PASSWORD", "admin123"),
                },
                token_field_path="data.token",
                include_paths=["/admin/**"],
            ),
        ]
    )

class GiftCardSettings(FrameworkSettings):
    business: BusinessConfig = Field(default_factory=BusinessConfig)

    @model_validator(mode='after')
    def _setup_interceptors(self) -> Self:
        self.http = _create_http_config()
        return self
```

**代码变更**:
- 删除: HTTPConfigBuilder（33行）
- 删除: bootstrap.py（75行）
- 简化: 配置逻辑更清晰

**总计**: 减少约60行代码 ✅

---

## ❓ 常见问题

### Q1: 拦截器配置后不生效？

**现象**: HTTP请求返回401 Unauthorized

**原因**: Pydantic字段继承问题，子类的default_factory无法覆盖父类Optional字段

**解决方案**:
```python
# ✅ 正确做法：使用model_validator
@model_validator(mode='after')
def _setup_interceptors(self) -> Self:
    self.http = _create_http_config()
    return self

# ❌ 错误做法：直接覆盖http字段（不生效）
http: HTTPConfig = Field(default_factory=_create_http_config)
```

### Q2: 环境变量读取不到？

**现象**: 拦截器使用默认值而非.env中的值

**原因**: 未调用load_dotenv()或调用时机错误

**解决方案**:
```python
# ✅ 在模块导入时加载
import os
from dotenv import load_dotenv
load_dotenv()  # 必须在import框架模块之前

from df_test_framework import ...
```

### Q3: 测试间配置相互影响？

**问题**: 修改了一个测试的配置，影响了其他测试

**解决方案**: 使用with_overrides()创建独立上下文
```python
def test_case_1(runtime_ctx):
    # 创建独立上下文，不影响其他测试
    test_ctx = runtime_ctx.with_overrides({"http.timeout": 5})
    client = test_ctx.http_client()
    # 使用client进行测试
```

### Q4: 如何调试拦截器问题？

**方法1**: 查看日志
```python
# v3.5.0自动输出拦截器日志
# [签名拦截器] 已初始化: algorithm=md5, header=X-Sign
# [签名拦截器] 已生成签名: abc123...
```

**方法2**: 启用Debug模式
```python
logging: LoggingConfig = Field(
    default_factory=lambda: LoggingConfig(
        level="DEBUG",  # 启用DEBUG日志
        enable_observability=True,  # 启用可观测性
        enable_http_logging=True,  # HTTP请求日志
    )
)
```

**方法3**: 验证拦截器配置
```python
from your_project.config import ProjectSettings
s = ProjectSettings()
print(f'拦截器数量: {len(s.http.interceptors)}')
print(f'拦截器类型: {[i.type for i in s.http.interceptors]}')
```

### Q5: Pydantic验证错误？

**错误**: `ValidationError: HTTP timeout should not be lower than 5 seconds`

**原因**: HTTPConfig有字段验证规则

**解决方案**: 遵守验证规则
```python
HTTPConfig(
    timeout=int(os.getenv("APP_HTTP__TIMEOUT", "30")),  # >= 5
    max_retries=int(os.getenv("APP_HTTP__MAX_RETRIES", "3")),  # 0-10
)
```

---

## 📚 参考文档

### 迁移相关
- [gift-card-test v3.5迁移实例](../../gift-card-test/V3.5_REFACTORING_COMPLETE.md)
- [v3.5最终总结](../V3.5_FINAL_SUMMARY.md)

### 配置指南
- [拦截器配置最佳实践](../INTERCEPTOR_CONFIG_BEST_PRACTICES.md)
- [Phase 3特性指南](../user-guide/PHASE3_FEATURES.md)
- [配置化拦截器实施报告](../CONFIGURABLE_INTERCEPTORS_IMPLEMENTATION.md)

### 示例代码
- [配置化拦截器示例](../../examples/07-v35-features/01_configurable_interceptors.py)（待创建）
- [Profile配置示例](../../examples/07-v35-features/02_profile_configuration.py)（待创建）
- [运行时覆盖示例](../../examples/07-v35-features/03_runtime_overrides.py)（待创建）

---

## ✅ 迁移检查清单

完成迁移后，请检查以下项：

### 代码检查
- [ ] settings.py已重构为v3.5声明式配置
- [ ] 删除了HTTPConfigBuilder相关代码
- [ ] 添加了load_dotenv()调用
- [ ] 拦截器配置使用model_validator(mode='after')
- [ ] 删除了不必要的bootstrap.py

### 功能验证
- [ ] 所有测试能够正常运行
- [ ] 拦截器日志显示正确初始化
- [ ] HTTP请求成功（无401错误）
- [ ] Profile环境切换工作正常
- [ ] with_overrides功能正常

### 文档更新
- [ ] README.md更新版本号到v3.5.0
- [ ] pyproject.toml更新依赖版本
- [ ] 更新项目文档中的配置示例

---

## 🎯 迁移后的优势

完成v3.5迁移后，你将获得：

### 开发效率
- ⏱️ 配置代码减少20-30%
- 🔧 零代码拦截器配置
- 🎯 清晰的配置结构

### 测试能力
- 🌍 灵活的环境配置管理
- 🔒 测试隔离（with_overrides）
- 📊 完整的可观测性日志

### 代码质量
- ✅ 类型安全（Pydantic v2）
- 📦 模块化设计
- 🧪 更容易测试

---

**迁移支持**: 如遇到问题，请查阅[常见问题](#-常见问题)或参考[gift-card-test迁移实例](../../gift-card-test/V3.5_REFACTORING_COMPLETE.md)

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
