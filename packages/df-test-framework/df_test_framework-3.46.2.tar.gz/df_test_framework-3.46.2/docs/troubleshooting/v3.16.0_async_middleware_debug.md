# v3.16.0 AsyncHttpClient 中间件调试记录

**日期**: 2025-12-04
**版本**: v3.16.0
**问题**: AsyncHttpClient 签名验证失败（401）

---

## 问题现象

运行 AsyncHttpClient 测试时，始终返回 HTTP 401 签名验证失败：

```bash
uv run pytest tests/examples/test_async_http_client.py::TestAsyncHttpClient::test_async_http_client_basic -v
# Result: FAILED - assert 401 == 200
# Error: {"code":401,"message":"签名验证失败"}
```

---

## 调查过程

### 第1步：验证中间件是否加载

**假设**: 中间件可能没有被加载

**验证方法**: 添加调试日志到 `__init__` 方法

**结果**: ✅ 中间件正常加载
```python
[DEBUG-AsyncHttpClient] 使用方式2: 从HTTPConfig加载中间件 (count=1)
client._middlewares = [PathFilteredMiddleware(name='PathFiltered[SignatureMiddleware]', priority=10)]
```

### 第2步：验证中间件是否执行

**假设**: 中间件链可能没有执行

**验证方法**: 添加调试日志到 `request()` 方法和 `SignatureMiddleware.__call__()`

**结果**: ✅ 中间件正常执行
```python
[DEBUG-request] 使用中间件链执行请求
[DEBUG-SignatureMiddleware] 开始处理请求: url=/master/card/query
[DEBUG-SignatureMiddleware] 生成签名: signature=d45813f5..., data={'cardNo': 'TEST_001'}
[DEBUG-SignatureMiddleware] 已添加签名头: X-Sign=d45813f5...
```

### 第3步：验证签名是否被发送

**假设**: 签名可能在中间件链后被丢弃

**验证方法**: 添加调试日志到 `_send_request_async()` 方法

**结果**: ✅ 签名正确发送
```python
[DEBUG-_send_request_async] params['headers'] = {
    'X-Timestamp': '1764849925',
    'X-Sign': '916a4ead66b9ea1d1b427f3d515fb35a'
}
```

### 第4步：对比后端签名算法

**结论**: ❌ **签名算法不匹配！**

**Python代码（错误）**:
```python
# 拼接 "key=value&key2=value2"
values = "&".join(f"{k}={v}" for k, v in sorted_items if v is not None)
sign_string = f"{values}{self.secret}"
```

**Java后端（正确）**:
```java
// SignatureUtil.java
// 只拼接value值
for (Map.Entry<String, String> entry : sortedParams.entrySet()) {
    if (entry.getValue() != null && !entry.getValue().isEmpty()) {
        sb.append(entry.getValue());  // 只append value！
    }
}
sb.append(appSecret);
```

---

## 根本原因

**签名算法与Java后端不一致**:

| 步骤 | Python (错误) | Java后端 (正确) |
|------|--------------|-----------------|
| 1. 排序 | ✅ 按key排序 | ✅ 按key排序 |
| 2. 拼接 | ❌ `"k1=v1&k2=v2"` | ✅ `"v1v2"` |
| 3. 加密钥 | ✅ 追加secret | ✅ 追加secret |
| 4. MD5 | ✅ MD5加密 | ✅ MD5加密 |

---

## 解决方案

### 修改前

```python
# 错误：包含key=value格式
values = "&".join(f"{k}={v}" for k, v in sorted_items if v is not None)
sign_string = f"{values}{self.secret}"
```

### 修改后

```python
# 正确：只拼接value值
values = "".join(str(v) for k, v in sorted_items if v is not None and str(v) != "")
sign_string = f"{values}{self.secret}"
```

### 完整代码

```python
def _sign(self, data: dict[str, Any]) -> str:
    """计算签名（与Java后端SignatureUtil.java对齐）

    签名算法：
    1. 参数按key排序
    2. 只拼接value值（不包含key）
    3. 追加密钥
    4. MD5/SHA256加密
    """
    # 按键名排序
    sorted_items = sorted(data.items(), key=lambda x: x[0])
    # 只拼接value值（与Java后端一致）
    values = "".join(str(v) for k, v in sorted_items if v is not None and str(v) != "")
    sign_string = f"{values}{self.secret}"

    return hashlib.md5(sign_string.encode()).hexdigest()
```

---

## 验证结果

### 修复前
```bash
响应状态码: 401
响应内容: {"code":401,"message":"签名验证失败"}
```

### 修复后
```bash
响应状态码: 200
响应内容: {"code":500,"message":"服务器内部错误",...}  # HTTP层签名验证通过
```

---

## 重要发现

1. **中间件系统工作正常** - v3.16.0的Middleware系统完全正常工作
2. **问题不在框架** - 问题出在业务层的签名算法实现
3. **需要对齐后端** - 签名算法必须与后端 SignatureUtil.java 完全一致

---

## 经验教训

### 调试技巧

1. **逐层验证** - 从外到内验证每一层（加载→执行→发送）
2. **添加调试日志** - print语句比logger更可靠（pytest捕获问题）
3. **对比后端代码** - 签名类问题必须查看后端实现

### 代码规范

1. **签名算法文档化** - 在代码注释中明确说明算法步骤
2. **参考后端实现** - 注释中引用后端文件名（如 SignatureUtil.java）
3. **单元测试覆盖** - 签名算法应有独立的单元测试

---

## 后续工作

- [ ] 为 SignatureMiddleware._sign() 添加单元测试
- [ ] 在配置文档中说明签名算法规则
- [ ] 考虑支持多种签名算法模式（兼容不同后端）

---

**作者**: DF QA Team
**最后更新**: 2025-12-04
