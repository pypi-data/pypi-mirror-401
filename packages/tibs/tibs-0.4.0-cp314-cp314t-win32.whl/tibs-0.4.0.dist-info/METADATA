Metadata-Version: 2.4
Name: tibs
Version: 0.4.0
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: 3.14
Classifier: Programming Language :: Rust
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: License :: OSI Approved :: MIT License
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Typing :: Typed
Requires-Dist: pytest>=7.4.2 ; extra == 'dev'
Requires-Dist: hypothesis>=6.98.13 ; extra == 'dev'
Requires-Dist: pytest-benchmark>=4.0.0 ; extra == 'dev'
Requires-Dist: pyright>=1.1.389 ; extra == 'dev'
Requires-Dist: build ; extra == 'dev'
Provides-Extra: dev
License-File: LICENSE
Summary: A sleek Python library for binary data.
Author-email: Scott Griffiths <dr.scottgriffiths@gmail.com>
License: The MIT License
	
	Copyright (c) 2025 Scott Griffiths (dr.scottgriffiths@gmail.com)
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	
Requires-Python: >=3.8
Description-Content-Type: text/markdown; charset=UTF-8; variant=GFM
Project-URL: documentation, https://mutibs.readthedocs.io/
Project-URL: homepage, https://github.com/scott-griffiths/tibs

[![tibs](https://raw.githubusercontent.com/scott-griffiths/tibs/main/doc/tibs.png)](https://github.com/scott-griffiths/tibs)

A sleek Python library for your binary data

[![PyPI - Version](https://img.shields.io/pypi/v/tibs?label=PyPI&logo=pypi&logoColor=white)](https://pypi.org/project/tibs/)
[![CI badge](https://github.com/scott-griffiths/tibs/actions/workflows/.github/workflows/test.yml/badge.svg)](https://github.com/scott-griffiths/tibs/actions/workflows/test.yml)
[![Docs](https://img.shields.io/readthedocs/mutibs?logo=readthedocs&logoColor=white)](https://mutibs.readthedocs.io/en/latest/)
![PyPI - License](https://img.shields.io/pypi/l/tibs)
&nbsp; &nbsp;
[![Pepy Total Downlods](https://img.shields.io/pepy/dt/tibs?logo=python&logoColor=white&labelColor=blue&color=blue)](https://www.pepy.tech/projects/tibs)


----

> [!NOTE]
> The project is currently in alpha. This documentation is incomplete.


# Documentation

The full documentation is available on [Read the Docs](https://mutibs.readthedocs.io/en/latest/).

## Getting started

To install use

```
pip install tibs
```

There are pre-built wheels for most configurations - if there are issues then please let me know.
Tibs works with Python 3.8 and later.

One way to get to know the library is to start a Python interactive session, import the two main
classes, and experiment with some of the example code in the rest of this document.

```python
>>> from tibs import Tibs, Mutibs
```

## A quick tour

``tibs`` is a simple but powerful Python library for creating, interpreting and manipulating binary data.
It is 100% written in Rust, and from the same author as the bitstring library.

The two main classes are:

* `Tibs`: An immutable sequence of bits.
* `Mutibs`: A mutable sequence of bits (pronounced 'mew-tibs').

They are created by class methods starting with ``from_``, for example


```python
>>> a = Tibs.from_bin('0110')
>>> b = Tibs.from_hex('abc')
>>> c = Tibs.from_string('0xfee, 0b11001')
>>> d = Tibs.from_bytes(b'some_byte_data')
>>> e = Tibs.from_random(1000)  # 1000 random bits
>>> f = Tibs.from_u(76, 25)  # Unsigned int stored in 25 bits
>>> g = Tibs.from_f(-0.125, 16)  # A float stored in 16 bits
>>> h = Tibs.from_bools([1, 0, 0])
>>> i = Tibs.from_joined([a, b, c, d, e, f, g, h])
```

Once created they are just binary data, stored efficiently, and they don't retain any information about how they were created.

The `Tibs` constructor can also be used to create new instances, and it will delegate to `from_string`, `from_bytes` or `from_bools`.
This is often more convenient:

```python
>>> a = Tibs('0b0110')
>>> b = Tibs('0xabc')
>>> c = Tibs('0xfee, 0b11001')
>>> d = Tibs(b'some_byte_data')
>>> h = Tibs([1, 0, 0])
```

Anything that works in the constructor can also be used in other places where a `Tibs` is needed.
For example, instead of writing 

```python
x = b & Tibs.from_hex('0xff0')
if x.starts_with(Tibs.from_bin('0b11')):
    x += Tibs.from_bools([0, 1, 1])
```

you can write just

```python
x = b & '0xff0'
if x.starts_with('0b11'):
    x += [0, 1, 1]
```


Note that the binary and hex strings need the `0b` and `0x` prefixes when not called via `from_bin` and `from_hex`.

To get the data out of the `Tibs` there are similar methods starting with ``to_``

```python
>>> a.to_bin()
'0110'
>>> b.to_hex()
'abc'
>>> d.to_bytes()
b'some_byte_data'
>>> f.to_u()
76
>>> g.to_f()
-0.125
```

There isn't a `to_bools` method, but creating a `list` from the `Tibs` instance will have the same effect.
You can also use `Tibs` instances as iterators of bits.

Instances of `Tibs` are immutable. Once created they can't change in value, much like the Python `bytes` and `str` types.
This allows them to be hashed, stored in sets, used as dictionary keys etc., and also allows various optimizations to be used to make them more efficient. They should be used by default if values don't need to be changed.

This does mean that the standard pieces of advice for working with things like Python strings does apply, and why something like this line:

```python
i = Tibs()
for t in [a, b, c, d, e, f, g, h]:
    i += t  # NOT RECOMMENDED!
```

is an anti-pattern to avoid as it will create a new instance every time it appends. Use `from_joined` instead.

For the times when you do need to a mutable container use `Mutibs`.
This can do everything that `Tibs` can do, except that it's not hashable, so can't be used as a dictionary key, in sets etc.
It also has several extra methods that will mutate the value in-place.

```python
>>> m = Mutibs()
>>> m.extend('0xabde')
Mutibs('0xabde')
>>> m.replace([1], [0, 1, 0])
Mutibs('0b01000100010001001001001000100100100100')
```

Note that mutating methods like `extend` and `replace` also return the modified `Mutibs` instance.
This perhaps isn't the most Pythonic of interfaces, but it allows methods to be chained:

```python
>>> m[:32].byte_swap().reverse().to_f()
2.1993814317305072e-18
```

You can do everything you'd expect with these classes - slicing, boolean operations, shifting, rotating, finding, replacing, setting, reversing etc.



## But why is it called tibs?

Because Tibs is Bits backwards (almost), it's distinctive, and the name was available on PyPI.
It's got nothing to do with Ethiopian stew.

