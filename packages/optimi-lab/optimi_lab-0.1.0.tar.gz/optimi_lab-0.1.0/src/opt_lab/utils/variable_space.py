from itertools import product

import numpy as np
from pydantic import field_validator, model_validator
from scipy.stats.qmc import (
    LatinHypercube,
    PoissonDisk,
    scale,
)

from opt_lab.utils.exceptions import ParameterException
from opt_lab.utils.quantities import BaseModel_with_q

SAMPLE_TYPES = ['uniform', 'latin_hypercube', 'poisson_disk', 'import']
"""
Sampling methods
- `uniform`: uniform sampling
- `latin_hypercube`: Latin hypercube sampling
- `poisson_disk`: Poisson-disk sampling
- `import`: import sample matrix from external source
"""


def float_range(start: float, stop: float, step: float):
    """A range function that supports float step values.

    Args:
        start (float): Start value (inclusive).
        stop (float): Stop value (exclusive unless step == 0).
        step (float): Step size. If 0, returns [start, stop].

    Returns:
        List[float]: A list of floats generated by the range.

    Examples:
        >>> float_range(3.612, 5.78, 0.22)
        [3.612, 3.8320000000000003, 4.0520000000000005, 4.272, 4.492, 4.712, 4.932, 5.152, 5.372]
        >>> float_range(3.612, 5.78, 4.22)
        [3.612, 5.78]
        >>> float_range(3.612, 5.78, 0)
        [3.612, 5.78]

    """
    if step == 0:
        ans = [start, stop]
    else:
        ans = [start + i * step for i in range(int((stop - start) // step))]
        if len(ans) == 0:
            ans = [start, stop]
    return ans


class VariableSpace(BaseModel_with_q):
    """`VariableSpace` defines the search space for optimization variables.

    Attributes mirror the configuration used to generate sampling matrices for
    different sampling methods (uniform grid, Latin hypercube, Poisson disk,
    or importing a precomputed matrix).
    """

    var_name_list: list[str]
    lower_bounds: list[float] | np.ndarray | None = None
    upper_bounds: list[float] | np.ndarray | None = None
    sample_type: str = 'uniform'
    var_space_matrix: list[list[float]] | np.ndarray[float] | None = None
    """
    Variable space matrix (2D numpy.ndarray), shape: [n_samples, n_variables].
    Each row is a sample: [[var0, var1, ...], [var0, var1, ...], ...].
    """
    # uniform
    step_list: list[float] = []
    # latin_hypercube, poisson_disk
    n_count: int = 10
    disk_radius: float = 0
    random_seed: int = 0

    @field_validator('sample_type')
    def validate_sample_type(cls, sample_type: str):
        if sample_type not in SAMPLE_TYPES:
            msg = f'sample_type must be one of {SAMPLE_TYPES}, got {sample_type}.'
            raise ParameterException(msg)
        return sample_type

    @field_validator('lower_bounds', 'upper_bounds', 'var_space_matrix')
    def validate_array(cls, v_array: list[float] | np.ndarray) -> np.ndarray:
        return np.array(v_array)

    @model_validator(mode='after')
    def calc_var_space_mat(self):
        sample_type = self.sample_type

        # For 'import' sample_type, no matrix generation is required
        if sample_type == 'import':
            return self

        # For other sample types, boundary conditions are required
        if self.lower_bounds is None or self.upper_bounds is None:
            msg = 'lower_bounds and upper_bounds must be provided for sampling.'
            raise ParameterException(msg)
        if (
            len(self.lower_bounds) != len(self.upper_bounds)
            or len(self.lower_bounds) != len(self.var_name_list)
            or len(self.var_name_list) == 0
        ):
            msg = 'var_name_list, lower_bounds, upper_bounds must have the same length and >0.'
            raise ParameterException(msg)
        if np.any(self.lower_bounds >= self.upper_bounds):
            msg = 'lower_bounds must be less than upper_bounds.'
            raise ParameterException(msg)

        match sample_type:
            case 'poisson_disk':
                d = len(self.upper_bounds)
                if self.disk_radius <= 0:
                    self.disk_radius = (1 / self.n_count) ** (-d)
                sampler = PoissonDisk(d=d, radius=self.disk_radius, seed=self.random_seed)
                sample = sampler.random(n=self.n_count)
                var_space_mat = scale(sample, self.lower_bounds, self.upper_bounds)
            case 'latin_hypercube':
                sampler = LatinHypercube(d=len(self.upper_bounds), seed=self.random_seed)
                sample = sampler.random(n=self.n_count)
                var_space_mat = scale(sample, self.lower_bounds, self.upper_bounds)
            case _:  #'uniform'
                # No need to catch unexpected values here: `sample_type` is validated
                # by `validate_sample_type`.
                if len(self.step_list) == 0:
                    step_list = [1] * len(self.upper_bounds)
                else:
                    step_list = self.step_list
                if len(self.lower_bounds) != len(step_list):
                    msg = 'lower_bounds, upper_bounds and step_list must have the same length.'
                    raise ParameterException(msg)
                sample_ranges = [
                    float_range(self.lower_bounds[i], self.upper_bounds[i] + step, step)
                    for i, step in enumerate(step_list)
                ]
                var_space_mat = np.array(list(product(*sample_ranges)))
        self.var_space_matrix = var_space_mat
        return self
