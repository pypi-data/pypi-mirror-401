

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_breez_sdk_spark_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_breez_sdk_spark_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_breez_sdk_spark_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("breez_sdk_spark_bindings")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_breez_sdk_spark_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_breez_sdk_spark_checksum_func_connect() != 40345:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_func_connect_with_signer() != 1399:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_func_default_config() != 62194:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_func_default_external_signer() != 40694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_func_init_logging() != 8518:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos() != 20959:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status() != 23018:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex() != 59376:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction() != 65179:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees() != 43230:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener() != 37737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization() != 56996:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available() != 31624:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message() != 4385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit() != 43529:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment() != 57587:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address() != 44132:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect() != 330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_token_conversion_limits() != 9413:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info() != 6771:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress() != 38008:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address() != 36552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment() != 11540:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer() != 26649:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata() != 40125:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings() != 38537:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies() != 63366:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates() != 5904:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments() != 16156:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits() != 22486:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay() != 10147:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw() != 45652:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_parse() != 14285:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay() != 37691:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment() != 34185:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment() != 36984:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees() != 16947:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit() != 33646:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address() != 530:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener() != 41066:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment() != 54349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message() != 57563:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization() != 22827:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet() != 30368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings() != 1721:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key() != 44711:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key() != 63908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa() != 52291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable() != 8564:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_encrypt() != 19449:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_decrypt() != 46414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr() != 57220:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_frost_signing_commitments() != 24826:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node() != 32818:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_key() != 22789:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key_source() != 37751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key() != 55375:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_public_key() != 49264:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_private_keys() != 46671:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret() != 840:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_private_key_for_receiver() != 42476:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_from_private_key_source() != 38684:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost() != 1497:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost_signatures() != 26523:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies() != 19092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates() != 11512:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send() != 30686:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_restclient_get_request() != 8260:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_restclient_post_request() != 24889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_restclient_delete_request() != 51072:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build() != 8126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service() != 2848:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage() != 14543:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service() != 37854:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set() != 50052:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client() != 51060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer() != 21617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage() != 20579:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service() != 63155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage() != 59400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item() != 6883:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item() != 30248:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item() != 7970:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_list_payments() != 19728:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_insert_payment() != 28075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata() != 45500:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id() != 35394:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice() != 57075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_add_deposit() != 60240:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit() != 60586:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_list_deposits() != 54118:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_update_deposit() != 39803:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata() != 7460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change() != 19087:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync() != 20071:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes() != 23473:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision() != 36887:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records() != 41782:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record() != 23002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records() != 61508:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records() != 53552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change() != 16326:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming() != 9986:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token() != 56056:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token() != 33277:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token() != 32344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance() != 9758:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata() != 57707:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token() != 36459:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token() != 65025:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new() != 65435:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event() != 24807:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_breez_sdk_spark_checksum_method_logger_log() != 11839:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_EVENT_LISTENER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.POINTER(_UniffiRustBuffer),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD5 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD6 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD7 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD9 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD10 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint32,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD11 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint32,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD12 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint32,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD13 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD14 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_uint32,ctypes.c_uint32,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD15 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD17 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD18 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_FIAT_SERVICE_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_FIAT_SERVICE_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_PAYMENT_OBSERVER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD5 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD6 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD7 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_uint32,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD9 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_uint32,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD10 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD11 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_uint32,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD12 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint32,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD5 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD6 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD7 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint32,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD9 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
class _UniffiVTableCallbackInterfaceEventListener(ctypes.Structure):
    _fields_ = [
        ("on_event", _UNIFFI_CALLBACK_INTERFACE_EVENT_LISTENER_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceLogger(ctypes.Structure):
    _fields_ = [
        ("log", _UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceBitcoinChainService(ctypes.Structure):
    _fields_ = [
        ("get_address_utxos", _UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD0),
        ("get_transaction_status", _UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD1),
        ("get_transaction_hex", _UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD2),
        ("broadcast_transaction", _UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD3),
        ("recommended_fees", _UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD4),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceExternalSigner(ctypes.Structure):
    _fields_ = [
        ("identity_public_key", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD0),
        ("derive_public_key", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD1),
        ("sign_ecdsa", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD2),
        ("sign_ecdsa_recoverable", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD3),
        ("ecies_encrypt", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD4),
        ("ecies_decrypt", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD5),
        ("sign_hash_schnorr", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD6),
        ("generate_frost_signing_commitments", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD7),
        ("get_public_key_for_node", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD8),
        ("generate_random_key", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD9),
        ("get_static_deposit_private_key_source", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD10),
        ("get_static_deposit_private_key", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD11),
        ("get_static_deposit_public_key", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD12),
        ("subtract_private_keys", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD13),
        ("split_secret", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD14),
        ("encrypt_private_key_for_receiver", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD15),
        ("get_public_key_from_private_key_source", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD16),
        ("sign_frost", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD17),
        ("aggregate_frost_signatures", _UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD18),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceFiatService(ctypes.Structure):
    _fields_ = [
        ("fetch_fiat_currencies", _UNIFFI_CALLBACK_INTERFACE_FIAT_SERVICE_METHOD0),
        ("fetch_fiat_rates", _UNIFFI_CALLBACK_INTERFACE_FIAT_SERVICE_METHOD1),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfacePaymentObserver(ctypes.Structure):
    _fields_ = [
        ("before_send", _UNIFFI_CALLBACK_INTERFACE_PAYMENT_OBSERVER_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceRestClient(ctypes.Structure):
    _fields_ = [
        ("get_request", _UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD0),
        ("post_request", _UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD1),
        ("delete_request", _UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD2),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceStorage(ctypes.Structure):
    _fields_ = [
        ("delete_cached_item", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD0),
        ("get_cached_item", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD1),
        ("set_cached_item", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD2),
        ("list_payments", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD3),
        ("insert_payment", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD4),
        ("set_payment_metadata", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD5),
        ("get_payment_by_id", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD6),
        ("get_payment_by_invoice", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD7),
        ("add_deposit", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD8),
        ("delete_deposit", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD9),
        ("list_deposits", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD10),
        ("update_deposit", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD11),
        ("set_lnurl_metadata", _UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD12),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceSyncStorage(ctypes.Structure):
    _fields_ = [
        ("add_outgoing_change", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD0),
        ("complete_outgoing_sync", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD1),
        ("get_pending_outgoing_changes", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD2),
        ("get_last_revision", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD3),
        ("insert_incoming_records", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD4),
        ("delete_incoming_record", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD5),
        ("rebase_pending_outgoing_records", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD6),
        ("get_incoming_records", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD7),
        ("get_latest_outgoing_change", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD8),
        ("update_record_from_incoming", _UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD9),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_bitcoinchainservice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_bitcoinchainservice.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceBitcoinChainService),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_breezsdk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_breezsdk.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_breezsdk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_breezsdk.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_check_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_check_message.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_token_conversion_limits.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_token_conversion_limits.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_info.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_info.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_parse.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_parse.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_externalsigner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_externalsigner.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_externalsigner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_externalsigner.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceExternalSigner),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_encrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_decrypt.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_generate_frost_signing_commitments.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_generate_frost_signing_commitments.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_key.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key_source.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key_source.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_public_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_private_keys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_private_keys.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_private_key_for_receiver.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_private_key_for_receiver.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_from_private_key_source.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_from_private_key_source.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost_signatures.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost_signatures.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_fiatservice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_fiatservice.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_fiatservice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_fiatservice.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFiatService),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_paymentobserver.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_paymentobserver.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_paymentobserver.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_paymentobserver.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfacePaymentObserver),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_restclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_restclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_restclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_restclient.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceRestClient),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_get_request.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_get_request.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_post_request.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_post_request.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_delete_request.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_delete_request.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_sdkbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_sdkbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_sdkbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_sdkbuilder.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_build.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_build.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_storage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_storage.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_storage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_storage.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_storage.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceStorage),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_storage.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_cached_item.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_cached_item.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_cached_item.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_cached_item.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_list_payments.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_list_payments.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_insert_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_insert_payment.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_add_deposit.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_add_deposit.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_delete_deposit.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_delete_deposit.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_list_deposits.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_list_deposits.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_update_deposit.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_update_deposit.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_syncstorage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_syncstorage.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_syncstorage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_syncstorage.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceSyncStorage),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_tokenissuer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_clone_tokenissuer.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_free_tokenissuer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_free_tokenissuer.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceEventListener),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_logger.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceLogger),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_logger.restype = None
_UniffiLib.uniffi_breez_sdk_spark_fn_func_connect.argtypes = (
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_func_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_func_connect_with_signer.argtypes = (
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_breez_sdk_spark_fn_func_connect_with_signer.restype = ctypes.c_uint64
_UniffiLib.uniffi_breez_sdk_spark_fn_func_default_config.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_func_default_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_breez_sdk_spark_fn_func_default_external_signer.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_func_default_external_signer.restype = ctypes.c_void_p
_UniffiLib.uniffi_breez_sdk_spark_fn_func_init_logging.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_breez_sdk_spark_fn_func_init_logging.restype = None
_UniffiLib.ffi_breez_sdk_spark_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_spark_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_spark_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rustbuffer_free.restype = None
_UniffiLib.ffi_breez_sdk_spark_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u8.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_u8.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i8.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_i8.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u16.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_u16.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i16.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_i16.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_u32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_i32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_u64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_i64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_f32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_f32.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_f64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_f64.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_pointer.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_cancel_void.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_free_void.restype = None
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void.restype = None
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_connect.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_connect_with_signer.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_connect_with_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_default_config.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_default_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_default_external_signer.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_default_external_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_init_logging.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_func_init_logging.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_token_conversion_limits.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_token_conversion_limits.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_parse.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_encrypt.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_decrypt.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_ecies_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_frost_signing_commitments.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_frost_signing_commitments.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_key.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key_source.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key_source.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_private_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_public_key.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_static_deposit_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_private_keys.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_private_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_private_key_for_receiver.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_private_key_for_receiver.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_from_private_key_source.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_from_private_key_source.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost_signatures.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost_signatures.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_restclient_get_request.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_restclient_get_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_restclient_post_request.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_restclient_post_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_restclient_delete_request.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_restclient_delete_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_list_payments.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_list_payments.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_insert_payment.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_insert_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_add_deposit.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_add_deposit.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_list_deposits.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_list_deposits.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_update_deposit.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_update_deposit.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_logger_log.argtypes = (
)
_UniffiLib.uniffi_breez_sdk_spark_checksum_method_logger_log.restype = ctypes.c_uint16
_UniffiLib.ffi_breez_sdk_spark_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_breez_sdk_spark_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)



class BitcoinChainService(typing.Protocol):
    def get_address_utxos(self, address: "str"):
        raise NotImplementedError
    def get_transaction_status(self, txid: "str"):
        raise NotImplementedError
    def get_transaction_hex(self, txid: "str"):
        raise NotImplementedError
    def broadcast_transaction(self, tx: "str"):
        raise NotImplementedError
    def recommended_fees(self, ):
        raise NotImplementedError


class BitcoinChainServiceImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_bitcoinchainservice, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def get_address_utxos(self, address: "str") -> "typing.List[Utxo]":
        _UniffiConverterString.check_lower(address)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeUtxo.lift,
            
    # Error FFI converter
_UniffiConverterTypeChainServiceError,

        )



    async def get_transaction_status(self, txid: "str") -> "TxStatus":
        _UniffiConverterString.check_lower(txid)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(txid)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTxStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeChainServiceError,

        )



    async def get_transaction_hex(self, txid: "str") -> "str":
        _UniffiConverterString.check_lower(txid)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(txid)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeChainServiceError,

        )



    async def broadcast_transaction(self, tx: "str") -> None:

        _UniffiConverterString.check_lower(tx)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(tx)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeChainServiceError,

        )



    async def recommended_fees(self, ) -> "RecommendedFees":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRecommendedFees.lift,
            
    # Error FFI converter
_UniffiConverterTypeChainServiceError,

        )


# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplBitcoinChainService:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD0
    def get_address_utxos(
            uniffi_handle,
            address,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeBitcoinChainService._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), )
            method = uniffi_obj.get_address_utxos
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeUtxo.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ChainServiceError, _UniffiConverterTypeChainServiceError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD1
    def get_transaction_status(
            uniffi_handle,
            txid,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeBitcoinChainService._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(txid), )
            method = uniffi_obj.get_transaction_status
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeTxStatus.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ChainServiceError, _UniffiConverterTypeChainServiceError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD2
    def get_transaction_hex(
            uniffi_handle,
            txid,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeBitcoinChainService._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(txid), )
            method = uniffi_obj.get_transaction_hex
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ChainServiceError, _UniffiConverterTypeChainServiceError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD3
    def broadcast_transaction(
            uniffi_handle,
            tx,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeBitcoinChainService._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(tx), )
            method = uniffi_obj.broadcast_transaction
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ChainServiceError, _UniffiConverterTypeChainServiceError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_BITCOIN_CHAIN_SERVICE_METHOD4
    def recommended_fees(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeBitcoinChainService._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.recommended_fees
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeRecommendedFees.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ChainServiceError, _UniffiConverterTypeChainServiceError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeBitcoinChainService._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceBitcoinChainService(
        get_address_utxos,
        get_transaction_status,
        get_transaction_hex,
        broadcast_transaction,
        recommended_fees,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeBitcoinChainService:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return BitcoinChainServiceImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: BitcoinChainService):
        pass

    @staticmethod
    def lower(value: BitcoinChainService):
        return _UniffiConverterTypeBitcoinChainService._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BitcoinChainService, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BreezSdkProtocol(typing.Protocol):
    """
    `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
    with request/response objects and comprehensive error handling.
    """

    def add_event_listener(self, listener: "EventListener"):
        """
        Registers a listener to receive SDK events

        # Arguments

        * `listener` - An implementation of the `EventListener` trait

        # Returns

        A unique identifier for the listener, which can be used to remove it later
        """

        raise NotImplementedError
    def cancel_leaf_optimization(self, ):
        """
        Cancels the ongoing leaf optimization.

        This method cancels the ongoing optimization and waits for it to fully stop.
        The current round will complete before stopping. This method blocks
        until the optimization has fully stopped and leaves reserved for optimization
        are available again.

        If no optimization is running, this method returns immediately.
        """

        raise NotImplementedError
    def check_lightning_address_available(self, req: "CheckLightningAddressRequest"):
        raise NotImplementedError
    def check_message(self, request: "CheckMessageRequest"):
        """
        Verifies a message signature against the provided public key. The message
        is SHA256 hashed before verification. The signature can be hex encoded
        in either DER or compact format.
        """

        raise NotImplementedError
    def claim_deposit(self, request: "ClaimDepositRequest"):
        raise NotImplementedError
    def claim_htlc_payment(self, request: "ClaimHtlcPaymentRequest"):
        raise NotImplementedError
    def delete_lightning_address(self, ):
        raise NotImplementedError
    def disconnect(self, ):
        """
        Stops the SDK's background tasks

        This method stops the background tasks started by the `start()` method.
        It should be called before your application terminates to ensure proper cleanup.

        # Returns

        Result containing either success or an `SdkError` if the background task couldn't be stopped
        """

        raise NotImplementedError
    def fetch_token_conversion_limits(self, request: "FetchTokenConversionLimitsRequest"):
        raise NotImplementedError
    def get_info(self, request: "GetInfoRequest"):
        """
        Returns the balance of the wallet in satoshis
        """

        raise NotImplementedError
    def get_leaf_optimization_progress(self, ):
        """
        Returns the current optimization progress snapshot.
        """

        raise NotImplementedError
    def get_lightning_address(self, ):
        raise NotImplementedError
    def get_payment(self, request: "GetPaymentRequest"):
        raise NotImplementedError
    def get_token_issuer(self, ):
        """
        Returns an instance of the [`TokenIssuer`] for managing token issuance.
        """

        raise NotImplementedError
    def get_tokens_metadata(self, request: "GetTokensMetadataRequest"):
        """
        Returns the metadata for the given token identifiers.

        Results are not guaranteed to be in the same order as the input token identifiers.

        If the metadata is not found locally in cache, it will be queried from
        the Spark network and then cached.
        """

        raise NotImplementedError
    def get_user_settings(self, ):
        """
        Returns the user settings for the wallet.

        Some settings are fetched from the Spark network so network requests are performed.
        """

        raise NotImplementedError
    def list_fiat_currencies(self, ):
        """
        List fiat currencies for which there is a known exchange rate,
        sorted by the canonical name of the currency.
        """

        raise NotImplementedError
    def list_fiat_rates(self, ):
        """
        List the latest rates of fiat currencies, sorted by name.
        """

        raise NotImplementedError
    def list_payments(self, request: "ListPaymentsRequest"):
        """
        Lists payments from the storage with pagination

        This method provides direct access to the payment history stored in the database.
        It returns payments in reverse chronological order (newest first).

        # Arguments

        * `request` - Contains pagination parameters (offset and limit)

        # Returns

        * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
        * `Err(SdkError)` - If there was an error accessing the storage

        """

        raise NotImplementedError
    def list_unclaimed_deposits(self, request: "ListUnclaimedDepositsRequest"):
        raise NotImplementedError
    def lnurl_pay(self, request: "LnurlPayRequest"):
        raise NotImplementedError
    def lnurl_withdraw(self, request: "LnurlWithdrawRequest"):
        """
        Performs an LNURL withdraw operation for the amount of satoshis to
        withdraw and the LNURL withdraw request details. The LNURL withdraw request
        details can be obtained from calling [`BreezSdk::parse`].

        The method generates a Lightning invoice for the withdraw amount, stores
        the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
        invoice.

        If the `completion_timeout_secs` parameter is provided and greater than 0, the
        method will wait for the payment to be completed within that period. If the
        withdraw is completed within the timeout, the `payment` field in the response
        will be set with the payment details. If the `completion_timeout_secs`
        parameter is not provided or set to 0, the method will not wait for the payment
        to be completed. If the withdraw is not completed within the
        timeout, the `payment` field will be empty.

        # Arguments

        * `request` - The LNURL withdraw request

        # Returns

        Result containing either:
        * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
        * `SdkError` - If there was an error during the withdraw process
        """

        raise NotImplementedError
    def parse(self, input: "str"):
        raise NotImplementedError
    def prepare_lnurl_pay(self, request: "PrepareLnurlPayRequest"):
        raise NotImplementedError
    def prepare_send_payment(self, request: "PrepareSendPaymentRequest"):
        raise NotImplementedError
    def receive_payment(self, request: "ReceivePaymentRequest"):
        raise NotImplementedError
    def recommended_fees(self, ):
        """
        Get the recommended BTC fees based on the configured chain service.
        """

        raise NotImplementedError
    def refund_deposit(self, request: "RefundDepositRequest"):
        raise NotImplementedError
    def register_lightning_address(self, request: "RegisterLightningAddressRequest"):
        raise NotImplementedError
    def remove_event_listener(self, id: "str"):
        """
        Removes a previously registered event listener

        # Arguments

        * `id` - The listener ID returned from `add_event_listener`

        # Returns

        `true` if the listener was found and removed, `false` otherwise
        """

        raise NotImplementedError
    def send_payment(self, request: "SendPaymentRequest"):
        raise NotImplementedError
    def sign_message(self, request: "SignMessageRequest"):
        """
        Signs a message with the wallet's identity key. The message is SHA256
        hashed before signing. The returned signature will be hex encoded in
        DER format by default, or compact format if specified.
        """

        raise NotImplementedError
    def start_leaf_optimization(self, ):
        """
        Starts leaf optimization in the background.

        This method spawns the optimization work in a background task and returns
        immediately. Progress is reported via events.
        If optimization is already running, no new task will be started.
        """

        raise NotImplementedError
    def sync_wallet(self, request: "SyncWalletRequest"):
        """
        Synchronizes the wallet with the Spark network
        """

        raise NotImplementedError
    def update_user_settings(self, request: "UpdateUserSettingsRequest"):
        """
        Updates the user settings for the wallet.

        Some settings are updated on the Spark network so network requests may be performed.
        """

        raise NotImplementedError


class BreezSdk:
    """
    `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
    with request/response objects and comprehensive error handling.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_breezsdk, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_breezsdk, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def add_event_listener(self, listener: "EventListener") -> "str":
        """
        Registers a listener to receive SDK events

        # Arguments

        * `listener` - An implementation of the `EventListener` trait

        # Returns

        A unique identifier for the listener, which can be used to remove it later
        """

        _UniffiConverterTypeEventListener.check_lower(listener)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEventListener.lower(listener)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter

    None,

        )



    async def cancel_leaf_optimization(self, ) -> None:

        """
        Cancels the ongoing leaf optimization.

        This method cancels the ongoing optimization and waits for it to fully stop.
        The current round will complete before stopping. This method blocks
        until the optimization has fully stopped and leaves reserved for optimization
        are available again.

        If no optimization is running, this method returns immediately.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def check_lightning_address_available(self, req: "CheckLightningAddressRequest") -> "bool":
        _UniffiConverterTypeCheckLightningAddressRequest.check_lower(req)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeCheckLightningAddressRequest.lower(req)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i8,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i8,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def check_message(self, request: "CheckMessageRequest") -> "CheckMessageResponse":
        """
        Verifies a message signature against the provided public key. The message
        is SHA256 hashed before verification. The signature can be hex encoded
        in either DER or compact format.
        """

        _UniffiConverterTypeCheckMessageRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeCheckMessageRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeCheckMessageResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def claim_deposit(self, request: "ClaimDepositRequest") -> "ClaimDepositResponse":
        _UniffiConverterTypeClaimDepositRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeClaimDepositRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeClaimDepositResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def claim_htlc_payment(self, request: "ClaimHtlcPaymentRequest") -> "ClaimHtlcPaymentResponse":
        _UniffiConverterTypeClaimHtlcPaymentRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeClaimHtlcPaymentRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeClaimHtlcPaymentResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def delete_lightning_address(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def disconnect(self, ) -> None:

        """
        Stops the SDK's background tasks

        This method stops the background tasks started by the `start()` method.
        It should be called before your application terminates to ensure proper cleanup.

        # Returns

        Result containing either success or an `SdkError` if the background task couldn't be stopped
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def fetch_token_conversion_limits(self, request: "FetchTokenConversionLimitsRequest") -> "FetchTokenConversionLimitsResponse":
        _UniffiConverterTypeFetchTokenConversionLimitsRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_token_conversion_limits(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFetchTokenConversionLimitsRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFetchTokenConversionLimitsResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def get_info(self, request: "GetInfoRequest") -> "GetInfoResponse":
        """
        Returns the balance of the wallet in satoshis
        """

        _UniffiConverterTypeGetInfoRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeGetInfoRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetInfoResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )




    def get_leaf_optimization_progress(self, ) -> "OptimizationProgress":
        """
        Returns the current optimization progress snapshot.
        """

        return _UniffiConverterTypeOptimizationProgress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress,self._uniffi_clone_pointer(),)
        )




    async def get_lightning_address(self, ) -> "typing.Optional[LightningAddressInfo]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeLightningAddressInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def get_payment(self, request: "GetPaymentRequest") -> "GetPaymentResponse":
        _UniffiConverterTypeGetPaymentRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeGetPaymentRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetPaymentResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )




    def get_token_issuer(self, ) -> "TokenIssuer":
        """
        Returns an instance of the [`TokenIssuer`] for managing token issuance.
        """

        return _UniffiConverterTypeTokenIssuer.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer,self._uniffi_clone_pointer(),)
        )




    async def get_tokens_metadata(self, request: "GetTokensMetadataRequest") -> "GetTokensMetadataResponse":
        """
        Returns the metadata for the given token identifiers.

        Results are not guaranteed to be in the same order as the input token identifiers.

        If the metadata is not found locally in cache, it will be queried from
        the Spark network and then cached.
        """

        _UniffiConverterTypeGetTokensMetadataRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeGetTokensMetadataRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetTokensMetadataResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def get_user_settings(self, ) -> "UserSettings":
        """
        Returns the user settings for the wallet.

        Some settings are fetched from the Spark network so network requests are performed.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeUserSettings.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def list_fiat_currencies(self, ) -> "ListFiatCurrenciesResponse":
        """
        List fiat currencies for which there is a known exchange rate,
        sorted by the canonical name of the currency.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeListFiatCurrenciesResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def list_fiat_rates(self, ) -> "ListFiatRatesResponse":
        """
        List the latest rates of fiat currencies, sorted by name.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeListFiatRatesResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def list_payments(self, request: "ListPaymentsRequest") -> "ListPaymentsResponse":
        """
        Lists payments from the storage with pagination

        This method provides direct access to the payment history stored in the database.
        It returns payments in reverse chronological order (newest first).

        # Arguments

        * `request` - Contains pagination parameters (offset and limit)

        # Returns

        * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
        * `Err(SdkError)` - If there was an error accessing the storage

        """

        _UniffiConverterTypeListPaymentsRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeListPaymentsRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeListPaymentsResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def list_unclaimed_deposits(self, request: "ListUnclaimedDepositsRequest") -> "ListUnclaimedDepositsResponse":
        _UniffiConverterTypeListUnclaimedDepositsRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeListUnclaimedDepositsRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeListUnclaimedDepositsResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def lnurl_pay(self, request: "LnurlPayRequest") -> "LnurlPayResponse":
        _UniffiConverterTypeLnurlPayRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeLnurlPayRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLnurlPayResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def lnurl_withdraw(self, request: "LnurlWithdrawRequest") -> "LnurlWithdrawResponse":
        """
        Performs an LNURL withdraw operation for the amount of satoshis to
        withdraw and the LNURL withdraw request details. The LNURL withdraw request
        details can be obtained from calling [`BreezSdk::parse`].

        The method generates a Lightning invoice for the withdraw amount, stores
        the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
        invoice.

        If the `completion_timeout_secs` parameter is provided and greater than 0, the
        method will wait for the payment to be completed within that period. If the
        withdraw is completed within the timeout, the `payment` field in the response
        will be set with the payment details. If the `completion_timeout_secs`
        parameter is not provided or set to 0, the method will not wait for the payment
        to be completed. If the withdraw is not completed within the
        timeout, the `payment` field will be empty.

        # Arguments

        * `request` - The LNURL withdraw request

        # Returns

        Result containing either:
        * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
        * `SdkError` - If there was an error during the withdraw process
        """

        _UniffiConverterTypeLnurlWithdrawRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeLnurlWithdrawRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLnurlWithdrawResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def parse(self, input: "str") -> "InputType":
        _UniffiConverterString.check_lower(input)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(input)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeInputType.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def prepare_lnurl_pay(self, request: "PrepareLnurlPayRequest") -> "PrepareLnurlPayResponse":
        _UniffiConverterTypePrepareLnurlPayRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePrepareLnurlPayRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePrepareLnurlPayResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def prepare_send_payment(self, request: "PrepareSendPaymentRequest") -> "PrepareSendPaymentResponse":
        _UniffiConverterTypePrepareSendPaymentRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePrepareSendPaymentRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePrepareSendPaymentResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def receive_payment(self, request: "ReceivePaymentRequest") -> "ReceivePaymentResponse":
        _UniffiConverterTypeReceivePaymentRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeReceivePaymentRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeReceivePaymentResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def recommended_fees(self, ) -> "RecommendedFees":
        """
        Get the recommended BTC fees based on the configured chain service.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRecommendedFees.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def refund_deposit(self, request: "RefundDepositRequest") -> "RefundDepositResponse":
        _UniffiConverterTypeRefundDepositRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRefundDepositRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRefundDepositResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def register_lightning_address(self, request: "RegisterLightningAddressRequest") -> "LightningAddressInfo":
        _UniffiConverterTypeRegisterLightningAddressRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRegisterLightningAddressRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLightningAddressInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def remove_event_listener(self, id: "str") -> "bool":
        """
        Removes a previously registered event listener

        # Arguments

        * `id` - The listener ID returned from `add_event_listener`

        # Returns

        `true` if the listener was found and removed, `false` otherwise
        """

        _UniffiConverterString.check_lower(id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_i8,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_i8,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter

    None,

        )



    async def send_payment(self, request: "SendPaymentRequest") -> "SendPaymentResponse":
        _UniffiConverterTypeSendPaymentRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSendPaymentRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSendPaymentResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def sign_message(self, request: "SignMessageRequest") -> "SignMessageResponse":
        """
        Signs a message with the wallet's identity key. The message is SHA256
        hashed before signing. The returned signature will be hex encoded in
        DER format by default, or compact format if specified.
        """

        _UniffiConverterTypeSignMessageRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSignMessageRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSignMessageResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )




    def start_leaf_optimization(self, ) -> None:
        """
        Starts leaf optimization in the background.

        This method spawns the optimization work in a background task and returns
        immediately. Progress is reported via events.
        If optimization is already running, no new task will be started.
        """

        _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization,self._uniffi_clone_pointer(),)





    async def sync_wallet(self, request: "SyncWalletRequest") -> "SyncWalletResponse":
        """
        Synchronizes the wallet with the Spark network
        """

        _UniffiConverterTypeSyncWalletRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSyncWalletRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSyncWalletResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def update_user_settings(self, request: "UpdateUserSettingsRequest") -> None:

        """
        Updates the user settings for the wallet.

        Some settings are updated on the Spark network so network requests may be performed.
        """

        _UniffiConverterTypeUpdateUserSettingsRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeUpdateUserSettingsRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )





class _UniffiConverterTypeBreezSdk:

    @staticmethod
    def lift(value: int):
        return BreezSdk._make_instance_(value)

    @staticmethod
    def check_lower(value: BreezSdk):
        if not isinstance(value, BreezSdk):
            raise TypeError("Expected BreezSdk instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BreezSdkProtocol):
        if not isinstance(value, BreezSdk):
            raise TypeError("Expected BreezSdk instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BreezSdkProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ExternalSigner(typing.Protocol):
    """
    External signer trait that can be implemented by users and passed to the SDK.

    This trait mirrors the `BreezSigner` trait but uses FFI-compatible types (bytes, strings)
    instead of Rust-specific types. This allows it to be exposed through FFI and WASM bindings.

    All methods accept and return simple types:
    - Derivation paths as strings (e.g., "m/44'/0'/0'")
    - Public keys, signatures, and other crypto primitives as Vec<u8>
    - Spark-specific types as serialized representations

    Errors are returned as `SignerError` for FFI compatibility.
    """

    def identity_public_key(self, ):
        """
        Returns the identity public key as 33 bytes (compressed secp256k1 key).
        """

        raise NotImplementedError
    def derive_public_key(self, path: "str"):
        """
        Derives a public key for the given BIP32 derivation path.

        # Arguments
        * `path` - BIP32 derivation path as a string (e.g., "m/44'/0'/0'/0/0")

        # Returns
        The derived public key as 33 bytes, or a `SignerError`
        """

        raise NotImplementedError
    def sign_ecdsa(self, message: "bytes",path: "str"):
        """
        Signs a message using ECDSA at the given derivation path.

        # Arguments
        * `message` - The message to sign
        * `path` - BIP32 derivation path as a string

        # Returns
        64-byte compact ECDSA signature, or a `SignerError`
        """

        raise NotImplementedError
    def sign_ecdsa_recoverable(self, message: "bytes",path: "str"):
        """
        Signs a message using recoverable ECDSA at the given derivation path.

        # Arguments
        * `message` - The message to sign (will be double-SHA256 hashed)
        * `path` - BIP32 derivation path as a string

        # Returns
        65 bytes: recovery ID (31 + `recovery_id`) + 64-byte signature, or a `SignerError`
        """

        raise NotImplementedError
    def ecies_encrypt(self, message: "bytes",path: "str"):
        """
        Encrypts a message using ECIES at the given derivation path.

        # Arguments
        * `message` - The message to encrypt
        * `path` - BIP32 derivation path for the encryption key

        # Returns
        Encrypted data, or a `SignerError`
        """

        raise NotImplementedError
    def ecies_decrypt(self, message: "bytes",path: "str"):
        """
        Decrypts a message using ECIES at the given derivation path.

        # Arguments
        * `message` - The encrypted message
        * `path` - BIP32 derivation path for the decryption key

        # Returns
        Decrypted data, or a `SignerError`
        """

        raise NotImplementedError
    def sign_hash_schnorr(self, hash: "bytes",path: "str"):
        """
        Signs a hash using Schnorr signature at the given derivation path.

        # Arguments
        * `hash` - The 32-byte hash to sign (must be 32 bytes)
        * `path` - BIP32 derivation path as a string

        # Returns
        64-byte Schnorr signature, or a `SignerError`
        """

        raise NotImplementedError
    def generate_frost_signing_commitments(self, ):
        """
        Generates Frost signing commitments for multi-party signing.

        # Returns
        Frost commitments with nonces, or a `SignerError`
        """

        raise NotImplementedError
    def get_public_key_for_node(self, id: "ExternalTreeNodeId"):
        """
        Gets the public key for a specific tree node in the Spark wallet.

        # Arguments
        * `id` - The tree node identifier

        # Returns
        The public key for the node, or an error string
        """

        raise NotImplementedError
    def generate_random_key(self, ):
        """
        Generates a random private key.

        # Returns
        A randomly generated private key source, or an error string
        """

        raise NotImplementedError
    def get_static_deposit_private_key_source(self, index: "int"):
        """
        Gets a static deposit private key source by index.

        # Arguments
        * `index` - The index of the static deposit key

        # Returns
        The private key source, or an error string
        """

        raise NotImplementedError
    def get_static_deposit_private_key(self, index: "int"):
        """
        Gets a static deposit private key by index.

        # Arguments
        * `index` - The index of the static deposit key

        # Returns
        The 32-byte private key, or an error string
        """

        raise NotImplementedError
    def get_static_deposit_public_key(self, index: "int"):
        """
        Gets a static deposit public key by index.

        # Arguments
        * `index` - The index of the static deposit key

        # Returns
        The 33-byte public key, or an error string
        """

        raise NotImplementedError
    def subtract_private_keys(self, signing_key: "ExternalPrivateKeySource",new_signing_key: "ExternalPrivateKeySource"):
        """
        Subtracts one private key from another.

        # Arguments
        * `signing_key` - The first private key source
        * `new_signing_key` - The second private key source to subtract

        # Returns
        The resulting private key source, or an error string
        """

        raise NotImplementedError
    def split_secret(self, secret: "ExternalSecretToSplit",threshold: "int",num_shares: "int"):
        """
        Splits a secret with proofs using Shamir's Secret Sharing.

        # Arguments
        * `secret` - The secret to split
        * `threshold` - Minimum number of shares needed to reconstruct
        * `num_shares` - Total number of shares to create

        # Returns
        Vector of verifiable secret shares, or an error string
        """

        raise NotImplementedError
    def encrypt_private_key_for_receiver(self, private_key: "ExternalEncryptedPrivateKey",receiver_public_key: "PublicKeyBytes"):
        """
        Encrypts a private key for a specific receiver's public key.

        # Arguments
        * `private_key` - The encrypted private key to re-encrypt
        * `receiver_public_key` - The receiver's 33-byte public key

        # Returns
        Encrypted data for the receiver, or an error string
        """

        raise NotImplementedError
    def get_public_key_from_private_key_source(self, private_key: "ExternalPrivateKeySource"):
        """
        Gets the public key from a private key source.

        # Arguments
        * `private_key` - The private key source

        # Returns
        The corresponding 33-byte public key, or an error string
        """

        raise NotImplementedError
    def sign_frost(self, request: "ExternalSignFrostRequest"):
        """
        Signs using Frost protocol (multi-party signing).

        # Arguments
        * `request` - The Frost signing request

        # Returns
        A signature share, or an error string
        """

        raise NotImplementedError
    def aggregate_frost_signatures(self, request: "ExternalAggregateFrostRequest"):
        """
        Aggregates Frost signature shares into a final signature.

        # Arguments
        * `request` - The Frost aggregation request

        # Returns
        The aggregated Frost signature, or an error string
        """

        raise NotImplementedError


class ExternalSignerImpl:
    """
    External signer trait that can be implemented by users and passed to the SDK.

    This trait mirrors the `BreezSigner` trait but uses FFI-compatible types (bytes, strings)
    instead of Rust-specific types. This allows it to be exposed through FFI and WASM bindings.

    All methods accept and return simple types:
    - Derivation paths as strings (e.g., "m/44'/0'/0'")
    - Public keys, signatures, and other crypto primitives as Vec<u8>
    - Spark-specific types as serialized representations

    Errors are returned as `SignerError` for FFI compatibility.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_externalsigner, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_externalsigner, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def identity_public_key(self, ) -> "PublicKeyBytes":
        """
        Returns the identity public key as 33 bytes (compressed secp256k1 key).
        """

        return _UniffiConverterTypePublicKeyBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSignerError,_UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key,self._uniffi_clone_pointer(),)
        )




    async def derive_public_key(self, path: "str") -> "PublicKeyBytes":
        """
        Derives a public key for the given BIP32 derivation path.

        # Arguments
        * `path` - BIP32 derivation path as a string (e.g., "m/44'/0'/0'/0/0")

        # Returns
        The derived public key as 33 bytes, or a `SignerError`
        """

        _UniffiConverterString.check_lower(path)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(path)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePublicKeyBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def sign_ecdsa(self, message: "bytes",path: "str") -> "EcdsaSignatureBytes":
        """
        Signs a message using ECDSA at the given derivation path.

        # Arguments
        * `message` - The message to sign
        * `path` - BIP32 derivation path as a string

        # Returns
        64-byte compact ECDSA signature, or a `SignerError`
        """

        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterString.check_lower(path)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(message),
        _UniffiConverterString.lower(path)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEcdsaSignatureBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def sign_ecdsa_recoverable(self, message: "bytes",path: "str") -> "RecoverableEcdsaSignatureBytes":
        """
        Signs a message using recoverable ECDSA at the given derivation path.

        # Arguments
        * `message` - The message to sign (will be double-SHA256 hashed)
        * `path` - BIP32 derivation path as a string

        # Returns
        65 bytes: recovery ID (31 + `recovery_id`) + 64-byte signature, or a `SignerError`
        """

        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterString.check_lower(path)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(message),
        _UniffiConverterString.lower(path)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRecoverableEcdsaSignatureBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def ecies_encrypt(self, message: "bytes",path: "str") -> "bytes":
        """
        Encrypts a message using ECIES at the given derivation path.

        # Arguments
        * `message` - The message to encrypt
        * `path` - BIP32 derivation path for the encryption key

        # Returns
        Encrypted data, or a `SignerError`
        """

        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterString.check_lower(path)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_encrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(message),
        _UniffiConverterString.lower(path)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def ecies_decrypt(self, message: "bytes",path: "str") -> "bytes":
        """
        Decrypts a message using ECIES at the given derivation path.

        # Arguments
        * `message` - The encrypted message
        * `path` - BIP32 derivation path for the decryption key

        # Returns
        Decrypted data, or a `SignerError`
        """

        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterString.check_lower(path)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_ecies_decrypt(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(message),
        _UniffiConverterString.lower(path)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def sign_hash_schnorr(self, hash: "bytes",path: "str") -> "SchnorrSignatureBytes":
        """
        Signs a hash using Schnorr signature at the given derivation path.

        # Arguments
        * `hash` - The 32-byte hash to sign (must be 32 bytes)
        * `path` - BIP32 derivation path as a string

        # Returns
        64-byte Schnorr signature, or a `SignerError`
        """

        _UniffiConverterBytes.check_lower(hash)
        
        _UniffiConverterString.check_lower(path)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(hash),
        _UniffiConverterString.lower(path)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSchnorrSignatureBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def generate_frost_signing_commitments(self, ) -> "ExternalFrostCommitments":
        """
        Generates Frost signing commitments for multi-party signing.

        # Returns
        Frost commitments with nonces, or a `SignerError`
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_generate_frost_signing_commitments(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeExternalFrostCommitments.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def get_public_key_for_node(self, id: "ExternalTreeNodeId") -> "PublicKeyBytes":
        """
        Gets the public key for a specific tree node in the Spark wallet.

        # Arguments
        * `id` - The tree node identifier

        # Returns
        The public key for the node, or an error string
        """

        _UniffiConverterTypeExternalTreeNodeId.check_lower(id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeExternalTreeNodeId.lower(id)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePublicKeyBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def generate_random_key(self, ) -> "ExternalPrivateKeySource":
        """
        Generates a random private key.

        # Returns
        A randomly generated private key source, or an error string
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_key(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeExternalPrivateKeySource.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def get_static_deposit_private_key_source(self, index: "int") -> "ExternalPrivateKeySource":
        """
        Gets a static deposit private key source by index.

        # Arguments
        * `index` - The index of the static deposit key

        # Returns
        The private key source, or an error string
        """

        _UniffiConverterUInt32.check_lower(index)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key_source(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt32.lower(index)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeExternalPrivateKeySource.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def get_static_deposit_private_key(self, index: "int") -> "PrivateKeyBytes":
        """
        Gets a static deposit private key by index.

        # Arguments
        * `index` - The index of the static deposit key

        # Returns
        The 32-byte private key, or an error string
        """

        _UniffiConverterUInt32.check_lower(index)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_private_key(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt32.lower(index)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePrivateKeyBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def get_static_deposit_public_key(self, index: "int") -> "PublicKeyBytes":
        """
        Gets a static deposit public key by index.

        # Arguments
        * `index` - The index of the static deposit key

        # Returns
        The 33-byte public key, or an error string
        """

        _UniffiConverterUInt32.check_lower(index)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_static_deposit_public_key(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt32.lower(index)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePublicKeyBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def subtract_private_keys(self, signing_key: "ExternalPrivateKeySource",new_signing_key: "ExternalPrivateKeySource") -> "ExternalPrivateKeySource":
        """
        Subtracts one private key from another.

        # Arguments
        * `signing_key` - The first private key source
        * `new_signing_key` - The second private key source to subtract

        # Returns
        The resulting private key source, or an error string
        """

        _UniffiConverterTypeExternalPrivateKeySource.check_lower(signing_key)
        
        _UniffiConverterTypeExternalPrivateKeySource.check_lower(new_signing_key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_private_keys(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeExternalPrivateKeySource.lower(signing_key),
        _UniffiConverterTypeExternalPrivateKeySource.lower(new_signing_key)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeExternalPrivateKeySource.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def split_secret(self, secret: "ExternalSecretToSplit",threshold: "int",num_shares: "int") -> "typing.List[ExternalVerifiableSecretShare]":
        """
        Splits a secret with proofs using Shamir's Secret Sharing.

        # Arguments
        * `secret` - The secret to split
        * `threshold` - Minimum number of shares needed to reconstruct
        * `num_shares` - Total number of shares to create

        # Returns
        Vector of verifiable secret shares, or an error string
        """

        _UniffiConverterTypeExternalSecretToSplit.check_lower(secret)
        
        _UniffiConverterUInt32.check_lower(threshold)
        
        _UniffiConverterUInt32.check_lower(num_shares)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeExternalSecretToSplit.lower(secret),
        _UniffiConverterUInt32.lower(threshold),
        _UniffiConverterUInt32.lower(num_shares)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeExternalVerifiableSecretShare.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def encrypt_private_key_for_receiver(self, private_key: "ExternalEncryptedPrivateKey",receiver_public_key: "PublicKeyBytes") -> "bytes":
        """
        Encrypts a private key for a specific receiver's public key.

        # Arguments
        * `private_key` - The encrypted private key to re-encrypt
        * `receiver_public_key` - The receiver's 33-byte public key

        # Returns
        Encrypted data for the receiver, or an error string
        """

        _UniffiConverterTypeExternalEncryptedPrivateKey.check_lower(private_key)
        
        _UniffiConverterTypePublicKeyBytes.check_lower(receiver_public_key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_private_key_for_receiver(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeExternalEncryptedPrivateKey.lower(private_key),
        _UniffiConverterTypePublicKeyBytes.lower(receiver_public_key)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def get_public_key_from_private_key_source(self, private_key: "ExternalPrivateKeySource") -> "PublicKeyBytes":
        """
        Gets the public key from a private key source.

        # Arguments
        * `private_key` - The private key source

        # Returns
        The corresponding 33-byte public key, or an error string
        """

        _UniffiConverterTypeExternalPrivateKeySource.check_lower(private_key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_from_private_key_source(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeExternalPrivateKeySource.lower(private_key)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePublicKeyBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def sign_frost(self, request: "ExternalSignFrostRequest") -> "ExternalFrostSignatureShare":
        """
        Signs using Frost protocol (multi-party signing).

        # Arguments
        * `request` - The Frost signing request

        # Returns
        A signature share, or an error string
        """

        _UniffiConverterTypeExternalSignFrostRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeExternalSignFrostRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeExternalFrostSignatureShare.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )



    async def aggregate_frost_signatures(self, request: "ExternalAggregateFrostRequest") -> "ExternalFrostSignature":
        """
        Aggregates Frost signature shares into a final signature.

        # Arguments
        * `request` - The Frost aggregation request

        # Returns
        The aggregated Frost signature, or an error string
        """

        _UniffiConverterTypeExternalAggregateFrostRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost_signatures(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeExternalAggregateFrostRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeExternalFrostSignature.lift,
            
    # Error FFI converter
_UniffiConverterTypeSignerError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplExternalSigner:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD0
    def identity_public_key(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.identity_public_key
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterTypePublicKeyBytes.lower(v)
        _uniffi_trait_interface_call_with_error(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
                SignerError,
                _UniffiConverterTypeSignerError.lower,
        )

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD1
    def derive_public_key(
            uniffi_handle,
            path,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(path), )
            method = uniffi_obj.derive_public_key
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePublicKeyBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD2
    def sign_ecdsa(
            uniffi_handle,
            message,
            path,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(message), _UniffiConverterString.lift(path), )
            method = uniffi_obj.sign_ecdsa
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeEcdsaSignatureBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD3
    def sign_ecdsa_recoverable(
            uniffi_handle,
            message,
            path,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(message), _UniffiConverterString.lift(path), )
            method = uniffi_obj.sign_ecdsa_recoverable
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeRecoverableEcdsaSignatureBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD4
    def ecies_encrypt(
            uniffi_handle,
            message,
            path,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(message), _UniffiConverterString.lift(path), )
            method = uniffi_obj.ecies_encrypt
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD5
    def ecies_decrypt(
            uniffi_handle,
            message,
            path,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(message), _UniffiConverterString.lift(path), )
            method = uniffi_obj.ecies_decrypt
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD6
    def sign_hash_schnorr(
            uniffi_handle,
            hash,
            path,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(hash), _UniffiConverterString.lift(path), )
            method = uniffi_obj.sign_hash_schnorr
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeSchnorrSignatureBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD7
    def generate_frost_signing_commitments(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.generate_frost_signing_commitments
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeExternalFrostCommitments.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD8
    def get_public_key_for_node(
            uniffi_handle,
            id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeExternalTreeNodeId.lift(id), )
            method = uniffi_obj.get_public_key_for_node
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePublicKeyBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD9
    def generate_random_key(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.generate_random_key
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeExternalPrivateKeySource.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD10
    def get_static_deposit_private_key_source(
            uniffi_handle,
            index,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt32.lift(index), )
            method = uniffi_obj.get_static_deposit_private_key_source
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeExternalPrivateKeySource.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD11
    def get_static_deposit_private_key(
            uniffi_handle,
            index,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt32.lift(index), )
            method = uniffi_obj.get_static_deposit_private_key
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePrivateKeyBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD12
    def get_static_deposit_public_key(
            uniffi_handle,
            index,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt32.lift(index), )
            method = uniffi_obj.get_static_deposit_public_key
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePublicKeyBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD13
    def subtract_private_keys(
            uniffi_handle,
            signing_key,
            new_signing_key,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeExternalPrivateKeySource.lift(signing_key), _UniffiConverterTypeExternalPrivateKeySource.lift(new_signing_key), )
            method = uniffi_obj.subtract_private_keys
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeExternalPrivateKeySource.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD14
    def split_secret(
            uniffi_handle,
            secret,
            threshold,
            num_shares,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeExternalSecretToSplit.lift(secret), _UniffiConverterUInt32.lift(threshold), _UniffiConverterUInt32.lift(num_shares), )
            method = uniffi_obj.split_secret
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeExternalVerifiableSecretShare.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD15
    def encrypt_private_key_for_receiver(
            uniffi_handle,
            private_key,
            receiver_public_key,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeExternalEncryptedPrivateKey.lift(private_key), _UniffiConverterTypePublicKeyBytes.lift(receiver_public_key), )
            method = uniffi_obj.encrypt_private_key_for_receiver
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD16
    def get_public_key_from_private_key_source(
            uniffi_handle,
            private_key,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeExternalPrivateKeySource.lift(private_key), )
            method = uniffi_obj.get_public_key_from_private_key_source
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePublicKeyBytes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD17
    def sign_frost(
            uniffi_handle,
            request,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeExternalSignFrostRequest.lift(request), )
            method = uniffi_obj.sign_frost
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeExternalFrostSignatureShare.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_EXTERNAL_SIGNER_METHOD18
    def aggregate_frost_signatures(
            uniffi_handle,
            request,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeExternalSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeExternalAggregateFrostRequest.lift(request), )
            method = uniffi_obj.aggregate_frost_signatures
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeExternalFrostSignature.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SignerError, _UniffiConverterTypeSignerError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeExternalSigner._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceExternalSigner(
        identity_public_key,
        derive_public_key,
        sign_ecdsa,
        sign_ecdsa_recoverable,
        ecies_encrypt,
        ecies_decrypt,
        sign_hash_schnorr,
        generate_frost_signing_commitments,
        get_public_key_for_node,
        generate_random_key,
        get_static_deposit_private_key_source,
        get_static_deposit_private_key,
        get_static_deposit_public_key,
        subtract_private_keys,
        split_secret,
        encrypt_private_key_for_receiver,
        get_public_key_from_private_key_source,
        sign_frost,
        aggregate_frost_signatures,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeExternalSigner:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return ExternalSignerImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: ExternalSigner):
        pass

    @staticmethod
    def lower(value: ExternalSigner):
        return _UniffiConverterTypeExternalSigner._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ExternalSigner, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FiatService(typing.Protocol):
    """
    Trait covering fiat-related functionality
    """

    def fetch_fiat_currencies(self, ):
        """
        List all supported fiat currencies for which there is a known exchange rate.
        """

        raise NotImplementedError
    def fetch_fiat_rates(self, ):
        """
        Get the live rates from the server.
        """

        raise NotImplementedError


class FiatServiceImpl:
    """
    Trait covering fiat-related functionality
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_fiatservice, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_fiatservice, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def fetch_fiat_currencies(self, ) -> "typing.List[FiatCurrency]":
        """
        List all supported fiat currencies for which there is a known exchange rate.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeFiatCurrency.lift,
            
    # Error FFI converter
_UniffiConverterTypeServiceConnectivityError,

        )



    async def fetch_fiat_rates(self, ) -> "typing.List[Rate]":
        """
        Get the live rates from the server.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeRate.lift,
            
    # Error FFI converter
_UniffiConverterTypeServiceConnectivityError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFiatService:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FIAT_SERVICE_METHOD0
    def fetch_fiat_currencies(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeFiatService._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.fetch_fiat_currencies
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeFiatCurrency.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ServiceConnectivityError, _UniffiConverterTypeServiceConnectivityError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FIAT_SERVICE_METHOD1
    def fetch_fiat_rates(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeFiatService._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.fetch_fiat_rates
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeRate.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ServiceConnectivityError, _UniffiConverterTypeServiceConnectivityError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFiatService._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFiatService(
        fetch_fiat_currencies,
        fetch_fiat_rates,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFiatService:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FiatServiceImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FiatService):
        pass

    @staticmethod
    def lower(value: FiatService):
        return _UniffiConverterTypeFiatService._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FiatService, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class PaymentObserver(typing.Protocol):
    """
    This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
    If the implementation returns an error, the payment is cancelled.
    """

    def before_send(self, payments: "typing.List[ProvisionalPayment]"):
        """
        Called before Lightning, Spark or onchain Bitcoin payments are made
        """

        raise NotImplementedError


class PaymentObserverImpl:
    """
    This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
    If the implementation returns an error, the payment is cancelled.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_paymentobserver, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_paymentobserver, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def before_send(self, payments: "typing.List[ProvisionalPayment]") -> None:

        """
        Called before Lightning, Spark or onchain Bitcoin payments are made
        """

        _UniffiConverterSequenceTypeProvisionalPayment.check_lower(payments)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeProvisionalPayment.lower(payments)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypePaymentObserverError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplPaymentObserver:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_PAYMENT_OBSERVER_METHOD0
    def before_send(
            uniffi_handle,
            payments,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypePaymentObserver._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterSequenceTypeProvisionalPayment.lift(payments), )
            method = uniffi_obj.before_send
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, PaymentObserverError, _UniffiConverterTypePaymentObserverError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypePaymentObserver._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfacePaymentObserver(
        before_send,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypePaymentObserver:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return PaymentObserverImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: PaymentObserver):
        pass

    @staticmethod
    def lower(value: PaymentObserver):
        return _UniffiConverterTypePaymentObserver._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PaymentObserver, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class RestClient(typing.Protocol):
    def get_request(self, url: "str",headers: "typing.Optional[dict[str, str]]"):
        """
        Makes a GET request and logs on DEBUG.
        ### Arguments
        - `url`: the URL on which GET will be called
        - `headers`: optional headers that will be set on the request
        """

        raise NotImplementedError
    def post_request(self, url: "str",headers: "typing.Optional[dict[str, str]]",body: "typing.Optional[str]"):
        """
        Makes a POST request, and logs on DEBUG.
        ### Arguments
        - `url`: the URL on which POST will be called
        - `headers`: the optional POST headers
        - `body`: the optional POST body
        """

        raise NotImplementedError
    def delete_request(self, url: "str",headers: "typing.Optional[dict[str, str]]",body: "typing.Optional[str]"):
        """
        Makes a DELETE request, and logs on DEBUG.
        ### Arguments
        - `url`: the URL on which DELETE will be called
        - `headers`: the optional DELETE headers
        - `body`: the optional DELETE body
        """

        raise NotImplementedError


class RestClientImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_restclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_restclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def get_request(self, url: "str",headers: "typing.Optional[dict[str, str]]") -> "RestResponse":
        """
        Makes a GET request and logs on DEBUG.
        ### Arguments
        - `url`: the URL on which GET will be called
        - `headers`: optional headers that will be set on the request
        """

        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterOptionalMapStringString.check_lower(headers)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_get_request(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalMapStringString.lower(headers)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRestResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeServiceConnectivityError,

        )



    async def post_request(self, url: "str",headers: "typing.Optional[dict[str, str]]",body: "typing.Optional[str]") -> "RestResponse":
        """
        Makes a POST request, and logs on DEBUG.
        ### Arguments
        - `url`: the URL on which POST will be called
        - `headers`: the optional POST headers
        - `body`: the optional POST body
        """

        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterOptionalMapStringString.check_lower(headers)
        
        _UniffiConverterOptionalString.check_lower(body)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_post_request(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalMapStringString.lower(headers),
        _UniffiConverterOptionalString.lower(body)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRestResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeServiceConnectivityError,

        )



    async def delete_request(self, url: "str",headers: "typing.Optional[dict[str, str]]",body: "typing.Optional[str]") -> "RestResponse":
        """
        Makes a DELETE request, and logs on DEBUG.
        ### Arguments
        - `url`: the URL on which DELETE will be called
        - `headers`: the optional DELETE headers
        - `body`: the optional DELETE body
        """

        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterOptionalMapStringString.check_lower(headers)
        
        _UniffiConverterOptionalString.check_lower(body)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_restclient_delete_request(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalMapStringString.lower(headers),
        _UniffiConverterOptionalString.lower(body)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRestResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeServiceConnectivityError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplRestClient:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD0
    def get_request(
            uniffi_handle,
            url,
            headers,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeRestClient._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(url), _UniffiConverterOptionalMapStringString.lift(headers), )
            method = uniffi_obj.get_request
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeRestResponse.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ServiceConnectivityError, _UniffiConverterTypeServiceConnectivityError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD1
    def post_request(
            uniffi_handle,
            url,
            headers,
            body,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeRestClient._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(url), _UniffiConverterOptionalMapStringString.lift(headers), _UniffiConverterOptionalString.lift(body), )
            method = uniffi_obj.post_request
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeRestResponse.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ServiceConnectivityError, _UniffiConverterTypeServiceConnectivityError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_REST_CLIENT_METHOD2
    def delete_request(
            uniffi_handle,
            url,
            headers,
            body,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeRestClient._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(url), _UniffiConverterOptionalMapStringString.lift(headers), _UniffiConverterOptionalString.lift(body), )
            method = uniffi_obj.delete_request
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeRestResponse.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, ServiceConnectivityError, _UniffiConverterTypeServiceConnectivityError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeRestClient._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceRestClient(
        get_request,
        post_request,
        delete_request,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeRestClient:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return RestClientImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: RestClient):
        pass

    @staticmethod
    def lower(value: RestClient):
        return _UniffiConverterTypeRestClient._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RestClient, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SdkBuilderProtocol(typing.Protocol):
    """
    Builder for creating `BreezSdk` instances with customizable components.
    """

    def build(self, ):
        """
        Builds the `BreezSdk` instance with the configured components.
        """

        raise NotImplementedError
    def with_chain_service(self, chain_service: "BitcoinChainService"):
        """
        Sets the chain service to be used by the SDK.
        Arguments:
        - `chain_service`: The chain service to be used.
        """

        raise NotImplementedError
    def with_default_storage(self, storage_dir: "str"):
        """
        Sets the root storage directory to initialize the default storage with.
        This initializes both storage and real-time sync storage with the
        default implementations.
        Arguments:
        - `storage_dir`: The data directory for storage.
        """

        raise NotImplementedError
    def with_fiat_service(self, fiat_service: "FiatService"):
        """
        Sets the fiat service to be used by the SDK.
        Arguments:
        - `fiat_service`: The fiat service to be used.
        """

        raise NotImplementedError
    def with_key_set(self, config: "KeySetConfig"):
        """
        Sets the key set type to be used by the SDK.
        Arguments:
        - `config`: Key set configuration containing the key set type, address index flag, and optional account number.
        """

        raise NotImplementedError
    def with_lnurl_client(self, lnurl_client: "RestClient"):
        raise NotImplementedError
    def with_payment_observer(self, payment_observer: "PaymentObserver"):
        """
        Sets the payment observer to be used by the SDK.
        Arguments:
        - `payment_observer`: The payment observer to be used.
        """

        raise NotImplementedError
    def with_real_time_sync_storage(self, storage: "SyncStorage"):
        """
        Sets the real-time sync storage implementation to be used by the SDK.
        Arguments:
        - `storage`: The sync storage implementation to be used.
        """

        raise NotImplementedError
    def with_rest_chain_service(self, url: "str",api_type: "ChainApiType",credentials: "typing.Optional[Credentials]"):
        """
        Sets the REST chain service to be used by the SDK.
        Arguments:
        - `url`: The base URL of the REST API.
        - `api_type`: The API type to be used.
        - `credentials`: Optional credentials for basic authentication.
        """

        raise NotImplementedError
    def with_storage(self, storage: "Storage"):
        """
        Sets the storage implementation to be used by the SDK.
        Arguments:
        - `storage`: The storage implementation to be used.
        """

        raise NotImplementedError


class SdkBuilder:
    """
    Builder for creating `BreezSdk` instances with customizable components.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, config: "Config",seed: "Seed"):
        """
        Creates a new `SdkBuilder` with the provided configuration.
        Arguments:
        - `config`: The configuration to be used.
        - `seed`: The seed for wallet generation.
        """

        _UniffiConverterTypeConfig.check_lower(config)
        
        _UniffiConverterTypeSeed.check_lower(seed)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new,
        _UniffiConverterTypeConfig.lower(config),
        _UniffiConverterTypeSeed.lower(seed))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_sdkbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_sdkbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def build(self, ) -> "BreezSdk":
        """
        Builds the `BreezSdk` instance with the configured components.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_pointer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_pointer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeBreezSdk.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def with_chain_service(self, chain_service: "BitcoinChainService") -> None:

        """
        Sets the chain service to be used by the SDK.
        Arguments:
        - `chain_service`: The chain service to be used.
        """

        _UniffiConverterTypeBitcoinChainService.check_lower(chain_service)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeBitcoinChainService.lower(chain_service)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def with_default_storage(self, storage_dir: "str") -> None:

        """
        Sets the root storage directory to initialize the default storage with.
        This initializes both storage and real-time sync storage with the
        default implementations.
        Arguments:
        - `storage_dir`: The data directory for storage.
        """

        _UniffiConverterString.check_lower(storage_dir)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(storage_dir)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def with_fiat_service(self, fiat_service: "FiatService") -> None:

        """
        Sets the fiat service to be used by the SDK.
        Arguments:
        - `fiat_service`: The fiat service to be used.
        """

        _UniffiConverterTypeFiatService.check_lower(fiat_service)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFiatService.lower(fiat_service)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def with_key_set(self, config: "KeySetConfig") -> None:

        """
        Sets the key set type to be used by the SDK.
        Arguments:
        - `config`: Key set configuration containing the key set type, address index flag, and optional account number.
        """

        _UniffiConverterTypeKeySetConfig.check_lower(config)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeKeySetConfig.lower(config)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def with_lnurl_client(self, lnurl_client: "RestClient") -> None:

        _UniffiConverterTypeRestClient.check_lower(lnurl_client)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRestClient.lower(lnurl_client)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def with_payment_observer(self, payment_observer: "PaymentObserver") -> None:

        """
        Sets the payment observer to be used by the SDK.
        Arguments:
        - `payment_observer`: The payment observer to be used.
        """

        _UniffiConverterTypePaymentObserver.check_lower(payment_observer)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePaymentObserver.lower(payment_observer)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def with_real_time_sync_storage(self, storage: "SyncStorage") -> None:

        """
        Sets the real-time sync storage implementation to be used by the SDK.
        Arguments:
        - `storage`: The sync storage implementation to be used.
        """

        _UniffiConverterTypeSyncStorage.check_lower(storage)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSyncStorage.lower(storage)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def with_rest_chain_service(self, url: "str",api_type: "ChainApiType",credentials: "typing.Optional[Credentials]") -> None:

        """
        Sets the REST chain service to be used by the SDK.
        Arguments:
        - `url`: The base URL of the REST API.
        - `api_type`: The API type to be used.
        - `credentials`: Optional credentials for basic authentication.
        """

        _UniffiConverterString.check_lower(url)
        
        _UniffiConverterTypeChainApiType.check_lower(api_type)
        
        _UniffiConverterOptionalTypeCredentials.check_lower(credentials)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(url),
        _UniffiConverterTypeChainApiType.lower(api_type),
        _UniffiConverterOptionalTypeCredentials.lower(credentials)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )



    async def with_storage(self, storage: "Storage") -> None:

        """
        Sets the storage implementation to be used by the SDK.
        Arguments:
        - `storage`: The storage implementation to be used.
        """

        _UniffiConverterTypeStorage.check_lower(storage)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeStorage.lower(storage)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )





class _UniffiConverterTypeSdkBuilder:

    @staticmethod
    def lift(value: int):
        return SdkBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: SdkBuilder):
        if not isinstance(value, SdkBuilder):
            raise TypeError("Expected SdkBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SdkBuilderProtocol):
        if not isinstance(value, SdkBuilder):
            raise TypeError("Expected SdkBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SdkBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Storage(typing.Protocol):
    """
    Trait for persistent storage
    """

    def delete_cached_item(self, key: "str"):
        raise NotImplementedError
    def get_cached_item(self, key: "str"):
        raise NotImplementedError
    def set_cached_item(self, key: "str",value: "str"):
        raise NotImplementedError
    def list_payments(self, request: "ListPaymentsRequest"):
        """
        Lists payments with optional filters and pagination

        # Arguments

        * `list_payments_request` - The request to list payments

        # Returns

        A vector of payments or a `StorageError`
        """

        raise NotImplementedError
    def insert_payment(self, payment: "Payment"):
        """
        Inserts a payment into storage

        # Arguments

        * `payment` - The payment to insert

        # Returns

        Success or a `StorageError`
        """

        raise NotImplementedError
    def set_payment_metadata(self, payment_id: "str",metadata: "PaymentMetadata"):
        """
        Inserts payment metadata into storage

        # Arguments

        * `payment_id` - The ID of the payment
        * `metadata` - The metadata to insert

        # Returns

        Success or a `StorageError`
        """

        raise NotImplementedError
    def get_payment_by_id(self, id: "str"):
        """
        Gets a payment by its ID
        # Arguments

        * `id` - The ID of the payment to retrieve

        # Returns

        The payment if found or None if not found
        """

        raise NotImplementedError
    def get_payment_by_invoice(self, invoice: "str"):
        """
        Gets a payment by its invoice
        # Arguments

        * `invoice` - The invoice of the payment to retrieve
        # Returns

        The payment if found or None if not found
        """

        raise NotImplementedError
    def add_deposit(self, txid: "str",vout: "int",amount_sats: "int"):
        """
        Add a deposit to storage
        # Arguments

        * `txid` - The transaction ID of the deposit
        * `vout` - The output index of the deposit
        * `amount_sats` - The amount of the deposit in sats

        # Returns

        Success or a `StorageError`
        """

        raise NotImplementedError
    def delete_deposit(self, txid: "str",vout: "int"):
        """
        Removes an unclaimed deposit from storage
        # Arguments

        * `txid` - The transaction ID of the deposit
        * `vout` - The output index of the deposit

        # Returns

        Success or a `StorageError`
        """

        raise NotImplementedError
    def list_deposits(self, ):
        """
        Lists all unclaimed deposits from storage
        # Returns

        A vector of `DepositInfo` or a `StorageError`
        """

        raise NotImplementedError
    def update_deposit(self, txid: "str",vout: "int",payload: "UpdateDepositPayload"):
        """
        Updates or inserts unclaimed deposit details
        # Arguments

        * `txid` - The transaction ID of the deposit
        * `vout` - The output index of the deposit
        * `payload` - The payload for the update

        # Returns

        Success or a `StorageError`
        """

        raise NotImplementedError
    def set_lnurl_metadata(self, metadata: "typing.List[SetLnurlMetadataItem]"):
        raise NotImplementedError


class StorageImpl:
    """
    Trait for persistent storage
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_storage, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_storage, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def delete_cached_item(self, key: "str") -> None:

        _UniffiConverterString.check_lower(key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(key)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def get_cached_item(self, key: "str") -> "typing.Optional[str]":
        _UniffiConverterString.check_lower(key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(key)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalString.lift,
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def set_cached_item(self, key: "str",value: "str") -> None:

        _UniffiConverterString.check_lower(key)
        
        _UniffiConverterString.check_lower(value)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(key),
        _UniffiConverterString.lower(value)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def list_payments(self, request: "ListPaymentsRequest") -> "typing.List[Payment]":
        """
        Lists payments with optional filters and pagination

        # Arguments

        * `list_payments_request` - The request to list payments

        # Returns

        A vector of payments or a `StorageError`
        """

        _UniffiConverterTypeListPaymentsRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_list_payments(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeListPaymentsRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypePayment.lift,
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def insert_payment(self, payment: "Payment") -> None:

        """
        Inserts a payment into storage

        # Arguments

        * `payment` - The payment to insert

        # Returns

        Success or a `StorageError`
        """

        _UniffiConverterTypePayment.check_lower(payment)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePayment.lower(payment)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def set_payment_metadata(self, payment_id: "str",metadata: "PaymentMetadata") -> None:

        """
        Inserts payment metadata into storage

        # Arguments

        * `payment_id` - The ID of the payment
        * `metadata` - The metadata to insert

        # Returns

        Success or a `StorageError`
        """

        _UniffiConverterString.check_lower(payment_id)
        
        _UniffiConverterTypePaymentMetadata.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(payment_id),
        _UniffiConverterTypePaymentMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def get_payment_by_id(self, id: "str") -> "Payment":
        """
        Gets a payment by its ID
        # Arguments

        * `id` - The ID of the payment to retrieve

        # Returns

        The payment if found or None if not found
        """

        _UniffiConverterString.check_lower(id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePayment.lift,
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def get_payment_by_invoice(self, invoice: "str") -> "typing.Optional[Payment]":
        """
        Gets a payment by its invoice
        # Arguments

        * `invoice` - The invoice of the payment to retrieve
        # Returns

        The payment if found or None if not found
        """

        _UniffiConverterString.check_lower(invoice)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(invoice)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypePayment.lift,
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def add_deposit(self, txid: "str",vout: "int",amount_sats: "int") -> None:

        """
        Add a deposit to storage
        # Arguments

        * `txid` - The transaction ID of the deposit
        * `vout` - The output index of the deposit
        * `amount_sats` - The amount of the deposit in sats

        # Returns

        Success or a `StorageError`
        """

        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterUInt32.check_lower(vout)
        
        _UniffiConverterUInt64.check_lower(amount_sats)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(txid),
        _UniffiConverterUInt32.lower(vout),
        _UniffiConverterUInt64.lower(amount_sats)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def delete_deposit(self, txid: "str",vout: "int") -> None:

        """
        Removes an unclaimed deposit from storage
        # Arguments

        * `txid` - The transaction ID of the deposit
        * `vout` - The output index of the deposit

        # Returns

        Success or a `StorageError`
        """

        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterUInt32.check_lower(vout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(txid),
        _UniffiConverterUInt32.lower(vout)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def list_deposits(self, ) -> "typing.List[DepositInfo]":
        """
        Lists all unclaimed deposits from storage
        # Returns

        A vector of `DepositInfo` or a `StorageError`
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeDepositInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def update_deposit(self, txid: "str",vout: "int",payload: "UpdateDepositPayload") -> None:

        """
        Updates or inserts unclaimed deposit details
        # Arguments

        * `txid` - The transaction ID of the deposit
        * `vout` - The output index of the deposit
        * `payload` - The payload for the update

        # Returns

        Success or a `StorageError`
        """

        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterUInt32.check_lower(vout)
        
        _UniffiConverterTypeUpdateDepositPayload.check_lower(payload)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(txid),
        _UniffiConverterUInt32.lower(vout),
        _UniffiConverterTypeUpdateDepositPayload.lower(payload)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )



    async def set_lnurl_metadata(self, metadata: "typing.List[SetLnurlMetadataItem]") -> None:

        _UniffiConverterSequenceTypeSetLnurlMetadataItem.check_lower(metadata)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeSetLnurlMetadataItem.lower(metadata)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeStorageError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplStorage:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD0
    def delete_cached_item(
            uniffi_handle,
            key,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(key), )
            method = uniffi_obj.delete_cached_item
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD1
    def get_cached_item(
            uniffi_handle,
            key,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(key), )
            method = uniffi_obj.get_cached_item
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD2
    def set_cached_item(
            uniffi_handle,
            key,
            value,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(key), _UniffiConverterString.lift(value), )
            method = uniffi_obj.set_cached_item
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD3
    def list_payments(
            uniffi_handle,
            request,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeListPaymentsRequest.lift(request), )
            method = uniffi_obj.list_payments
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypePayment.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD4
    def insert_payment(
            uniffi_handle,
            payment,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypePayment.lift(payment), )
            method = uniffi_obj.insert_payment
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD5
    def set_payment_metadata(
            uniffi_handle,
            payment_id,
            metadata,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(payment_id), _UniffiConverterTypePaymentMetadata.lift(metadata), )
            method = uniffi_obj.set_payment_metadata
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD6
    def get_payment_by_id(
            uniffi_handle,
            id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(id), )
            method = uniffi_obj.get_payment_by_id
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePayment.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD7
    def get_payment_by_invoice(
            uniffi_handle,
            invoice,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(invoice), )
            method = uniffi_obj.get_payment_by_invoice
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypePayment.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD8
    def add_deposit(
            uniffi_handle,
            txid,
            vout,
            amount_sats,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(txid), _UniffiConverterUInt32.lift(vout), _UniffiConverterUInt64.lift(amount_sats), )
            method = uniffi_obj.add_deposit
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD9
    def delete_deposit(
            uniffi_handle,
            txid,
            vout,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(txid), _UniffiConverterUInt32.lift(vout), )
            method = uniffi_obj.delete_deposit
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD10
    def list_deposits(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.list_deposits
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeDepositInfo.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD11
    def update_deposit(
            uniffi_handle,
            txid,
            vout,
            payload,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(txid), _UniffiConverterUInt32.lift(vout), _UniffiConverterTypeUpdateDepositPayload.lift(payload), )
            method = uniffi_obj.update_deposit
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_STORAGE_METHOD12
    def set_lnurl_metadata(
            uniffi_handle,
            metadata,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterSequenceTypeSetLnurlMetadataItem.lift(metadata), )
            method = uniffi_obj.set_lnurl_metadata
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, StorageError, _UniffiConverterTypeStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeStorage._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceStorage(
        delete_cached_item,
        get_cached_item,
        set_cached_item,
        list_payments,
        insert_payment,
        set_payment_metadata,
        get_payment_by_id,
        get_payment_by_invoice,
        add_deposit,
        delete_deposit,
        list_deposits,
        update_deposit,
        set_lnurl_metadata,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeStorage:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return StorageImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: Storage):
        pass

    @staticmethod
    def lower(value: Storage):
        return _UniffiConverterTypeStorage._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Storage, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SyncStorage(typing.Protocol):
    def add_outgoing_change(self, record: "UnversionedRecordChange"):
        raise NotImplementedError
    def complete_outgoing_sync(self, record: "Record"):
        raise NotImplementedError
    def get_pending_outgoing_changes(self, limit: "int"):
        raise NotImplementedError
    def get_last_revision(self, ):
        """
        Get the revision number of the last synchronized record
        """

        raise NotImplementedError
    def insert_incoming_records(self, records: "typing.List[Record]"):
        """
        Insert incoming records from remote sync
        """

        raise NotImplementedError
    def delete_incoming_record(self, record: "Record"):
        """
        Delete an incoming record after it has been processed
        """

        raise NotImplementedError
    def rebase_pending_outgoing_records(self, revision: "int"):
        """
        Update revision numbers of pending outgoing records to be higher than the given revision
        """

        raise NotImplementedError
    def get_incoming_records(self, limit: "int"):
        """
        Get incoming records that need to be processed, up to the specified limit
        """

        raise NotImplementedError
    def get_latest_outgoing_change(self, ):
        """
        Get the latest outgoing record if any exists
        """

        raise NotImplementedError
    def update_record_from_incoming(self, record: "Record"):
        """
        Update the sync state record from an incoming record
        """

        raise NotImplementedError


class SyncStorageImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_syncstorage, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_syncstorage, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def add_outgoing_change(self, record: "UnversionedRecordChange") -> "int":
        _UniffiConverterTypeUnversionedRecordChange.check_lower(record)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeUnversionedRecordChange.lower(record)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u64,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u64,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def complete_outgoing_sync(self, record: "Record") -> None:

        _UniffiConverterTypeRecord.check_lower(record)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRecord.lower(record)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def get_pending_outgoing_changes(self, limit: "int") -> "typing.List[OutgoingChange]":
        _UniffiConverterUInt32.check_lower(limit)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt32.lower(limit)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeOutgoingChange.lift,
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def get_last_revision(self, ) -> "int":
        """
        Get the revision number of the last synchronized record
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_u64,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_u64,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def insert_incoming_records(self, records: "typing.List[Record]") -> None:

        """
        Insert incoming records from remote sync
        """

        _UniffiConverterSequenceTypeRecord.check_lower(records)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeRecord.lower(records)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def delete_incoming_record(self, record: "Record") -> None:

        """
        Delete an incoming record after it has been processed
        """

        _UniffiConverterTypeRecord.check_lower(record)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRecord.lower(record)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def rebase_pending_outgoing_records(self, revision: "int") -> None:

        """
        Update revision numbers of pending outgoing records to be higher than the given revision
        """

        _UniffiConverterUInt64.check_lower(revision)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(revision)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def get_incoming_records(self, limit: "int") -> "typing.List[IncomingChange]":
        """
        Get incoming records that need to be processed, up to the specified limit
        """

        _UniffiConverterUInt32.check_lower(limit)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt32.lower(limit)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeIncomingChange.lift,
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def get_latest_outgoing_change(self, ) -> "typing.Optional[OutgoingChange]":
        """
        Get the latest outgoing record if any exists
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeOutgoingChange.lift,
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )



    async def update_record_from_incoming(self, record: "Record") -> None:

        """
        Update the sync state record from an incoming record
        """

        _UniffiConverterTypeRecord.check_lower(record)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRecord.lower(record)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_void,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSyncStorageError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplSyncStorage:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD0
    def add_outgoing_change(
            uniffi_handle,
            record,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeUnversionedRecordChange.lift(record), )
            method = uniffi_obj.add_outgoing_change
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructU64(
                    _UniffiConverterUInt64.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructU64(
                    0,
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD1
    def complete_outgoing_sync(
            uniffi_handle,
            record,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeRecord.lift(record), )
            method = uniffi_obj.complete_outgoing_sync
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD2
    def get_pending_outgoing_changes(
            uniffi_handle,
            limit,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt32.lift(limit), )
            method = uniffi_obj.get_pending_outgoing_changes
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeOutgoingChange.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD3
    def get_last_revision(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_last_revision
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructU64(
                    _UniffiConverterUInt64.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructU64(
                    0,
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD4
    def insert_incoming_records(
            uniffi_handle,
            records,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterSequenceTypeRecord.lift(records), )
            method = uniffi_obj.insert_incoming_records
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD5
    def delete_incoming_record(
            uniffi_handle,
            record,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeRecord.lift(record), )
            method = uniffi_obj.delete_incoming_record
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD6
    def rebase_pending_outgoing_records(
            uniffi_handle,
            revision,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(revision), )
            method = uniffi_obj.rebase_pending_outgoing_records
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD7
    def get_incoming_records(
            uniffi_handle,
            limit,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt32.lift(limit), )
            method = uniffi_obj.get_incoming_records
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeIncomingChange.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD8
    def get_latest_outgoing_change(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_latest_outgoing_change
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterOptionalTypeOutgoingChange.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_STORAGE_METHOD9
    def update_record_from_incoming(
            uniffi_handle,
            record,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSyncStorage._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeRecord.lift(record), )
            method = uniffi_obj.update_record_from_incoming
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, SyncStorageError, _UniffiConverterTypeSyncStorageError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeSyncStorage._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceSyncStorage(
        add_outgoing_change,
        complete_outgoing_sync,
        get_pending_outgoing_changes,
        get_last_revision,
        insert_incoming_records,
        delete_incoming_record,
        rebase_pending_outgoing_records,
        get_incoming_records,
        get_latest_outgoing_change,
        update_record_from_incoming,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeSyncStorage:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return SyncStorageImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: SyncStorage):
        pass

    @staticmethod
    def lower(value: SyncStorage):
        return _UniffiConverterTypeSyncStorage._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SyncStorage, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TokenIssuerProtocol(typing.Protocol):
    def burn_issuer_token(self, request: "BurnIssuerTokenRequest"):
        """
        Burns supply of the issuer token

        # Arguments

        * `request`: The request containing the amount of the supply to burn

        # Returns

        Result containing either:
        * `Payment` - The payment representing the burn transaction
        * `SdkError` - If there was an error during the burn process
        """

        raise NotImplementedError
    def create_issuer_token(self, request: "CreateIssuerTokenRequest"):
        """
        Creates a new issuer token

        # Arguments

        * `request`: The request containing the token parameters

        # Returns

        Result containing either:
        * `TokenMetadata` - The metadata of the created token
        * `SdkError` - If there was an error during the token creation
        """

        raise NotImplementedError
    def freeze_issuer_token(self, request: "FreezeIssuerTokenRequest"):
        """
        Freezes tokens held at the specified address

        # Arguments

        * `request`: The request containing the spark address where the tokens to be frozen are held

        # Returns

        Result containing either:
        * `FreezeIssuerTokenResponse` - The response containing details of the freeze operation
        * `SdkError` - If there was an error during the freeze process
        """

        raise NotImplementedError
    def get_issuer_token_balance(self, ):
        """
        Gets the issuer token balance

        # Returns

        Result containing either:
        * `TokenBalance` - The balance of the issuer token
        * `SdkError` - If there was an error during the retrieval or no issuer token exists
        """

        raise NotImplementedError
    def get_issuer_token_metadata(self, ):
        """
        Gets the issuer token metadata

        # Returns

        Result containing either:
        * `TokenMetadata` - The metadata of the issuer token
        * `SdkError` - If there was an error during the retrieval or no issuer token exists
        """

        raise NotImplementedError
    def mint_issuer_token(self, request: "MintIssuerTokenRequest"):
        """
        Mints supply for the issuer token

        # Arguments

        * `request`: The request contiaining the amount of the supply to mint

        # Returns

        Result containing either:
        * `Payment` - The payment representing the minting transaction
        * `SdkError` - If there was an error during the minting process
        """

        raise NotImplementedError
    def unfreeze_issuer_token(self, request: "UnfreezeIssuerTokenRequest"):
        """
        Unfreezes tokens held at the specified address

        # Arguments

        * `request`: The request containing the spark address where the tokens to be unfrozen are held

        # Returns

        Result containing either:
        * `UnfreezeIssuerTokenResponse` - The response containing details of the unfreeze operation
        * `SdkError` - If there was an error during the unfreeze process
        """

        raise NotImplementedError


class TokenIssuer:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_free_tokenissuer, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_clone_tokenissuer, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def burn_issuer_token(self, request: "BurnIssuerTokenRequest") -> "Payment":
        """
        Burns supply of the issuer token

        # Arguments

        * `request`: The request containing the amount of the supply to burn

        # Returns

        Result containing either:
        * `Payment` - The payment representing the burn transaction
        * `SdkError` - If there was an error during the burn process
        """

        _UniffiConverterTypeBurnIssuerTokenRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeBurnIssuerTokenRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePayment.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def create_issuer_token(self, request: "CreateIssuerTokenRequest") -> "TokenMetadata":
        """
        Creates a new issuer token

        # Arguments

        * `request`: The request containing the token parameters

        # Returns

        Result containing either:
        * `TokenMetadata` - The metadata of the created token
        * `SdkError` - If there was an error during the token creation
        """

        _UniffiConverterTypeCreateIssuerTokenRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeCreateIssuerTokenRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTokenMetadata.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def freeze_issuer_token(self, request: "FreezeIssuerTokenRequest") -> "FreezeIssuerTokenResponse":
        """
        Freezes tokens held at the specified address

        # Arguments

        * `request`: The request containing the spark address where the tokens to be frozen are held

        # Returns

        Result containing either:
        * `FreezeIssuerTokenResponse` - The response containing details of the freeze operation
        * `SdkError` - If there was an error during the freeze process
        """

        _UniffiConverterTypeFreezeIssuerTokenRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFreezeIssuerTokenRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFreezeIssuerTokenResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def get_issuer_token_balance(self, ) -> "TokenBalance":
        """
        Gets the issuer token balance

        # Returns

        Result containing either:
        * `TokenBalance` - The balance of the issuer token
        * `SdkError` - If there was an error during the retrieval or no issuer token exists
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTokenBalance.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def get_issuer_token_metadata(self, ) -> "TokenMetadata":
        """
        Gets the issuer token metadata

        # Returns

        Result containing either:
        * `TokenMetadata` - The metadata of the issuer token
        * `SdkError` - If there was an error during the retrieval or no issuer token exists
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTokenMetadata.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def mint_issuer_token(self, request: "MintIssuerTokenRequest") -> "Payment":
        """
        Mints supply for the issuer token

        # Arguments

        * `request`: The request contiaining the amount of the supply to mint

        # Returns

        Result containing either:
        * `Payment` - The payment representing the minting transaction
        * `SdkError` - If there was an error during the minting process
        """

        _UniffiConverterTypeMintIssuerTokenRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeMintIssuerTokenRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePayment.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )



    async def unfreeze_issuer_token(self, request: "UnfreezeIssuerTokenRequest") -> "UnfreezeIssuerTokenResponse":
        """
        Unfreezes tokens held at the specified address

        # Arguments

        * `request`: The request containing the spark address where the tokens to be unfrozen are held

        # Returns

        Result containing either:
        * `UnfreezeIssuerTokenResponse` - The response containing details of the unfreeze operation
        * `SdkError` - If there was an error during the unfreeze process
        """

        _UniffiConverterTypeUnfreezeIssuerTokenRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeUnfreezeIssuerTokenRequest.lower(request)
            ),
            _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeUnfreezeIssuerTokenResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkError,

        )





class _UniffiConverterTypeTokenIssuer:

    @staticmethod
    def lift(value: int):
        return TokenIssuer._make_instance_(value)

    @staticmethod
    def check_lower(value: TokenIssuer):
        if not isinstance(value, TokenIssuer):
            raise TypeError("Expected TokenIssuer instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TokenIssuerProtocol):
        if not isinstance(value, TokenIssuer):
            raise TypeError("Expected TokenIssuer instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TokenIssuerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class AesSuccessActionData:
    """
    Payload of the AES success action, as received from the LNURL endpoint

    See [`AesSuccessActionDataDecrypted`] for a similar wrapper containing the decrypted payload
    """

    description: "str"
    """
    Contents description, up to 144 characters
    """

    ciphertext: "str"
    """
    Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
    """

    iv: "str"
    """
    Base64, initialization vector, exactly 24 characters
    """

    def __init__(self, *, description: "str", ciphertext: "str", iv: "str"):
        self.description = description
        self.ciphertext = ciphertext
        self.iv = iv

    def __str__(self):
        return "AesSuccessActionData(description={}, ciphertext={}, iv={})".format(self.description, self.ciphertext, self.iv)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.ciphertext != other.ciphertext:
            return False
        if self.iv != other.iv:
            return False
        return True

class _UniffiConverterTypeAesSuccessActionData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AesSuccessActionData(
            description=_UniffiConverterString.read(buf),
            ciphertext=_UniffiConverterString.read(buf),
            iv=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.ciphertext)
        _UniffiConverterString.check_lower(value.iv)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterString.write(value.ciphertext, buf)
        _UniffiConverterString.write(value.iv, buf)


class AesSuccessActionDataDecrypted:
    """
    Wrapper for the decrypted [`AesSuccessActionData`] payload
    """

    description: "str"
    """
    Contents description, up to 144 characters
    """

    plaintext: "str"
    """
    Decrypted content
    """

    def __init__(self, *, description: "str", plaintext: "str"):
        self.description = description
        self.plaintext = plaintext

    def __str__(self):
        return "AesSuccessActionDataDecrypted(description={}, plaintext={})".format(self.description, self.plaintext)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.plaintext != other.plaintext:
            return False
        return True

class _UniffiConverterTypeAesSuccessActionDataDecrypted(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AesSuccessActionDataDecrypted(
            description=_UniffiConverterString.read(buf),
            plaintext=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.plaintext)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterString.write(value.plaintext, buf)


class Bip21Details:
    amount_sat: "typing.Optional[int]"
    asset_id: "typing.Optional[str]"
    uri: "str"
    extras: "typing.List[Bip21Extra]"
    label: "typing.Optional[str]"
    message: "typing.Optional[str]"
    payment_methods: "typing.List[InputType]"
    def __init__(self, *, amount_sat: "typing.Optional[int]", asset_id: "typing.Optional[str]", uri: "str", extras: "typing.List[Bip21Extra]", label: "typing.Optional[str]", message: "typing.Optional[str]", payment_methods: "typing.List[InputType]"):
        self.amount_sat = amount_sat
        self.asset_id = asset_id
        self.uri = uri
        self.extras = extras
        self.label = label
        self.message = message
        self.payment_methods = payment_methods

    def __str__(self):
        return "Bip21Details(amount_sat={}, asset_id={}, uri={}, extras={}, label={}, message={}, payment_methods={})".format(self.amount_sat, self.asset_id, self.uri, self.extras, self.label, self.message, self.payment_methods)

    def __eq__(self, other):
        if self.amount_sat != other.amount_sat:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.uri != other.uri:
            return False
        if self.extras != other.extras:
            return False
        if self.label != other.label:
            return False
        if self.message != other.message:
            return False
        if self.payment_methods != other.payment_methods:
            return False
        return True

class _UniffiConverterTypeBip21Details(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bip21Details(
            amount_sat=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterOptionalString.read(buf),
            uri=_UniffiConverterString.read(buf),
            extras=_UniffiConverterSequenceTypeBip21Extra.read(buf),
            label=_UniffiConverterOptionalString.read(buf),
            message=_UniffiConverterOptionalString.read(buf),
            payment_methods=_UniffiConverterSequenceTypeInputType.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.amount_sat)
        _UniffiConverterOptionalString.check_lower(value.asset_id)
        _UniffiConverterString.check_lower(value.uri)
        _UniffiConverterSequenceTypeBip21Extra.check_lower(value.extras)
        _UniffiConverterOptionalString.check_lower(value.label)
        _UniffiConverterOptionalString.check_lower(value.message)
        _UniffiConverterSequenceTypeInputType.check_lower(value.payment_methods)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.amount_sat, buf)
        _UniffiConverterOptionalString.write(value.asset_id, buf)
        _UniffiConverterString.write(value.uri, buf)
        _UniffiConverterSequenceTypeBip21Extra.write(value.extras, buf)
        _UniffiConverterOptionalString.write(value.label, buf)
        _UniffiConverterOptionalString.write(value.message, buf)
        _UniffiConverterSequenceTypeInputType.write(value.payment_methods, buf)


class Bip21Extra:
    key: "str"
    value: "str"
    def __init__(self, *, key: "str", value: "str"):
        self.key = key
        self.value = value

    def __str__(self):
        return "Bip21Extra(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeBip21Extra(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bip21Extra(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.key)
        _UniffiConverterString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterString.write(value.value, buf)


class BitcoinAddressDetails:
    address: "str"
    network: "BitcoinNetwork"
    source: "PaymentRequestSource"
    def __init__(self, *, address: "str", network: "BitcoinNetwork", source: "PaymentRequestSource"):
        self.address = address
        self.network = network
        self.source = source

    def __str__(self):
        return "BitcoinAddressDetails(address={}, network={}, source={})".format(self.address, self.network, self.source)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.network != other.network:
            return False
        if self.source != other.source:
            return False
        return True

class _UniffiConverterTypeBitcoinAddressDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BitcoinAddressDetails(
            address=_UniffiConverterString.read(buf),
            network=_UniffiConverterTypeBitcoinNetwork.read(buf),
            source=_UniffiConverterTypePaymentRequestSource.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterTypeBitcoinNetwork.check_lower(value.network)
        _UniffiConverterTypePaymentRequestSource.check_lower(value.source)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterTypeBitcoinNetwork.write(value.network, buf)
        _UniffiConverterTypePaymentRequestSource.write(value.source, buf)


class Bolt11Invoice:
    bolt11: "str"
    source: "PaymentRequestSource"
    def __init__(self, *, bolt11: "str", source: "PaymentRequestSource"):
        self.bolt11 = bolt11
        self.source = source

    def __str__(self):
        return "Bolt11Invoice(bolt11={}, source={})".format(self.bolt11, self.source)

    def __eq__(self, other):
        if self.bolt11 != other.bolt11:
            return False
        if self.source != other.source:
            return False
        return True

class _UniffiConverterTypeBolt11Invoice(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt11Invoice(
            bolt11=_UniffiConverterString.read(buf),
            source=_UniffiConverterTypePaymentRequestSource.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.bolt11)
        _UniffiConverterTypePaymentRequestSource.check_lower(value.source)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.bolt11, buf)
        _UniffiConverterTypePaymentRequestSource.write(value.source, buf)


class Bolt11InvoiceDetails:
    amount_msat: "typing.Optional[int]"
    description: "typing.Optional[str]"
    description_hash: "typing.Optional[str]"
    expiry: "int"
    invoice: "Bolt11Invoice"
    min_final_cltv_expiry_delta: "int"
    network: "BitcoinNetwork"
    payee_pubkey: "str"
    payment_hash: "str"
    payment_secret: "str"
    routing_hints: "typing.List[Bolt11RouteHint]"
    timestamp: "int"
    def __init__(self, *, amount_msat: "typing.Optional[int]", description: "typing.Optional[str]", description_hash: "typing.Optional[str]", expiry: "int", invoice: "Bolt11Invoice", min_final_cltv_expiry_delta: "int", network: "BitcoinNetwork", payee_pubkey: "str", payment_hash: "str", payment_secret: "str", routing_hints: "typing.List[Bolt11RouteHint]", timestamp: "int"):
        self.amount_msat = amount_msat
        self.description = description
        self.description_hash = description_hash
        self.expiry = expiry
        self.invoice = invoice
        self.min_final_cltv_expiry_delta = min_final_cltv_expiry_delta
        self.network = network
        self.payee_pubkey = payee_pubkey
        self.payment_hash = payment_hash
        self.payment_secret = payment_secret
        self.routing_hints = routing_hints
        self.timestamp = timestamp

    def __str__(self):
        return "Bolt11InvoiceDetails(amount_msat={}, description={}, description_hash={}, expiry={}, invoice={}, min_final_cltv_expiry_delta={}, network={}, payee_pubkey={}, payment_hash={}, payment_secret={}, routing_hints={}, timestamp={})".format(self.amount_msat, self.description, self.description_hash, self.expiry, self.invoice, self.min_final_cltv_expiry_delta, self.network, self.payee_pubkey, self.payment_hash, self.payment_secret, self.routing_hints, self.timestamp)

    def __eq__(self, other):
        if self.amount_msat != other.amount_msat:
            return False
        if self.description != other.description:
            return False
        if self.description_hash != other.description_hash:
            return False
        if self.expiry != other.expiry:
            return False
        if self.invoice != other.invoice:
            return False
        if self.min_final_cltv_expiry_delta != other.min_final_cltv_expiry_delta:
            return False
        if self.network != other.network:
            return False
        if self.payee_pubkey != other.payee_pubkey:
            return False
        if self.payment_hash != other.payment_hash:
            return False
        if self.payment_secret != other.payment_secret:
            return False
        if self.routing_hints != other.routing_hints:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class _UniffiConverterTypeBolt11InvoiceDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt11InvoiceDetails(
            amount_msat=_UniffiConverterOptionalUInt64.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            description_hash=_UniffiConverterOptionalString.read(buf),
            expiry=_UniffiConverterUInt64.read(buf),
            invoice=_UniffiConverterTypeBolt11Invoice.read(buf),
            min_final_cltv_expiry_delta=_UniffiConverterUInt64.read(buf),
            network=_UniffiConverterTypeBitcoinNetwork.read(buf),
            payee_pubkey=_UniffiConverterString.read(buf),
            payment_hash=_UniffiConverterString.read(buf),
            payment_secret=_UniffiConverterString.read(buf),
            routing_hints=_UniffiConverterSequenceTypeBolt11RouteHint.read(buf),
            timestamp=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.amount_msat)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.description_hash)
        _UniffiConverterUInt64.check_lower(value.expiry)
        _UniffiConverterTypeBolt11Invoice.check_lower(value.invoice)
        _UniffiConverterUInt64.check_lower(value.min_final_cltv_expiry_delta)
        _UniffiConverterTypeBitcoinNetwork.check_lower(value.network)
        _UniffiConverterString.check_lower(value.payee_pubkey)
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterString.check_lower(value.payment_secret)
        _UniffiConverterSequenceTypeBolt11RouteHint.check_lower(value.routing_hints)
        _UniffiConverterUInt64.check_lower(value.timestamp)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.amount_msat, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.description_hash, buf)
        _UniffiConverterUInt64.write(value.expiry, buf)
        _UniffiConverterTypeBolt11Invoice.write(value.invoice, buf)
        _UniffiConverterUInt64.write(value.min_final_cltv_expiry_delta, buf)
        _UniffiConverterTypeBitcoinNetwork.write(value.network, buf)
        _UniffiConverterString.write(value.payee_pubkey, buf)
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterString.write(value.payment_secret, buf)
        _UniffiConverterSequenceTypeBolt11RouteHint.write(value.routing_hints, buf)
        _UniffiConverterUInt64.write(value.timestamp, buf)


class Bolt11RouteHint:
    hops: "typing.List[Bolt11RouteHintHop]"
    def __init__(self, *, hops: "typing.List[Bolt11RouteHintHop]"):
        self.hops = hops

    def __str__(self):
        return "Bolt11RouteHint(hops={})".format(self.hops)

    def __eq__(self, other):
        if self.hops != other.hops:
            return False
        return True

class _UniffiConverterTypeBolt11RouteHint(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt11RouteHint(
            hops=_UniffiConverterSequenceTypeBolt11RouteHintHop.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeBolt11RouteHintHop.check_lower(value.hops)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeBolt11RouteHintHop.write(value.hops, buf)


class Bolt11RouteHintHop:
    src_node_id: "str"
    """
    The `node_id` of the non-target end of the route
    """

    short_channel_id: "str"
    """
    The `short_channel_id` of this channel
    """

    fees_base_msat: "int"
    """
    The fees which must be paid to use this channel
    """

    fees_proportional_millionths: "int"
    cltv_expiry_delta: "int"
    """
    The difference in CLTV values between this node and the next node.
    """

    htlc_minimum_msat: "typing.Optional[int]"
    """
    The minimum value, in msat, which must be relayed to the next hop.
    """

    htlc_maximum_msat: "typing.Optional[int]"
    """
    The maximum value in msat available for routing with a single HTLC.
    """

    def __init__(self, *, src_node_id: "str", short_channel_id: "str", fees_base_msat: "int", fees_proportional_millionths: "int", cltv_expiry_delta: "int", htlc_minimum_msat: "typing.Optional[int]", htlc_maximum_msat: "typing.Optional[int]"):
        self.src_node_id = src_node_id
        self.short_channel_id = short_channel_id
        self.fees_base_msat = fees_base_msat
        self.fees_proportional_millionths = fees_proportional_millionths
        self.cltv_expiry_delta = cltv_expiry_delta
        self.htlc_minimum_msat = htlc_minimum_msat
        self.htlc_maximum_msat = htlc_maximum_msat

    def __str__(self):
        return "Bolt11RouteHintHop(src_node_id={}, short_channel_id={}, fees_base_msat={}, fees_proportional_millionths={}, cltv_expiry_delta={}, htlc_minimum_msat={}, htlc_maximum_msat={})".format(self.src_node_id, self.short_channel_id, self.fees_base_msat, self.fees_proportional_millionths, self.cltv_expiry_delta, self.htlc_minimum_msat, self.htlc_maximum_msat)

    def __eq__(self, other):
        if self.src_node_id != other.src_node_id:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.fees_base_msat != other.fees_base_msat:
            return False
        if self.fees_proportional_millionths != other.fees_proportional_millionths:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.htlc_minimum_msat != other.htlc_minimum_msat:
            return False
        if self.htlc_maximum_msat != other.htlc_maximum_msat:
            return False
        return True

class _UniffiConverterTypeBolt11RouteHintHop(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt11RouteHintHop(
            src_node_id=_UniffiConverterString.read(buf),
            short_channel_id=_UniffiConverterString.read(buf),
            fees_base_msat=_UniffiConverterUInt32.read(buf),
            fees_proportional_millionths=_UniffiConverterUInt32.read(buf),
            cltv_expiry_delta=_UniffiConverterUInt16.read(buf),
            htlc_minimum_msat=_UniffiConverterOptionalUInt64.read(buf),
            htlc_maximum_msat=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.src_node_id)
        _UniffiConverterString.check_lower(value.short_channel_id)
        _UniffiConverterUInt32.check_lower(value.fees_base_msat)
        _UniffiConverterUInt32.check_lower(value.fees_proportional_millionths)
        _UniffiConverterUInt16.check_lower(value.cltv_expiry_delta)
        _UniffiConverterOptionalUInt64.check_lower(value.htlc_minimum_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.htlc_maximum_msat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.src_node_id, buf)
        _UniffiConverterString.write(value.short_channel_id, buf)
        _UniffiConverterUInt32.write(value.fees_base_msat, buf)
        _UniffiConverterUInt32.write(value.fees_proportional_millionths, buf)
        _UniffiConverterUInt16.write(value.cltv_expiry_delta, buf)
        _UniffiConverterOptionalUInt64.write(value.htlc_minimum_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.htlc_maximum_msat, buf)


class Bolt12Invoice:
    invoice: "str"
    source: "PaymentRequestSource"
    def __init__(self, *, invoice: "str", source: "PaymentRequestSource"):
        self.invoice = invoice
        self.source = source

    def __str__(self):
        return "Bolt12Invoice(invoice={}, source={})".format(self.invoice, self.source)

    def __eq__(self, other):
        if self.invoice != other.invoice:
            return False
        if self.source != other.source:
            return False
        return True

class _UniffiConverterTypeBolt12Invoice(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt12Invoice(
            invoice=_UniffiConverterString.read(buf),
            source=_UniffiConverterTypePaymentRequestSource.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.invoice)
        _UniffiConverterTypePaymentRequestSource.check_lower(value.source)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.invoice, buf)
        _UniffiConverterTypePaymentRequestSource.write(value.source, buf)


class Bolt12InvoiceDetails:
    amount_msat: "int"
    invoice: "Bolt12Invoice"
    def __init__(self, *, amount_msat: "int", invoice: "Bolt12Invoice"):
        self.amount_msat = amount_msat
        self.invoice = invoice

    def __str__(self):
        return "Bolt12InvoiceDetails(amount_msat={}, invoice={})".format(self.amount_msat, self.invoice)

    def __eq__(self, other):
        if self.amount_msat != other.amount_msat:
            return False
        if self.invoice != other.invoice:
            return False
        return True

class _UniffiConverterTypeBolt12InvoiceDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt12InvoiceDetails(
            amount_msat=_UniffiConverterUInt64.read(buf),
            invoice=_UniffiConverterTypeBolt12Invoice.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterTypeBolt12Invoice.check_lower(value.invoice)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterTypeBolt12Invoice.write(value.invoice, buf)


class Bolt12InvoiceRequestDetails:

    def __str__(self):
        return "Bolt12InvoiceRequestDetails()".format()

    def __eq__(self, other):
        return True

class _UniffiConverterTypeBolt12InvoiceRequestDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt12InvoiceRequestDetails(
        )

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        pass


class Bolt12Offer:
    offer: "str"
    source: "PaymentRequestSource"
    def __init__(self, *, offer: "str", source: "PaymentRequestSource"):
        self.offer = offer
        self.source = source

    def __str__(self):
        return "Bolt12Offer(offer={}, source={})".format(self.offer, self.source)

    def __eq__(self, other):
        if self.offer != other.offer:
            return False
        if self.source != other.source:
            return False
        return True

class _UniffiConverterTypeBolt12Offer(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt12Offer(
            offer=_UniffiConverterString.read(buf),
            source=_UniffiConverterTypePaymentRequestSource.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.offer)
        _UniffiConverterTypePaymentRequestSource.check_lower(value.source)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.offer, buf)
        _UniffiConverterTypePaymentRequestSource.write(value.source, buf)


class Bolt12OfferBlindedPath:
    blinded_hops: "typing.List[str]"
    def __init__(self, *, blinded_hops: "typing.List[str]"):
        self.blinded_hops = blinded_hops

    def __str__(self):
        return "Bolt12OfferBlindedPath(blinded_hops={})".format(self.blinded_hops)

    def __eq__(self, other):
        if self.blinded_hops != other.blinded_hops:
            return False
        return True

class _UniffiConverterTypeBolt12OfferBlindedPath(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt12OfferBlindedPath(
            blinded_hops=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceString.check_lower(value.blinded_hops)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceString.write(value.blinded_hops, buf)


class Bolt12OfferDetails:
    absolute_expiry: "typing.Optional[int]"
    chains: "typing.List[str]"
    description: "typing.Optional[str]"
    issuer: "typing.Optional[str]"
    min_amount: "typing.Optional[Amount]"
    offer: "Bolt12Offer"
    paths: "typing.List[Bolt12OfferBlindedPath]"
    signing_pubkey: "typing.Optional[str]"
    def __init__(self, *, absolute_expiry: "typing.Optional[int]", chains: "typing.List[str]", description: "typing.Optional[str]", issuer: "typing.Optional[str]", min_amount: "typing.Optional[Amount]", offer: "Bolt12Offer", paths: "typing.List[Bolt12OfferBlindedPath]", signing_pubkey: "typing.Optional[str]"):
        self.absolute_expiry = absolute_expiry
        self.chains = chains
        self.description = description
        self.issuer = issuer
        self.min_amount = min_amount
        self.offer = offer
        self.paths = paths
        self.signing_pubkey = signing_pubkey

    def __str__(self):
        return "Bolt12OfferDetails(absolute_expiry={}, chains={}, description={}, issuer={}, min_amount={}, offer={}, paths={}, signing_pubkey={})".format(self.absolute_expiry, self.chains, self.description, self.issuer, self.min_amount, self.offer, self.paths, self.signing_pubkey)

    def __eq__(self, other):
        if self.absolute_expiry != other.absolute_expiry:
            return False
        if self.chains != other.chains:
            return False
        if self.description != other.description:
            return False
        if self.issuer != other.issuer:
            return False
        if self.min_amount != other.min_amount:
            return False
        if self.offer != other.offer:
            return False
        if self.paths != other.paths:
            return False
        if self.signing_pubkey != other.signing_pubkey:
            return False
        return True

class _UniffiConverterTypeBolt12OfferDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Bolt12OfferDetails(
            absolute_expiry=_UniffiConverterOptionalUInt64.read(buf),
            chains=_UniffiConverterSequenceString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            issuer=_UniffiConverterOptionalString.read(buf),
            min_amount=_UniffiConverterOptionalTypeAmount.read(buf),
            offer=_UniffiConverterTypeBolt12Offer.read(buf),
            paths=_UniffiConverterSequenceTypeBolt12OfferBlindedPath.read(buf),
            signing_pubkey=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.absolute_expiry)
        _UniffiConverterSequenceString.check_lower(value.chains)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.issuer)
        _UniffiConverterOptionalTypeAmount.check_lower(value.min_amount)
        _UniffiConverterTypeBolt12Offer.check_lower(value.offer)
        _UniffiConverterSequenceTypeBolt12OfferBlindedPath.check_lower(value.paths)
        _UniffiConverterOptionalString.check_lower(value.signing_pubkey)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.absolute_expiry, buf)
        _UniffiConverterSequenceString.write(value.chains, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.issuer, buf)
        _UniffiConverterOptionalTypeAmount.write(value.min_amount, buf)
        _UniffiConverterTypeBolt12Offer.write(value.offer, buf)
        _UniffiConverterSequenceTypeBolt12OfferBlindedPath.write(value.paths, buf)
        _UniffiConverterOptionalString.write(value.signing_pubkey, buf)


class BurnIssuerTokenRequest:
    amount: "U128"
    def __init__(self, *, amount: "U128"):
        self.amount = amount

    def __str__(self):
        return "BurnIssuerTokenRequest(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeBurnIssuerTokenRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BurnIssuerTokenRequest(
            amount=_UniffiConverterTypeU128.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeU128.check_lower(value.amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeU128.write(value.amount, buf)


class CheckLightningAddressRequest:
    username: "str"
    def __init__(self, *, username: "str"):
        self.username = username

    def __str__(self):
        return "CheckLightningAddressRequest(username={})".format(self.username)

    def __eq__(self, other):
        if self.username != other.username:
            return False
        return True

class _UniffiConverterTypeCheckLightningAddressRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckLightningAddressRequest(
            username=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.username)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.username, buf)


class CheckMessageRequest:
    message: "str"
    """
    The message that was signed
    """

    pubkey: "str"
    """
    The public key that signed the message
    """

    signature: "str"
    """
    The DER or compact hex encoded signature
    """

    def __init__(self, *, message: "str", pubkey: "str", signature: "str"):
        self.message = message
        self.pubkey = pubkey
        self.signature = signature

    def __str__(self):
        return "CheckMessageRequest(message={}, pubkey={}, signature={})".format(self.message, self.pubkey, self.signature)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.signature != other.signature:
            return False
        return True

class _UniffiConverterTypeCheckMessageRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckMessageRequest(
            message=_UniffiConverterString.read(buf),
            pubkey=_UniffiConverterString.read(buf),
            signature=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.message)
        _UniffiConverterString.check_lower(value.pubkey)
        _UniffiConverterString.check_lower(value.signature)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.message, buf)
        _UniffiConverterString.write(value.pubkey, buf)
        _UniffiConverterString.write(value.signature, buf)


class CheckMessageResponse:
    is_valid: "bool"
    def __init__(self, *, is_valid: "bool"):
        self.is_valid = is_valid

    def __str__(self):
        return "CheckMessageResponse(is_valid={})".format(self.is_valid)

    def __eq__(self, other):
        if self.is_valid != other.is_valid:
            return False
        return True

class _UniffiConverterTypeCheckMessageResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckMessageResponse(
            is_valid=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.is_valid)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.is_valid, buf)


class ClaimDepositRequest:
    txid: "str"
    vout: "int"
    max_fee: "typing.Optional[MaxFee]"
    def __init__(self, *, txid: "str", vout: "int", max_fee: "typing.Optional[MaxFee]" = _DEFAULT):
        self.txid = txid
        self.vout = vout
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee

    def __str__(self):
        return "ClaimDepositRequest(txid={}, vout={}, max_fee={})".format(self.txid, self.vout, self.max_fee)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        if self.max_fee != other.max_fee:
            return False
        return True

class _UniffiConverterTypeClaimDepositRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClaimDepositRequest(
            txid=_UniffiConverterString.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
            max_fee=_UniffiConverterOptionalTypeMaxFee.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)
        _UniffiConverterOptionalTypeMaxFee.check_lower(value.max_fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)
        _UniffiConverterOptionalTypeMaxFee.write(value.max_fee, buf)


class ClaimDepositResponse:
    payment: "Payment"
    def __init__(self, *, payment: "Payment"):
        self.payment = payment

    def __str__(self):
        return "ClaimDepositResponse(payment={})".format(self.payment)

    def __eq__(self, other):
        if self.payment != other.payment:
            return False
        return True

class _UniffiConverterTypeClaimDepositResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClaimDepositResponse(
            payment=_UniffiConverterTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePayment.check_lower(value.payment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePayment.write(value.payment, buf)


class ClaimHtlcPaymentRequest:
    preimage: "str"
    def __init__(self, *, preimage: "str"):
        self.preimage = preimage

    def __str__(self):
        return "ClaimHtlcPaymentRequest(preimage={})".format(self.preimage)

    def __eq__(self, other):
        if self.preimage != other.preimage:
            return False
        return True

class _UniffiConverterTypeClaimHtlcPaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClaimHtlcPaymentRequest(
            preimage=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.preimage)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.preimage, buf)


class ClaimHtlcPaymentResponse:
    payment: "Payment"
    def __init__(self, *, payment: "Payment"):
        self.payment = payment

    def __str__(self):
        return "ClaimHtlcPaymentResponse(payment={})".format(self.payment)

    def __eq__(self, other):
        if self.payment != other.payment:
            return False
        return True

class _UniffiConverterTypeClaimHtlcPaymentResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClaimHtlcPaymentResponse(
            payment=_UniffiConverterTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePayment.check_lower(value.payment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePayment.write(value.payment, buf)


class Config:
    api_key: "typing.Optional[str]"
    network: "Network"
    sync_interval_secs: "int"
    max_deposit_claim_fee: "typing.Optional[MaxFee]"
    lnurl_domain: "typing.Optional[str]"
    """
    The domain used for receiving through lnurl-pay and lightning address.
    """

    prefer_spark_over_lightning: "bool"
    """
    When this is set to `true` we will prefer to use spark payments over
    lightning when sending and receiving. This has the benefit of lower fees
    but is at the cost of privacy.
    """

    external_input_parsers: "typing.Optional[typing.List[ExternalInputParser]]"
    """
    A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
    is not recognized. See [`ExternalInputParser`] for more details on how to configure
    external parsing.
    """

    use_default_external_input_parsers: "bool"
    """
    The SDK includes some default external input parsers
    ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
    Set this to false in order to prevent their use.
    """

    real_time_sync_server_url: "typing.Optional[str]"
    """
    Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
    """

    private_enabled_default: "bool"
    """
    Whether the Spark private mode is enabled by default.

    If set to true, the Spark private mode will be enabled on the first initialization of the SDK.
    If set to false, no changes will be made to the Spark private mode.
    """

    optimization_config: "OptimizationConfig"
    """
    Configuration for leaf optimization.

    Leaf optimization controls the denominations of leaves that are held in the wallet.
    Fewer, bigger leaves allow for more funds to be exited unilaterally.
    More leaves allow payments to be made without needing a swap, reducing payment latency.
    """

    def __init__(self, *, api_key: "typing.Optional[str]", network: "Network", sync_interval_secs: "int", max_deposit_claim_fee: "typing.Optional[MaxFee]", lnurl_domain: "typing.Optional[str]", prefer_spark_over_lightning: "bool", external_input_parsers: "typing.Optional[typing.List[ExternalInputParser]]", use_default_external_input_parsers: "bool", real_time_sync_server_url: "typing.Optional[str]", private_enabled_default: "bool", optimization_config: "OptimizationConfig"):
        self.api_key = api_key
        self.network = network
        self.sync_interval_secs = sync_interval_secs
        self.max_deposit_claim_fee = max_deposit_claim_fee
        self.lnurl_domain = lnurl_domain
        self.prefer_spark_over_lightning = prefer_spark_over_lightning
        self.external_input_parsers = external_input_parsers
        self.use_default_external_input_parsers = use_default_external_input_parsers
        self.real_time_sync_server_url = real_time_sync_server_url
        self.private_enabled_default = private_enabled_default
        self.optimization_config = optimization_config

    def __str__(self):
        return "Config(api_key={}, network={}, sync_interval_secs={}, max_deposit_claim_fee={}, lnurl_domain={}, prefer_spark_over_lightning={}, external_input_parsers={}, use_default_external_input_parsers={}, real_time_sync_server_url={}, private_enabled_default={}, optimization_config={})".format(self.api_key, self.network, self.sync_interval_secs, self.max_deposit_claim_fee, self.lnurl_domain, self.prefer_spark_over_lightning, self.external_input_parsers, self.use_default_external_input_parsers, self.real_time_sync_server_url, self.private_enabled_default, self.optimization_config)

    def __eq__(self, other):
        if self.api_key != other.api_key:
            return False
        if self.network != other.network:
            return False
        if self.sync_interval_secs != other.sync_interval_secs:
            return False
        if self.max_deposit_claim_fee != other.max_deposit_claim_fee:
            return False
        if self.lnurl_domain != other.lnurl_domain:
            return False
        if self.prefer_spark_over_lightning != other.prefer_spark_over_lightning:
            return False
        if self.external_input_parsers != other.external_input_parsers:
            return False
        if self.use_default_external_input_parsers != other.use_default_external_input_parsers:
            return False
        if self.real_time_sync_server_url != other.real_time_sync_server_url:
            return False
        if self.private_enabled_default != other.private_enabled_default:
            return False
        if self.optimization_config != other.optimization_config:
            return False
        return True

class _UniffiConverterTypeConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Config(
            api_key=_UniffiConverterOptionalString.read(buf),
            network=_UniffiConverterTypeNetwork.read(buf),
            sync_interval_secs=_UniffiConverterUInt32.read(buf),
            max_deposit_claim_fee=_UniffiConverterOptionalTypeMaxFee.read(buf),
            lnurl_domain=_UniffiConverterOptionalString.read(buf),
            prefer_spark_over_lightning=_UniffiConverterBool.read(buf),
            external_input_parsers=_UniffiConverterOptionalSequenceTypeExternalInputParser.read(buf),
            use_default_external_input_parsers=_UniffiConverterBool.read(buf),
            real_time_sync_server_url=_UniffiConverterOptionalString.read(buf),
            private_enabled_default=_UniffiConverterBool.read(buf),
            optimization_config=_UniffiConverterTypeOptimizationConfig.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.api_key)
        _UniffiConverterTypeNetwork.check_lower(value.network)
        _UniffiConverterUInt32.check_lower(value.sync_interval_secs)
        _UniffiConverterOptionalTypeMaxFee.check_lower(value.max_deposit_claim_fee)
        _UniffiConverterOptionalString.check_lower(value.lnurl_domain)
        _UniffiConverterBool.check_lower(value.prefer_spark_over_lightning)
        _UniffiConverterOptionalSequenceTypeExternalInputParser.check_lower(value.external_input_parsers)
        _UniffiConverterBool.check_lower(value.use_default_external_input_parsers)
        _UniffiConverterOptionalString.check_lower(value.real_time_sync_server_url)
        _UniffiConverterBool.check_lower(value.private_enabled_default)
        _UniffiConverterTypeOptimizationConfig.check_lower(value.optimization_config)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.api_key, buf)
        _UniffiConverterTypeNetwork.write(value.network, buf)
        _UniffiConverterUInt32.write(value.sync_interval_secs, buf)
        _UniffiConverterOptionalTypeMaxFee.write(value.max_deposit_claim_fee, buf)
        _UniffiConverterOptionalString.write(value.lnurl_domain, buf)
        _UniffiConverterBool.write(value.prefer_spark_over_lightning, buf)
        _UniffiConverterOptionalSequenceTypeExternalInputParser.write(value.external_input_parsers, buf)
        _UniffiConverterBool.write(value.use_default_external_input_parsers, buf)
        _UniffiConverterOptionalString.write(value.real_time_sync_server_url, buf)
        _UniffiConverterBool.write(value.private_enabled_default, buf)
        _UniffiConverterTypeOptimizationConfig.write(value.optimization_config, buf)


class ConnectRequest:
    config: "Config"
    seed: "Seed"
    storage_dir: "str"
    def __init__(self, *, config: "Config", seed: "Seed", storage_dir: "str"):
        self.config = config
        self.seed = seed
        self.storage_dir = storage_dir

    def __str__(self):
        return "ConnectRequest(config={}, seed={}, storage_dir={})".format(self.config, self.seed, self.storage_dir)

    def __eq__(self, other):
        if self.config != other.config:
            return False
        if self.seed != other.seed:
            return False
        if self.storage_dir != other.storage_dir:
            return False
        return True

class _UniffiConverterTypeConnectRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConnectRequest(
            config=_UniffiConverterTypeConfig.read(buf),
            seed=_UniffiConverterTypeSeed.read(buf),
            storage_dir=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeConfig.check_lower(value.config)
        _UniffiConverterTypeSeed.check_lower(value.seed)
        _UniffiConverterString.check_lower(value.storage_dir)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeConfig.write(value.config, buf)
        _UniffiConverterTypeSeed.write(value.seed, buf)
        _UniffiConverterString.write(value.storage_dir, buf)


class ConnectWithSignerRequest:
    """
    Request object for connecting to the Spark network using an external signer.

    This allows using a custom signer implementation instead of providing a seed directly.
    """

    config: "Config"
    signer: "ExternalSigner"
    storage_dir: "str"
    def __init__(self, *, config: "Config", signer: "ExternalSigner", storage_dir: "str"):
        self.config = config
        self.signer = signer
        self.storage_dir = storage_dir

    def __str__(self):
        return "ConnectWithSignerRequest(config={}, signer={}, storage_dir={})".format(self.config, self.signer, self.storage_dir)

    def __eq__(self, other):
        if self.config != other.config:
            return False
        if self.signer != other.signer:
            return False
        if self.storage_dir != other.storage_dir:
            return False
        return True

class _UniffiConverterTypeConnectWithSignerRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConnectWithSignerRequest(
            config=_UniffiConverterTypeConfig.read(buf),
            signer=_UniffiConverterTypeExternalSigner.read(buf),
            storage_dir=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeConfig.check_lower(value.config)
        _UniffiConverterTypeExternalSigner.check_lower(value.signer)
        _UniffiConverterString.check_lower(value.storage_dir)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeConfig.write(value.config, buf)
        _UniffiConverterTypeExternalSigner.write(value.signer, buf)
        _UniffiConverterString.write(value.storage_dir, buf)


class CreateIssuerTokenRequest:
    name: "str"
    ticker: "str"
    decimals: "int"
    is_freezable: "bool"
    max_supply: "U128"
    def __init__(self, *, name: "str", ticker: "str", decimals: "int", is_freezable: "bool", max_supply: "U128"):
        self.name = name
        self.ticker = ticker
        self.decimals = decimals
        self.is_freezable = is_freezable
        self.max_supply = max_supply

    def __str__(self):
        return "CreateIssuerTokenRequest(name={}, ticker={}, decimals={}, is_freezable={}, max_supply={})".format(self.name, self.ticker, self.decimals, self.is_freezable, self.max_supply)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.ticker != other.ticker:
            return False
        if self.decimals != other.decimals:
            return False
        if self.is_freezable != other.is_freezable:
            return False
        if self.max_supply != other.max_supply:
            return False
        return True

class _UniffiConverterTypeCreateIssuerTokenRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CreateIssuerTokenRequest(
            name=_UniffiConverterString.read(buf),
            ticker=_UniffiConverterString.read(buf),
            decimals=_UniffiConverterUInt32.read(buf),
            is_freezable=_UniffiConverterBool.read(buf),
            max_supply=_UniffiConverterTypeU128.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterString.check_lower(value.ticker)
        _UniffiConverterUInt32.check_lower(value.decimals)
        _UniffiConverterBool.check_lower(value.is_freezable)
        _UniffiConverterTypeU128.check_lower(value.max_supply)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterString.write(value.ticker, buf)
        _UniffiConverterUInt32.write(value.decimals, buf)
        _UniffiConverterBool.write(value.is_freezable, buf)
        _UniffiConverterTypeU128.write(value.max_supply, buf)


class Credentials:
    username: "str"
    password: "str"
    def __init__(self, *, username: "str", password: "str"):
        self.username = username
        self.password = password

    def __str__(self):
        return "Credentials(username={}, password={})".format(self.username, self.password)

    def __eq__(self, other):
        if self.username != other.username:
            return False
        if self.password != other.password:
            return False
        return True

class _UniffiConverterTypeCredentials(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Credentials(
            username=_UniffiConverterString.read(buf),
            password=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.username)
        _UniffiConverterString.check_lower(value.password)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.username, buf)
        _UniffiConverterString.write(value.password, buf)


class CurrencyInfo:
    """
    Details about a supported currency in the fiat rate feed
    """

    name: "str"
    fraction_size: "int"
    spacing: "typing.Optional[int]"
    symbol: "typing.Optional[Symbol]"
    uniq_symbol: "typing.Optional[Symbol]"
    localized_name: "typing.List[LocalizedName]"
    locale_overrides: "typing.List[LocaleOverrides]"
    def __init__(self, *, name: "str", fraction_size: "int", spacing: "typing.Optional[int]", symbol: "typing.Optional[Symbol]", uniq_symbol: "typing.Optional[Symbol]", localized_name: "typing.List[LocalizedName]", locale_overrides: "typing.List[LocaleOverrides]"):
        self.name = name
        self.fraction_size = fraction_size
        self.spacing = spacing
        self.symbol = symbol
        self.uniq_symbol = uniq_symbol
        self.localized_name = localized_name
        self.locale_overrides = locale_overrides

    def __str__(self):
        return "CurrencyInfo(name={}, fraction_size={}, spacing={}, symbol={}, uniq_symbol={}, localized_name={}, locale_overrides={})".format(self.name, self.fraction_size, self.spacing, self.symbol, self.uniq_symbol, self.localized_name, self.locale_overrides)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.fraction_size != other.fraction_size:
            return False
        if self.spacing != other.spacing:
            return False
        if self.symbol != other.symbol:
            return False
        if self.uniq_symbol != other.uniq_symbol:
            return False
        if self.localized_name != other.localized_name:
            return False
        if self.locale_overrides != other.locale_overrides:
            return False
        return True

class _UniffiConverterTypeCurrencyInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CurrencyInfo(
            name=_UniffiConverterString.read(buf),
            fraction_size=_UniffiConverterUInt32.read(buf),
            spacing=_UniffiConverterOptionalUInt32.read(buf),
            symbol=_UniffiConverterOptionalTypeSymbol.read(buf),
            uniq_symbol=_UniffiConverterOptionalTypeSymbol.read(buf),
            localized_name=_UniffiConverterSequenceTypeLocalizedName.read(buf),
            locale_overrides=_UniffiConverterSequenceTypeLocaleOverrides.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterUInt32.check_lower(value.fraction_size)
        _UniffiConverterOptionalUInt32.check_lower(value.spacing)
        _UniffiConverterOptionalTypeSymbol.check_lower(value.symbol)
        _UniffiConverterOptionalTypeSymbol.check_lower(value.uniq_symbol)
        _UniffiConverterSequenceTypeLocalizedName.check_lower(value.localized_name)
        _UniffiConverterSequenceTypeLocaleOverrides.check_lower(value.locale_overrides)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterUInt32.write(value.fraction_size, buf)
        _UniffiConverterOptionalUInt32.write(value.spacing, buf)
        _UniffiConverterOptionalTypeSymbol.write(value.symbol, buf)
        _UniffiConverterOptionalTypeSymbol.write(value.uniq_symbol, buf)
        _UniffiConverterSequenceTypeLocalizedName.write(value.localized_name, buf)
        _UniffiConverterSequenceTypeLocaleOverrides.write(value.locale_overrides, buf)


class DepositInfo:
    txid: "str"
    vout: "int"
    amount_sats: "int"
    refund_tx: "typing.Optional[str]"
    refund_tx_id: "typing.Optional[str]"
    claim_error: "typing.Optional[DepositClaimError]"
    def __init__(self, *, txid: "str", vout: "int", amount_sats: "int", refund_tx: "typing.Optional[str]", refund_tx_id: "typing.Optional[str]", claim_error: "typing.Optional[DepositClaimError]"):
        self.txid = txid
        self.vout = vout
        self.amount_sats = amount_sats
        self.refund_tx = refund_tx
        self.refund_tx_id = refund_tx_id
        self.claim_error = claim_error

    def __str__(self):
        return "DepositInfo(txid={}, vout={}, amount_sats={}, refund_tx={}, refund_tx_id={}, claim_error={})".format(self.txid, self.vout, self.amount_sats, self.refund_tx, self.refund_tx_id, self.claim_error)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        if self.amount_sats != other.amount_sats:
            return False
        if self.refund_tx != other.refund_tx:
            return False
        if self.refund_tx_id != other.refund_tx_id:
            return False
        if self.claim_error != other.claim_error:
            return False
        return True

class _UniffiConverterTypeDepositInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DepositInfo(
            txid=_UniffiConverterString.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
            amount_sats=_UniffiConverterUInt64.read(buf),
            refund_tx=_UniffiConverterOptionalString.read(buf),
            refund_tx_id=_UniffiConverterOptionalString.read(buf),
            claim_error=_UniffiConverterOptionalTypeDepositClaimError.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)
        _UniffiConverterUInt64.check_lower(value.amount_sats)
        _UniffiConverterOptionalString.check_lower(value.refund_tx)
        _UniffiConverterOptionalString.check_lower(value.refund_tx_id)
        _UniffiConverterOptionalTypeDepositClaimError.check_lower(value.claim_error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)
        _UniffiConverterUInt64.write(value.amount_sats, buf)
        _UniffiConverterOptionalString.write(value.refund_tx, buf)
        _UniffiConverterOptionalString.write(value.refund_tx_id, buf)
        _UniffiConverterOptionalTypeDepositClaimError.write(value.claim_error, buf)


class EcdsaSignatureBytes:
    """
    FFI-safe representation of an ECDSA signature (64 bytes)
    """

    bytes: "bytes"
    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "EcdsaSignatureBytes(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypeEcdsaSignatureBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EcdsaSignatureBytes(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class ExternalAggregateFrostRequest:
    """
    FFI-safe representation of `spark_wallet::AggregateFrostRequest`
    """

    message: "bytes"
    """
    The message that was signed
    """

    statechain_signatures: "typing.List[IdentifierSignaturePair]"
    """
    Statechain signatures as a list of identifier-signature pairs
    """

    statechain_public_keys: "typing.List[IdentifierPublicKeyPair]"
    """
    Statechain public keys as a list of identifier-publickey pairs
    """

    verifying_key: "bytes"
    """
    The verifying key (33 bytes compressed)
    """

    statechain_commitments: "typing.List[IdentifierCommitmentPair]"
    """
    Statechain commitments as a list of identifier-commitment pairs
    """

    self_commitment: "ExternalSigningCommitments"
    """
    The self commitment
    """

    public_key: "bytes"
    """
    The public key (33 bytes compressed)
    """

    self_signature: "ExternalFrostSignatureShare"
    """
    The self signature share
    """

    adaptor_public_key: "typing.Optional[bytes]"
    """
    Optional adaptor public key (33 bytes compressed)
    """

    def __init__(self, *, message: "bytes", statechain_signatures: "typing.List[IdentifierSignaturePair]", statechain_public_keys: "typing.List[IdentifierPublicKeyPair]", verifying_key: "bytes", statechain_commitments: "typing.List[IdentifierCommitmentPair]", self_commitment: "ExternalSigningCommitments", public_key: "bytes", self_signature: "ExternalFrostSignatureShare", adaptor_public_key: "typing.Optional[bytes]"):
        self.message = message
        self.statechain_signatures = statechain_signatures
        self.statechain_public_keys = statechain_public_keys
        self.verifying_key = verifying_key
        self.statechain_commitments = statechain_commitments
        self.self_commitment = self_commitment
        self.public_key = public_key
        self.self_signature = self_signature
        self.adaptor_public_key = adaptor_public_key

    def __str__(self):
        return "ExternalAggregateFrostRequest(message={}, statechain_signatures={}, statechain_public_keys={}, verifying_key={}, statechain_commitments={}, self_commitment={}, public_key={}, self_signature={}, adaptor_public_key={})".format(self.message, self.statechain_signatures, self.statechain_public_keys, self.verifying_key, self.statechain_commitments, self.self_commitment, self.public_key, self.self_signature, self.adaptor_public_key)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.statechain_signatures != other.statechain_signatures:
            return False
        if self.statechain_public_keys != other.statechain_public_keys:
            return False
        if self.verifying_key != other.verifying_key:
            return False
        if self.statechain_commitments != other.statechain_commitments:
            return False
        if self.self_commitment != other.self_commitment:
            return False
        if self.public_key != other.public_key:
            return False
        if self.self_signature != other.self_signature:
            return False
        if self.adaptor_public_key != other.adaptor_public_key:
            return False
        return True

class _UniffiConverterTypeExternalAggregateFrostRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalAggregateFrostRequest(
            message=_UniffiConverterBytes.read(buf),
            statechain_signatures=_UniffiConverterSequenceTypeIdentifierSignaturePair.read(buf),
            statechain_public_keys=_UniffiConverterSequenceTypeIdentifierPublicKeyPair.read(buf),
            verifying_key=_UniffiConverterBytes.read(buf),
            statechain_commitments=_UniffiConverterSequenceTypeIdentifierCommitmentPair.read(buf),
            self_commitment=_UniffiConverterTypeExternalSigningCommitments.read(buf),
            public_key=_UniffiConverterBytes.read(buf),
            self_signature=_UniffiConverterTypeExternalFrostSignatureShare.read(buf),
            adaptor_public_key=_UniffiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.message)
        _UniffiConverterSequenceTypeIdentifierSignaturePair.check_lower(value.statechain_signatures)
        _UniffiConverterSequenceTypeIdentifierPublicKeyPair.check_lower(value.statechain_public_keys)
        _UniffiConverterBytes.check_lower(value.verifying_key)
        _UniffiConverterSequenceTypeIdentifierCommitmentPair.check_lower(value.statechain_commitments)
        _UniffiConverterTypeExternalSigningCommitments.check_lower(value.self_commitment)
        _UniffiConverterBytes.check_lower(value.public_key)
        _UniffiConverterTypeExternalFrostSignatureShare.check_lower(value.self_signature)
        _UniffiConverterOptionalBytes.check_lower(value.adaptor_public_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.message, buf)
        _UniffiConverterSequenceTypeIdentifierSignaturePair.write(value.statechain_signatures, buf)
        _UniffiConverterSequenceTypeIdentifierPublicKeyPair.write(value.statechain_public_keys, buf)
        _UniffiConverterBytes.write(value.verifying_key, buf)
        _UniffiConverterSequenceTypeIdentifierCommitmentPair.write(value.statechain_commitments, buf)
        _UniffiConverterTypeExternalSigningCommitments.write(value.self_commitment, buf)
        _UniffiConverterBytes.write(value.public_key, buf)
        _UniffiConverterTypeExternalFrostSignatureShare.write(value.self_signature, buf)
        _UniffiConverterOptionalBytes.write(value.adaptor_public_key, buf)


class ExternalEncryptedPrivateKey:
    """
    FFI-safe representation of `spark_wallet::EncryptedPrivateKey`
    """

    ciphertext: "bytes"
    """
    The encrypted ciphertext
    """

    def __init__(self, *, ciphertext: "bytes"):
        self.ciphertext = ciphertext

    def __str__(self):
        return "ExternalEncryptedPrivateKey(ciphertext={})".format(self.ciphertext)

    def __eq__(self, other):
        if self.ciphertext != other.ciphertext:
            return False
        return True

class _UniffiConverterTypeExternalEncryptedPrivateKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalEncryptedPrivateKey(
            ciphertext=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.ciphertext)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.ciphertext, buf)


class ExternalFrostCommitments:
    """
    FFI-safe representation of `spark_wallet::FrostSigningCommitmentsWithNonces`
    """

    hiding_commitment: "bytes"
    """
    Serialized hiding nonce commitment (variable length, typically 33 bytes compressed point)
    """

    binding_commitment: "bytes"
    """
    Serialized binding nonce commitment (variable length, typically 33 bytes compressed point)
    """

    nonces_ciphertext: "bytes"
    """
    Encrypted nonces ciphertext
    """

    def __init__(self, *, hiding_commitment: "bytes", binding_commitment: "bytes", nonces_ciphertext: "bytes"):
        self.hiding_commitment = hiding_commitment
        self.binding_commitment = binding_commitment
        self.nonces_ciphertext = nonces_ciphertext

    def __str__(self):
        return "ExternalFrostCommitments(hiding_commitment={}, binding_commitment={}, nonces_ciphertext={})".format(self.hiding_commitment, self.binding_commitment, self.nonces_ciphertext)

    def __eq__(self, other):
        if self.hiding_commitment != other.hiding_commitment:
            return False
        if self.binding_commitment != other.binding_commitment:
            return False
        if self.nonces_ciphertext != other.nonces_ciphertext:
            return False
        return True

class _UniffiConverterTypeExternalFrostCommitments(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalFrostCommitments(
            hiding_commitment=_UniffiConverterBytes.read(buf),
            binding_commitment=_UniffiConverterBytes.read(buf),
            nonces_ciphertext=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.hiding_commitment)
        _UniffiConverterBytes.check_lower(value.binding_commitment)
        _UniffiConverterBytes.check_lower(value.nonces_ciphertext)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.hiding_commitment, buf)
        _UniffiConverterBytes.write(value.binding_commitment, buf)
        _UniffiConverterBytes.write(value.nonces_ciphertext, buf)


class ExternalFrostSignature:
    """
    FFI-safe representation of `frost_secp256k1_tr::Signature`
    """

    bytes: "bytes"
    """
    Serialized Frost signature bytes (64 bytes)
    """

    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "ExternalFrostSignature(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypeExternalFrostSignature(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalFrostSignature(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class ExternalFrostSignatureShare:
    """
    FFI-safe representation of `frost_secp256k1_tr::round2::SignatureShare`
    """

    bytes: "bytes"
    """
    Serialized signature share bytes (variable length, typically 32 bytes)
    """

    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "ExternalFrostSignatureShare(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypeExternalFrostSignatureShare(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalFrostSignatureShare(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class ExternalIdentifier:
    """
    FFI-safe representation of `frost_secp256k1_tr::Identifier`
    """

    bytes: "bytes"
    """
    Serialized identifier bytes
    """

    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "ExternalIdentifier(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypeExternalIdentifier(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalIdentifier(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class ExternalInputParser:
    """
    Configuration for an external input parser
    """

    provider_id: "str"
    """
    An arbitrary parser provider id
    """

    input_regex: "str"
    """
    The external parser will be used when an input conforms to this regex
    """

    parser_url: "str"
    """
    The URL of the parser containing a placeholder `<input>` that will be replaced with the
    input to be parsed. The input is sanitized using percent encoding.
    """

    def __init__(self, *, provider_id: "str", input_regex: "str", parser_url: "str"):
        self.provider_id = provider_id
        self.input_regex = input_regex
        self.parser_url = parser_url

    def __str__(self):
        return "ExternalInputParser(provider_id={}, input_regex={}, parser_url={})".format(self.provider_id, self.input_regex, self.parser_url)

    def __eq__(self, other):
        if self.provider_id != other.provider_id:
            return False
        if self.input_regex != other.input_regex:
            return False
        if self.parser_url != other.parser_url:
            return False
        return True

class _UniffiConverterTypeExternalInputParser(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalInputParser(
            provider_id=_UniffiConverterString.read(buf),
            input_regex=_UniffiConverterString.read(buf),
            parser_url=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.provider_id)
        _UniffiConverterString.check_lower(value.input_regex)
        _UniffiConverterString.check_lower(value.parser_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.provider_id, buf)
        _UniffiConverterString.write(value.input_regex, buf)
        _UniffiConverterString.write(value.parser_url, buf)


class ExternalScalar:
    """
    FFI-safe representation of `k256::Scalar` (32 bytes)
    """

    bytes: "bytes"
    """
    The 32-byte scalar value
    """

    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "ExternalScalar(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypeExternalScalar(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalScalar(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class ExternalSecretShare:
    """
    FFI-safe representation of `spark_wallet::SecretShare`
    """

    threshold: "int"
    """
    Number of shares required to recover the secret
    """

    index: "ExternalScalar"
    """
    Index (x-coordinate) of the share as 32 bytes
    """

    share: "ExternalScalar"
    """
    Share value (y-coordinate) as 32 bytes
    """

    def __init__(self, *, threshold: "int", index: "ExternalScalar", share: "ExternalScalar"):
        self.threshold = threshold
        self.index = index
        self.share = share

    def __str__(self):
        return "ExternalSecretShare(threshold={}, index={}, share={})".format(self.threshold, self.index, self.share)

    def __eq__(self, other):
        if self.threshold != other.threshold:
            return False
        if self.index != other.index:
            return False
        if self.share != other.share:
            return False
        return True

class _UniffiConverterTypeExternalSecretShare(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalSecretShare(
            threshold=_UniffiConverterUInt32.read(buf),
            index=_UniffiConverterTypeExternalScalar.read(buf),
            share=_UniffiConverterTypeExternalScalar.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.threshold)
        _UniffiConverterTypeExternalScalar.check_lower(value.index)
        _UniffiConverterTypeExternalScalar.check_lower(value.share)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.threshold, buf)
        _UniffiConverterTypeExternalScalar.write(value.index, buf)
        _UniffiConverterTypeExternalScalar.write(value.share, buf)


class ExternalSignFrostRequest:
    """
    FFI-safe representation of `spark_wallet::SignFrostRequest`
    """

    message: "bytes"
    """
    The message to sign
    """

    public_key: "bytes"
    """
    The public key (33 bytes compressed)
    """

    private_key: "ExternalPrivateKeySource"
    """
    The private key source
    """

    verifying_key: "bytes"
    """
    The verifying key (33 bytes compressed)
    """

    self_nonce_commitment: "ExternalFrostCommitments"
    """
    The self nonce commitment
    """

    statechain_commitments: "typing.List[IdentifierCommitmentPair]"
    """
    Statechain commitments as a list of identifier-commitment pairs
    """

    adaptor_public_key: "typing.Optional[bytes]"
    """
    Optional adaptor public key (33 bytes compressed)
    """

    def __init__(self, *, message: "bytes", public_key: "bytes", private_key: "ExternalPrivateKeySource", verifying_key: "bytes", self_nonce_commitment: "ExternalFrostCommitments", statechain_commitments: "typing.List[IdentifierCommitmentPair]", adaptor_public_key: "typing.Optional[bytes]"):
        self.message = message
        self.public_key = public_key
        self.private_key = private_key
        self.verifying_key = verifying_key
        self.self_nonce_commitment = self_nonce_commitment
        self.statechain_commitments = statechain_commitments
        self.adaptor_public_key = adaptor_public_key

    def __str__(self):
        return "ExternalSignFrostRequest(message={}, public_key={}, private_key={}, verifying_key={}, self_nonce_commitment={}, statechain_commitments={}, adaptor_public_key={})".format(self.message, self.public_key, self.private_key, self.verifying_key, self.self_nonce_commitment, self.statechain_commitments, self.adaptor_public_key)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.public_key != other.public_key:
            return False
        if self.private_key != other.private_key:
            return False
        if self.verifying_key != other.verifying_key:
            return False
        if self.self_nonce_commitment != other.self_nonce_commitment:
            return False
        if self.statechain_commitments != other.statechain_commitments:
            return False
        if self.adaptor_public_key != other.adaptor_public_key:
            return False
        return True

class _UniffiConverterTypeExternalSignFrostRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalSignFrostRequest(
            message=_UniffiConverterBytes.read(buf),
            public_key=_UniffiConverterBytes.read(buf),
            private_key=_UniffiConverterTypeExternalPrivateKeySource.read(buf),
            verifying_key=_UniffiConverterBytes.read(buf),
            self_nonce_commitment=_UniffiConverterTypeExternalFrostCommitments.read(buf),
            statechain_commitments=_UniffiConverterSequenceTypeIdentifierCommitmentPair.read(buf),
            adaptor_public_key=_UniffiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.message)
        _UniffiConverterBytes.check_lower(value.public_key)
        _UniffiConverterTypeExternalPrivateKeySource.check_lower(value.private_key)
        _UniffiConverterBytes.check_lower(value.verifying_key)
        _UniffiConverterTypeExternalFrostCommitments.check_lower(value.self_nonce_commitment)
        _UniffiConverterSequenceTypeIdentifierCommitmentPair.check_lower(value.statechain_commitments)
        _UniffiConverterOptionalBytes.check_lower(value.adaptor_public_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.message, buf)
        _UniffiConverterBytes.write(value.public_key, buf)
        _UniffiConverterTypeExternalPrivateKeySource.write(value.private_key, buf)
        _UniffiConverterBytes.write(value.verifying_key, buf)
        _UniffiConverterTypeExternalFrostCommitments.write(value.self_nonce_commitment, buf)
        _UniffiConverterSequenceTypeIdentifierCommitmentPair.write(value.statechain_commitments, buf)
        _UniffiConverterOptionalBytes.write(value.adaptor_public_key, buf)


class ExternalSigningCommitments:
    """
    FFI-safe representation of `frost_secp256k1_tr::round1::SigningCommitments`
    """

    hiding: "bytes"
    """
    Serialized hiding nonce commitment
    """

    binding: "bytes"
    """
    Serialized binding nonce commitment
    """

    def __init__(self, *, hiding: "bytes", binding: "bytes"):
        self.hiding = hiding
        self.binding = binding

    def __str__(self):
        return "ExternalSigningCommitments(hiding={}, binding={})".format(self.hiding, self.binding)

    def __eq__(self, other):
        if self.hiding != other.hiding:
            return False
        if self.binding != other.binding:
            return False
        return True

class _UniffiConverterTypeExternalSigningCommitments(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalSigningCommitments(
            hiding=_UniffiConverterBytes.read(buf),
            binding=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.hiding)
        _UniffiConverterBytes.check_lower(value.binding)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.hiding, buf)
        _UniffiConverterBytes.write(value.binding, buf)


class ExternalTreeNodeId:
    """
    FFI-safe representation of `spark_wallet::TreeNodeId`
    """

    id: "str"
    """
    The tree node identifier as a string
    """

    def __init__(self, *, id: "str"):
        self.id = id

    def __str__(self):
        return "ExternalTreeNodeId(id={})".format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True

class _UniffiConverterTypeExternalTreeNodeId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalTreeNodeId(
            id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)


class ExternalVerifiableSecretShare:
    """
    FFI-safe representation of `spark_wallet::VerifiableSecretShare`
    """

    secret_share: "ExternalSecretShare"
    """
    Base secret share containing threshold, index, and share value
    """

    proofs: "typing.List[bytes]"
    """
    Cryptographic proofs for share verification (each proof is 33 bytes compressed public key)
    """

    def __init__(self, *, secret_share: "ExternalSecretShare", proofs: "typing.List[bytes]"):
        self.secret_share = secret_share
        self.proofs = proofs

    def __str__(self):
        return "ExternalVerifiableSecretShare(secret_share={}, proofs={})".format(self.secret_share, self.proofs)

    def __eq__(self, other):
        if self.secret_share != other.secret_share:
            return False
        if self.proofs != other.proofs:
            return False
        return True

class _UniffiConverterTypeExternalVerifiableSecretShare(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExternalVerifiableSecretShare(
            secret_share=_UniffiConverterTypeExternalSecretShare.read(buf),
            proofs=_UniffiConverterSequenceBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeExternalSecretShare.check_lower(value.secret_share)
        _UniffiConverterSequenceBytes.check_lower(value.proofs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeExternalSecretShare.write(value.secret_share, buf)
        _UniffiConverterSequenceBytes.write(value.proofs, buf)


class FetchTokenConversionLimitsRequest:
    conversion_type: "TokenConversionType"
    """
    The type of conversion, either from or to Bitcoin.
    """

    token_identifier: "typing.Optional[str]"
    """
    The token identifier when converting to a token.
    """

    def __init__(self, *, conversion_type: "TokenConversionType", token_identifier: "typing.Optional[str]" = _DEFAULT):
        self.conversion_type = conversion_type
        if token_identifier is _DEFAULT:
            self.token_identifier = None
        else:
            self.token_identifier = token_identifier

    def __str__(self):
        return "FetchTokenConversionLimitsRequest(conversion_type={}, token_identifier={})".format(self.conversion_type, self.token_identifier)

    def __eq__(self, other):
        if self.conversion_type != other.conversion_type:
            return False
        if self.token_identifier != other.token_identifier:
            return False
        return True

class _UniffiConverterTypeFetchTokenConversionLimitsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FetchTokenConversionLimitsRequest(
            conversion_type=_UniffiConverterTypeTokenConversionType.read(buf),
            token_identifier=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTokenConversionType.check_lower(value.conversion_type)
        _UniffiConverterOptionalString.check_lower(value.token_identifier)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTokenConversionType.write(value.conversion_type, buf)
        _UniffiConverterOptionalString.write(value.token_identifier, buf)


class FetchTokenConversionLimitsResponse:
    min_from_amount: "typing.Optional[U128]"
    """
    The minimum amount to be converted.
    Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
    """

    min_to_amount: "typing.Optional[U128]"
    """
    The minimum amount to be received from the conversion.
    Denominated in satoshis if converting to Bitcoin, otherwise in the token base units.
    """

    def __init__(self, *, min_from_amount: "typing.Optional[U128]", min_to_amount: "typing.Optional[U128]"):
        self.min_from_amount = min_from_amount
        self.min_to_amount = min_to_amount

    def __str__(self):
        return "FetchTokenConversionLimitsResponse(min_from_amount={}, min_to_amount={})".format(self.min_from_amount, self.min_to_amount)

    def __eq__(self, other):
        if self.min_from_amount != other.min_from_amount:
            return False
        if self.min_to_amount != other.min_to_amount:
            return False
        return True

class _UniffiConverterTypeFetchTokenConversionLimitsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FetchTokenConversionLimitsResponse(
            min_from_amount=_UniffiConverterOptionalTypeU128.read(buf),
            min_to_amount=_UniffiConverterOptionalTypeU128.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeU128.check_lower(value.min_from_amount)
        _UniffiConverterOptionalTypeU128.check_lower(value.min_to_amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeU128.write(value.min_from_amount, buf)
        _UniffiConverterOptionalTypeU128.write(value.min_to_amount, buf)


class FiatCurrency:
    """
    Wrapper around the [`CurrencyInfo`] of a fiat currency
    """

    id: "str"
    info: "CurrencyInfo"
    def __init__(self, *, id: "str", info: "CurrencyInfo"):
        self.id = id
        self.info = info

    def __str__(self):
        return "FiatCurrency(id={}, info={})".format(self.id, self.info)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.info != other.info:
            return False
        return True

class _UniffiConverterTypeFiatCurrency(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FiatCurrency(
            id=_UniffiConverterString.read(buf),
            info=_UniffiConverterTypeCurrencyInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterTypeCurrencyInfo.check_lower(value.info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterTypeCurrencyInfo.write(value.info, buf)


class FreezeIssuerTokenRequest:
    address: "str"
    def __init__(self, *, address: "str"):
        self.address = address

    def __str__(self):
        return "FreezeIssuerTokenRequest(address={})".format(self.address)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        return True

class _UniffiConverterTypeFreezeIssuerTokenRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FreezeIssuerTokenRequest(
            address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)


class FreezeIssuerTokenResponse:
    impacted_output_ids: "typing.List[str]"
    impacted_token_amount: "U128"
    def __init__(self, *, impacted_output_ids: "typing.List[str]", impacted_token_amount: "U128"):
        self.impacted_output_ids = impacted_output_ids
        self.impacted_token_amount = impacted_token_amount

    def __str__(self):
        return "FreezeIssuerTokenResponse(impacted_output_ids={}, impacted_token_amount={})".format(self.impacted_output_ids, self.impacted_token_amount)

    def __eq__(self, other):
        if self.impacted_output_ids != other.impacted_output_ids:
            return False
        if self.impacted_token_amount != other.impacted_token_amount:
            return False
        return True

class _UniffiConverterTypeFreezeIssuerTokenResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FreezeIssuerTokenResponse(
            impacted_output_ids=_UniffiConverterSequenceString.read(buf),
            impacted_token_amount=_UniffiConverterTypeU128.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceString.check_lower(value.impacted_output_ids)
        _UniffiConverterTypeU128.check_lower(value.impacted_token_amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceString.write(value.impacted_output_ids, buf)
        _UniffiConverterTypeU128.write(value.impacted_token_amount, buf)


class GetInfoRequest:
    """
    Request to get the balance of the wallet
    """

    ensure_synced: "typing.Optional[bool]"
    def __init__(self, *, ensure_synced: "typing.Optional[bool]"):
        self.ensure_synced = ensure_synced

    def __str__(self):
        return "GetInfoRequest(ensure_synced={})".format(self.ensure_synced)

    def __eq__(self, other):
        if self.ensure_synced != other.ensure_synced:
            return False
        return True

class _UniffiConverterTypeGetInfoRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetInfoRequest(
            ensure_synced=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalBool.check_lower(value.ensure_synced)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalBool.write(value.ensure_synced, buf)


class GetInfoResponse:
    """
    Response containing the balance of the wallet
    """

    balance_sats: "int"
    """
    The balance in satoshis
    """

    token_balances: "dict[str, TokenBalance]"
    """
    The balances of the tokens in the wallet keyed by the token identifier
    """

    def __init__(self, *, balance_sats: "int", token_balances: "dict[str, TokenBalance]"):
        self.balance_sats = balance_sats
        self.token_balances = token_balances

    def __str__(self):
        return "GetInfoResponse(balance_sats={}, token_balances={})".format(self.balance_sats, self.token_balances)

    def __eq__(self, other):
        if self.balance_sats != other.balance_sats:
            return False
        if self.token_balances != other.token_balances:
            return False
        return True

class _UniffiConverterTypeGetInfoResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetInfoResponse(
            balance_sats=_UniffiConverterUInt64.read(buf),
            token_balances=_UniffiConverterMapStringTypeTokenBalance.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.balance_sats)
        _UniffiConverterMapStringTypeTokenBalance.check_lower(value.token_balances)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.balance_sats, buf)
        _UniffiConverterMapStringTypeTokenBalance.write(value.token_balances, buf)


class GetPaymentRequest:
    payment_id: "str"
    def __init__(self, *, payment_id: "str"):
        self.payment_id = payment_id

    def __str__(self):
        return "GetPaymentRequest(payment_id={})".format(self.payment_id)

    def __eq__(self, other):
        if self.payment_id != other.payment_id:
            return False
        return True

class _UniffiConverterTypeGetPaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetPaymentRequest(
            payment_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_id, buf)


class GetPaymentResponse:
    payment: "Payment"
    def __init__(self, *, payment: "Payment"):
        self.payment = payment

    def __str__(self):
        return "GetPaymentResponse(payment={})".format(self.payment)

    def __eq__(self, other):
        if self.payment != other.payment:
            return False
        return True

class _UniffiConverterTypeGetPaymentResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetPaymentResponse(
            payment=_UniffiConverterTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePayment.check_lower(value.payment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePayment.write(value.payment, buf)


class GetTokensMetadataRequest:
    token_identifiers: "typing.List[str]"
    def __init__(self, *, token_identifiers: "typing.List[str]"):
        self.token_identifiers = token_identifiers

    def __str__(self):
        return "GetTokensMetadataRequest(token_identifiers={})".format(self.token_identifiers)

    def __eq__(self, other):
        if self.token_identifiers != other.token_identifiers:
            return False
        return True

class _UniffiConverterTypeGetTokensMetadataRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetTokensMetadataRequest(
            token_identifiers=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceString.check_lower(value.token_identifiers)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceString.write(value.token_identifiers, buf)


class GetTokensMetadataResponse:
    tokens_metadata: "typing.List[TokenMetadata]"
    def __init__(self, *, tokens_metadata: "typing.List[TokenMetadata]"):
        self.tokens_metadata = tokens_metadata

    def __str__(self):
        return "GetTokensMetadataResponse(tokens_metadata={})".format(self.tokens_metadata)

    def __eq__(self, other):
        if self.tokens_metadata != other.tokens_metadata:
            return False
        return True

class _UniffiConverterTypeGetTokensMetadataResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetTokensMetadataResponse(
            tokens_metadata=_UniffiConverterSequenceTypeTokenMetadata.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeTokenMetadata.check_lower(value.tokens_metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeTokenMetadata.write(value.tokens_metadata, buf)


class IdentifierCommitmentPair:
    """
    FFI-safe wrapper for (Identifier, `SigningCommitments`) pair
    """

    identifier: "ExternalIdentifier"
    commitment: "ExternalSigningCommitments"
    def __init__(self, *, identifier: "ExternalIdentifier", commitment: "ExternalSigningCommitments"):
        self.identifier = identifier
        self.commitment = commitment

    def __str__(self):
        return "IdentifierCommitmentPair(identifier={}, commitment={})".format(self.identifier, self.commitment)

    def __eq__(self, other):
        if self.identifier != other.identifier:
            return False
        if self.commitment != other.commitment:
            return False
        return True

class _UniffiConverterTypeIdentifierCommitmentPair(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IdentifierCommitmentPair(
            identifier=_UniffiConverterTypeExternalIdentifier.read(buf),
            commitment=_UniffiConverterTypeExternalSigningCommitments.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeExternalIdentifier.check_lower(value.identifier)
        _UniffiConverterTypeExternalSigningCommitments.check_lower(value.commitment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeExternalIdentifier.write(value.identifier, buf)
        _UniffiConverterTypeExternalSigningCommitments.write(value.commitment, buf)


class IdentifierPublicKeyPair:
    """
    FFI-safe wrapper for (Identifier, `PublicKey`) pair
    """

    identifier: "ExternalIdentifier"
    public_key: "bytes"
    def __init__(self, *, identifier: "ExternalIdentifier", public_key: "bytes"):
        self.identifier = identifier
        self.public_key = public_key

    def __str__(self):
        return "IdentifierPublicKeyPair(identifier={}, public_key={})".format(self.identifier, self.public_key)

    def __eq__(self, other):
        if self.identifier != other.identifier:
            return False
        if self.public_key != other.public_key:
            return False
        return True

class _UniffiConverterTypeIdentifierPublicKeyPair(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IdentifierPublicKeyPair(
            identifier=_UniffiConverterTypeExternalIdentifier.read(buf),
            public_key=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeExternalIdentifier.check_lower(value.identifier)
        _UniffiConverterBytes.check_lower(value.public_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeExternalIdentifier.write(value.identifier, buf)
        _UniffiConverterBytes.write(value.public_key, buf)


class IdentifierSignaturePair:
    """
    FFI-safe wrapper for (Identifier, `SignatureShare`) pair
    """

    identifier: "ExternalIdentifier"
    signature: "ExternalFrostSignatureShare"
    def __init__(self, *, identifier: "ExternalIdentifier", signature: "ExternalFrostSignatureShare"):
        self.identifier = identifier
        self.signature = signature

    def __str__(self):
        return "IdentifierSignaturePair(identifier={}, signature={})".format(self.identifier, self.signature)

    def __eq__(self, other):
        if self.identifier != other.identifier:
            return False
        if self.signature != other.signature:
            return False
        return True

class _UniffiConverterTypeIdentifierSignaturePair(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IdentifierSignaturePair(
            identifier=_UniffiConverterTypeExternalIdentifier.read(buf),
            signature=_UniffiConverterTypeExternalFrostSignatureShare.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeExternalIdentifier.check_lower(value.identifier)
        _UniffiConverterTypeExternalFrostSignatureShare.check_lower(value.signature)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeExternalIdentifier.write(value.identifier, buf)
        _UniffiConverterTypeExternalFrostSignatureShare.write(value.signature, buf)


class IncomingChange:
    new_state: "Record"
    old_state: "typing.Optional[Record]"
    def __init__(self, *, new_state: "Record", old_state: "typing.Optional[Record]"):
        self.new_state = new_state
        self.old_state = old_state

    def __str__(self):
        return "IncomingChange(new_state={}, old_state={})".format(self.new_state, self.old_state)

    def __eq__(self, other):
        if self.new_state != other.new_state:
            return False
        if self.old_state != other.old_state:
            return False
        return True

class _UniffiConverterTypeIncomingChange(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IncomingChange(
            new_state=_UniffiConverterTypeRecord.read(buf),
            old_state=_UniffiConverterOptionalTypeRecord.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeRecord.check_lower(value.new_state)
        _UniffiConverterOptionalTypeRecord.check_lower(value.old_state)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeRecord.write(value.new_state, buf)
        _UniffiConverterOptionalTypeRecord.write(value.old_state, buf)


class KeySetConfig:
    """
    Configuration for key set derivation.

    This struct encapsulates the parameters needed for BIP32 key derivation.
    """

    key_set_type: "KeySetType"
    """
    The key set type which determines the derivation path
    """

    use_address_index: "bool"
    """
    Controls the structure of the BIP derivation path
    """

    account_number: "typing.Optional[int]"
    """
    Optional account number for key derivation
    """

    def __init__(self, *, key_set_type: "KeySetType", use_address_index: "bool", account_number: "typing.Optional[int]"):
        self.key_set_type = key_set_type
        self.use_address_index = use_address_index
        self.account_number = account_number

    def __str__(self):
        return "KeySetConfig(key_set_type={}, use_address_index={}, account_number={})".format(self.key_set_type, self.use_address_index, self.account_number)

    def __eq__(self, other):
        if self.key_set_type != other.key_set_type:
            return False
        if self.use_address_index != other.use_address_index:
            return False
        if self.account_number != other.account_number:
            return False
        return True

class _UniffiConverterTypeKeySetConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeySetConfig(
            key_set_type=_UniffiConverterTypeKeySetType.read(buf),
            use_address_index=_UniffiConverterBool.read(buf),
            account_number=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeKeySetType.check_lower(value.key_set_type)
        _UniffiConverterBool.check_lower(value.use_address_index)
        _UniffiConverterOptionalUInt32.check_lower(value.account_number)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeKeySetType.write(value.key_set_type, buf)
        _UniffiConverterBool.write(value.use_address_index, buf)
        _UniffiConverterOptionalUInt32.write(value.account_number, buf)


class LightningAddressDetails:
    address: "str"
    pay_request: "LnurlPayRequestDetails"
    def __init__(self, *, address: "str", pay_request: "LnurlPayRequestDetails"):
        self.address = address
        self.pay_request = pay_request

    def __str__(self):
        return "LightningAddressDetails(address={}, pay_request={})".format(self.address, self.pay_request)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.pay_request != other.pay_request:
            return False
        return True

class _UniffiConverterTypeLightningAddressDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LightningAddressDetails(
            address=_UniffiConverterString.read(buf),
            pay_request=_UniffiConverterTypeLnurlPayRequestDetails.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterTypeLnurlPayRequestDetails.check_lower(value.pay_request)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterTypeLnurlPayRequestDetails.write(value.pay_request, buf)


class LightningAddressInfo:
    description: "str"
    lightning_address: "str"
    lnurl: "str"
    username: "str"
    def __init__(self, *, description: "str", lightning_address: "str", lnurl: "str", username: "str"):
        self.description = description
        self.lightning_address = lightning_address
        self.lnurl = lnurl
        self.username = username

    def __str__(self):
        return "LightningAddressInfo(description={}, lightning_address={}, lnurl={}, username={})".format(self.description, self.lightning_address, self.lnurl, self.username)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.lightning_address != other.lightning_address:
            return False
        if self.lnurl != other.lnurl:
            return False
        if self.username != other.username:
            return False
        return True

class _UniffiConverterTypeLightningAddressInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LightningAddressInfo(
            description=_UniffiConverterString.read(buf),
            lightning_address=_UniffiConverterString.read(buf),
            lnurl=_UniffiConverterString.read(buf),
            username=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.lightning_address)
        _UniffiConverterString.check_lower(value.lnurl)
        _UniffiConverterString.check_lower(value.username)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterString.write(value.lightning_address, buf)
        _UniffiConverterString.write(value.lnurl, buf)
        _UniffiConverterString.write(value.username, buf)


class ListFiatCurrenciesResponse:
    """
    Response from listing fiat currencies
    """

    currencies: "typing.List[FiatCurrency]"
    """
    The list of fiat currencies
    """

    def __init__(self, *, currencies: "typing.List[FiatCurrency]"):
        self.currencies = currencies

    def __str__(self):
        return "ListFiatCurrenciesResponse(currencies={})".format(self.currencies)

    def __eq__(self, other):
        if self.currencies != other.currencies:
            return False
        return True

class _UniffiConverterTypeListFiatCurrenciesResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListFiatCurrenciesResponse(
            currencies=_UniffiConverterSequenceTypeFiatCurrency.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeFiatCurrency.check_lower(value.currencies)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeFiatCurrency.write(value.currencies, buf)


class ListFiatRatesResponse:
    """
    Response from listing fiat rates
    """

    rates: "typing.List[Rate]"
    """
    The list of fiat rates
    """

    def __init__(self, *, rates: "typing.List[Rate]"):
        self.rates = rates

    def __str__(self):
        return "ListFiatRatesResponse(rates={})".format(self.rates)

    def __eq__(self, other):
        if self.rates != other.rates:
            return False
        return True

class _UniffiConverterTypeListFiatRatesResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListFiatRatesResponse(
            rates=_UniffiConverterSequenceTypeRate.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeRate.check_lower(value.rates)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeRate.write(value.rates, buf)


class ListPaymentsRequest:
    """
    Request to list payments with optional filters and pagination
    """

    type_filter: "typing.Optional[typing.List[PaymentType]]"
    status_filter: "typing.Optional[typing.List[PaymentStatus]]"
    asset_filter: "typing.Optional[AssetFilter]"
    payment_details_filter: "typing.Optional[typing.List[PaymentDetailsFilter]]"
    """
    Only include payments matching at least one of these payment details filters
    """

    from_timestamp: "typing.Optional[int]"
    """
    Only include payments created after this timestamp (inclusive)
    """

    to_timestamp: "typing.Optional[int]"
    """
    Only include payments created before this timestamp (exclusive)
    """

    offset: "typing.Optional[int]"
    """
    Number of records to skip
    """

    limit: "typing.Optional[int]"
    """
    Maximum number of records to return
    """

    sort_ascending: "typing.Optional[bool]"
    def __init__(self, *, type_filter: "typing.Optional[typing.List[PaymentType]]" = _DEFAULT, status_filter: "typing.Optional[typing.List[PaymentStatus]]" = _DEFAULT, asset_filter: "typing.Optional[AssetFilter]" = _DEFAULT, payment_details_filter: "typing.Optional[typing.List[PaymentDetailsFilter]]" = _DEFAULT, from_timestamp: "typing.Optional[int]" = _DEFAULT, to_timestamp: "typing.Optional[int]" = _DEFAULT, offset: "typing.Optional[int]" = _DEFAULT, limit: "typing.Optional[int]" = _DEFAULT, sort_ascending: "typing.Optional[bool]" = _DEFAULT):
        if type_filter is _DEFAULT:
            self.type_filter = None
        else:
            self.type_filter = type_filter
        if status_filter is _DEFAULT:
            self.status_filter = None
        else:
            self.status_filter = status_filter
        if asset_filter is _DEFAULT:
            self.asset_filter = None
        else:
            self.asset_filter = asset_filter
        if payment_details_filter is _DEFAULT:
            self.payment_details_filter = None
        else:
            self.payment_details_filter = payment_details_filter
        if from_timestamp is _DEFAULT:
            self.from_timestamp = None
        else:
            self.from_timestamp = from_timestamp
        if to_timestamp is _DEFAULT:
            self.to_timestamp = None
        else:
            self.to_timestamp = to_timestamp
        if offset is _DEFAULT:
            self.offset = None
        else:
            self.offset = offset
        if limit is _DEFAULT:
            self.limit = None
        else:
            self.limit = limit
        if sort_ascending is _DEFAULT:
            self.sort_ascending = None
        else:
            self.sort_ascending = sort_ascending

    def __str__(self):
        return "ListPaymentsRequest(type_filter={}, status_filter={}, asset_filter={}, payment_details_filter={}, from_timestamp={}, to_timestamp={}, offset={}, limit={}, sort_ascending={})".format(self.type_filter, self.status_filter, self.asset_filter, self.payment_details_filter, self.from_timestamp, self.to_timestamp, self.offset, self.limit, self.sort_ascending)

    def __eq__(self, other):
        if self.type_filter != other.type_filter:
            return False
        if self.status_filter != other.status_filter:
            return False
        if self.asset_filter != other.asset_filter:
            return False
        if self.payment_details_filter != other.payment_details_filter:
            return False
        if self.from_timestamp != other.from_timestamp:
            return False
        if self.to_timestamp != other.to_timestamp:
            return False
        if self.offset != other.offset:
            return False
        if self.limit != other.limit:
            return False
        if self.sort_ascending != other.sort_ascending:
            return False
        return True

class _UniffiConverterTypeListPaymentsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListPaymentsRequest(
            type_filter=_UniffiConverterOptionalSequenceTypePaymentType.read(buf),
            status_filter=_UniffiConverterOptionalSequenceTypePaymentStatus.read(buf),
            asset_filter=_UniffiConverterOptionalTypeAssetFilter.read(buf),
            payment_details_filter=_UniffiConverterOptionalSequenceTypePaymentDetailsFilter.read(buf),
            from_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            to_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            offset=_UniffiConverterOptionalUInt32.read(buf),
            limit=_UniffiConverterOptionalUInt32.read(buf),
            sort_ascending=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypePaymentType.check_lower(value.type_filter)
        _UniffiConverterOptionalSequenceTypePaymentStatus.check_lower(value.status_filter)
        _UniffiConverterOptionalTypeAssetFilter.check_lower(value.asset_filter)
        _UniffiConverterOptionalSequenceTypePaymentDetailsFilter.check_lower(value.payment_details_filter)
        _UniffiConverterOptionalUInt64.check_lower(value.from_timestamp)
        _UniffiConverterOptionalUInt64.check_lower(value.to_timestamp)
        _UniffiConverterOptionalUInt32.check_lower(value.offset)
        _UniffiConverterOptionalUInt32.check_lower(value.limit)
        _UniffiConverterOptionalBool.check_lower(value.sort_ascending)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypePaymentType.write(value.type_filter, buf)
        _UniffiConverterOptionalSequenceTypePaymentStatus.write(value.status_filter, buf)
        _UniffiConverterOptionalTypeAssetFilter.write(value.asset_filter, buf)
        _UniffiConverterOptionalSequenceTypePaymentDetailsFilter.write(value.payment_details_filter, buf)
        _UniffiConverterOptionalUInt64.write(value.from_timestamp, buf)
        _UniffiConverterOptionalUInt64.write(value.to_timestamp, buf)
        _UniffiConverterOptionalUInt32.write(value.offset, buf)
        _UniffiConverterOptionalUInt32.write(value.limit, buf)
        _UniffiConverterOptionalBool.write(value.sort_ascending, buf)


class ListPaymentsResponse:
    """
    Response from listing payments
    """

    payments: "typing.List[Payment]"
    """
    The list of payments
    """

    def __init__(self, *, payments: "typing.List[Payment]"):
        self.payments = payments

    def __str__(self):
        return "ListPaymentsResponse(payments={})".format(self.payments)

    def __eq__(self, other):
        if self.payments != other.payments:
            return False
        return True

class _UniffiConverterTypeListPaymentsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListPaymentsResponse(
            payments=_UniffiConverterSequenceTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePayment.check_lower(value.payments)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePayment.write(value.payments, buf)


class ListUnclaimedDepositsRequest:

    def __str__(self):
        return "ListUnclaimedDepositsRequest()".format()

    def __eq__(self, other):
        return True

class _UniffiConverterTypeListUnclaimedDepositsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListUnclaimedDepositsRequest(
        )

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        pass


class ListUnclaimedDepositsResponse:
    deposits: "typing.List[DepositInfo]"
    def __init__(self, *, deposits: "typing.List[DepositInfo]"):
        self.deposits = deposits

    def __str__(self):
        return "ListUnclaimedDepositsResponse(deposits={})".format(self.deposits)

    def __eq__(self, other):
        if self.deposits != other.deposits:
            return False
        return True

class _UniffiConverterTypeListUnclaimedDepositsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListUnclaimedDepositsResponse(
            deposits=_UniffiConverterSequenceTypeDepositInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeDepositInfo.check_lower(value.deposits)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeDepositInfo.write(value.deposits, buf)


class LnurlAuthRequestDetails:
    """
    Wrapped in a [`InputType::LnurlAuth`], this is the result of [`parse`](breez_sdk_common::input::parse) when given a LNURL-auth endpoint.

    It represents the endpoint's parameters for the LNURL workflow.

    See <https://github.com/lnurl/luds/blob/luds/04.md>
    """

    k1: "str"
    """
    Hex encoded 32 bytes of challenge
    """

    action: "typing.Optional[str]"
    """
    When available, one of: register, login, link, auth
    """

    domain: "str"
    """
    Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
    auth confirmation, as per LUD-04 spec.
    """

    url: "str"
    """
    Indicates the URL of the LNURL-auth service, including the query arguments. This will be
    extended with the signed challenge and the linking key, then called in the second step of the workflow.
    """

    def __init__(self, *, k1: "str", action: "typing.Optional[str]", domain: "str", url: "str"):
        self.k1 = k1
        self.action = action
        self.domain = domain
        self.url = url

    def __str__(self):
        return "LnurlAuthRequestDetails(k1={}, action={}, domain={}, url={})".format(self.k1, self.action, self.domain, self.url)

    def __eq__(self, other):
        if self.k1 != other.k1:
            return False
        if self.action != other.action:
            return False
        if self.domain != other.domain:
            return False
        if self.url != other.url:
            return False
        return True

class _UniffiConverterTypeLnurlAuthRequestDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlAuthRequestDetails(
            k1=_UniffiConverterString.read(buf),
            action=_UniffiConverterOptionalString.read(buf),
            domain=_UniffiConverterString.read(buf),
            url=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.k1)
        _UniffiConverterOptionalString.check_lower(value.action)
        _UniffiConverterString.check_lower(value.domain)
        _UniffiConverterString.check_lower(value.url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.k1, buf)
        _UniffiConverterOptionalString.write(value.action, buf)
        _UniffiConverterString.write(value.domain, buf)
        _UniffiConverterString.write(value.url, buf)


class LnurlPayInfo:
    """
    Represents the payment LNURL info
    """

    ln_address: "typing.Optional[str]"
    comment: "typing.Optional[str]"
    domain: "typing.Optional[str]"
    metadata: "typing.Optional[str]"
    processed_success_action: "typing.Optional[SuccessActionProcessed]"
    raw_success_action: "typing.Optional[SuccessAction]"
    def __init__(self, *, ln_address: "typing.Optional[str]", comment: "typing.Optional[str]", domain: "typing.Optional[str]", metadata: "typing.Optional[str]", processed_success_action: "typing.Optional[SuccessActionProcessed]", raw_success_action: "typing.Optional[SuccessAction]"):
        self.ln_address = ln_address
        self.comment = comment
        self.domain = domain
        self.metadata = metadata
        self.processed_success_action = processed_success_action
        self.raw_success_action = raw_success_action

    def __str__(self):
        return "LnurlPayInfo(ln_address={}, comment={}, domain={}, metadata={}, processed_success_action={}, raw_success_action={})".format(self.ln_address, self.comment, self.domain, self.metadata, self.processed_success_action, self.raw_success_action)

    def __eq__(self, other):
        if self.ln_address != other.ln_address:
            return False
        if self.comment != other.comment:
            return False
        if self.domain != other.domain:
            return False
        if self.metadata != other.metadata:
            return False
        if self.processed_success_action != other.processed_success_action:
            return False
        if self.raw_success_action != other.raw_success_action:
            return False
        return True

class _UniffiConverterTypeLnurlPayInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlPayInfo(
            ln_address=_UniffiConverterOptionalString.read(buf),
            comment=_UniffiConverterOptionalString.read(buf),
            domain=_UniffiConverterOptionalString.read(buf),
            metadata=_UniffiConverterOptionalString.read(buf),
            processed_success_action=_UniffiConverterOptionalTypeSuccessActionProcessed.read(buf),
            raw_success_action=_UniffiConverterOptionalTypeSuccessAction.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.ln_address)
        _UniffiConverterOptionalString.check_lower(value.comment)
        _UniffiConverterOptionalString.check_lower(value.domain)
        _UniffiConverterOptionalString.check_lower(value.metadata)
        _UniffiConverterOptionalTypeSuccessActionProcessed.check_lower(value.processed_success_action)
        _UniffiConverterOptionalTypeSuccessAction.check_lower(value.raw_success_action)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.ln_address, buf)
        _UniffiConverterOptionalString.write(value.comment, buf)
        _UniffiConverterOptionalString.write(value.domain, buf)
        _UniffiConverterOptionalString.write(value.metadata, buf)
        _UniffiConverterOptionalTypeSuccessActionProcessed.write(value.processed_success_action, buf)
        _UniffiConverterOptionalTypeSuccessAction.write(value.raw_success_action, buf)


class LnurlPayRequest:
    prepare_response: "PrepareLnurlPayResponse"
    idempotency_key: "typing.Optional[str]"
    """
    If set, providing the same idempotency key for multiple requests will ensure that only one
    payment is made. If an idempotency key is re-used, the same payment will be returned.
    The idempotency key must be a valid UUID.
    """

    def __init__(self, *, prepare_response: "PrepareLnurlPayResponse", idempotency_key: "typing.Optional[str]" = _DEFAULT):
        self.prepare_response = prepare_response
        if idempotency_key is _DEFAULT:
            self.idempotency_key = None
        else:
            self.idempotency_key = idempotency_key

    def __str__(self):
        return "LnurlPayRequest(prepare_response={}, idempotency_key={})".format(self.prepare_response, self.idempotency_key)

    def __eq__(self, other):
        if self.prepare_response != other.prepare_response:
            return False
        if self.idempotency_key != other.idempotency_key:
            return False
        return True

class _UniffiConverterTypeLnurlPayRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlPayRequest(
            prepare_response=_UniffiConverterTypePrepareLnurlPayResponse.read(buf),
            idempotency_key=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePrepareLnurlPayResponse.check_lower(value.prepare_response)
        _UniffiConverterOptionalString.check_lower(value.idempotency_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePrepareLnurlPayResponse.write(value.prepare_response, buf)
        _UniffiConverterOptionalString.write(value.idempotency_key, buf)


class LnurlPayRequestDetails:
    callback: "str"
    min_sendable: "int"
    """
    The minimum amount, in millisats, that this LNURL-pay endpoint accepts
    """

    max_sendable: "int"
    """
    The maximum amount, in millisats, that this LNURL-pay endpoint accepts
    """

    metadata_str: "str"
    """
    As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
    Use `metadata_vec()` to get the parsed items.
    """

    comment_allowed: "int"
    """
    The comment length accepted by this endpoint

    See <https://github.com/lnurl/luds/blob/luds/12.md>
    """

    domain: "str"
    """
    Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
    payment input, as per LUD-06 spec.

    Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
    """

    url: "str"
    address: "typing.Optional[str]"
    """
    Optional lightning address if that was used to resolve the lnurl.
    """

    allows_nostr: "typing.Optional[bool]"
    """
    Value indicating whether the recipient supports Nostr Zaps through NIP-57.

    See <https://github.com/nostr-protocol/nips/blob/master/57.md>
    """

    nostr_pubkey: "typing.Optional[str]"
    """
    Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
    valid BIP 340 public key in hex.

    See <https://github.com/nostr-protocol/nips/blob/master/57.md>
    See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
    """

    def __init__(self, *, callback: "str", min_sendable: "int", max_sendable: "int", metadata_str: "str", comment_allowed: "int", domain: "str", url: "str", address: "typing.Optional[str]", allows_nostr: "typing.Optional[bool]", nostr_pubkey: "typing.Optional[str]"):
        self.callback = callback
        self.min_sendable = min_sendable
        self.max_sendable = max_sendable
        self.metadata_str = metadata_str
        self.comment_allowed = comment_allowed
        self.domain = domain
        self.url = url
        self.address = address
        self.allows_nostr = allows_nostr
        self.nostr_pubkey = nostr_pubkey

    def __str__(self):
        return "LnurlPayRequestDetails(callback={}, min_sendable={}, max_sendable={}, metadata_str={}, comment_allowed={}, domain={}, url={}, address={}, allows_nostr={}, nostr_pubkey={})".format(self.callback, self.min_sendable, self.max_sendable, self.metadata_str, self.comment_allowed, self.domain, self.url, self.address, self.allows_nostr, self.nostr_pubkey)

    def __eq__(self, other):
        if self.callback != other.callback:
            return False
        if self.min_sendable != other.min_sendable:
            return False
        if self.max_sendable != other.max_sendable:
            return False
        if self.metadata_str != other.metadata_str:
            return False
        if self.comment_allowed != other.comment_allowed:
            return False
        if self.domain != other.domain:
            return False
        if self.url != other.url:
            return False
        if self.address != other.address:
            return False
        if self.allows_nostr != other.allows_nostr:
            return False
        if self.nostr_pubkey != other.nostr_pubkey:
            return False
        return True

class _UniffiConverterTypeLnurlPayRequestDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlPayRequestDetails(
            callback=_UniffiConverterString.read(buf),
            min_sendable=_UniffiConverterUInt64.read(buf),
            max_sendable=_UniffiConverterUInt64.read(buf),
            metadata_str=_UniffiConverterString.read(buf),
            comment_allowed=_UniffiConverterUInt16.read(buf),
            domain=_UniffiConverterString.read(buf),
            url=_UniffiConverterString.read(buf),
            address=_UniffiConverterOptionalString.read(buf),
            allows_nostr=_UniffiConverterOptionalBool.read(buf),
            nostr_pubkey=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.callback)
        _UniffiConverterUInt64.check_lower(value.min_sendable)
        _UniffiConverterUInt64.check_lower(value.max_sendable)
        _UniffiConverterString.check_lower(value.metadata_str)
        _UniffiConverterUInt16.check_lower(value.comment_allowed)
        _UniffiConverterString.check_lower(value.domain)
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterOptionalString.check_lower(value.address)
        _UniffiConverterOptionalBool.check_lower(value.allows_nostr)
        _UniffiConverterOptionalString.check_lower(value.nostr_pubkey)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.callback, buf)
        _UniffiConverterUInt64.write(value.min_sendable, buf)
        _UniffiConverterUInt64.write(value.max_sendable, buf)
        _UniffiConverterString.write(value.metadata_str, buf)
        _UniffiConverterUInt16.write(value.comment_allowed, buf)
        _UniffiConverterString.write(value.domain, buf)
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterOptionalString.write(value.address, buf)
        _UniffiConverterOptionalBool.write(value.allows_nostr, buf)
        _UniffiConverterOptionalString.write(value.nostr_pubkey, buf)


class LnurlPayResponse:
    payment: "Payment"
    success_action: "typing.Optional[SuccessActionProcessed]"
    def __init__(self, *, payment: "Payment", success_action: "typing.Optional[SuccessActionProcessed]"):
        self.payment = payment
        self.success_action = success_action

    def __str__(self):
        return "LnurlPayResponse(payment={}, success_action={})".format(self.payment, self.success_action)

    def __eq__(self, other):
        if self.payment != other.payment:
            return False
        if self.success_action != other.success_action:
            return False
        return True

class _UniffiConverterTypeLnurlPayResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlPayResponse(
            payment=_UniffiConverterTypePayment.read(buf),
            success_action=_UniffiConverterOptionalTypeSuccessActionProcessed.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePayment.check_lower(value.payment)
        _UniffiConverterOptionalTypeSuccessActionProcessed.check_lower(value.success_action)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePayment.write(value.payment, buf)
        _UniffiConverterOptionalTypeSuccessActionProcessed.write(value.success_action, buf)


class LnurlReceiveMetadata:
    nostr_zap_request: "typing.Optional[str]"
    nostr_zap_receipt: "typing.Optional[str]"
    sender_comment: "typing.Optional[str]"
    def __init__(self, *, nostr_zap_request: "typing.Optional[str]", nostr_zap_receipt: "typing.Optional[str]", sender_comment: "typing.Optional[str]"):
        self.nostr_zap_request = nostr_zap_request
        self.nostr_zap_receipt = nostr_zap_receipt
        self.sender_comment = sender_comment

    def __str__(self):
        return "LnurlReceiveMetadata(nostr_zap_request={}, nostr_zap_receipt={}, sender_comment={})".format(self.nostr_zap_request, self.nostr_zap_receipt, self.sender_comment)

    def __eq__(self, other):
        if self.nostr_zap_request != other.nostr_zap_request:
            return False
        if self.nostr_zap_receipt != other.nostr_zap_receipt:
            return False
        if self.sender_comment != other.sender_comment:
            return False
        return True

class _UniffiConverterTypeLnurlReceiveMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlReceiveMetadata(
            nostr_zap_request=_UniffiConverterOptionalString.read(buf),
            nostr_zap_receipt=_UniffiConverterOptionalString.read(buf),
            sender_comment=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.nostr_zap_request)
        _UniffiConverterOptionalString.check_lower(value.nostr_zap_receipt)
        _UniffiConverterOptionalString.check_lower(value.sender_comment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.nostr_zap_request, buf)
        _UniffiConverterOptionalString.write(value.nostr_zap_receipt, buf)
        _UniffiConverterOptionalString.write(value.sender_comment, buf)


class LnurlWithdrawInfo:
    """
    Represents the withdraw LNURL info
    """

    withdraw_url: "str"
    def __init__(self, *, withdraw_url: "str"):
        self.withdraw_url = withdraw_url

    def __str__(self):
        return "LnurlWithdrawInfo(withdraw_url={})".format(self.withdraw_url)

    def __eq__(self, other):
        if self.withdraw_url != other.withdraw_url:
            return False
        return True

class _UniffiConverterTypeLnurlWithdrawInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlWithdrawInfo(
            withdraw_url=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.withdraw_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.withdraw_url, buf)


class LnurlWithdrawRequest:
    amount_sats: "int"
    """
    The amount to withdraw in satoshis
    Must be within the min and max withdrawable limits
    """

    withdraw_request: "LnurlWithdrawRequestDetails"
    completion_timeout_secs: "typing.Optional[int]"
    """
    If set, the function will return the payment if it is still pending after this
    number of seconds. If unset, the function will return immediately after
    initiating the LNURL withdraw.
    """

    def __init__(self, *, amount_sats: "int", withdraw_request: "LnurlWithdrawRequestDetails", completion_timeout_secs: "typing.Optional[int]" = _DEFAULT):
        self.amount_sats = amount_sats
        self.withdraw_request = withdraw_request
        if completion_timeout_secs is _DEFAULT:
            self.completion_timeout_secs = None
        else:
            self.completion_timeout_secs = completion_timeout_secs

    def __str__(self):
        return "LnurlWithdrawRequest(amount_sats={}, withdraw_request={}, completion_timeout_secs={})".format(self.amount_sats, self.withdraw_request, self.completion_timeout_secs)

    def __eq__(self, other):
        if self.amount_sats != other.amount_sats:
            return False
        if self.withdraw_request != other.withdraw_request:
            return False
        if self.completion_timeout_secs != other.completion_timeout_secs:
            return False
        return True

class _UniffiConverterTypeLnurlWithdrawRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlWithdrawRequest(
            amount_sats=_UniffiConverterUInt64.read(buf),
            withdraw_request=_UniffiConverterTypeLnurlWithdrawRequestDetails.read(buf),
            completion_timeout_secs=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount_sats)
        _UniffiConverterTypeLnurlWithdrawRequestDetails.check_lower(value.withdraw_request)
        _UniffiConverterOptionalUInt32.check_lower(value.completion_timeout_secs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount_sats, buf)
        _UniffiConverterTypeLnurlWithdrawRequestDetails.write(value.withdraw_request, buf)
        _UniffiConverterOptionalUInt32.write(value.completion_timeout_secs, buf)


class LnurlWithdrawRequestDetails:
    callback: "str"
    k1: "str"
    default_description: "str"
    min_withdrawable: "int"
    """
    The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
    """

    max_withdrawable: "int"
    """
    The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
    """

    def __init__(self, *, callback: "str", k1: "str", default_description: "str", min_withdrawable: "int", max_withdrawable: "int"):
        self.callback = callback
        self.k1 = k1
        self.default_description = default_description
        self.min_withdrawable = min_withdrawable
        self.max_withdrawable = max_withdrawable

    def __str__(self):
        return "LnurlWithdrawRequestDetails(callback={}, k1={}, default_description={}, min_withdrawable={}, max_withdrawable={})".format(self.callback, self.k1, self.default_description, self.min_withdrawable, self.max_withdrawable)

    def __eq__(self, other):
        if self.callback != other.callback:
            return False
        if self.k1 != other.k1:
            return False
        if self.default_description != other.default_description:
            return False
        if self.min_withdrawable != other.min_withdrawable:
            return False
        if self.max_withdrawable != other.max_withdrawable:
            return False
        return True

class _UniffiConverterTypeLnurlWithdrawRequestDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlWithdrawRequestDetails(
            callback=_UniffiConverterString.read(buf),
            k1=_UniffiConverterString.read(buf),
            default_description=_UniffiConverterString.read(buf),
            min_withdrawable=_UniffiConverterUInt64.read(buf),
            max_withdrawable=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.callback)
        _UniffiConverterString.check_lower(value.k1)
        _UniffiConverterString.check_lower(value.default_description)
        _UniffiConverterUInt64.check_lower(value.min_withdrawable)
        _UniffiConverterUInt64.check_lower(value.max_withdrawable)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.callback, buf)
        _UniffiConverterString.write(value.k1, buf)
        _UniffiConverterString.write(value.default_description, buf)
        _UniffiConverterUInt64.write(value.min_withdrawable, buf)
        _UniffiConverterUInt64.write(value.max_withdrawable, buf)


class LnurlWithdrawResponse:
    payment_request: "str"
    """
    The Lightning invoice generated for the LNURL withdraw
    """

    payment: "typing.Optional[Payment]"
    def __init__(self, *, payment_request: "str", payment: "typing.Optional[Payment]"):
        self.payment_request = payment_request
        self.payment = payment

    def __str__(self):
        return "LnurlWithdrawResponse(payment_request={}, payment={})".format(self.payment_request, self.payment)

    def __eq__(self, other):
        if self.payment_request != other.payment_request:
            return False
        if self.payment != other.payment:
            return False
        return True

class _UniffiConverterTypeLnurlWithdrawResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LnurlWithdrawResponse(
            payment_request=_UniffiConverterString.read(buf),
            payment=_UniffiConverterOptionalTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_request)
        _UniffiConverterOptionalTypePayment.check_lower(value.payment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_request, buf)
        _UniffiConverterOptionalTypePayment.write(value.payment, buf)


class LocaleOverrides:
    """
    Locale-specific settings for the representation of a currency
    """

    locale: "str"
    spacing: "typing.Optional[int]"
    symbol: "Symbol"
    def __init__(self, *, locale: "str", spacing: "typing.Optional[int]", symbol: "Symbol"):
        self.locale = locale
        self.spacing = spacing
        self.symbol = symbol

    def __str__(self):
        return "LocaleOverrides(locale={}, spacing={}, symbol={})".format(self.locale, self.spacing, self.symbol)

    def __eq__(self, other):
        if self.locale != other.locale:
            return False
        if self.spacing != other.spacing:
            return False
        if self.symbol != other.symbol:
            return False
        return True

class _UniffiConverterTypeLocaleOverrides(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocaleOverrides(
            locale=_UniffiConverterString.read(buf),
            spacing=_UniffiConverterOptionalUInt32.read(buf),
            symbol=_UniffiConverterTypeSymbol.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.locale)
        _UniffiConverterOptionalUInt32.check_lower(value.spacing)
        _UniffiConverterTypeSymbol.check_lower(value.symbol)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.locale, buf)
        _UniffiConverterOptionalUInt32.write(value.spacing, buf)
        _UniffiConverterTypeSymbol.write(value.symbol, buf)


class LocalizedName:
    """
    Localized name of a currency
    """

    locale: "str"
    name: "str"
    def __init__(self, *, locale: "str", name: "str"):
        self.locale = locale
        self.name = name

    def __str__(self):
        return "LocalizedName(locale={}, name={})".format(self.locale, self.name)

    def __eq__(self, other):
        if self.locale != other.locale:
            return False
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeLocalizedName(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalizedName(
            locale=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.locale)
        _UniffiConverterString.check_lower(value.name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.locale, buf)
        _UniffiConverterString.write(value.name, buf)


class LogEntry:
    line: "str"
    level: "str"
    def __init__(self, *, line: "str", level: "str"):
        self.line = line
        self.level = level

    def __str__(self):
        return "LogEntry(line={}, level={})".format(self.line, self.level)

    def __eq__(self, other):
        if self.line != other.line:
            return False
        if self.level != other.level:
            return False
        return True

class _UniffiConverterTypeLogEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LogEntry(
            line=_UniffiConverterString.read(buf),
            level=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.line)
        _UniffiConverterString.check_lower(value.level)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.line, buf)
        _UniffiConverterString.write(value.level, buf)


class MessageSuccessActionData:
    message: "str"
    def __init__(self, *, message: "str"):
        self.message = message

    def __str__(self):
        return "MessageSuccessActionData(message={})".format(self.message)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        return True

class _UniffiConverterTypeMessageSuccessActionData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MessageSuccessActionData(
            message=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.message, buf)


class MintIssuerTokenRequest:
    amount: "U128"
    def __init__(self, *, amount: "U128"):
        self.amount = amount

    def __str__(self):
        return "MintIssuerTokenRequest(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeMintIssuerTokenRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MintIssuerTokenRequest(
            amount=_UniffiConverterTypeU128.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeU128.check_lower(value.amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeU128.write(value.amount, buf)


class OptimizationConfig:
    auto_enabled: "bool"
    """
    Whether automatic leaf optimization is enabled.

    If set to true, the SDK will automatically optimize the leaf set when it changes.
    Otherwise, the manual optimization API must be used to optimize the leaf set.

    Default value is true.
    """

    multiplicity: "int"
    """
    The desired multiplicity for the leaf set. Acceptable values are 0-5.

    Setting this to 0 will optimize for maximizing unilateral exit.
    Higher values will optimize for minimizing transfer swaps, with higher values
    being more aggressive.

    Default value is 1.
    """

    def __init__(self, *, auto_enabled: "bool", multiplicity: "int"):
        self.auto_enabled = auto_enabled
        self.multiplicity = multiplicity

    def __str__(self):
        return "OptimizationConfig(auto_enabled={}, multiplicity={})".format(self.auto_enabled, self.multiplicity)

    def __eq__(self, other):
        if self.auto_enabled != other.auto_enabled:
            return False
        if self.multiplicity != other.multiplicity:
            return False
        return True

class _UniffiConverterTypeOptimizationConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OptimizationConfig(
            auto_enabled=_UniffiConverterBool.read(buf),
            multiplicity=_UniffiConverterUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.auto_enabled)
        _UniffiConverterUInt8.check_lower(value.multiplicity)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.auto_enabled, buf)
        _UniffiConverterUInt8.write(value.multiplicity, buf)


class OptimizationProgress:
    is_running: "bool"
    current_round: "int"
    total_rounds: "int"
    def __init__(self, *, is_running: "bool", current_round: "int", total_rounds: "int"):
        self.is_running = is_running
        self.current_round = current_round
        self.total_rounds = total_rounds

    def __str__(self):
        return "OptimizationProgress(is_running={}, current_round={}, total_rounds={})".format(self.is_running, self.current_round, self.total_rounds)

    def __eq__(self, other):
        if self.is_running != other.is_running:
            return False
        if self.current_round != other.current_round:
            return False
        if self.total_rounds != other.total_rounds:
            return False
        return True

class _UniffiConverterTypeOptimizationProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OptimizationProgress(
            is_running=_UniffiConverterBool.read(buf),
            current_round=_UniffiConverterUInt32.read(buf),
            total_rounds=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.is_running)
        _UniffiConverterUInt32.check_lower(value.current_round)
        _UniffiConverterUInt32.check_lower(value.total_rounds)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.is_running, buf)
        _UniffiConverterUInt32.write(value.current_round, buf)
        _UniffiConverterUInt32.write(value.total_rounds, buf)


class OutgoingChange:
    change: "RecordChange"
    parent: "typing.Optional[Record]"
    def __init__(self, *, change: "RecordChange", parent: "typing.Optional[Record]"):
        self.change = change
        self.parent = parent

    def __str__(self):
        return "OutgoingChange(change={}, parent={})".format(self.change, self.parent)

    def __eq__(self, other):
        if self.change != other.change:
            return False
        if self.parent != other.parent:
            return False
        return True

class _UniffiConverterTypeOutgoingChange(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OutgoingChange(
            change=_UniffiConverterTypeRecordChange.read(buf),
            parent=_UniffiConverterOptionalTypeRecord.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeRecordChange.check_lower(value.change)
        _UniffiConverterOptionalTypeRecord.check_lower(value.parent)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeRecordChange.write(value.change, buf)
        _UniffiConverterOptionalTypeRecord.write(value.parent, buf)


class Payment:
    """
    Represents a payment (sent or received)
    """

    id: "str"
    """
    Unique identifier for the payment
    """

    payment_type: "PaymentType"
    """
    Type of payment (send or receive)
    """

    status: "PaymentStatus"
    """
    Status of the payment
    """

    amount: "U128"
    """
    Amount in satoshis or token base units
    """

    fees: "U128"
    """
    Fee paid in satoshis or token base units
    """

    timestamp: "int"
    """
    Timestamp of when the payment was created
    """

    method: "PaymentMethod"
    """
    Method of payment. Sometimes the payment details is empty so this field
    is used to determine the payment method.
    """

    details: "typing.Optional[PaymentDetails]"
    """
    Details of the payment
    """

    def __init__(self, *, id: "str", payment_type: "PaymentType", status: "PaymentStatus", amount: "U128", fees: "U128", timestamp: "int", method: "PaymentMethod", details: "typing.Optional[PaymentDetails]"):
        self.id = id
        self.payment_type = payment_type
        self.status = status
        self.amount = amount
        self.fees = fees
        self.timestamp = timestamp
        self.method = method
        self.details = details

    def __str__(self):
        return "Payment(id={}, payment_type={}, status={}, amount={}, fees={}, timestamp={}, method={}, details={})".format(self.id, self.payment_type, self.status, self.amount, self.fees, self.timestamp, self.method, self.details)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.payment_type != other.payment_type:
            return False
        if self.status != other.status:
            return False
        if self.amount != other.amount:
            return False
        if self.fees != other.fees:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.method != other.method:
            return False
        if self.details != other.details:
            return False
        return True

class _UniffiConverterTypePayment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Payment(
            id=_UniffiConverterString.read(buf),
            payment_type=_UniffiConverterTypePaymentType.read(buf),
            status=_UniffiConverterTypePaymentStatus.read(buf),
            amount=_UniffiConverterTypeU128.read(buf),
            fees=_UniffiConverterTypeU128.read(buf),
            timestamp=_UniffiConverterUInt64.read(buf),
            method=_UniffiConverterTypePaymentMethod.read(buf),
            details=_UniffiConverterOptionalTypePaymentDetails.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterTypePaymentType.check_lower(value.payment_type)
        _UniffiConverterTypePaymentStatus.check_lower(value.status)
        _UniffiConverterTypeU128.check_lower(value.amount)
        _UniffiConverterTypeU128.check_lower(value.fees)
        _UniffiConverterUInt64.check_lower(value.timestamp)
        _UniffiConverterTypePaymentMethod.check_lower(value.method)
        _UniffiConverterOptionalTypePaymentDetails.check_lower(value.details)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterTypePaymentType.write(value.payment_type, buf)
        _UniffiConverterTypePaymentStatus.write(value.status, buf)
        _UniffiConverterTypeU128.write(value.amount, buf)
        _UniffiConverterTypeU128.write(value.fees, buf)
        _UniffiConverterUInt64.write(value.timestamp, buf)
        _UniffiConverterTypePaymentMethod.write(value.method, buf)
        _UniffiConverterOptionalTypePaymentDetails.write(value.details, buf)


class PaymentMetadata:
    """
    Metadata associated with a payment that cannot be extracted from the Spark operator.
    """

    parent_payment_id: "typing.Optional[str]"
    lnurl_pay_info: "typing.Optional[LnurlPayInfo]"
    lnurl_withdraw_info: "typing.Optional[LnurlWithdrawInfo]"
    lnurl_description: "typing.Optional[str]"
    token_conversion_info: "typing.Optional[TokenConversionInfo]"
    def __init__(self, *, parent_payment_id: "typing.Optional[str]", lnurl_pay_info: "typing.Optional[LnurlPayInfo]", lnurl_withdraw_info: "typing.Optional[LnurlWithdrawInfo]", lnurl_description: "typing.Optional[str]", token_conversion_info: "typing.Optional[TokenConversionInfo]"):
        self.parent_payment_id = parent_payment_id
        self.lnurl_pay_info = lnurl_pay_info
        self.lnurl_withdraw_info = lnurl_withdraw_info
        self.lnurl_description = lnurl_description
        self.token_conversion_info = token_conversion_info

    def __str__(self):
        return "PaymentMetadata(parent_payment_id={}, lnurl_pay_info={}, lnurl_withdraw_info={}, lnurl_description={}, token_conversion_info={})".format(self.parent_payment_id, self.lnurl_pay_info, self.lnurl_withdraw_info, self.lnurl_description, self.token_conversion_info)

    def __eq__(self, other):
        if self.parent_payment_id != other.parent_payment_id:
            return False
        if self.lnurl_pay_info != other.lnurl_pay_info:
            return False
        if self.lnurl_withdraw_info != other.lnurl_withdraw_info:
            return False
        if self.lnurl_description != other.lnurl_description:
            return False
        if self.token_conversion_info != other.token_conversion_info:
            return False
        return True

class _UniffiConverterTypePaymentMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentMetadata(
            parent_payment_id=_UniffiConverterOptionalString.read(buf),
            lnurl_pay_info=_UniffiConverterOptionalTypeLnurlPayInfo.read(buf),
            lnurl_withdraw_info=_UniffiConverterOptionalTypeLnurlWithdrawInfo.read(buf),
            lnurl_description=_UniffiConverterOptionalString.read(buf),
            token_conversion_info=_UniffiConverterOptionalTypeTokenConversionInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.parent_payment_id)
        _UniffiConverterOptionalTypeLnurlPayInfo.check_lower(value.lnurl_pay_info)
        _UniffiConverterOptionalTypeLnurlWithdrawInfo.check_lower(value.lnurl_withdraw_info)
        _UniffiConverterOptionalString.check_lower(value.lnurl_description)
        _UniffiConverterOptionalTypeTokenConversionInfo.check_lower(value.token_conversion_info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.parent_payment_id, buf)
        _UniffiConverterOptionalTypeLnurlPayInfo.write(value.lnurl_pay_info, buf)
        _UniffiConverterOptionalTypeLnurlWithdrawInfo.write(value.lnurl_withdraw_info, buf)
        _UniffiConverterOptionalString.write(value.lnurl_description, buf)
        _UniffiConverterOptionalTypeTokenConversionInfo.write(value.token_conversion_info, buf)


class PaymentRequestSource:
    bip_21_uri: "typing.Optional[str]"
    bip_353_address: "typing.Optional[str]"
    def __init__(self, *, bip_21_uri: "typing.Optional[str]", bip_353_address: "typing.Optional[str]"):
        self.bip_21_uri = bip_21_uri
        self.bip_353_address = bip_353_address

    def __str__(self):
        return "PaymentRequestSource(bip_21_uri={}, bip_353_address={})".format(self.bip_21_uri, self.bip_353_address)

    def __eq__(self, other):
        if self.bip_21_uri != other.bip_21_uri:
            return False
        if self.bip_353_address != other.bip_353_address:
            return False
        return True

class _UniffiConverterTypePaymentRequestSource(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentRequestSource(
            bip_21_uri=_UniffiConverterOptionalString.read(buf),
            bip_353_address=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.bip_21_uri)
        _UniffiConverterOptionalString.check_lower(value.bip_353_address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.bip_21_uri, buf)
        _UniffiConverterOptionalString.write(value.bip_353_address, buf)


class PrepareLnurlPayRequest:
    amount_sats: "int"
    pay_request: "LnurlPayRequestDetails"
    comment: "typing.Optional[str]"
    validate_success_action_url: "typing.Optional[bool]"
    def __init__(self, *, amount_sats: "int", pay_request: "LnurlPayRequestDetails", comment: "typing.Optional[str]" = _DEFAULT, validate_success_action_url: "typing.Optional[bool]" = _DEFAULT):
        self.amount_sats = amount_sats
        self.pay_request = pay_request
        if comment is _DEFAULT:
            self.comment = None
        else:
            self.comment = comment
        if validate_success_action_url is _DEFAULT:
            self.validate_success_action_url = None
        else:
            self.validate_success_action_url = validate_success_action_url

    def __str__(self):
        return "PrepareLnurlPayRequest(amount_sats={}, pay_request={}, comment={}, validate_success_action_url={})".format(self.amount_sats, self.pay_request, self.comment, self.validate_success_action_url)

    def __eq__(self, other):
        if self.amount_sats != other.amount_sats:
            return False
        if self.pay_request != other.pay_request:
            return False
        if self.comment != other.comment:
            return False
        if self.validate_success_action_url != other.validate_success_action_url:
            return False
        return True

class _UniffiConverterTypePrepareLnurlPayRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareLnurlPayRequest(
            amount_sats=_UniffiConverterUInt64.read(buf),
            pay_request=_UniffiConverterTypeLnurlPayRequestDetails.read(buf),
            comment=_UniffiConverterOptionalString.read(buf),
            validate_success_action_url=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount_sats)
        _UniffiConverterTypeLnurlPayRequestDetails.check_lower(value.pay_request)
        _UniffiConverterOptionalString.check_lower(value.comment)
        _UniffiConverterOptionalBool.check_lower(value.validate_success_action_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount_sats, buf)
        _UniffiConverterTypeLnurlPayRequestDetails.write(value.pay_request, buf)
        _UniffiConverterOptionalString.write(value.comment, buf)
        _UniffiConverterOptionalBool.write(value.validate_success_action_url, buf)


class PrepareLnurlPayResponse:
    amount_sats: "int"
    comment: "typing.Optional[str]"
    pay_request: "LnurlPayRequestDetails"
    fee_sats: "int"
    invoice_details: "Bolt11InvoiceDetails"
    success_action: "typing.Optional[SuccessAction]"
    def __init__(self, *, amount_sats: "int", comment: "typing.Optional[str]", pay_request: "LnurlPayRequestDetails", fee_sats: "int", invoice_details: "Bolt11InvoiceDetails", success_action: "typing.Optional[SuccessAction]"):
        self.amount_sats = amount_sats
        self.comment = comment
        self.pay_request = pay_request
        self.fee_sats = fee_sats
        self.invoice_details = invoice_details
        self.success_action = success_action

    def __str__(self):
        return "PrepareLnurlPayResponse(amount_sats={}, comment={}, pay_request={}, fee_sats={}, invoice_details={}, success_action={})".format(self.amount_sats, self.comment, self.pay_request, self.fee_sats, self.invoice_details, self.success_action)

    def __eq__(self, other):
        if self.amount_sats != other.amount_sats:
            return False
        if self.comment != other.comment:
            return False
        if self.pay_request != other.pay_request:
            return False
        if self.fee_sats != other.fee_sats:
            return False
        if self.invoice_details != other.invoice_details:
            return False
        if self.success_action != other.success_action:
            return False
        return True

class _UniffiConverterTypePrepareLnurlPayResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareLnurlPayResponse(
            amount_sats=_UniffiConverterUInt64.read(buf),
            comment=_UniffiConverterOptionalString.read(buf),
            pay_request=_UniffiConverterTypeLnurlPayRequestDetails.read(buf),
            fee_sats=_UniffiConverterUInt64.read(buf),
            invoice_details=_UniffiConverterTypeBolt11InvoiceDetails.read(buf),
            success_action=_UniffiConverterOptionalTypeSuccessAction.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount_sats)
        _UniffiConverterOptionalString.check_lower(value.comment)
        _UniffiConverterTypeLnurlPayRequestDetails.check_lower(value.pay_request)
        _UniffiConverterUInt64.check_lower(value.fee_sats)
        _UniffiConverterTypeBolt11InvoiceDetails.check_lower(value.invoice_details)
        _UniffiConverterOptionalTypeSuccessAction.check_lower(value.success_action)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount_sats, buf)
        _UniffiConverterOptionalString.write(value.comment, buf)
        _UniffiConverterTypeLnurlPayRequestDetails.write(value.pay_request, buf)
        _UniffiConverterUInt64.write(value.fee_sats, buf)
        _UniffiConverterTypeBolt11InvoiceDetails.write(value.invoice_details, buf)
        _UniffiConverterOptionalTypeSuccessAction.write(value.success_action, buf)


class PrepareSendPaymentRequest:
    payment_request: "str"
    amount: "typing.Optional[U128]"
    """
    Amount to send. By default is denominated in sats.
    If a token identifier is provided, the amount will be denominated in the token base units.
    """

    token_identifier: "typing.Optional[str]"
    """
    If provided, the payment will be for a token.
    May only be provided if the payment request is a spark address.
    """

    token_conversion_options: "typing.Optional[TokenConversionOptions]"
    """
    If provided, the payment will include a token conversion step before sending the payment
    """

    def __init__(self, *, payment_request: "str", amount: "typing.Optional[U128]" = _DEFAULT, token_identifier: "typing.Optional[str]" = _DEFAULT, token_conversion_options: "typing.Optional[TokenConversionOptions]" = _DEFAULT):
        self.payment_request = payment_request
        if amount is _DEFAULT:
            self.amount = None
        else:
            self.amount = amount
        if token_identifier is _DEFAULT:
            self.token_identifier = None
        else:
            self.token_identifier = token_identifier
        if token_conversion_options is _DEFAULT:
            self.token_conversion_options = None
        else:
            self.token_conversion_options = token_conversion_options

    def __str__(self):
        return "PrepareSendPaymentRequest(payment_request={}, amount={}, token_identifier={}, token_conversion_options={})".format(self.payment_request, self.amount, self.token_identifier, self.token_conversion_options)

    def __eq__(self, other):
        if self.payment_request != other.payment_request:
            return False
        if self.amount != other.amount:
            return False
        if self.token_identifier != other.token_identifier:
            return False
        if self.token_conversion_options != other.token_conversion_options:
            return False
        return True

class _UniffiConverterTypePrepareSendPaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareSendPaymentRequest(
            payment_request=_UniffiConverterString.read(buf),
            amount=_UniffiConverterOptionalTypeU128.read(buf),
            token_identifier=_UniffiConverterOptionalString.read(buf),
            token_conversion_options=_UniffiConverterOptionalTypeTokenConversionOptions.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_request)
        _UniffiConverterOptionalTypeU128.check_lower(value.amount)
        _UniffiConverterOptionalString.check_lower(value.token_identifier)
        _UniffiConverterOptionalTypeTokenConversionOptions.check_lower(value.token_conversion_options)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_request, buf)
        _UniffiConverterOptionalTypeU128.write(value.amount, buf)
        _UniffiConverterOptionalString.write(value.token_identifier, buf)
        _UniffiConverterOptionalTypeTokenConversionOptions.write(value.token_conversion_options, buf)


class PrepareSendPaymentResponse:
    payment_method: "SendPaymentMethod"
    amount: "U128"
    """
    Amount to send. By default is denominated in sats.
    If a token identifier is provided, the amount will be denominated in the token base units.
    """

    token_identifier: "typing.Optional[str]"
    """
    The presence of this field indicates that the payment is for a token.
    If empty, it is a Bitcoin payment.
    """

    token_conversion_options: "typing.Optional[TokenConversionOptions]"
    """
    When set, the payment will include a token conversion step before sending the payment
    """

    token_conversion_fee: "typing.Optional[U128]"
    """
    The estimated token conversion fee if the payment involves a token conversion
    """

    def __init__(self, *, payment_method: "SendPaymentMethod", amount: "U128", token_identifier: "typing.Optional[str]", token_conversion_options: "typing.Optional[TokenConversionOptions]", token_conversion_fee: "typing.Optional[U128]"):
        self.payment_method = payment_method
        self.amount = amount
        self.token_identifier = token_identifier
        self.token_conversion_options = token_conversion_options
        self.token_conversion_fee = token_conversion_fee

    def __str__(self):
        return "PrepareSendPaymentResponse(payment_method={}, amount={}, token_identifier={}, token_conversion_options={}, token_conversion_fee={})".format(self.payment_method, self.amount, self.token_identifier, self.token_conversion_options, self.token_conversion_fee)

    def __eq__(self, other):
        if self.payment_method != other.payment_method:
            return False
        if self.amount != other.amount:
            return False
        if self.token_identifier != other.token_identifier:
            return False
        if self.token_conversion_options != other.token_conversion_options:
            return False
        if self.token_conversion_fee != other.token_conversion_fee:
            return False
        return True

class _UniffiConverterTypePrepareSendPaymentResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrepareSendPaymentResponse(
            payment_method=_UniffiConverterTypeSendPaymentMethod.read(buf),
            amount=_UniffiConverterTypeU128.read(buf),
            token_identifier=_UniffiConverterOptionalString.read(buf),
            token_conversion_options=_UniffiConverterOptionalTypeTokenConversionOptions.read(buf),
            token_conversion_fee=_UniffiConverterOptionalTypeU128.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeSendPaymentMethod.check_lower(value.payment_method)
        _UniffiConverterTypeU128.check_lower(value.amount)
        _UniffiConverterOptionalString.check_lower(value.token_identifier)
        _UniffiConverterOptionalTypeTokenConversionOptions.check_lower(value.token_conversion_options)
        _UniffiConverterOptionalTypeU128.check_lower(value.token_conversion_fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSendPaymentMethod.write(value.payment_method, buf)
        _UniffiConverterTypeU128.write(value.amount, buf)
        _UniffiConverterOptionalString.write(value.token_identifier, buf)
        _UniffiConverterOptionalTypeTokenConversionOptions.write(value.token_conversion_options, buf)
        _UniffiConverterOptionalTypeU128.write(value.token_conversion_fee, buf)


class PrivateKeyBytes:
    """
    FFI-safe representation of a private key (32 bytes)
    """

    bytes: "bytes"
    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "PrivateKeyBytes(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypePrivateKeyBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PrivateKeyBytes(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class ProvisionalPayment:
    payment_id: "str"
    """
    Unique identifier for the payment
    """

    amount: "U128"
    """
    Amount in satoshis or token base units
    """

    details: "ProvisionalPaymentDetails"
    """
    Details of the payment
    """

    def __init__(self, *, payment_id: "str", amount: "U128", details: "ProvisionalPaymentDetails"):
        self.payment_id = payment_id
        self.amount = amount
        self.details = details

    def __str__(self):
        return "ProvisionalPayment(payment_id={}, amount={}, details={})".format(self.payment_id, self.amount, self.details)

    def __eq__(self, other):
        if self.payment_id != other.payment_id:
            return False
        if self.amount != other.amount:
            return False
        if self.details != other.details:
            return False
        return True

class _UniffiConverterTypeProvisionalPayment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProvisionalPayment(
            payment_id=_UniffiConverterString.read(buf),
            amount=_UniffiConverterTypeU128.read(buf),
            details=_UniffiConverterTypeProvisionalPaymentDetails.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_id)
        _UniffiConverterTypeU128.check_lower(value.amount)
        _UniffiConverterTypeProvisionalPaymentDetails.check_lower(value.details)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_id, buf)
        _UniffiConverterTypeU128.write(value.amount, buf)
        _UniffiConverterTypeProvisionalPaymentDetails.write(value.details, buf)


class PublicKeyBytes:
    """
    FFI-safe representation of a secp256k1 public key (33 bytes compressed)
    """

    bytes: "bytes"
    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "PublicKeyBytes(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypePublicKeyBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PublicKeyBytes(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class Rate:
    """
    Denominator in an exchange rate
    """

    coin: "str"
    value: "float"
    def __init__(self, *, coin: "str", value: "float"):
        self.coin = coin
        self.value = value

    def __str__(self):
        return "Rate(coin={}, value={})".format(self.coin, self.value)

    def __eq__(self, other):
        if self.coin != other.coin:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeRate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Rate(
            coin=_UniffiConverterString.read(buf),
            value=_UniffiConverterDouble.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.coin)
        _UniffiConverterDouble.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.coin, buf)
        _UniffiConverterDouble.write(value.value, buf)


class ReceivePaymentRequest:
    payment_method: "ReceivePaymentMethod"
    def __init__(self, *, payment_method: "ReceivePaymentMethod"):
        self.payment_method = payment_method

    def __str__(self):
        return "ReceivePaymentRequest(payment_method={})".format(self.payment_method)

    def __eq__(self, other):
        if self.payment_method != other.payment_method:
            return False
        return True

class _UniffiConverterTypeReceivePaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivePaymentRequest(
            payment_method=_UniffiConverterTypeReceivePaymentMethod.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeReceivePaymentMethod.check_lower(value.payment_method)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeReceivePaymentMethod.write(value.payment_method, buf)


class ReceivePaymentResponse:
    payment_request: "str"
    fee: "U128"
    """
    Fee to pay to receive the payment
    Denominated in sats or token base units
    """

    def __init__(self, *, payment_request: "str", fee: "U128"):
        self.payment_request = payment_request
        self.fee = fee

    def __str__(self):
        return "ReceivePaymentResponse(payment_request={}, fee={})".format(self.payment_request, self.fee)

    def __eq__(self, other):
        if self.payment_request != other.payment_request:
            return False
        if self.fee != other.fee:
            return False
        return True

class _UniffiConverterTypeReceivePaymentResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceivePaymentResponse(
            payment_request=_UniffiConverterString.read(buf),
            fee=_UniffiConverterTypeU128.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_request)
        _UniffiConverterTypeU128.check_lower(value.fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_request, buf)
        _UniffiConverterTypeU128.write(value.fee, buf)


class RecommendedFees:
    fastest_fee: "int"
    half_hour_fee: "int"
    hour_fee: "int"
    economy_fee: "int"
    minimum_fee: "int"
    def __init__(self, *, fastest_fee: "int", half_hour_fee: "int", hour_fee: "int", economy_fee: "int", minimum_fee: "int"):
        self.fastest_fee = fastest_fee
        self.half_hour_fee = half_hour_fee
        self.hour_fee = hour_fee
        self.economy_fee = economy_fee
        self.minimum_fee = minimum_fee

    def __str__(self):
        return "RecommendedFees(fastest_fee={}, half_hour_fee={}, hour_fee={}, economy_fee={}, minimum_fee={})".format(self.fastest_fee, self.half_hour_fee, self.hour_fee, self.economy_fee, self.minimum_fee)

    def __eq__(self, other):
        if self.fastest_fee != other.fastest_fee:
            return False
        if self.half_hour_fee != other.half_hour_fee:
            return False
        if self.hour_fee != other.hour_fee:
            return False
        if self.economy_fee != other.economy_fee:
            return False
        if self.minimum_fee != other.minimum_fee:
            return False
        return True

class _UniffiConverterTypeRecommendedFees(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecommendedFees(
            fastest_fee=_UniffiConverterUInt64.read(buf),
            half_hour_fee=_UniffiConverterUInt64.read(buf),
            hour_fee=_UniffiConverterUInt64.read(buf),
            economy_fee=_UniffiConverterUInt64.read(buf),
            minimum_fee=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.fastest_fee)
        _UniffiConverterUInt64.check_lower(value.half_hour_fee)
        _UniffiConverterUInt64.check_lower(value.hour_fee)
        _UniffiConverterUInt64.check_lower(value.economy_fee)
        _UniffiConverterUInt64.check_lower(value.minimum_fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.fastest_fee, buf)
        _UniffiConverterUInt64.write(value.half_hour_fee, buf)
        _UniffiConverterUInt64.write(value.hour_fee, buf)
        _UniffiConverterUInt64.write(value.economy_fee, buf)
        _UniffiConverterUInt64.write(value.minimum_fee, buf)


class Record:
    id: "RecordId"
    revision: "int"
    schema_version: "str"
    data: "dict[str, str]"
    def __init__(self, *, id: "RecordId", revision: "int", schema_version: "str", data: "dict[str, str]"):
        self.id = id
        self.revision = revision
        self.schema_version = schema_version
        self.data = data

    def __str__(self):
        return "Record(id={}, revision={}, schema_version={}, data={})".format(self.id, self.revision, self.schema_version, self.data)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.revision != other.revision:
            return False
        if self.schema_version != other.schema_version:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Record(
            id=_UniffiConverterTypeRecordId.read(buf),
            revision=_UniffiConverterUInt64.read(buf),
            schema_version=_UniffiConverterString.read(buf),
            data=_UniffiConverterMapStringString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeRecordId.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.revision)
        _UniffiConverterString.check_lower(value.schema_version)
        _UniffiConverterMapStringString.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeRecordId.write(value.id, buf)
        _UniffiConverterUInt64.write(value.revision, buf)
        _UniffiConverterString.write(value.schema_version, buf)
        _UniffiConverterMapStringString.write(value.data, buf)


class RecordChange:
    id: "RecordId"
    schema_version: "str"
    updated_fields: "dict[str, str]"
    revision: "int"
    def __init__(self, *, id: "RecordId", schema_version: "str", updated_fields: "dict[str, str]", revision: "int"):
        self.id = id
        self.schema_version = schema_version
        self.updated_fields = updated_fields
        self.revision = revision

    def __str__(self):
        return "RecordChange(id={}, schema_version={}, updated_fields={}, revision={})".format(self.id, self.schema_version, self.updated_fields, self.revision)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.schema_version != other.schema_version:
            return False
        if self.updated_fields != other.updated_fields:
            return False
        if self.revision != other.revision:
            return False
        return True

class _UniffiConverterTypeRecordChange(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecordChange(
            id=_UniffiConverterTypeRecordId.read(buf),
            schema_version=_UniffiConverterString.read(buf),
            updated_fields=_UniffiConverterMapStringString.read(buf),
            revision=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeRecordId.check_lower(value.id)
        _UniffiConverterString.check_lower(value.schema_version)
        _UniffiConverterMapStringString.check_lower(value.updated_fields)
        _UniffiConverterUInt64.check_lower(value.revision)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeRecordId.write(value.id, buf)
        _UniffiConverterString.write(value.schema_version, buf)
        _UniffiConverterMapStringString.write(value.updated_fields, buf)
        _UniffiConverterUInt64.write(value.revision, buf)


class RecordId:
    type: "str"
    data_id: "str"
    def __init__(self, *, type: "str", data_id: "str"):
        self.type = type
        self.data_id = data_id

    def __str__(self):
        return "RecordId(type={}, data_id={})".format(self.type, self.data_id)

    def __eq__(self, other):
        if self.type != other.type:
            return False
        if self.data_id != other.data_id:
            return False
        return True

class _UniffiConverterTypeRecordId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecordId(
            type=_UniffiConverterString.read(buf),
            data_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.type)
        _UniffiConverterString.check_lower(value.data_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.type, buf)
        _UniffiConverterString.write(value.data_id, buf)


class RecoverableEcdsaSignatureBytes:
    """
    FFI-safe representation of a recoverable ECDSA signature (65 bytes: 1 recovery byte + 64 signature bytes)
    """

    bytes: "bytes"
    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "RecoverableEcdsaSignatureBytes(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypeRecoverableEcdsaSignatureBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecoverableEcdsaSignatureBytes(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class RefundDepositRequest:
    txid: "str"
    vout: "int"
    destination_address: "str"
    fee: "Fee"
    def __init__(self, *, txid: "str", vout: "int", destination_address: "str", fee: "Fee"):
        self.txid = txid
        self.vout = vout
        self.destination_address = destination_address
        self.fee = fee

    def __str__(self):
        return "RefundDepositRequest(txid={}, vout={}, destination_address={}, fee={})".format(self.txid, self.vout, self.destination_address, self.fee)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        if self.destination_address != other.destination_address:
            return False
        if self.fee != other.fee:
            return False
        return True

class _UniffiConverterTypeRefundDepositRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RefundDepositRequest(
            txid=_UniffiConverterString.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
            destination_address=_UniffiConverterString.read(buf),
            fee=_UniffiConverterTypeFee.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)
        _UniffiConverterString.check_lower(value.destination_address)
        _UniffiConverterTypeFee.check_lower(value.fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)
        _UniffiConverterString.write(value.destination_address, buf)
        _UniffiConverterTypeFee.write(value.fee, buf)


class RefundDepositResponse:
    tx_id: "str"
    tx_hex: "str"
    def __init__(self, *, tx_id: "str", tx_hex: "str"):
        self.tx_id = tx_id
        self.tx_hex = tx_hex

    def __str__(self):
        return "RefundDepositResponse(tx_id={}, tx_hex={})".format(self.tx_id, self.tx_hex)

    def __eq__(self, other):
        if self.tx_id != other.tx_id:
            return False
        if self.tx_hex != other.tx_hex:
            return False
        return True

class _UniffiConverterTypeRefundDepositResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RefundDepositResponse(
            tx_id=_UniffiConverterString.read(buf),
            tx_hex=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.tx_id)
        _UniffiConverterString.check_lower(value.tx_hex)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.tx_id, buf)
        _UniffiConverterString.write(value.tx_hex, buf)


class RegisterLightningAddressRequest:
    username: "str"
    description: "typing.Optional[str]"
    def __init__(self, *, username: "str", description: "typing.Optional[str]" = _DEFAULT):
        self.username = username
        if description is _DEFAULT:
            self.description = None
        else:
            self.description = description

    def __str__(self):
        return "RegisterLightningAddressRequest(username={}, description={})".format(self.username, self.description)

    def __eq__(self, other):
        if self.username != other.username:
            return False
        if self.description != other.description:
            return False
        return True

class _UniffiConverterTypeRegisterLightningAddressRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RegisterLightningAddressRequest(
            username=_UniffiConverterString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.username)
        _UniffiConverterOptionalString.check_lower(value.description)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.username, buf)
        _UniffiConverterOptionalString.write(value.description, buf)


class RestResponse:
    status: "int"
    body: "str"
    def __init__(self, *, status: "int", body: "str"):
        self.status = status
        self.body = body

    def __str__(self):
        return "RestResponse(status={}, body={})".format(self.status, self.body)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        if self.body != other.body:
            return False
        return True

class _UniffiConverterTypeRestResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RestResponse(
            status=_UniffiConverterUInt16.read(buf),
            body=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt16.check_lower(value.status)
        _UniffiConverterString.check_lower(value.body)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt16.write(value.status, buf)
        _UniffiConverterString.write(value.body, buf)


class SchnorrSignatureBytes:
    """
    FFI-safe representation of a Schnorr signature (64 bytes)
    """

    bytes: "bytes"
    def __init__(self, *, bytes: "bytes"):
        self.bytes = bytes

    def __str__(self):
        return "SchnorrSignatureBytes(bytes={})".format(self.bytes)

    def __eq__(self, other):
        if self.bytes != other.bytes:
            return False
        return True

class _UniffiConverterTypeSchnorrSignatureBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SchnorrSignatureBytes(
            bytes=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.bytes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.bytes, buf)


class SendOnchainFeeQuote:
    id: "str"
    expires_at: "int"
    speed_fast: "SendOnchainSpeedFeeQuote"
    speed_medium: "SendOnchainSpeedFeeQuote"
    speed_slow: "SendOnchainSpeedFeeQuote"
    def __init__(self, *, id: "str", expires_at: "int", speed_fast: "SendOnchainSpeedFeeQuote", speed_medium: "SendOnchainSpeedFeeQuote", speed_slow: "SendOnchainSpeedFeeQuote"):
        self.id = id
        self.expires_at = expires_at
        self.speed_fast = speed_fast
        self.speed_medium = speed_medium
        self.speed_slow = speed_slow

    def __str__(self):
        return "SendOnchainFeeQuote(id={}, expires_at={}, speed_fast={}, speed_medium={}, speed_slow={})".format(self.id, self.expires_at, self.speed_fast, self.speed_medium, self.speed_slow)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.expires_at != other.expires_at:
            return False
        if self.speed_fast != other.speed_fast:
            return False
        if self.speed_medium != other.speed_medium:
            return False
        if self.speed_slow != other.speed_slow:
            return False
        return True

class _UniffiConverterTypeSendOnchainFeeQuote(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendOnchainFeeQuote(
            id=_UniffiConverterString.read(buf),
            expires_at=_UniffiConverterUInt64.read(buf),
            speed_fast=_UniffiConverterTypeSendOnchainSpeedFeeQuote.read(buf),
            speed_medium=_UniffiConverterTypeSendOnchainSpeedFeeQuote.read(buf),
            speed_slow=_UniffiConverterTypeSendOnchainSpeedFeeQuote.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.expires_at)
        _UniffiConverterTypeSendOnchainSpeedFeeQuote.check_lower(value.speed_fast)
        _UniffiConverterTypeSendOnchainSpeedFeeQuote.check_lower(value.speed_medium)
        _UniffiConverterTypeSendOnchainSpeedFeeQuote.check_lower(value.speed_slow)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterUInt64.write(value.expires_at, buf)
        _UniffiConverterTypeSendOnchainSpeedFeeQuote.write(value.speed_fast, buf)
        _UniffiConverterTypeSendOnchainSpeedFeeQuote.write(value.speed_medium, buf)
        _UniffiConverterTypeSendOnchainSpeedFeeQuote.write(value.speed_slow, buf)


class SendOnchainSpeedFeeQuote:
    user_fee_sat: "int"
    l1_broadcast_fee_sat: "int"
    def __init__(self, *, user_fee_sat: "int", l1_broadcast_fee_sat: "int"):
        self.user_fee_sat = user_fee_sat
        self.l1_broadcast_fee_sat = l1_broadcast_fee_sat

    def __str__(self):
        return "SendOnchainSpeedFeeQuote(user_fee_sat={}, l1_broadcast_fee_sat={})".format(self.user_fee_sat, self.l1_broadcast_fee_sat)

    def __eq__(self, other):
        if self.user_fee_sat != other.user_fee_sat:
            return False
        if self.l1_broadcast_fee_sat != other.l1_broadcast_fee_sat:
            return False
        return True

class _UniffiConverterTypeSendOnchainSpeedFeeQuote(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendOnchainSpeedFeeQuote(
            user_fee_sat=_UniffiConverterUInt64.read(buf),
            l1_broadcast_fee_sat=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.user_fee_sat)
        _UniffiConverterUInt64.check_lower(value.l1_broadcast_fee_sat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.user_fee_sat, buf)
        _UniffiConverterUInt64.write(value.l1_broadcast_fee_sat, buf)


class SendPaymentRequest:
    prepare_response: "PrepareSendPaymentResponse"
    options: "typing.Optional[SendPaymentOptions]"
    idempotency_key: "typing.Optional[str]"
    """
    The optional idempotency key for all Spark based transfers (excludes token payments).
    If set, providing the same idempotency key for multiple requests will ensure that only one
    payment is made. If an idempotency key is re-used, the same payment will be returned.
    The idempotency key must be a valid UUID.
    """

    def __init__(self, *, prepare_response: "PrepareSendPaymentResponse", options: "typing.Optional[SendPaymentOptions]" = _DEFAULT, idempotency_key: "typing.Optional[str]" = _DEFAULT):
        self.prepare_response = prepare_response
        if options is _DEFAULT:
            self.options = None
        else:
            self.options = options
        if idempotency_key is _DEFAULT:
            self.idempotency_key = None
        else:
            self.idempotency_key = idempotency_key

    def __str__(self):
        return "SendPaymentRequest(prepare_response={}, options={}, idempotency_key={})".format(self.prepare_response, self.options, self.idempotency_key)

    def __eq__(self, other):
        if self.prepare_response != other.prepare_response:
            return False
        if self.options != other.options:
            return False
        if self.idempotency_key != other.idempotency_key:
            return False
        return True

class _UniffiConverterTypeSendPaymentRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendPaymentRequest(
            prepare_response=_UniffiConverterTypePrepareSendPaymentResponse.read(buf),
            options=_UniffiConverterOptionalTypeSendPaymentOptions.read(buf),
            idempotency_key=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePrepareSendPaymentResponse.check_lower(value.prepare_response)
        _UniffiConverterOptionalTypeSendPaymentOptions.check_lower(value.options)
        _UniffiConverterOptionalString.check_lower(value.idempotency_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePrepareSendPaymentResponse.write(value.prepare_response, buf)
        _UniffiConverterOptionalTypeSendPaymentOptions.write(value.options, buf)
        _UniffiConverterOptionalString.write(value.idempotency_key, buf)


class SendPaymentResponse:
    payment: "Payment"
    def __init__(self, *, payment: "Payment"):
        self.payment = payment

    def __str__(self):
        return "SendPaymentResponse(payment={})".format(self.payment)

    def __eq__(self, other):
        if self.payment != other.payment:
            return False
        return True

class _UniffiConverterTypeSendPaymentResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendPaymentResponse(
            payment=_UniffiConverterTypePayment.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePayment.check_lower(value.payment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePayment.write(value.payment, buf)


class SetLnurlMetadataItem:
    payment_hash: "str"
    sender_comment: "typing.Optional[str]"
    nostr_zap_request: "typing.Optional[str]"
    nostr_zap_receipt: "typing.Optional[str]"
    def __init__(self, *, payment_hash: "str", sender_comment: "typing.Optional[str]", nostr_zap_request: "typing.Optional[str]", nostr_zap_receipt: "typing.Optional[str]"):
        self.payment_hash = payment_hash
        self.sender_comment = sender_comment
        self.nostr_zap_request = nostr_zap_request
        self.nostr_zap_receipt = nostr_zap_receipt

    def __str__(self):
        return "SetLnurlMetadataItem(payment_hash={}, sender_comment={}, nostr_zap_request={}, nostr_zap_receipt={})".format(self.payment_hash, self.sender_comment, self.nostr_zap_request, self.nostr_zap_receipt)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.sender_comment != other.sender_comment:
            return False
        if self.nostr_zap_request != other.nostr_zap_request:
            return False
        if self.nostr_zap_receipt != other.nostr_zap_receipt:
            return False
        return True

class _UniffiConverterTypeSetLnurlMetadataItem(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetLnurlMetadataItem(
            payment_hash=_UniffiConverterString.read(buf),
            sender_comment=_UniffiConverterOptionalString.read(buf),
            nostr_zap_request=_UniffiConverterOptionalString.read(buf),
            nostr_zap_receipt=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterOptionalString.check_lower(value.sender_comment)
        _UniffiConverterOptionalString.check_lower(value.nostr_zap_request)
        _UniffiConverterOptionalString.check_lower(value.nostr_zap_receipt)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterOptionalString.write(value.sender_comment, buf)
        _UniffiConverterOptionalString.write(value.nostr_zap_request, buf)
        _UniffiConverterOptionalString.write(value.nostr_zap_receipt, buf)


class SignMessageRequest:
    message: "str"
    compact: "bool"
    """
    If true, the signature will be encoded in compact format instead of DER format
    """

    def __init__(self, *, message: "str", compact: "bool"):
        self.message = message
        self.compact = compact

    def __str__(self):
        return "SignMessageRequest(message={}, compact={})".format(self.message, self.compact)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.compact != other.compact:
            return False
        return True

class _UniffiConverterTypeSignMessageRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignMessageRequest(
            message=_UniffiConverterString.read(buf),
            compact=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.message)
        _UniffiConverterBool.check_lower(value.compact)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.message, buf)
        _UniffiConverterBool.write(value.compact, buf)


class SignMessageResponse:
    pubkey: "str"
    signature: "str"
    """
    The DER or compact hex encoded signature
    """

    def __init__(self, *, pubkey: "str", signature: "str"):
        self.pubkey = pubkey
        self.signature = signature

    def __str__(self):
        return "SignMessageResponse(pubkey={}, signature={})".format(self.pubkey, self.signature)

    def __eq__(self, other):
        if self.pubkey != other.pubkey:
            return False
        if self.signature != other.signature:
            return False
        return True

class _UniffiConverterTypeSignMessageResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignMessageResponse(
            pubkey=_UniffiConverterString.read(buf),
            signature=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.pubkey)
        _UniffiConverterString.check_lower(value.signature)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.pubkey, buf)
        _UniffiConverterString.write(value.signature, buf)


class SilentPaymentAddressDetails:
    address: "str"
    network: "BitcoinNetwork"
    source: "PaymentRequestSource"
    def __init__(self, *, address: "str", network: "BitcoinNetwork", source: "PaymentRequestSource"):
        self.address = address
        self.network = network
        self.source = source

    def __str__(self):
        return "SilentPaymentAddressDetails(address={}, network={}, source={})".format(self.address, self.network, self.source)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.network != other.network:
            return False
        if self.source != other.source:
            return False
        return True

class _UniffiConverterTypeSilentPaymentAddressDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SilentPaymentAddressDetails(
            address=_UniffiConverterString.read(buf),
            network=_UniffiConverterTypeBitcoinNetwork.read(buf),
            source=_UniffiConverterTypePaymentRequestSource.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterTypeBitcoinNetwork.check_lower(value.network)
        _UniffiConverterTypePaymentRequestSource.check_lower(value.source)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterTypeBitcoinNetwork.write(value.network, buf)
        _UniffiConverterTypePaymentRequestSource.write(value.source, buf)


class SparkAddressDetails:
    address: "str"
    """
    The raw address string
    """

    identity_public_key: "str"
    """
    The identity public key of the address owner
    """

    network: "BitcoinNetwork"
    source: "PaymentRequestSource"
    def __init__(self, *, address: "str", identity_public_key: "str", network: "BitcoinNetwork", source: "PaymentRequestSource"):
        self.address = address
        self.identity_public_key = identity_public_key
        self.network = network
        self.source = source

    def __str__(self):
        return "SparkAddressDetails(address={}, identity_public_key={}, network={}, source={})".format(self.address, self.identity_public_key, self.network, self.source)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.identity_public_key != other.identity_public_key:
            return False
        if self.network != other.network:
            return False
        if self.source != other.source:
            return False
        return True

class _UniffiConverterTypeSparkAddressDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SparkAddressDetails(
            address=_UniffiConverterString.read(buf),
            identity_public_key=_UniffiConverterString.read(buf),
            network=_UniffiConverterTypeBitcoinNetwork.read(buf),
            source=_UniffiConverterTypePaymentRequestSource.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterString.check_lower(value.identity_public_key)
        _UniffiConverterTypeBitcoinNetwork.check_lower(value.network)
        _UniffiConverterTypePaymentRequestSource.check_lower(value.source)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterString.write(value.identity_public_key, buf)
        _UniffiConverterTypeBitcoinNetwork.write(value.network, buf)
        _UniffiConverterTypePaymentRequestSource.write(value.source, buf)


class SparkHtlcDetails:
    payment_hash: "str"
    """
    The payment hash of the HTLC
    """

    preimage: "typing.Optional[str]"
    """
    The preimage of the HTLC. Empty until receiver has released it.
    """

    expiry_time: "int"
    """
    The expiry time of the HTLC in seconds since the Unix epoch
    """

    status: "SparkHtlcStatus"
    """
    The HTLC status
    """

    def __init__(self, *, payment_hash: "str", preimage: "typing.Optional[str]", expiry_time: "int", status: "SparkHtlcStatus"):
        self.payment_hash = payment_hash
        self.preimage = preimage
        self.expiry_time = expiry_time
        self.status = status

    def __str__(self):
        return "SparkHtlcDetails(payment_hash={}, preimage={}, expiry_time={}, status={})".format(self.payment_hash, self.preimage, self.expiry_time, self.status)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.preimage != other.preimage:
            return False
        if self.expiry_time != other.expiry_time:
            return False
        if self.status != other.status:
            return False
        return True

class _UniffiConverterTypeSparkHtlcDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SparkHtlcDetails(
            payment_hash=_UniffiConverterString.read(buf),
            preimage=_UniffiConverterOptionalString.read(buf),
            expiry_time=_UniffiConverterUInt64.read(buf),
            status=_UniffiConverterTypeSparkHtlcStatus.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterOptionalString.check_lower(value.preimage)
        _UniffiConverterUInt64.check_lower(value.expiry_time)
        _UniffiConverterTypeSparkHtlcStatus.check_lower(value.status)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterOptionalString.write(value.preimage, buf)
        _UniffiConverterUInt64.write(value.expiry_time, buf)
        _UniffiConverterTypeSparkHtlcStatus.write(value.status, buf)


class SparkHtlcOptions:
    payment_hash: "str"
    """
    The payment hash of the HTLC. The receiver will need to provide the associated preimage to claim it.
    """

    expiry_duration_secs: "int"
    """
    The duration of the HTLC in seconds.
    After this time, the HTLC will be returned.
    """

    def __init__(self, *, payment_hash: "str", expiry_duration_secs: "int"):
        self.payment_hash = payment_hash
        self.expiry_duration_secs = expiry_duration_secs

    def __str__(self):
        return "SparkHtlcOptions(payment_hash={}, expiry_duration_secs={})".format(self.payment_hash, self.expiry_duration_secs)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.expiry_duration_secs != other.expiry_duration_secs:
            return False
        return True

class _UniffiConverterTypeSparkHtlcOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SparkHtlcOptions(
            payment_hash=_UniffiConverterString.read(buf),
            expiry_duration_secs=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.payment_hash)
        _UniffiConverterUInt64.check_lower(value.expiry_duration_secs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.payment_hash, buf)
        _UniffiConverterUInt64.write(value.expiry_duration_secs, buf)


class SparkInvoiceDetails:
    invoice: "str"
    """
    The raw invoice string
    """

    identity_public_key: "str"
    """
    The identity public key of the invoice issuer
    """

    network: "BitcoinNetwork"
    amount: "typing.Optional[U128]"
    """
    Optional amount denominated in sats if `token_identifier` is absent, otherwise in the token base units
    """

    token_identifier: "typing.Optional[str]"
    """
    The token identifier of the token payment. Absence indicates a Bitcoin payment.
    """

    expiry_time: "typing.Optional[int]"
    """
    Optional expiry time. If not provided, the invoice will never expire.
    """

    description: "typing.Optional[str]"
    """
    Optional description.
    """

    sender_public_key: "typing.Optional[str]"
    """
    If set, the invoice may only be fulfilled by a payer with this public key.
    """

    def __init__(self, *, invoice: "str", identity_public_key: "str", network: "BitcoinNetwork", amount: "typing.Optional[U128]", token_identifier: "typing.Optional[str]", expiry_time: "typing.Optional[int]", description: "typing.Optional[str]", sender_public_key: "typing.Optional[str]"):
        self.invoice = invoice
        self.identity_public_key = identity_public_key
        self.network = network
        self.amount = amount
        self.token_identifier = token_identifier
        self.expiry_time = expiry_time
        self.description = description
        self.sender_public_key = sender_public_key

    def __str__(self):
        return "SparkInvoiceDetails(invoice={}, identity_public_key={}, network={}, amount={}, token_identifier={}, expiry_time={}, description={}, sender_public_key={})".format(self.invoice, self.identity_public_key, self.network, self.amount, self.token_identifier, self.expiry_time, self.description, self.sender_public_key)

    def __eq__(self, other):
        if self.invoice != other.invoice:
            return False
        if self.identity_public_key != other.identity_public_key:
            return False
        if self.network != other.network:
            return False
        if self.amount != other.amount:
            return False
        if self.token_identifier != other.token_identifier:
            return False
        if self.expiry_time != other.expiry_time:
            return False
        if self.description != other.description:
            return False
        if self.sender_public_key != other.sender_public_key:
            return False
        return True

class _UniffiConverterTypeSparkInvoiceDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SparkInvoiceDetails(
            invoice=_UniffiConverterString.read(buf),
            identity_public_key=_UniffiConverterString.read(buf),
            network=_UniffiConverterTypeBitcoinNetwork.read(buf),
            amount=_UniffiConverterOptionalTypeU128.read(buf),
            token_identifier=_UniffiConverterOptionalString.read(buf),
            expiry_time=_UniffiConverterOptionalUInt64.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            sender_public_key=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.invoice)
        _UniffiConverterString.check_lower(value.identity_public_key)
        _UniffiConverterTypeBitcoinNetwork.check_lower(value.network)
        _UniffiConverterOptionalTypeU128.check_lower(value.amount)
        _UniffiConverterOptionalString.check_lower(value.token_identifier)
        _UniffiConverterOptionalUInt64.check_lower(value.expiry_time)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.sender_public_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.invoice, buf)
        _UniffiConverterString.write(value.identity_public_key, buf)
        _UniffiConverterTypeBitcoinNetwork.write(value.network, buf)
        _UniffiConverterOptionalTypeU128.write(value.amount, buf)
        _UniffiConverterOptionalString.write(value.token_identifier, buf)
        _UniffiConverterOptionalUInt64.write(value.expiry_time, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.sender_public_key, buf)


class SparkInvoicePaymentDetails:
    description: "typing.Optional[str]"
    """
    Represents the spark invoice description
    """

    invoice: "str"
    """
    The raw spark invoice string
    """

    def __init__(self, *, description: "typing.Optional[str]", invoice: "str"):
        self.description = description
        self.invoice = invoice

    def __str__(self):
        return "SparkInvoicePaymentDetails(description={}, invoice={})".format(self.description, self.invoice)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.invoice != other.invoice:
            return False
        return True

class _UniffiConverterTypeSparkInvoicePaymentDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SparkInvoicePaymentDetails(
            description=_UniffiConverterOptionalString.read(buf),
            invoice=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.invoice)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterString.write(value.invoice, buf)


class Symbol:
    """
    Settings for the symbol representation of a currency
    """

    grapheme: "typing.Optional[str]"
    template: "typing.Optional[str]"
    rtl: "typing.Optional[bool]"
    position: "typing.Optional[int]"
    def __init__(self, *, grapheme: "typing.Optional[str]", template: "typing.Optional[str]", rtl: "typing.Optional[bool]", position: "typing.Optional[int]"):
        self.grapheme = grapheme
        self.template = template
        self.rtl = rtl
        self.position = position

    def __str__(self):
        return "Symbol(grapheme={}, template={}, rtl={}, position={})".format(self.grapheme, self.template, self.rtl, self.position)

    def __eq__(self, other):
        if self.grapheme != other.grapheme:
            return False
        if self.template != other.template:
            return False
        if self.rtl != other.rtl:
            return False
        if self.position != other.position:
            return False
        return True

class _UniffiConverterTypeSymbol(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Symbol(
            grapheme=_UniffiConverterOptionalString.read(buf),
            template=_UniffiConverterOptionalString.read(buf),
            rtl=_UniffiConverterOptionalBool.read(buf),
            position=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.grapheme)
        _UniffiConverterOptionalString.check_lower(value.template)
        _UniffiConverterOptionalBool.check_lower(value.rtl)
        _UniffiConverterOptionalUInt32.check_lower(value.position)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.grapheme, buf)
        _UniffiConverterOptionalString.write(value.template, buf)
        _UniffiConverterOptionalBool.write(value.rtl, buf)
        _UniffiConverterOptionalUInt32.write(value.position, buf)


class SyncWalletRequest:
    """
    Request to sync the wallet with the Spark network
    """


    def __str__(self):
        return "SyncWalletRequest()".format()

    def __eq__(self, other):
        return True

class _UniffiConverterTypeSyncWalletRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SyncWalletRequest(
        )

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        pass


class SyncWalletResponse:
    """
    Response from synchronizing the wallet
    """


    def __str__(self):
        return "SyncWalletResponse()".format()

    def __eq__(self, other):
        return True

class _UniffiConverterTypeSyncWalletResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SyncWalletResponse(
        )

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        pass


class TokenBalance:
    balance: "U128"
    token_metadata: "TokenMetadata"
    def __init__(self, *, balance: "U128", token_metadata: "TokenMetadata"):
        self.balance = balance
        self.token_metadata = token_metadata

    def __str__(self):
        return "TokenBalance(balance={}, token_metadata={})".format(self.balance, self.token_metadata)

    def __eq__(self, other):
        if self.balance != other.balance:
            return False
        if self.token_metadata != other.token_metadata:
            return False
        return True

class _UniffiConverterTypeTokenBalance(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenBalance(
            balance=_UniffiConverterTypeU128.read(buf),
            token_metadata=_UniffiConverterTypeTokenMetadata.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeU128.check_lower(value.balance)
        _UniffiConverterTypeTokenMetadata.check_lower(value.token_metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeU128.write(value.balance, buf)
        _UniffiConverterTypeTokenMetadata.write(value.token_metadata, buf)


class TokenConversionInfo:
    pool_id: "str"
    """
    The pool id associated with the conversion
    """

    payment_id: "typing.Optional[str]"
    """
    The receiving payment id associated with the conversion
    """

    fee: "typing.Optional[U128]"
    """
    The fee paid for the conversion
    Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
    """

    refund_identifier: "typing.Optional[str]"
    """
    The refund payment id if a refund payment was made
    """

    def __init__(self, *, pool_id: "str", payment_id: "typing.Optional[str]", fee: "typing.Optional[U128]", refund_identifier: "typing.Optional[str]"):
        self.pool_id = pool_id
        self.payment_id = payment_id
        self.fee = fee
        self.refund_identifier = refund_identifier

    def __str__(self):
        return "TokenConversionInfo(pool_id={}, payment_id={}, fee={}, refund_identifier={})".format(self.pool_id, self.payment_id, self.fee, self.refund_identifier)

    def __eq__(self, other):
        if self.pool_id != other.pool_id:
            return False
        if self.payment_id != other.payment_id:
            return False
        if self.fee != other.fee:
            return False
        if self.refund_identifier != other.refund_identifier:
            return False
        return True

class _UniffiConverterTypeTokenConversionInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenConversionInfo(
            pool_id=_UniffiConverterString.read(buf),
            payment_id=_UniffiConverterOptionalString.read(buf),
            fee=_UniffiConverterOptionalTypeU128.read(buf),
            refund_identifier=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.pool_id)
        _UniffiConverterOptionalString.check_lower(value.payment_id)
        _UniffiConverterOptionalTypeU128.check_lower(value.fee)
        _UniffiConverterOptionalString.check_lower(value.refund_identifier)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.pool_id, buf)
        _UniffiConverterOptionalString.write(value.payment_id, buf)
        _UniffiConverterOptionalTypeU128.write(value.fee, buf)
        _UniffiConverterOptionalString.write(value.refund_identifier, buf)


class TokenConversionOptions:
    """
    Options for token conversion when fulfilling a payment. When set, the SDK will
    perform a token conversion before fulfilling the payment. If not set, the payment
    will only be fulfilled if the wallet has sufficient balance of the required asset.
    """

    conversion_type: "TokenConversionType"
    """
    The type of token conversion to perform when fulfilling the payment
    """

    max_slippage_bps: "typing.Optional[int]"
    """
    The optional maximum slippage in basis points (1/100 of a percent) allowed when
    a token conversion is needed to fulfill the payment. Defaults to 50 bps (0.5%) if not set.
    The token conversion will fail if the actual amount received is less than
    `estimated_amount * (1 - max_slippage_bps / 10_000)`.
    """

    completion_timeout_secs: "typing.Optional[int]"
    """
    The optional timeout in seconds to wait for the token conversion to complete
    when fulfilling the payment. This timeout only concerns waiting for the received
    payment of the token conversion. If the timeout is reached before the conversion
    is complete, the payment will fail. Defaults to 30 seconds if not set.
    """

    def __init__(self, *, conversion_type: "TokenConversionType", max_slippage_bps: "typing.Optional[int]" = _DEFAULT, completion_timeout_secs: "typing.Optional[int]" = _DEFAULT):
        self.conversion_type = conversion_type
        if max_slippage_bps is _DEFAULT:
            self.max_slippage_bps = None
        else:
            self.max_slippage_bps = max_slippage_bps
        if completion_timeout_secs is _DEFAULT:
            self.completion_timeout_secs = None
        else:
            self.completion_timeout_secs = completion_timeout_secs

    def __str__(self):
        return "TokenConversionOptions(conversion_type={}, max_slippage_bps={}, completion_timeout_secs={})".format(self.conversion_type, self.max_slippage_bps, self.completion_timeout_secs)

    def __eq__(self, other):
        if self.conversion_type != other.conversion_type:
            return False
        if self.max_slippage_bps != other.max_slippage_bps:
            return False
        if self.completion_timeout_secs != other.completion_timeout_secs:
            return False
        return True

class _UniffiConverterTypeTokenConversionOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenConversionOptions(
            conversion_type=_UniffiConverterTypeTokenConversionType.read(buf),
            max_slippage_bps=_UniffiConverterOptionalUInt32.read(buf),
            completion_timeout_secs=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTokenConversionType.check_lower(value.conversion_type)
        _UniffiConverterOptionalUInt32.check_lower(value.max_slippage_bps)
        _UniffiConverterOptionalUInt32.check_lower(value.completion_timeout_secs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTokenConversionType.write(value.conversion_type, buf)
        _UniffiConverterOptionalUInt32.write(value.max_slippage_bps, buf)
        _UniffiConverterOptionalUInt32.write(value.completion_timeout_secs, buf)


class TokenMetadata:
    identifier: "str"
    issuer_public_key: "str"
    """
    Hex representation of the issuer public key
    """

    name: "str"
    ticker: "str"
    decimals: "int"
    """
    Number of decimals the token uses
    """

    max_supply: "U128"
    is_freezable: "bool"
    def __init__(self, *, identifier: "str", issuer_public_key: "str", name: "str", ticker: "str", decimals: "int", max_supply: "U128", is_freezable: "bool"):
        self.identifier = identifier
        self.issuer_public_key = issuer_public_key
        self.name = name
        self.ticker = ticker
        self.decimals = decimals
        self.max_supply = max_supply
        self.is_freezable = is_freezable

    def __str__(self):
        return "TokenMetadata(identifier={}, issuer_public_key={}, name={}, ticker={}, decimals={}, max_supply={}, is_freezable={})".format(self.identifier, self.issuer_public_key, self.name, self.ticker, self.decimals, self.max_supply, self.is_freezable)

    def __eq__(self, other):
        if self.identifier != other.identifier:
            return False
        if self.issuer_public_key != other.issuer_public_key:
            return False
        if self.name != other.name:
            return False
        if self.ticker != other.ticker:
            return False
        if self.decimals != other.decimals:
            return False
        if self.max_supply != other.max_supply:
            return False
        if self.is_freezable != other.is_freezable:
            return False
        return True

class _UniffiConverterTypeTokenMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TokenMetadata(
            identifier=_UniffiConverterString.read(buf),
            issuer_public_key=_UniffiConverterString.read(buf),
            name=_UniffiConverterString.read(buf),
            ticker=_UniffiConverterString.read(buf),
            decimals=_UniffiConverterUInt32.read(buf),
            max_supply=_UniffiConverterTypeU128.read(buf),
            is_freezable=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.identifier)
        _UniffiConverterString.check_lower(value.issuer_public_key)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterString.check_lower(value.ticker)
        _UniffiConverterUInt32.check_lower(value.decimals)
        _UniffiConverterTypeU128.check_lower(value.max_supply)
        _UniffiConverterBool.check_lower(value.is_freezable)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.identifier, buf)
        _UniffiConverterString.write(value.issuer_public_key, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterString.write(value.ticker, buf)
        _UniffiConverterUInt32.write(value.decimals, buf)
        _UniffiConverterTypeU128.write(value.max_supply, buf)
        _UniffiConverterBool.write(value.is_freezable, buf)


class TxStatus:
    confirmed: "bool"
    block_height: "typing.Optional[int]"
    block_time: "typing.Optional[int]"
    def __init__(self, *, confirmed: "bool", block_height: "typing.Optional[int]", block_time: "typing.Optional[int]"):
        self.confirmed = confirmed
        self.block_height = block_height
        self.block_time = block_time

    def __str__(self):
        return "TxStatus(confirmed={}, block_height={}, block_time={})".format(self.confirmed, self.block_height, self.block_time)

    def __eq__(self, other):
        if self.confirmed != other.confirmed:
            return False
        if self.block_height != other.block_height:
            return False
        if self.block_time != other.block_time:
            return False
        return True

class _UniffiConverterTypeTxStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxStatus(
            confirmed=_UniffiConverterBool.read(buf),
            block_height=_UniffiConverterOptionalUInt32.read(buf),
            block_time=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.confirmed)
        _UniffiConverterOptionalUInt32.check_lower(value.block_height)
        _UniffiConverterOptionalUInt64.check_lower(value.block_time)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.confirmed, buf)
        _UniffiConverterOptionalUInt32.write(value.block_height, buf)
        _UniffiConverterOptionalUInt64.write(value.block_time, buf)


class UnfreezeIssuerTokenRequest:
    address: "str"
    def __init__(self, *, address: "str"):
        self.address = address

    def __str__(self):
        return "UnfreezeIssuerTokenRequest(address={})".format(self.address)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        return True

class _UniffiConverterTypeUnfreezeIssuerTokenRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnfreezeIssuerTokenRequest(
            address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)


class UnfreezeIssuerTokenResponse:
    impacted_output_ids: "typing.List[str]"
    impacted_token_amount: "U128"
    def __init__(self, *, impacted_output_ids: "typing.List[str]", impacted_token_amount: "U128"):
        self.impacted_output_ids = impacted_output_ids
        self.impacted_token_amount = impacted_token_amount

    def __str__(self):
        return "UnfreezeIssuerTokenResponse(impacted_output_ids={}, impacted_token_amount={})".format(self.impacted_output_ids, self.impacted_token_amount)

    def __eq__(self, other):
        if self.impacted_output_ids != other.impacted_output_ids:
            return False
        if self.impacted_token_amount != other.impacted_token_amount:
            return False
        return True

class _UniffiConverterTypeUnfreezeIssuerTokenResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnfreezeIssuerTokenResponse(
            impacted_output_ids=_UniffiConverterSequenceString.read(buf),
            impacted_token_amount=_UniffiConverterTypeU128.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceString.check_lower(value.impacted_output_ids)
        _UniffiConverterTypeU128.check_lower(value.impacted_token_amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceString.write(value.impacted_output_ids, buf)
        _UniffiConverterTypeU128.write(value.impacted_token_amount, buf)


class UnversionedRecordChange:
    id: "RecordId"
    schema_version: "str"
    updated_fields: "dict[str, str]"
    def __init__(self, *, id: "RecordId", schema_version: "str", updated_fields: "dict[str, str]"):
        self.id = id
        self.schema_version = schema_version
        self.updated_fields = updated_fields

    def __str__(self):
        return "UnversionedRecordChange(id={}, schema_version={}, updated_fields={})".format(self.id, self.schema_version, self.updated_fields)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.schema_version != other.schema_version:
            return False
        if self.updated_fields != other.updated_fields:
            return False
        return True

class _UniffiConverterTypeUnversionedRecordChange(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnversionedRecordChange(
            id=_UniffiConverterTypeRecordId.read(buf),
            schema_version=_UniffiConverterString.read(buf),
            updated_fields=_UniffiConverterMapStringString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeRecordId.check_lower(value.id)
        _UniffiConverterString.check_lower(value.schema_version)
        _UniffiConverterMapStringString.check_lower(value.updated_fields)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeRecordId.write(value.id, buf)
        _UniffiConverterString.write(value.schema_version, buf)
        _UniffiConverterMapStringString.write(value.updated_fields, buf)


class UpdateUserSettingsRequest:
    spark_private_mode_enabled: "typing.Optional[bool]"
    def __init__(self, *, spark_private_mode_enabled: "typing.Optional[bool]"):
        self.spark_private_mode_enabled = spark_private_mode_enabled

    def __str__(self):
        return "UpdateUserSettingsRequest(spark_private_mode_enabled={})".format(self.spark_private_mode_enabled)

    def __eq__(self, other):
        if self.spark_private_mode_enabled != other.spark_private_mode_enabled:
            return False
        return True

class _UniffiConverterTypeUpdateUserSettingsRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UpdateUserSettingsRequest(
            spark_private_mode_enabled=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalBool.check_lower(value.spark_private_mode_enabled)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalBool.write(value.spark_private_mode_enabled, buf)


class UrlSuccessActionData:
    description: "str"
    """
    Contents description, up to 144 characters
    """

    url: "str"
    """
    URL of the success action
    """

    matches_callback_domain: "bool"
    """
    Indicates the success URL domain matches the LNURL callback domain.

    See <https://github.com/lnurl/luds/blob/luds/09.md>
    """

    def __init__(self, *, description: "str", url: "str", matches_callback_domain: "bool"):
        self.description = description
        self.url = url
        self.matches_callback_domain = matches_callback_domain

    def __str__(self):
        return "UrlSuccessActionData(description={}, url={}, matches_callback_domain={})".format(self.description, self.url, self.matches_callback_domain)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.url != other.url:
            return False
        if self.matches_callback_domain != other.matches_callback_domain:
            return False
        return True

class _UniffiConverterTypeUrlSuccessActionData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UrlSuccessActionData(
            description=_UniffiConverterString.read(buf),
            url=_UniffiConverterString.read(buf),
            matches_callback_domain=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterBool.check_lower(value.matches_callback_domain)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterBool.write(value.matches_callback_domain, buf)


class UserSettings:
    spark_private_mode_enabled: "bool"
    def __init__(self, *, spark_private_mode_enabled: "bool"):
        self.spark_private_mode_enabled = spark_private_mode_enabled

    def __str__(self):
        return "UserSettings(spark_private_mode_enabled={})".format(self.spark_private_mode_enabled)

    def __eq__(self, other):
        if self.spark_private_mode_enabled != other.spark_private_mode_enabled:
            return False
        return True

class _UniffiConverterTypeUserSettings(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UserSettings(
            spark_private_mode_enabled=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.spark_private_mode_enabled)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.spark_private_mode_enabled, buf)


class Utxo:
    txid: "str"
    vout: "int"
    value: "int"
    status: "TxStatus"
    def __init__(self, *, txid: "str", vout: "int", value: "int", status: "TxStatus"):
        self.txid = txid
        self.vout = vout
        self.value = value
        self.status = status

    def __str__(self):
        return "Utxo(txid={}, vout={}, value={}, status={})".format(self.txid, self.vout, self.value, self.status)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        if self.value != other.value:
            return False
        if self.status != other.status:
            return False
        return True

class _UniffiConverterTypeUtxo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Utxo(
            txid=_UniffiConverterString.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
            value=_UniffiConverterUInt64.read(buf),
            status=_UniffiConverterTypeTxStatus.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)
        _UniffiConverterUInt64.check_lower(value.value)
        _UniffiConverterTypeTxStatus.check_lower(value.status)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)
        _UniffiConverterUInt64.write(value.value, buf)
        _UniffiConverterTypeTxStatus.write(value.status, buf)





class AesSuccessActionDataResult:
    """
    Result of decryption of [`AesSuccessActionData`] payload
    """

    def __init__(self):
        raise RuntimeError("AesSuccessActionDataResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class DECRYPTED:
        data: "AesSuccessActionDataDecrypted"

        def __init__(self,data: "AesSuccessActionDataDecrypted"):
            self.data = data

        def __str__(self):
            return "AesSuccessActionDataResult.DECRYPTED(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_decrypted():
                return False
            if self.data != other.data:
                return False
            return True
    
    class ERROR_STATUS:
        reason: "str"

        def __init__(self,reason: "str"):
            self.reason = reason

        def __str__(self):
            return "AesSuccessActionDataResult.ERROR_STATUS(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_error_status():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_decrypted(self) -> bool:
        return isinstance(self, AesSuccessActionDataResult.DECRYPTED)
    def is_error_status(self) -> bool:
        return isinstance(self, AesSuccessActionDataResult.ERROR_STATUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AesSuccessActionDataResult.DECRYPTED = type("AesSuccessActionDataResult.DECRYPTED", (AesSuccessActionDataResult.DECRYPTED, AesSuccessActionDataResult,), {})  # type: ignore
AesSuccessActionDataResult.ERROR_STATUS = type("AesSuccessActionDataResult.ERROR_STATUS", (AesSuccessActionDataResult.ERROR_STATUS, AesSuccessActionDataResult,), {})  # type: ignore




class _UniffiConverterTypeAesSuccessActionDataResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AesSuccessActionDataResult.DECRYPTED(
                _UniffiConverterTypeAesSuccessActionDataDecrypted.read(buf),
            )
        if variant == 2:
            return AesSuccessActionDataResult.ERROR_STATUS(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_decrypted():
            _UniffiConverterTypeAesSuccessActionDataDecrypted.check_lower(value.data)
            return
        if value.is_error_status():
            _UniffiConverterString.check_lower(value.reason)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_decrypted():
            buf.write_i32(1)
            _UniffiConverterTypeAesSuccessActionDataDecrypted.write(value.data, buf)
        if value.is_error_status():
            buf.write_i32(2)
            _UniffiConverterString.write(value.reason, buf)







class Amount:
    def __init__(self):
        raise RuntimeError("Amount cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN:
        amount_msat: "int"

        def __init__(self,amount_msat: "int"):
            self.amount_msat = amount_msat

        def __str__(self):
            return "Amount.BITCOIN(amount_msat={})".format(self.amount_msat)

        def __eq__(self, other):
            if not other.is_bitcoin():
                return False
            if self.amount_msat != other.amount_msat:
                return False
            return True
    
    class CURRENCY:
        """
        An amount of currency specified using ISO 4712.
        """

        iso4217_code: "str"
        """
        The currency that the amount is denominated in.
        """

        fractional_amount: "int"
        """
        The amount in the currency unit adjusted by the ISO 4712 exponent (e.g., USD cents).
        """


        def __init__(self,iso4217_code: "str", fractional_amount: "int"):
            self.iso4217_code = iso4217_code
            self.fractional_amount = fractional_amount

        def __str__(self):
            return "Amount.CURRENCY(iso4217_code={}, fractional_amount={})".format(self.iso4217_code, self.fractional_amount)

        def __eq__(self, other):
            if not other.is_currency():
                return False
            if self.iso4217_code != other.iso4217_code:
                return False
            if self.fractional_amount != other.fractional_amount:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin(self) -> bool:
        return isinstance(self, Amount.BITCOIN)
    def is_currency(self) -> bool:
        return isinstance(self, Amount.CURRENCY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Amount.BITCOIN = type("Amount.BITCOIN", (Amount.BITCOIN, Amount,), {})  # type: ignore
Amount.CURRENCY = type("Amount.CURRENCY", (Amount.CURRENCY, Amount,), {})  # type: ignore




class _UniffiConverterTypeAmount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Amount.BITCOIN(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return Amount.CURRENCY(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bitcoin():
            _UniffiConverterUInt64.check_lower(value.amount_msat)
            return
        if value.is_currency():
            _UniffiConverterString.check_lower(value.iso4217_code)
            _UniffiConverterUInt64.check_lower(value.fractional_amount)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_bitcoin():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.amount_msat, buf)
        if value.is_currency():
            buf.write_i32(2)
            _UniffiConverterString.write(value.iso4217_code, buf)
            _UniffiConverterUInt64.write(value.fractional_amount, buf)







class AssetFilter:
    """
    A field of [`ListPaymentsRequest`] when listing payments filtered by asset
    """

    def __init__(self):
        raise RuntimeError("AssetFilter cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN:

        def __init__(self,):
            pass

        def __str__(self):
            return "AssetFilter.BITCOIN()".format()

        def __eq__(self, other):
            if not other.is_bitcoin():
                return False
            return True
    
    class TOKEN:
        token_identifier: "typing.Optional[str]"
        """
        Optional token identifier to filter by
        """


        def __init__(self,token_identifier: "typing.Optional[str]"):
            self.token_identifier = token_identifier

        def __str__(self):
            return "AssetFilter.TOKEN(token_identifier={})".format(self.token_identifier)

        def __eq__(self, other):
            if not other.is_token():
                return False
            if self.token_identifier != other.token_identifier:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin(self) -> bool:
        return isinstance(self, AssetFilter.BITCOIN)
    def is_token(self) -> bool:
        return isinstance(self, AssetFilter.TOKEN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AssetFilter.BITCOIN = type("AssetFilter.BITCOIN", (AssetFilter.BITCOIN, AssetFilter,), {})  # type: ignore
AssetFilter.TOKEN = type("AssetFilter.TOKEN", (AssetFilter.TOKEN, AssetFilter,), {})  # type: ignore




class _UniffiConverterTypeAssetFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AssetFilter.BITCOIN(
            )
        if variant == 2:
            return AssetFilter.TOKEN(
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bitcoin():
            return
        if value.is_token():
            _UniffiConverterOptionalString.check_lower(value.token_identifier)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_bitcoin():
            buf.write_i32(1)
        if value.is_token():
            buf.write_i32(2)
            _UniffiConverterOptionalString.write(value.token_identifier, buf)







class BitcoinNetwork(enum.Enum):
    BITCOIN = 0
    """
    Mainnet
    """

    
    TESTNET3 = 1
    
    TESTNET4 = 2
    
    SIGNET = 3
    
    REGTEST = 4
    


class _UniffiConverterTypeBitcoinNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BitcoinNetwork.BITCOIN
        if variant == 2:
            return BitcoinNetwork.TESTNET3
        if variant == 3:
            return BitcoinNetwork.TESTNET4
        if variant == 4:
            return BitcoinNetwork.SIGNET
        if variant == 5:
            return BitcoinNetwork.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == BitcoinNetwork.BITCOIN:
            return
        if value == BitcoinNetwork.TESTNET3:
            return
        if value == BitcoinNetwork.TESTNET4:
            return
        if value == BitcoinNetwork.SIGNET:
            return
        if value == BitcoinNetwork.REGTEST:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == BitcoinNetwork.BITCOIN:
            buf.write_i32(1)
        if value == BitcoinNetwork.TESTNET3:
            buf.write_i32(2)
        if value == BitcoinNetwork.TESTNET4:
            buf.write_i32(3)
        if value == BitcoinNetwork.SIGNET:
            buf.write_i32(4)
        if value == BitcoinNetwork.REGTEST:
            buf.write_i32(5)







class ChainApiType(enum.Enum):
    ESPLORA = 0
    
    MEMPOOL_SPACE = 1
    


class _UniffiConverterTypeChainApiType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ChainApiType.ESPLORA
        if variant == 2:
            return ChainApiType.MEMPOOL_SPACE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ChainApiType.ESPLORA:
            return
        if value == ChainApiType.MEMPOOL_SPACE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ChainApiType.ESPLORA:
            buf.write_i32(1)
        if value == ChainApiType.MEMPOOL_SPACE:
            buf.write_i32(2)




# ChainServiceError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ChainServiceError(Exception):
    pass

_UniffiTempChainServiceError = ChainServiceError

class ChainServiceError:  # type: ignore
    class InvalidAddress(_UniffiTempChainServiceError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ChainServiceError.InvalidAddress({})".format(str(self))
    _UniffiTempChainServiceError.InvalidAddress = InvalidAddress # type: ignore
    class ServiceConnectivity(_UniffiTempChainServiceError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ChainServiceError.ServiceConnectivity({})".format(str(self))
    _UniffiTempChainServiceError.ServiceConnectivity = ServiceConnectivity # type: ignore
    class Generic(_UniffiTempChainServiceError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ChainServiceError.Generic({})".format(str(self))
    _UniffiTempChainServiceError.Generic = Generic # type: ignore

ChainServiceError = _UniffiTempChainServiceError # type: ignore
del _UniffiTempChainServiceError


class _UniffiConverterTypeChainServiceError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ChainServiceError.InvalidAddress(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ChainServiceError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ChainServiceError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ChainServiceError.InvalidAddress):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ChainServiceError.ServiceConnectivity):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ChainServiceError.Generic):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ChainServiceError.InvalidAddress):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ChainServiceError.ServiceConnectivity):
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ChainServiceError.Generic):
            buf.write_i32(3)
            _UniffiConverterString.write(value._values[0], buf)





class DepositClaimError:
    def __init__(self):
        raise RuntimeError("DepositClaimError cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class MAX_DEPOSIT_CLAIM_FEE_EXCEEDED:
        tx: "str"
        vout: "int"
        max_fee: "typing.Optional[Fee]"
        required_fee_sats: "int"
        required_fee_rate_sat_per_vbyte: "int"

        def __init__(self,tx: "str", vout: "int", max_fee: "typing.Optional[Fee]", required_fee_sats: "int", required_fee_rate_sat_per_vbyte: "int"):
            self.tx = tx
            self.vout = vout
            self.max_fee = max_fee
            self.required_fee_sats = required_fee_sats
            self.required_fee_rate_sat_per_vbyte = required_fee_rate_sat_per_vbyte

        def __str__(self):
            return "DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED(tx={}, vout={}, max_fee={}, required_fee_sats={}, required_fee_rate_sat_per_vbyte={})".format(self.tx, self.vout, self.max_fee, self.required_fee_sats, self.required_fee_rate_sat_per_vbyte)

        def __eq__(self, other):
            if not other.is_max_deposit_claim_fee_exceeded():
                return False
            if self.tx != other.tx:
                return False
            if self.vout != other.vout:
                return False
            if self.max_fee != other.max_fee:
                return False
            if self.required_fee_sats != other.required_fee_sats:
                return False
            if self.required_fee_rate_sat_per_vbyte != other.required_fee_rate_sat_per_vbyte:
                return False
            return True
    
    class MISSING_UTXO:
        tx: "str"
        vout: "int"

        def __init__(self,tx: "str", vout: "int"):
            self.tx = tx
            self.vout = vout

        def __str__(self):
            return "DepositClaimError.MISSING_UTXO(tx={}, vout={})".format(self.tx, self.vout)

        def __eq__(self, other):
            if not other.is_missing_utxo():
                return False
            if self.tx != other.tx:
                return False
            if self.vout != other.vout:
                return False
            return True
    
    class GENERIC:
        message: "str"

        def __init__(self,message: "str"):
            self.message = message

        def __str__(self):
            return "DepositClaimError.GENERIC(message={})".format(self.message)

        def __eq__(self, other):
            if not other.is_generic():
                return False
            if self.message != other.message:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_max_deposit_claim_fee_exceeded(self) -> bool:
        return isinstance(self, DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED)
    def is_missing_utxo(self) -> bool:
        return isinstance(self, DepositClaimError.MISSING_UTXO)
    def is_generic(self) -> bool:
        return isinstance(self, DepositClaimError.GENERIC)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED = type("DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED", (DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED, DepositClaimError,), {})  # type: ignore
DepositClaimError.MISSING_UTXO = type("DepositClaimError.MISSING_UTXO", (DepositClaimError.MISSING_UTXO, DepositClaimError,), {})  # type: ignore
DepositClaimError.GENERIC = type("DepositClaimError.GENERIC", (DepositClaimError.GENERIC, DepositClaimError,), {})  # type: ignore




class _UniffiConverterTypeDepositClaimError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterOptionalTypeFee.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return DepositClaimError.MISSING_UTXO(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 3:
            return DepositClaimError.GENERIC(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_max_deposit_claim_fee_exceeded():
            _UniffiConverterString.check_lower(value.tx)
            _UniffiConverterUInt32.check_lower(value.vout)
            _UniffiConverterOptionalTypeFee.check_lower(value.max_fee)
            _UniffiConverterUInt64.check_lower(value.required_fee_sats)
            _UniffiConverterUInt64.check_lower(value.required_fee_rate_sat_per_vbyte)
            return
        if value.is_missing_utxo():
            _UniffiConverterString.check_lower(value.tx)
            _UniffiConverterUInt32.check_lower(value.vout)
            return
        if value.is_generic():
            _UniffiConverterString.check_lower(value.message)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_max_deposit_claim_fee_exceeded():
            buf.write_i32(1)
            _UniffiConverterString.write(value.tx, buf)
            _UniffiConverterUInt32.write(value.vout, buf)
            _UniffiConverterOptionalTypeFee.write(value.max_fee, buf)
            _UniffiConverterUInt64.write(value.required_fee_sats, buf)
            _UniffiConverterUInt64.write(value.required_fee_rate_sat_per_vbyte, buf)
        if value.is_missing_utxo():
            buf.write_i32(2)
            _UniffiConverterString.write(value.tx, buf)
            _UniffiConverterUInt32.write(value.vout, buf)
        if value.is_generic():
            buf.write_i32(3)
            _UniffiConverterString.write(value.message, buf)







class ExternalPrivateKeySource:
    """
    FFI-safe representation of `spark_wallet::PrivateKeySource`
    """

    def __init__(self):
        raise RuntimeError("ExternalPrivateKeySource cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class DERIVED:
        """
        Private key derived from a tree node
        """

        node_id: "ExternalTreeNodeId"

        def __init__(self,node_id: "ExternalTreeNodeId"):
            self.node_id = node_id

        def __str__(self):
            return "ExternalPrivateKeySource.DERIVED(node_id={})".format(self.node_id)

        def __eq__(self, other):
            if not other.is_derived():
                return False
            if self.node_id != other.node_id:
                return False
            return True
    
    class ENCRYPTED:
        """
        Encrypted private key
        """

        key: "ExternalEncryptedPrivateKey"

        def __init__(self,key: "ExternalEncryptedPrivateKey"):
            self.key = key

        def __str__(self):
            return "ExternalPrivateKeySource.ENCRYPTED(key={})".format(self.key)

        def __eq__(self, other):
            if not other.is_encrypted():
                return False
            if self.key != other.key:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_derived(self) -> bool:
        return isinstance(self, ExternalPrivateKeySource.DERIVED)
    def is_encrypted(self) -> bool:
        return isinstance(self, ExternalPrivateKeySource.ENCRYPTED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ExternalPrivateKeySource.DERIVED = type("ExternalPrivateKeySource.DERIVED", (ExternalPrivateKeySource.DERIVED, ExternalPrivateKeySource,), {})  # type: ignore
ExternalPrivateKeySource.ENCRYPTED = type("ExternalPrivateKeySource.ENCRYPTED", (ExternalPrivateKeySource.ENCRYPTED, ExternalPrivateKeySource,), {})  # type: ignore




class _UniffiConverterTypeExternalPrivateKeySource(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExternalPrivateKeySource.DERIVED(
                _UniffiConverterTypeExternalTreeNodeId.read(buf),
            )
        if variant == 2:
            return ExternalPrivateKeySource.ENCRYPTED(
                _UniffiConverterTypeExternalEncryptedPrivateKey.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_derived():
            _UniffiConverterTypeExternalTreeNodeId.check_lower(value.node_id)
            return
        if value.is_encrypted():
            _UniffiConverterTypeExternalEncryptedPrivateKey.check_lower(value.key)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_derived():
            buf.write_i32(1)
            _UniffiConverterTypeExternalTreeNodeId.write(value.node_id, buf)
        if value.is_encrypted():
            buf.write_i32(2)
            _UniffiConverterTypeExternalEncryptedPrivateKey.write(value.key, buf)







class ExternalSecretToSplit:
    """
    FFI-safe representation of `spark_wallet::SecretToSplit`
    """

    def __init__(self):
        raise RuntimeError("ExternalSecretToSplit cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PRIVATE_KEY:
        """
        A private key to split
        """

        source: "ExternalPrivateKeySource"

        def __init__(self,source: "ExternalPrivateKeySource"):
            self.source = source

        def __str__(self):
            return "ExternalSecretToSplit.PRIVATE_KEY(source={})".format(self.source)

        def __eq__(self, other):
            if not other.is_private_key():
                return False
            if self.source != other.source:
                return False
            return True
    
    class PREIMAGE:
        """
        A preimage to split (32 bytes)
        """

        data: "bytes"

        def __init__(self,data: "bytes"):
            self.data = data

        def __str__(self):
            return "ExternalSecretToSplit.PREIMAGE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_preimage():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_private_key(self) -> bool:
        return isinstance(self, ExternalSecretToSplit.PRIVATE_KEY)
    def is_preimage(self) -> bool:
        return isinstance(self, ExternalSecretToSplit.PREIMAGE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ExternalSecretToSplit.PRIVATE_KEY = type("ExternalSecretToSplit.PRIVATE_KEY", (ExternalSecretToSplit.PRIVATE_KEY, ExternalSecretToSplit,), {})  # type: ignore
ExternalSecretToSplit.PREIMAGE = type("ExternalSecretToSplit.PREIMAGE", (ExternalSecretToSplit.PREIMAGE, ExternalSecretToSplit,), {})  # type: ignore




class _UniffiConverterTypeExternalSecretToSplit(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExternalSecretToSplit.PRIVATE_KEY(
                _UniffiConverterTypeExternalPrivateKeySource.read(buf),
            )
        if variant == 2:
            return ExternalSecretToSplit.PREIMAGE(
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_private_key():
            _UniffiConverterTypeExternalPrivateKeySource.check_lower(value.source)
            return
        if value.is_preimage():
            _UniffiConverterBytes.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_private_key():
            buf.write_i32(1)
            _UniffiConverterTypeExternalPrivateKeySource.write(value.source, buf)
        if value.is_preimage():
            buf.write_i32(2)
            _UniffiConverterBytes.write(value.data, buf)







class Fee:
    def __init__(self):
        raise RuntimeError("Fee cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FIXED:
        amount: "int"

        def __init__(self,amount: "int"):
            self.amount = amount

        def __str__(self):
            return "Fee.FIXED(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_fixed():
                return False
            if self.amount != other.amount:
                return False
            return True
    
    class RATE:
        sat_per_vbyte: "int"

        def __init__(self,sat_per_vbyte: "int"):
            self.sat_per_vbyte = sat_per_vbyte

        def __str__(self):
            return "Fee.RATE(sat_per_vbyte={})".format(self.sat_per_vbyte)

        def __eq__(self, other):
            if not other.is_rate():
                return False
            if self.sat_per_vbyte != other.sat_per_vbyte:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fixed(self) -> bool:
        return isinstance(self, Fee.FIXED)
    def is_rate(self) -> bool:
        return isinstance(self, Fee.RATE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Fee.FIXED = type("Fee.FIXED", (Fee.FIXED, Fee,), {})  # type: ignore
Fee.RATE = type("Fee.RATE", (Fee.RATE, Fee,), {})  # type: ignore




class _UniffiConverterTypeFee(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Fee.FIXED(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return Fee.RATE(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_fixed():
            _UniffiConverterUInt64.check_lower(value.amount)
            return
        if value.is_rate():
            _UniffiConverterUInt64.check_lower(value.sat_per_vbyte)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_fixed():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.amount, buf)
        if value.is_rate():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.sat_per_vbyte, buf)







class InputType:
    def __init__(self):
        raise RuntimeError("InputType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN_ADDRESS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], BitcoinAddressDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'BitcoinAddressDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.BITCOIN_ADDRESS{self._values!r}"

        def __eq__(self, other):
            if not other.is_bitcoin_address():
                return False
            return self._values == other._values
    class BOLT11_INVOICE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], Bolt11InvoiceDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'Bolt11InvoiceDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.BOLT11_INVOICE{self._values!r}"

        def __eq__(self, other):
            if not other.is_bolt11_invoice():
                return False
            return self._values == other._values
    class BOLT12_INVOICE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], Bolt12InvoiceDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'Bolt12InvoiceDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.BOLT12_INVOICE{self._values!r}"

        def __eq__(self, other):
            if not other.is_bolt12_invoice():
                return False
            return self._values == other._values
    class BOLT12_OFFER:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], Bolt12OfferDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'Bolt12OfferDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.BOLT12_OFFER{self._values!r}"

        def __eq__(self, other):
            if not other.is_bolt12_offer():
                return False
            return self._values == other._values
    class LIGHTNING_ADDRESS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], LightningAddressDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'LightningAddressDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.LIGHTNING_ADDRESS{self._values!r}"

        def __eq__(self, other):
            if not other.is_lightning_address():
                return False
            return self._values == other._values
    class LNURL_PAY:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], LnurlPayRequestDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'LnurlPayRequestDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.LNURL_PAY{self._values!r}"

        def __eq__(self, other):
            if not other.is_lnurl_pay():
                return False
            return self._values == other._values
    class SILENT_PAYMENT_ADDRESS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], SilentPaymentAddressDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'SilentPaymentAddressDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.SILENT_PAYMENT_ADDRESS{self._values!r}"

        def __eq__(self, other):
            if not other.is_silent_payment_address():
                return False
            return self._values == other._values
    class LNURL_AUTH:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], LnurlAuthRequestDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'LnurlAuthRequestDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.LNURL_AUTH{self._values!r}"

        def __eq__(self, other):
            if not other.is_lnurl_auth():
                return False
            return self._values == other._values
    class URL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.URL{self._values!r}"

        def __eq__(self, other):
            if not other.is_url():
                return False
            return self._values == other._values
    class BIP21:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], Bip21Details):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'Bip21Details', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.BIP21{self._values!r}"

        def __eq__(self, other):
            if not other.is_bip21():
                return False
            return self._values == other._values
    class BOLT12_INVOICE_REQUEST:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], Bolt12InvoiceRequestDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'Bolt12InvoiceRequestDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.BOLT12_INVOICE_REQUEST{self._values!r}"

        def __eq__(self, other):
            if not other.is_bolt12_invoice_request():
                return False
            return self._values == other._values
    class LNURL_WITHDRAW:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], LnurlWithdrawRequestDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'LnurlWithdrawRequestDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.LNURL_WITHDRAW{self._values!r}"

        def __eq__(self, other):
            if not other.is_lnurl_withdraw():
                return False
            return self._values == other._values
    class SPARK_ADDRESS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], SparkAddressDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'SparkAddressDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.SPARK_ADDRESS{self._values!r}"

        def __eq__(self, other):
            if not other.is_spark_address():
                return False
            return self._values == other._values
    class SPARK_INVOICE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], SparkInvoiceDetails):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'SparkInvoiceDetails', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"InputType.SPARK_INVOICE{self._values!r}"

        def __eq__(self, other):
            if not other.is_spark_invoice():
                return False
            return self._values == other._values
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin_address(self) -> bool:
        return isinstance(self, InputType.BITCOIN_ADDRESS)
    def is_bolt11_invoice(self) -> bool:
        return isinstance(self, InputType.BOLT11_INVOICE)
    def is_bolt12_invoice(self) -> bool:
        return isinstance(self, InputType.BOLT12_INVOICE)
    def is_bolt12_offer(self) -> bool:
        return isinstance(self, InputType.BOLT12_OFFER)
    def is_lightning_address(self) -> bool:
        return isinstance(self, InputType.LIGHTNING_ADDRESS)
    def is_lnurl_pay(self) -> bool:
        return isinstance(self, InputType.LNURL_PAY)
    def is_silent_payment_address(self) -> bool:
        return isinstance(self, InputType.SILENT_PAYMENT_ADDRESS)
    def is_lnurl_auth(self) -> bool:
        return isinstance(self, InputType.LNURL_AUTH)
    def is_url(self) -> bool:
        return isinstance(self, InputType.URL)
    def is_bip21(self) -> bool:
        return isinstance(self, InputType.BIP21)
    def is_bolt12_invoice_request(self) -> bool:
        return isinstance(self, InputType.BOLT12_INVOICE_REQUEST)
    def is_lnurl_withdraw(self) -> bool:
        return isinstance(self, InputType.LNURL_WITHDRAW)
    def is_spark_address(self) -> bool:
        return isinstance(self, InputType.SPARK_ADDRESS)
    def is_spark_invoice(self) -> bool:
        return isinstance(self, InputType.SPARK_INVOICE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
InputType.BITCOIN_ADDRESS = type("InputType.BITCOIN_ADDRESS", (InputType.BITCOIN_ADDRESS, InputType,), {})  # type: ignore
InputType.BOLT11_INVOICE = type("InputType.BOLT11_INVOICE", (InputType.BOLT11_INVOICE, InputType,), {})  # type: ignore
InputType.BOLT12_INVOICE = type("InputType.BOLT12_INVOICE", (InputType.BOLT12_INVOICE, InputType,), {})  # type: ignore
InputType.BOLT12_OFFER = type("InputType.BOLT12_OFFER", (InputType.BOLT12_OFFER, InputType,), {})  # type: ignore
InputType.LIGHTNING_ADDRESS = type("InputType.LIGHTNING_ADDRESS", (InputType.LIGHTNING_ADDRESS, InputType,), {})  # type: ignore
InputType.LNURL_PAY = type("InputType.LNURL_PAY", (InputType.LNURL_PAY, InputType,), {})  # type: ignore
InputType.SILENT_PAYMENT_ADDRESS = type("InputType.SILENT_PAYMENT_ADDRESS", (InputType.SILENT_PAYMENT_ADDRESS, InputType,), {})  # type: ignore
InputType.LNURL_AUTH = type("InputType.LNURL_AUTH", (InputType.LNURL_AUTH, InputType,), {})  # type: ignore
InputType.URL = type("InputType.URL", (InputType.URL, InputType,), {})  # type: ignore
InputType.BIP21 = type("InputType.BIP21", (InputType.BIP21, InputType,), {})  # type: ignore
InputType.BOLT12_INVOICE_REQUEST = type("InputType.BOLT12_INVOICE_REQUEST", (InputType.BOLT12_INVOICE_REQUEST, InputType,), {})  # type: ignore
InputType.LNURL_WITHDRAW = type("InputType.LNURL_WITHDRAW", (InputType.LNURL_WITHDRAW, InputType,), {})  # type: ignore
InputType.SPARK_ADDRESS = type("InputType.SPARK_ADDRESS", (InputType.SPARK_ADDRESS, InputType,), {})  # type: ignore
InputType.SPARK_INVOICE = type("InputType.SPARK_INVOICE", (InputType.SPARK_INVOICE, InputType,), {})  # type: ignore




class _UniffiConverterTypeInputType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return InputType.BITCOIN_ADDRESS(
                _UniffiConverterTypeBitcoinAddressDetails.read(buf),
            )
        if variant == 2:
            return InputType.BOLT11_INVOICE(
                _UniffiConverterTypeBolt11InvoiceDetails.read(buf),
            )
        if variant == 3:
            return InputType.BOLT12_INVOICE(
                _UniffiConverterTypeBolt12InvoiceDetails.read(buf),
            )
        if variant == 4:
            return InputType.BOLT12_OFFER(
                _UniffiConverterTypeBolt12OfferDetails.read(buf),
            )
        if variant == 5:
            return InputType.LIGHTNING_ADDRESS(
                _UniffiConverterTypeLightningAddressDetails.read(buf),
            )
        if variant == 6:
            return InputType.LNURL_PAY(
                _UniffiConverterTypeLnurlPayRequestDetails.read(buf),
            )
        if variant == 7:
            return InputType.SILENT_PAYMENT_ADDRESS(
                _UniffiConverterTypeSilentPaymentAddressDetails.read(buf),
            )
        if variant == 8:
            return InputType.LNURL_AUTH(
                _UniffiConverterTypeLnurlAuthRequestDetails.read(buf),
            )
        if variant == 9:
            return InputType.URL(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return InputType.BIP21(
                _UniffiConverterTypeBip21Details.read(buf),
            )
        if variant == 11:
            return InputType.BOLT12_INVOICE_REQUEST(
                _UniffiConverterTypeBolt12InvoiceRequestDetails.read(buf),
            )
        if variant == 12:
            return InputType.LNURL_WITHDRAW(
                _UniffiConverterTypeLnurlWithdrawRequestDetails.read(buf),
            )
        if variant == 13:
            return InputType.SPARK_ADDRESS(
                _UniffiConverterTypeSparkAddressDetails.read(buf),
            )
        if variant == 14:
            return InputType.SPARK_INVOICE(
                _UniffiConverterTypeSparkInvoiceDetails.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bitcoin_address():
            _UniffiConverterTypeBitcoinAddressDetails.check_lower(value._values[0])
            return
        if value.is_bolt11_invoice():
            _UniffiConverterTypeBolt11InvoiceDetails.check_lower(value._values[0])
            return
        if value.is_bolt12_invoice():
            _UniffiConverterTypeBolt12InvoiceDetails.check_lower(value._values[0])
            return
        if value.is_bolt12_offer():
            _UniffiConverterTypeBolt12OfferDetails.check_lower(value._values[0])
            return
        if value.is_lightning_address():
            _UniffiConverterTypeLightningAddressDetails.check_lower(value._values[0])
            return
        if value.is_lnurl_pay():
            _UniffiConverterTypeLnurlPayRequestDetails.check_lower(value._values[0])
            return
        if value.is_silent_payment_address():
            _UniffiConverterTypeSilentPaymentAddressDetails.check_lower(value._values[0])
            return
        if value.is_lnurl_auth():
            _UniffiConverterTypeLnurlAuthRequestDetails.check_lower(value._values[0])
            return
        if value.is_url():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_bip21():
            _UniffiConverterTypeBip21Details.check_lower(value._values[0])
            return
        if value.is_bolt12_invoice_request():
            _UniffiConverterTypeBolt12InvoiceRequestDetails.check_lower(value._values[0])
            return
        if value.is_lnurl_withdraw():
            _UniffiConverterTypeLnurlWithdrawRequestDetails.check_lower(value._values[0])
            return
        if value.is_spark_address():
            _UniffiConverterTypeSparkAddressDetails.check_lower(value._values[0])
            return
        if value.is_spark_invoice():
            _UniffiConverterTypeSparkInvoiceDetails.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_bitcoin_address():
            buf.write_i32(1)
            _UniffiConverterTypeBitcoinAddressDetails.write(value._values[0], buf)
        if value.is_bolt11_invoice():
            buf.write_i32(2)
            _UniffiConverterTypeBolt11InvoiceDetails.write(value._values[0], buf)
        if value.is_bolt12_invoice():
            buf.write_i32(3)
            _UniffiConverterTypeBolt12InvoiceDetails.write(value._values[0], buf)
        if value.is_bolt12_offer():
            buf.write_i32(4)
            _UniffiConverterTypeBolt12OfferDetails.write(value._values[0], buf)
        if value.is_lightning_address():
            buf.write_i32(5)
            _UniffiConverterTypeLightningAddressDetails.write(value._values[0], buf)
        if value.is_lnurl_pay():
            buf.write_i32(6)
            _UniffiConverterTypeLnurlPayRequestDetails.write(value._values[0], buf)
        if value.is_silent_payment_address():
            buf.write_i32(7)
            _UniffiConverterTypeSilentPaymentAddressDetails.write(value._values[0], buf)
        if value.is_lnurl_auth():
            buf.write_i32(8)
            _UniffiConverterTypeLnurlAuthRequestDetails.write(value._values[0], buf)
        if value.is_url():
            buf.write_i32(9)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_bip21():
            buf.write_i32(10)
            _UniffiConverterTypeBip21Details.write(value._values[0], buf)
        if value.is_bolt12_invoice_request():
            buf.write_i32(11)
            _UniffiConverterTypeBolt12InvoiceRequestDetails.write(value._values[0], buf)
        if value.is_lnurl_withdraw():
            buf.write_i32(12)
            _UniffiConverterTypeLnurlWithdrawRequestDetails.write(value._values[0], buf)
        if value.is_spark_address():
            buf.write_i32(13)
            _UniffiConverterTypeSparkAddressDetails.write(value._values[0], buf)
        if value.is_spark_invoice():
            buf.write_i32(14)
            _UniffiConverterTypeSparkInvoiceDetails.write(value._values[0], buf)







class KeySetType(enum.Enum):
    DEFAULT = 0
    
    TAPROOT = 1
    
    NATIVE_SEGWIT = 2
    
    WRAPPED_SEGWIT = 3
    
    LEGACY = 4
    


class _UniffiConverterTypeKeySetType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KeySetType.DEFAULT
        if variant == 2:
            return KeySetType.TAPROOT
        if variant == 3:
            return KeySetType.NATIVE_SEGWIT
        if variant == 4:
            return KeySetType.WRAPPED_SEGWIT
        if variant == 5:
            return KeySetType.LEGACY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == KeySetType.DEFAULT:
            return
        if value == KeySetType.TAPROOT:
            return
        if value == KeySetType.NATIVE_SEGWIT:
            return
        if value == KeySetType.WRAPPED_SEGWIT:
            return
        if value == KeySetType.LEGACY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == KeySetType.DEFAULT:
            buf.write_i32(1)
        if value == KeySetType.TAPROOT:
            buf.write_i32(2)
        if value == KeySetType.NATIVE_SEGWIT:
            buf.write_i32(3)
        if value == KeySetType.WRAPPED_SEGWIT:
            buf.write_i32(4)
        if value == KeySetType.LEGACY:
            buf.write_i32(5)







class MaxFee:
    def __init__(self):
        raise RuntimeError("MaxFee cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FIXED:
        amount: "int"

        def __init__(self,amount: "int"):
            self.amount = amount

        def __str__(self):
            return "MaxFee.FIXED(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_fixed():
                return False
            if self.amount != other.amount:
                return False
            return True
    
    class RATE:
        sat_per_vbyte: "int"

        def __init__(self,sat_per_vbyte: "int"):
            self.sat_per_vbyte = sat_per_vbyte

        def __str__(self):
            return "MaxFee.RATE(sat_per_vbyte={})".format(self.sat_per_vbyte)

        def __eq__(self, other):
            if not other.is_rate():
                return False
            if self.sat_per_vbyte != other.sat_per_vbyte:
                return False
            return True
    
    class NETWORK_RECOMMENDED:
        leeway_sat_per_vbyte: "int"

        def __init__(self,leeway_sat_per_vbyte: "int"):
            self.leeway_sat_per_vbyte = leeway_sat_per_vbyte

        def __str__(self):
            return "MaxFee.NETWORK_RECOMMENDED(leeway_sat_per_vbyte={})".format(self.leeway_sat_per_vbyte)

        def __eq__(self, other):
            if not other.is_network_recommended():
                return False
            if self.leeway_sat_per_vbyte != other.leeway_sat_per_vbyte:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fixed(self) -> bool:
        return isinstance(self, MaxFee.FIXED)
    def is_rate(self) -> bool:
        return isinstance(self, MaxFee.RATE)
    def is_network_recommended(self) -> bool:
        return isinstance(self, MaxFee.NETWORK_RECOMMENDED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
MaxFee.FIXED = type("MaxFee.FIXED", (MaxFee.FIXED, MaxFee,), {})  # type: ignore
MaxFee.RATE = type("MaxFee.RATE", (MaxFee.RATE, MaxFee,), {})  # type: ignore
MaxFee.NETWORK_RECOMMENDED = type("MaxFee.NETWORK_RECOMMENDED", (MaxFee.NETWORK_RECOMMENDED, MaxFee,), {})  # type: ignore




class _UniffiConverterTypeMaxFee(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MaxFee.FIXED(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return MaxFee.RATE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return MaxFee.NETWORK_RECOMMENDED(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_fixed():
            _UniffiConverterUInt64.check_lower(value.amount)
            return
        if value.is_rate():
            _UniffiConverterUInt64.check_lower(value.sat_per_vbyte)
            return
        if value.is_network_recommended():
            _UniffiConverterUInt64.check_lower(value.leeway_sat_per_vbyte)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_fixed():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.amount, buf)
        if value.is_rate():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.sat_per_vbyte, buf)
        if value.is_network_recommended():
            buf.write_i32(3)
            _UniffiConverterUInt64.write(value.leeway_sat_per_vbyte, buf)







class Network(enum.Enum):
    MAINNET = 0
    
    REGTEST = 1
    


class _UniffiConverterTypeNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Network.MAINNET
        if variant == 2:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Network.MAINNET:
            return
        if value == Network.REGTEST:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Network.MAINNET:
            buf.write_i32(1)
        if value == Network.REGTEST:
            buf.write_i32(2)







class OnchainConfirmationSpeed(enum.Enum):
    FAST = 0
    
    MEDIUM = 1
    
    SLOW = 2
    


class _UniffiConverterTypeOnchainConfirmationSpeed(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OnchainConfirmationSpeed.FAST
        if variant == 2:
            return OnchainConfirmationSpeed.MEDIUM
        if variant == 3:
            return OnchainConfirmationSpeed.SLOW
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == OnchainConfirmationSpeed.FAST:
            return
        if value == OnchainConfirmationSpeed.MEDIUM:
            return
        if value == OnchainConfirmationSpeed.SLOW:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == OnchainConfirmationSpeed.FAST:
            buf.write_i32(1)
        if value == OnchainConfirmationSpeed.MEDIUM:
            buf.write_i32(2)
        if value == OnchainConfirmationSpeed.SLOW:
            buf.write_i32(3)







class OptimizationEvent:
    def __init__(self):
        raise RuntimeError("OptimizationEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class STARTED:
        """
        Optimization has started with the given number of rounds.
        """

        total_rounds: "int"

        def __init__(self,total_rounds: "int"):
            self.total_rounds = total_rounds

        def __str__(self):
            return "OptimizationEvent.STARTED(total_rounds={})".format(self.total_rounds)

        def __eq__(self, other):
            if not other.is_started():
                return False
            if self.total_rounds != other.total_rounds:
                return False
            return True
    
    class ROUND_COMPLETED:
        """
        A round has completed.
        """

        current_round: "int"
        total_rounds: "int"

        def __init__(self,current_round: "int", total_rounds: "int"):
            self.current_round = current_round
            self.total_rounds = total_rounds

        def __str__(self):
            return "OptimizationEvent.ROUND_COMPLETED(current_round={}, total_rounds={})".format(self.current_round, self.total_rounds)

        def __eq__(self, other):
            if not other.is_round_completed():
                return False
            if self.current_round != other.current_round:
                return False
            if self.total_rounds != other.total_rounds:
                return False
            return True
    
    class COMPLETED:
        """
        Optimization completed successfully.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "OptimizationEvent.COMPLETED()".format()

        def __eq__(self, other):
            if not other.is_completed():
                return False
            return True
    
    class CANCELLED:
        """
        Optimization was cancelled.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "OptimizationEvent.CANCELLED()".format()

        def __eq__(self, other):
            if not other.is_cancelled():
                return False
            return True
    
    class FAILED:
        """
        Optimization failed with an error.
        """

        error: "str"

        def __init__(self,error: "str"):
            self.error = error

        def __str__(self):
            return "OptimizationEvent.FAILED(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_failed():
                return False
            if self.error != other.error:
                return False
            return True
    
    class SKIPPED:
        """
        Optimization was skipped because leaves are already optimal.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "OptimizationEvent.SKIPPED()".format()

        def __eq__(self, other):
            if not other.is_skipped():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_started(self) -> bool:
        return isinstance(self, OptimizationEvent.STARTED)
    def is_round_completed(self) -> bool:
        return isinstance(self, OptimizationEvent.ROUND_COMPLETED)
    def is_completed(self) -> bool:
        return isinstance(self, OptimizationEvent.COMPLETED)
    def is_cancelled(self) -> bool:
        return isinstance(self, OptimizationEvent.CANCELLED)
    def is_failed(self) -> bool:
        return isinstance(self, OptimizationEvent.FAILED)
    def is_skipped(self) -> bool:
        return isinstance(self, OptimizationEvent.SKIPPED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
OptimizationEvent.STARTED = type("OptimizationEvent.STARTED", (OptimizationEvent.STARTED, OptimizationEvent,), {})  # type: ignore
OptimizationEvent.ROUND_COMPLETED = type("OptimizationEvent.ROUND_COMPLETED", (OptimizationEvent.ROUND_COMPLETED, OptimizationEvent,), {})  # type: ignore
OptimizationEvent.COMPLETED = type("OptimizationEvent.COMPLETED", (OptimizationEvent.COMPLETED, OptimizationEvent,), {})  # type: ignore
OptimizationEvent.CANCELLED = type("OptimizationEvent.CANCELLED", (OptimizationEvent.CANCELLED, OptimizationEvent,), {})  # type: ignore
OptimizationEvent.FAILED = type("OptimizationEvent.FAILED", (OptimizationEvent.FAILED, OptimizationEvent,), {})  # type: ignore
OptimizationEvent.SKIPPED = type("OptimizationEvent.SKIPPED", (OptimizationEvent.SKIPPED, OptimizationEvent,), {})  # type: ignore




class _UniffiConverterTypeOptimizationEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OptimizationEvent.STARTED(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 2:
            return OptimizationEvent.ROUND_COMPLETED(
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 3:
            return OptimizationEvent.COMPLETED(
            )
        if variant == 4:
            return OptimizationEvent.CANCELLED(
            )
        if variant == 5:
            return OptimizationEvent.FAILED(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return OptimizationEvent.SKIPPED(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_started():
            _UniffiConverterUInt32.check_lower(value.total_rounds)
            return
        if value.is_round_completed():
            _UniffiConverterUInt32.check_lower(value.current_round)
            _UniffiConverterUInt32.check_lower(value.total_rounds)
            return
        if value.is_completed():
            return
        if value.is_cancelled():
            return
        if value.is_failed():
            _UniffiConverterString.check_lower(value.error)
            return
        if value.is_skipped():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_started():
            buf.write_i32(1)
            _UniffiConverterUInt32.write(value.total_rounds, buf)
        if value.is_round_completed():
            buf.write_i32(2)
            _UniffiConverterUInt32.write(value.current_round, buf)
            _UniffiConverterUInt32.write(value.total_rounds, buf)
        if value.is_completed():
            buf.write_i32(3)
        if value.is_cancelled():
            buf.write_i32(4)
        if value.is_failed():
            buf.write_i32(5)
            _UniffiConverterString.write(value.error, buf)
        if value.is_skipped():
            buf.write_i32(6)







class PaymentDetails:
    def __init__(self):
        raise RuntimeError("PaymentDetails cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SPARK:
        invoice_details: "typing.Optional[SparkInvoicePaymentDetails]"
        """
        The invoice details if the payment fulfilled a spark invoice
        """

        htlc_details: "typing.Optional[SparkHtlcDetails]"
        """
        The HTLC transfer details if the payment fulfilled an HTLC transfer
        """

        token_conversion_info: "typing.Optional[TokenConversionInfo]"
        """
        The information for a token conversion
        """


        def __init__(self,invoice_details: "typing.Optional[SparkInvoicePaymentDetails]", htlc_details: "typing.Optional[SparkHtlcDetails]", token_conversion_info: "typing.Optional[TokenConversionInfo]"):
            self.invoice_details = invoice_details
            self.htlc_details = htlc_details
            self.token_conversion_info = token_conversion_info

        def __str__(self):
            return "PaymentDetails.SPARK(invoice_details={}, htlc_details={}, token_conversion_info={})".format(self.invoice_details, self.htlc_details, self.token_conversion_info)

        def __eq__(self, other):
            if not other.is_spark():
                return False
            if self.invoice_details != other.invoice_details:
                return False
            if self.htlc_details != other.htlc_details:
                return False
            if self.token_conversion_info != other.token_conversion_info:
                return False
            return True
    
    class TOKEN:
        metadata: "TokenMetadata"
        tx_hash: "str"
        invoice_details: "typing.Optional[SparkInvoicePaymentDetails]"
        """
        The invoice details if the payment fulfilled a spark invoice
        """

        token_conversion_info: "typing.Optional[TokenConversionInfo]"
        """
        The information for a token conversion
        """


        def __init__(self,metadata: "TokenMetadata", tx_hash: "str", invoice_details: "typing.Optional[SparkInvoicePaymentDetails]", token_conversion_info: "typing.Optional[TokenConversionInfo]"):
            self.metadata = metadata
            self.tx_hash = tx_hash
            self.invoice_details = invoice_details
            self.token_conversion_info = token_conversion_info

        def __str__(self):
            return "PaymentDetails.TOKEN(metadata={}, tx_hash={}, invoice_details={}, token_conversion_info={})".format(self.metadata, self.tx_hash, self.invoice_details, self.token_conversion_info)

        def __eq__(self, other):
            if not other.is_token():
                return False
            if self.metadata != other.metadata:
                return False
            if self.tx_hash != other.tx_hash:
                return False
            if self.invoice_details != other.invoice_details:
                return False
            if self.token_conversion_info != other.token_conversion_info:
                return False
            return True
    
    class LIGHTNING:
        description: "typing.Optional[str]"
        """
        Represents the invoice description
        """

        preimage: "typing.Optional[str]"
        """
        The preimage of the paid invoice (proof of payment).
        """

        invoice: "str"
        """
        Represents the Bolt11/Bolt12 invoice associated with a payment
        In the case of a Send payment, this is the invoice paid by the user
        In the case of a Receive payment, this is the invoice paid to the user
        """

        payment_hash: "str"
        """
        The payment hash of the invoice
        """

        destination_pubkey: "str"
        """
        The invoice destination/payee pubkey
        """

        lnurl_pay_info: "typing.Optional[LnurlPayInfo]"
        """
        Lnurl payment information if this was an lnurl payment.
        """

        lnurl_withdraw_info: "typing.Optional[LnurlWithdrawInfo]"
        """
        Lnurl withdrawal information if this was an lnurl payment.
        """

        lnurl_receive_metadata: "typing.Optional[LnurlReceiveMetadata]"
        """
        Lnurl receive information if this was a received lnurl payment.
        """


        def __init__(self,description: "typing.Optional[str]", preimage: "typing.Optional[str]", invoice: "str", payment_hash: "str", destination_pubkey: "str", lnurl_pay_info: "typing.Optional[LnurlPayInfo]", lnurl_withdraw_info: "typing.Optional[LnurlWithdrawInfo]", lnurl_receive_metadata: "typing.Optional[LnurlReceiveMetadata]"):
            self.description = description
            self.preimage = preimage
            self.invoice = invoice
            self.payment_hash = payment_hash
            self.destination_pubkey = destination_pubkey
            self.lnurl_pay_info = lnurl_pay_info
            self.lnurl_withdraw_info = lnurl_withdraw_info
            self.lnurl_receive_metadata = lnurl_receive_metadata

        def __str__(self):
            return "PaymentDetails.LIGHTNING(description={}, preimage={}, invoice={}, payment_hash={}, destination_pubkey={}, lnurl_pay_info={}, lnurl_withdraw_info={}, lnurl_receive_metadata={})".format(self.description, self.preimage, self.invoice, self.payment_hash, self.destination_pubkey, self.lnurl_pay_info, self.lnurl_withdraw_info, self.lnurl_receive_metadata)

        def __eq__(self, other):
            if not other.is_lightning():
                return False
            if self.description != other.description:
                return False
            if self.preimage != other.preimage:
                return False
            if self.invoice != other.invoice:
                return False
            if self.payment_hash != other.payment_hash:
                return False
            if self.destination_pubkey != other.destination_pubkey:
                return False
            if self.lnurl_pay_info != other.lnurl_pay_info:
                return False
            if self.lnurl_withdraw_info != other.lnurl_withdraw_info:
                return False
            if self.lnurl_receive_metadata != other.lnurl_receive_metadata:
                return False
            return True
    
    class WITHDRAW:
        tx_id: "str"

        def __init__(self,tx_id: "str"):
            self.tx_id = tx_id

        def __str__(self):
            return "PaymentDetails.WITHDRAW(tx_id={})".format(self.tx_id)

        def __eq__(self, other):
            if not other.is_withdraw():
                return False
            if self.tx_id != other.tx_id:
                return False
            return True
    
    class DEPOSIT:
        tx_id: "str"

        def __init__(self,tx_id: "str"):
            self.tx_id = tx_id

        def __str__(self):
            return "PaymentDetails.DEPOSIT(tx_id={})".format(self.tx_id)

        def __eq__(self, other):
            if not other.is_deposit():
                return False
            if self.tx_id != other.tx_id:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_spark(self) -> bool:
        return isinstance(self, PaymentDetails.SPARK)
    def is_token(self) -> bool:
        return isinstance(self, PaymentDetails.TOKEN)
    def is_lightning(self) -> bool:
        return isinstance(self, PaymentDetails.LIGHTNING)
    def is_withdraw(self) -> bool:
        return isinstance(self, PaymentDetails.WITHDRAW)
    def is_deposit(self) -> bool:
        return isinstance(self, PaymentDetails.DEPOSIT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PaymentDetails.SPARK = type("PaymentDetails.SPARK", (PaymentDetails.SPARK, PaymentDetails,), {})  # type: ignore
PaymentDetails.TOKEN = type("PaymentDetails.TOKEN", (PaymentDetails.TOKEN, PaymentDetails,), {})  # type: ignore
PaymentDetails.LIGHTNING = type("PaymentDetails.LIGHTNING", (PaymentDetails.LIGHTNING, PaymentDetails,), {})  # type: ignore
PaymentDetails.WITHDRAW = type("PaymentDetails.WITHDRAW", (PaymentDetails.WITHDRAW, PaymentDetails,), {})  # type: ignore
PaymentDetails.DEPOSIT = type("PaymentDetails.DEPOSIT", (PaymentDetails.DEPOSIT, PaymentDetails,), {})  # type: ignore




class _UniffiConverterTypePaymentDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentDetails.SPARK(
                _UniffiConverterOptionalTypeSparkInvoicePaymentDetails.read(buf),
                _UniffiConverterOptionalTypeSparkHtlcDetails.read(buf),
                _UniffiConverterOptionalTypeTokenConversionInfo.read(buf),
            )
        if variant == 2:
            return PaymentDetails.TOKEN(
                _UniffiConverterTypeTokenMetadata.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeSparkInvoicePaymentDetails.read(buf),
                _UniffiConverterOptionalTypeTokenConversionInfo.read(buf),
            )
        if variant == 3:
            return PaymentDetails.LIGHTNING(
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalTypeLnurlPayInfo.read(buf),
                _UniffiConverterOptionalTypeLnurlWithdrawInfo.read(buf),
                _UniffiConverterOptionalTypeLnurlReceiveMetadata.read(buf),
            )
        if variant == 4:
            return PaymentDetails.WITHDRAW(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return PaymentDetails.DEPOSIT(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_spark():
            _UniffiConverterOptionalTypeSparkInvoicePaymentDetails.check_lower(value.invoice_details)
            _UniffiConverterOptionalTypeSparkHtlcDetails.check_lower(value.htlc_details)
            _UniffiConverterOptionalTypeTokenConversionInfo.check_lower(value.token_conversion_info)
            return
        if value.is_token():
            _UniffiConverterTypeTokenMetadata.check_lower(value.metadata)
            _UniffiConverterString.check_lower(value.tx_hash)
            _UniffiConverterOptionalTypeSparkInvoicePaymentDetails.check_lower(value.invoice_details)
            _UniffiConverterOptionalTypeTokenConversionInfo.check_lower(value.token_conversion_info)
            return
        if value.is_lightning():
            _UniffiConverterOptionalString.check_lower(value.description)
            _UniffiConverterOptionalString.check_lower(value.preimage)
            _UniffiConverterString.check_lower(value.invoice)
            _UniffiConverterString.check_lower(value.payment_hash)
            _UniffiConverterString.check_lower(value.destination_pubkey)
            _UniffiConverterOptionalTypeLnurlPayInfo.check_lower(value.lnurl_pay_info)
            _UniffiConverterOptionalTypeLnurlWithdrawInfo.check_lower(value.lnurl_withdraw_info)
            _UniffiConverterOptionalTypeLnurlReceiveMetadata.check_lower(value.lnurl_receive_metadata)
            return
        if value.is_withdraw():
            _UniffiConverterString.check_lower(value.tx_id)
            return
        if value.is_deposit():
            _UniffiConverterString.check_lower(value.tx_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_spark():
            buf.write_i32(1)
            _UniffiConverterOptionalTypeSparkInvoicePaymentDetails.write(value.invoice_details, buf)
            _UniffiConverterOptionalTypeSparkHtlcDetails.write(value.htlc_details, buf)
            _UniffiConverterOptionalTypeTokenConversionInfo.write(value.token_conversion_info, buf)
        if value.is_token():
            buf.write_i32(2)
            _UniffiConverterTypeTokenMetadata.write(value.metadata, buf)
            _UniffiConverterString.write(value.tx_hash, buf)
            _UniffiConverterOptionalTypeSparkInvoicePaymentDetails.write(value.invoice_details, buf)
            _UniffiConverterOptionalTypeTokenConversionInfo.write(value.token_conversion_info, buf)
        if value.is_lightning():
            buf.write_i32(3)
            _UniffiConverterOptionalString.write(value.description, buf)
            _UniffiConverterOptionalString.write(value.preimage, buf)
            _UniffiConverterString.write(value.invoice, buf)
            _UniffiConverterString.write(value.payment_hash, buf)
            _UniffiConverterString.write(value.destination_pubkey, buf)
            _UniffiConverterOptionalTypeLnurlPayInfo.write(value.lnurl_pay_info, buf)
            _UniffiConverterOptionalTypeLnurlWithdrawInfo.write(value.lnurl_withdraw_info, buf)
            _UniffiConverterOptionalTypeLnurlReceiveMetadata.write(value.lnurl_receive_metadata, buf)
        if value.is_withdraw():
            buf.write_i32(4)
            _UniffiConverterString.write(value.tx_id, buf)
        if value.is_deposit():
            buf.write_i32(5)
            _UniffiConverterString.write(value.tx_id, buf)







class PaymentDetailsFilter:
    def __init__(self):
        raise RuntimeError("PaymentDetailsFilter cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SPARK:
        htlc_status: "typing.Optional[typing.List[SparkHtlcStatus]]"
        """
        Filter specific Spark HTLC statuses
        """

        conversion_refund_needed: "typing.Optional[bool]"
        """
        Filter conversion payments with refund information
        """


        def __init__(self,htlc_status: "typing.Optional[typing.List[SparkHtlcStatus]]", conversion_refund_needed: "typing.Optional[bool]"):
            self.htlc_status = htlc_status
            self.conversion_refund_needed = conversion_refund_needed

        def __str__(self):
            return "PaymentDetailsFilter.SPARK(htlc_status={}, conversion_refund_needed={})".format(self.htlc_status, self.conversion_refund_needed)

        def __eq__(self, other):
            if not other.is_spark():
                return False
            if self.htlc_status != other.htlc_status:
                return False
            if self.conversion_refund_needed != other.conversion_refund_needed:
                return False
            return True
    
    class TOKEN:
        conversion_refund_needed: "typing.Optional[bool]"
        """
        Filter conversion payments with refund information
        """

        tx_hash: "typing.Optional[str]"
        """
        Filter by transaction hash
        """


        def __init__(self,conversion_refund_needed: "typing.Optional[bool]", tx_hash: "typing.Optional[str]"):
            self.conversion_refund_needed = conversion_refund_needed
            self.tx_hash = tx_hash

        def __str__(self):
            return "PaymentDetailsFilter.TOKEN(conversion_refund_needed={}, tx_hash={})".format(self.conversion_refund_needed, self.tx_hash)

        def __eq__(self, other):
            if not other.is_token():
                return False
            if self.conversion_refund_needed != other.conversion_refund_needed:
                return False
            if self.tx_hash != other.tx_hash:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_spark(self) -> bool:
        return isinstance(self, PaymentDetailsFilter.SPARK)
    def is_token(self) -> bool:
        return isinstance(self, PaymentDetailsFilter.TOKEN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PaymentDetailsFilter.SPARK = type("PaymentDetailsFilter.SPARK", (PaymentDetailsFilter.SPARK, PaymentDetailsFilter,), {})  # type: ignore
PaymentDetailsFilter.TOKEN = type("PaymentDetailsFilter.TOKEN", (PaymentDetailsFilter.TOKEN, PaymentDetailsFilter,), {})  # type: ignore




class _UniffiConverterTypePaymentDetailsFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentDetailsFilter.SPARK(
                _UniffiConverterOptionalSequenceTypeSparkHtlcStatus.read(buf),
                _UniffiConverterOptionalBool.read(buf),
            )
        if variant == 2:
            return PaymentDetailsFilter.TOKEN(
                _UniffiConverterOptionalBool.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_spark():
            _UniffiConverterOptionalSequenceTypeSparkHtlcStatus.check_lower(value.htlc_status)
            _UniffiConverterOptionalBool.check_lower(value.conversion_refund_needed)
            return
        if value.is_token():
            _UniffiConverterOptionalBool.check_lower(value.conversion_refund_needed)
            _UniffiConverterOptionalString.check_lower(value.tx_hash)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_spark():
            buf.write_i32(1)
            _UniffiConverterOptionalSequenceTypeSparkHtlcStatus.write(value.htlc_status, buf)
            _UniffiConverterOptionalBool.write(value.conversion_refund_needed, buf)
        if value.is_token():
            buf.write_i32(2)
            _UniffiConverterOptionalBool.write(value.conversion_refund_needed, buf)
            _UniffiConverterOptionalString.write(value.tx_hash, buf)







class PaymentMethod(enum.Enum):
    LIGHTNING = 0
    
    SPARK = 1
    
    TOKEN = 2
    
    DEPOSIT = 3
    
    WITHDRAW = 4
    
    UNKNOWN = 5
    


class _UniffiConverterTypePaymentMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentMethod.LIGHTNING
        if variant == 2:
            return PaymentMethod.SPARK
        if variant == 3:
            return PaymentMethod.TOKEN
        if variant == 4:
            return PaymentMethod.DEPOSIT
        if variant == 5:
            return PaymentMethod.WITHDRAW
        if variant == 6:
            return PaymentMethod.UNKNOWN
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentMethod.LIGHTNING:
            return
        if value == PaymentMethod.SPARK:
            return
        if value == PaymentMethod.TOKEN:
            return
        if value == PaymentMethod.DEPOSIT:
            return
        if value == PaymentMethod.WITHDRAW:
            return
        if value == PaymentMethod.UNKNOWN:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentMethod.LIGHTNING:
            buf.write_i32(1)
        if value == PaymentMethod.SPARK:
            buf.write_i32(2)
        if value == PaymentMethod.TOKEN:
            buf.write_i32(3)
        if value == PaymentMethod.DEPOSIT:
            buf.write_i32(4)
        if value == PaymentMethod.WITHDRAW:
            buf.write_i32(5)
        if value == PaymentMethod.UNKNOWN:
            buf.write_i32(6)




# PaymentObserverError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class PaymentObserverError(Exception):
    pass

_UniffiTempPaymentObserverError = PaymentObserverError

class PaymentObserverError:  # type: ignore
    class ServiceConnectivity(_UniffiTempPaymentObserverError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "PaymentObserverError.ServiceConnectivity({})".format(str(self))
    _UniffiTempPaymentObserverError.ServiceConnectivity = ServiceConnectivity # type: ignore
    class Generic(_UniffiTempPaymentObserverError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "PaymentObserverError.Generic({})".format(str(self))
    _UniffiTempPaymentObserverError.Generic = Generic # type: ignore

PaymentObserverError = _UniffiTempPaymentObserverError # type: ignore
del _UniffiTempPaymentObserverError


class _UniffiConverterTypePaymentObserverError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentObserverError.ServiceConnectivity(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return PaymentObserverError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, PaymentObserverError.ServiceConnectivity):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, PaymentObserverError.Generic):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, PaymentObserverError.ServiceConnectivity):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, PaymentObserverError.Generic):
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)





class PaymentStatus(enum.Enum):
    """
    The status of a payment
    """

    COMPLETED = 0
    """
    Payment is completed successfully
    """

    
    PENDING = 1
    """
    Payment is in progress
    """

    
    FAILED = 2
    """
    Payment has failed
    """

    


class _UniffiConverterTypePaymentStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentStatus.COMPLETED
        if variant == 2:
            return PaymentStatus.PENDING
        if variant == 3:
            return PaymentStatus.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentStatus.COMPLETED:
            return
        if value == PaymentStatus.PENDING:
            return
        if value == PaymentStatus.FAILED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentStatus.COMPLETED:
            buf.write_i32(1)
        if value == PaymentStatus.PENDING:
            buf.write_i32(2)
        if value == PaymentStatus.FAILED:
            buf.write_i32(3)







class PaymentType(enum.Enum):
    """
    The type of payment
    """

    SEND = 0
    """
    Payment sent from this wallet
    """

    
    RECEIVE = 1
    """
    Payment received to this wallet
    """

    


class _UniffiConverterTypePaymentType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentType.SEND
        if variant == 2:
            return PaymentType.RECEIVE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentType.SEND:
            return
        if value == PaymentType.RECEIVE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentType.SEND:
            buf.write_i32(1)
        if value == PaymentType.RECEIVE:
            buf.write_i32(2)







class ProvisionalPaymentDetails:
    def __init__(self):
        raise RuntimeError("ProvisionalPaymentDetails cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN:
        withdrawal_address: "str"
        """
        Onchain Bitcoin address
        """


        def __init__(self,withdrawal_address: "str"):
            self.withdrawal_address = withdrawal_address

        def __str__(self):
            return "ProvisionalPaymentDetails.BITCOIN(withdrawal_address={})".format(self.withdrawal_address)

        def __eq__(self, other):
            if not other.is_bitcoin():
                return False
            if self.withdrawal_address != other.withdrawal_address:
                return False
            return True
    
    class LIGHTNING:
        invoice: "str"
        """
        BOLT11 invoice
        """


        def __init__(self,invoice: "str"):
            self.invoice = invoice

        def __str__(self):
            return "ProvisionalPaymentDetails.LIGHTNING(invoice={})".format(self.invoice)

        def __eq__(self, other):
            if not other.is_lightning():
                return False
            if self.invoice != other.invoice:
                return False
            return True
    
    class SPARK:
        pay_request: "str"
        """
        Spark pay request being paid (either a Spark address or a Spark invoice)
        """


        def __init__(self,pay_request: "str"):
            self.pay_request = pay_request

        def __str__(self):
            return "ProvisionalPaymentDetails.SPARK(pay_request={})".format(self.pay_request)

        def __eq__(self, other):
            if not other.is_spark():
                return False
            if self.pay_request != other.pay_request:
                return False
            return True
    
    class TOKEN:
        token_id: "str"
        """
        Token identifier
        """

        pay_request: "str"
        """
        Spark pay request being paid (either a Spark address or a Spark invoice)
        """


        def __init__(self,token_id: "str", pay_request: "str"):
            self.token_id = token_id
            self.pay_request = pay_request

        def __str__(self):
            return "ProvisionalPaymentDetails.TOKEN(token_id={}, pay_request={})".format(self.token_id, self.pay_request)

        def __eq__(self, other):
            if not other.is_token():
                return False
            if self.token_id != other.token_id:
                return False
            if self.pay_request != other.pay_request:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin(self) -> bool:
        return isinstance(self, ProvisionalPaymentDetails.BITCOIN)
    def is_lightning(self) -> bool:
        return isinstance(self, ProvisionalPaymentDetails.LIGHTNING)
    def is_spark(self) -> bool:
        return isinstance(self, ProvisionalPaymentDetails.SPARK)
    def is_token(self) -> bool:
        return isinstance(self, ProvisionalPaymentDetails.TOKEN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ProvisionalPaymentDetails.BITCOIN = type("ProvisionalPaymentDetails.BITCOIN", (ProvisionalPaymentDetails.BITCOIN, ProvisionalPaymentDetails,), {})  # type: ignore
ProvisionalPaymentDetails.LIGHTNING = type("ProvisionalPaymentDetails.LIGHTNING", (ProvisionalPaymentDetails.LIGHTNING, ProvisionalPaymentDetails,), {})  # type: ignore
ProvisionalPaymentDetails.SPARK = type("ProvisionalPaymentDetails.SPARK", (ProvisionalPaymentDetails.SPARK, ProvisionalPaymentDetails,), {})  # type: ignore
ProvisionalPaymentDetails.TOKEN = type("ProvisionalPaymentDetails.TOKEN", (ProvisionalPaymentDetails.TOKEN, ProvisionalPaymentDetails,), {})  # type: ignore




class _UniffiConverterTypeProvisionalPaymentDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ProvisionalPaymentDetails.BITCOIN(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ProvisionalPaymentDetails.LIGHTNING(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ProvisionalPaymentDetails.SPARK(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return ProvisionalPaymentDetails.TOKEN(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bitcoin():
            _UniffiConverterString.check_lower(value.withdrawal_address)
            return
        if value.is_lightning():
            _UniffiConverterString.check_lower(value.invoice)
            return
        if value.is_spark():
            _UniffiConverterString.check_lower(value.pay_request)
            return
        if value.is_token():
            _UniffiConverterString.check_lower(value.token_id)
            _UniffiConverterString.check_lower(value.pay_request)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_bitcoin():
            buf.write_i32(1)
            _UniffiConverterString.write(value.withdrawal_address, buf)
        if value.is_lightning():
            buf.write_i32(2)
            _UniffiConverterString.write(value.invoice, buf)
        if value.is_spark():
            buf.write_i32(3)
            _UniffiConverterString.write(value.pay_request, buf)
        if value.is_token():
            buf.write_i32(4)
            _UniffiConverterString.write(value.token_id, buf)
            _UniffiConverterString.write(value.pay_request, buf)







class ReceivePaymentMethod:
    def __init__(self):
        raise RuntimeError("ReceivePaymentMethod cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SPARK_ADDRESS:

        def __init__(self,):
            pass

        def __str__(self):
            return "ReceivePaymentMethod.SPARK_ADDRESS()".format()

        def __eq__(self, other):
            if not other.is_spark_address():
                return False
            return True
    
    class SPARK_INVOICE:
        amount: "typing.Optional[U128]"
        """
        Amount to receive. Denominated in sats if token identifier is empty, otherwise in the token base units
        """

        token_identifier: "typing.Optional[str]"
        """
        The presence of this field indicates that the payment is for a token
        If empty, it is a Bitcoin payment
        """

        expiry_time: "typing.Optional[int]"
        """
        The expiry time of the invoice in seconds since the Unix epoch
        """

        description: "typing.Optional[str]"
        """
        A description to embed in the invoice.
        """

        sender_public_key: "typing.Optional[str]"
        """
        If set, the invoice may only be fulfilled by a payer with this public key
        """


        def __init__(self,amount: "typing.Optional[U128]", token_identifier: "typing.Optional[str]", expiry_time: "typing.Optional[int]", description: "typing.Optional[str]", sender_public_key: "typing.Optional[str]"):
            self.amount = amount
            self.token_identifier = token_identifier
            self.expiry_time = expiry_time
            self.description = description
            self.sender_public_key = sender_public_key

        def __str__(self):
            return "ReceivePaymentMethod.SPARK_INVOICE(amount={}, token_identifier={}, expiry_time={}, description={}, sender_public_key={})".format(self.amount, self.token_identifier, self.expiry_time, self.description, self.sender_public_key)

        def __eq__(self, other):
            if not other.is_spark_invoice():
                return False
            if self.amount != other.amount:
                return False
            if self.token_identifier != other.token_identifier:
                return False
            if self.expiry_time != other.expiry_time:
                return False
            if self.description != other.description:
                return False
            if self.sender_public_key != other.sender_public_key:
                return False
            return True
    
    class BITCOIN_ADDRESS:

        def __init__(self,):
            pass

        def __str__(self):
            return "ReceivePaymentMethod.BITCOIN_ADDRESS()".format()

        def __eq__(self, other):
            if not other.is_bitcoin_address():
                return False
            return True
    
    class BOLT11_INVOICE:
        description: "str"
        amount_sats: "typing.Optional[int]"
        expiry_secs: "typing.Optional[int]"
        """
        The expiry time of the invoice in seconds
        """


        def __init__(self,description: "str", amount_sats: "typing.Optional[int]", expiry_secs: "typing.Optional[int]"):
            self.description = description
            self.amount_sats = amount_sats
            self.expiry_secs = expiry_secs

        def __str__(self):
            return "ReceivePaymentMethod.BOLT11_INVOICE(description={}, amount_sats={}, expiry_secs={})".format(self.description, self.amount_sats, self.expiry_secs)

        def __eq__(self, other):
            if not other.is_bolt11_invoice():
                return False
            if self.description != other.description:
                return False
            if self.amount_sats != other.amount_sats:
                return False
            if self.expiry_secs != other.expiry_secs:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_spark_address(self) -> bool:
        return isinstance(self, ReceivePaymentMethod.SPARK_ADDRESS)
    def is_spark_invoice(self) -> bool:
        return isinstance(self, ReceivePaymentMethod.SPARK_INVOICE)
    def is_bitcoin_address(self) -> bool:
        return isinstance(self, ReceivePaymentMethod.BITCOIN_ADDRESS)
    def is_bolt11_invoice(self) -> bool:
        return isinstance(self, ReceivePaymentMethod.BOLT11_INVOICE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ReceivePaymentMethod.SPARK_ADDRESS = type("ReceivePaymentMethod.SPARK_ADDRESS", (ReceivePaymentMethod.SPARK_ADDRESS, ReceivePaymentMethod,), {})  # type: ignore
ReceivePaymentMethod.SPARK_INVOICE = type("ReceivePaymentMethod.SPARK_INVOICE", (ReceivePaymentMethod.SPARK_INVOICE, ReceivePaymentMethod,), {})  # type: ignore
ReceivePaymentMethod.BITCOIN_ADDRESS = type("ReceivePaymentMethod.BITCOIN_ADDRESS", (ReceivePaymentMethod.BITCOIN_ADDRESS, ReceivePaymentMethod,), {})  # type: ignore
ReceivePaymentMethod.BOLT11_INVOICE = type("ReceivePaymentMethod.BOLT11_INVOICE", (ReceivePaymentMethod.BOLT11_INVOICE, ReceivePaymentMethod,), {})  # type: ignore




class _UniffiConverterTypeReceivePaymentMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ReceivePaymentMethod.SPARK_ADDRESS(
            )
        if variant == 2:
            return ReceivePaymentMethod.SPARK_INVOICE(
                _UniffiConverterOptionalTypeU128.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 3:
            return ReceivePaymentMethod.BITCOIN_ADDRESS(
            )
        if variant == 4:
            return ReceivePaymentMethod.BOLT11_INVOICE(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
                _UniffiConverterOptionalUInt32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_spark_address():
            return
        if value.is_spark_invoice():
            _UniffiConverterOptionalTypeU128.check_lower(value.amount)
            _UniffiConverterOptionalString.check_lower(value.token_identifier)
            _UniffiConverterOptionalUInt64.check_lower(value.expiry_time)
            _UniffiConverterOptionalString.check_lower(value.description)
            _UniffiConverterOptionalString.check_lower(value.sender_public_key)
            return
        if value.is_bitcoin_address():
            return
        if value.is_bolt11_invoice():
            _UniffiConverterString.check_lower(value.description)
            _UniffiConverterOptionalUInt64.check_lower(value.amount_sats)
            _UniffiConverterOptionalUInt32.check_lower(value.expiry_secs)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_spark_address():
            buf.write_i32(1)
        if value.is_spark_invoice():
            buf.write_i32(2)
            _UniffiConverterOptionalTypeU128.write(value.amount, buf)
            _UniffiConverterOptionalString.write(value.token_identifier, buf)
            _UniffiConverterOptionalUInt64.write(value.expiry_time, buf)
            _UniffiConverterOptionalString.write(value.description, buf)
            _UniffiConverterOptionalString.write(value.sender_public_key, buf)
        if value.is_bitcoin_address():
            buf.write_i32(3)
        if value.is_bolt11_invoice():
            buf.write_i32(4)
            _UniffiConverterString.write(value.description, buf)
            _UniffiConverterOptionalUInt64.write(value.amount_sats, buf)
            _UniffiConverterOptionalUInt32.write(value.expiry_secs, buf)




# SdkError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SdkError(Exception):
    """
    Error type for the `BreezSdk`
    """

    pass

_UniffiTempSdkError = SdkError

class SdkError:  # type: ignore
    """
    Error type for the `BreezSdk`
    """

    class SparkError(_UniffiTempSdkError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.SparkError({})".format(str(self))
    _UniffiTempSdkError.SparkError = SparkError # type: ignore
    class InsufficientFunds(_UniffiTempSdkError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SdkError.InsufficientFunds({})".format(str(self))
    _UniffiTempSdkError.InsufficientFunds = InsufficientFunds # type: ignore
    class InvalidUuid(_UniffiTempSdkError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.InvalidUuid({})".format(str(self))
    _UniffiTempSdkError.InvalidUuid = InvalidUuid # type: ignore
    class InvalidInput(_UniffiTempSdkError):
        """
        Invalid input error
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.InvalidInput({})".format(str(self))
    _UniffiTempSdkError.InvalidInput = InvalidInput # type: ignore
    class NetworkError(_UniffiTempSdkError):
        """
        Network error
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.NetworkError({})".format(str(self))
    _UniffiTempSdkError.NetworkError = NetworkError # type: ignore
    class StorageError(_UniffiTempSdkError):
        """
        Storage error
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.StorageError({})".format(str(self))
    _UniffiTempSdkError.StorageError = StorageError # type: ignore
    class ChainServiceError(_UniffiTempSdkError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.ChainServiceError({})".format(str(self))
    _UniffiTempSdkError.ChainServiceError = ChainServiceError # type: ignore
    class MaxDepositClaimFeeExceeded(_UniffiTempSdkError):
        def __init__(self, tx, vout, max_fee, required_fee_sats, required_fee_rate_sat_per_vbyte):
            super().__init__(", ".join([
                "tx={!r}".format(tx),
                "vout={!r}".format(vout),
                "max_fee={!r}".format(max_fee),
                "required_fee_sats={!r}".format(required_fee_sats),
                "required_fee_rate_sat_per_vbyte={!r}".format(required_fee_rate_sat_per_vbyte),
            ]))
            self.tx = tx
            self.vout = vout
            self.max_fee = max_fee
            self.required_fee_sats = required_fee_sats
            self.required_fee_rate_sat_per_vbyte = required_fee_rate_sat_per_vbyte

        def __repr__(self):
            return "SdkError.MaxDepositClaimFeeExceeded({})".format(str(self))
    _UniffiTempSdkError.MaxDepositClaimFeeExceeded = MaxDepositClaimFeeExceeded # type: ignore
    class MissingUtxo(_UniffiTempSdkError):
        def __init__(self, tx, vout):
            super().__init__(", ".join([
                "tx={!r}".format(tx),
                "vout={!r}".format(vout),
            ]))
            self.tx = tx
            self.vout = vout

        def __repr__(self):
            return "SdkError.MissingUtxo({})".format(str(self))
    _UniffiTempSdkError.MissingUtxo = MissingUtxo # type: ignore
    class LnurlError(_UniffiTempSdkError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.LnurlError({})".format(str(self))
    _UniffiTempSdkError.LnurlError = LnurlError # type: ignore
    class Signer(_UniffiTempSdkError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.Signer({})".format(str(self))
    _UniffiTempSdkError.Signer = Signer # type: ignore
    class Generic(_UniffiTempSdkError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SdkError.Generic({})".format(str(self))
    _UniffiTempSdkError.Generic = Generic # type: ignore

SdkError = _UniffiTempSdkError # type: ignore
del _UniffiTempSdkError


class _UniffiConverterTypeSdkError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SdkError.SparkError(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return SdkError.InsufficientFunds(
            )
        if variant == 3:
            return SdkError.InvalidUuid(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return SdkError.InvalidInput(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return SdkError.NetworkError(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return SdkError.StorageError(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return SdkError.ChainServiceError(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return SdkError.MaxDepositClaimFeeExceeded(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterOptionalTypeFee.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 9:
            return SdkError.MissingUtxo(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 10:
            return SdkError.LnurlError(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return SdkError.Signer(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return SdkError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SdkError.SparkError):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SdkError.InsufficientFunds):
            return
        if isinstance(value, SdkError.InvalidUuid):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SdkError.InvalidInput):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SdkError.NetworkError):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SdkError.StorageError):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SdkError.ChainServiceError):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SdkError.MaxDepositClaimFeeExceeded):
            _UniffiConverterString.check_lower(value.tx)
            _UniffiConverterUInt32.check_lower(value.vout)
            _UniffiConverterOptionalTypeFee.check_lower(value.max_fee)
            _UniffiConverterUInt64.check_lower(value.required_fee_sats)
            _UniffiConverterUInt64.check_lower(value.required_fee_rate_sat_per_vbyte)
            return
        if isinstance(value, SdkError.MissingUtxo):
            _UniffiConverterString.check_lower(value.tx)
            _UniffiConverterUInt32.check_lower(value.vout)
            return
        if isinstance(value, SdkError.LnurlError):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SdkError.Signer):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SdkError.Generic):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SdkError.SparkError):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SdkError.InsufficientFunds):
            buf.write_i32(2)
        if isinstance(value, SdkError.InvalidUuid):
            buf.write_i32(3)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SdkError.InvalidInput):
            buf.write_i32(4)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SdkError.NetworkError):
            buf.write_i32(5)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SdkError.StorageError):
            buf.write_i32(6)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SdkError.ChainServiceError):
            buf.write_i32(7)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SdkError.MaxDepositClaimFeeExceeded):
            buf.write_i32(8)
            _UniffiConverterString.write(value.tx, buf)
            _UniffiConverterUInt32.write(value.vout, buf)
            _UniffiConverterOptionalTypeFee.write(value.max_fee, buf)
            _UniffiConverterUInt64.write(value.required_fee_sats, buf)
            _UniffiConverterUInt64.write(value.required_fee_rate_sat_per_vbyte, buf)
        if isinstance(value, SdkError.MissingUtxo):
            buf.write_i32(9)
            _UniffiConverterString.write(value.tx, buf)
            _UniffiConverterUInt32.write(value.vout, buf)
        if isinstance(value, SdkError.LnurlError):
            buf.write_i32(10)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SdkError.Signer):
            buf.write_i32(11)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SdkError.Generic):
            buf.write_i32(12)
            _UniffiConverterString.write(value._values[0], buf)





class SdkEvent:
    """
    Events emitted by the SDK
    """

    def __init__(self):
        raise RuntimeError("SdkEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SYNCED:
        """
        Emitted when the wallet has been synchronized with the network
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "SdkEvent.SYNCED()".format()

        def __eq__(self, other):
            if not other.is_synced():
                return False
            return True
    
    class UNCLAIMED_DEPOSITS:
        """
        Emitted when the SDK was unable to claim deposits
        """

        unclaimed_deposits: "typing.List[DepositInfo]"

        def __init__(self,unclaimed_deposits: "typing.List[DepositInfo]"):
            self.unclaimed_deposits = unclaimed_deposits

        def __str__(self):
            return "SdkEvent.UNCLAIMED_DEPOSITS(unclaimed_deposits={})".format(self.unclaimed_deposits)

        def __eq__(self, other):
            if not other.is_unclaimed_deposits():
                return False
            if self.unclaimed_deposits != other.unclaimed_deposits:
                return False
            return True
    
    class CLAIMED_DEPOSITS:
        claimed_deposits: "typing.List[DepositInfo]"

        def __init__(self,claimed_deposits: "typing.List[DepositInfo]"):
            self.claimed_deposits = claimed_deposits

        def __str__(self):
            return "SdkEvent.CLAIMED_DEPOSITS(claimed_deposits={})".format(self.claimed_deposits)

        def __eq__(self, other):
            if not other.is_claimed_deposits():
                return False
            if self.claimed_deposits != other.claimed_deposits:
                return False
            return True
    
    class PAYMENT_SUCCEEDED:
        payment: "Payment"

        def __init__(self,payment: "Payment"):
            self.payment = payment

        def __str__(self):
            return "SdkEvent.PAYMENT_SUCCEEDED(payment={})".format(self.payment)

        def __eq__(self, other):
            if not other.is_payment_succeeded():
                return False
            if self.payment != other.payment:
                return False
            return True
    
    class PAYMENT_PENDING:
        payment: "Payment"

        def __init__(self,payment: "Payment"):
            self.payment = payment

        def __str__(self):
            return "SdkEvent.PAYMENT_PENDING(payment={})".format(self.payment)

        def __eq__(self, other):
            if not other.is_payment_pending():
                return False
            if self.payment != other.payment:
                return False
            return True
    
    class PAYMENT_FAILED:
        payment: "Payment"

        def __init__(self,payment: "Payment"):
            self.payment = payment

        def __str__(self):
            return "SdkEvent.PAYMENT_FAILED(payment={})".format(self.payment)

        def __eq__(self, other):
            if not other.is_payment_failed():
                return False
            if self.payment != other.payment:
                return False
            return True
    
    class OPTIMIZATION:
        optimization_event: "OptimizationEvent"

        def __init__(self,optimization_event: "OptimizationEvent"):
            self.optimization_event = optimization_event

        def __str__(self):
            return "SdkEvent.OPTIMIZATION(optimization_event={})".format(self.optimization_event)

        def __eq__(self, other):
            if not other.is_optimization():
                return False
            if self.optimization_event != other.optimization_event:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_synced(self) -> bool:
        return isinstance(self, SdkEvent.SYNCED)
    def is_unclaimed_deposits(self) -> bool:
        return isinstance(self, SdkEvent.UNCLAIMED_DEPOSITS)
    def is_claimed_deposits(self) -> bool:
        return isinstance(self, SdkEvent.CLAIMED_DEPOSITS)
    def is_payment_succeeded(self) -> bool:
        return isinstance(self, SdkEvent.PAYMENT_SUCCEEDED)
    def is_payment_pending(self) -> bool:
        return isinstance(self, SdkEvent.PAYMENT_PENDING)
    def is_payment_failed(self) -> bool:
        return isinstance(self, SdkEvent.PAYMENT_FAILED)
    def is_optimization(self) -> bool:
        return isinstance(self, SdkEvent.OPTIMIZATION)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SdkEvent.SYNCED = type("SdkEvent.SYNCED", (SdkEvent.SYNCED, SdkEvent,), {})  # type: ignore
SdkEvent.UNCLAIMED_DEPOSITS = type("SdkEvent.UNCLAIMED_DEPOSITS", (SdkEvent.UNCLAIMED_DEPOSITS, SdkEvent,), {})  # type: ignore
SdkEvent.CLAIMED_DEPOSITS = type("SdkEvent.CLAIMED_DEPOSITS", (SdkEvent.CLAIMED_DEPOSITS, SdkEvent,), {})  # type: ignore
SdkEvent.PAYMENT_SUCCEEDED = type("SdkEvent.PAYMENT_SUCCEEDED", (SdkEvent.PAYMENT_SUCCEEDED, SdkEvent,), {})  # type: ignore
SdkEvent.PAYMENT_PENDING = type("SdkEvent.PAYMENT_PENDING", (SdkEvent.PAYMENT_PENDING, SdkEvent,), {})  # type: ignore
SdkEvent.PAYMENT_FAILED = type("SdkEvent.PAYMENT_FAILED", (SdkEvent.PAYMENT_FAILED, SdkEvent,), {})  # type: ignore
SdkEvent.OPTIMIZATION = type("SdkEvent.OPTIMIZATION", (SdkEvent.OPTIMIZATION, SdkEvent,), {})  # type: ignore




class _UniffiConverterTypeSdkEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SdkEvent.SYNCED(
            )
        if variant == 2:
            return SdkEvent.UNCLAIMED_DEPOSITS(
                _UniffiConverterSequenceTypeDepositInfo.read(buf),
            )
        if variant == 3:
            return SdkEvent.CLAIMED_DEPOSITS(
                _UniffiConverterSequenceTypeDepositInfo.read(buf),
            )
        if variant == 4:
            return SdkEvent.PAYMENT_SUCCEEDED(
                _UniffiConverterTypePayment.read(buf),
            )
        if variant == 5:
            return SdkEvent.PAYMENT_PENDING(
                _UniffiConverterTypePayment.read(buf),
            )
        if variant == 6:
            return SdkEvent.PAYMENT_FAILED(
                _UniffiConverterTypePayment.read(buf),
            )
        if variant == 7:
            return SdkEvent.OPTIMIZATION(
                _UniffiConverterTypeOptimizationEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_synced():
            return
        if value.is_unclaimed_deposits():
            _UniffiConverterSequenceTypeDepositInfo.check_lower(value.unclaimed_deposits)
            return
        if value.is_claimed_deposits():
            _UniffiConverterSequenceTypeDepositInfo.check_lower(value.claimed_deposits)
            return
        if value.is_payment_succeeded():
            _UniffiConverterTypePayment.check_lower(value.payment)
            return
        if value.is_payment_pending():
            _UniffiConverterTypePayment.check_lower(value.payment)
            return
        if value.is_payment_failed():
            _UniffiConverterTypePayment.check_lower(value.payment)
            return
        if value.is_optimization():
            _UniffiConverterTypeOptimizationEvent.check_lower(value.optimization_event)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_synced():
            buf.write_i32(1)
        if value.is_unclaimed_deposits():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeDepositInfo.write(value.unclaimed_deposits, buf)
        if value.is_claimed_deposits():
            buf.write_i32(3)
            _UniffiConverterSequenceTypeDepositInfo.write(value.claimed_deposits, buf)
        if value.is_payment_succeeded():
            buf.write_i32(4)
            _UniffiConverterTypePayment.write(value.payment, buf)
        if value.is_payment_pending():
            buf.write_i32(5)
            _UniffiConverterTypePayment.write(value.payment, buf)
        if value.is_payment_failed():
            buf.write_i32(6)
            _UniffiConverterTypePayment.write(value.payment, buf)
        if value.is_optimization():
            buf.write_i32(7)
            _UniffiConverterTypeOptimizationEvent.write(value.optimization_event, buf)







class Seed:
    """
    Represents the seed for wallet generation, either as a mnemonic phrase with an optional
    passphrase or as raw entropy bytes.
    """

    def __init__(self):
        raise RuntimeError("Seed cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class MNEMONIC:
        """
        A BIP-39 mnemonic phrase with an optional passphrase.
        """

        mnemonic: "str"
        """
        The mnemonic phrase. 12 or 24 words.
        """

        passphrase: "typing.Optional[str]"
        """
        An optional passphrase for the mnemonic.
        """


        def __init__(self,mnemonic: "str", passphrase: "typing.Optional[str]"):
            self.mnemonic = mnemonic
            self.passphrase = passphrase

        def __str__(self):
            return "Seed.MNEMONIC(mnemonic={}, passphrase={})".format(self.mnemonic, self.passphrase)

        def __eq__(self, other):
            if not other.is_mnemonic():
                return False
            if self.mnemonic != other.mnemonic:
                return False
            if self.passphrase != other.passphrase:
                return False
            return True
    
    class ENTROPY:
        """
        Raw entropy bytes.
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], bytes):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'bytes', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"Seed.ENTROPY{self._values!r}"

        def __eq__(self, other):
            if not other.is_entropy():
                return False
            return self._values == other._values
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_mnemonic(self) -> bool:
        return isinstance(self, Seed.MNEMONIC)
    def is_entropy(self) -> bool:
        return isinstance(self, Seed.ENTROPY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Seed.MNEMONIC = type("Seed.MNEMONIC", (Seed.MNEMONIC, Seed,), {})  # type: ignore
Seed.ENTROPY = type("Seed.ENTROPY", (Seed.ENTROPY, Seed,), {})  # type: ignore




class _UniffiConverterTypeSeed(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Seed.MNEMONIC(
                _UniffiConverterString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 2:
            return Seed.ENTROPY(
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_mnemonic():
            _UniffiConverterString.check_lower(value.mnemonic)
            _UniffiConverterOptionalString.check_lower(value.passphrase)
            return
        if value.is_entropy():
            _UniffiConverterBytes.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_mnemonic():
            buf.write_i32(1)
            _UniffiConverterString.write(value.mnemonic, buf)
            _UniffiConverterOptionalString.write(value.passphrase, buf)
        if value.is_entropy():
            buf.write_i32(2)
            _UniffiConverterBytes.write(value._values[0], buf)







class SendPaymentMethod:
    def __init__(self):
        raise RuntimeError("SendPaymentMethod cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN_ADDRESS:
        address: "BitcoinAddressDetails"
        fee_quote: "SendOnchainFeeQuote"

        def __init__(self,address: "BitcoinAddressDetails", fee_quote: "SendOnchainFeeQuote"):
            self.address = address
            self.fee_quote = fee_quote

        def __str__(self):
            return "SendPaymentMethod.BITCOIN_ADDRESS(address={}, fee_quote={})".format(self.address, self.fee_quote)

        def __eq__(self, other):
            if not other.is_bitcoin_address():
                return False
            if self.address != other.address:
                return False
            if self.fee_quote != other.fee_quote:
                return False
            return True
    
    class BOLT11_INVOICE:
        invoice_details: "Bolt11InvoiceDetails"
        spark_transfer_fee_sats: "typing.Optional[int]"
        lightning_fee_sats: "int"

        def __init__(self,invoice_details: "Bolt11InvoiceDetails", spark_transfer_fee_sats: "typing.Optional[int]", lightning_fee_sats: "int"):
            self.invoice_details = invoice_details
            self.spark_transfer_fee_sats = spark_transfer_fee_sats
            self.lightning_fee_sats = lightning_fee_sats

        def __str__(self):
            return "SendPaymentMethod.BOLT11_INVOICE(invoice_details={}, spark_transfer_fee_sats={}, lightning_fee_sats={})".format(self.invoice_details, self.spark_transfer_fee_sats, self.lightning_fee_sats)

        def __eq__(self, other):
            if not other.is_bolt11_invoice():
                return False
            if self.invoice_details != other.invoice_details:
                return False
            if self.spark_transfer_fee_sats != other.spark_transfer_fee_sats:
                return False
            if self.lightning_fee_sats != other.lightning_fee_sats:
                return False
            return True
    
    class SPARK_ADDRESS:
        address: "str"
        fee: "U128"
        """
        Fee to pay for the transaction
        Denominated in sats if token identifier is empty, otherwise in the token base units
        """

        token_identifier: "typing.Optional[str]"
        """
        The presence of this field indicates that the payment is for a token
        If empty, it is a Bitcoin payment
        """


        def __init__(self,address: "str", fee: "U128", token_identifier: "typing.Optional[str]"):
            self.address = address
            self.fee = fee
            self.token_identifier = token_identifier

        def __str__(self):
            return "SendPaymentMethod.SPARK_ADDRESS(address={}, fee={}, token_identifier={})".format(self.address, self.fee, self.token_identifier)

        def __eq__(self, other):
            if not other.is_spark_address():
                return False
            if self.address != other.address:
                return False
            if self.fee != other.fee:
                return False
            if self.token_identifier != other.token_identifier:
                return False
            return True
    
    class SPARK_INVOICE:
        spark_invoice_details: "SparkInvoiceDetails"
        fee: "U128"
        """
        Fee to pay for the transaction
        Denominated in sats if token identifier is empty, otherwise in the token base units
        """

        token_identifier: "typing.Optional[str]"
        """
        The presence of this field indicates that the payment is for a token
        If empty, it is a Bitcoin payment
        """


        def __init__(self,spark_invoice_details: "SparkInvoiceDetails", fee: "U128", token_identifier: "typing.Optional[str]"):
            self.spark_invoice_details = spark_invoice_details
            self.fee = fee
            self.token_identifier = token_identifier

        def __str__(self):
            return "SendPaymentMethod.SPARK_INVOICE(spark_invoice_details={}, fee={}, token_identifier={})".format(self.spark_invoice_details, self.fee, self.token_identifier)

        def __eq__(self, other):
            if not other.is_spark_invoice():
                return False
            if self.spark_invoice_details != other.spark_invoice_details:
                return False
            if self.fee != other.fee:
                return False
            if self.token_identifier != other.token_identifier:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin_address(self) -> bool:
        return isinstance(self, SendPaymentMethod.BITCOIN_ADDRESS)
    def is_bolt11_invoice(self) -> bool:
        return isinstance(self, SendPaymentMethod.BOLT11_INVOICE)
    def is_spark_address(self) -> bool:
        return isinstance(self, SendPaymentMethod.SPARK_ADDRESS)
    def is_spark_invoice(self) -> bool:
        return isinstance(self, SendPaymentMethod.SPARK_INVOICE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SendPaymentMethod.BITCOIN_ADDRESS = type("SendPaymentMethod.BITCOIN_ADDRESS", (SendPaymentMethod.BITCOIN_ADDRESS, SendPaymentMethod,), {})  # type: ignore
SendPaymentMethod.BOLT11_INVOICE = type("SendPaymentMethod.BOLT11_INVOICE", (SendPaymentMethod.BOLT11_INVOICE, SendPaymentMethod,), {})  # type: ignore
SendPaymentMethod.SPARK_ADDRESS = type("SendPaymentMethod.SPARK_ADDRESS", (SendPaymentMethod.SPARK_ADDRESS, SendPaymentMethod,), {})  # type: ignore
SendPaymentMethod.SPARK_INVOICE = type("SendPaymentMethod.SPARK_INVOICE", (SendPaymentMethod.SPARK_INVOICE, SendPaymentMethod,), {})  # type: ignore




class _UniffiConverterTypeSendPaymentMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SendPaymentMethod.BITCOIN_ADDRESS(
                _UniffiConverterTypeBitcoinAddressDetails.read(buf),
                _UniffiConverterTypeSendOnchainFeeQuote.read(buf),
            )
        if variant == 2:
            return SendPaymentMethod.BOLT11_INVOICE(
                _UniffiConverterTypeBolt11InvoiceDetails.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return SendPaymentMethod.SPARK_ADDRESS(
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeU128.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 4:
            return SendPaymentMethod.SPARK_INVOICE(
                _UniffiConverterTypeSparkInvoiceDetails.read(buf),
                _UniffiConverterTypeU128.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bitcoin_address():
            _UniffiConverterTypeBitcoinAddressDetails.check_lower(value.address)
            _UniffiConverterTypeSendOnchainFeeQuote.check_lower(value.fee_quote)
            return
        if value.is_bolt11_invoice():
            _UniffiConverterTypeBolt11InvoiceDetails.check_lower(value.invoice_details)
            _UniffiConverterOptionalUInt64.check_lower(value.spark_transfer_fee_sats)
            _UniffiConverterUInt64.check_lower(value.lightning_fee_sats)
            return
        if value.is_spark_address():
            _UniffiConverterString.check_lower(value.address)
            _UniffiConverterTypeU128.check_lower(value.fee)
            _UniffiConverterOptionalString.check_lower(value.token_identifier)
            return
        if value.is_spark_invoice():
            _UniffiConverterTypeSparkInvoiceDetails.check_lower(value.spark_invoice_details)
            _UniffiConverterTypeU128.check_lower(value.fee)
            _UniffiConverterOptionalString.check_lower(value.token_identifier)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_bitcoin_address():
            buf.write_i32(1)
            _UniffiConverterTypeBitcoinAddressDetails.write(value.address, buf)
            _UniffiConverterTypeSendOnchainFeeQuote.write(value.fee_quote, buf)
        if value.is_bolt11_invoice():
            buf.write_i32(2)
            _UniffiConverterTypeBolt11InvoiceDetails.write(value.invoice_details, buf)
            _UniffiConverterOptionalUInt64.write(value.spark_transfer_fee_sats, buf)
            _UniffiConverterUInt64.write(value.lightning_fee_sats, buf)
        if value.is_spark_address():
            buf.write_i32(3)
            _UniffiConverterString.write(value.address, buf)
            _UniffiConverterTypeU128.write(value.fee, buf)
            _UniffiConverterOptionalString.write(value.token_identifier, buf)
        if value.is_spark_invoice():
            buf.write_i32(4)
            _UniffiConverterTypeSparkInvoiceDetails.write(value.spark_invoice_details, buf)
            _UniffiConverterTypeU128.write(value.fee, buf)
            _UniffiConverterOptionalString.write(value.token_identifier, buf)







class SendPaymentOptions:
    def __init__(self):
        raise RuntimeError("SendPaymentOptions cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN_ADDRESS:
        confirmation_speed: "OnchainConfirmationSpeed"

        def __init__(self,confirmation_speed: "OnchainConfirmationSpeed"):
            self.confirmation_speed = confirmation_speed

        def __str__(self):
            return "SendPaymentOptions.BITCOIN_ADDRESS(confirmation_speed={})".format(self.confirmation_speed)

        def __eq__(self, other):
            if not other.is_bitcoin_address():
                return False
            if self.confirmation_speed != other.confirmation_speed:
                return False
            return True
    
    class BOLT11_INVOICE:
        prefer_spark: "bool"
        completion_timeout_secs: "typing.Optional[int]"
        """
        If set, the function will return the payment if it is still pending after this
        number of seconds. If unset, the function will return immediately after initiating the payment.
        """


        def __init__(self,prefer_spark: "bool", completion_timeout_secs: "typing.Optional[int]"):
            self.prefer_spark = prefer_spark
            self.completion_timeout_secs = completion_timeout_secs

        def __str__(self):
            return "SendPaymentOptions.BOLT11_INVOICE(prefer_spark={}, completion_timeout_secs={})".format(self.prefer_spark, self.completion_timeout_secs)

        def __eq__(self, other):
            if not other.is_bolt11_invoice():
                return False
            if self.prefer_spark != other.prefer_spark:
                return False
            if self.completion_timeout_secs != other.completion_timeout_secs:
                return False
            return True
    
    class SPARK_ADDRESS:
        htlc_options: "typing.Optional[SparkHtlcOptions]"
        """
        Can only be provided for Bitcoin payments. If set, a Spark HTLC transfer will be created.
        The receiver will need to provide the preimage to claim it.
        """


        def __init__(self,htlc_options: "typing.Optional[SparkHtlcOptions]"):
            self.htlc_options = htlc_options

        def __str__(self):
            return "SendPaymentOptions.SPARK_ADDRESS(htlc_options={})".format(self.htlc_options)

        def __eq__(self, other):
            if not other.is_spark_address():
                return False
            if self.htlc_options != other.htlc_options:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin_address(self) -> bool:
        return isinstance(self, SendPaymentOptions.BITCOIN_ADDRESS)
    def is_bolt11_invoice(self) -> bool:
        return isinstance(self, SendPaymentOptions.BOLT11_INVOICE)
    def is_spark_address(self) -> bool:
        return isinstance(self, SendPaymentOptions.SPARK_ADDRESS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SendPaymentOptions.BITCOIN_ADDRESS = type("SendPaymentOptions.BITCOIN_ADDRESS", (SendPaymentOptions.BITCOIN_ADDRESS, SendPaymentOptions,), {})  # type: ignore
SendPaymentOptions.BOLT11_INVOICE = type("SendPaymentOptions.BOLT11_INVOICE", (SendPaymentOptions.BOLT11_INVOICE, SendPaymentOptions,), {})  # type: ignore
SendPaymentOptions.SPARK_ADDRESS = type("SendPaymentOptions.SPARK_ADDRESS", (SendPaymentOptions.SPARK_ADDRESS, SendPaymentOptions,), {})  # type: ignore




class _UniffiConverterTypeSendPaymentOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SendPaymentOptions.BITCOIN_ADDRESS(
                _UniffiConverterTypeOnchainConfirmationSpeed.read(buf),
            )
        if variant == 2:
            return SendPaymentOptions.BOLT11_INVOICE(
                _UniffiConverterBool.read(buf),
                _UniffiConverterOptionalUInt32.read(buf),
            )
        if variant == 3:
            return SendPaymentOptions.SPARK_ADDRESS(
                _UniffiConverterOptionalTypeSparkHtlcOptions.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bitcoin_address():
            _UniffiConverterTypeOnchainConfirmationSpeed.check_lower(value.confirmation_speed)
            return
        if value.is_bolt11_invoice():
            _UniffiConverterBool.check_lower(value.prefer_spark)
            _UniffiConverterOptionalUInt32.check_lower(value.completion_timeout_secs)
            return
        if value.is_spark_address():
            _UniffiConverterOptionalTypeSparkHtlcOptions.check_lower(value.htlc_options)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_bitcoin_address():
            buf.write_i32(1)
            _UniffiConverterTypeOnchainConfirmationSpeed.write(value.confirmation_speed, buf)
        if value.is_bolt11_invoice():
            buf.write_i32(2)
            _UniffiConverterBool.write(value.prefer_spark, buf)
            _UniffiConverterOptionalUInt32.write(value.completion_timeout_secs, buf)
        if value.is_spark_address():
            buf.write_i32(3)
            _UniffiConverterOptionalTypeSparkHtlcOptions.write(value.htlc_options, buf)




# ServiceConnectivityError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ServiceConnectivityError(Exception):
    pass

_UniffiTempServiceConnectivityError = ServiceConnectivityError

class ServiceConnectivityError:  # type: ignore
    class Builder(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Builder({})".format(str(self))
    _UniffiTempServiceConnectivityError.Builder = Builder # type: ignore
    class Redirect(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Redirect({})".format(str(self))
    _UniffiTempServiceConnectivityError.Redirect = Redirect # type: ignore
    class Status(_UniffiTempServiceConnectivityError):
        def __init__(self, status, body):
            super().__init__(", ".join([
                "status={!r}".format(status),
                "body={!r}".format(body),
            ]))
            self.status = status
            self.body = body

        def __repr__(self):
            return "ServiceConnectivityError.Status({})".format(str(self))
    _UniffiTempServiceConnectivityError.Status = Status # type: ignore
    class Timeout(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Timeout({})".format(str(self))
    _UniffiTempServiceConnectivityError.Timeout = Timeout # type: ignore
    class Request(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Request({})".format(str(self))
    _UniffiTempServiceConnectivityError.Request = Request # type: ignore
    class Connect(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Connect({})".format(str(self))
    _UniffiTempServiceConnectivityError.Connect = Connect # type: ignore
    class Body(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Body({})".format(str(self))
    _UniffiTempServiceConnectivityError.Body = Body # type: ignore
    class Decode(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Decode({})".format(str(self))
    _UniffiTempServiceConnectivityError.Decode = Decode # type: ignore
    class Json(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Json({})".format(str(self))
    _UniffiTempServiceConnectivityError.Json = Json # type: ignore
    class Other(_UniffiTempServiceConnectivityError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ServiceConnectivityError.Other({})".format(str(self))
    _UniffiTempServiceConnectivityError.Other = Other # type: ignore

ServiceConnectivityError = _UniffiTempServiceConnectivityError # type: ignore
del _UniffiTempServiceConnectivityError


class _UniffiConverterTypeServiceConnectivityError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ServiceConnectivityError.Builder(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ServiceConnectivityError.Redirect(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ServiceConnectivityError.Status(
                _UniffiConverterUInt16.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return ServiceConnectivityError.Timeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ServiceConnectivityError.Request(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return ServiceConnectivityError.Connect(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ServiceConnectivityError.Body(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return ServiceConnectivityError.Decode(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return ServiceConnectivityError.Json(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return ServiceConnectivityError.Other(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ServiceConnectivityError.Builder):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ServiceConnectivityError.Redirect):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ServiceConnectivityError.Status):
            _UniffiConverterUInt16.check_lower(value.status)
            _UniffiConverterString.check_lower(value.body)
            return
        if isinstance(value, ServiceConnectivityError.Timeout):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ServiceConnectivityError.Request):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ServiceConnectivityError.Connect):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ServiceConnectivityError.Body):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ServiceConnectivityError.Decode):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ServiceConnectivityError.Json):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, ServiceConnectivityError.Other):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ServiceConnectivityError.Builder):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ServiceConnectivityError.Redirect):
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ServiceConnectivityError.Status):
            buf.write_i32(3)
            _UniffiConverterUInt16.write(value.status, buf)
            _UniffiConverterString.write(value.body, buf)
        if isinstance(value, ServiceConnectivityError.Timeout):
            buf.write_i32(4)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ServiceConnectivityError.Request):
            buf.write_i32(5)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ServiceConnectivityError.Connect):
            buf.write_i32(6)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ServiceConnectivityError.Body):
            buf.write_i32(7)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ServiceConnectivityError.Decode):
            buf.write_i32(8)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ServiceConnectivityError.Json):
            buf.write_i32(9)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, ServiceConnectivityError.Other):
            buf.write_i32(10)
            _UniffiConverterString.write(value._values[0], buf)


# SignerError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SignerError(Exception):
    """
    Error type for signer operations
    """

    pass

_UniffiTempSignerError = SignerError

class SignerError:  # type: ignore
    """
    Error type for signer operations
    """

    class KeyDerivation(_UniffiTempSignerError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SignerError.KeyDerivation({})".format(str(self))
    _UniffiTempSignerError.KeyDerivation = KeyDerivation # type: ignore
    class Signing(_UniffiTempSignerError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SignerError.Signing({})".format(str(self))
    _UniffiTempSignerError.Signing = Signing # type: ignore
    class Encryption(_UniffiTempSignerError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SignerError.Encryption({})".format(str(self))
    _UniffiTempSignerError.Encryption = Encryption # type: ignore
    class Decryption(_UniffiTempSignerError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SignerError.Decryption({})".format(str(self))
    _UniffiTempSignerError.Decryption = Decryption # type: ignore
    class Frost(_UniffiTempSignerError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SignerError.Frost({})".format(str(self))
    _UniffiTempSignerError.Frost = Frost # type: ignore
    class InvalidInput(_UniffiTempSignerError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SignerError.InvalidInput({})".format(str(self))
    _UniffiTempSignerError.InvalidInput = InvalidInput # type: ignore
    class Generic(_UniffiTempSignerError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SignerError.Generic({})".format(str(self))
    _UniffiTempSignerError.Generic = Generic # type: ignore

SignerError = _UniffiTempSignerError # type: ignore
del _UniffiTempSignerError


class _UniffiConverterTypeSignerError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SignerError.KeyDerivation(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return SignerError.Signing(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return SignerError.Encryption(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return SignerError.Decryption(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return SignerError.Frost(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return SignerError.InvalidInput(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return SignerError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SignerError.KeyDerivation):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SignerError.Signing):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SignerError.Encryption):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SignerError.Decryption):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SignerError.Frost):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SignerError.InvalidInput):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SignerError.Generic):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SignerError.KeyDerivation):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SignerError.Signing):
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SignerError.Encryption):
            buf.write_i32(3)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SignerError.Decryption):
            buf.write_i32(4)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SignerError.Frost):
            buf.write_i32(5)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SignerError.InvalidInput):
            buf.write_i32(6)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SignerError.Generic):
            buf.write_i32(7)
            _UniffiConverterString.write(value._values[0], buf)





class SparkHtlcStatus(enum.Enum):
    WAITING_FOR_PREIMAGE = 0
    """
    The HTLC is waiting for the preimage to be shared by the receiver
    """

    
    PREIMAGE_SHARED = 1
    """
    The HTLC preimage has been shared and the transfer can be or has been claimed by the receiver
    """

    
    RETURNED = 2
    """
    The HTLC has been returned to the sender due to expiry
    """

    


class _UniffiConverterTypeSparkHtlcStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SparkHtlcStatus.WAITING_FOR_PREIMAGE
        if variant == 2:
            return SparkHtlcStatus.PREIMAGE_SHARED
        if variant == 3:
            return SparkHtlcStatus.RETURNED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SparkHtlcStatus.WAITING_FOR_PREIMAGE:
            return
        if value == SparkHtlcStatus.PREIMAGE_SHARED:
            return
        if value == SparkHtlcStatus.RETURNED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SparkHtlcStatus.WAITING_FOR_PREIMAGE:
            buf.write_i32(1)
        if value == SparkHtlcStatus.PREIMAGE_SHARED:
            buf.write_i32(2)
        if value == SparkHtlcStatus.RETURNED:
            buf.write_i32(3)




# StorageError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class StorageError(Exception):
    """
    Errors that can occur during storage operations
    """

    pass

_UniffiTempStorageError = StorageError

class StorageError:  # type: ignore
    """
    Errors that can occur during storage operations
    """

    class Implementation(_UniffiTempStorageError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "StorageError.Implementation({})".format(str(self))
    _UniffiTempStorageError.Implementation = Implementation # type: ignore
    class InitializationError(_UniffiTempStorageError):
        """
        Database initialization error
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "StorageError.InitializationError({})".format(str(self))
    _UniffiTempStorageError.InitializationError = InitializationError # type: ignore
    class Serialization(_UniffiTempStorageError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "StorageError.Serialization({})".format(str(self))
    _UniffiTempStorageError.Serialization = Serialization # type: ignore

StorageError = _UniffiTempStorageError # type: ignore
del _UniffiTempStorageError


class _UniffiConverterTypeStorageError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return StorageError.Implementation(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return StorageError.InitializationError(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return StorageError.Serialization(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, StorageError.Implementation):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, StorageError.InitializationError):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, StorageError.Serialization):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, StorageError.Implementation):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, StorageError.InitializationError):
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, StorageError.Serialization):
            buf.write_i32(3)
            _UniffiConverterString.write(value._values[0], buf)





class SuccessAction:
    """
    Supported success action types

    Receiving any other (unsupported) success action type will result in a failed parsing,
    which will abort the LNURL-pay workflow, as per LUD-09.
    """

    def __init__(self):
        raise RuntimeError("SuccessAction cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AES:
        """
        AES type, described in LUD-10
        """

        data: "AesSuccessActionData"

        def __init__(self,data: "AesSuccessActionData"):
            self.data = data

        def __str__(self):
            return "SuccessAction.AES(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_aes():
                return False
            if self.data != other.data:
                return False
            return True
    
    class MESSAGE:
        """
        Message type, described in LUD-09
        """

        data: "MessageSuccessActionData"

        def __init__(self,data: "MessageSuccessActionData"):
            self.data = data

        def __str__(self):
            return "SuccessAction.MESSAGE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_message():
                return False
            if self.data != other.data:
                return False
            return True
    
    class URL:
        """
        URL type, described in LUD-09
        """

        data: "UrlSuccessActionData"

        def __init__(self,data: "UrlSuccessActionData"):
            self.data = data

        def __str__(self):
            return "SuccessAction.URL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_aes(self) -> bool:
        return isinstance(self, SuccessAction.AES)
    def is_message(self) -> bool:
        return isinstance(self, SuccessAction.MESSAGE)
    def is_url(self) -> bool:
        return isinstance(self, SuccessAction.URL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SuccessAction.AES = type("SuccessAction.AES", (SuccessAction.AES, SuccessAction,), {})  # type: ignore
SuccessAction.MESSAGE = type("SuccessAction.MESSAGE", (SuccessAction.MESSAGE, SuccessAction,), {})  # type: ignore
SuccessAction.URL = type("SuccessAction.URL", (SuccessAction.URL, SuccessAction,), {})  # type: ignore




class _UniffiConverterTypeSuccessAction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SuccessAction.AES(
                _UniffiConverterTypeAesSuccessActionData.read(buf),
            )
        if variant == 2:
            return SuccessAction.MESSAGE(
                _UniffiConverterTypeMessageSuccessActionData.read(buf),
            )
        if variant == 3:
            return SuccessAction.URL(
                _UniffiConverterTypeUrlSuccessActionData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_aes():
            _UniffiConverterTypeAesSuccessActionData.check_lower(value.data)
            return
        if value.is_message():
            _UniffiConverterTypeMessageSuccessActionData.check_lower(value.data)
            return
        if value.is_url():
            _UniffiConverterTypeUrlSuccessActionData.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_aes():
            buf.write_i32(1)
            _UniffiConverterTypeAesSuccessActionData.write(value.data, buf)
        if value.is_message():
            buf.write_i32(2)
            _UniffiConverterTypeMessageSuccessActionData.write(value.data, buf)
        if value.is_url():
            buf.write_i32(3)
            _UniffiConverterTypeUrlSuccessActionData.write(value.data, buf)







class SuccessActionProcessed:
    """
    [`SuccessAction`] where contents are ready to be consumed by the caller

    Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
    """

    def __init__(self):
        raise RuntimeError("SuccessActionProcessed cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AES:
        """
        See [`SuccessAction::Aes`] for received payload

        See [`AesSuccessActionDataDecrypted`] for decrypted payload
        """

        result: "AesSuccessActionDataResult"

        def __init__(self,result: "AesSuccessActionDataResult"):
            self.result = result

        def __str__(self):
            return "SuccessActionProcessed.AES(result={})".format(self.result)

        def __eq__(self, other):
            if not other.is_aes():
                return False
            if self.result != other.result:
                return False
            return True
    
    class MESSAGE:
        """
        See [`SuccessAction::Message`]
        """

        data: "MessageSuccessActionData"

        def __init__(self,data: "MessageSuccessActionData"):
            self.data = data

        def __str__(self):
            return "SuccessActionProcessed.MESSAGE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_message():
                return False
            if self.data != other.data:
                return False
            return True
    
    class URL:
        """
        See [`SuccessAction::Url`]
        """

        data: "UrlSuccessActionData"

        def __init__(self,data: "UrlSuccessActionData"):
            self.data = data

        def __str__(self):
            return "SuccessActionProcessed.URL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_url():
                return False
            if self.data != other.data:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_aes(self) -> bool:
        return isinstance(self, SuccessActionProcessed.AES)
    def is_message(self) -> bool:
        return isinstance(self, SuccessActionProcessed.MESSAGE)
    def is_url(self) -> bool:
        return isinstance(self, SuccessActionProcessed.URL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SuccessActionProcessed.AES = type("SuccessActionProcessed.AES", (SuccessActionProcessed.AES, SuccessActionProcessed,), {})  # type: ignore
SuccessActionProcessed.MESSAGE = type("SuccessActionProcessed.MESSAGE", (SuccessActionProcessed.MESSAGE, SuccessActionProcessed,), {})  # type: ignore
SuccessActionProcessed.URL = type("SuccessActionProcessed.URL", (SuccessActionProcessed.URL, SuccessActionProcessed,), {})  # type: ignore




class _UniffiConverterTypeSuccessActionProcessed(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SuccessActionProcessed.AES(
                _UniffiConverterTypeAesSuccessActionDataResult.read(buf),
            )
        if variant == 2:
            return SuccessActionProcessed.MESSAGE(
                _UniffiConverterTypeMessageSuccessActionData.read(buf),
            )
        if variant == 3:
            return SuccessActionProcessed.URL(
                _UniffiConverterTypeUrlSuccessActionData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_aes():
            _UniffiConverterTypeAesSuccessActionDataResult.check_lower(value.result)
            return
        if value.is_message():
            _UniffiConverterTypeMessageSuccessActionData.check_lower(value.data)
            return
        if value.is_url():
            _UniffiConverterTypeUrlSuccessActionData.check_lower(value.data)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_aes():
            buf.write_i32(1)
            _UniffiConverterTypeAesSuccessActionDataResult.write(value.result, buf)
        if value.is_message():
            buf.write_i32(2)
            _UniffiConverterTypeMessageSuccessActionData.write(value.data, buf)
        if value.is_url():
            buf.write_i32(3)
            _UniffiConverterTypeUrlSuccessActionData.write(value.data, buf)




# SyncStorageError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SyncStorageError(Exception):
    """
    Errors that can occur during storage operations
    """

    pass

_UniffiTempSyncStorageError = SyncStorageError

class SyncStorageError:  # type: ignore
    """
    Errors that can occur during storage operations
    """

    class Implementation(_UniffiTempSyncStorageError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SyncStorageError.Implementation({})".format(str(self))
    _UniffiTempSyncStorageError.Implementation = Implementation # type: ignore
    class InitializationError(_UniffiTempSyncStorageError):
        """
        Database initialization error
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SyncStorageError.InitializationError({})".format(str(self))
    _UniffiTempSyncStorageError.InitializationError = InitializationError # type: ignore
    class Serialization(_UniffiTempSyncStorageError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SyncStorageError.Serialization({})".format(str(self))
    _UniffiTempSyncStorageError.Serialization = Serialization # type: ignore

SyncStorageError = _UniffiTempSyncStorageError # type: ignore
del _UniffiTempSyncStorageError


class _UniffiConverterTypeSyncStorageError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SyncStorageError.Implementation(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return SyncStorageError.InitializationError(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return SyncStorageError.Serialization(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SyncStorageError.Implementation):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SyncStorageError.InitializationError):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, SyncStorageError.Serialization):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SyncStorageError.Implementation):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SyncStorageError.InitializationError):
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, SyncStorageError.Serialization):
            buf.write_i32(3)
            _UniffiConverterString.write(value._values[0], buf)





class TokenConversionType:
    def __init__(self):
        raise RuntimeError("TokenConversionType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FROM_BITCOIN:
        """
        Converting from Bitcoin to a token
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TokenConversionType.FROM_BITCOIN()".format()

        def __eq__(self, other):
            if not other.is_from_bitcoin():
                return False
            return True
    
    class TO_BITCOIN:
        """
        Converting from a token to Bitcoin
        """

        from_token_identifier: "str"

        def __init__(self,from_token_identifier: "str"):
            self.from_token_identifier = from_token_identifier

        def __str__(self):
            return "TokenConversionType.TO_BITCOIN(from_token_identifier={})".format(self.from_token_identifier)

        def __eq__(self, other):
            if not other.is_to_bitcoin():
                return False
            if self.from_token_identifier != other.from_token_identifier:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_from_bitcoin(self) -> bool:
        return isinstance(self, TokenConversionType.FROM_BITCOIN)
    def is_to_bitcoin(self) -> bool:
        return isinstance(self, TokenConversionType.TO_BITCOIN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TokenConversionType.FROM_BITCOIN = type("TokenConversionType.FROM_BITCOIN", (TokenConversionType.FROM_BITCOIN, TokenConversionType,), {})  # type: ignore
TokenConversionType.TO_BITCOIN = type("TokenConversionType.TO_BITCOIN", (TokenConversionType.TO_BITCOIN, TokenConversionType,), {})  # type: ignore




class _UniffiConverterTypeTokenConversionType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TokenConversionType.FROM_BITCOIN(
            )
        if variant == 2:
            return TokenConversionType.TO_BITCOIN(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_from_bitcoin():
            return
        if value.is_to_bitcoin():
            _UniffiConverterString.check_lower(value.from_token_identifier)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_from_bitcoin():
            buf.write_i32(1)
        if value.is_to_bitcoin():
            buf.write_i32(2)
            _UniffiConverterString.write(value.from_token_identifier, buf)







class UpdateDepositPayload:
    def __init__(self):
        raise RuntimeError("UpdateDepositPayload cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CLAIM_ERROR:
        error: "DepositClaimError"

        def __init__(self,error: "DepositClaimError"):
            self.error = error

        def __str__(self):
            return "UpdateDepositPayload.CLAIM_ERROR(error={})".format(self.error)

        def __eq__(self, other):
            if not other.is_claim_error():
                return False
            if self.error != other.error:
                return False
            return True
    
    class REFUND:
        refund_txid: "str"
        refund_tx: "str"

        def __init__(self,refund_txid: "str", refund_tx: "str"):
            self.refund_txid = refund_txid
            self.refund_tx = refund_tx

        def __str__(self):
            return "UpdateDepositPayload.REFUND(refund_txid={}, refund_tx={})".format(self.refund_txid, self.refund_tx)

        def __eq__(self, other):
            if not other.is_refund():
                return False
            if self.refund_txid != other.refund_txid:
                return False
            if self.refund_tx != other.refund_tx:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_claim_error(self) -> bool:
        return isinstance(self, UpdateDepositPayload.CLAIM_ERROR)
    def is_refund(self) -> bool:
        return isinstance(self, UpdateDepositPayload.REFUND)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
UpdateDepositPayload.CLAIM_ERROR = type("UpdateDepositPayload.CLAIM_ERROR", (UpdateDepositPayload.CLAIM_ERROR, UpdateDepositPayload,), {})  # type: ignore
UpdateDepositPayload.REFUND = type("UpdateDepositPayload.REFUND", (UpdateDepositPayload.REFUND, UpdateDepositPayload,), {})  # type: ignore




class _UniffiConverterTypeUpdateDepositPayload(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UpdateDepositPayload.CLAIM_ERROR(
                _UniffiConverterTypeDepositClaimError.read(buf),
            )
        if variant == 2:
            return UpdateDepositPayload.REFUND(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_claim_error():
            _UniffiConverterTypeDepositClaimError.check_lower(value.error)
            return
        if value.is_refund():
            _UniffiConverterString.check_lower(value.refund_txid)
            _UniffiConverterString.check_lower(value.refund_tx)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_claim_error():
            buf.write_i32(1)
            _UniffiConverterTypeDepositClaimError.write(value.error, buf)
        if value.is_refund():
            buf.write_i32(2)
            _UniffiConverterString.write(value.refund_txid, buf)
            _UniffiConverterString.write(value.refund_tx, buf)





class EventListener(typing.Protocol):
    """
    Trait for event listeners
    """

    def on_event(self, event: "SdkEvent"):
        """
        Called when an event occurs
        """

        raise NotImplementedError


# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplEventListener:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_EVENT_LISTENER_METHOD0
    def on_event(
            uniffi_handle,
            event,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeEventListener._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeSdkEvent.lift(event), )
            method = uniffi_obj.on_event
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async(make_call, handle_success, handle_error)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeEventListener._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceEventListener(
        on_event,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(ctypes.byref(_uniffi_vtable))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterTypeEventListener = _UniffiCallbackInterfaceFfiConverter()



class Logger(typing.Protocol):
    def log(self, l: "LogEntry"):
        raise NotImplementedError


# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplLogger:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD0
    def log(
            uniffi_handle,
            l,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeLogger._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeLogEntry.lift(l), )
            method = uniffi_obj.log
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeLogger._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceLogger(
        log,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(ctypes.byref(_uniffi_vtable))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterTypeLogger = _UniffiCallbackInterfaceFfiConverter()



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCredentials(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeCredentials.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCredentials.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCredentials.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeKeySetConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeKeySetConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeKeySetConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeKeySetConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLightningAddressInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLightningAddressInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLightningAddressInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLightningAddressInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLnurlPayInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLnurlPayInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLnurlPayInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLnurlPayInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLnurlReceiveMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLnurlReceiveMetadata.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLnurlReceiveMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLnurlReceiveMetadata.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLnurlWithdrawInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLnurlWithdrawInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLnurlWithdrawInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLnurlWithdrawInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeOutgoingChange(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeOutgoingChange.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeOutgoingChange.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeOutgoingChange.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePayment(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePayment.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePayment.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePayment.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRecord(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRecord.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRecord.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRecord.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSparkHtlcDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSparkHtlcDetails.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSparkHtlcDetails.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSparkHtlcDetails.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSparkHtlcOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSparkHtlcOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSparkHtlcOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSparkHtlcOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSparkInvoicePaymentDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSparkInvoicePaymentDetails.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSparkInvoicePaymentDetails.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSparkInvoicePaymentDetails.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSymbol(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSymbol.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSymbol.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSymbol.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTokenConversionInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTokenConversionInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTokenConversionInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTokenConversionInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTokenConversionOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTokenConversionOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTokenConversionOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTokenConversionOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAmount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAmount.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAmount.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAmount.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAssetFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAssetFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAssetFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAssetFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDepositClaimError(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDepositClaimError.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDepositClaimError.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDepositClaimError.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFee(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFee.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFee.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFee.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMaxFee(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMaxFee.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMaxFee.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMaxFee.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePaymentDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePaymentDetails.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePaymentDetails.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePaymentDetails.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSendPaymentOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSendPaymentOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSendPaymentOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSendPaymentOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSuccessAction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSuccessAction.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSuccessAction.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSuccessAction.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSuccessActionProcessed(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSuccessActionProcessed.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSuccessActionProcessed.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSuccessActionProcessed.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLogger(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLogger.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLogger.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLogger.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeExternalInputParser(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeExternalInputParser.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeExternalInputParser.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeExternalInputParser.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypePaymentDetailsFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypePaymentDetailsFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypePaymentDetailsFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypePaymentDetailsFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypePaymentStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypePaymentStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypePaymentStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypePaymentStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypePaymentType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypePaymentType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypePaymentType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypePaymentType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeSparkHtlcStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeSparkHtlcStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeSparkHtlcStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeSparkHtlcStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterMapStringString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterMapStringString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterMapStringString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeU128(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeU128.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeU128.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeU128.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterBytes.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBytes.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterBytes.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBip21Extra(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeBip21Extra.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBip21Extra.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBip21Extra.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBolt11RouteHint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeBolt11RouteHint.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBolt11RouteHint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBolt11RouteHint.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBolt11RouteHintHop(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeBolt11RouteHintHop.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBolt11RouteHintHop.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBolt11RouteHintHop.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBolt12OfferBlindedPath(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeBolt12OfferBlindedPath.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBolt12OfferBlindedPath.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBolt12OfferBlindedPath.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDepositInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDepositInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDepositInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDepositInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeExternalInputParser(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeExternalInputParser.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeExternalInputParser.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeExternalInputParser.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeExternalVerifiableSecretShare(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeExternalVerifiableSecretShare.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeExternalVerifiableSecretShare.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeExternalVerifiableSecretShare.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFiatCurrency(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFiatCurrency.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFiatCurrency.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFiatCurrency.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeIdentifierCommitmentPair(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeIdentifierCommitmentPair.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeIdentifierCommitmentPair.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeIdentifierCommitmentPair.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeIdentifierPublicKeyPair(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeIdentifierPublicKeyPair.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeIdentifierPublicKeyPair.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeIdentifierPublicKeyPair.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeIdentifierSignaturePair(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeIdentifierSignaturePair.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeIdentifierSignaturePair.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeIdentifierSignaturePair.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeIncomingChange(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeIncomingChange.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeIncomingChange.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeIncomingChange.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLocaleOverrides(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLocaleOverrides.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLocaleOverrides.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLocaleOverrides.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLocalizedName(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLocalizedName.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLocalizedName.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLocalizedName.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeOutgoingChange(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeOutgoingChange.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeOutgoingChange.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeOutgoingChange.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePayment(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePayment.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePayment.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePayment.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeProvisionalPayment(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeProvisionalPayment.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeProvisionalPayment.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeProvisionalPayment.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRate.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRate.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRecord(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRecord.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRecord.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRecord.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSetLnurlMetadataItem(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSetLnurlMetadataItem.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSetLnurlMetadataItem.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSetLnurlMetadataItem.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTokenMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTokenMetadata.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTokenMetadata.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTokenMetadata.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeUtxo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeUtxo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeUtxo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeUtxo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeInputType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeInputType.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeInputType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeInputType.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePaymentDetailsFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePaymentDetailsFilter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePaymentDetailsFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePaymentDetailsFilter.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePaymentStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePaymentStatus.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePaymentStatus.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePaymentStatus.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePaymentType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePaymentType.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePaymentType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePaymentType.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSparkHtlcStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSparkHtlcStatus.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSparkHtlcStatus.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSparkHtlcStatus.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterString.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypeTokenBalance(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterTypeTokenBalance.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeTokenBalance.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeTokenBalance.read(buf)
            d[key] = val
        return d


class _UniffiConverterTypeU128:
    @staticmethod
    def write(value, buf):
        builtin_value = str(value)
        _UniffiConverterString.write(builtin_value, buf)

    @staticmethod
    def read(buf):
        builtin_value = _UniffiConverterString.read(buf)
        return int(builtin_value)

    @staticmethod
    def lift(value):
        builtin_value = _UniffiConverterString.lift(value)
        return int(builtin_value)

    @staticmethod
    def check_lower(value):
        builtin_value = str(value)
        return _UniffiConverterString.check_lower(builtin_value)

    @staticmethod
    def lower(value):
        builtin_value = str(value)
        return _UniffiConverterString.lower(builtin_value)
U128 = str

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)
def _uniffi_trait_interface_call_async(make_call, handle_success, handle_error):
    async def make_call_and_call_callback():
        try:
            handle_success(await make_call())
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

def _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, error_type, lower_error):
    async def make_call_and_call_callback():
        try:
            try:
                handle_success(await make_call())
            except error_type as e:
                handle_error(
                    _UniffiRustCallStatus.CALL_ERROR,
                    lower_error(e),
                )
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

_UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = _UniffiHandleMap()

@_UNIFFI_FOREIGN_FUTURE_FREE
def _uniffi_foreign_future_free(handle):
    (eventloop, task) = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle)
    eventloop.call_soon(_uniffi_foreign_future_do_free, task)

def _uniffi_foreign_future_do_free(task):
    if not task.done():
        task.cancel()
async def connect(request: "ConnectRequest") -> "BreezSdk":

    """
    Connects to the Spark network using the provided configuration and mnemonic.

    # Arguments

    * `request` - The connection request object

    # Returns

    Result containing either the initialized `BreezSdk` or an `SdkError`
    """

    _UniffiConverterTypeConnectRequest.check_lower(request)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_breez_sdk_spark_fn_func_connect(
        _UniffiConverterTypeConnectRequest.lower(request)),
        _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_pointer,
        _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_pointer,
        _UniffiLib.ffi_breez_sdk_spark_rust_future_free_pointer,
        # lift function
        _UniffiConverterTypeBreezSdk.lift,
        
    # Error FFI converter
_UniffiConverterTypeSdkError,

    )
async def connect_with_signer(request: "ConnectWithSignerRequest") -> "BreezSdk":

    """
    Connects to the Spark network using an external signer.

    This method allows using a custom signer implementation instead of providing
    a seed directly.

    # Arguments

    * `request` - The connection request object with external signer

    # Returns

    Result containing either the initialized `BreezSdk` or an `SdkError`
    """

    _UniffiConverterTypeConnectWithSignerRequest.check_lower(request)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_breez_sdk_spark_fn_func_connect_with_signer(
        _UniffiConverterTypeConnectWithSignerRequest.lower(request)),
        _UniffiLib.ffi_breez_sdk_spark_rust_future_poll_pointer,
        _UniffiLib.ffi_breez_sdk_spark_rust_future_complete_pointer,
        _UniffiLib.ffi_breez_sdk_spark_rust_future_free_pointer,
        # lift function
        _UniffiConverterTypeBreezSdk.lift,
        
    # Error FFI converter
_UniffiConverterTypeSdkError,

    )

def default_config(network: "Network") -> "Config":
    _UniffiConverterTypeNetwork.check_lower(network)
    
    return _UniffiConverterTypeConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_breez_sdk_spark_fn_func_default_config,
        _UniffiConverterTypeNetwork.lower(network)))


def default_external_signer(mnemonic: "str",passphrase: "typing.Optional[str]",network: "Network",key_set_config: "typing.Optional[KeySetConfig]") -> "ExternalSigner":
    """
    Creates a default external signer from a mnemonic.

    This is a convenience factory method for creating a signer that can be used
    with `connect_with_signer` or `SdkBuilder::new_with_signer`.

    # Arguments

    * `mnemonic` - BIP39 mnemonic phrase (12 or 24 words)
    * `passphrase` - Optional passphrase for the mnemonic
    * `network` - Network to use (Mainnet or Regtest)
    * `key_set_config` - Optional key set configuration. If None, uses default configuration.

    # Returns

    Result containing the signer as `Arc<dyn ExternalSigner>`
    """

    _UniffiConverterString.check_lower(mnemonic)
    
    _UniffiConverterOptionalString.check_lower(passphrase)
    
    _UniffiConverterTypeNetwork.check_lower(network)
    
    _UniffiConverterOptionalTypeKeySetConfig.check_lower(key_set_config)
    
    return _UniffiConverterTypeExternalSigner.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_spark_fn_func_default_external_signer,
        _UniffiConverterString.lower(mnemonic),
        _UniffiConverterOptionalString.lower(passphrase),
        _UniffiConverterTypeNetwork.lower(network),
        _UniffiConverterOptionalTypeKeySetConfig.lower(key_set_config)))


def init_logging(log_dir: "typing.Optional[str]",app_logger: "typing.Optional[Logger]",log_filter: "typing.Optional[str]") -> None:
    _UniffiConverterOptionalString.check_lower(log_dir)
    
    _UniffiConverterOptionalTypeLogger.check_lower(app_logger)
    
    _UniffiConverterOptionalString.check_lower(log_filter)
    
    _uniffi_rust_call_with_error(_UniffiConverterTypeSdkError,_UniffiLib.uniffi_breez_sdk_spark_fn_func_init_logging,
        _UniffiConverterOptionalString.lower(log_dir),
        _UniffiConverterOptionalTypeLogger.lower(app_logger),
        _UniffiConverterOptionalString.lower(log_filter))


__all__ = [
    "InternalError",
    "AesSuccessActionDataResult",
    "Amount",
    "AssetFilter",
    "BitcoinNetwork",
    "ChainApiType",
    "ChainServiceError",
    "DepositClaimError",
    "ExternalPrivateKeySource",
    "ExternalSecretToSplit",
    "Fee",
    "InputType",
    "KeySetType",
    "MaxFee",
    "Network",
    "OnchainConfirmationSpeed",
    "OptimizationEvent",
    "PaymentDetails",
    "PaymentDetailsFilter",
    "PaymentMethod",
    "PaymentObserverError",
    "PaymentStatus",
    "PaymentType",
    "ProvisionalPaymentDetails",
    "ReceivePaymentMethod",
    "SdkError",
    "SdkEvent",
    "Seed",
    "SendPaymentMethod",
    "SendPaymentOptions",
    "ServiceConnectivityError",
    "SignerError",
    "SparkHtlcStatus",
    "StorageError",
    "SuccessAction",
    "SuccessActionProcessed",
    "SyncStorageError",
    "TokenConversionType",
    "UpdateDepositPayload",
    "AesSuccessActionData",
    "AesSuccessActionDataDecrypted",
    "Bip21Details",
    "Bip21Extra",
    "BitcoinAddressDetails",
    "Bolt11Invoice",
    "Bolt11InvoiceDetails",
    "Bolt11RouteHint",
    "Bolt11RouteHintHop",
    "Bolt12Invoice",
    "Bolt12InvoiceDetails",
    "Bolt12InvoiceRequestDetails",
    "Bolt12Offer",
    "Bolt12OfferBlindedPath",
    "Bolt12OfferDetails",
    "BurnIssuerTokenRequest",
    "CheckLightningAddressRequest",
    "CheckMessageRequest",
    "CheckMessageResponse",
    "ClaimDepositRequest",
    "ClaimDepositResponse",
    "ClaimHtlcPaymentRequest",
    "ClaimHtlcPaymentResponse",
    "Config",
    "ConnectRequest",
    "ConnectWithSignerRequest",
    "CreateIssuerTokenRequest",
    "Credentials",
    "CurrencyInfo",
    "DepositInfo",
    "EcdsaSignatureBytes",
    "ExternalAggregateFrostRequest",
    "ExternalEncryptedPrivateKey",
    "ExternalFrostCommitments",
    "ExternalFrostSignature",
    "ExternalFrostSignatureShare",
    "ExternalIdentifier",
    "ExternalInputParser",
    "ExternalScalar",
    "ExternalSecretShare",
    "ExternalSignFrostRequest",
    "ExternalSigningCommitments",
    "ExternalTreeNodeId",
    "ExternalVerifiableSecretShare",
    "FetchTokenConversionLimitsRequest",
    "FetchTokenConversionLimitsResponse",
    "FiatCurrency",
    "FreezeIssuerTokenRequest",
    "FreezeIssuerTokenResponse",
    "GetInfoRequest",
    "GetInfoResponse",
    "GetPaymentRequest",
    "GetPaymentResponse",
    "GetTokensMetadataRequest",
    "GetTokensMetadataResponse",
    "IdentifierCommitmentPair",
    "IdentifierPublicKeyPair",
    "IdentifierSignaturePair",
    "IncomingChange",
    "KeySetConfig",
    "LightningAddressDetails",
    "LightningAddressInfo",
    "ListFiatCurrenciesResponse",
    "ListFiatRatesResponse",
    "ListPaymentsRequest",
    "ListPaymentsResponse",
    "ListUnclaimedDepositsRequest",
    "ListUnclaimedDepositsResponse",
    "LnurlAuthRequestDetails",
    "LnurlPayInfo",
    "LnurlPayRequest",
    "LnurlPayRequestDetails",
    "LnurlPayResponse",
    "LnurlReceiveMetadata",
    "LnurlWithdrawInfo",
    "LnurlWithdrawRequest",
    "LnurlWithdrawRequestDetails",
    "LnurlWithdrawResponse",
    "LocaleOverrides",
    "LocalizedName",
    "LogEntry",
    "MessageSuccessActionData",
    "MintIssuerTokenRequest",
    "OptimizationConfig",
    "OptimizationProgress",
    "OutgoingChange",
    "Payment",
    "PaymentMetadata",
    "PaymentRequestSource",
    "PrepareLnurlPayRequest",
    "PrepareLnurlPayResponse",
    "PrepareSendPaymentRequest",
    "PrepareSendPaymentResponse",
    "PrivateKeyBytes",
    "ProvisionalPayment",
    "PublicKeyBytes",
    "Rate",
    "ReceivePaymentRequest",
    "ReceivePaymentResponse",
    "RecommendedFees",
    "Record",
    "RecordChange",
    "RecordId",
    "RecoverableEcdsaSignatureBytes",
    "RefundDepositRequest",
    "RefundDepositResponse",
    "RegisterLightningAddressRequest",
    "RestResponse",
    "SchnorrSignatureBytes",
    "SendOnchainFeeQuote",
    "SendOnchainSpeedFeeQuote",
    "SendPaymentRequest",
    "SendPaymentResponse",
    "SetLnurlMetadataItem",
    "SignMessageRequest",
    "SignMessageResponse",
    "SilentPaymentAddressDetails",
    "SparkAddressDetails",
    "SparkHtlcDetails",
    "SparkHtlcOptions",
    "SparkInvoiceDetails",
    "SparkInvoicePaymentDetails",
    "Symbol",
    "SyncWalletRequest",
    "SyncWalletResponse",
    "TokenBalance",
    "TokenConversionInfo",
    "TokenConversionOptions",
    "TokenMetadata",
    "TxStatus",
    "UnfreezeIssuerTokenRequest",
    "UnfreezeIssuerTokenResponse",
    "UnversionedRecordChange",
    "UpdateUserSettingsRequest",
    "UrlSuccessActionData",
    "UserSettings",
    "Utxo",
    "connect",
    "connect_with_signer",
    "default_config",
    "default_external_signer",
    "init_logging",
    "BitcoinChainService",
    "BreezSdk",
    "ExternalSigner",
    "FiatService",
    "PaymentObserver",
    "RestClient",
    "SdkBuilder",
    "Storage",
    "SyncStorage",
    "TokenIssuer",
    "EventListener",
    "Logger",
]

