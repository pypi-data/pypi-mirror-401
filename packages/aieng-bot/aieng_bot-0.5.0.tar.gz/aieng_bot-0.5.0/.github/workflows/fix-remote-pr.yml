name: Fix Remote Repository PR

on:
  workflow_dispatch:
    inputs:
      target_repo:
        description: 'Target repository (e.g., VectorInstitute/repo-name)'
        required: true
      pr_number:
        description: 'PR number to fix'
        required: true

permissions:
  contents: read
  issues: write
  id-token: write

jobs:
  fix-pr:
    runs-on: ubuntu-latest

    steps:
      - name: Validate target repository
        run: |
          TARGET_REPO="${{ github.event.inputs.target_repo }}"

          # Prevent the bot from modifying its own repository
          if [ "$TARGET_REPO" = "VectorInstitute/aieng-bot" ]; then
            echo "‚ùå ERROR: Cannot run fix workflow on the bot repository itself (VectorInstitute/aieng-bot)"
            echo "This would cause the bot to modify its own code, potentially deleting important files."
            echo "If you need to fix PRs in aieng-bot, do it manually."
            exit 1
          fi

          echo "‚úì Target repository validated: $TARGET_REPO"

      - name: Checkout bot repository
        uses: actions/checkout@v6
        with:
          path: bot-repo

      - name: Get PR basic info for checkout
        id: pr-details
        run: |
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"

          # Get minimal PR info needed for checkout (full details fetched by CLI)
          PR_INFO=$(gh pr view $PR_NUMBER --repo "$REPO" --json \
            title,author,headRefName,baseRefName,mergeable)

          echo "PR Info:"
          echo "$PR_INFO" | jq '.'

          # Extract details for checkout step
          HEAD_REF=$(echo "$PR_INFO" | jq -r '.headRefName')
          BASE_REF=$(echo "$PR_INFO" | jq -r '.baseRefName')
          PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
          PR_AUTHOR=$(echo "$PR_INFO" | jq -r '.author.login')
          MERGEABLE=$(echo "$PR_INFO" | jq -r '.mergeable')

          echo "head-ref=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "base-ref=$BASE_REF" >> $GITHUB_OUTPUT
          echo "pr-title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "pr-author=$PR_AUTHOR" >> $GITHUB_OUTPUT
          echo "mergeable=$MERGEABLE" >> $GITHUB_OUTPUT

          echo "Branch: $HEAD_REF ‚Üí $BASE_REF"
          echo "Mergeable: $MERGEABLE"
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}

      - name: Checkout target repository PR branch
        uses: actions/checkout@v6
        with:
          repository: ${{ github.event.inputs.target_repo }}
          ref: refs/pull/${{ github.event.inputs.pr_number }}/head
          token: ${{ secrets.ORG_ACCESS_TOKEN }}
          path: target-repo
          fetch-depth: 0

      - name: Configure git for agent
        working-directory: target-repo
        run: |
          git config user.name "aieng-bot[bot]"
          git config user.email "aieng-bot@vectorinstitute.ai"

      - name: Attempt merge to expose conflicts
        id: merge-attempt
        working-directory: target-repo
        run: |
          MERGEABLE='${{ steps.pr-details.outputs.mergeable }}'
          BASE_REF="${{ steps.pr-details.outputs.base-ref }}"

          # If PR has merge conflicts, attempt merge to create conflict markers
          if [ "$MERGEABLE" = "CONFLICTING" ]; then
            echo "PR has merge conflicts - attempting merge to expose conflict markers"

            # Fetch the base branch
            git fetch origin "$BASE_REF"

            # Attempt to merge (this will fail and create conflict markers)
            if ! git merge "origin/$BASE_REF" --no-edit; then
              echo "‚úì Merge failed as expected - conflict markers are now in files"
              echo "conflicts-exposed=true" >> $GITHUB_OUTPUT

              # Show which files have conflicts
              echo "Files with conflicts:"
              git diff --name-only --diff-filter=U
            else
              echo "‚ö†Ô∏è  Merge succeeded unexpectedly - PR may no longer have conflicts"
              echo "conflicts-exposed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "PR is mergeable - no conflict exposure needed"
            echo "conflicts-exposed=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true


      - name: Setup Python for classification
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install classifier dependencies
        run: |
          cd bot-repo
          pip install -e .

      - name: Analyze failure type with Claude
        id: analyze
        working-directory: bot-repo
        run: |
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"

          echo "Analyzing PR $REPO#$PR_NUMBER with Claude-based classifier..."
          echo ""

          # Run classify command and save JSON to file
          if ! aieng-bot classify \
            --repo "$REPO" \
            --pr "$PR_NUMBER" \
            --output /tmp/classification.json 2> /tmp/classification-error.txt; then
            echo "‚ùå Classification failed with exit code $?"
            echo "STDERR:"
            cat /tmp/classification-error.txt || echo "(no stderr)"
            exit 1
          fi

          # Parse JSON and output to GitHub Actions
          echo "Classification results:"
          cat /tmp/classification.json
          echo ""

          # Extract fields from JSON for validation
          FAILURE_TYPE=$(jq -r '.failure_type' /tmp/classification.json)
          CONFIDENCE=$(jq -r '.confidence' /tmp/classification.json)
          REASONING=$(jq -r '.reasoning' /tmp/classification.json)

          # Output to GitHub Actions
          echo "failure-type=$FAILURE_TYPE" >> $GITHUB_OUTPUT
          echo "confidence=$CONFIDENCE" >> $GITHUB_OUTPUT
          {
            echo "reasoning<<EOF_REASONING"
            echo "$REASONING"
            echo "EOF_REASONING"
          } >> $GITHUB_OUTPUT

          # Check if we should skip (unknown failure type)
          echo "Classification: $FAILURE_TYPE (confidence: $CONFIDENCE)"
          printf 'Reasoning: %s\n' "$REASONING"

          if [ "$FAILURE_TYPE" = "unknown" ]; then
            echo "Failure type is unknown - skipping automated fix attempt"
            echo "should-skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Verify failure type is supported
          case "$FAILURE_TYPE" in
            merge_conflict|test|lint|security|build)
              echo "‚úì Failure type '$FAILURE_TYPE' is supported"
              echo "should-skip=false" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unsupported failure type: $FAILURE_TYPE - skipping"
              echo "should-skip=true" >> $GITHUB_OUTPUT
              exit 0
              ;;
          esac
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}

      - name: Install Claude Code CLI
        if: steps.analyze.outputs.should-skip != 'true'
        run: |
          curl -fsSL https://claude.ai/install.sh | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Setup Python for Agent SDK
        if: steps.analyze.outputs.should-skip != 'true'
        uses: actions/setup-python@v6
        with:
          python-version-file: bot-repo/.python-version

      - name: Install uv (Python package manager)
        if: steps.analyze.outputs.should-skip != 'true'
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Authenticate to Google Cloud
        if: steps.analyze.outputs.should-skip != 'true'
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
        continue-on-error: true

      - name: Set up Cloud SDK
        if: steps.analyze.outputs.should-skip != 'true'
        uses: google-github-actions/setup-gcloud@v3
        continue-on-error: true

      - name: Apply AI fixes using Claude Agent SDK
        if: steps.analyze.outputs.should-skip != 'true'
        id: fix
        working-directory: target-repo
        run: |
          # Apply fixes using the simplified fix command
          # All preparation (skills copying, logs fetching, PR details) is now done in Python
          aieng-bot fix \
            --repo "${{ github.event.inputs.target_repo }}" \
            --pr "${{ github.event.inputs.pr_number }}" \
            --cls /tmp/classification.json \
            --cwd "$(pwd)" \
            --workflow-run-id "${{ github.run_id }}" \
            --github-run-url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
        continue-on-error: false

      - name: Verify bot files not committed (Layer 3)
        if: steps.analyze.outputs.should-skip != 'true'
        working-directory: target-repo
        run: |
          echo "Verifying bot temporary files are not staged or committed..."

          # Check if bot files are in staging area
          BOT_FILES_STAGED=$(git diff --cached --name-only | grep -E "^\.claude/|^\.pr-context\.json$|^\.failure-logs\.txt$" || true)

          if [ -n "$BOT_FILES_STAGED" ]; then
            echo "‚ùå ERROR: Bot temporary files found in staging area!"
            echo "$BOT_FILES_STAGED"
            echo ""
            echo "Unstaging bot files..."
            echo "$BOT_FILES_STAGED" | xargs git reset HEAD --
            echo "‚úì Bot files unstaged"
          fi

          # Check if bot files exist in any unpushed commits
          BASE_REF="${{ steps.pr-details.outputs.base-ref }}"
          BOT_FILES_COMMITTED=$(git diff --name-only "origin/$BASE_REF...HEAD" | grep -E "^\.claude/|^\.pr-context\.json$|^\.failure-logs\.txt$" || true)

          if [ -n "$BOT_FILES_COMMITTED" ]; then
            echo "‚ö†Ô∏è  WARNING: Bot temporary files found in commits!"
            echo "$BOT_FILES_COMMITTED"
            echo ""
            echo "These files should not be committed. Please check the commits."
            exit 1
          fi

          echo "‚úì No bot files found in staging area or commits"

          # Note: Cleanup is now handled by the fix command itself
          echo "‚úì Bot files cleanup handled by fix command"

      - name: Upload trace to GCS
        if: always()
        working-directory: target-repo
        run: |
          if [ -f /tmp/agent-execution-trace.json ]; then
            # Generate date-based path: traces/YYYY/MM/DD/
            DATE_PATH=$(date -u +"%Y/%m/%d")

            # Generate filename: repo-name-pr-123-runid.json
            REPO_NAME=$(echo "${{ github.event.inputs.target_repo }}" | sed 's/\//-/g')
            TRACE_FILE="$REPO_NAME-pr-${{ github.event.inputs.pr_number }}-${{ github.run_id }}.json"

            DEST_PATH="traces/$DATE_PATH/$TRACE_FILE"

            echo "Uploading trace to gs://bot-dashboard-vectorinstitute/$DEST_PATH"

            gcloud storage cp /tmp/agent-execution-trace.json \
              "gs://bot-dashboard-vectorinstitute/$DEST_PATH" \
              --content-type="application/json" \
              --cache-control="no-cache, no-store, must-revalidate" || {
              echo " Failed to upload trace to GCS, will rely on GitHub artifact"
            }

            # Save trace URL for PR comment
            echo "trace_url=https://storage.googleapis.com/bot-dashboard-vectorinstitute/$DEST_PATH" >> $GITHUB_OUTPUT

            # Update traces index for faster lookups
            cat > /tmp/trace-index-entry.json << EOF
            {
              "repo": "${{ github.event.inputs.target_repo }}",
              "pr_number": ${{ github.event.inputs.pr_number }},
              "trace_path": "$DEST_PATH",
              "workflow_run_id": "${{ github.run_id }}",
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            }
          EOF

            # Download existing index or create new one
            if gcloud storage cp gs://bot-dashboard-vectorinstitute/data/traces_index.json /tmp/traces_index.json 2>/dev/null; then
              echo "Downloaded existing traces index"
            else
              echo '{"traces": [], "last_updated": ""}' > /tmp/traces_index.json
              echo "Created new traces index"
            fi

            # Append new entry to index
            jq --slurpfile entry /tmp/trace-index-entry.json \
              '.traces += $entry | .last_updated = "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"' \
              /tmp/traces_index.json > /tmp/traces_index_updated.json

            # Upload updated index back to GCS
            gcloud storage cp /tmp/traces_index_updated.json \
              gs://bot-dashboard-vectorinstitute/data/traces_index.json \
              --content-type="application/json" \
              --cache-control="no-cache, no-store, must-revalidate" || {
              echo " Failed to update traces index"
            }

            echo "‚úì Trace uploaded successfully and index updated"

            # Also record to activity log for unified dashboard view
            echo "üìä Recording bot fix activity to activity log..."

            # Extract key info from trace
            TRACE_STATUS=$(jq -r '.result.status' /tmp/agent-execution-trace.json)
            FAILURE_TYPE=$(jq -r '.metadata.failure.type' /tmp/agent-execution-trace.json)
            FIX_TIME=$(jq -r '.execution.duration_seconds / 3600' /tmp/agent-execution-trace.json)

            # Create activity entry
            ACTIVITY_JSON=$(cat <<ACTIVITY_EOF
            {
              "type": "bot_fix",
              "repo": "${{ github.event.inputs.target_repo }}",
              "pr_number": ${{ github.event.inputs.pr_number }},
              "pr_title": "${{ steps.pr-details.outputs.pr-title }}",
              "pr_author": "${{ steps.pr-details.outputs.pr-author }}",
              "pr_url": "https://github.com/${{ github.event.inputs.target_repo }}/pull/${{ github.event.inputs.pr_number }}",
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "workflow_run_id": "${{ github.run_id }}",
              "github_run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
              "status": "$TRACE_STATUS",
              "failure_type": "$FAILURE_TYPE",
              "trace_path": "$DEST_PATH",
              "fix_time_hours": $FIX_TIME
            }
          ACTIVITY_EOF
            )

            # Download existing activity log or create new one
            ACTIVITY_LOG="/tmp/bot_activity_log.json"
            if gcloud storage cp gs://bot-dashboard-vectorinstitute/data/bot_activity_log.json "$ACTIVITY_LOG" 2>/dev/null; then
              echo "‚úì Downloaded existing activity log"
            else
              echo '{"activities": [], "last_updated": null}' > "$ACTIVITY_LOG"
              echo "‚úì Created new activity log"
            fi

            # Append new activity and update timestamp
            TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            jq --argjson new_activity "$ACTIVITY_JSON" \
               --arg timestamp "$TIMESTAMP" \
               '.activities += [$new_activity] | .last_updated = $timestamp' \
               "$ACTIVITY_LOG" > /tmp/updated_activity_log.json

            # Upload back to GCS
            gcloud storage cp /tmp/updated_activity_log.json gs://bot-dashboard-vectorinstitute/data/bot_activity_log.json \
              --content-type=application/json \
              --cache-control="no-cache, no-store, must-revalidate" || {
              echo " Failed to update activity log"
            }

            echo "‚úì Bot fix activity recorded to GCS"
          else
            echo " No trace file found at /tmp/agent-execution-trace.json"
          fi
        continue-on-error: true
        id: upload-trace

      - name: Upload trace as GitHub artifact (backup)
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: agent-trace-${{ github.event.inputs.pr_number }}-${{ github.run_id }}
          path: /tmp/agent-execution-trace.json
          retention-days: 90
        continue-on-error: true

      - name: Check for changes and push
        if: steps.analyze.outputs.should-skip != 'true'
        id: push-fixes
        working-directory: target-repo
        run: |
          # Check if Agent SDK created a commit (check if HEAD differs from remote)
          git fetch origin ${{ steps.pr-details.outputs.head-ref }}

          if ! git diff --quiet HEAD FETCH_HEAD; then
            echo " Agent SDK made changes, pushing commit..."

            # Push the commit created by Agent SDK
            git push origin HEAD:${{ steps.pr-details.outputs.head-ref }}

            echo "changes-pushed=true" >> $GITHUB_OUTPUT
            echo " Fixes pushed to PR"
          elif [ -n "$(git status --porcelain)" ]; then
            echo "Uncommitted changes detected, committing..."

            git config user.name "aieng-bot[bot]"
            git config user.email "aieng-bot@vectorinstitute.ai"
            git add -A

            # Extract failure info from classification for commit message
            FAILURE_TYPE=$(jq -r '.failure_type' /tmp/classification.json)
            FAILED_CHECKS=$(jq -r '.failed_check_names | join(", ")' /tmp/classification.json)

            cat > /tmp/commit-message.txt <<EOF
          Fix ${FAILURE_TYPE} failures after dependency updates

          Automated fixes applied by AI Engineering Maintenance Bot

          Fixes: ${FAILED_CHECKS}

          Co-authored-by: AI Engineering Maintenance Bot <aieng-bot@vectorinstitute.ai>
          EOF

            git commit -F /tmp/commit-message.txt
            git push origin HEAD:${{ steps.pr-details.outputs.head-ref }}

            echo "changes-pushed=true" >> $GITHUB_OUTPUT
            echo " Fixes pushed to PR"
          else
            echo "changes-pushed=false" >> $GITHUB_OUTPUT
            echo "  No changes to push"
          fi
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
        continue-on-error: true

      - name: Comment on PR - Result
        if: steps.push-fixes.outputs.changes-pushed == 'true'
        run: |
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"

          # Extract failure type from classification
          FAILURE_TYPE=$(jq -r '.failure_type' /tmp/classification.json)

          # Read the fix summary if available
          FIX_SUMMARY=""
          if [ -f /tmp/fix-summary.txt ]; then
            FIX_SUMMARY=$(cat /tmp/fix-summary.txt)
          fi

          TRACE_URL="${{ steps.upload-trace.outputs.trace_url }}"
          DASHBOARD_URL="https://platform.vectorinstitute.ai/aieng-bot"

          echo "**Automated fix applied**" > /tmp/pr-result.txt
          echo "" >> /tmp/pr-result.txt
          echo "Fixed ${FAILURE_TYPE} failures after dependency updates." >> /tmp/pr-result.txt
          echo "" >> /tmp/pr-result.txt

          if [ -n "$FIX_SUMMARY" ]; then
            echo "$FIX_SUMMARY" >> /tmp/pr-result.txt
            echo "" >> /tmp/pr-result.txt
          fi

          echo "CI checks will re-run automatically." >> /tmp/pr-result.txt
          echo "" >> /tmp/pr-result.txt
          echo "**[View detailed trace on dashboard](${DASHBOARD_URL})** | [Raw trace](${TRACE_URL})" >> /tmp/pr-result.txt
          echo "" >> /tmp/pr-result.txt
          echo "*AI Engineering Maintenance Bot*" >> /tmp/pr-result.txt

          gh pr comment $PR_NUMBER --repo "$REPO" --body-file /tmp/pr-result.txt
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}

      - name: Wait for checks to complete
        if: steps.fix.outcome == 'success'
        id: wait-checks
        run: |
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"

          echo "‚úì Fix pushed successfully"
          echo "Waiting for CI checks to complete before triggering auto-merge..."
          echo ""

          # Use Python CLI for check waiting (testable, maintainable)
          cd bot-repo
          if aieng-bot wait-checks --repo "$REPO" --pr-number "$PR_NUMBER" --max-wait-minutes 15 --check-interval 30; then
            echo "checks_completed=true" >> $GITHUB_OUTPUT
          else
            EXIT_CODE=$?
            echo "checks_completed=false" >> $GITHUB_OUTPUT

            # Provide helpful messages based on exit code
            case $EXIT_CODE in
              1)
                echo ""
                echo "‚ùå Some checks failed. Will not trigger auto-merge."
                echo "   The monitor workflow will re-attempt fixes on its next run."
                ;;
              2)
                echo ""
                echo "‚è±Ô∏è  Timeout: Checks still running after 15 minutes"
                echo "   Will not trigger auto-merge now."
                echo "   The monitor workflow (runs every 6h) will merge when checks complete."
                ;;
              3)
                echo ""
                echo "‚ö†Ô∏è  No checks found on PR. This might indicate:"
                echo "   - Repository has no CI configured"
                echo "   - Checks haven't started yet"
                ;;
              *)
                echo "‚ùå Error checking PR status (exit code: $EXIT_CODE)"
                ;;
            esac
          fi
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}

      - name: Trigger monitor workflow for auto-merge
        if: steps.wait-checks.outputs.checks_completed == 'true'
        run: |
          echo "üöÄ Triggering monitor workflow to auto-merge PR..."
          echo ""

          # Trigger the monitor workflow to check and merge the PR
          gh workflow run monitor-org-bot-prs.yml \
            --repo VectorInstitute/aieng-bot

          echo "‚úì Monitor workflow triggered"
          echo "  It will check the PR and auto-merge if all conditions are met."
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
