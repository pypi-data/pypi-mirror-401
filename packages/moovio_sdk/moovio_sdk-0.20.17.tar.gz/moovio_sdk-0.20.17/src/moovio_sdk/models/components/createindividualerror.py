"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .addresserror import AddressError, AddressErrorTypedDict
from .birthdateerror import BirthDateError, BirthDateErrorTypedDict
from .individualnameerror import IndividualNameError, IndividualNameErrorTypedDict
from .phonenumbererror import PhoneNumberError, PhoneNumberErrorTypedDict
from moovio_sdk.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class CreateIndividualErrorSsnTypedDict(TypedDict):
    full: NotRequired[str]
    last_four: NotRequired[str]


class CreateIndividualErrorSsn(BaseModel):
    full: Optional[str] = None

    last_four: Annotated[Optional[str], pydantic.Field(alias="lastFour")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["full", "lastFour"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateIndividualErrorItinTypedDict(TypedDict):
    full: NotRequired[str]
    last_four: NotRequired[str]


class CreateIndividualErrorItin(BaseModel):
    full: Optional[str] = None

    last_four: Annotated[Optional[str], pydantic.Field(alias="lastFour")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["full", "lastFour"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateIndividualErrorGovernmentIDTypedDict(TypedDict):
    ssn: NotRequired[CreateIndividualErrorSsnTypedDict]
    itin: NotRequired[CreateIndividualErrorItinTypedDict]


class CreateIndividualErrorGovernmentID(BaseModel):
    ssn: Optional[CreateIndividualErrorSsn] = None

    itin: Optional[CreateIndividualErrorItin] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ssn", "itin"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateIndividualErrorTypedDict(TypedDict):
    name: NotRequired[IndividualNameErrorTypedDict]
    phone: NotRequired[PhoneNumberErrorTypedDict]
    email: NotRequired[str]
    address: NotRequired[AddressErrorTypedDict]
    birth_date: NotRequired[BirthDateErrorTypedDict]
    government_id: NotRequired[CreateIndividualErrorGovernmentIDTypedDict]


class CreateIndividualError(BaseModel):
    name: Optional[IndividualNameError] = None

    phone: Optional[PhoneNumberError] = None

    email: Optional[str] = None

    address: Optional[AddressError] = None

    birth_date: Annotated[
        Optional[BirthDateError], pydantic.Field(alias="birthDate")
    ] = None

    government_id: Annotated[
        Optional[CreateIndividualErrorGovernmentID],
        pydantic.Field(alias="governmentID"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["name", "phone", "email", "address", "birthDate", "governmentID"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
