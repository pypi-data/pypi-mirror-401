# mypy: ignore-errors
# flake8: noqa

# This file is autogenerated by /metadata-ingestion/scripts/avro_codegen.py
# Do not modify manually!

# pylint: skip-file
# fmt: off
# isort: skip_file

# The SchemaFromJSONData method only exists in avro-python3, but is called make_avsc_object in avro.
# We can use this fact to detect conflicts between the two packages. Pip won't detect those conflicts
# because both are namespace packages, and hence are allowed to overwrite files from each other.
# This means that installation order matters, which is a pretty unintuitive outcome.
# See https://github.com/pypa/pip/issues/4625 for details.
try:
    from avro.schema import SchemaFromJSONData  # type: ignore
    import warnings

    warnings.warn("It seems like 'avro-python3' is installed, which conflicts with the 'avro' package used by datahub. "
                + "Try running `pip uninstall avro-python3 && pip install --upgrade --force-reinstall avro` to fix this issue.")
except ImportError:
    pass

import json
import os.path
import decimal
import datetime
import six
from avrogen.dict_wrapper import DictWrapper
from avrogen import avrojson
from avro.schema import RecordSchema, make_avsc_object
from avro import schema as avro_schema
from typing import ClassVar, List, Dict, Union, Optional, Type


def __read_file(file_name):
    with open(file_name, "r") as f:
        return f.read()
        

def __get_names_and_schema(json_str):
    names = avro_schema.Names()
    schema = make_avsc_object(json.loads(json_str), names)
    return names, schema


_SCHEMA_JSON_STR = __read_file(os.path.join(os.path.dirname(__file__), "schema.avsc"))


__NAMES, _SCHEMA = __get_names_and_schema(_SCHEMA_JSON_STR)
__SCHEMAS: Dict[str, RecordSchema] = {}

from datahub._codegen.aspect import _Aspect



def get_schema_type(fullname: str) -> RecordSchema:
    return __SCHEMAS[fullname]
    
    
__SCHEMAS = dict((n.fullname.lstrip("."), n) for n in six.itervalues(__NAMES.names))

class KafkaAuditHeaderClass(DictWrapper):
    """This header records information about the context of an event as it is emitted into kafka and is intended to be used by the kafka audit application.  For more information see go/kafkaauditheader"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.events.KafkaAuditHeader")
    def __init__(self,
        time: int,
        server: str,
        appName: str,
        messageId: bytes,
        instance: Union[None, str]=None,
        auditVersion: Union[None, int]=None,
        fabricUrn: Union[None, str]=None,
        clusterConnectionString: Union[None, str]=None,
    ):
        super().__init__()
        
        self.time = time
        self.server = server
        self.instance = instance
        self.appName = appName
        self.messageId = messageId
        self.auditVersion = auditVersion
        self.fabricUrn = fabricUrn
        self.clusterConnectionString = clusterConnectionString
    
    def _restore_defaults(self) -> None:
        self.time = int()
        self.server = str()
        self.instance = self.RECORD_SCHEMA.fields_dict["instance"].default
        self.appName = str()
        self.messageId = bytes()
        self.auditVersion = self.RECORD_SCHEMA.fields_dict["auditVersion"].default
        self.fabricUrn = self.RECORD_SCHEMA.fields_dict["fabricUrn"].default
        self.clusterConnectionString = self.RECORD_SCHEMA.fields_dict["clusterConnectionString"].default
    
    
    @property
    def time(self) -> int:
        """The time at which the event was emitted into kafka."""
        return self._inner_dict.get('time')  # type: ignore
    
    @time.setter
    def time(self, value: int) -> None:
        self._inner_dict['time'] = value
    
    
    @property
    def server(self) -> str:
        """The fully qualified name of the host from which the event is being emitted."""
        return self._inner_dict.get('server')  # type: ignore
    
    @server.setter
    def server(self, value: str) -> None:
        self._inner_dict['server'] = value
    
    
    @property
    def instance(self) -> Union[None, str]:
        """The instance on the server from which the event is being emitted. e.g. i001"""
        return self._inner_dict.get('instance')  # type: ignore
    
    @instance.setter
    def instance(self, value: Union[None, str]) -> None:
        self._inner_dict['instance'] = value
    
    
    @property
    def appName(self) -> str:
        """The name of the application from which the event is being emitted. see go/appname"""
        return self._inner_dict.get('appName')  # type: ignore
    
    @appName.setter
    def appName(self, value: str) -> None:
        self._inner_dict['appName'] = value
    
    
    @property
    def messageId(self) -> bytes:
        """A unique identifier for the message"""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: bytes) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def auditVersion(self) -> Union[None, int]:
        """The version that is being used for auditing. In version 0, the audit trail buckets events into 10 minute audit windows based on the EventHeader timestamp. In version 1, the audit trail buckets events as follows: if the schema has an outer KafkaAuditHeader, use the outer audit header timestamp for bucketing; else if the EventHeader has an inner KafkaAuditHeader use that inner audit header's timestamp for bucketing"""
        return self._inner_dict.get('auditVersion')  # type: ignore
    
    @auditVersion.setter
    def auditVersion(self, value: Union[None, int]) -> None:
        self._inner_dict['auditVersion'] = value
    
    
    @property
    def fabricUrn(self) -> Union[None, str]:
        """The fabricUrn of the host from which the event is being emitted. Fabric Urn in the format of urn:li:fabric:{fabric_name}. See go/fabric."""
        return self._inner_dict.get('fabricUrn')  # type: ignore
    
    @fabricUrn.setter
    def fabricUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['fabricUrn'] = value
    
    
    @property
    def clusterConnectionString(self) -> Union[None, str]:
        """This is a String that the client uses to establish some kind of connection with the Kafka cluster. The exact format of it depends on specific versions of clients and brokers. This information could potentially identify the fabric and cluster with which the client is producing to or consuming from."""
        return self._inner_dict.get('clusterConnectionString')  # type: ignore
    
    @clusterConnectionString.setter
    def clusterConnectionString(self, value: Union[None, str]) -> None:
        self._inner_dict['clusterConnectionString'] = value
    
    
class DataHubAccessTokenInfoClass(_Aspect):
    """Information about a DataHub Access Token"""


    ASPECT_NAME = 'dataHubAccessTokenInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.access.token.DataHubAccessTokenInfo")

    def __init__(self,
        name: str,
        actorUrn: str,
        ownerUrn: str,
        createdAt: int,
        expiresAt: Union[None, int]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.actorUrn = actorUrn
        self.ownerUrn = ownerUrn
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.actorUrn = str()
        self.ownerUrn = str()
        self.createdAt = int()
        self.expiresAt = self.RECORD_SCHEMA.fields_dict["expiresAt"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def name(self) -> str:
        """User defined name for the access token if defined."""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def actorUrn(self) -> str:
        """Urn of the actor to which this access token belongs to."""
        return self._inner_dict.get('actorUrn')  # type: ignore
    
    @actorUrn.setter
    def actorUrn(self, value: str) -> None:
        self._inner_dict['actorUrn'] = value
    
    
    @property
    def ownerUrn(self) -> str:
        """Urn of the actor which created this access token."""
        return self._inner_dict.get('ownerUrn')  # type: ignore
    
    @ownerUrn.setter
    def ownerUrn(self, value: str) -> None:
        self._inner_dict['ownerUrn'] = value
    
    
    @property
    def createdAt(self) -> int:
        """When the token was created."""
        return self._inner_dict.get('createdAt')  # type: ignore
    
    @createdAt.setter
    def createdAt(self, value: int) -> None:
        self._inner_dict['createdAt'] = value
    
    
    @property
    def expiresAt(self) -> Union[None, int]:
        """When the token expires."""
        return self._inner_dict.get('expiresAt')  # type: ignore
    
    @expiresAt.setter
    def expiresAt(self, value: Union[None, int]) -> None:
        self._inner_dict['expiresAt'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the token if defined."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class DataHubActionConfigClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.action.DataHubActionConfig")
    def __init__(self,
        recipe: str,
        executorId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.recipe = recipe
        self.executorId = executorId
    
    def _restore_defaults(self) -> None:
        self.recipe = str()
        self.executorId = self.RECORD_SCHEMA.fields_dict["executorId"].default
    
    
    @property
    def recipe(self) -> str:
        """The JSON recipe to use for the automation"""
        return self._inner_dict.get('recipe')  # type: ignore
    
    @recipe.setter
    def recipe(self, value: str) -> None:
        self._inner_dict['recipe'] = value
    
    
    @property
    def executorId(self) -> Union[None, str]:
        """The id of the executor pool to use to execute the automation. Defaults to 'default' (runs locally embedded)"""
        return self._inner_dict.get('executorId')  # type: ignore
    
    @executorId.setter
    def executorId(self, value: Union[None, str]) -> None:
        self._inner_dict['executorId'] = value
    
    
class DataHubActionInfoClass(_Aspect):
    """Info about a DataHub Action Pipeline"""


    ASPECT_NAME = 'dataHubActionInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.action.DataHubActionInfo")

    def __init__(self,
        name: str,
        type: str,
        config: "DataHubActionConfigClass",
        category: Union[None, str]=None,
        description: Union[None, str]=None,
        state: Optional[Union[Union[str, "DataHubActionStateClass"], None]]=None,
        source: Union[None, "DataHubActionSourceClass"]=None,
    ):
        super().__init__()
        
        self.name = name
        self.type = type
        self.category = category
        self.description = description
        self.config = config
        if state is None:
            # default: 'ACTIVE'
            self.state = self.RECORD_SCHEMA.fields_dict["state"].default
        else:
            self.state = state
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.type = str()
        self.category = self.RECORD_SCHEMA.fields_dict["category"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.config = DataHubActionConfigClass._construct_with_defaults()
        self.state = self.RECORD_SCHEMA.fields_dict["state"].default
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
    
    
    @property
    def name(self) -> str:
        """The display name of the action"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def type(self) -> str:
        """The type of the action itself, e.g. tag_propagation. Should match the recipe."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def category(self) -> Union[None, str]:
        """The category of the action"""
        return self._inner_dict.get('category')  # type: ignore
    
    @category.setter
    def category(self, value: Union[None, str]) -> None:
        self._inner_dict['category'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """The description of the action"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def config(self) -> "DataHubActionConfigClass":
        """Parameters associated with the Action"""
        return self._inner_dict.get('config')  # type: ignore
    
    @config.setter
    def config(self, value: "DataHubActionConfigClass") -> None:
        self._inner_dict['config'] = value
    
    
    @property
    def state(self) -> Union[Union[str, "DataHubActionStateClass"], None]:
        """The intended state of the action"""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[Union[str, "DataHubActionStateClass"], None]) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def source(self) -> Union[None, "DataHubActionSourceClass"]:
        """The source or origin of the Action
    
    Currently CLI and UI do not provide an explicit source."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "DataHubActionSourceClass"]) -> None:
        self._inner_dict['source'] = value
    
    
class DataHubActionRequestSourceClass(object):
    # No docs available.
    
    SYSTEM = "SYSTEM"
    """A system internal source, e.g. for running search indexing operations, feature computation, etc."""
    
    
    
class DataHubActionSourceClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.action.DataHubActionSource")
    def __init__(self,
        type: Union[str, "DataHubActionRequestSourceClass"],
    ):
        super().__init__()
        
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.type = DataHubActionRequestSourceClass.SYSTEM
    
    
    @property
    def type(self) -> Union[str, "DataHubActionRequestSourceClass"]:
        """The source type of the ingestion source"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DataHubActionRequestSourceClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class DataHubActionStageStatusClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.action.DataHubActionStageStatus")
    def __init__(self,
        reportedTime: "AuditStampClass",
        statusCode: Union[str, "DataHubActionStageStatusCodeClass"],
        startTime: int,
        endTime: Union[None, int]=None,
        lastSuccess: Union[None, int]=None,
        report: Union[None, str]=None,
        structuredReport: Union[None, "StructuredExecutionReportClass"]=None,
        customProperties: Optional[Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.reportedTime = reportedTime
        self.statusCode = statusCode
        self.startTime = startTime
        self.endTime = endTime
        self.lastSuccess = lastSuccess
        self.report = report
        self.structuredReport = structuredReport
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
    
    def _restore_defaults(self) -> None:
        self.reportedTime = AuditStampClass._construct_with_defaults()
        self.statusCode = DataHubActionStageStatusCodeClass.RUNNING
        self.startTime = int()
        self.endTime = self.RECORD_SCHEMA.fields_dict["endTime"].default
        self.lastSuccess = self.RECORD_SCHEMA.fields_dict["lastSuccess"].default
        self.report = self.RECORD_SCHEMA.fields_dict["report"].default
        self.structuredReport = self.RECORD_SCHEMA.fields_dict["structuredReport"].default
        self.customProperties = dict()
    
    
    @property
    def reportedTime(self) -> "AuditStampClass":
        """The time and source of the last update to the status"""
        return self._inner_dict.get('reportedTime')  # type: ignore
    
    @reportedTime.setter
    def reportedTime(self, value: "AuditStampClass") -> None:
        self._inner_dict['reportedTime'] = value
    
    
    @property
    def statusCode(self) -> Union[str, "DataHubActionStageStatusCodeClass"]:
        """The status of the stage"""
        return self._inner_dict.get('statusCode')  # type: ignore
    
    @statusCode.setter
    def statusCode(self, value: Union[str, "DataHubActionStageStatusCodeClass"]) -> None:
        self._inner_dict['statusCode'] = value
    
    
    @property
    def startTime(self) -> int:
        """The time the most recent invocation of the stage was started"""
        return self._inner_dict.get('startTime')  # type: ignore
    
    @startTime.setter
    def startTime(self, value: int) -> None:
        self._inner_dict['startTime'] = value
    
    
    @property
    def endTime(self) -> Union[None, int]:
        """The time the most recent invocation of the stage completed (either
    successfully or unsuccessfully)
    In the case of a running stage, this field should be null"""
        return self._inner_dict.get('endTime')  # type: ignore
    
    @endTime.setter
    def endTime(self, value: Union[None, int]) -> None:
        self._inner_dict['endTime'] = value
    
    
    @property
    def lastSuccess(self) -> Union[None, int]:
        """The time the most recent invocation of the stage was successful"""
        return self._inner_dict.get('lastSuccess')  # type: ignore
    
    @lastSuccess.setter
    def lastSuccess(self, value: Union[None, int]) -> None:
        self._inner_dict['lastSuccess'] = value
    
    
    @property
    def report(self) -> Union[None, str]:
        """Logs from the action stage."""
        return self._inner_dict.get('report')  # type: ignore
    
    @report.setter
    def report(self, value: Union[None, str]) -> None:
        self._inner_dict['report'] = value
    
    
    @property
    def structuredReport(self) -> Union[None, "StructuredExecutionReportClass"]:
        """A structured report."""
        return self._inner_dict.get('structuredReport')  # type: ignore
    
    @structuredReport.setter
    def structuredReport(self, value: Union[None, "StructuredExecutionReportClass"]) -> None:
        self._inner_dict['structuredReport'] = value
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Additional properties for the pipeline status"""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
class DataHubActionStageStatusCodeClass(object):
    """Captures the various status codes for different stages of a DataHub Action Pipeline"""
    
    RUNNING = "RUNNING"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    STOPPED = "STOPPED"
    CANCELLED = "CANCELLED"
    
    
class DataHubActionStateClass(object):
    # No docs available.
    
    ACTIVE = "ACTIVE"
    """The action is supposed to be active"""
    
    INACTIVE = "INACTIVE"
    """The action should be inactive"""
    
    
    
class DataHubActionStatusClass(_Aspect):
    """Status about a DataHub Action Pipeline
    This combines status from all the three stages of the pipeline - bootstrap, live and rollback"""


    ASPECT_NAME = 'dataHubActionStatus'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.action.DataHubActionStatus")

    def __init__(self,
        bootstrap: Union[None, "DataHubActionStageStatusClass"]=None,
        live: Union[None, "DataHubActionStageStatusClass"]=None,
        rollback: Union[None, "DataHubActionStageStatusClass"]=None,
    ):
        super().__init__()
        
        self.bootstrap = bootstrap
        self.live = live
        self.rollback = rollback
    
    def _restore_defaults(self) -> None:
        self.bootstrap = self.RECORD_SCHEMA.fields_dict["bootstrap"].default
        self.live = self.RECORD_SCHEMA.fields_dict["live"].default
        self.rollback = self.RECORD_SCHEMA.fields_dict["rollback"].default
    
    
    @property
    def bootstrap(self) -> Union[None, "DataHubActionStageStatusClass"]:
        """Status of the bootstrap pipeline if applicable"""
        return self._inner_dict.get('bootstrap')  # type: ignore
    
    @bootstrap.setter
    def bootstrap(self, value: Union[None, "DataHubActionStageStatusClass"]) -> None:
        self._inner_dict['bootstrap'] = value
    
    
    @property
    def live(self) -> Union[None, "DataHubActionStageStatusClass"]:
        """Status of the live pipeline"""
        return self._inner_dict.get('live')  # type: ignore
    
    @live.setter
    def live(self, value: Union[None, "DataHubActionStageStatusClass"]) -> None:
        self._inner_dict['live'] = value
    
    
    @property
    def rollback(self) -> Union[None, "DataHubActionStageStatusClass"]:
        """Status of the rollback pipeline if applicable"""
        return self._inner_dict.get('rollback')  # type: ignore
    
    @rollback.setter
    def rollback(self, value: Union[None, "DataHubActionStageStatusClass"]) -> None:
        self._inner_dict['rollback'] = value
    
    
class ActionRequestArchivedClass(_Aspect):
    """Stores the archival status of an Action Request"""


    ASPECT_NAME = 'actionRequestArchived'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.ActionRequestArchived")

    def __init__(self,
        lastModified: "AuditStampClass",
        archived: Optional[bool]=None,
    ):
        super().__init__()
        
        if archived is None:
            # default: False
            self.archived = self.RECORD_SCHEMA.fields_dict["archived"].default
        else:
            self.archived = archived
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.archived = self.RECORD_SCHEMA.fields_dict["archived"].default
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def archived(self) -> bool:
        """Status of the action request."""
        return self._inner_dict.get('archived')  # type: ignore
    
    @archived.setter
    def archived(self, value: bool) -> None:
        self._inner_dict['archived'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp containing who last modified the archival status and when."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class ActionRequestInfoClass(_Aspect):
    """The status of the action request - e.g. accepted, rejected, pending, etc"""


    ASPECT_NAME = 'actionRequestInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.ActionRequestInfo")

    def __init__(self,
        type: str,
        assignedUsers: List[str],
        assignedGroups: List[str],
        created: int,
        createdBy: str,
        assignedRoles: Union[None, List[str]]=None,
        resourceType: Union[None, str]=None,
        resource: Union[None, str]=None,
        subResourceType: Union[None, str]=None,
        subResource: Union[None, str]=None,
        params: Union[None, "ActionRequestParamsClass"]=None,
        description: Union[None, str]=None,
        dueDate: Union[None, int]=None,
        origin: Optional[Union[Union[str, "ActionRequestOriginClass"], None]]=None,
        inferenceMetadata: Union[None, "InferenceMetadataClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.assignedUsers = assignedUsers
        self.assignedGroups = assignedGroups
        self.assignedRoles = assignedRoles
        self.resourceType = resourceType
        self.resource = resource
        self.subResourceType = subResourceType
        self.subResource = subResource
        self.params = params
        self.created = created
        self.createdBy = createdBy
        self.description = description
        self.dueDate = dueDate
        if origin is None:
            # default: 'MANUAL'
            self.origin = self.RECORD_SCHEMA.fields_dict["origin"].default
        else:
            self.origin = origin
        self.inferenceMetadata = inferenceMetadata
    
    def _restore_defaults(self) -> None:
        self.type = str()
        self.assignedUsers = list()
        self.assignedGroups = list()
        self.assignedRoles = self.RECORD_SCHEMA.fields_dict["assignedRoles"].default
        self.resourceType = self.RECORD_SCHEMA.fields_dict["resourceType"].default
        self.resource = self.RECORD_SCHEMA.fields_dict["resource"].default
        self.subResourceType = self.RECORD_SCHEMA.fields_dict["subResourceType"].default
        self.subResource = self.RECORD_SCHEMA.fields_dict["subResource"].default
        self.params = self.RECORD_SCHEMA.fields_dict["params"].default
        self.created = int()
        self.createdBy = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.dueDate = self.RECORD_SCHEMA.fields_dict["dueDate"].default
        self.origin = self.RECORD_SCHEMA.fields_dict["origin"].default
        self.inferenceMetadata = self.RECORD_SCHEMA.fields_dict["inferenceMetadata"].default
    
    
    @property
    def type(self) -> str:
        """The type of the action request, for example 'TAG_ASSOCIATION', 'WORKFLOW_FORM_REQUEST'"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def assignedUsers(self) -> List[str]:
        """The users this action request is assigned to.
    By default, action requests are assigned to Dataset Owners
    and with anyone who has the View Proposals platform privilege."""
        return self._inner_dict.get('assignedUsers')  # type: ignore
    
    @assignedUsers.setter
    def assignedUsers(self, value: List[str]) -> None:
        self._inner_dict['assignedUsers'] = value
    
    
    @property
    def assignedGroups(self) -> List[str]:
        """The groups this action request is assigned to
    By default, action requests are assigned to Dataset Owners
    and with anyone who has the View Proposals platform privilege."""
        return self._inner_dict.get('assignedGroups')  # type: ignore
    
    @assignedGroups.setter
    def assignedGroups(self, value: List[str]) -> None:
        self._inner_dict['assignedGroups'] = value
    
    
    @property
    def assignedRoles(self) -> Union[None, List[str]]:
        """The roles this action request is assigned to
    By default, action requests are assigned any roles that have the View Proposals platform privilege."""
        return self._inner_dict.get('assignedRoles')  # type: ignore
    
    @assignedRoles.setter
    def assignedRoles(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['assignedRoles'] = value
    
    
    @property
    def resourceType(self) -> Union[None, str]:
        """The resource type that the action is associated with, for example 'dataset'"""
        return self._inner_dict.get('resourceType')  # type: ignore
    
    @resourceType.setter
    def resourceType(self, value: Union[None, str]) -> None:
        self._inner_dict['resourceType'] = value
    
    
    @property
    def resource(self) -> Union[None, str]:
        """The resource identifier that the action is associated with, for example 'urn:li:dataset:...'"""
        return self._inner_dict.get('resource')  # type: ignore
    
    @resource.setter
    def resource(self, value: Union[None, str]) -> None:
        self._inner_dict['resource'] = value
    
    
    @property
    def subResourceType(self) -> Union[None, str]:
        """The sub resource type that the action is associated with, for example 'datasetField'"""
        return self._inner_dict.get('subResourceType')  # type: ignore
    
    @subResourceType.setter
    def subResourceType(self, value: Union[None, str]) -> None:
        self._inner_dict['subResourceType'] = value
    
    
    @property
    def subResource(self) -> Union[None, str]:
        """The sub-resource identifier that the action is associated with, for example 'fieldName'.
    Currently, this is only used for Field Paths & schema fields."""
        return self._inner_dict.get('subResource')  # type: ignore
    
    @subResource.setter
    def subResource(self, value: Union[None, str]) -> None:
        self._inner_dict['subResource'] = value
    
    
    @property
    def params(self) -> Union[None, "ActionRequestParamsClass"]:
        """Parameters specific for a particular Action Request type"""
        return self._inner_dict.get('params')  # type: ignore
    
    @params.setter
    def params(self, value: Union[None, "ActionRequestParamsClass"]) -> None:
        self._inner_dict['params'] = value
    
    
    @property
    def created(self) -> int:
        """The time at which the request was initially created"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: int) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def createdBy(self) -> str:
        """Who the action request was created by"""
        return self._inner_dict.get('createdBy')  # type: ignore
    
    @createdBy.setter
    def createdBy(self, value: str) -> None:
        self._inner_dict['createdBy'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """An optional description that can be added to the action request
    to explain the intention behind it."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def dueDate(self) -> Union[None, int]:
        """The time at which the request is due"""
        return self._inner_dict.get('dueDate')  # type: ignore
    
    @dueDate.setter
    def dueDate(self, value: Union[None, int]) -> None:
        self._inner_dict['dueDate'] = value
    
    
    @property
    def origin(self) -> Union[Union[str, "ActionRequestOriginClass"], None]:
        """The origin of the action request"""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: Union[Union[str, "ActionRequestOriginClass"], None]) -> None:
        self._inner_dict['origin'] = value
    
    
    @property
    def inferenceMetadata(self) -> Union[None, "InferenceMetadataClass"]:
        """Additional inference metadata. Optionally provided if the origin is INFERRED."""
        return self._inner_dict.get('inferenceMetadata')  # type: ignore
    
    @inferenceMetadata.setter
    def inferenceMetadata(self, value: Union[None, "InferenceMetadataClass"]) -> None:
        self._inner_dict['inferenceMetadata'] = value
    
    
class ActionRequestOriginClass(object):
    """The origin type of an Action Request"""
    
    MANUAL = "MANUAL"
    """The Action Request was created by the user or group via the API or UI"""
    
    INFERRED = "INFERRED"
    """The Action Request was inferred by an inference pipeline, e.g. DataHub AI."""
    
    
    
class ActionRequestParamsClass(DictWrapper):
    """Parameters provided with a particular action request. Only one of the fields will be populated,
    depending on the action request type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.ActionRequestParams")
    def __init__(self,
        glossaryTermProposal: Union[None, "GlossaryTermProposalClass"]=None,
        tagProposal: Union[None, "TagProposalClass"]=None,
        domainProposal: Union[None, "DomainProposalClass"]=None,
        ownerProposal: Union[None, "OwnerProposalClass"]=None,
        structuredPropertyProposal: Union[None, "StructuredPropertyProposalClass"]=None,
        createGlossaryTermProposal: Union[None, "CreateGlossaryTermProposalClass"]=None,
        createGlossaryNodeProposal: Union[None, "CreateGlossaryNodeProposalClass"]=None,
        updateDescriptionProposal: Union[None, "DescriptionProposalClass"]=None,
        dataContractProposal: Union[None, "DataContractProposalClass"]=None,
        workflowFormRequest: Union[None, "ActionWorkflowFormRequestClass"]=None,
    ):
        super().__init__()
        
        self.glossaryTermProposal = glossaryTermProposal
        self.tagProposal = tagProposal
        self.domainProposal = domainProposal
        self.ownerProposal = ownerProposal
        self.structuredPropertyProposal = structuredPropertyProposal
        self.createGlossaryTermProposal = createGlossaryTermProposal
        self.createGlossaryNodeProposal = createGlossaryNodeProposal
        self.updateDescriptionProposal = updateDescriptionProposal
        self.dataContractProposal = dataContractProposal
        self.workflowFormRequest = workflowFormRequest
    
    def _restore_defaults(self) -> None:
        self.glossaryTermProposal = self.RECORD_SCHEMA.fields_dict["glossaryTermProposal"].default
        self.tagProposal = self.RECORD_SCHEMA.fields_dict["tagProposal"].default
        self.domainProposal = self.RECORD_SCHEMA.fields_dict["domainProposal"].default
        self.ownerProposal = self.RECORD_SCHEMA.fields_dict["ownerProposal"].default
        self.structuredPropertyProposal = self.RECORD_SCHEMA.fields_dict["structuredPropertyProposal"].default
        self.createGlossaryTermProposal = self.RECORD_SCHEMA.fields_dict["createGlossaryTermProposal"].default
        self.createGlossaryNodeProposal = self.RECORD_SCHEMA.fields_dict["createGlossaryNodeProposal"].default
        self.updateDescriptionProposal = self.RECORD_SCHEMA.fields_dict["updateDescriptionProposal"].default
        self.dataContractProposal = self.RECORD_SCHEMA.fields_dict["dataContractProposal"].default
        self.workflowFormRequest = self.RECORD_SCHEMA.fields_dict["workflowFormRequest"].default
    
    
    @property
    def glossaryTermProposal(self) -> Union[None, "GlossaryTermProposalClass"]:
        """An optional set of information specific to term proposals.
    TODO: Add validation that ensures that glossaryTerm or glossaryTerms field is provided, but not both."""
        return self._inner_dict.get('glossaryTermProposal')  # type: ignore
    
    @glossaryTermProposal.setter
    def glossaryTermProposal(self, value: Union[None, "GlossaryTermProposalClass"]) -> None:
        self._inner_dict['glossaryTermProposal'] = value
    
    
    @property
    def tagProposal(self) -> Union[None, "TagProposalClass"]:
        """An optional set of information specific to tag proposals.
    TODO: Add validation that ensures that tag or tagUrns field is provided, but not both."""
        return self._inner_dict.get('tagProposal')  # type: ignore
    
    @tagProposal.setter
    def tagProposal(self, value: Union[None, "TagProposalClass"]) -> None:
        self._inner_dict['tagProposal'] = value
    
    
    @property
    def domainProposal(self) -> Union[None, "DomainProposalClass"]:
        """An optional set of information specific to domain proposals."""
        return self._inner_dict.get('domainProposal')  # type: ignore
    
    @domainProposal.setter
    def domainProposal(self, value: Union[None, "DomainProposalClass"]) -> None:
        self._inner_dict['domainProposal'] = value
    
    
    @property
    def ownerProposal(self) -> Union[None, "OwnerProposalClass"]:
        """An optional set of information specific to ownership proposals."""
        return self._inner_dict.get('ownerProposal')  # type: ignore
    
    @ownerProposal.setter
    def ownerProposal(self, value: Union[None, "OwnerProposalClass"]) -> None:
        self._inner_dict['ownerProposal'] = value
    
    
    @property
    def structuredPropertyProposal(self) -> Union[None, "StructuredPropertyProposalClass"]:
        """An optional set of information specific to structured property proposals."""
        return self._inner_dict.get('structuredPropertyProposal')  # type: ignore
    
    @structuredPropertyProposal.setter
    def structuredPropertyProposal(self, value: Union[None, "StructuredPropertyProposalClass"]) -> None:
        self._inner_dict['structuredPropertyProposal'] = value
    
    
    @property
    def createGlossaryTermProposal(self) -> Union[None, "CreateGlossaryTermProposalClass"]:
        """An optional set of information specific to proposals for creating new Glossary Terms."""
        return self._inner_dict.get('createGlossaryTermProposal')  # type: ignore
    
    @createGlossaryTermProposal.setter
    def createGlossaryTermProposal(self, value: Union[None, "CreateGlossaryTermProposalClass"]) -> None:
        self._inner_dict['createGlossaryTermProposal'] = value
    
    
    @property
    def createGlossaryNodeProposal(self) -> Union[None, "CreateGlossaryNodeProposalClass"]:
        """An optional set of information specific to proposals for creating new Glossary Nodes."""
        return self._inner_dict.get('createGlossaryNodeProposal')  # type: ignore
    
    @createGlossaryNodeProposal.setter
    def createGlossaryNodeProposal(self, value: Union[None, "CreateGlossaryNodeProposalClass"]) -> None:
        self._inner_dict['createGlossaryNodeProposal'] = value
    
    
    @property
    def updateDescriptionProposal(self) -> Union[None, "DescriptionProposalClass"]:
        """An optional set of information specific to proposals for updating Descriptions."""
        return self._inner_dict.get('updateDescriptionProposal')  # type: ignore
    
    @updateDescriptionProposal.setter
    def updateDescriptionProposal(self, value: Union[None, "DescriptionProposalClass"]) -> None:
        self._inner_dict['updateDescriptionProposal'] = value
    
    
    @property
    def dataContractProposal(self) -> Union[None, "DataContractProposalClass"]:
        """A proposal to create or modify a Data Contract"""
        return self._inner_dict.get('dataContractProposal')  # type: ignore
    
    @dataContractProposal.setter
    def dataContractProposal(self, value: Union[None, "DataContractProposalClass"]) -> None:
        self._inner_dict['dataContractProposal'] = value
    
    
    @property
    def workflowFormRequest(self) -> Union[None, "ActionWorkflowFormRequestClass"]:
        """An action workflow form request."""
        return self._inner_dict.get('workflowFormRequest')  # type: ignore
    
    @workflowFormRequest.setter
    def workflowFormRequest(self, value: Union[None, "ActionWorkflowFormRequestClass"]) -> None:
        self._inner_dict['workflowFormRequest'] = value
    
    
class ActionRequestStatusClass(_Aspect):
    """The status of the action request - e.g. accepted, rejected, pending, etc"""


    ASPECT_NAME = 'actionRequestStatus'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.ActionRequestStatus")

    def __init__(self,
        status: str,
        lastModified: "AuditStampClass",
        result: Union[None, str]=None,
        note: Union[None, str]=None,
    ):
        super().__init__()
        
        self.status = status
        self.result = result
        self.note = note
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.status = str()
        self.result = self.RECORD_SCHEMA.fields_dict["result"].default
        self.note = self.RECORD_SCHEMA.fields_dict["note"].default
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def status(self) -> str:
        """Status of the action request. e.g. PENDING / COMPLETED"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: str) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def result(self) -> Union[None, str]:
        """Optional result of the action request, e.g. APPROVE or DENY in case of request approvals."""
        return self._inner_dict.get('result')  # type: ignore
    
    @result.setter
    def result(self, value: Union[None, str]) -> None:
        self._inner_dict['result'] = value
    
    
    @property
    def note(self) -> Union[None, str]:
        """Optional note associated with the status.
    E.g. if the request is rejected, the reason for rejection. If the request is approved, the reason for approval."""
        return self._inner_dict.get('note')  # type: ignore
    
    @note.setter
    def note(self, value: Union[None, str]) -> None:
        self._inner_dict['note'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp containing who last modified the status and when."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class CreateGlossaryNodeProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.CreateGlossaryNodeProposal")
    def __init__(self,
        name: str,
        parentNode: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.parentNode = parentNode
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.parentNode = self.RECORD_SCHEMA.fields_dict["parentNode"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def name(self) -> str:
        """Name of the proposed Glossary Node"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def parentNode(self) -> Union[None, str]:
        """The urn of the parent node of the Proposed Node"""
        return self._inner_dict.get('parentNode')  # type: ignore
    
    @parentNode.setter
    def parentNode(self, value: Union[None, str]) -> None:
        self._inner_dict['parentNode'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """The description of the Proposed Node"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class CreateGlossaryTermProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.CreateGlossaryTermProposal")
    def __init__(self,
        name: str,
        parentNode: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.parentNode = parentNode
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.parentNode = self.RECORD_SCHEMA.fields_dict["parentNode"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def name(self) -> str:
        """Name of the proposed Glossary Term"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def parentNode(self) -> Union[None, str]:
        """The urn of the parent node of the Proposed Term"""
        return self._inner_dict.get('parentNode')  # type: ignore
    
    @parentNode.setter
    def parentNode(self, value: Union[None, str]) -> None:
        self._inner_dict['parentNode'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """The description of the Proposed Term"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class DataContractProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.DataContractProposal")
    def __init__(self,
        type: Optional[Union[Union[str, "DataContractProposalOperationTypeClass"], None]]=None,
        schema: Union[None, List["SchemaContractClass"]]=None,
        freshness: Union[None, List["FreshnessContractClass"]]=None,
        dataQuality: Union[None, List["DataQualityContractClass"]]=None,
    ):
        super().__init__()
        
        if type is None:
            # default: 'OVERWRITE'
            self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        else:
            self.type = type
        self.schema = schema
        self.freshness = freshness
        self.dataQuality = dataQuality
    
    def _restore_defaults(self) -> None:
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        self.schema = self.RECORD_SCHEMA.fields_dict["schema"].default
        self.freshness = self.RECORD_SCHEMA.fields_dict["freshness"].default
        self.dataQuality = self.RECORD_SCHEMA.fields_dict["dataQuality"].default
    
    
    @property
    def type(self) -> Union[Union[str, "DataContractProposalOperationTypeClass"], None]:
        """How to apply the Data Contract"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[Union[str, "DataContractProposalOperationTypeClass"], None]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def schema(self) -> Union[None, List["SchemaContractClass"]]:
        """An optional set of schema contracts. If this is a dataset contract, there will only be one."""
        return self._inner_dict.get('schema')  # type: ignore
    
    @schema.setter
    def schema(self, value: Union[None, List["SchemaContractClass"]]) -> None:
        self._inner_dict['schema'] = value
    
    
    @property
    def freshness(self) -> Union[None, List["FreshnessContractClass"]]:
        """An optional set of Freshness contracts. If this is a dataset contract, there will only be one."""
        return self._inner_dict.get('freshness')  # type: ignore
    
    @freshness.setter
    def freshness(self, value: Union[None, List["FreshnessContractClass"]]) -> None:
        self._inner_dict['freshness'] = value
    
    
    @property
    def dataQuality(self) -> Union[None, List["DataQualityContractClass"]]:
        """An optional set of Data Quality contracts, e.g. table and column level contract constraints."""
        return self._inner_dict.get('dataQuality')  # type: ignore
    
    @dataQuality.setter
    def dataQuality(self, value: Union[None, List["DataQualityContractClass"]]) -> None:
        self._inner_dict['dataQuality'] = value
    
    
class DataContractProposalOperationTypeClass(object):
    # No docs available.
    
    ADD = "ADD"
    """Add contracts to existing contract"""
    
    OVERWRITE = "OVERWRITE"
    """Overwrite the contract in its entirety"""
    
    
    
class DescriptionProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.DescriptionProposal")
    def __init__(self,
        description: str,
    ):
        super().__init__()
        
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.description = str()
    
    
    @property
    def description(self) -> str:
        """The text of the description."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: str) -> None:
        self._inner_dict['description'] = value
    
    
class DomainProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.DomainProposal")
    def __init__(self,
        domains: List[str],
    ):
        super().__init__()
        
        self.domains = domains
    
    def _restore_defaults(self) -> None:
        self.domains = list()
    
    
    @property
    def domains(self) -> List[str]:
        """The urns of the domain(s) being proposed. Currently, only 1 domain is supported per asset.
    If this changes in the future, this data modeling will suffice."""
        return self._inner_dict.get('domains')  # type: ignore
    
    @domains.setter
    def domains(self, value: List[str]) -> None:
        self._inner_dict['domains'] = value
    
    
class GlossaryTermProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.GlossaryTermProposal")
    def __init__(self,
        glossaryTerm: Union[None, str]=None,
        glossaryTerms: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.glossaryTerm = glossaryTerm
        self.glossaryTerms = glossaryTerms
    
    def _restore_defaults(self) -> None:
        self.glossaryTerm = self.RECORD_SCHEMA.fields_dict["glossaryTerm"].default
        self.glossaryTerms = self.RECORD_SCHEMA.fields_dict["glossaryTerms"].default
    
    
    @property
    def glossaryTerm(self) -> Union[None, str]:
        """This field is deprecated and will be removed in a future version. Use glossaryTerms instead.
    The urn of the glossary term being proposed."""
        return self._inner_dict.get('glossaryTerm')  # type: ignore
    
    @glossaryTerm.setter
    def glossaryTerm(self, value: Union[None, str]) -> None:
        self._inner_dict['glossaryTerm'] = value
    
    
    @property
    def glossaryTerms(self) -> Union[None, List[str]]:
        """The urns of the glossary terms being proposed.
    Use this field over glossaryTerm."""
        return self._inner_dict.get('glossaryTerms')  # type: ignore
    
    @glossaryTerms.setter
    def glossaryTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['glossaryTerms'] = value
    
    
class OwnerProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.OwnerProposal")
    def __init__(self,
        owners: Union[None, List["OwnerClass"]]=None,
    ):
        super().__init__()
        
        self.owners = owners
    
    def _restore_defaults(self) -> None:
        self.owners = self.RECORD_SCHEMA.fields_dict["owners"].default
    
    
    @property
    def owners(self) -> Union[None, List["OwnerClass"]]:
        """The urns of the owner(s) being proposed."""
        return self._inner_dict.get('owners')  # type: ignore
    
    @owners.setter
    def owners(self, value: Union[None, List["OwnerClass"]]) -> None:
        self._inner_dict['owners'] = value
    
    
class StructuredPropertyProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.StructuredPropertyProposal")
    def __init__(self,
        structuredPropertyValues: Union[None, List["StructuredPropertyValueAssignmentClass"]]=None,
    ):
        super().__init__()
        
        self.structuredPropertyValues = structuredPropertyValues
    
    def _restore_defaults(self) -> None:
        self.structuredPropertyValues = self.RECORD_SCHEMA.fields_dict["structuredPropertyValues"].default
    
    
    @property
    def structuredPropertyValues(self) -> Union[None, List["StructuredPropertyValueAssignmentClass"]]:
        """The urns of the domain(s) being proposed. Currently, only 1 domain is supported per asset.
    If this changes in the future, the data model will be ready.
    TODO: Decide if indexing the value would also be useful."""
        return self._inner_dict.get('structuredPropertyValues')  # type: ignore
    
    @structuredPropertyValues.setter
    def structuredPropertyValues(self, value: Union[None, List["StructuredPropertyValueAssignmentClass"]]) -> None:
        self._inner_dict['structuredPropertyValues'] = value
    
    
class TagProposalClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionrequest.TagProposal")
    def __init__(self,
        tag: Union[None, str]=None,
        tags: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.tag = tag
        self.tags = tags
    
    def _restore_defaults(self) -> None:
        self.tag = self.RECORD_SCHEMA.fields_dict["tag"].default
        self.tags = self.RECORD_SCHEMA.fields_dict["tags"].default
    
    
    @property
    def tag(self) -> Union[None, str]:
        """This field is deprecated and will be removed in a future version. Use tags instead.
    The urn of the tag being proposed."""
        return self._inner_dict.get('tag')  # type: ignore
    
    @tag.setter
    def tag(self, value: Union[None, str]) -> None:
        self._inner_dict['tag'] = value
    
    
    @property
    def tags(self) -> Union[None, List[str]]:
        """The urns of the glossary terms being proposed.
    Use this field over glossaryTerm."""
        return self._inner_dict.get('tags')  # type: ignore
    
    @tags.setter
    def tags(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['tags'] = value
    
    
class ActionWorkflowCategoryClass(object):
    # No docs available.
    
    ACCESS = "ACCESS"
    """Workflow for requesting access to a resource, such as a dataset or data job.
    Requires the `access` field to be populated with specific access parameters."""
    
    CUSTOM = "CUSTOM"
    """Custom, non-access related workflow. For example, may be used to model workflows like
    asset creation, asset cleanup or deletion, etc."""
    
    
    
class ActionWorkflowEntrypointClass(DictWrapper):
    """The entry point arguments for the action request workflowform.
    In the future, we may extend this model to support more granular entry point filters."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowEntrypoint")
    def __init__(self,
        type: Union[str, "ActionWorkflowEntrypointTypeClass"],
        label: str,
        filter: Union[None, "FilterClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.label = label
        self.filter = filter
    
    def _restore_defaults(self) -> None:
        self.type = ActionWorkflowEntrypointTypeClass.HOME
        self.label = str()
        self.filter = self.RECORD_SCHEMA.fields_dict["filter"].default
    
    
    @property
    def type(self) -> Union[str, "ActionWorkflowEntrypointTypeClass"]:
        """The type of entry point for the action request workflow.
    This determines where the action request workflow will be displayed."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "ActionWorkflowEntrypointTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def label(self) -> str:
        """The label for the entry point, which is displayed to users.
    This should be a user-friendly name that describes the action request."""
        return self._inner_dict.get('label')  # type: ignore
    
    @label.setter
    def label(self, value: str) -> None:
        self._inner_dict['label'] = value
    
    
    @property
    def filter(self) -> Union[None, "FilterClass"]:
        """Additional filter criteria to determine when the entry point should be displayed.
    
    Not yet supported (but will be in the future)."""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: Union[None, "FilterClass"]) -> None:
        self._inner_dict['filter'] = value
    
    
class ActionWorkflowEntrypointTypeClass(object):
    # No docs available.
    
    HOME = "HOME"
    """ Visible on the home page to all users. """
    
    ENTITY_PROFILE = "ENTITY_PROFILE"
    """ Visible on the entity profile page. For all valid entity types specified in the parent object. """
    
    
    
class ActionWorkflowFieldClass(DictWrapper):
    """A field inside an Action Workflow Form."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowField")
    def __init__(self,
        id: str,
        name: str,
        valueType: str,
        cardinality: Union[str, "PropertyCardinalityClass"],
        description: Union[None, str]=None,
        allowedEntityTypes: Union[None, List[str]]=None,
        allowedValues: Union[None, List["PropertyValueClass"]]=None,
        required: Optional[bool]=None,
        condition: Union[None, "ActionWorkflowFieldConditionClass"]=None,
    ):
        super().__init__()
        
        self.id = id
        self.name = name
        self.description = description
        self.valueType = valueType
        self.allowedEntityTypes = allowedEntityTypes
        self.allowedValues = allowedValues
        self.cardinality = cardinality
        if required is None:
            # default: False
            self.required = self.RECORD_SCHEMA.fields_dict["required"].default
        else:
            self.required = required
        self.condition = condition
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.valueType = str()
        self.allowedEntityTypes = self.RECORD_SCHEMA.fields_dict["allowedEntityTypes"].default
        self.allowedValues = self.RECORD_SCHEMA.fields_dict["allowedValues"].default
        self.cardinality = PropertyCardinalityClass.SINGLE
        self.required = self.RECORD_SCHEMA.fields_dict["required"].default
        self.condition = self.RECORD_SCHEMA.fields_dict["condition"].default
    
    
    @property
    def id(self) -> str:
        """Workflow-local id for the field"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def name(self) -> str:
        """The display name or label for the field, for rendering"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """The description for the field, for rendering"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def valueType(self) -> str:
        """The urn of the value type for the values - reused from structured properties.
    Also, used for rendering"""
        return self._inner_dict.get('valueType')  # type: ignore
    
    @valueType.setter
    def valueType(self, value: str) -> None:
        self._inner_dict['valueType'] = value
    
    
    @property
    def allowedEntityTypes(self) -> Union[None, List[str]]:
        """The urns for allowed entity types."""
        return self._inner_dict.get('allowedEntityTypes')  # type: ignore
    
    @allowedEntityTypes.setter
    def allowedEntityTypes(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['allowedEntityTypes'] = value
    
    
    @property
    def allowedValues(self) -> Union[None, List["PropertyValueClass"]]:
        """A list of allowed values that the property is allowed to take.
    If this is not specified, then the property can take any value of given type."""
        return self._inner_dict.get('allowedValues')  # type: ignore
    
    @allowedValues.setter
    def allowedValues(self, value: Union[None, List["PropertyValueClass"]]) -> None:
        self._inner_dict['allowedValues'] = value
    
    
    @property
    def cardinality(self) -> Union[str, "PropertyCardinalityClass"]:
        """Whether or not multiple values are allowed."""
        return self._inner_dict.get('cardinality')  # type: ignore
    
    @cardinality.setter
    def cardinality(self, value: Union[str, "PropertyCardinalityClass"]) -> None:
        self._inner_dict['cardinality'] = value
    
    
    @property
    def required(self) -> bool:
        """Whether the field is required or not."""
        return self._inner_dict.get('required')  # type: ignore
    
    @required.setter
    def required(self, value: bool) -> None:
        self._inner_dict['required'] = value
    
    
    @property
    def condition(self) -> Union[None, "ActionWorkflowFieldConditionClass"]:
        """A dynamic condition that determines whether the field should be shown or not."""
        return self._inner_dict.get('condition')  # type: ignore
    
    @condition.setter
    def condition(self, value: Union[None, "ActionWorkflowFieldConditionClass"]) -> None:
        self._inner_dict['condition'] = value
    
    
class ActionWorkflowFieldConditionClass(DictWrapper):
    """A condition that determines whether a form field should be shown in the action workflow.
    This may evolve in the future to have additional condition types."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowFieldCondition")
    def __init__(self,
        type: Union[str, "ActionWorkflowFieldConditionTypeClass"],
        singleFieldValueCondition: Union[None, "ActionWorkflowSingleFieldValueConditionClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.singleFieldValueCondition = singleFieldValueCondition
    
    def _restore_defaults(self) -> None:
        self.type = ActionWorkflowFieldConditionTypeClass.SINGLE_FIELD_VALUE
        self.singleFieldValueCondition = self.RECORD_SCHEMA.fields_dict["singleFieldValueCondition"].default
    
    
    @property
    def type(self) -> Union[str, "ActionWorkflowFieldConditionTypeClass"]:
        """The type of field condition"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "ActionWorkflowFieldConditionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def singleFieldValueCondition(self) -> Union[None, "ActionWorkflowSingleFieldValueConditionClass"]:
        """A field value condition. Present if type is FIELD_VALUE."""
        return self._inner_dict.get('singleFieldValueCondition')  # type: ignore
    
    @singleFieldValueCondition.setter
    def singleFieldValueCondition(self, value: Union[None, "ActionWorkflowSingleFieldValueConditionClass"]) -> None:
        self._inner_dict['singleFieldValueCondition'] = value
    
    
class ActionWorkflowFieldConditionTypeClass(object):
    # No docs available.
    
    SINGLE_FIELD_VALUE = "SINGLE_FIELD_VALUE"
    """The field should be shown if the value of a previously completed field matches the specified value."""
    
    
    
class ActionWorkflowFormClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowForm")
    def __init__(self,
        entrypoints: List["ActionWorkflowEntrypointClass"],
        fields: List["ActionWorkflowFieldClass"],
        entityTypes: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.entrypoints = entrypoints
        self.entityTypes = entityTypes
        self.fields = fields
    
    def _restore_defaults(self) -> None:
        self.entrypoints = list()
        self.entityTypes = self.RECORD_SCHEMA.fields_dict["entityTypes"].default
        self.fields = list()
    
    
    @property
    def entrypoints(self) -> List["ActionWorkflowEntrypointClass"]:
        """Entrypoints for form submission."""
        return self._inner_dict.get('entrypoints')  # type: ignore
    
    @entrypoints.setter
    def entrypoints(self, value: List["ActionWorkflowEntrypointClass"]) -> None:
        self._inner_dict['entrypoints'] = value
    
    
    @property
    def entityTypes(self) -> Union[None, List[str]]:
        """The valid entity type URNs that can be associated with a Workflow Form.
    If provided, this will require that an entity of one of the provided types is specified when completing the form.
    
    If no entity types are provided, the workflow form can be submitted without specifying an entity. In general, this should
    be populated for workflows of type ACCESS to enable users to request access to a specific entity!
    
    If specified, the associated action requests for this workflow will contain an URN of the corresponding type inside of
    the `resource` field.
    
    Note that associating multiple entities with a single Action Request is not yet supported."""
        return self._inner_dict.get('entityTypes')  # type: ignore
    
    @entityTypes.setter
    def entityTypes(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['entityTypes'] = value
    
    
    @property
    def fields(self) -> List["ActionWorkflowFieldClass"]:
        """Fields comprising the workflow request. These are the inputs / arguments required to trigger the workflow."""
        return self._inner_dict.get('fields')  # type: ignore
    
    @fields.setter
    def fields(self, value: List["ActionWorkflowFieldClass"]) -> None:
        self._inner_dict['fields'] = value
    
    
class ActionWorkflowFormRequestClass(DictWrapper):
    """A request for an access workflow form to be reviewed.
    
    For an access workflow of trigger type FORM, this action request currently represents the "state" 
    of the workflow instance. 
    
    In the future, we may add more features like due dates, escalations, etc.
    Ideally, for now we are keeping these out of here."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowFormRequest")
    def __init__(self,
        workflow: str,
        category: Union[str, "ActionWorkflowCategoryClass"],
        fields: List["ActionWorkflowFormRequestFieldClass"],
        stepState: "ActionWorkflowRequestStepStateClass",
        customCategory: Union[None, str]=None,
        access: Union[None, "ActionWorkflowRequestAccessClass"]=None,
    ):
        super().__init__()
        
        self.workflow = workflow
        self.category = category
        self.customCategory = customCategory
        self.fields = fields
        self.access = access
        self.stepState = stepState
    
    def _restore_defaults(self) -> None:
        self.workflow = str()
        self.category = ActionWorkflowCategoryClass.ACCESS
        self.customCategory = self.RECORD_SCHEMA.fields_dict["customCategory"].default
        self.fields = list()
        self.access = self.RECORD_SCHEMA.fields_dict["access"].default
        self.stepState = ActionWorkflowRequestStepStateClass._construct_with_defaults()
    
    
    @property
    def workflow(self) -> str:
        """The urn of the associated access request workflow."""
        return self._inner_dict.get('workflow')  # type: ignore
    
    @workflow.setter
    def workflow(self, value: str) -> None:
        self._inner_dict['workflow'] = value
    
    
    @property
    def category(self) -> Union[str, "ActionWorkflowCategoryClass"]:
        """The category of the workflow. 
    Primarily used for searching / filtering action requests."""
        return self._inner_dict.get('category')  # type: ignore
    
    @category.setter
    def category(self, value: Union[str, "ActionWorkflowCategoryClass"]) -> None:
        self._inner_dict['category'] = value
    
    
    @property
    def customCategory(self) -> Union[None, str]:
        """The custom category of the workflow, if category is custom.
    Primarily used for searching / filtering action requests."""
        return self._inner_dict.get('customCategory')  # type: ignore
    
    @customCategory.setter
    def customCategory(self, value: Union[None, str]) -> None:
        self._inner_dict['customCategory'] = value
    
    
    @property
    def fields(self) -> List["ActionWorkflowFormRequestFieldClass"]:
        """Custom fields provided by the user making the request if the action request is of type FORM_SUBMITTED
    Eventually, these may need to become search indexed. For now, not indexed."""
        return self._inner_dict.get('fields')  # type: ignore
    
    @fields.setter
    def fields(self, value: List["ActionWorkflowFormRequestFieldClass"]) -> None:
        self._inner_dict['fields'] = value
    
    
    @property
    def access(self) -> Union[None, "ActionWorkflowRequestAccessClass"]:
        """Details specific for access request workflow requests."""
        return self._inner_dict.get('access')  # type: ignore
    
    @access.setter
    def access(self, value: Union[None, "ActionWorkflowRequestAccessClass"]) -> None:
        self._inner_dict['access'] = value
    
    
    @property
    def stepState(self) -> "ActionWorkflowRequestStepStateClass":
        """State related to steps. This should correspond to a step of type ACTION_REQUEST_REVIEW in the workflow 
    definition."""
        return self._inner_dict.get('stepState')  # type: ignore
    
    @stepState.setter
    def stepState(self, value: "ActionWorkflowRequestStepStateClass") -> None:
        self._inner_dict['stepState'] = value
    
    
class ActionWorkflowFormRequestFieldClass(DictWrapper):
    """Simply capture the field id + the value."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowFormRequestField")
    def __init__(self,
        id: str,
        values: List[Union[str, float]],
    ):
        super().__init__()
        
        self.id = id
        self.values = values
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.values = list()
    
    
    @property
    def id(self) -> str:
        """Workflow-local id for the field"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def values(self) -> List[Union[str, float]]:
        """Value, reused model from structured properties. Empty if no response was provided."""
        return self._inner_dict.get('values')  # type: ignore
    
    @values.setter
    def values(self, value: List[Union[str, float]]) -> None:
        self._inner_dict['values'] = value
    
    
class ActionWorkflowInfoClass(_Aspect):
    """The ActionWorkflowInfo record captures the metadata and configuration of a workflow.
    TODO: In the future, we may store the serialized camunda / flowable workflow instance ID inside.
    We'll likely also need to add the "steps" into here since we'll need that to inform state transitions."""


    ASPECT_NAME = 'actionWorkflowInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowInfo")

    def __init__(self,
        name: str,
        category: Union[str, "ActionWorkflowCategoryClass"],
        trigger: "ActionWorkflowTriggerClass",
        steps: List["ActionWorkflowStepClass"],
        created: "AuditStampClass",
        lastModified: "AuditStampClass",
        customCategory: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.category = category
        self.customCategory = customCategory
        self.description = description
        self.trigger = trigger
        self.steps = steps
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.category = ActionWorkflowCategoryClass.ACCESS
        self.customCategory = self.RECORD_SCHEMA.fields_dict["customCategory"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.trigger = ActionWorkflowTriggerClass._construct_with_defaults()
        self.steps = list()
        self.created = AuditStampClass._construct_with_defaults()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def name(self) -> str:
        """Display name of the workflow"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def category(self) -> Union[str, "ActionWorkflowCategoryClass"]:
        """Top-level category of the workflow, e.g. ACCESS"""
        return self._inner_dict.get('category')  # type: ignore
    
    @category.setter
    def category(self, value: Union[str, "ActionWorkflowCategoryClass"]) -> None:
        self._inner_dict['category'] = value
    
    
    @property
    def customCategory(self) -> Union[None, str]:
        """Custom category for the workflow, if applicable.
    
    This is used to group workflows that are not part of the standard types.
    Should be provided when the type is CUSTOM."""
        return self._inner_dict.get('customCategory')  # type: ignore
    
    @customCategory.setter
    def customCategory(self, value: Union[None, str]) -> None:
        self._inner_dict['customCategory'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the workflow. 
    If this is based on a Form trigger, this will be displayed to users when completing the form. """
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def trigger(self) -> "ActionWorkflowTriggerClass":
        """The action or event that triggers the workflow. This MUST be stored here, because there is no other
    place to capture dynamic form state like this. """
        return self._inner_dict.get('trigger')  # type: ignore
    
    @trigger.setter
    def trigger(self, value: "ActionWorkflowTriggerClass") -> None:
        self._inner_dict['trigger'] = value
    
    
    @property
    def steps(self) -> List["ActionWorkflowStepClass"]:
        """Definition of the steps / tasks / nodes comprising the workflow definition. This is the part we can aim 
    to be able to convert / transform into serialized XML BPMN Format. For now, we model it strongly here. 
    If we can successfully use BPMN for step state, we can deprecate this field in place of the XML serialization. 
    
    This is the part we'll try to build a transpiler to BPMN for execution for. Ultimately, we do need 
    a representation we can easily convert into the frontend framework for display. This represents the set of 
    well known workflow step types - across tasks, conditionals, notifications, etc - that are officially supported today.
    
    If necessary, we'll extend this to represent conditional branching nodes as a step / node in the Workflow, e.g. Conditional Step, Notification Step, Review Step"""
        return self._inner_dict.get('steps')  # type: ignore
    
    @steps.setter
    def steps(self, value: List["ActionWorkflowStepClass"]) -> None:
        self._inner_dict['steps'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp capturing the time and actor who created the workflow."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp capturing the time and actor who last modified the workflow."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class ActionWorkflowRequestAccessClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowRequestAccess")
    def __init__(self,
        expiresAt: Union[None, int]=None,
    ):
        super().__init__()
        
        self.expiresAt = expiresAt
    
    def _restore_defaults(self) -> None:
        self.expiresAt = self.RECORD_SCHEMA.fields_dict["expiresAt"].default
    
    
    @property
    def expiresAt(self) -> Union[None, int]:
        """Expiration time for the action request (optional, if part of the template)."""
        return self._inner_dict.get('expiresAt')  # type: ignore
    
    @expiresAt.setter
    def expiresAt(self, value: Union[None, int]) -> None:
        self._inner_dict['expiresAt'] = value
    
    
class ActionWorkflowRequestStepStateClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowRequestStepState")
    def __init__(self,
        stepId: str,
    ):
        super().__init__()
        
        self.stepId = stepId
    
    def _restore_defaults(self) -> None:
        self.stepId = str()
    
    
    @property
    def stepId(self) -> str:
        """The id of the current step in the workflow, which should be of type ACTION_REQUEST_REVIEW."""
        return self._inner_dict.get('stepId')  # type: ignore
    
    @stepId.setter
    def stepId(self, value: str) -> None:
        self._inner_dict['stepId'] = value
    
    
class ActionWorkflowSingleFieldValueConditionClass(DictWrapper):
    """A specific type of field condition that checks whether a field should be shown based on the value of a previously completed field."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowSingleFieldValueCondition")
    def __init__(self,
        field: str,
        values: Optional[List[str]]=None,
        condition: Optional[Union[str, "ConditionClass"]]=None,
        negated: Optional[bool]=None,
    ):
        super().__init__()
        
        self.field = field
        if values is None:
            # default: []
            self.values = list()
        else:
            self.values = values
        if condition is None:
            # default: 'EQUAL'
            self.condition = self.RECORD_SCHEMA.fields_dict["condition"].default
        else:
            self.condition = condition
        if negated is None:
            # default: False
            self.negated = self.RECORD_SCHEMA.fields_dict["negated"].default
        else:
            self.negated = negated
    
    def _restore_defaults(self) -> None:
        self.field = str()
        self.values = list()
        self.condition = self.RECORD_SCHEMA.fields_dict["condition"].default
        self.negated = self.RECORD_SCHEMA.fields_dict["negated"].default
    
    
    @property
    def field(self) -> str:
        """The id / name of the field that the criterion refers to"""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: str) -> None:
        self._inner_dict['field'] = value
    
    
    @property
    def values(self) -> List[str]:
        """Values. one of which the intended field should match
    Note, if values is set, the above "value" field will be ignored"""
        return self._inner_dict.get('values')  # type: ignore
    
    @values.setter
    def values(self, value: List[str]) -> None:
        self._inner_dict['values'] = value
    
    
    @property
    def condition(self) -> Union[str, "ConditionClass"]:
        """The condition for the criterion, e.g. EQUAL, START_WITH"""
        return self._inner_dict.get('condition')  # type: ignore
    
    @condition.setter
    def condition(self, value: Union[str, "ConditionClass"]) -> None:
        self._inner_dict['condition'] = value
    
    
    @property
    def negated(self) -> bool:
        """Whether the condition should be negated"""
        return self._inner_dict.get('negated')  # type: ignore
    
    @negated.setter
    def negated(self, value: bool) -> None:
        self._inner_dict['negated'] = value
    
    
class ActionWorkflowStepClass(DictWrapper):
    """Defines a single review step in a workflow.
    
    Today, steps are simple. They execute in sequence after the trigger event. 
    
    In the future, we may extend steps to include "depends on steps" to form a DAG structure across
    steps. For now, steps execute in linear sequence after the trigger event -- however the expectation
    is that they COULD run in parallel after the trigger event without a problem in the future.
    
    If necessary, we'll extend this to represent conditional branching nodes as a step / node in the Workflow, e.g. Conditional Step, Notification Step, Review Step
    
    Today, step state is reflected via a single entity representing the workflow instance: the ActionRequest entity.
    In the future we'll explore modeling individual step states separately if required."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowStep")
    def __init__(self,
        id: str,
        type: Union[str, "ActionWorkflowStepTypeClass"],
        description: Union[None, str]=None,
        actors: Union[None, "ActionWorkflowStepActorsClass"]=None,
    ):
        super().__init__()
        
        self.id = id
        self.type = type
        self.description = description
        self.actors = actors
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.type = ActionWorkflowStepTypeClass.APPROVAL
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.actors = self.RECORD_SCHEMA.fields_dict["actors"].default
    
    
    @property
    def id(self) -> str:
        """A unique identifier for this step within the workflow.
    This ID must be unique within the workflow and is used to match values during workflow execution."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def type(self) -> Union[str, "ActionWorkflowStepTypeClass"]:
        """A type of step / task / node in the Action Workflow. """
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "ActionWorkflowStepTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Optional description shown alongside the step to explain its purpose."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def actors(self) -> Union[None, "ActionWorkflowStepActorsClass"]:
        """A definition of the actors required to execute the step, if there are any.
    
    For steps of type REQUEST_REVIEW, this field MUST be provided! """
        return self._inner_dict.get('actors')  # type: ignore
    
    @actors.setter
    def actors(self, value: Union[None, "ActionWorkflowStepActorsClass"]) -> None:
        self._inner_dict['actors'] = value
    
    
class ActionWorkflowStepActorsClass(DictWrapper):
    """A definition of the actors required to review."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowStepActors")
    def __init__(self,
        users: List[str],
        groups: List[str],
        roles: List[str],
        dynamicAssignment: Union[None, "ActionWorkflowStepDynamicAssignmentClass"]=None,
    ):
        super().__init__()
        
        self.users = users
        self.groups = groups
        self.roles = roles
        self.dynamicAssignment = dynamicAssignment
    
    def _restore_defaults(self) -> None:
        self.users = list()
        self.groups = list()
        self.roles = list()
        self.dynamicAssignment = self.RECORD_SCHEMA.fields_dict["dynamicAssignment"].default
    
    
    @property
    def users(self) -> List[str]:
        """Users statically assigned to perform the review step."""
        return self._inner_dict.get('users')  # type: ignore
    
    @users.setter
    def users(self, value: List[str]) -> None:
        self._inner_dict['users'] = value
    
    
    @property
    def groups(self) -> List[str]:
        """Groups statically assigned to perform the review step."""
        return self._inner_dict.get('groups')  # type: ignore
    
    @groups.setter
    def groups(self, value: List[str]) -> None:
        self._inner_dict['groups'] = value
    
    
    @property
    def roles(self) -> List[str]:
        """Roles statically assigned to perform the review step."""
        return self._inner_dict.get('roles')  # type: ignore
    
    @roles.setter
    def roles(self, value: List[str]) -> None:
        self._inner_dict['roles'] = value
    
    
    @property
    def dynamicAssignment(self) -> Union[None, "ActionWorkflowStepDynamicAssignmentClass"]:
        """Dynamic assignment type for the review step."""
        return self._inner_dict.get('dynamicAssignment')  # type: ignore
    
    @dynamicAssignment.setter
    def dynamicAssignment(self, value: Union[None, "ActionWorkflowStepDynamicAssignmentClass"]) -> None:
        self._inner_dict['dynamicAssignment'] = value
    
    
class ActionWorkflowStepDynamicAssignmentClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowStepDynamicAssignment")
    def __init__(self,
        type: Union[str, "ActionWorkflowStepDynamicAssignmentTypeClass"],
        ownershipTypeUrns: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.type = type
        self.ownershipTypeUrns = ownershipTypeUrns
    
    def _restore_defaults(self) -> None:
        self.type = ActionWorkflowStepDynamicAssignmentTypeClass.ENTITY_OWNERS
        self.ownershipTypeUrns = self.RECORD_SCHEMA.fields_dict["ownershipTypeUrns"].default
    
    
    @property
    def type(self) -> Union[str, "ActionWorkflowStepDynamicAssignmentTypeClass"]:
        """A standardized policy for resolving actors dynamically for an access request."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "ActionWorkflowStepDynamicAssignmentTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def ownershipTypeUrns(self) -> Union[None, List[str]]:
        """Optional: A well defined set of ownership type urns to including in routing."""
        return self._inner_dict.get('ownershipTypeUrns')  # type: ignore
    
    @ownershipTypeUrns.setter
    def ownershipTypeUrns(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['ownershipTypeUrns'] = value
    
    
class ActionWorkflowStepDynamicAssignmentTypeClass(object):
    # No docs available.
    
    ENTITY_OWNERS = "ENTITY_OWNERS"
    """Assign the entity owners."""
    
    ENTITY_DOMAIN_OWNERS = "ENTITY_DOMAIN_OWNERS"
    """Assign the entity domain owners."""
    
    ENTITY_DATA_PRODUCT_OWNERS = "ENTITY_DATA_PRODUCT_OWNERS"
    """Assign the entity data product owners."""
    
    
    
class ActionWorkflowStepTypeClass(object):
    # No docs available.
    
    APPROVAL = "APPROVAL"
    """The only step type currently supported - a human review step. 
    This step type requires that an assigned user reviews an action request associated with this workflow. 
    reviews the request, approving or denying it (currently the actions supported, may extend later). """
    
    
    
class ActionWorkflowTriggerClass(DictWrapper):
    """Defines the conditions on which the action workflow is triggered. 
    
    Currently we have only one trigger type, but we expect this to extend e.g. in the case that change events, proposals,
    or other actions can trigger workflows. 
    
    Currently, the workflow must have exactly 1 trigger condition. We don't expect this to change. """
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowTrigger")
    def __init__(self,
        type: Union[str, "ActionWorkflowTriggerTypeClass"],
        form: Union[None, "ActionWorkflowFormClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.form = form
    
    def _restore_defaults(self) -> None:
        self.type = ActionWorkflowTriggerTypeClass.FORM_SUBMITTED
        self.form = self.RECORD_SCHEMA.fields_dict["form"].default
    
    
    @property
    def type(self) -> Union[str, "ActionWorkflowTriggerTypeClass"]:
        """A type of step / task / node in the Action Workflow. """
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "ActionWorkflowTriggerTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def form(self) -> Union[None, "ActionWorkflowFormClass"]:
        """The form definition that will trigger the action workflow when submitted. """
        return self._inner_dict.get('form')  # type: ignore
    
    @form.setter
    def form(self, value: Union[None, "ActionWorkflowFormClass"]) -> None:
        self._inner_dict['form'] = value
    
    
class ActionWorkflowTriggerTypeClass(object):
    # No docs available.
    
    FORM_SUBMITTED = "FORM_SUBMITTED"
    """The only trigger type currently supported - a workflow request form is submitted successfully. 
    This enables admins to create forms and display them on various entrypoints. 
    The form is also captured in the field "form" below. """
    
    
    
class AiInferenceMetadataClass(_Aspect):
    """AI Inference Metadata of various types."""


    ASPECT_NAME = 'aiInferenceMetadata'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ai.AiInferenceMetadata")

    def __init__(self,
        glossaryTermsInference: Union[None, "GlossaryTermsInferenceMetadataClass"]=None,
    ):
        super().__init__()
        
        self.glossaryTermsInference = glossaryTermsInference
    
    def _restore_defaults(self) -> None:
        self.glossaryTermsInference = self.RECORD_SCHEMA.fields_dict["glossaryTermsInference"].default
    
    
    @property
    def glossaryTermsInference(self) -> Union[None, "GlossaryTermsInferenceMetadataClass"]:
        """Information about a glossary terms inference."""
        return self._inner_dict.get('glossaryTermsInference')  # type: ignore
    
    @glossaryTermsInference.setter
    def glossaryTermsInference(self, value: Union[None, "GlossaryTermsInferenceMetadataClass"]) -> None:
        self._inner_dict['glossaryTermsInference'] = value
    
    
class EntityInferenceMetadataClass(_Aspect):
    """AI Inference Metadata for a specific entity."""


    ASPECT_NAME = 'entityInferenceMetadata'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ai.EntityInferenceMetadata")

    def __init__(self,
        glossaryTermsInference: Union[None, "InferenceGroupMetadataClass"]=None,
    ):
        super().__init__()
        
        self.glossaryTermsInference = glossaryTermsInference
    
    def _restore_defaults(self) -> None:
        self.glossaryTermsInference = self.RECORD_SCHEMA.fields_dict["glossaryTermsInference"].default
    
    
    @property
    def glossaryTermsInference(self) -> Union[None, "InferenceGroupMetadataClass"]:
        """Information about a group of inferences made for Glossary Terms."""
        return self._inner_dict.get('glossaryTermsInference')  # type: ignore
    
    @glossaryTermsInference.setter
    def glossaryTermsInference(self, value: Union[None, "InferenceGroupMetadataClass"]) -> None:
        self._inner_dict['glossaryTermsInference'] = value
    
    
class GlossaryTermsInferenceMetadataClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ai.GlossaryTermsInferenceMetadata")
    def __init__(self,
        lastInferredAt: int,
        version: int,
    ):
        super().__init__()
        
        self.lastInferredAt = lastInferredAt
        self.version = version
    
    def _restore_defaults(self) -> None:
        self.lastInferredAt = int()
        self.version = int()
    
    
    @property
    def lastInferredAt(self) -> int:
        """Timestamp of the last inference in milliseconds."""
        return self._inner_dict.get('lastInferredAt')  # type: ignore
    
    @lastInferredAt.setter
    def lastInferredAt(self, value: int) -> None:
        self._inner_dict['lastInferredAt'] = value
    
    
    @property
    def version(self) -> int:
        """Monotonically incrementing version number. Once bumped, will re-trigger a new inference."""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: int) -> None:
        self._inner_dict['version'] = value
    
    
class InferenceGroupMetadataClass(DictWrapper):
    """Reusable metadata about a group of inferences of the same type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ai.InferenceGroupMetadata")
    def __init__(self,
        lastInferredAt: int,
        version: int,
    ):
        super().__init__()
        
        self.lastInferredAt = lastInferredAt
        self.version = version
    
    def _restore_defaults(self) -> None:
        self.lastInferredAt = int()
        self.version = int()
    
    
    @property
    def lastInferredAt(self) -> int:
        """Timestamp of the last inference in milliseconds."""
        return self._inner_dict.get('lastInferredAt')  # type: ignore
    
    @lastInferredAt.setter
    def lastInferredAt(self, value: int) -> None:
        self._inner_dict['lastInferredAt'] = value
    
    
    @property
    def version(self) -> int:
        """Monotonically incrementing version number. Once bumped, will re-trigger a new inference."""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: int) -> None:
        self._inner_dict['version'] = value
    
    
class InferenceMetadataClass(DictWrapper):
    """Reusable metadata about an individual inference - i.e. a single glossary term, tag, description, etc."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ai.InferenceMetadata")
    def __init__(self,
        lastInferredAt: int,
        version: int,
        confidenceLevel: Union[None, int]=None,
    ):
        super().__init__()
        
        self.lastInferredAt = lastInferredAt
        self.version = version
        self.confidenceLevel = confidenceLevel
    
    def _restore_defaults(self) -> None:
        self.lastInferredAt = int()
        self.version = int()
        self.confidenceLevel = self.RECORD_SCHEMA.fields_dict["confidenceLevel"].default
    
    
    @property
    def lastInferredAt(self) -> int:
        """Timestamp of the last inference in milliseconds."""
        return self._inner_dict.get('lastInferredAt')  # type: ignore
    
    @lastInferredAt.setter
    def lastInferredAt(self, value: int) -> None:
        self._inner_dict['lastInferredAt'] = value
    
    
    @property
    def version(self) -> int:
        """Monotonically incrementing version number. Once bumped, will re-trigger a new inference."""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: int) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def confidenceLevel(self) -> Union[None, int]:
        """Numeric confidence level of the inference that was made.
    
       0 = Low Confidence
       1 = Medium Confidence
       2 = High Confidence"""
        return self._inner_dict.get('confidenceLevel')  # type: ignore
    
    @confidenceLevel.setter
    def confidenceLevel(self, value: Union[None, int]) -> None:
        self._inner_dict['confidenceLevel'] = value
    
    
class AnomalyReviewStateClass(object):
    # No docs available.
    
    CONFIRMED = "CONFIRMED"
    """The anomaly has been confirmed by a human reviewer. This means the anomaly was validated."""
    
    REJECTED = "REJECTED"
    """The anomaly has been dismissed, or ignored, by a human reviewer. This means the anomaly should have been ignored."""
    
    
    
class AnomalySourceClass(DictWrapper):
    """Information about the source of feedback for an anomaly raised on an asset."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.anomaly.AnomalySource")
    def __init__(self,
        type: Union[str, "AnomalySourceTypeClass"],
        sourceUrn: Union[None, str]=None,
        sourceEventTimestampMillis: Union[None, int]=None,
        properties: Union[None, "AnomalySourcePropertiesClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.sourceUrn = sourceUrn
        self.sourceEventTimestampMillis = sourceEventTimestampMillis
        self.properties = properties
    
    def _restore_defaults(self) -> None:
        self.type = AnomalySourceTypeClass.INFERRED_ASSERTION_FAILURE
        self.sourceUrn = self.RECORD_SCHEMA.fields_dict["sourceUrn"].default
        self.sourceEventTimestampMillis = self.RECORD_SCHEMA.fields_dict["sourceEventTimestampMillis"].default
        self.properties = self.RECORD_SCHEMA.fields_dict["properties"].default
    
    
    @property
    def type(self) -> Union[str, "AnomalySourceTypeClass"]:
        """How this feedback was provided."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AnomalySourceTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def sourceUrn(self) -> Union[None, str]:
        """Reference to an URN related to the source of an anomaly.
    For assertion monitors, this will contain the urn of the source Assertion."""
        return self._inner_dict.get('sourceUrn')  # type: ignore
    
    @sourceUrn.setter
    def sourceUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['sourceUrn'] = value
    
    
    @property
    def sourceEventTimestampMillis(self) -> Union[None, int]:
        """The timestamp of the event that triggered the anomaly.
    For assertion monitors, this will be the timestamp of the assertion run event."""
        return self._inner_dict.get('sourceEventTimestampMillis')  # type: ignore
    
    @sourceEventTimestampMillis.setter
    def sourceEventTimestampMillis(self, value: Union[None, int]) -> None:
        self._inner_dict['sourceEventTimestampMillis'] = value
    
    
    @property
    def properties(self) -> Union[None, "AnomalySourcePropertiesClass"]:
        """Additional properties about the source, for example which metric
    of an assertion generated the anomaly."""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Union[None, "AnomalySourcePropertiesClass"]) -> None:
        self._inner_dict['properties'] = value
    
    
class AnomalySourcePropertiesClass(DictWrapper):
    """Ad-hoc properties about an anomaly source."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.anomaly.AnomalySourceProperties")
    def __init__(self,
        assertionMetric: Union[None, "AssertionMetricClass"]=None,
        operationRange: Union[None, "OperationRangeClass"]=None,
    ):
        super().__init__()
        
        self.assertionMetric = assertionMetric
        self.operationRange = operationRange
    
    def _restore_defaults(self) -> None:
        self.assertionMetric = self.RECORD_SCHEMA.fields_dict["assertionMetric"].default
        self.operationRange = self.RECORD_SCHEMA.fields_dict["operationRange"].default
    
    
    @property
    def assertionMetric(self) -> Union[None, "AssertionMetricClass"]:
        """The monitor metric associated with the anomaly, if generated from an assertion monitor (the norm)."""
        return self._inner_dict.get('assertionMetric')  # type: ignore
    
    @assertionMetric.setter
    def assertionMetric(self, value: Union[None, "AssertionMetricClass"]) -> None:
        self._inner_dict['assertionMetric'] = value
    
    
    @property
    def operationRange(self) -> Union[None, "OperationRangeClass"]:
        """The operation range associated with the anomaly, if generated from an assertion monitor (the norm).
    This is specific to freshness assertions."""
        return self._inner_dict.get('operationRange')  # type: ignore
    
    @operationRange.setter
    def operationRange(self, value: Union[None, "OperationRangeClass"]) -> None:
        self._inner_dict['operationRange'] = value
    
    
class AnomalySourceTypeClass(object):
    # No docs available.
    
    INFERRED_ASSERTION_FAILURE = "INFERRED_ASSERTION_FAILURE"
    """An assertion has failed, triggering the anomaly report."""
    
    USER_FEEDBACK = "USER_FEEDBACK"
    """An anomaly was reported by a user."""
    
    
    
class MonitorAnomalyEventClass(_Aspect):
    """A feedback log of anomalies detected by a monitor
    NOTE: this is an immutable log. The most recent entry for a given run can be used to determine the state of the anomaly."""


    ASPECT_NAME = 'monitorAnomalyEvent'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.anomaly.MonitorAnomalyEvent")

    def __init__(self,
        timestampMillis: int,
        source: "AnomalySourceClass",
        created: "TimeStampClass",
        lastUpdated: "TimeStampClass",
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        state: Union[None, Union[str, "AnomalyReviewStateClass"]]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.state = state
        self.source = source
        self.created = created
        self.lastUpdated = lastUpdated
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.state = self.RECORD_SCHEMA.fields_dict["state"].default
        self.source = AnomalySourceClass._construct_with_defaults()
        self.created = TimeStampClass._construct_with_defaults()
        self.lastUpdated = TimeStampClass._construct_with_defaults()
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def state(self) -> Union[None, Union[str, "AnomalyReviewStateClass"]]:
        """The review of the anomaly, based on human-provided feedback.
    If this is not present, then the Anomaly has not yet been reviewed."""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[None, Union[str, "AnomalyReviewStateClass"]]) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def source(self) -> "AnomalySourceClass":
        """The source of an anomaly, i.e. how it was generated."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: "AnomalySourceClass") -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def created(self) -> "TimeStampClass":
        """@Deprecated: this matches the timestampMillis field in the TimeseriesAspectBase."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "TimeStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastUpdated(self) -> "TimeStampClass":
        """The time at which the anomaly was last updated
    @Deprecated: this field is not used as this is an immutable log."""
        return self._inner_dict.get('lastUpdated')  # type: ignore
    
    @lastUpdated.setter
    def lastUpdated(self, value: "TimeStampClass") -> None:
        self._inner_dict['lastUpdated'] = value
    
    
class OperationRangeClass(DictWrapper):
    """The time range of the anomalous operation."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.anomaly.OperationRange")
    def __init__(self,
        startTimestampMillis: int,
        endTimestampMillis: int,
    ):
        super().__init__()
        
        self.startTimestampMillis = startTimestampMillis
        self.endTimestampMillis = endTimestampMillis
    
    def _restore_defaults(self) -> None:
        self.startTimestampMillis = int()
        self.endTimestampMillis = int()
    
    
    @property
    def startTimestampMillis(self) -> int:
        """The start timestamp of the operation in milliseconds since epoch."""
        return self._inner_dict.get('startTimestampMillis')  # type: ignore
    
    @startTimestampMillis.setter
    def startTimestampMillis(self, value: int) -> None:
        self._inner_dict['startTimestampMillis'] = value
    
    
    @property
    def endTimestampMillis(self) -> int:
        """The end timestamp of the operation in milliseconds since epoch."""
        return self._inner_dict.get('endTimestampMillis')  # type: ignore
    
    @endTimestampMillis.setter
    def endTimestampMillis(self, value: int) -> None:
        self._inner_dict['endTimestampMillis'] = value
    
    
class ApplicationKeyClass(_Aspect):
    """Key for a Query"""


    ASPECT_NAME = 'applicationKey'
    ASPECT_INFO = {'keyForEntity': 'application', 'entityCategory': 'core', 'entityAspects': ['applicationProperties', 'ownership', 'glossaryTerms', 'globalTags', 'domains', 'institutionalMemory', 'status', 'structuredProperties', 'forms', 'testResults', 'subTypes']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.application.ApplicationKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the Application."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class ApplicationPropertiesClass(_Aspect):
    """The main properties of an Application"""


    ASPECT_NAME = 'applicationProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.application.ApplicationProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        name: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.name = name
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the Application"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the application"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class ApplicationsClass(_Aspect):
    """Links from an Asset to its Applications"""


    ASPECT_NAME = 'applications'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.application.Applications")

    def __init__(self,
        applications: List[str],
    ):
        super().__init__()
        
        self.applications = applications
    
    def _restore_defaults(self) -> None:
        self.applications = list()
    
    
    @property
    def applications(self) -> List[str]:
        """The Applications attached to an Asset"""
        return self._inner_dict.get('applications')  # type: ignore
    
    @applications.setter
    def applications(self, value: List[str]) -> None:
        self._inner_dict['applications'] = value
    
    
class AdjustmentAlgorithmClass(object):
    """The adjustment algorithm to use when determining the threshold for an assertion."""
    
    CUSTOM = "CUSTOM"
    
    
class AssertionActionClass(DictWrapper):
    """The Actions about an Assertion.
    In the future, we'll likely extend this model to support additional
    parameters or options related to the assertion actions."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionAction")
    def __init__(self,
        type: Union[str, "AssertionActionTypeClass"],
    ):
        super().__init__()
        
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.type = AssertionActionTypeClass.RAISE_INCIDENT
    
    
    @property
    def type(self) -> Union[str, "AssertionActionTypeClass"]:
        """The type of the Action"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionActionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class AssertionActionTypeClass(object):
    # No docs available.
    
    RAISE_INCIDENT = "RAISE_INCIDENT"
    """Raise an incident."""
    
    RESOLVE_INCIDENT = "RESOLVE_INCIDENT"
    """Resolve open incidents related to the assertion."""
    
    
    
class AssertionActionsClass(_Aspect):
    """The Actions about an Assertion"""


    ASPECT_NAME = 'assertionActions'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionActions")

    def __init__(self,
        onSuccess: Optional[List["AssertionActionClass"]]=None,
        onFailure: Optional[List["AssertionActionClass"]]=None,
    ):
        super().__init__()
        
        if onSuccess is None:
            # default: []
            self.onSuccess = list()
        else:
            self.onSuccess = onSuccess
        if onFailure is None:
            # default: []
            self.onFailure = list()
        else:
            self.onFailure = onFailure
    
    def _restore_defaults(self) -> None:
        self.onSuccess = list()
        self.onFailure = list()
    
    
    @property
    def onSuccess(self) -> List["AssertionActionClass"]:
        """Actions to be executed on successful assertion run."""
        return self._inner_dict.get('onSuccess')  # type: ignore
    
    @onSuccess.setter
    def onSuccess(self, value: List["AssertionActionClass"]) -> None:
        self._inner_dict['onSuccess'] = value
    
    
    @property
    def onFailure(self) -> List["AssertionActionClass"]:
        """Actions to be executed on failed assertion run."""
        return self._inner_dict.get('onFailure')  # type: ignore
    
    @onFailure.setter
    def onFailure(self, value: List["AssertionActionClass"]) -> None:
        self._inner_dict['onFailure'] = value
    
    
class AssertionAdjustmentSettingsClass(DictWrapper):
    """A set of settings that can be used to adjust assertion values
    NOTE: This is only applied against inferred assertions"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionAdjustmentSettings")
    def __init__(self,
        algorithm: Union[None, Union[str, "AdjustmentAlgorithmClass"]]=None,
        algorithmName: Union[None, str]=None,
        context: Union[None, Dict[str, str]]=None,
        exclusionWindows: Union[None, List["AssertionExclusionWindowClass"]]=None,
        anomalyExclusionWindows: Union[None, List["AssertionExclusionWindowClass"]]=None,
        trainingDataLookbackWindowDays: Union[None, int]=None,
        sensitivity: Union[None, "AssertionMonitorSensitivityClass"]=None,
    ):
        super().__init__()
        
        self.algorithm = algorithm
        self.algorithmName = algorithmName
        self.context = context
        self.exclusionWindows = exclusionWindows
        self.anomalyExclusionWindows = anomalyExclusionWindows
        self.trainingDataLookbackWindowDays = trainingDataLookbackWindowDays
        self.sensitivity = sensitivity
    
    def _restore_defaults(self) -> None:
        self.algorithm = self.RECORD_SCHEMA.fields_dict["algorithm"].default
        self.algorithmName = self.RECORD_SCHEMA.fields_dict["algorithmName"].default
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
        self.exclusionWindows = self.RECORD_SCHEMA.fields_dict["exclusionWindows"].default
        self.anomalyExclusionWindows = self.RECORD_SCHEMA.fields_dict["anomalyExclusionWindows"].default
        self.trainingDataLookbackWindowDays = self.RECORD_SCHEMA.fields_dict["trainingDataLookbackWindowDays"].default
        self.sensitivity = self.RECORD_SCHEMA.fields_dict["sensitivity"].default
    
    
    @property
    def algorithm(self) -> Union[None, Union[str, "AdjustmentAlgorithmClass"]]:
        """The algorithm to use to adjust assertion values to power the sensitivity control feature
    
    Note that for algorithm "STDDEV" which leverages the standard deviation of trailing values,
    the "stdDev" field must be provided inside of AssertionEvaluationContext.pdl by the offline pipeline."""
        return self._inner_dict.get('algorithm')  # type: ignore
    
    @algorithm.setter
    def algorithm(self, value: Union[None, Union[str, "AdjustmentAlgorithmClass"]]) -> None:
        self._inner_dict['algorithm'] = value
    
    
    @property
    def algorithmName(self) -> Union[None, str]:
        """The name of the algorithm to use to adjust assertion values to power the sensitivity control feature"""
        return self._inner_dict.get('algorithmName')  # type: ignore
    
    @algorithmName.setter
    def algorithmName(self, value: Union[None, str]) -> None:
        self._inner_dict['algorithmName'] = value
    
    
    @property
    def context(self) -> Union[None, Dict[str, str]]:
        """The context to use to adjust assertion values"""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['context'] = value
    
    
    @property
    def exclusionWindows(self) -> Union[None, List["AssertionExclusionWindowClass"]]:
        """The user-defined exclusion windows for the assertion."""
        return self._inner_dict.get('exclusionWindows')  # type: ignore
    
    @exclusionWindows.setter
    def exclusionWindows(self, value: Union[None, List["AssertionExclusionWindowClass"]]) -> None:
        self._inner_dict['exclusionWindows'] = value
    
    
    @property
    def anomalyExclusionWindows(self) -> Union[None, List["AssertionExclusionWindowClass"]]:
        """Exclude the anomaly data points for the assertion. These are detected automatically by the system."""
        return self._inner_dict.get('anomalyExclusionWindows')  # type: ignore
    
    @anomalyExclusionWindows.setter
    def anomalyExclusionWindows(self, value: Union[None, List["AssertionExclusionWindowClass"]]) -> None:
        self._inner_dict['anomalyExclusionWindows'] = value
    
    
    @property
    def trainingDataLookbackWindowDays(self) -> Union[None, int]:
        """The lookback window configuration for retrieving training data points.
    Defines how far back in time to look when gathering data for training.
    Defaults to 60 days if not specified."""
        return self._inner_dict.get('trainingDataLookbackWindowDays')  # type: ignore
    
    @trainingDataLookbackWindowDays.setter
    def trainingDataLookbackWindowDays(self, value: Union[None, int]) -> None:
        self._inner_dict['trainingDataLookbackWindowDays'] = value
    
    
    @property
    def sensitivity(self) -> Union[None, "AssertionMonitorSensitivityClass"]:
        """The sensitivity level for an assertion"""
        return self._inner_dict.get('sensitivity')  # type: ignore
    
    @sensitivity.setter
    def sensitivity(self, value: Union[None, "AssertionMonitorSensitivityClass"]) -> None:
        self._inner_dict['sensitivity'] = value
    
    
class AssertionAnalyticsRunEventClass(_Aspect):
    """An event representing the current status of evaluating an assertion on a batch.
    This should be derrived from {@link AssertionRunEvent}.
    
    It represents the subset of data used for analytics, and hydrates extra fields for filtering"""


    ASPECT_NAME = 'assertionAnalyticsRunEvent'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionAnalyticsRunEvent")

    def __init__(self,
        type: Union[str, "AssertionTypeClass"],
        timestampMillis: int,
        runId: str,
        asserteeUrn: str,
        assertionUrn: str,
        status: Union[str, "AssertionRunStatusClass"],
        creator: Union[None, str]=None,
        asserteeDomains: Union[None, List[str]]=None,
        asserteeDataProducts: Union[None, List[str]]=None,
        asserteeTags: Union[None, List[str]]=None,
        asserteeGlossaryTerms: Union[None, List[str]]=None,
        asserteeOwners: Union[None, List[str]]=None,
        asserteeDataPlatform: Union[None, str]=None,
        asserteeDataPlatformInstance: Union[None, str]=None,
        asserteeContainer: Union[None, str]=None,
        asserteeSchemaFieldGlossaryTerms: Union[None, List[str]]=None,
        asserteeSchemaFieldTags: Union[None, List[str]]=None,
        result: Union[None, "AssertionResultClass"]=None,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.creator = creator
        self.asserteeDomains = asserteeDomains
        self.asserteeDataProducts = asserteeDataProducts
        self.asserteeTags = asserteeTags
        self.asserteeGlossaryTerms = asserteeGlossaryTerms
        self.asserteeOwners = asserteeOwners
        self.asserteeDataPlatform = asserteeDataPlatform
        self.asserteeDataPlatformInstance = asserteeDataPlatformInstance
        self.asserteeContainer = asserteeContainer
        self.asserteeSchemaFieldGlossaryTerms = asserteeSchemaFieldGlossaryTerms
        self.asserteeSchemaFieldTags = asserteeSchemaFieldTags
        self.timestampMillis = timestampMillis
        self.runId = runId
        self.asserteeUrn = asserteeUrn
        self.assertionUrn = assertionUrn
        self.status = status
        self.result = result
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
    
    def _restore_defaults(self) -> None:
        self.type = AssertionTypeClass.DATASET
        self.creator = self.RECORD_SCHEMA.fields_dict["creator"].default
        self.asserteeDomains = self.RECORD_SCHEMA.fields_dict["asserteeDomains"].default
        self.asserteeDataProducts = self.RECORD_SCHEMA.fields_dict["asserteeDataProducts"].default
        self.asserteeTags = self.RECORD_SCHEMA.fields_dict["asserteeTags"].default
        self.asserteeGlossaryTerms = self.RECORD_SCHEMA.fields_dict["asserteeGlossaryTerms"].default
        self.asserteeOwners = self.RECORD_SCHEMA.fields_dict["asserteeOwners"].default
        self.asserteeDataPlatform = self.RECORD_SCHEMA.fields_dict["asserteeDataPlatform"].default
        self.asserteeDataPlatformInstance = self.RECORD_SCHEMA.fields_dict["asserteeDataPlatformInstance"].default
        self.asserteeContainer = self.RECORD_SCHEMA.fields_dict["asserteeContainer"].default
        self.asserteeSchemaFieldGlossaryTerms = self.RECORD_SCHEMA.fields_dict["asserteeSchemaFieldGlossaryTerms"].default
        self.asserteeSchemaFieldTags = self.RECORD_SCHEMA.fields_dict["asserteeSchemaFieldTags"].default
        self.timestampMillis = int()
        self.runId = str()
        self.asserteeUrn = str()
        self.assertionUrn = str()
        self.status = AssertionRunStatusClass.COMPLETE
        self.result = self.RECORD_SCHEMA.fields_dict["result"].default
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
    
    
    @property
    def type(self) -> Union[str, "AssertionTypeClass"]:
        """Type of assertion."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def creator(self) -> Union[None, str]:
        """Creator of the assertion."""
        return self._inner_dict.get('creator')  # type: ignore
    
    @creator.setter
    def creator(self, value: Union[None, str]) -> None:
        self._inner_dict['creator'] = value
    
    
    @property
    def asserteeDomains(self) -> Union[None, List[str]]:
        """The Domains attached to the entity's parent Asset"""
        return self._inner_dict.get('asserteeDomains')  # type: ignore
    
    @asserteeDomains.setter
    def asserteeDomains(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['asserteeDomains'] = value
    
    
    @property
    def asserteeDataProducts(self) -> Union[None, List[str]]:
        """The Data Products attached to the entity's parent Asset"""
        return self._inner_dict.get('asserteeDataProducts')  # type: ignore
    
    @asserteeDataProducts.setter
    def asserteeDataProducts(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['asserteeDataProducts'] = value
    
    
    @property
    def asserteeTags(self) -> Union[None, List[str]]:
        """The Tags attached to the entity's parent Asset"""
        return self._inner_dict.get('asserteeTags')  # type: ignore
    
    @asserteeTags.setter
    def asserteeTags(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['asserteeTags'] = value
    
    
    @property
    def asserteeGlossaryTerms(self) -> Union[None, List[str]]:
        """The Glossary Terms attached to the entity's parent Asset"""
        return self._inner_dict.get('asserteeGlossaryTerms')  # type: ignore
    
    @asserteeGlossaryTerms.setter
    def asserteeGlossaryTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['asserteeGlossaryTerms'] = value
    
    
    @property
    def asserteeOwners(self) -> Union[None, List[str]]:
        """Parent Owner URN, e.g. urn:li:corpuser:ldap, urn:li:corpGroup:group_name, and urn:li:multiProduct:mp_name
    (Caveat: only corpuser is currently supported in the frontend.)"""
        return self._inner_dict.get('asserteeOwners')  # type: ignore
    
    @asserteeOwners.setter
    def asserteeOwners(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['asserteeOwners'] = value
    
    
    @property
    def asserteeDataPlatform(self) -> Union[None, str]:
        """Data Platform for parent"""
        return self._inner_dict.get('asserteeDataPlatform')  # type: ignore
    
    @asserteeDataPlatform.setter
    def asserteeDataPlatform(self, value: Union[None, str]) -> None:
        self._inner_dict['asserteeDataPlatform'] = value
    
    
    @property
    def asserteeDataPlatformInstance(self) -> Union[None, str]:
        """Instance of the parent's data platform (e.g. db instance)"""
        return self._inner_dict.get('asserteeDataPlatformInstance')  # type: ignore
    
    @asserteeDataPlatformInstance.setter
    def asserteeDataPlatformInstance(self, value: Union[None, str]) -> None:
        self._inner_dict['asserteeDataPlatformInstance'] = value
    
    
    @property
    def asserteeContainer(self) -> Union[None, str]:
        """The container of the parent"""
        return self._inner_dict.get('asserteeContainer')  # type: ignore
    
    @asserteeContainer.setter
    def asserteeContainer(self, value: Union[None, str]) -> None:
        self._inner_dict['asserteeContainer'] = value
    
    
    @property
    def asserteeSchemaFieldGlossaryTerms(self) -> Union[None, List[str]]:
        """Only provided if the Assertion is of type 'Column'. The glossary terms associated with the target column."""
        return self._inner_dict.get('asserteeSchemaFieldGlossaryTerms')  # type: ignore
    
    @asserteeSchemaFieldGlossaryTerms.setter
    def asserteeSchemaFieldGlossaryTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['asserteeSchemaFieldGlossaryTerms'] = value
    
    
    @property
    def asserteeSchemaFieldTags(self) -> Union[None, List[str]]:
        """Only provided if the Assertion is of type 'Column'. The tags associated with the target column."""
        return self._inner_dict.get('asserteeSchemaFieldTags')  # type: ignore
    
    @asserteeSchemaFieldTags.setter
    def asserteeSchemaFieldTags(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['asserteeSchemaFieldTags'] = value
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milliseconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def runId(self) -> str:
        """ Native (platform-specific) identifier for this run"""
        return self._inner_dict.get('runId')  # type: ignore
    
    @runId.setter
    def runId(self, value: str) -> None:
        self._inner_dict['runId'] = value
    
    
    @property
    def asserteeUrn(self) -> str:
        # No docs available.
        return self._inner_dict.get('asserteeUrn')  # type: ignore
    
    @asserteeUrn.setter
    def asserteeUrn(self, value: str) -> None:
        self._inner_dict['asserteeUrn'] = value
    
    
    @property
    def assertionUrn(self) -> str:
        # No docs available.
        return self._inner_dict.get('assertionUrn')  # type: ignore
    
    @assertionUrn.setter
    def assertionUrn(self, value: str) -> None:
        self._inner_dict['assertionUrn'] = value
    
    
    @property
    def status(self) -> Union[str, "AssertionRunStatusClass"]:
        """The status of the assertion run as per this timeseries event."""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "AssertionRunStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def result(self) -> Union[None, "AssertionResultClass"]:
        """Results of assertion, present if the status is COMPLETE"""
        return self._inner_dict.get('result')  # type: ignore
    
    @result.setter
    def result(self, value: Union[None, "AssertionResultClass"]) -> None:
        self._inner_dict['result'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
class AssertionDryRunEventClass(_Aspect):
    """An event produced when assertion is executed in dry-run mode, e.g.
    when an assertion is being "dark-tested".
    
    This is used primarily in Acryl Observe to test assertion inference before production release.
    
    A subset of AssertionRunEvent without the @Searchables."""


    ASPECT_NAME = 'assertionDryRunEvent'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionDryRunEvent")

    def __init__(self,
        timestampMillis: int,
        asserteeUrn: str,
        status: Union[str, "AssertionRunStatusClass"],
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        result: Union[None, "AssertionDryRunResultClass"]=None,
        runtimeContext: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.asserteeUrn = asserteeUrn
        self.status = status
        self.result = result
        self.runtimeContext = runtimeContext
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.asserteeUrn = str()
        self.status = AssertionRunStatusClass.COMPLETE
        self.result = self.RECORD_SCHEMA.fields_dict["result"].default
        self.runtimeContext = self.RECORD_SCHEMA.fields_dict["runtimeContext"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def asserteeUrn(self) -> str:
        # No docs available.
        return self._inner_dict.get('asserteeUrn')  # type: ignore
    
    @asserteeUrn.setter
    def asserteeUrn(self, value: str) -> None:
        self._inner_dict['asserteeUrn'] = value
    
    
    @property
    def status(self) -> Union[str, "AssertionRunStatusClass"]:
        """The status of the assertion dry run as per this timeseries event."""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "AssertionRunStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def result(self) -> Union[None, "AssertionDryRunResultClass"]:
        """Results of assertion, present if the status is COMPLETE"""
        return self._inner_dict.get('result')  # type: ignore
    
    @result.setter
    def result(self, value: Union[None, "AssertionDryRunResultClass"]) -> None:
        self._inner_dict['result'] = value
    
    
    @property
    def runtimeContext(self) -> Union[None, Dict[str, str]]:
        """Runtime parameters of evaluation"""
        return self._inner_dict.get('runtimeContext')  # type: ignore
    
    @runtimeContext.setter
    def runtimeContext(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['runtimeContext'] = value
    
    
class AssertionDryRunResultClass(DictWrapper):
    """The result of dry running an assertion.
    
    A subset of AssertionResult without the @Searchables."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionDryRunResult")
    def __init__(self,
        type: Union[str, "AssertionResultTypeClass"],
        rowCount: Union[None, int]=None,
        missingCount: Union[None, int]=None,
        unexpectedCount: Union[None, int]=None,
        nativeResults: Union[None, Dict[str, str]]=None,
        error: Union[None, "AssertionResultErrorClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.rowCount = rowCount
        self.missingCount = missingCount
        self.unexpectedCount = unexpectedCount
        self.nativeResults = nativeResults
        self.error = error
    
    def _restore_defaults(self) -> None:
        self.type = AssertionResultTypeClass.INIT
        self.rowCount = self.RECORD_SCHEMA.fields_dict["rowCount"].default
        self.missingCount = self.RECORD_SCHEMA.fields_dict["missingCount"].default
        self.unexpectedCount = self.RECORD_SCHEMA.fields_dict["unexpectedCount"].default
        self.nativeResults = self.RECORD_SCHEMA.fields_dict["nativeResults"].default
        self.error = self.RECORD_SCHEMA.fields_dict["error"].default
    
    
    @property
    def type(self) -> Union[str, "AssertionResultTypeClass"]:
        """ The final result, e.g. either SUCCESS, FAILURE, or ERROR."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionResultTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def rowCount(self) -> Union[None, int]:
        """Number of rows for evaluated batch"""
        return self._inner_dict.get('rowCount')  # type: ignore
    
    @rowCount.setter
    def rowCount(self, value: Union[None, int]) -> None:
        self._inner_dict['rowCount'] = value
    
    
    @property
    def missingCount(self) -> Union[None, int]:
        """Number of rows with missing value for evaluated batch"""
        return self._inner_dict.get('missingCount')  # type: ignore
    
    @missingCount.setter
    def missingCount(self, value: Union[None, int]) -> None:
        self._inner_dict['missingCount'] = value
    
    
    @property
    def unexpectedCount(self) -> Union[None, int]:
        """Number of rows with unexpected value for evaluated batch"""
        return self._inner_dict.get('unexpectedCount')  # type: ignore
    
    @unexpectedCount.setter
    def unexpectedCount(self, value: Union[None, int]) -> None:
        self._inner_dict['unexpectedCount'] = value
    
    
    @property
    def nativeResults(self) -> Union[None, Dict[str, str]]:
        """Other results of evaluation"""
        return self._inner_dict.get('nativeResults')  # type: ignore
    
    @nativeResults.setter
    def nativeResults(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['nativeResults'] = value
    
    
    @property
    def error(self) -> Union[None, "AssertionResultErrorClass"]:
        """ The error object if AssertionResultType is an Error"""
        return self._inner_dict.get('error')  # type: ignore
    
    @error.setter
    def error(self, value: Union[None, "AssertionResultErrorClass"]) -> None:
        self._inner_dict['error'] = value
    
    
class AssertionExclusionWindowClass(DictWrapper):
    """Information about an assertion exclusion window.
    This is used to exclude specific time periods from assertion evaluation or training.
    For example, excluding holidays, weekends, or known anomalous periods.
    Supports various recurrence patterns: one-off exclusions, or recurring exclusions
    (yearly, monthly, weekly, daily, or specific holidays)."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionExclusionWindow")
    def __init__(self,
        type: Union[str, "AssertionExclusionWindowTypeClass"],
        displayName: Union[None, str]=None,
        fixedRange: Union[None, "AbsoluteTimeWindowClass"]=None,
        weekly: Union[None, "WeeklyWindowClass"]=None,
        holiday: Union[None, "HolidayWindowClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.displayName = displayName
        self.fixedRange = fixedRange
        self.weekly = weekly
        self.holiday = holiday
    
    def _restore_defaults(self) -> None:
        self.type = AssertionExclusionWindowTypeClass.FIXED_RANGE
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.fixedRange = self.RECORD_SCHEMA.fields_dict["fixedRange"].default
        self.weekly = self.RECORD_SCHEMA.fields_dict["weekly"].default
        self.holiday = self.RECORD_SCHEMA.fields_dict["holiday"].default
    
    
    @property
    def type(self) -> Union[str, "AssertionExclusionWindowTypeClass"]:
        """The type of exclusion window."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionExclusionWindowTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """Display name for this exclusion window"""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def fixedRange(self) -> Union[None, "AbsoluteTimeWindowClass"]:
        """Date window for one-off exclusion range
    Only used when type is FIXED_RANGE"""
        return self._inner_dict.get('fixedRange')  # type: ignore
    
    @fixedRange.setter
    def fixedRange(self, value: Union[None, "AbsoluteTimeWindowClass"]) -> None:
        self._inner_dict['fixedRange'] = value
    
    
    @property
    def weekly(self) -> Union[None, "WeeklyWindowClass"]:
        """Window of time each week to exclude."""
        return self._inner_dict.get('weekly')  # type: ignore
    
    @weekly.setter
    def weekly(self, value: Union[None, "WeeklyWindowClass"]) -> None:
        self._inner_dict['weekly'] = value
    
    
    @property
    def holiday(self) -> Union[None, "HolidayWindowClass"]:
        """The holiday to exclude
    Only used when type is HOLIDAY"""
        return self._inner_dict.get('holiday')  # type: ignore
    
    @holiday.setter
    def holiday(self, value: Union[None, "HolidayWindowClass"]) -> None:
        self._inner_dict['holiday'] = value
    
    
class AssertionExclusionWindowTypeClass(object):
    # No docs available.
    
    FIXED_RANGE = "FIXED_RANGE"
    """One-off time range to exclude"""
    
    WEEKLY = "WEEKLY"
    """Recurring time range to exclude each week"""
    
    HOLIDAY = "HOLIDAY"
    """Specific holiday to exclude"""
    
    
    
class AssertionInferenceDetailsClass(_Aspect):
    """The details of an assertion that was inferred.
    
    Deprecated as an aspect for assertions!"""


    ASPECT_NAME = 'assertionInferenceDetails'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionInferenceDetails")

    def __init__(self,
        modelId: Union[None, str]=None,
        modelVersion: Union[None, str]=None,
        confidence: Union[None, float]=None,
        parameters: Union[None, Dict[str, str]]=None,
        generatedAt: Union[None, int]=None,
        adjustmentSettings: Union[None, "AssertionAdjustmentSettingsClass"]=None,
    ):
        super().__init__()
        
        self.modelId = modelId
        self.modelVersion = modelVersion
        self.confidence = confidence
        self.parameters = parameters
        self.generatedAt = generatedAt
        self.adjustmentSettings = adjustmentSettings
    
    def _restore_defaults(self) -> None:
        self.modelId = self.RECORD_SCHEMA.fields_dict["modelId"].default
        self.modelVersion = self.RECORD_SCHEMA.fields_dict["modelVersion"].default
        self.confidence = self.RECORD_SCHEMA.fields_dict["confidence"].default
        self.parameters = self.RECORD_SCHEMA.fields_dict["parameters"].default
        self.generatedAt = self.RECORD_SCHEMA.fields_dict["generatedAt"].default
        self.adjustmentSettings = self.RECORD_SCHEMA.fields_dict["adjustmentSettings"].default
    
    
    @property
    def modelId(self) -> Union[None, str]:
        """The id of the assertion prediction model."""
        return self._inner_dict.get('modelId')  # type: ignore
    
    @modelId.setter
    def modelId(self, value: Union[None, str]) -> None:
        self._inner_dict['modelId'] = value
    
    
    @property
    def modelVersion(self) -> Union[None, str]:
        """The version of the model used to make the assertion."""
        return self._inner_dict.get('modelVersion')  # type: ignore
    
    @modelVersion.setter
    def modelVersion(self, value: Union[None, str]) -> None:
        self._inner_dict['modelVersion'] = value
    
    
    @property
    def confidence(self) -> Union[None, float]:
        """The confidence of the inference, if available."""
        return self._inner_dict.get('confidence')  # type: ignore
    
    @confidence.setter
    def confidence(self, value: Union[None, float]) -> None:
        self._inner_dict['confidence'] = value
    
    
    @property
    def parameters(self) -> Union[None, Dict[str, str]]:
        """The parameters used to make the inference."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['parameters'] = value
    
    
    @property
    def generatedAt(self) -> Union[None, int]:
        """The time the inferred assertion was generated at in milliseconds."""
        return self._inner_dict.get('generatedAt')  # type: ignore
    
    @generatedAt.setter
    def generatedAt(self, value: Union[None, int]) -> None:
        self._inner_dict['generatedAt'] = value
    
    
    @property
    def adjustmentSettings(self) -> Union[None, "AssertionAdjustmentSettingsClass"]:
        """The settings used to adjust the assertion."""
        return self._inner_dict.get('adjustmentSettings')  # type: ignore
    
    @adjustmentSettings.setter
    def adjustmentSettings(self, value: Union[None, "AssertionAdjustmentSettingsClass"]) -> None:
        self._inner_dict['adjustmentSettings'] = value
    
    
class AssertionInfoClass(_Aspect):
    """Information about an assertion
    
    Acryl Only: Did you update AssertionWithoutAnnotations.pdl? If not, please update it."""


    ASPECT_NAME = 'assertionInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionInfo")

    def __init__(self,
        type: Union[str, "AssertionTypeClass"],
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        datasetAssertion: Union[None, "DatasetAssertionInfoClass"]=None,
        freshnessAssertion: Union[None, "FreshnessAssertionInfoClass"]=None,
        volumeAssertion: Union[None, "VolumeAssertionInfoClass"]=None,
        sqlAssertion: Union[None, "SqlAssertionInfoClass"]=None,
        fieldAssertion: Union[None, "FieldAssertionInfoClass"]=None,
        schemaAssertion: Union[None, "SchemaAssertionInfoClass"]=None,
        customAssertion: Union[None, "CustomAssertionInfoClass"]=None,
        source: Union[None, "AssertionSourceClass"]=None,
        lastUpdated: Union[None, "AuditStampClass"]=None,
        description: Union[None, str]=None,
        note: Union[None, "AssertionNoteClass"]=None,
        entityUrn: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.type = type
        self.datasetAssertion = datasetAssertion
        self.freshnessAssertion = freshnessAssertion
        self.volumeAssertion = volumeAssertion
        self.sqlAssertion = sqlAssertion
        self.fieldAssertion = fieldAssertion
        self.schemaAssertion = schemaAssertion
        self.customAssertion = customAssertion
        self.source = source
        self.lastUpdated = lastUpdated
        self.description = description
        self.note = note
        self.entityUrn = entityUrn
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.type = AssertionTypeClass.DATASET
        self.datasetAssertion = self.RECORD_SCHEMA.fields_dict["datasetAssertion"].default
        self.freshnessAssertion = self.RECORD_SCHEMA.fields_dict["freshnessAssertion"].default
        self.volumeAssertion = self.RECORD_SCHEMA.fields_dict["volumeAssertion"].default
        self.sqlAssertion = self.RECORD_SCHEMA.fields_dict["sqlAssertion"].default
        self.fieldAssertion = self.RECORD_SCHEMA.fields_dict["fieldAssertion"].default
        self.schemaAssertion = self.RECORD_SCHEMA.fields_dict["schemaAssertion"].default
        self.customAssertion = self.RECORD_SCHEMA.fields_dict["customAssertion"].default
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
        self.lastUpdated = self.RECORD_SCHEMA.fields_dict["lastUpdated"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.note = self.RECORD_SCHEMA.fields_dict["note"].default
        self.entityUrn = self.RECORD_SCHEMA.fields_dict["entityUrn"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def type(self) -> Union[str, "AssertionTypeClass"]:
        """Type of assertion."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def datasetAssertion(self) -> Union[None, "DatasetAssertionInfoClass"]:
        """A Dataset Assertion definition. This field is populated when the type is DATASET."""
        return self._inner_dict.get('datasetAssertion')  # type: ignore
    
    @datasetAssertion.setter
    def datasetAssertion(self, value: Union[None, "DatasetAssertionInfoClass"]) -> None:
        self._inner_dict['datasetAssertion'] = value
    
    
    @property
    def freshnessAssertion(self) -> Union[None, "FreshnessAssertionInfoClass"]:
        """An Freshness Assertion definition. This field is populated when the type is FRESHNESS."""
        return self._inner_dict.get('freshnessAssertion')  # type: ignore
    
    @freshnessAssertion.setter
    def freshnessAssertion(self, value: Union[None, "FreshnessAssertionInfoClass"]) -> None:
        self._inner_dict['freshnessAssertion'] = value
    
    
    @property
    def volumeAssertion(self) -> Union[None, "VolumeAssertionInfoClass"]:
        """An Volume Assertion definition. This field is populated when the type is VOLUME."""
        return self._inner_dict.get('volumeAssertion')  # type: ignore
    
    @volumeAssertion.setter
    def volumeAssertion(self, value: Union[None, "VolumeAssertionInfoClass"]) -> None:
        self._inner_dict['volumeAssertion'] = value
    
    
    @property
    def sqlAssertion(self) -> Union[None, "SqlAssertionInfoClass"]:
        """A SQL Assertion definition. This field is populated when the type is SQL."""
        return self._inner_dict.get('sqlAssertion')  # type: ignore
    
    @sqlAssertion.setter
    def sqlAssertion(self, value: Union[None, "SqlAssertionInfoClass"]) -> None:
        self._inner_dict['sqlAssertion'] = value
    
    
    @property
    def fieldAssertion(self) -> Union[None, "FieldAssertionInfoClass"]:
        """A Field Assertion definition. This field is populated when the type is FIELD."""
        return self._inner_dict.get('fieldAssertion')  # type: ignore
    
    @fieldAssertion.setter
    def fieldAssertion(self, value: Union[None, "FieldAssertionInfoClass"]) -> None:
        self._inner_dict['fieldAssertion'] = value
    
    
    @property
    def schemaAssertion(self) -> Union[None, "SchemaAssertionInfoClass"]:
        """An schema Assertion definition. This field is populated when the type is DATA_SCHEMA"""
        return self._inner_dict.get('schemaAssertion')  # type: ignore
    
    @schemaAssertion.setter
    def schemaAssertion(self, value: Union[None, "SchemaAssertionInfoClass"]) -> None:
        self._inner_dict['schemaAssertion'] = value
    
    
    @property
    def customAssertion(self) -> Union[None, "CustomAssertionInfoClass"]:
        """A Custom Assertion definition. This field is populated when type is CUSTOM."""
        return self._inner_dict.get('customAssertion')  # type: ignore
    
    @customAssertion.setter
    def customAssertion(self, value: Union[None, "CustomAssertionInfoClass"]) -> None:
        self._inner_dict['customAssertion'] = value
    
    
    @property
    def source(self) -> Union[None, "AssertionSourceClass"]:
        """The source or origin of the Assertion definition.
    
    If the source type of the Assertion is EXTERNAL, it is expected to have a corresponding dataPlatformInstance aspect detailing
    the platform where it was ingested from."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "AssertionSourceClass"]) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def lastUpdated(self) -> Union[None, "AuditStampClass"]:
        """The time at which the assertion was last updated and the actor who updated it.
    This field is only present for Native assertions updated after this field was introduced."""
        return self._inner_dict.get('lastUpdated')  # type: ignore
    
    @lastUpdated.setter
    def lastUpdated(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastUpdated'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """An optional human-readable description of the assertion"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def note(self) -> Union[None, "AssertionNoteClass"]:
        """An optional note to give technical owners more context about the assertion, and how to troubleshoot it.
    The UI will render this in markdown format."""
        return self._inner_dict.get('note')  # type: ignore
    
    @note.setter
    def note(self, value: Union[None, "AssertionNoteClass"]) -> None:
        self._inner_dict['note'] = value
    
    
    @property
    def entityUrn(self) -> Union[None, str]:
        """The entity targeted by this assertion. Newly added field, automatically set by mutation"""
        return self._inner_dict.get('entityUrn')  # type: ignore
    
    @entityUrn.setter
    def entityUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['entityUrn'] = value
    
    
class AssertionMetricClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionMetric")
    def __init__(self,
        timestampMs: int,
        value: float,
    ):
        super().__init__()
        
        self.timestampMs = timestampMs
        self.value = value
    
    def _restore_defaults(self) -> None:
        self.timestampMs = int()
        self.value = float()
    
    
    @property
    def timestampMs(self) -> int:
        """The timestamp associated with the metric sampling time in milliseconds since epoch"""
        return self._inner_dict.get('timestampMs')  # type: ignore
    
    @timestampMs.setter
    def timestampMs(self, value: int) -> None:
        self._inner_dict['timestampMs'] = value
    
    
    @property
    def value(self) -> float:
        """The value of the metric that was sampled"""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: float) -> None:
        self._inner_dict['value'] = value
    
    
class AssertionMonitorSensitivityClass(DictWrapper):
    """Assertion monitor sensitivity is a measure of how sensitive the assertion monitor is to the assertion condition."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionMonitorSensitivity")
    def __init__(self,
        level: int,
    ):
        super().__init__()
        
        self.level = level
    
    def _restore_defaults(self) -> None:
        self.level = int()
    
    
    @property
    def level(self) -> int:
        """The assertion monitor level from 0-10"""
        return self._inner_dict.get('level')  # type: ignore
    
    @level.setter
    def level(self, value: int) -> None:
        self._inner_dict['level'] = value
    
    
class AssertionNoteClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionNote")
    def __init__(self,
        content: str,
        lastModified: "AuditStampClass",
    ):
        super().__init__()
        
        self.content = content
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.content = str()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def content(self) -> str:
        """The note to give technical owners more context about the assertion, and how to troubleshoot it."""
        return self._inner_dict.get('content')  # type: ignore
    
    @content.setter
    def content(self, value: str) -> None:
        self._inner_dict['content'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """The time at which the note was last modified."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class AssertionResultClass(DictWrapper):
    """The result of running an assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionResult")
    def __init__(self,
        type: Union[str, "AssertionResultTypeClass"],
        assertion: Union[None, "AssertionInfoClass"]=None,
        baseAssertion: Union[None, "AssertionInfoClass"]=None,
        rowCount: Union[None, int]=None,
        missingCount: Union[None, int]=None,
        unexpectedCount: Union[None, int]=None,
        actualAggValue: Union[None, float]=None,
        nativeResults: Union[None, Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        error: Union[None, "AssertionResultErrorClass"]=None,
        parameters: Union[None, "AssertionEvaluationParametersClass"]=None,
        assertionInferenceDetails: Union[None, "AssertionInferenceDetailsClass"]=None,
        metric: Union[None, "AssertionMetricClass"]=None,
    ):
        super().__init__()
        
        self.assertion = assertion
        self.baseAssertion = baseAssertion
        self.type = type
        self.rowCount = rowCount
        self.missingCount = missingCount
        self.unexpectedCount = unexpectedCount
        self.actualAggValue = actualAggValue
        self.nativeResults = nativeResults
        self.externalUrl = externalUrl
        self.error = error
        self.parameters = parameters
        self.assertionInferenceDetails = assertionInferenceDetails
        self.metric = metric
    
    def _restore_defaults(self) -> None:
        self.assertion = self.RECORD_SCHEMA.fields_dict["assertion"].default
        self.baseAssertion = self.RECORD_SCHEMA.fields_dict["baseAssertion"].default
        self.type = AssertionResultTypeClass.INIT
        self.rowCount = self.RECORD_SCHEMA.fields_dict["rowCount"].default
        self.missingCount = self.RECORD_SCHEMA.fields_dict["missingCount"].default
        self.unexpectedCount = self.RECORD_SCHEMA.fields_dict["unexpectedCount"].default
        self.actualAggValue = self.RECORD_SCHEMA.fields_dict["actualAggValue"].default
        self.nativeResults = self.RECORD_SCHEMA.fields_dict["nativeResults"].default
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.error = self.RECORD_SCHEMA.fields_dict["error"].default
        self.parameters = self.RECORD_SCHEMA.fields_dict["parameters"].default
        self.assertionInferenceDetails = self.RECORD_SCHEMA.fields_dict["assertionInferenceDetails"].default
        self.metric = self.RECORD_SCHEMA.fields_dict["metric"].default
    
    
    @property
    def assertion(self) -> Union[None, "AssertionInfoClass"]:
        """Acryl Only! An assertion without any searchable or relationship annotations."""
        return self._inner_dict.get('assertion')  # type: ignore
    
    @assertion.setter
    def assertion(self, value: Union[None, "AssertionInfoClass"]) -> None:
        self._inner_dict['assertion'] = value
    
    
    @property
    def baseAssertion(self) -> Union[None, "AssertionInfoClass"]:
        """The optional AssertionInfo which contains the original/untransformed assertion that was predicted.
    This field is used to store the original assertion that was made before the evaluation process.
    It is optional and may not always be present in the AssertionRunEvent record.
    When present, it provides additional context about the original assertion that was made.
    
    Acryl Only! An assertion without any searchable or relationship annotations."""
        return self._inner_dict.get('baseAssertion')  # type: ignore
    
    @baseAssertion.setter
    def baseAssertion(self, value: Union[None, "AssertionInfoClass"]) -> None:
        self._inner_dict['baseAssertion'] = value
    
    
    @property
    def type(self) -> Union[str, "AssertionResultTypeClass"]:
        """ The final result, e.g. either SUCCESS, FAILURE, or ERROR."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionResultTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def rowCount(self) -> Union[None, int]:
        """Number of rows for evaluated batch"""
        return self._inner_dict.get('rowCount')  # type: ignore
    
    @rowCount.setter
    def rowCount(self, value: Union[None, int]) -> None:
        self._inner_dict['rowCount'] = value
    
    
    @property
    def missingCount(self) -> Union[None, int]:
        """Number of rows with missing value for evaluated batch"""
        return self._inner_dict.get('missingCount')  # type: ignore
    
    @missingCount.setter
    def missingCount(self, value: Union[None, int]) -> None:
        self._inner_dict['missingCount'] = value
    
    
    @property
    def unexpectedCount(self) -> Union[None, int]:
        """Number of rows with unexpected value for evaluated batch"""
        return self._inner_dict.get('unexpectedCount')  # type: ignore
    
    @unexpectedCount.setter
    def unexpectedCount(self, value: Union[None, int]) -> None:
        self._inner_dict['unexpectedCount'] = value
    
    
    @property
    def actualAggValue(self) -> Union[None, float]:
        """Observed aggregate value for evaluated batch"""
        return self._inner_dict.get('actualAggValue')  # type: ignore
    
    @actualAggValue.setter
    def actualAggValue(self, value: Union[None, float]) -> None:
        self._inner_dict['actualAggValue'] = value
    
    
    @property
    def nativeResults(self) -> Union[None, Dict[str, str]]:
        """Other results of evaluation"""
        return self._inner_dict.get('nativeResults')  # type: ignore
    
    @nativeResults.setter
    def nativeResults(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['nativeResults'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """External URL where full results are available. Only present when assertion source is not native."""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def error(self) -> Union[None, "AssertionResultErrorClass"]:
        """ The error object if AssertionResultType is an Error"""
        return self._inner_dict.get('error')  # type: ignore
    
    @error.setter
    def error(self, value: Union[None, "AssertionResultErrorClass"]) -> None:
        self._inner_dict['error'] = value
    
    
    @property
    def parameters(self) -> Union[None, "AssertionEvaluationParametersClass"]:
        """Acryl Only! The parameters that were used for running the assertion."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: Union[None, "AssertionEvaluationParametersClass"]) -> None:
        self._inner_dict['parameters'] = value
    
    
    @property
    def assertionInferenceDetails(self) -> Union[None, "AssertionInferenceDetailsClass"]:
        """The optional AssertionInferenceDetails which contains the settings used for the inferred assertion.
    This field is used to store the settings used for the smart assertion.
    It is optional and may not always be present in the AssertionRunEvent record.
    When present, it provides additional context about the settings used for the smart assertion."""
        return self._inner_dict.get('assertionInferenceDetails')  # type: ignore
    
    @assertionInferenceDetails.setter
    def assertionInferenceDetails(self, value: Union[None, "AssertionInferenceDetailsClass"]) -> None:
        self._inner_dict['assertionInferenceDetails'] = value
    
    
    @property
    def metric(self) -> Union[None, "AssertionMetricClass"]:
        """Information about the metric that was sampled & used when evaluating the assertion.
    
    Currently, this is only populated for Volume & Field Metric Assertions and used for anomaly
    logging for Smart Assertions."""
        return self._inner_dict.get('metric')  # type: ignore
    
    @metric.setter
    def metric(self, value: Union[None, "AssertionMetricClass"]) -> None:
        self._inner_dict['metric'] = value
    
    
class AssertionResultErrorClass(DictWrapper):
    """ An error encountered when evaluating an AssertionResult"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionResultError")
    def __init__(self,
        type: Union[str, "AssertionResultErrorTypeClass"],
        properties: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.type = type
        self.properties = properties
    
    def _restore_defaults(self) -> None:
        self.type = AssertionResultErrorTypeClass.SOURCE_CONNECTION_ERROR
        self.properties = self.RECORD_SCHEMA.fields_dict["properties"].default
    
    
    @property
    def type(self) -> Union[str, "AssertionResultErrorTypeClass"]:
        """ The type of error encountered"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionResultErrorTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def properties(self) -> Union[None, Dict[str, str]]:
        """ Additional metadata depending on the type of error"""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['properties'] = value
    
    
class AssertionResultErrorTypeClass(object):
    # No docs available.
    
    SOURCE_CONNECTION_ERROR = "SOURCE_CONNECTION_ERROR"
    """ Source is unreachable"""
    
    SOURCE_QUERY_FAILED = "SOURCE_QUERY_FAILED"
    """ Source query failed to execute"""
    
    INSUFFICIENT_DATA = "INSUFFICIENT_DATA"
    """ Insufficient data to evaluate the assertion"""
    
    INVALID_PARAMETERS = "INVALID_PARAMETERS"
    """ Invalid parameters were detected"""
    
    INVALID_SOURCE_TYPE = "INVALID_SOURCE_TYPE"
    """ Event type not supported by the specified source"""
    
    UNSUPPORTED_PLATFORM = "UNSUPPORTED_PLATFORM"
    """ Unsupported platform"""
    
    CUSTOM_SQL_ERROR = "CUSTOM_SQL_ERROR"
    """ Error while executing a custom SQL assertion"""
    
    FIELD_ASSERTION_ERROR = "FIELD_ASSERTION_ERROR"
    """ Error while executing a field assertion"""
    
    UNKNOWN_ERROR = "UNKNOWN_ERROR"
    """ Unknown error"""
    
    
    
class AssertionResultTypeClass(object):
    """ The final result of evaluating an assertion, e.g. SUCCESS, FAILURE, or ERROR."""
    
    INIT = "INIT"
    """ The Assertion has not yet been fully evaluated"""
    
    SUCCESS = "SUCCESS"
    """ The Assertion Succeeded"""
    
    FAILURE = "FAILURE"
    """ The Assertion Failed"""
    
    ERROR = "ERROR"
    """ The Assertion encountered an Error"""
    
    
    
class AssertionRunEventClass(_Aspect):
    """An event representing the current status of evaluating an assertion on a batch.
    AssertionRunEvent should be used for reporting the status of a run as an assertion evaluation progresses."""


    ASPECT_NAME = 'assertionRunEvent'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionRunEvent")

    def __init__(self,
        timestampMillis: int,
        runId: str,
        asserteeUrn: str,
        status: Union[str, "AssertionRunStatusClass"],
        assertionUrn: str,
        result: Union[None, "AssertionResultClass"]=None,
        runtimeContext: Union[None, Dict[str, str]]=None,
        batchSpec: Union[None, "BatchSpecClass"]=None,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.runId = runId
        self.asserteeUrn = asserteeUrn
        self.status = status
        self.result = result
        self.runtimeContext = runtimeContext
        self.batchSpec = batchSpec
        self.assertionUrn = assertionUrn
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.runId = str()
        self.asserteeUrn = str()
        self.status = AssertionRunStatusClass.COMPLETE
        self.result = self.RECORD_SCHEMA.fields_dict["result"].default
        self.runtimeContext = self.RECORD_SCHEMA.fields_dict["runtimeContext"].default
        self.batchSpec = self.RECORD_SCHEMA.fields_dict["batchSpec"].default
        self.assertionUrn = str()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milliseconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def runId(self) -> str:
        """ Native (platform-specific) identifier for this run"""
        return self._inner_dict.get('runId')  # type: ignore
    
    @runId.setter
    def runId(self, value: str) -> None:
        self._inner_dict['runId'] = value
    
    
    @property
    def asserteeUrn(self) -> str:
        # No docs available.
        return self._inner_dict.get('asserteeUrn')  # type: ignore
    
    @asserteeUrn.setter
    def asserteeUrn(self, value: str) -> None:
        self._inner_dict['asserteeUrn'] = value
    
    
    @property
    def status(self) -> Union[str, "AssertionRunStatusClass"]:
        """The status of the assertion run as per this timeseries event."""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "AssertionRunStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def result(self) -> Union[None, "AssertionResultClass"]:
        """Results of assertion, present if the status is COMPLETE"""
        return self._inner_dict.get('result')  # type: ignore
    
    @result.setter
    def result(self, value: Union[None, "AssertionResultClass"]) -> None:
        self._inner_dict['result'] = value
    
    
    @property
    def runtimeContext(self) -> Union[None, Dict[str, str]]:
        """Runtime parameters of evaluation"""
        return self._inner_dict.get('runtimeContext')  # type: ignore
    
    @runtimeContext.setter
    def runtimeContext(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['runtimeContext'] = value
    
    
    @property
    def batchSpec(self) -> Union[None, "BatchSpecClass"]:
        """Specification of the batch which this run is evaluating"""
        return self._inner_dict.get('batchSpec')  # type: ignore
    
    @batchSpec.setter
    def batchSpec(self, value: Union[None, "BatchSpecClass"]) -> None:
        self._inner_dict['batchSpec'] = value
    
    
    @property
    def assertionUrn(self) -> str:
        # No docs available.
        return self._inner_dict.get('assertionUrn')  # type: ignore
    
    @assertionUrn.setter
    def assertionUrn(self, value: str) -> None:
        self._inner_dict['assertionUrn'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
class AssertionRunStatusClass(object):
    """The lifecycle status of an assertion run."""
    
    COMPLETE = "COMPLETE"
    """The Assertion Run has completed"""
    
    
    
class AssertionRunSummaryClass(_Aspect):
    """Derived.
    Tracks the latest summary details of an assertion."""


    ASPECT_NAME = 'assertionRunSummary'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionRunSummary")

    def __init__(self,
        lastFailedAtMillis: Union[None, int]=None,
        lastErroredAtMillis: Union[None, int]=None,
        lastPassedAtMillis: Union[None, int]=None,
        lastInitializedAtMillis: Union[None, int]=None,
    ):
        super().__init__()
        
        self.lastFailedAtMillis = lastFailedAtMillis
        self.lastErroredAtMillis = lastErroredAtMillis
        self.lastPassedAtMillis = lastPassedAtMillis
        self.lastInitializedAtMillis = lastInitializedAtMillis
    
    def _restore_defaults(self) -> None:
        self.lastFailedAtMillis = self.RECORD_SCHEMA.fields_dict["lastFailedAtMillis"].default
        self.lastErroredAtMillis = self.RECORD_SCHEMA.fields_dict["lastErroredAtMillis"].default
        self.lastPassedAtMillis = self.RECORD_SCHEMA.fields_dict["lastPassedAtMillis"].default
        self.lastInitializedAtMillis = self.RECORD_SCHEMA.fields_dict["lastInitializedAtMillis"].default
    
    
    @property
    def lastFailedAtMillis(self) -> Union[None, int]:
        """The last failure event timestamp field as epoch at UTC in milliseconds."""
        return self._inner_dict.get('lastFailedAtMillis')  # type: ignore
    
    @lastFailedAtMillis.setter
    def lastFailedAtMillis(self, value: Union[None, int]) -> None:
        self._inner_dict['lastFailedAtMillis'] = value
    
    
    @property
    def lastErroredAtMillis(self) -> Union[None, int]:
        """The last error event timestamp field as epoch at UTC in milliseconds."""
        return self._inner_dict.get('lastErroredAtMillis')  # type: ignore
    
    @lastErroredAtMillis.setter
    def lastErroredAtMillis(self, value: Union[None, int]) -> None:
        self._inner_dict['lastErroredAtMillis'] = value
    
    
    @property
    def lastPassedAtMillis(self) -> Union[None, int]:
        """The last pass event timestamp field as epoch at UTC in milliseconds."""
        return self._inner_dict.get('lastPassedAtMillis')  # type: ignore
    
    @lastPassedAtMillis.setter
    def lastPassedAtMillis(self, value: Union[None, int]) -> None:
        self._inner_dict['lastPassedAtMillis'] = value
    
    
    @property
    def lastInitializedAtMillis(self) -> Union[None, int]:
        """The last initialized event timestamp field as epoch at UTC in milliseconds."""
        return self._inner_dict.get('lastInitializedAtMillis')  # type: ignore
    
    @lastInitializedAtMillis.setter
    def lastInitializedAtMillis(self, value: Union[None, int]) -> None:
        self._inner_dict['lastInitializedAtMillis'] = value
    
    
class AssertionSourceClass(DictWrapper):
    """The source of an assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionSource")
    def __init__(self,
        type: Union[str, "AssertionSourceTypeClass"],
        created: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.created = created
    
    def _restore_defaults(self) -> None:
        self.type = AssertionSourceTypeClass.NATIVE
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
    
    
    @property
    def type(self) -> Union[str, "AssertionSourceTypeClass"]:
        """The type of the Assertion Source"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionSourceTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """The time at which the assertion was initially created and the author who created it.
    This field is only present for Native assertions created after this field was introduced."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
class AssertionSourceTypeClass(object):
    # No docs available.
    
    NATIVE = "NATIVE"
    """The assertion was defined natively on DataHub by a user.
    DataHub Cloud only"""
    
    EXTERNAL = "EXTERNAL"
    """The assertion was defined and managed externally of DataHub."""
    
    INFERRED = "INFERRED"
    """The assertion was inferred, e.g. from offline AI / ML models.
    DataHub Cloud only"""
    
    
    
class AssertionStdAggregationClass(object):
    """The function that is applied to the aggregation input (schema, rows, column values) before evaluating an operator."""
    
    ROW_COUNT = "ROW_COUNT"
    """Assertion is applied on number of rows."""
    
    COLUMNS = "COLUMNS"
    """Assertion is applied on all columns."""
    
    COLUMN_COUNT = "COLUMN_COUNT"
    """Assertion is applied on number of columns."""
    
    IDENTITY = "IDENTITY"
    """Assertion is applied on individual column value. (No aggregation)"""
    
    MEAN = "MEAN"
    """Assertion is applied on column mean"""
    
    MEDIAN = "MEDIAN"
    """Assertion is applied on column median"""
    
    UNIQUE_COUNT = "UNIQUE_COUNT"
    """Assertion is applied on number of distinct values in column"""
    
    UNIQUE_PROPORTION = "UNIQUE_PROPORTION"
    """Assertion is applied on proportion of distinct values in column"""
    
    UNIQUE_PROPOTION = "UNIQUE_PROPOTION"
    """Assertion is applied on proportion of distinct values in column
    
    Deprecated! Use UNIQUE_PROPORTION instead."""
    
    NULL_COUNT = "NULL_COUNT"
    """Assertion is applied on number of null values in column"""
    
    NULL_PROPORTION = "NULL_PROPORTION"
    """Assertion is applied on proportion of null values in column"""
    
    STDDEV = "STDDEV"
    """Assertion is applied on column std deviation"""
    
    MIN = "MIN"
    """Assertion is applied on column min"""
    
    MAX = "MAX"
    """Assertion is applied on column std deviation"""
    
    SUM = "SUM"
    """Assertion is applied on column sum"""
    
    _NATIVE_ = "_NATIVE_"
    """Other"""
    
    
    
class AssertionStdOperatorClass(object):
    """A boolean operator that is applied on the input to an assertion, after an aggregation function has been applied."""
    
    BETWEEN = "BETWEEN"
    """Value being asserted is between min_value and max_value.  Requires 'minValue' & 'maxValue' parameters."""
    
    LESS_THAN = "LESS_THAN"
    """Value being asserted is less than a max value. Requires 'value' parameter."""
    
    LESS_THAN_OR_EQUAL_TO = "LESS_THAN_OR_EQUAL_TO"
    """Value being asserted is less than or equal to some value. Requires 'value' parameter."""
    
    GREATER_THAN = "GREATER_THAN"
    """Value being asserted is greater than some value. Requires 'value' parameter."""
    
    GREATER_THAN_OR_EQUAL_TO = "GREATER_THAN_OR_EQUAL_TO"
    """Value being asserted is greater than or equal to some value. Requires 'value' parameter."""
    
    EQUAL_TO = "EQUAL_TO"
    """Value being asserted is equal to value. Requires 'value' parameter."""
    
    NOT_EQUAL_TO = "NOT_EQUAL_TO"
    """Value being asserted is not equal to value. Requires 'value' parameter."""
    
    NULL = "NULL"
    """Value being asserted is null. Requires no parameters."""
    
    NOT_NULL = "NOT_NULL"
    """Value being asserted is not null. Requires no parameters."""
    
    CONTAIN = "CONTAIN"
    """Value being asserted contains value. Requires 'value' parameter."""
    
    END_WITH = "END_WITH"
    """Value being asserted ends with value. Requires 'value' parameter."""
    
    START_WITH = "START_WITH"
    """Value being asserted starts with value. Requires 'value' parameter."""
    
    REGEX_MATCH = "REGEX_MATCH"
    """Value being asserted matches the regex value. Requires 'value' parameter."""
    
    IN = "IN"
    """Value being asserted is one of the array values. Requires 'value' parameter."""
    
    NOT_IN = "NOT_IN"
    """Value being asserted is not in one of the array values. Requires 'value' parameter."""
    
    IS_TRUE = "IS_TRUE"
    """Value being asserted is true. Requires no parameters."""
    
    IS_FALSE = "IS_FALSE"
    """Value being asserted is false. Requires no parameters."""
    
    _NATIVE_ = "_NATIVE_"
    """Other"""
    
    
    
class AssertionStdParameterClass(DictWrapper):
    """Single parameter for AssertionStdOperators."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionStdParameter")
    def __init__(self,
        value: str,
        type: Union[str, "AssertionStdParameterTypeClass"],
    ):
        super().__init__()
        
        self.value = value
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.value = str()
        self.type = AssertionStdParameterTypeClass.STRING
    
    
    @property
    def value(self) -> str:
        """The parameter value"""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: str) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def type(self) -> Union[str, "AssertionStdParameterTypeClass"]:
        """The type of the parameter"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionStdParameterTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class AssertionStdParameterTypeClass(object):
    # No docs available.
    
    STRING = "STRING"
    """A string value"""
    
    NUMBER = "NUMBER"
    """A numeric value"""
    
    LIST = "LIST"
    """A list of values. When used, value should be formatted as a serialized JSON array."""
    
    SET = "SET"
    """A set of values. When used, value should be formatted as a serialized JSON array."""
    
    SQL = "SQL"
    """A SQL expression"""
    
    UNKNOWN = "UNKNOWN"
    """A value of unknown type"""
    
    
    
class AssertionStdParametersClass(DictWrapper):
    """Parameters for AssertionStdOperators."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.AssertionStdParameters")
    def __init__(self,
        value: Union[None, "AssertionStdParameterClass"]=None,
        maxValue: Union[None, "AssertionStdParameterClass"]=None,
        minValue: Union[None, "AssertionStdParameterClass"]=None,
    ):
        super().__init__()
        
        self.value = value
        self.maxValue = maxValue
        self.minValue = minValue
    
    def _restore_defaults(self) -> None:
        self.value = self.RECORD_SCHEMA.fields_dict["value"].default
        self.maxValue = self.RECORD_SCHEMA.fields_dict["maxValue"].default
        self.minValue = self.RECORD_SCHEMA.fields_dict["minValue"].default
    
    
    @property
    def value(self) -> Union[None, "AssertionStdParameterClass"]:
        """The value parameter of an assertion"""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: Union[None, "AssertionStdParameterClass"]) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def maxValue(self) -> Union[None, "AssertionStdParameterClass"]:
        """The maxValue parameter of an assertion"""
        return self._inner_dict.get('maxValue')  # type: ignore
    
    @maxValue.setter
    def maxValue(self, value: Union[None, "AssertionStdParameterClass"]) -> None:
        self._inner_dict['maxValue'] = value
    
    
    @property
    def minValue(self) -> Union[None, "AssertionStdParameterClass"]:
        """The minValue parameter of an assertion"""
        return self._inner_dict.get('minValue')  # type: ignore
    
    @minValue.setter
    def minValue(self, value: Union[None, "AssertionStdParameterClass"]) -> None:
        self._inner_dict['minValue'] = value
    
    
class AssertionTypeClass(object):
    """Type of assertion. Assertion types can evolve to span Datasets, Flows (Pipelines), Models, Features etc."""
    
    DATASET = "DATASET"
    """A single-dataset assertion.
    When this is the value, the datasetAssertion field will be populated."""
    
    FRESHNESS = "FRESHNESS"
    """A freshness assertion, or an assertion which indicates when a particular operation should occur
    to an asset."""
    
    VOLUME = "VOLUME"
    """A volume assertion, or an assertion which indicates how much data should be available for a
    particular asset."""
    
    SQL = "SQL"
    """A raw SQL-statement based assertion"""
    
    FIELD = "FIELD"
    """A structured assertion targeting a specific column or field of the Dataset."""
    
    DATA_SCHEMA = "DATA_SCHEMA"
    """A schema or structural assertion.
    
    Would have named this SCHEMA but the codegen for PDL does not allow this (reserved word)."""
    
    CUSTOM = "CUSTOM"
    """A custom assertion.
    When this is the value, the customAssertion field will be populated.
    Use this assertion type when the exact type of assertion is not modeled in DataHub or
    as a starting point when integrating third-party data quality tools."""
    
    
    
class AssertionValueChangeTypeClass(object):
    """An enum to represent a type of change in an assertion value, metric, or measurement."""
    
    ABSOLUTE = "ABSOLUTE"
    """A change that is defined in absolute terms."""
    
    PERCENTAGE = "PERCENTAGE"
    """A change that is defined in relative terms using percentage change
    from the original value."""
    
    
    
class BatchSpecClass(DictWrapper):
    """A batch on which certain operations, e.g. data quality evaluation, is done."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.BatchSpec")
    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        nativeBatchId: Union[None, str]=None,
        query: Union[None, str]=None,
        limit: Union[None, int]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.nativeBatchId = nativeBatchId
        self.query = query
        self.limit = limit
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.nativeBatchId = self.RECORD_SCHEMA.fields_dict["nativeBatchId"].default
        self.query = self.RECORD_SCHEMA.fields_dict["query"].default
        self.limit = self.RECORD_SCHEMA.fields_dict["limit"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def nativeBatchId(self) -> Union[None, str]:
        """The native identifier as specified by the system operating on the batch."""
        return self._inner_dict.get('nativeBatchId')  # type: ignore
    
    @nativeBatchId.setter
    def nativeBatchId(self, value: Union[None, str]) -> None:
        self._inner_dict['nativeBatchId'] = value
    
    
    @property
    def query(self) -> Union[None, str]:
        """A query that identifies a batch of data"""
        return self._inner_dict.get('query')  # type: ignore
    
    @query.setter
    def query(self, value: Union[None, str]) -> None:
        self._inner_dict['query'] = value
    
    
    @property
    def limit(self) -> Union[None, int]:
        """Any limit to the number of rows in the batch, if applied"""
        return self._inner_dict.get('limit')  # type: ignore
    
    @limit.setter
    def limit(self, value: Union[None, int]) -> None:
        self._inner_dict['limit'] = value
    
    
class CustomAssertionInfoClass(DictWrapper):
    """Attributes that are applicable to Custom Assertions"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.CustomAssertionInfo")
    def __init__(self,
        type: str,
        entity: str,
        field: Union[None, str]=None,
        logic: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.entity = entity
        self.field = field
        self.logic = logic
    
    def _restore_defaults(self) -> None:
        self.type = str()
        self.entity = str()
        self.field = self.RECORD_SCHEMA.fields_dict["field"].default
        self.logic = self.RECORD_SCHEMA.fields_dict["logic"].default
    
    
    @property
    def type(self) -> str:
        """The type of custom assertion.
    This is how your assertion will appear categorized in DataHub UI. """
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def entity(self) -> str:
        """The entity targeted by this assertion.
    This can have support more entityTypes (e.g. dataJob) in future"""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def field(self) -> Union[None, str]:
        """dataset schema field targeted by this assertion.
    
    This field is expected to be provided if the assertion is on dataset field"""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: Union[None, str]) -> None:
        self._inner_dict['field'] = value
    
    
    @property
    def logic(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('logic')  # type: ignore
    
    @logic.setter
    def logic(self, value: Union[None, str]) -> None:
        self._inner_dict['logic'] = value
    
    
class DatasetAssertionInfoClass(DictWrapper):
    """Attributes that are applicable to single-Dataset Assertions"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.DatasetAssertionInfo")
    def __init__(self,
        dataset: str,
        scope: Union[str, "DatasetAssertionScopeClass"],
        operator: Union[str, "AssertionStdOperatorClass"],
        fields: Union[None, List[str]]=None,
        aggregation: Union[None, Union[str, "AssertionStdAggregationClass"]]=None,
        parameters: Union[None, "AssertionStdParametersClass"]=None,
        nativeType: Union[None, str]=None,
        nativeParameters: Union[None, Dict[str, str]]=None,
        logic: Union[None, str]=None,
    ):
        super().__init__()
        
        self.dataset = dataset
        self.scope = scope
        self.fields = fields
        self.aggregation = aggregation
        self.operator = operator
        self.parameters = parameters
        self.nativeType = nativeType
        self.nativeParameters = nativeParameters
        self.logic = logic
    
    def _restore_defaults(self) -> None:
        self.dataset = str()
        self.scope = DatasetAssertionScopeClass.DATASET_COLUMN
        self.fields = self.RECORD_SCHEMA.fields_dict["fields"].default
        self.aggregation = self.RECORD_SCHEMA.fields_dict["aggregation"].default
        self.operator = AssertionStdOperatorClass.BETWEEN
        self.parameters = self.RECORD_SCHEMA.fields_dict["parameters"].default
        self.nativeType = self.RECORD_SCHEMA.fields_dict["nativeType"].default
        self.nativeParameters = self.RECORD_SCHEMA.fields_dict["nativeParameters"].default
        self.logic = self.RECORD_SCHEMA.fields_dict["logic"].default
    
    
    @property
    def dataset(self) -> str:
        """The dataset targeted by this assertion."""
        return self._inner_dict.get('dataset')  # type: ignore
    
    @dataset.setter
    def dataset(self, value: str) -> None:
        self._inner_dict['dataset'] = value
    
    
    @property
    def scope(self) -> Union[str, "DatasetAssertionScopeClass"]:
        """Scope of the Assertion. What part of the dataset does this assertion apply to?"""
        return self._inner_dict.get('scope')  # type: ignore
    
    @scope.setter
    def scope(self, value: Union[str, "DatasetAssertionScopeClass"]) -> None:
        self._inner_dict['scope'] = value
    
    
    @property
    def fields(self) -> Union[None, List[str]]:
        """One or more dataset schema fields that are targeted by this assertion.
    
    This field is expected to be provided if the assertion scope is DATASET_COLUMN."""
        return self._inner_dict.get('fields')  # type: ignore
    
    @fields.setter
    def fields(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['fields'] = value
    
    
    @property
    def aggregation(self) -> Union[None, Union[str, "AssertionStdAggregationClass"]]:
        """Standardized assertion operator
    This field is left blank if there is no selected aggregation or metric for a particular column."""
        return self._inner_dict.get('aggregation')  # type: ignore
    
    @aggregation.setter
    def aggregation(self, value: Union[None, Union[str, "AssertionStdAggregationClass"]]) -> None:
        self._inner_dict['aggregation'] = value
    
    
    @property
    def operator(self) -> Union[str, "AssertionStdOperatorClass"]:
        """Standardized assertion operator"""
        return self._inner_dict.get('operator')  # type: ignore
    
    @operator.setter
    def operator(self, value: Union[str, "AssertionStdOperatorClass"]) -> None:
        self._inner_dict['operator'] = value
    
    
    @property
    def parameters(self) -> Union[None, "AssertionStdParametersClass"]:
        """Standard parameters required for the assertion. e.g. min_value, max_value, value, columns"""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: Union[None, "AssertionStdParametersClass"]) -> None:
        self._inner_dict['parameters'] = value
    
    
    @property
    def nativeType(self) -> Union[None, str]:
        """Native assertion type"""
        return self._inner_dict.get('nativeType')  # type: ignore
    
    @nativeType.setter
    def nativeType(self, value: Union[None, str]) -> None:
        self._inner_dict['nativeType'] = value
    
    
    @property
    def nativeParameters(self) -> Union[None, Dict[str, str]]:
        """Native parameters required for the assertion."""
        return self._inner_dict.get('nativeParameters')  # type: ignore
    
    @nativeParameters.setter
    def nativeParameters(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['nativeParameters'] = value
    
    
    @property
    def logic(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('logic')  # type: ignore
    
    @logic.setter
    def logic(self, value: Union[None, str]) -> None:
        self._inner_dict['logic'] = value
    
    
class DatasetAssertionScopeClass(object):
    # No docs available.
    
    DATASET_COLUMN = "DATASET_COLUMN"
    """This assertion applies to dataset column(s)"""
    
    DATASET_ROWS = "DATASET_ROWS"
    """This assertion applies to entire rows of the dataset"""
    
    DATASET_STORAGE_SIZE = "DATASET_STORAGE_SIZE"
    """This assertion applies to the storage size of the dataset"""
    
    DATASET_SCHEMA = "DATASET_SCHEMA"
    """This assertion applies to the schema of the dataset"""
    
    UNKNOWN = "UNKNOWN"
    """The scope of the assertion is unknown"""
    
    
    
class FieldAssertionInfoClass(DictWrapper):
    """Attributes defining a Field Assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FieldAssertionInfo")
    def __init__(self,
        type: Union[str, "FieldAssertionTypeClass"],
        entity: str,
        fieldValuesAssertion: Union[None, "FieldValuesAssertionClass"]=None,
        fieldMetricAssertion: Union[None, "FieldMetricAssertionClass"]=None,
        filter: Union[None, "DatasetFilterClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.entity = entity
        self.fieldValuesAssertion = fieldValuesAssertion
        self.fieldMetricAssertion = fieldMetricAssertion
        self.filter = filter
    
    def _restore_defaults(self) -> None:
        self.type = FieldAssertionTypeClass.FIELD_VALUES
        self.entity = str()
        self.fieldValuesAssertion = self.RECORD_SCHEMA.fields_dict["fieldValuesAssertion"].default
        self.fieldMetricAssertion = self.RECORD_SCHEMA.fields_dict["fieldMetricAssertion"].default
        self.filter = self.RECORD_SCHEMA.fields_dict["filter"].default
    
    
    @property
    def type(self) -> Union[str, "FieldAssertionTypeClass"]:
        """The type of the field assertion being monitored."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "FieldAssertionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def entity(self) -> str:
        """The entity targeted by this Field check."""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def fieldValuesAssertion(self) -> Union[None, "FieldValuesAssertionClass"]:
        """The definition of an assertion that validates individual values of a field / column for a set of rows.
    This type of assertion verifies that each column value meets a particular requirement."""
        return self._inner_dict.get('fieldValuesAssertion')  # type: ignore
    
    @fieldValuesAssertion.setter
    def fieldValuesAssertion(self, value: Union[None, "FieldValuesAssertionClass"]) -> None:
        self._inner_dict['fieldValuesAssertion'] = value
    
    
    @property
    def fieldMetricAssertion(self) -> Union[None, "FieldMetricAssertionClass"]:
        """The definition of an assertion that validates a common metric obtained about a field / column for a set of rows.
    This type of assertion verifies that the value of a high-level metric obtained by aggregating over a column meets
    expectations"""
        return self._inner_dict.get('fieldMetricAssertion')  # type: ignore
    
    @fieldMetricAssertion.setter
    def fieldMetricAssertion(self, value: Union[None, "FieldMetricAssertionClass"]) -> None:
        self._inner_dict['fieldMetricAssertion'] = value
    
    
    @property
    def filter(self) -> Union[None, "DatasetFilterClass"]:
        """A definition of the specific filters that should be applied, when performing monitoring.
    If not provided, there is no filter, and the full table is under consideration.
    If using DataHub Dataset Profiles as the assertion source type, the value of this field will be ignored."""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: Union[None, "DatasetFilterClass"]) -> None:
        self._inner_dict['filter'] = value
    
    
class FieldAssertionTypeClass(object):
    # No docs available.
    
    FIELD_VALUES = "FIELD_VALUES"
    """An assertion used to validate the values contained with a field / column given a set of rows."""
    
    FIELD_METRIC = "FIELD_METRIC"
    """An assertion used to validate the value of a common field / column metric (e.g. aggregation) such as null count + percentage,
    min, max, median, and more."""
    
    
    
class FieldMetricAssertionClass(DictWrapper):
    """Attributes defining a field metric assertion, which asserts an expectation against
    a common metric derived from the set of field / column values, for example:
    max, min, median, null count, null percentage, unique count, unique percentage, and more."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FieldMetricAssertion")
    def __init__(self,
        field: "SchemaFieldSpecClass",
        metric: Union[str, "FieldMetricTypeClass"],
        operator: Union[str, "AssertionStdOperatorClass"],
        parameters: Union[None, "AssertionStdParametersClass"]=None,
    ):
        super().__init__()
        
        self.field = field
        self.metric = metric
        self.operator = operator
        self.parameters = parameters
    
    def _restore_defaults(self) -> None:
        self.field = SchemaFieldSpecClass._construct_with_defaults()
        self.metric = FieldMetricTypeClass.UNIQUE_COUNT
        self.operator = AssertionStdOperatorClass.BETWEEN
        self.parameters = self.RECORD_SCHEMA.fields_dict["parameters"].default
    
    
    @property
    def field(self) -> "SchemaFieldSpecClass":
        """The field path under evaluation"""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: "SchemaFieldSpecClass") -> None:
        self._inner_dict['field'] = value
    
    
    @property
    def metric(self) -> Union[str, "FieldMetricTypeClass"]:
        """The specific metric to assert against. This is the value that
    will be obtained by applying a standard operation, such as an aggregation,
    to the selected field."""
        return self._inner_dict.get('metric')  # type: ignore
    
    @metric.setter
    def metric(self, value: Union[str, "FieldMetricTypeClass"]) -> None:
        self._inner_dict['metric'] = value
    
    
    @property
    def operator(self) -> Union[str, "AssertionStdOperatorClass"]:
        """The predicate to evaluate against the metric for the field / column.
    Depending on the operator, parameters may be required in order to successfully
    evaluate the assertion against the metric value."""
        return self._inner_dict.get('operator')  # type: ignore
    
    @operator.setter
    def operator(self, value: Union[str, "AssertionStdOperatorClass"]) -> None:
        self._inner_dict['operator'] = value
    
    
    @property
    def parameters(self) -> Union[None, "AssertionStdParametersClass"]:
        """Standard parameters required for the assertion. e.g. min_value, max_value, value, columns"""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: Union[None, "AssertionStdParametersClass"]) -> None:
        self._inner_dict['parameters'] = value
    
    
class FieldMetricTypeClass(object):
    """A standard metric that can be derived from the set of values
    for a specific field / column of a dataset / table."""
    
    UNIQUE_COUNT = "UNIQUE_COUNT"
    """The number of unique values found in the column value set"""
    
    UNIQUE_PERCENTAGE = "UNIQUE_PERCENTAGE"
    """The percentage of unique values to total rows for the dataset"""
    
    NULL_COUNT = "NULL_COUNT"
    """The number of null values found in the column value set"""
    
    NULL_PERCENTAGE = "NULL_PERCENTAGE"
    """The percentage of null values to total rows for the dataset"""
    
    MIN = "MIN"
    """The minimum value in the column set (applies to numeric columns)"""
    
    MAX = "MAX"
    """The maximum value in the column set (applies to numeric columns)"""
    
    MEAN = "MEAN"
    """The mean length found in the column set (applies to numeric columns)"""
    
    MEDIAN = "MEDIAN"
    """The median length found in the column set (applies to numeric columns)"""
    
    STDDEV = "STDDEV"
    """The stddev length found in the column set (applies to numeric columns)"""
    
    NEGATIVE_COUNT = "NEGATIVE_COUNT"
    """The number of negative values found in the value set (applies to numeric columns)"""
    
    NEGATIVE_PERCENTAGE = "NEGATIVE_PERCENTAGE"
    """The percentage of negative values to total rows for the dataset (applies to numeric columns)"""
    
    ZERO_COUNT = "ZERO_COUNT"
    """The number of zero values found in the value set (applies to numeric columns)"""
    
    ZERO_PERCENTAGE = "ZERO_PERCENTAGE"
    """The percentage of zero values to total rows for the dataset (applies to numeric columns)"""
    
    MIN_LENGTH = "MIN_LENGTH"
    """The minimum length found in the column set (applies to string columns)"""
    
    MAX_LENGTH = "MAX_LENGTH"
    """The maximum length found in the column set (applies to string columns)"""
    
    EMPTY_COUNT = "EMPTY_COUNT"
    """The number of empty string values found in the value set (applies to string columns).
    Note: This is a completely different metric different from NULL_COUNT!"""
    
    EMPTY_PERCENTAGE = "EMPTY_PERCENTAGE"
    """The percentage of empty string values to total rows for the dataset (applies to string columns)
    Note: This is a completely different metric different from NULL_PERCENTAGE!"""
    
    
    
class FieldTransformClass(DictWrapper):
    """Definition of a transform applied to the values of a column / field.
    Note that the applicability of a field transform ultimately depends on the native type
    of the field / column.
    
    Model has single field to permit extension."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FieldTransform")
    def __init__(self,
        type: Union[str, "FieldTransformTypeClass"],
    ):
        super().__init__()
        
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.type = FieldTransformTypeClass.LENGTH
    
    
    @property
    def type(self) -> Union[str, "FieldTransformTypeClass"]:
        """The type of the field transform, e.g. the transformation
    function / operator to apply."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "FieldTransformTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class FieldTransformTypeClass(object):
    # No docs available.
    
    LENGTH = "LENGTH"
    """Obtain the length of a string field / column (applicable to string types)"""
    
    
    
class FieldValuesAssertionClass(DictWrapper):
    """Attributes defining a field values assertion, which asserts that the values for a field / column
    of a dataset / table matches a set of expectations.
    
    In other words, this type of assertion acts as a semantic constraint applied to fields for a specific column.
    
    TODO: We should display the "failed row count" to the user if the column fails the verification rules.
    TODO: Determine whether we need an "operator" that can be applied to the field."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FieldValuesAssertion")
    def __init__(self,
        field: "SchemaFieldSpecClass",
        operator: Union[str, "AssertionStdOperatorClass"],
        failThreshold: "FieldValuesFailThresholdClass",
        transform: Union[None, "FieldTransformClass"]=None,
        parameters: Union[None, "AssertionStdParametersClass"]=None,
        excludeNulls: Optional[bool]=None,
    ):
        super().__init__()
        
        self.field = field
        self.transform = transform
        self.operator = operator
        self.parameters = parameters
        self.failThreshold = failThreshold
        if excludeNulls is None:
            # default: True
            self.excludeNulls = self.RECORD_SCHEMA.fields_dict["excludeNulls"].default
        else:
            self.excludeNulls = excludeNulls
    
    def _restore_defaults(self) -> None:
        self.field = SchemaFieldSpecClass._construct_with_defaults()
        self.transform = self.RECORD_SCHEMA.fields_dict["transform"].default
        self.operator = AssertionStdOperatorClass.BETWEEN
        self.parameters = self.RECORD_SCHEMA.fields_dict["parameters"].default
        self.failThreshold = FieldValuesFailThresholdClass._construct_with_defaults()
        self.excludeNulls = self.RECORD_SCHEMA.fields_dict["excludeNulls"].default
    
    
    @property
    def field(self) -> "SchemaFieldSpecClass":
        """The field under evaluation"""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: "SchemaFieldSpecClass") -> None:
        self._inner_dict['field'] = value
    
    
    @property
    def transform(self) -> Union[None, "FieldTransformClass"]:
        """An optional transform to apply to field values
    before evaluating the operator.
    
    If none is applied, the field value will be compared as is."""
        return self._inner_dict.get('transform')  # type: ignore
    
    @transform.setter
    def transform(self, value: Union[None, "FieldTransformClass"]) -> None:
        self._inner_dict['transform'] = value
    
    
    @property
    def operator(self) -> Union[str, "AssertionStdOperatorClass"]:
        """The predicate to evaluate against a single value of the field.
    Depending on the operator, parameters may be required in order to successfully
    evaluate the assertion against the field value."""
        return self._inner_dict.get('operator')  # type: ignore
    
    @operator.setter
    def operator(self, value: Union[str, "AssertionStdOperatorClass"]) -> None:
        self._inner_dict['operator'] = value
    
    
    @property
    def parameters(self) -> Union[None, "AssertionStdParametersClass"]:
        """Standard parameters required for the assertion. e.g. min_value, max_value, value, columns"""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: Union[None, "AssertionStdParametersClass"]) -> None:
        self._inner_dict['parameters'] = value
    
    
    @property
    def failThreshold(self) -> "FieldValuesFailThresholdClass":
        """Additional customization about when the assertion
    should be officially considered failing."""
        return self._inner_dict.get('failThreshold')  # type: ignore
    
    @failThreshold.setter
    def failThreshold(self, value: "FieldValuesFailThresholdClass") -> None:
        self._inner_dict['failThreshold'] = value
    
    
    @property
    def excludeNulls(self) -> bool:
        """Whether to ignore or allow nulls when running the values assertion. (i.e.
    consider only non-null values) using operators OTHER than the IS_NULL operator.
    
    Defaults to true, allowing null values."""
        return self._inner_dict.get('excludeNulls')  # type: ignore
    
    @excludeNulls.setter
    def excludeNulls(self, value: bool) -> None:
        self._inner_dict['excludeNulls'] = value
    
    
class FieldValuesFailThresholdClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FieldValuesFailThreshold")
    def __init__(self,
        type: Optional[Union[str, "FieldValuesFailThresholdTypeClass"]]=None,
        value: Optional[int]=None,
    ):
        super().__init__()
        
        if type is None:
            # default: 'COUNT'
            self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        else:
            self.type = type
        if value is None:
            # default: 0
            self.value = self.RECORD_SCHEMA.fields_dict["value"].default
        else:
            self.value = value
    
    def _restore_defaults(self) -> None:
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        self.value = self.RECORD_SCHEMA.fields_dict["value"].default
    
    
    @property
    def type(self) -> Union[str, "FieldValuesFailThresholdTypeClass"]:
        """The type of failure threshold. Either based on the number
    of column values (rows) that fail the expectations, or the percentage
    of the total rows under consideration."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "FieldValuesFailThresholdTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def value(self) -> int:
        """By default this is 0, meaning that ALL column values (i.e. rows) must
    meet the defined expectations."""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: int) -> None:
        self._inner_dict['value'] = value
    
    
class FieldValuesFailThresholdTypeClass(object):
    # No docs available.
    
    COUNT = "COUNT"
    PERCENTAGE = "PERCENTAGE"
    
    
class FixedIntervalScheduleClass(DictWrapper):
    """Attributes defining a relative fixed interval SLA schedule."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FixedIntervalSchedule")
    def __init__(self,
        unit: Union[str, "CalendarIntervalClass"],
        multiple: Optional[int]=None,
    ):
        super().__init__()
        
        self.unit = unit
        if multiple is None:
            # default: 1
            self.multiple = self.RECORD_SCHEMA.fields_dict["multiple"].default
        else:
            self.multiple = multiple
    
    def _restore_defaults(self) -> None:
        self.unit = CalendarIntervalClass.SECOND
        self.multiple = self.RECORD_SCHEMA.fields_dict["multiple"].default
    
    
    @property
    def unit(self) -> Union[str, "CalendarIntervalClass"]:
        """Interval unit such as minute/hour/day etc."""
        return self._inner_dict.get('unit')  # type: ignore
    
    @unit.setter
    def unit(self, value: Union[str, "CalendarIntervalClass"]) -> None:
        self._inner_dict['unit'] = value
    
    
    @property
    def multiple(self) -> int:
        """How many units. Defaults to 1."""
        return self._inner_dict.get('multiple')  # type: ignore
    
    @multiple.setter
    def multiple(self, value: int) -> None:
        self._inner_dict['multiple'] = value
    
    
class FreshnessAssertionInfoClass(DictWrapper):
    """Attributes defining a Freshness Assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FreshnessAssertionInfo")
    def __init__(self,
        type: Union[str, "FreshnessAssertionTypeClass"],
        entity: str,
        schedule: Union[None, "FreshnessAssertionScheduleClass"]=None,
        filter: Union[None, "DatasetFilterClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.entity = entity
        self.schedule = schedule
        self.filter = filter
    
    def _restore_defaults(self) -> None:
        self.type = FreshnessAssertionTypeClass.DATASET_CHANGE
        self.entity = str()
        self.schedule = self.RECORD_SCHEMA.fields_dict["schedule"].default
        self.filter = self.RECORD_SCHEMA.fields_dict["filter"].default
    
    
    @property
    def type(self) -> Union[str, "FreshnessAssertionTypeClass"]:
        """The type of the freshness assertion being monitored."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "FreshnessAssertionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def entity(self) -> str:
        """The entity targeted by this Freshness check."""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def schedule(self) -> Union[None, "FreshnessAssertionScheduleClass"]:
        """Produce FAILURE Assertion Result if the asset is not updated on the cadence and within the time range described by the schedule."""
        return self._inner_dict.get('schedule')  # type: ignore
    
    @schedule.setter
    def schedule(self, value: Union[None, "FreshnessAssertionScheduleClass"]) -> None:
        self._inner_dict['schedule'] = value
    
    
    @property
    def filter(self) -> Union[None, "DatasetFilterClass"]:
        """A definition of the specific filters that should be applied, when performing monitoring.
    If not provided, there is no filter, and the full table is under consideration."""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: Union[None, "DatasetFilterClass"]) -> None:
        self._inner_dict['filter'] = value
    
    
class FreshnessAssertionScheduleClass(DictWrapper):
    """Attributes defining a single Freshness schedule."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FreshnessAssertionSchedule")
    def __init__(self,
        type: Union[str, "FreshnessAssertionScheduleTypeClass"],
        cron: Union[None, "FreshnessCronScheduleClass"]=None,
        fixedInterval: Union[None, "FixedIntervalScheduleClass"]=None,
        exclusions: Union[None, List["AssertionExclusionWindowClass"]]=None,
    ):
        super().__init__()
        
        self.type = type
        self.cron = cron
        self.fixedInterval = fixedInterval
        self.exclusions = exclusions
    
    def _restore_defaults(self) -> None:
        self.type = FreshnessAssertionScheduleTypeClass.CRON
        self.cron = self.RECORD_SCHEMA.fields_dict["cron"].default
        self.fixedInterval = self.RECORD_SCHEMA.fields_dict["fixedInterval"].default
        self.exclusions = self.RECORD_SCHEMA.fields_dict["exclusions"].default
    
    
    @property
    def type(self) -> Union[str, "FreshnessAssertionScheduleTypeClass"]:
        """The type of a Freshness Assertion Schedule.
    
    Once we support data-time-relative schedules (e.g. schedules relative to time partitions),
    we will add those schedule types here."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "FreshnessAssertionScheduleTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def cron(self) -> Union[None, "FreshnessCronScheduleClass"]:
        """A cron schedule. This field is required when type is CRON."""
        return self._inner_dict.get('cron')  # type: ignore
    
    @cron.setter
    def cron(self, value: Union[None, "FreshnessCronScheduleClass"]) -> None:
        self._inner_dict['cron'] = value
    
    
    @property
    def fixedInterval(self) -> Union[None, "FixedIntervalScheduleClass"]:
        """A fixed interval schedule. This field is required when type is FIXED_INTERVAL."""
        return self._inner_dict.get('fixedInterval')  # type: ignore
    
    @fixedInterval.setter
    def fixedInterval(self, value: Union[None, "FixedIntervalScheduleClass"]) -> None:
        self._inner_dict['fixedInterval'] = value
    
    
    @property
    def exclusions(self) -> Union[None, List["AssertionExclusionWindowClass"]]:
        """Blackout windows. Periods of time to exclude from the schedule."""
        return self._inner_dict.get('exclusions')  # type: ignore
    
    @exclusions.setter
    def exclusions(self, value: Union[None, List["AssertionExclusionWindowClass"]]) -> None:
        self._inner_dict['exclusions'] = value
    
    
class FreshnessAssertionScheduleTypeClass(object):
    # No docs available.
    
    CRON = "CRON"
    """A highly configurable recurring schedule which describes the times of events described
    by a CRON schedule, with the evaluation schedule assuming to be matching the cron schedule.
    
    In a CRON schedule type, we compute the look-back window to be the time between the last scheduled event
    and the current event (evaluation time). This means that the evaluation schedule must match exactly
    the schedule defined inside the cron schedule.
    
    For example, a CRON schedule defined as "0 8 * * *" would represent a schedule of "every day by 8am". Assuming
    that the assertion evaluation schedule is defined to match this, the freshness assertion would be evaluated in the following way:
    
        1. Compute the "last scheduled occurrence" of the event using the CRON schedule. For example, yesterday at 8am.
        2. Compute the bounds of a time window between the "last scheduled occurrence" (yesterday at 8am) until the "current occurrence" (today at 8am)
        3. Verify that the target event has occurred within the CRON-interval window.
        4. If the target event has occurred within the time window, then assertion passes.
        5. If the target event has not occurred within the time window, then the assertion fails."""
    
    FIXED_INTERVAL = "FIXED_INTERVAL"
    """A fixed interval which is used to compute a look-back window for use when evaluating the assertion relative
    to the Evaluation Time of the Assertion.
    
    To compute the valid look-back window, we subtract the fixed interval from the evaluation time. Then, we verify
    that the target event has occurred within that window.
    
    For example, a fixed interval of "24h" would represent a schedule of "in the last 24 hours".
    The 24 hour interval is relative to the evaluation time of the assertion. For example if we schedule the assertion
    to be evaluated each hour, we'd compute the result as follows:
    
        1. Subtract the fixed interval from the current time (Evaluation time) to compute the bounds of a fixed look-back window.
        2. Verify that the target event has occurred within the look-back window.
        3. If the target event has occurred within the time window, then assertion passes.
        4. If the target event has not occurred within the time window, then the assertion fails."""
    
    SINCE_THE_LAST_CHECK = "SINCE_THE_LAST_CHECK"
    """A stateful check that takes the last time this check ran to determine the look-back window.
    
    To compute the valid look-back- window, we start at the time the monitor last evaluated this assertion,
    and we end at the point in time the check is currently running.
    
    For example, let's say a Freshness assertion is of type SINCE_THE_LAST_CHECK, and the monitor is configured to
    run every day at 12:00am. Let's assume this assertion was last evaluated yesterday at 12:04am. We'd compute
    the result as follows:
    
        1. Get the timestamp for the last run of the monitor on this assertion.
        2. look_back_window_start_time = latest_monitor_run.timestampMillis [ie. 12:04a yesterday]
        3. look_back_window_end_time = nowMillis [ie. 12:02a today]
        4. If the target event has occurred within the window [ie. 12:04a yday to 12:02a today],
           then the assertion passes.
        5. If the target event has not occurred within the window, then the assertion fails."""
    
    
    
class FreshnessAssertionTypeClass(object):
    # No docs available.
    
    DATASET_CHANGE = "DATASET_CHANGE"
    """An Freshness based on Operations performed on a particular Dataset (insert, update, delete, etc) and sourced from an audit log, as
    opposed to based on the highest watermark in a timestamp column (e.g. a query). Only valid when entity is of type "dataset"."""
    
    DATA_JOB_RUN = "DATA_JOB_RUN"
    """An Freshness based on a successful execution of a Data Job."""
    
    
    
class FreshnessCronScheduleClass(DictWrapper):
    """Attributes defining a CRON-formatted schedule used for defining a freshness assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FreshnessCronSchedule")
    def __init__(self,
        cron: str,
        timezone: str,
        windowStartOffsetMs: Union[None, int]=None,
    ):
        super().__init__()
        
        self.cron = cron
        self.timezone = timezone
        self.windowStartOffsetMs = windowStartOffsetMs
    
    def _restore_defaults(self) -> None:
        self.cron = str()
        self.timezone = str()
        self.windowStartOffsetMs = self.RECORD_SCHEMA.fields_dict["windowStartOffsetMs"].default
    
    
    @property
    def cron(self) -> str:
        """A cron-formatted execution interval, as a cron string, e.g. 1 * * * *"""
        return self._inner_dict.get('cron')  # type: ignore
    
    @cron.setter
    def cron(self, value: str) -> None:
        self._inner_dict['cron'] = value
    
    
    @property
    def timezone(self) -> str:
        """Timezone in which the cron interval applies, e.g. America/Los Angeles"""
        return self._inner_dict.get('timezone')  # type: ignore
    
    @timezone.setter
    def timezone(self, value: str) -> None:
        self._inner_dict['timezone'] = value
    
    
    @property
    def windowStartOffsetMs(self) -> Union[None, int]:
        """An optional offset in milliseconds to SUBTRACT from the timestamp generated by the cron schedule
    to generate the lower bounds of the "freshness window", or the window of time in which an event must have occurred in order for the Freshness check
    to be considering passing.
    
    If left empty, the start of the SLA window will be the _end_ of the previously evaluated Freshness window."""
        return self._inner_dict.get('windowStartOffsetMs')  # type: ignore
    
    @windowStartOffsetMs.setter
    def windowStartOffsetMs(self, value: Union[None, int]) -> None:
        self._inner_dict['windowStartOffsetMs'] = value
    
    
class FreshnessFieldKindClass(object):
    # No docs available.
    
    LAST_MODIFIED = "LAST_MODIFIED"
    """Determine that a change has occurred by inspecting an last modified field which
    represents the last time at which a row was changed."""
    
    HIGH_WATERMARK = "HIGH_WATERMARK"
    """Determine that a change has occurred by inspecting a field which should be tracked as the
    "high watermark" for the table. This should be an ascending number or date field.
    
    If rows with this column have not been added since the previous check
    then the Freshness Assertion will fail."""
    
    
    
class FreshnessFieldSpecClass(DictWrapper):
    """Lightweight spec used for referencing a particular schema field that is used to compute
    a freshness signal or operation.
    TODO: Since this is now leveraged across assertions & metrics / operations, we should consider moving this to a common package."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.FreshnessFieldSpec")
    def __init__(self,
        path: str,
        type: str,
        nativeType: str,
        kind: Union[None, Union[str, "FreshnessFieldKindClass"]]=None,
    ):
        super().__init__()
        
        self.path = path
        self.type = type
        self.nativeType = nativeType
        self.kind = kind
    
    def _restore_defaults(self) -> None:
        self.path = str()
        self.type = str()
        self.nativeType = str()
        self.kind = self.RECORD_SCHEMA.fields_dict["kind"].default
    
    
    @property
    def path(self) -> str:
        """The field path"""
        return self._inner_dict.get('path')  # type: ignore
    
    @path.setter
    def path(self, value: str) -> None:
        self._inner_dict['path'] = value
    
    
    @property
    def type(self) -> str:
        """The DataHub standard schema field type."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def nativeType(self) -> str:
        """The native field type"""
        return self._inner_dict.get('nativeType')  # type: ignore
    
    @nativeType.setter
    def nativeType(self, value: str) -> None:
        self._inner_dict['nativeType'] = value
    
    
    @property
    def kind(self) -> Union[None, Union[str, "FreshnessFieldKindClass"]]:
        """The type of the field being used to verify the Freshness of the asset."""
        return self._inner_dict.get('kind')  # type: ignore
    
    @kind.setter
    def kind(self, value: Union[None, Union[str, "FreshnessFieldKindClass"]]) -> None:
        self._inner_dict['kind'] = value
    
    
class IncrementingSegmentFieldTransformerClass(DictWrapper):
    """The definition of the transformer function  that should be applied to a given field / column value in a dataset
    in order to determine the segment or bucket that it belongs to, which in turn is used to evaluate
    volume assertions."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.IncrementingSegmentFieldTransformer")
    def __init__(self,
        type: Union[str, "IncrementingSegmentFieldTransformerTypeClass"],
        nativeType: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.nativeType = nativeType
    
    def _restore_defaults(self) -> None:
        self.type = IncrementingSegmentFieldTransformerTypeClass.TIMESTAMP_MS_TO_MINUTE
        self.nativeType = self.RECORD_SCHEMA.fields_dict["nativeType"].default
    
    
    @property
    def type(self) -> Union[str, "IncrementingSegmentFieldTransformerTypeClass"]:
        """A 'standard' transformer type. Note that not all source systems will support all operators."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "IncrementingSegmentFieldTransformerTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def nativeType(self) -> Union[None, str]:
        """The 'native' transformer type, useful as a back door if a custom operator is required.
    This field is required if the type is NATIVE."""
        return self._inner_dict.get('nativeType')  # type: ignore
    
    @nativeType.setter
    def nativeType(self, value: Union[None, str]) -> None:
        self._inner_dict['nativeType'] = value
    
    
class IncrementingSegmentFieldTransformerTypeClass(object):
    # No docs available.
    
    TIMESTAMP_MS_TO_MINUTE = "TIMESTAMP_MS_TO_MINUTE"
    """Rounds a timestamp (in seconds) down to the start of the month."""
    
    TIMESTAMP_MS_TO_HOUR = "TIMESTAMP_MS_TO_HOUR"
    """Rounds a timestamp (in milliseconds) down to the nearest hour."""
    
    TIMESTAMP_MS_TO_DATE = "TIMESTAMP_MS_TO_DATE"
    """Rounds a timestamp (in milliseconds) down to the start of the day."""
    
    TIMESTAMP_MS_TO_MONTH = "TIMESTAMP_MS_TO_MONTH"
    """Rounds a timestamp (in milliseconds) down to the start of the month"""
    
    TIMESTAMP_MS_TO_YEAR = "TIMESTAMP_MS_TO_YEAR"
    """Rounds a timestamp (in milliseconds) down to the start of the year"""
    
    FLOOR = "FLOOR"
    """Rounds a numeric value down to the nearest integer."""
    
    CEILING = "CEILING"
    """Rounds a numeric value up to the nearest integer."""
    
    NATIVE = "NATIVE"
    """A backdoor to provide a native operator type specific to a given source system like
    Snowflake, Redshift, BQ, etc."""
    
    
    
class IncrementingSegmentRowCountChangeClass(DictWrapper):
    """Attributes defining an INCREMENTING_SEGMENT_ROW_COUNT_CHANGE volume assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.IncrementingSegmentRowCountChange")
    def __init__(self,
        segment: "IncrementingSegmentSpecClass",
        type: Union[str, "AssertionValueChangeTypeClass"],
        operator: Union[str, "AssertionStdOperatorClass"],
        parameters: "AssertionStdParametersClass",
    ):
        super().__init__()
        
        self.segment = segment
        self.type = type
        self.operator = operator
        self.parameters = parameters
    
    def _restore_defaults(self) -> None:
        self.segment = IncrementingSegmentSpecClass._construct_with_defaults()
        self.type = AssertionValueChangeTypeClass.ABSOLUTE
        self.operator = AssertionStdOperatorClass.BETWEEN
        self.parameters = AssertionStdParametersClass._construct_with_defaults()
    
    
    @property
    def segment(self) -> "IncrementingSegmentSpecClass":
        """A specification of how the 'segment' can be derived using a column and an optional transformer function."""
        return self._inner_dict.get('segment')  # type: ignore
    
    @segment.setter
    def segment(self, value: "IncrementingSegmentSpecClass") -> None:
        self._inner_dict['segment'] = value
    
    
    @property
    def type(self) -> Union[str, "AssertionValueChangeTypeClass"]:
        """The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionValueChangeTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def operator(self) -> Union[str, "AssertionStdOperatorClass"]:
        """The operator you'd like to apply to the row count value
    
    Note that only numeric operators are valid inputs:
    GREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,
    BETWEEN."""
        return self._inner_dict.get('operator')  # type: ignore
    
    @operator.setter
    def operator(self, value: Union[str, "AssertionStdOperatorClass"]) -> None:
        self._inner_dict['operator'] = value
    
    
    @property
    def parameters(self) -> "AssertionStdParametersClass":
        """The parameters you'd like to provide as input to the operator.
    
    Note that only numeric parameter types are valid inputs: NUMBER."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: "AssertionStdParametersClass") -> None:
        self._inner_dict['parameters'] = value
    
    
class IncrementingSegmentRowCountTotalClass(DictWrapper):
    """Attributes defining an INCREMENTING_SEGMENT_ROW_COUNT_TOTAL volume assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.IncrementingSegmentRowCountTotal")
    def __init__(self,
        segment: "IncrementingSegmentSpecClass",
        operator: Union[str, "AssertionStdOperatorClass"],
        parameters: "AssertionStdParametersClass",
    ):
        super().__init__()
        
        self.segment = segment
        self.operator = operator
        self.parameters = parameters
    
    def _restore_defaults(self) -> None:
        self.segment = IncrementingSegmentSpecClass._construct_with_defaults()
        self.operator = AssertionStdOperatorClass.BETWEEN
        self.parameters = AssertionStdParametersClass._construct_with_defaults()
    
    
    @property
    def segment(self) -> "IncrementingSegmentSpecClass":
        """A specification of how the 'segment' can be derived using a column and an optional transformer function."""
        return self._inner_dict.get('segment')  # type: ignore
    
    @segment.setter
    def segment(self, value: "IncrementingSegmentSpecClass") -> None:
        self._inner_dict['segment'] = value
    
    
    @property
    def operator(self) -> Union[str, "AssertionStdOperatorClass"]:
        """The operator you'd like to apply.
    
    Note that only numeric operators are valid inputs:
    GREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,
    BETWEEN."""
        return self._inner_dict.get('operator')  # type: ignore
    
    @operator.setter
    def operator(self, value: Union[str, "AssertionStdOperatorClass"]) -> None:
        self._inner_dict['operator'] = value
    
    
    @property
    def parameters(self) -> "AssertionStdParametersClass":
        """The parameters you'd like to provide as input to the operator.
    
    Note that only numeric parameter types are valid inputs: NUMBER."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: "AssertionStdParametersClass") -> None:
        self._inner_dict['parameters'] = value
    
    
class IncrementingSegmentSpecClass(DictWrapper):
    """Core attributes required to identify an incrementing segment in a table. This type is mainly useful
    for tables that constantly increase with new rows being added on a particular cadence (e.g. fact or event tables)
    
    An incrementing segment represents a logical chunk of data which is INSERTED
    into a dataset on a regular interval, along with the presence of a constantly-incrementing column
    value such as an event time, date partition, or last modified column.
    
    An incrementing segment is principally identified by 2 key attributes combined:
    
     1. A field or column that represents the incrementing value. New rows that are inserted will be identified using this column.
        Note that the value of this column may not by itself represent the "bucket" or the "segment" in which the row falls.
    
     2. [Optional] An transformer function that may be applied to the selected column value in order
        to obtain the final "segment identifier" or "bucket identifier". Rows that have the same value after applying the transformation
        will be grouped into the same segment, using which the final value (e.g. row count) will be determined."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.IncrementingSegmentSpec")
    def __init__(self,
        field: "SchemaFieldSpecClass",
        transformer: Union[None, "IncrementingSegmentFieldTransformerClass"]=None,
    ):
        super().__init__()
        
        self.field = field
        self.transformer = transformer
    
    def _restore_defaults(self) -> None:
        self.field = SchemaFieldSpecClass._construct_with_defaults()
        self.transformer = self.RECORD_SCHEMA.fields_dict["transformer"].default
    
    
    @property
    def field(self) -> "SchemaFieldSpecClass":
        """The field to use to generate segments. It must be constantly incrementing as new rows are inserted."""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: "SchemaFieldSpecClass") -> None:
        self._inner_dict['field'] = value
    
    
    @property
    def transformer(self) -> Union[None, "IncrementingSegmentFieldTransformerClass"]:
        """Optional transformer function to apply to the field in order to obtain the final segment or bucket identifier.
    If not provided, then no operator will be applied to the field. (identity function)"""
        return self._inner_dict.get('transformer')  # type: ignore
    
    @transformer.setter
    def transformer(self, value: Union[None, "IncrementingSegmentFieldTransformerClass"]) -> None:
        self._inner_dict['transformer'] = value
    
    
class RowCountChangeClass(DictWrapper):
    """Attributes defining a ROW_COUNT_CHANGE volume assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.RowCountChange")
    def __init__(self,
        type: Union[str, "AssertionValueChangeTypeClass"],
        operator: Union[str, "AssertionStdOperatorClass"],
        parameters: "AssertionStdParametersClass",
    ):
        super().__init__()
        
        self.type = type
        self.operator = operator
        self.parameters = parameters
    
    def _restore_defaults(self) -> None:
        self.type = AssertionValueChangeTypeClass.ABSOLUTE
        self.operator = AssertionStdOperatorClass.BETWEEN
        self.parameters = AssertionStdParametersClass._construct_with_defaults()
    
    
    @property
    def type(self) -> Union[str, "AssertionValueChangeTypeClass"]:
        """The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionValueChangeTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def operator(self) -> Union[str, "AssertionStdOperatorClass"]:
        """The operator you'd like to apply.
    
    Note that only numeric operators are valid inputs:
    GREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,
    BETWEEN."""
        return self._inner_dict.get('operator')  # type: ignore
    
    @operator.setter
    def operator(self, value: Union[str, "AssertionStdOperatorClass"]) -> None:
        self._inner_dict['operator'] = value
    
    
    @property
    def parameters(self) -> "AssertionStdParametersClass":
        """The parameters you'd like to provide as input to the operator.
    
    Note that only numeric parameter types are valid inputs: NUMBER."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: "AssertionStdParametersClass") -> None:
        self._inner_dict['parameters'] = value
    
    
class RowCountTotalClass(DictWrapper):
    """Attributes defining a ROW_COUNT_TOTAL volume assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.RowCountTotal")
    def __init__(self,
        operator: Union[str, "AssertionStdOperatorClass"],
        parameters: "AssertionStdParametersClass",
    ):
        super().__init__()
        
        self.operator = operator
        self.parameters = parameters
    
    def _restore_defaults(self) -> None:
        self.operator = AssertionStdOperatorClass.BETWEEN
        self.parameters = AssertionStdParametersClass._construct_with_defaults()
    
    
    @property
    def operator(self) -> Union[str, "AssertionStdOperatorClass"]:
        """The operator you'd like to apply.
    
    Note that only numeric operators are valid inputs:
    GREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,
    BETWEEN."""
        return self._inner_dict.get('operator')  # type: ignore
    
    @operator.setter
    def operator(self, value: Union[str, "AssertionStdOperatorClass"]) -> None:
        self._inner_dict['operator'] = value
    
    
    @property
    def parameters(self) -> "AssertionStdParametersClass":
        """The parameters you'd like to provide as input to the operator.
    
    Note that only numeric parameter types are valid inputs: NUMBER."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: "AssertionStdParametersClass") -> None:
        self._inner_dict['parameters'] = value
    
    
class SchemaAssertionCompatibilityClass(object):
    # No docs available.
    
    EXACT_MATCH = "EXACT_MATCH"
    """The actual schema must be exactly the same as the expected schema"""
    
    SUPERSET = "SUPERSET"
    """The actual schema must be a superset of the expected schema"""
    
    SUBSET = "SUBSET"
    """The actual schema must be a subset of the expected schema"""
    
    
    
class SchemaAssertionInfoClass(DictWrapper):
    """Attributes that are applicable to schema assertions"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.SchemaAssertionInfo")
    def __init__(self,
        entity: str,
        schema: "SchemaMetadataClass",
        compatibility: Optional[Union[Union[str, "SchemaAssertionCompatibilityClass"], None]]=None,
    ):
        super().__init__()
        
        self.entity = entity
        self.schema = schema
        if compatibility is None:
            # default: 'EXACT_MATCH'
            self.compatibility = self.RECORD_SCHEMA.fields_dict["compatibility"].default
        else:
            self.compatibility = compatibility
    
    def _restore_defaults(self) -> None:
        self.entity = str()
        self.schema = SchemaMetadataClass._construct_with_defaults()
        self.compatibility = self.RECORD_SCHEMA.fields_dict["compatibility"].default
    
    
    @property
    def entity(self) -> str:
        """The entity targeted by the assertion"""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def schema(self) -> "SchemaMetadataClass":
        """A definition of the expected structure for the asset
    
    Note that many of the fields of this model, especially those related to metadata (tags, terms)
    will go unused in this context."""
        return self._inner_dict.get('schema')  # type: ignore
    
    @schema.setter
    def schema(self, value: "SchemaMetadataClass") -> None:
        self._inner_dict['schema'] = value
    
    
    @property
    def compatibility(self) -> Union[Union[str, "SchemaAssertionCompatibilityClass"], None]:
        """The required compatibility level for the schema assertion to pass."""
        return self._inner_dict.get('compatibility')  # type: ignore
    
    @compatibility.setter
    def compatibility(self, value: Union[Union[str, "SchemaAssertionCompatibilityClass"], None]) -> None:
        self._inner_dict['compatibility'] = value
    
    
class SqlAssertionInfoClass(DictWrapper):
    """Attributes defining a SQL Assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.SqlAssertionInfo")
    def __init__(self,
        type: Union[str, "SqlAssertionTypeClass"],
        entity: str,
        statement: str,
        operator: Union[str, "AssertionStdOperatorClass"],
        parameters: "AssertionStdParametersClass",
        changeType: Union[None, Union[str, "AssertionValueChangeTypeClass"]]=None,
    ):
        super().__init__()
        
        self.type = type
        self.entity = entity
        self.statement = statement
        self.changeType = changeType
        self.operator = operator
        self.parameters = parameters
    
    def _restore_defaults(self) -> None:
        self.type = SqlAssertionTypeClass.METRIC
        self.entity = str()
        self.statement = str()
        self.changeType = self.RECORD_SCHEMA.fields_dict["changeType"].default
        self.operator = AssertionStdOperatorClass.BETWEEN
        self.parameters = AssertionStdParametersClass._construct_with_defaults()
    
    
    @property
    def type(self) -> Union[str, "SqlAssertionTypeClass"]:
        """The type of the SQL assertion being monitored."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "SqlAssertionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def entity(self) -> str:
        """The entity targeted by this SQL check."""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def statement(self) -> str:
        """The SQL statement to be executed when evaluating the assertion (or computing the metric).
    This should be a valid and complete statement, executable by itself.
    
    Usually this should be a SELECT query statement."""
        return self._inner_dict.get('statement')  # type: ignore
    
    @statement.setter
    def statement(self, value: str) -> None:
        self._inner_dict['statement'] = value
    
    
    @property
    def changeType(self) -> Union[None, Union[str, "AssertionValueChangeTypeClass"]]:
        """The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage.
    This value is required if the type is METRIC_CHANGE."""
        return self._inner_dict.get('changeType')  # type: ignore
    
    @changeType.setter
    def changeType(self, value: Union[None, Union[str, "AssertionValueChangeTypeClass"]]) -> None:
        self._inner_dict['changeType'] = value
    
    
    @property
    def operator(self) -> Union[str, "AssertionStdOperatorClass"]:
        """The operator you'd like to apply to the result of the SQL query.
    
    Note that at this time, only numeric operators are valid inputs:
    GREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,
    BETWEEN."""
        return self._inner_dict.get('operator')  # type: ignore
    
    @operator.setter
    def operator(self, value: Union[str, "AssertionStdOperatorClass"]) -> None:
        self._inner_dict['operator'] = value
    
    
    @property
    def parameters(self) -> "AssertionStdParametersClass":
        """The parameters you'd like to provide as input to the operator.
    
    Note that only numeric parameter types are valid inputs: NUMBER."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: "AssertionStdParametersClass") -> None:
        self._inner_dict['parameters'] = value
    
    
class SqlAssertionTypeClass(object):
    # No docs available.
    
    METRIC = "METRIC"
    """A SQL Metric Assertion, e.g. one based on a numeric value returned by an arbitrary SQL query."""
    
    METRIC_CHANGE = "METRIC_CHANGE"
    """A SQL assertion that is evaluated against the CHANGE in a metric assertion
    over time."""
    
    
    
class VolumeAssertionInfoClass(DictWrapper):
    """Attributes defining a dataset Volume Assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.assertion.VolumeAssertionInfo")
    def __init__(self,
        type: Union[str, "VolumeAssertionTypeClass"],
        entity: str,
        rowCountTotal: Union[None, "RowCountTotalClass"]=None,
        rowCountChange: Union[None, "RowCountChangeClass"]=None,
        incrementingSegmentRowCountTotal: Union[None, "IncrementingSegmentRowCountTotalClass"]=None,
        incrementingSegmentRowCountChange: Union[None, "IncrementingSegmentRowCountChangeClass"]=None,
        filter: Union[None, "DatasetFilterClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.entity = entity
        self.rowCountTotal = rowCountTotal
        self.rowCountChange = rowCountChange
        self.incrementingSegmentRowCountTotal = incrementingSegmentRowCountTotal
        self.incrementingSegmentRowCountChange = incrementingSegmentRowCountChange
        self.filter = filter
    
    def _restore_defaults(self) -> None:
        self.type = VolumeAssertionTypeClass.ROW_COUNT_TOTAL
        self.entity = str()
        self.rowCountTotal = self.RECORD_SCHEMA.fields_dict["rowCountTotal"].default
        self.rowCountChange = self.RECORD_SCHEMA.fields_dict["rowCountChange"].default
        self.incrementingSegmentRowCountTotal = self.RECORD_SCHEMA.fields_dict["incrementingSegmentRowCountTotal"].default
        self.incrementingSegmentRowCountChange = self.RECORD_SCHEMA.fields_dict["incrementingSegmentRowCountChange"].default
        self.filter = self.RECORD_SCHEMA.fields_dict["filter"].default
    
    
    @property
    def type(self) -> Union[str, "VolumeAssertionTypeClass"]:
        """The type of the volume assertion being monitored."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "VolumeAssertionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def entity(self) -> str:
        """The entity targeted by this Volume check."""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def rowCountTotal(self) -> Union[None, "RowCountTotalClass"]:
        """Produce FAILURE Assertion Result if the row count of the asset does not meet specific requirements.
    Required if type is 'ROW_COUNT_TOTAL'"""
        return self._inner_dict.get('rowCountTotal')  # type: ignore
    
    @rowCountTotal.setter
    def rowCountTotal(self, value: Union[None, "RowCountTotalClass"]) -> None:
        self._inner_dict['rowCountTotal'] = value
    
    
    @property
    def rowCountChange(self) -> Union[None, "RowCountChangeClass"]:
        """Produce FAILURE Assertion Result if the delta row count of the asset does not meet specific requirements
    within a given period of time.
    Required if type is 'ROW_COUNT_CHANGE'"""
        return self._inner_dict.get('rowCountChange')  # type: ignore
    
    @rowCountChange.setter
    def rowCountChange(self, value: Union[None, "RowCountChangeClass"]) -> None:
        self._inner_dict['rowCountChange'] = value
    
    
    @property
    def incrementingSegmentRowCountTotal(self) -> Union[None, "IncrementingSegmentRowCountTotalClass"]:
        """Produce FAILURE Assertion Result if the asset's latest incrementing segment row count total
    does not meet specific requirements. Required if type is 'INCREMENTING_SEGMENT_ROW_COUNT_TOTAL'"""
        return self._inner_dict.get('incrementingSegmentRowCountTotal')  # type: ignore
    
    @incrementingSegmentRowCountTotal.setter
    def incrementingSegmentRowCountTotal(self, value: Union[None, "IncrementingSegmentRowCountTotalClass"]) -> None:
        self._inner_dict['incrementingSegmentRowCountTotal'] = value
    
    
    @property
    def incrementingSegmentRowCountChange(self) -> Union[None, "IncrementingSegmentRowCountChangeClass"]:
        """Produce FAILURE Assertion Result if the asset's incrementing segment row count delta
    does not meet specific requirements. Required if type is 'INCREMENTING_SEGMENT_ROW_COUNT_CHANGE'"""
        return self._inner_dict.get('incrementingSegmentRowCountChange')  # type: ignore
    
    @incrementingSegmentRowCountChange.setter
    def incrementingSegmentRowCountChange(self, value: Union[None, "IncrementingSegmentRowCountChangeClass"]) -> None:
        self._inner_dict['incrementingSegmentRowCountChange'] = value
    
    
    @property
    def filter(self) -> Union[None, "DatasetFilterClass"]:
        """A definition of the specific filters that should be applied, when performing monitoring.
    If not provided, there is no filter, and the full table is under consideration."""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: Union[None, "DatasetFilterClass"]) -> None:
        self._inner_dict['filter'] = value
    
    
class VolumeAssertionTypeClass(object):
    # No docs available.
    
    ROW_COUNT_TOTAL = "ROW_COUNT_TOTAL"
    """A volume assertion that is evaluated against the total row count of a dataset."""
    
    ROW_COUNT_CHANGE = "ROW_COUNT_CHANGE"
    """A volume assertion that is evaluated against an incremental row count of a dataset,
    or a row count change."""
    
    INCREMENTING_SEGMENT_ROW_COUNT_TOTAL = "INCREMENTING_SEGMENT_ROW_COUNT_TOTAL"
    """A volume assertion that checks the latest "segment" in a table based on an incrementing
    column to check whether it's row count falls into a particular range.
    
    This can be used to monitor the row count of an incrementing date-partition column segment."""
    
    INCREMENTING_SEGMENT_ROW_COUNT_CHANGE = "INCREMENTING_SEGMENT_ROW_COUNT_CHANGE"
    """A volume assertion that compares the row counts in neighboring "segments" or "partitions"
    of an incrementing column.
    This can be used to track changes between subsequent date partition
    in a table, for example."""
    
    
    
class BusinessAttributeAssociationClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.businessattribute.BusinessAttributeAssociation")
    def __init__(self,
        businessAttributeUrn: str,
    ):
        super().__init__()
        
        self.businessAttributeUrn = businessAttributeUrn
    
    def _restore_defaults(self) -> None:
        self.businessAttributeUrn = str()
    
    
    @property
    def businessAttributeUrn(self) -> str:
        """Urn of the applied businessAttribute"""
        return self._inner_dict.get('businessAttributeUrn')  # type: ignore
    
    @businessAttributeUrn.setter
    def businessAttributeUrn(self, value: str) -> None:
        self._inner_dict['businessAttributeUrn'] = value
    
    
class BusinessAttributeInfoClass(_Aspect):
    """Properties associated with a BusinessAttribute"""


    ASPECT_NAME = 'businessAttributeInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.businessattribute.BusinessAttributeInfo")

    def __init__(self,
        fieldPath: str,
        name: str,
        description: Union[None, str]=None,
        globalTags: Union[None, "GlobalTagsClass"]=None,
        glossaryTerms: Union[None, "GlossaryTermsClass"]=None,
        customProperties: Optional[Dict[str, str]]=None,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        type: Union[None, "SchemaFieldDataTypeClass"]=None,
    ):
        super().__init__()
        
        self.fieldPath = fieldPath
        self.description = description
        self.globalTags = globalTags
        self.glossaryTerms = glossaryTerms
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.name = name
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.fieldPath = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.globalTags = self.RECORD_SCHEMA.fields_dict["globalTags"].default
        self.glossaryTerms = self.RECORD_SCHEMA.fields_dict["glossaryTerms"].default
        self.customProperties = dict()
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.name = str()
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
    
    
    @property
    def fieldPath(self) -> str:
        """FieldPath uniquely identifying the SchemaField this metadata is associated with"""
        return self._inner_dict.get('fieldPath')  # type: ignore
    
    @fieldPath.setter
    def fieldPath(self, value: str) -> None:
        self._inner_dict['fieldPath'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def globalTags(self) -> Union[None, "GlobalTagsClass"]:
        """Tags associated with the field"""
        return self._inner_dict.get('globalTags')  # type: ignore
    
    @globalTags.setter
    def globalTags(self, value: Union[None, "GlobalTagsClass"]) -> None:
        self._inner_dict['globalTags'] = value
    
    
    @property
    def glossaryTerms(self) -> Union[None, "GlossaryTermsClass"]:
        """Glossary terms associated with the field"""
        return self._inner_dict.get('glossaryTerms')  # type: ignore
    
    @glossaryTerms.setter
    def glossaryTerms(self, value: Union[None, "GlossaryTermsClass"]) -> None:
        self._inner_dict['glossaryTerms'] = value
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def name(self) -> str:
        """Display name of the BusinessAttribute"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def type(self) -> Union[None, "SchemaFieldDataTypeClass"]:
        # No docs available.
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[None, "SchemaFieldDataTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class BusinessAttributeKeyClass(_Aspect):
    """Key for a Query"""


    ASPECT_NAME = 'businessAttributeKey'
    ASPECT_INFO = {'keyForEntity': 'businessAttribute', 'entityCategory': 'core', 'entityAspects': ['businessAttributeInfo', 'status', 'ownership', 'institutionalMemory']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.businessattribute.BusinessAttributeKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the Business Attribute."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class BusinessAttributesClass(_Aspect):
    """BusinessAttribute aspect used for applying it to an entity"""


    ASPECT_NAME = 'businessAttributes'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.businessattribute.BusinessAttributes")

    def __init__(self,
        businessAttribute: Union[None, "BusinessAttributeAssociationClass"]=None,
    ):
        super().__init__()
        
        self.businessAttribute = businessAttribute
    
    def _restore_defaults(self) -> None:
        self.businessAttribute = self.RECORD_SCHEMA.fields_dict["businessAttribute"].default
    
    
    @property
    def businessAttribute(self) -> Union[None, "BusinessAttributeAssociationClass"]:
        """Business Attribute for this field."""
        return self._inner_dict.get('businessAttribute')  # type: ignore
    
    @businessAttribute.setter
    def businessAttribute(self, value: Union[None, "BusinessAttributeAssociationClass"]) -> None:
        self._inner_dict['businessAttribute'] = value
    
    
class ChartInfoClass(_Aspect):
    """Information about a chart"""


    ASPECT_NAME = 'chartInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.chart.ChartInfo")

    def __init__(self,
        title: str,
        description: str,
        lastModified: "ChangeAuditStampsClass",
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        chartUrl: Union[None, str]=None,
        inputs: Union[None, List[str]]=None,
        inputEdges: Union[None, List["EdgeClass"]]=None,
        type: Union[None, Union[str, "ChartTypeClass"]]=None,
        access: Union[None, Union[str, "AccessLevelClass"]]=None,
        lastRefreshed: Union[None, int]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.title = title
        self.description = description
        self.lastModified = lastModified
        self.chartUrl = chartUrl
        self.inputs = inputs
        self.inputEdges = inputEdges
        self.type = type
        self.access = access
        self.lastRefreshed = lastRefreshed
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.title = str()
        self.description = str()
        self.lastModified = ChangeAuditStampsClass._construct_with_defaults()
        self.chartUrl = self.RECORD_SCHEMA.fields_dict["chartUrl"].default
        self.inputs = self.RECORD_SCHEMA.fields_dict["inputs"].default
        self.inputEdges = self.RECORD_SCHEMA.fields_dict["inputEdges"].default
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        self.access = self.RECORD_SCHEMA.fields_dict["access"].default
        self.lastRefreshed = self.RECORD_SCHEMA.fields_dict["lastRefreshed"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def title(self) -> str:
        """Title of the chart"""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: str) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def description(self) -> str:
        """Detailed description about the chart"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: str) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def lastModified(self) -> "ChangeAuditStampsClass":
        """Captures information about who created/last modified/deleted this chart and when"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "ChangeAuditStampsClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def chartUrl(self) -> Union[None, str]:
        """URL for the chart. This could be used as an external link on DataHub to allow users access/view the chart"""
        return self._inner_dict.get('chartUrl')  # type: ignore
    
    @chartUrl.setter
    def chartUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['chartUrl'] = value
    
    
    @property
    def inputs(self) -> Union[None, List[str]]:
        """Data sources for the chart
    Deprecated! Use inputEdges instead."""
        return self._inner_dict.get('inputs')  # type: ignore
    
    @inputs.setter
    def inputs(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['inputs'] = value
    
    
    @property
    def inputEdges(self) -> Union[None, List["EdgeClass"]]:
        """Data sources for the chart"""
        return self._inner_dict.get('inputEdges')  # type: ignore
    
    @inputEdges.setter
    def inputEdges(self, value: Union[None, List["EdgeClass"]]) -> None:
        self._inner_dict['inputEdges'] = value
    
    
    @property
    def type(self) -> Union[None, Union[str, "ChartTypeClass"]]:
        """Type of the chart"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[None, Union[str, "ChartTypeClass"]]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def access(self) -> Union[None, Union[str, "AccessLevelClass"]]:
        """Access level for the chart"""
        return self._inner_dict.get('access')  # type: ignore
    
    @access.setter
    def access(self, value: Union[None, Union[str, "AccessLevelClass"]]) -> None:
        self._inner_dict['access'] = value
    
    
    @property
    def lastRefreshed(self) -> Union[None, int]:
        """The time when this chart last refreshed"""
        return self._inner_dict.get('lastRefreshed')  # type: ignore
    
    @lastRefreshed.setter
    def lastRefreshed(self, value: Union[None, int]) -> None:
        self._inner_dict['lastRefreshed'] = value
    
    
class ChartQueryClass(_Aspect):
    """Information for chart query which is used for getting data of the chart"""


    ASPECT_NAME = 'chartQuery'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.chart.ChartQuery")

    def __init__(self,
        rawQuery: str,
        type: Union[str, "ChartQueryTypeClass"],
    ):
        super().__init__()
        
        self.rawQuery = rawQuery
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.rawQuery = str()
        self.type = ChartQueryTypeClass.LOOKML
    
    
    @property
    def rawQuery(self) -> str:
        """Raw query to build a chart from input datasets"""
        return self._inner_dict.get('rawQuery')  # type: ignore
    
    @rawQuery.setter
    def rawQuery(self, value: str) -> None:
        self._inner_dict['rawQuery'] = value
    
    
    @property
    def type(self) -> Union[str, "ChartQueryTypeClass"]:
        """Chart query type"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "ChartQueryTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class ChartQueryTypeClass(object):
    # No docs available.
    
    LOOKML = "LOOKML"
    """LookML queries"""
    
    SQL = "SQL"
    """SQL type queries"""
    
    
    
class ChartTypeClass(object):
    """The various types of charts"""
    
    BAR = "BAR"
    """Chart showing a Bar chart"""
    
    PIE = "PIE"
    """Chart showing a Pie chart"""
    
    SCATTER = "SCATTER"
    """Chart showing a Scatter plot"""
    
    TABLE = "TABLE"
    """Chart showing a table"""
    
    TEXT = "TEXT"
    """Chart showing Markdown formatted text"""
    
    LINE = "LINE"
    
    AREA = "AREA"
    
    HISTOGRAM = "HISTOGRAM"
    
    BOX_PLOT = "BOX_PLOT"
    
    WORD_CLOUD = "WORD_CLOUD"
    
    COHORT = "COHORT"
    
    
    
class ChartUsageStatisticsClass(_Aspect):
    """Experimental (Subject to breaking change) -- Stats corresponding to chart's usage.
    
    If this aspect represents the latest snapshot of the statistics about a Chart, the eventGranularity field should be null.
    If this aspect represents a bucketed window of usage statistics (e.g. over a day), then the eventGranularity field should be set accordingly."""


    ASPECT_NAME = 'chartUsageStatistics'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.chart.ChartUsageStatistics")

    def __init__(self,
        timestampMillis: int,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        viewsCount: Union[None, int]=None,
        uniqueUserCount: Union[None, int]=None,
        userCounts: Union[None, List["ChartUserUsageCountsClass"]]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.viewsCount = viewsCount
        self.uniqueUserCount = uniqueUserCount
        self.userCounts = userCounts
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.viewsCount = self.RECORD_SCHEMA.fields_dict["viewsCount"].default
        self.uniqueUserCount = self.RECORD_SCHEMA.fields_dict["uniqueUserCount"].default
        self.userCounts = self.RECORD_SCHEMA.fields_dict["userCounts"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def viewsCount(self) -> Union[None, int]:
        """The total number of times chart has been viewed"""
        return self._inner_dict.get('viewsCount')  # type: ignore
    
    @viewsCount.setter
    def viewsCount(self, value: Union[None, int]) -> None:
        self._inner_dict['viewsCount'] = value
    
    
    @property
    def uniqueUserCount(self) -> Union[None, int]:
        """Unique user count"""
        return self._inner_dict.get('uniqueUserCount')  # type: ignore
    
    @uniqueUserCount.setter
    def uniqueUserCount(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueUserCount'] = value
    
    
    @property
    def userCounts(self) -> Union[None, List["ChartUserUsageCountsClass"]]:
        """Users within this bucket, with frequency counts"""
        return self._inner_dict.get('userCounts')  # type: ignore
    
    @userCounts.setter
    def userCounts(self, value: Union[None, List["ChartUserUsageCountsClass"]]) -> None:
        self._inner_dict['userCounts'] = value
    
    
class ChartUserUsageCountsClass(DictWrapper):
    """Records a single user's usage counts for a given resource"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.chart.ChartUserUsageCounts")
    def __init__(self,
        user: str,
        viewsCount: Union[None, int]=None,
    ):
        super().__init__()
        
        self.user = user
        self.viewsCount = viewsCount
    
    def _restore_defaults(self) -> None:
        self.user = str()
        self.viewsCount = self.RECORD_SCHEMA.fields_dict["viewsCount"].default
    
    
    @property
    def user(self) -> str:
        """The unique id of the user."""
        return self._inner_dict.get('user')  # type: ignore
    
    @user.setter
    def user(self, value: str) -> None:
        self._inner_dict['user'] = value
    
    
    @property
    def viewsCount(self) -> Union[None, int]:
        """The number of times the user has viewed the chart"""
        return self._inner_dict.get('viewsCount')  # type: ignore
    
    @viewsCount.setter
    def viewsCount(self, value: Union[None, int]) -> None:
        self._inner_dict['viewsCount'] = value
    
    
class EditableChartPropertiesClass(_Aspect):
    """Stores editable changes made to properties. This separates changes made from
    ingestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"""


    ASPECT_NAME = 'editableChartProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.chart.EditableChartProperties")

    def __init__(self,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Edited documentation of the chart """
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class AccessClass(_Aspect):
    """Aspect used for associating roles to a dataset or any asset"""


    ASPECT_NAME = 'access'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Access")

    def __init__(self,
        roles: Union[None, List["RoleAssociationClass"]]=None,
    ):
        super().__init__()
        
        self.roles = roles
    
    def _restore_defaults(self) -> None:
        self.roles = self.RECORD_SCHEMA.fields_dict["roles"].default
    
    
    @property
    def roles(self) -> Union[None, List["RoleAssociationClass"]]:
        """List of Roles which needs to be associated"""
        return self._inner_dict.get('roles')  # type: ignore
    
    @roles.setter
    def roles(self, value: Union[None, List["RoleAssociationClass"]]) -> None:
        self._inner_dict['roles'] = value
    
    
class AccessLevelClass(object):
    """The various access levels"""
    
    PUBLIC = "PUBLIC"
    """Publicly available access level"""
    
    PRIVATE = "PRIVATE"
    """Private availability to certain set of users"""
    
    
    
class AnomaliesSummaryClass(_Aspect):
    """Summary related to entity anomalies"""


    ASPECT_NAME = 'anomaliesSummary'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.AnomaliesSummary")

    def __init__(self,
        activeAnomalyDetails: Optional[List["AnomalySummaryDetailsClass"]]=None,
        resolvedAnomalyDetails: Optional[List["AnomalySummaryDetailsClass"]]=None,
    ):
        super().__init__()
        
        if activeAnomalyDetails is None:
            # default: []
            self.activeAnomalyDetails = list()
        else:
            self.activeAnomalyDetails = activeAnomalyDetails
        if resolvedAnomalyDetails is None:
            # default: []
            self.resolvedAnomalyDetails = list()
        else:
            self.resolvedAnomalyDetails = resolvedAnomalyDetails
    
    def _restore_defaults(self) -> None:
        self.activeAnomalyDetails = list()
        self.resolvedAnomalyDetails = list()
    
    
    @property
    def activeAnomalyDetails(self) -> List["AnomalySummaryDetailsClass"]:
        """Summary details about the set of active anomalies"""
        return self._inner_dict.get('activeAnomalyDetails')  # type: ignore
    
    @activeAnomalyDetails.setter
    def activeAnomalyDetails(self, value: List["AnomalySummaryDetailsClass"]) -> None:
        self._inner_dict['activeAnomalyDetails'] = value
    
    
    @property
    def resolvedAnomalyDetails(self) -> List["AnomalySummaryDetailsClass"]:
        """Summary details about the set of resolved anomalies"""
        return self._inner_dict.get('resolvedAnomalyDetails')  # type: ignore
    
    @resolvedAnomalyDetails.setter
    def resolvedAnomalyDetails(self, value: List["AnomalySummaryDetailsClass"]) -> None:
        self._inner_dict['resolvedAnomalyDetails'] = value
    
    
class AnomalySummaryDetailsClass(DictWrapper):
    """Summary statistics about anomalies on an entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.AnomalySummaryDetails")
    def __init__(self,
        urn: str,
        type: str,
        lastResultAt: int,
        source: Union[None, str]=None,
    ):
        super().__init__()
        
        self.urn = urn
        self.type = type
        self.lastResultAt = lastResultAt
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.type = str()
        self.lastResultAt = int()
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
    
    
    @property
    def urn(self) -> str:
        """The urn of the anomaly"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def type(self) -> str:
        """The top-level type of an anomaly"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def lastResultAt(self) -> int:
        """The time at which the last result was produced."""
        return self._inner_dict.get('lastResultAt')  # type: ignore
    
    @lastResultAt.setter
    def lastResultAt(self, value: int) -> None:
        self._inner_dict['lastResultAt'] = value
    
    
    @property
    def source(self) -> Union[None, str]:
        """The source of the anomaly"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, str]) -> None:
        self._inner_dict['source'] = value
    
    
class AssertionSummaryDetailsClass(DictWrapper):
    """Summary statistics about assertions on an entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.AssertionSummaryDetails")
    def __init__(self,
        urn: str,
        type: str,
        lastResultAt: int,
        source: Union[None, str]=None,
    ):
        super().__init__()
        
        self.urn = urn
        self.type = type
        self.lastResultAt = lastResultAt
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.type = str()
        self.lastResultAt = int()
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
    
    
    @property
    def urn(self) -> str:
        """The urn of the assertion"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def type(self) -> str:
        """The top-level type of an assertion"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def lastResultAt(self) -> int:
        """The time at which the last result was produced."""
        return self._inner_dict.get('lastResultAt')  # type: ignore
    
    @lastResultAt.setter
    def lastResultAt(self, value: int) -> None:
        self._inner_dict['lastResultAt'] = value
    
    
    @property
    def source(self) -> Union[None, str]:
        """The source of the assertion"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, str]) -> None:
        self._inner_dict['source'] = value
    
    
class AssertionsSummaryClass(_Aspect):
    """Summary related to entity assertions"""


    ASPECT_NAME = 'assertionsSummary'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.AssertionsSummary")

    def __init__(self,
        failingAssertions: Optional[List[str]]=None,
        passingAssertions: Optional[List[str]]=None,
        lastAssertionResultAt: Union[None, int]=None,
        passingAssertionDetails: Optional[List["AssertionSummaryDetailsClass"]]=None,
        failingAssertionDetails: Optional[List["AssertionSummaryDetailsClass"]]=None,
        erroringAssertionDetails: Optional[List["AssertionSummaryDetailsClass"]]=None,
        initializingAssertionDetails: Optional[List["AssertionSummaryDetailsClass"]]=None,
    ):
        super().__init__()
        
        if failingAssertions is None:
            # default: []
            self.failingAssertions = list()
        else:
            self.failingAssertions = failingAssertions
        if passingAssertions is None:
            # default: []
            self.passingAssertions = list()
        else:
            self.passingAssertions = passingAssertions
        self.lastAssertionResultAt = lastAssertionResultAt
        if passingAssertionDetails is None:
            # default: []
            self.passingAssertionDetails = list()
        else:
            self.passingAssertionDetails = passingAssertionDetails
        if failingAssertionDetails is None:
            # default: []
            self.failingAssertionDetails = list()
        else:
            self.failingAssertionDetails = failingAssertionDetails
        if erroringAssertionDetails is None:
            # default: []
            self.erroringAssertionDetails = list()
        else:
            self.erroringAssertionDetails = erroringAssertionDetails
        if initializingAssertionDetails is None:
            # default: []
            self.initializingAssertionDetails = list()
        else:
            self.initializingAssertionDetails = initializingAssertionDetails
    
    def _restore_defaults(self) -> None:
        self.failingAssertions = list()
        self.passingAssertions = list()
        self.lastAssertionResultAt = self.RECORD_SCHEMA.fields_dict["lastAssertionResultAt"].default
        self.passingAssertionDetails = list()
        self.failingAssertionDetails = list()
        self.erroringAssertionDetails = list()
        self.initializingAssertionDetails = list()
    
    
    @property
    def failingAssertions(self) -> List[str]:
        """Failing assertions for an asset
    Deprecated! Use failingAssertionDetails."""
        return self._inner_dict.get('failingAssertions')  # type: ignore
    
    @failingAssertions.setter
    def failingAssertions(self, value: List[str]) -> None:
        self._inner_dict['failingAssertions'] = value
    
    
    @property
    def passingAssertions(self) -> List[str]:
        """Passing assertions for an asset
    Deprecated! Use passingAssertionDetails."""
        return self._inner_dict.get('passingAssertions')  # type: ignore
    
    @passingAssertions.setter
    def passingAssertions(self, value: List[str]) -> None:
        self._inner_dict['passingAssertions'] = value
    
    
    @property
    def lastAssertionResultAt(self) -> Union[None, int]:
        """The last time an assertion was run."""
        return self._inner_dict.get('lastAssertionResultAt')  # type: ignore
    
    @lastAssertionResultAt.setter
    def lastAssertionResultAt(self, value: Union[None, int]) -> None:
        self._inner_dict['lastAssertionResultAt'] = value
    
    
    @property
    def passingAssertionDetails(self) -> List["AssertionSummaryDetailsClass"]:
        """Summary details about the set of passing assertions"""
        return self._inner_dict.get('passingAssertionDetails')  # type: ignore
    
    @passingAssertionDetails.setter
    def passingAssertionDetails(self, value: List["AssertionSummaryDetailsClass"]) -> None:
        self._inner_dict['passingAssertionDetails'] = value
    
    
    @property
    def failingAssertionDetails(self) -> List["AssertionSummaryDetailsClass"]:
        """Summary details about the set of failing assertions"""
        return self._inner_dict.get('failingAssertionDetails')  # type: ignore
    
    @failingAssertionDetails.setter
    def failingAssertionDetails(self, value: List["AssertionSummaryDetailsClass"]) -> None:
        self._inner_dict['failingAssertionDetails'] = value
    
    
    @property
    def erroringAssertionDetails(self) -> List["AssertionSummaryDetailsClass"]:
        """Summary details about the set of erroring assertions"""
        return self._inner_dict.get('erroringAssertionDetails')  # type: ignore
    
    @erroringAssertionDetails.setter
    def erroringAssertionDetails(self, value: List["AssertionSummaryDetailsClass"]) -> None:
        self._inner_dict['erroringAssertionDetails'] = value
    
    
    @property
    def initializingAssertionDetails(self) -> List["AssertionSummaryDetailsClass"]:
        """Summary details about the set of initializing assertions"""
        return self._inner_dict.get('initializingAssertionDetails')  # type: ignore
    
    @initializingAssertionDetails.setter
    def initializingAssertionDetails(self, value: List["AssertionSummaryDetailsClass"]) -> None:
        self._inner_dict['initializingAssertionDetails'] = value
    
    
class AuditStampClass(DictWrapper):
    """Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.AuditStamp")
    def __init__(self,
        time: int,
        actor: str,
        impersonator: Union[None, str]=None,
        message: Union[None, str]=None,
    ):
        super().__init__()
        
        self.time = time
        self.actor = actor
        self.impersonator = impersonator
        self.message = message
    
    def _restore_defaults(self) -> None:
        self.time = int()
        self.actor = str()
        self.impersonator = self.RECORD_SCHEMA.fields_dict["impersonator"].default
        self.message = self.RECORD_SCHEMA.fields_dict["message"].default
    
    
    @property
    def time(self) -> int:
        """When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."""
        return self._inner_dict.get('time')  # type: ignore
    
    @time.setter
    def time(self, value: int) -> None:
        self._inner_dict['time'] = value
    
    
    @property
    def actor(self) -> str:
        """The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: str) -> None:
        self._inner_dict['actor'] = value
    
    
    @property
    def impersonator(self) -> Union[None, str]:
        """The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor."""
        return self._inner_dict.get('impersonator')  # type: ignore
    
    @impersonator.setter
    def impersonator(self, value: Union[None, str]) -> None:
        self._inner_dict['impersonator'] = value
    
    
    @property
    def message(self) -> Union[None, str]:
        """Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually."""
        return self._inner_dict.get('message')  # type: ignore
    
    @message.setter
    def message(self, value: Union[None, str]) -> None:
        self._inner_dict['message'] = value
    
    
class BrowsePathEntryClass(DictWrapper):
    """Represents a single level in an entity's browsePathV2"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.BrowsePathEntry")
    def __init__(self,
        id: str,
        urn: Union[None, str]=None,
    ):
        super().__init__()
        
        self.id = id
        self.urn = urn
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.urn = self.RECORD_SCHEMA.fields_dict["urn"].default
    
    
    @property
    def id(self) -> str:
        """The ID of the browse path entry. This is what gets stored in the index.
    If there's an urn associated with this entry, id and urn will be the same"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def urn(self) -> Union[None, str]:
        """Optional urn pointing to some entity in DataHub"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: Union[None, str]) -> None:
        self._inner_dict['urn'] = value
    
    
class BrowsePathsClass(_Aspect):
    """Shared aspect containing Browse Paths to be indexed for an entity."""


    ASPECT_NAME = 'browsePaths'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.BrowsePaths")

    def __init__(self,
        paths: List[str],
    ):
        super().__init__()
        
        self.paths = paths
    
    def _restore_defaults(self) -> None:
        self.paths = list()
    
    
    @property
    def paths(self) -> List[str]:
        """A list of valid browse paths for the entity.
    
    Browse paths are expected to be forward slash-separated strings. For example: 'prod/snowflake/datasetName'"""
        return self._inner_dict.get('paths')  # type: ignore
    
    @paths.setter
    def paths(self, value: List[str]) -> None:
        self._inner_dict['paths'] = value
    
    
class BrowsePathsV2Class(_Aspect):
    """Shared aspect containing a Browse Path to be indexed for an entity."""


    ASPECT_NAME = 'browsePathsV2'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.BrowsePathsV2")

    def __init__(self,
        path: List["BrowsePathEntryClass"],
    ):
        super().__init__()
        
        self.path = path
    
    def _restore_defaults(self) -> None:
        self.path = list()
    
    
    @property
    def path(self) -> List["BrowsePathEntryClass"]:
        """A valid browse path for the entity. This field is provided by DataHub by default.
    This aspect is a newer version of browsePaths where we can encode more information in the path.
    This path is also based on containers for a given entity if it has containers.
    
    This is stored in elasticsearch as unit-separator delimited strings and only includes platform specific folders or containers.
    These paths should not include high level info captured elsewhere ie. Platform and Environment."""
        return self._inner_dict.get('path')  # type: ignore
    
    @path.setter
    def path(self, value: List["BrowsePathEntryClass"]) -> None:
        self._inner_dict['path'] = value
    
    
class ChangeAuditStampsClass(DictWrapper):
    """Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into various lifecycle stages, and who acted to move it into those lifecycle stages. The recommended best practice is to include this record in your record schema, and annotate its fields as @readOnly in your resource. See https://github.com/linkedin/rest.li/wiki/Validation-in-Rest.li#restli-validation-annotations"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.ChangeAuditStamps")
    def __init__(self,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
class CostClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'cost'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Cost")

    def __init__(self,
        costType: Union[str, "CostTypeClass"],
        cost: "CostCostClass",
    ):
        super().__init__()
        
        self.costType = costType
        self.cost = cost
    
    def _restore_defaults(self) -> None:
        self.costType = CostTypeClass.ORG_COST_TYPE
        self.cost = CostCostClass._construct_with_defaults()
    
    
    @property
    def costType(self) -> Union[str, "CostTypeClass"]:
        # No docs available.
        return self._inner_dict.get('costType')  # type: ignore
    
    @costType.setter
    def costType(self, value: Union[str, "CostTypeClass"]) -> None:
        self._inner_dict['costType'] = value
    
    
    @property
    def cost(self) -> "CostCostClass":
        # No docs available.
        return self._inner_dict.get('cost')  # type: ignore
    
    @cost.setter
    def cost(self, value: "CostCostClass") -> None:
        self._inner_dict['cost'] = value
    
    
class CostCostClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.CostCost")
    def __init__(self,
        fieldDiscriminator: Union[str, "CostCostDiscriminatorClass"],
        costId: Union[None, float]=None,
        costCode: Union[None, str]=None,
    ):
        super().__init__()
        
        self.costId = costId
        self.costCode = costCode
        self.fieldDiscriminator = fieldDiscriminator
    
    def _restore_defaults(self) -> None:
        self.costId = self.RECORD_SCHEMA.fields_dict["costId"].default
        self.costCode = self.RECORD_SCHEMA.fields_dict["costCode"].default
        self.fieldDiscriminator = CostCostDiscriminatorClass.costId
    
    
    @property
    def costId(self) -> Union[None, float]:
        # No docs available.
        return self._inner_dict.get('costId')  # type: ignore
    
    @costId.setter
    def costId(self, value: Union[None, float]) -> None:
        self._inner_dict['costId'] = value
    
    
    @property
    def costCode(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('costCode')  # type: ignore
    
    @costCode.setter
    def costCode(self, value: Union[None, str]) -> None:
        self._inner_dict['costCode'] = value
    
    
    @property
    def fieldDiscriminator(self) -> Union[str, "CostCostDiscriminatorClass"]:
        """Contains the name of the field that has its value set."""
        return self._inner_dict.get('fieldDiscriminator')  # type: ignore
    
    @fieldDiscriminator.setter
    def fieldDiscriminator(self, value: Union[str, "CostCostDiscriminatorClass"]) -> None:
        self._inner_dict['fieldDiscriminator'] = value
    
    
class CostCostDiscriminatorClass(object):
    # No docs available.
    
    costId = "costId"
    costCode = "costCode"
    
    
class CostTypeClass(object):
    """Type of Cost Code"""
    
    ORG_COST_TYPE = "ORG_COST_TYPE"
    """Org Cost Type to which the Cost of this entity should be attributed to"""
    
    
    
class CronScheduleClass(DictWrapper):
    """Attributes defining a CRON-formatted schedule."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.CronSchedule")
    def __init__(self,
        cron: str,
        timezone: str,
    ):
        super().__init__()
        
        self.cron = cron
        self.timezone = timezone
    
    def _restore_defaults(self) -> None:
        self.cron = str()
        self.timezone = str()
    
    
    @property
    def cron(self) -> str:
        """A cron-formatted execution interval, as a cron string, e.g. 1 * * * *"""
        return self._inner_dict.get('cron')  # type: ignore
    
    @cron.setter
    def cron(self, value: str) -> None:
        self._inner_dict['cron'] = value
    
    
    @property
    def timezone(self) -> str:
        """Timezone in which the cron interval applies, e.g. America/Los Angeles"""
        return self._inner_dict.get('timezone')  # type: ignore
    
    @timezone.setter
    def timezone(self, value: str) -> None:
        self._inner_dict['timezone'] = value
    
    
class DataPlatformInstanceClass(_Aspect):
    """The specific instance of the data platform that this entity belongs to"""


    ASPECT_NAME = 'dataPlatformInstance'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.DataPlatformInstance")

    def __init__(self,
        platform: str,
        instance: Union[None, str]=None,
    ):
        super().__init__()
        
        self.platform = platform
        self.instance = instance
    
    def _restore_defaults(self) -> None:
        self.platform = str()
        self.instance = self.RECORD_SCHEMA.fields_dict["instance"].default
    
    
    @property
    def platform(self) -> str:
        """Data Platform"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def instance(self) -> Union[None, str]:
        """Instance of the data platform (e.g. db instance)"""
        return self._inner_dict.get('instance')  # type: ignore
    
    @instance.setter
    def instance(self, value: Union[None, str]) -> None:
        self._inner_dict['instance'] = value
    
    
class DataTransformClass(DictWrapper):
    """Information about a transformation. It may be a query,"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.DataTransform")
    def __init__(self,
        queryStatement: Union[None, "QueryStatementClass"]=None,
    ):
        super().__init__()
        
        self.queryStatement = queryStatement
    
    def _restore_defaults(self) -> None:
        self.queryStatement = self.RECORD_SCHEMA.fields_dict["queryStatement"].default
    
    
    @property
    def queryStatement(self) -> Union[None, "QueryStatementClass"]:
        """The data transform may be defined by a query statement"""
        return self._inner_dict.get('queryStatement')  # type: ignore
    
    @queryStatement.setter
    def queryStatement(self, value: Union[None, "QueryStatementClass"]) -> None:
        self._inner_dict['queryStatement'] = value
    
    
class DataTransformLogicClass(_Aspect):
    """Information about a Query against one or more data assets (e.g. Tables or Views)."""


    ASPECT_NAME = 'dataTransformLogic'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.DataTransformLogic")

    def __init__(self,
        transforms: List["DataTransformClass"],
    ):
        super().__init__()
        
        self.transforms = transforms
    
    def _restore_defaults(self) -> None:
        self.transforms = list()
    
    
    @property
    def transforms(self) -> List["DataTransformClass"]:
        """List of transformations applied"""
        return self._inner_dict.get('transforms')  # type: ignore
    
    @transforms.setter
    def transforms(self, value: List["DataTransformClass"]) -> None:
        self._inner_dict['transforms'] = value
    
    
class DeprecationClass(_Aspect):
    """Deprecation status of an entity"""


    ASPECT_NAME = 'deprecation'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Deprecation")

    def __init__(self,
        deprecated: bool,
        note: str,
        actor: str,
        decommissionTime: Union[None, int]=None,
        replacement: Union[None, str]=None,
    ):
        super().__init__()
        
        self.deprecated = deprecated
        self.decommissionTime = decommissionTime
        self.note = note
        self.actor = actor
        self.replacement = replacement
    
    def _restore_defaults(self) -> None:
        self.deprecated = bool()
        self.decommissionTime = self.RECORD_SCHEMA.fields_dict["decommissionTime"].default
        self.note = str()
        self.actor = str()
        self.replacement = self.RECORD_SCHEMA.fields_dict["replacement"].default
    
    
    @property
    def deprecated(self) -> bool:
        """Whether the entity is deprecated."""
        return self._inner_dict.get('deprecated')  # type: ignore
    
    @deprecated.setter
    def deprecated(self, value: bool) -> None:
        self._inner_dict['deprecated'] = value
    
    
    @property
    def decommissionTime(self) -> Union[None, int]:
        """The time user plan to decommission this entity."""
        return self._inner_dict.get('decommissionTime')  # type: ignore
    
    @decommissionTime.setter
    def decommissionTime(self, value: Union[None, int]) -> None:
        self._inner_dict['decommissionTime'] = value
    
    
    @property
    def note(self) -> str:
        """Additional information about the entity deprecation plan, such as the wiki, doc, RB."""
        return self._inner_dict.get('note')  # type: ignore
    
    @note.setter
    def note(self, value: str) -> None:
        self._inner_dict['note'] = value
    
    
    @property
    def actor(self) -> str:
        """The user URN which will be credited for modifying this deprecation content."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: str) -> None:
        self._inner_dict['actor'] = value
    
    
    @property
    def replacement(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('replacement')  # type: ignore
    
    @replacement.setter
    def replacement(self, value: Union[None, str]) -> None:
        self._inner_dict['replacement'] = value
    
    
class DisplayPropertiesClass(_Aspect):
    """Properties related to how the entity is displayed in the Datahub UI"""


    ASPECT_NAME = 'displayProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.DisplayProperties")

    def __init__(self,
        colorHex: Union[None, str]=None,
        icon: Union[None, "IconPropertiesClass"]=None,
    ):
        super().__init__()
        
        self.colorHex = colorHex
        self.icon = icon
    
    def _restore_defaults(self) -> None:
        self.colorHex = self.RECORD_SCHEMA.fields_dict["colorHex"].default
        self.icon = self.RECORD_SCHEMA.fields_dict["icon"].default
    
    
    @property
    def colorHex(self) -> Union[None, str]:
        """The color associated with the entity in Hex. For example #FFFFFF."""
        return self._inner_dict.get('colorHex')  # type: ignore
    
    @colorHex.setter
    def colorHex(self, value: Union[None, str]) -> None:
        self._inner_dict['colorHex'] = value
    
    
    @property
    def icon(self) -> Union[None, "IconPropertiesClass"]:
        """The icon associated with the entity"""
        return self._inner_dict.get('icon')  # type: ignore
    
    @icon.setter
    def icon(self, value: Union[None, "IconPropertiesClass"]) -> None:
        self._inner_dict['icon'] = value
    
    
class DocumentationClass(_Aspect):
    """Aspect used for storing all applicable documentations on assets.
    This aspect supports multiple documentations from different sources.
    There is an implicit assumption that there is only one documentation per
       source.
    For example, if there are two documentations from the same source, the
       latest one will overwrite the previous one.
    If there are two documentations from different sources, both will be
       stored.
    Future evolution considerations:
    The first entity that uses this aspect is Schema Field. We will expand this
        aspect to other entities eventually.
    The values of the documentation are not currently searchable. This will be
        changed once this aspect develops opinion on which documentation entry is
        the authoritative one.
    Ensuring that there is only one documentation per source is a business
        rule that is not enforced by the aspect yet. This will currently be enforced by the
        application that uses this aspect. We will eventually enforce this rule in
        the aspect using AspectMutators."""


    ASPECT_NAME = 'documentation'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Documentation")

    def __init__(self,
        documentations: List["DocumentationAssociationClass"],
        lastModified: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.lastModified = lastModified
        self.documentations = documentations
    
    def _restore_defaults(self) -> None:
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.documentations = list()
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """The time and actor that generated or last updated this documentation."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def documentations(self) -> List["DocumentationAssociationClass"]:
        """Documentations associated with this asset. We could be receiving docs from different sources"""
        return self._inner_dict.get('documentations')  # type: ignore
    
    @documentations.setter
    def documentations(self, value: List["DocumentationAssociationClass"]) -> None:
        self._inner_dict['documentations'] = value
    
    
class DocumentationAssociationClass(DictWrapper):
    """Properties of applied documentation including the attribution of the doc"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.DocumentationAssociation")
    def __init__(self,
        documentation: str,
        attribution: Union[None, "MetadataAttributionClass"]=None,
    ):
        super().__init__()
        
        self.documentation = documentation
        self.attribution = attribution
    
    def _restore_defaults(self) -> None:
        self.documentation = str()
        self.attribution = self.RECORD_SCHEMA.fields_dict["attribution"].default
    
    
    @property
    def documentation(self) -> str:
        """Description of this asset"""
        return self._inner_dict.get('documentation')  # type: ignore
    
    @documentation.setter
    def documentation(self, value: str) -> None:
        self._inner_dict['documentation'] = value
    
    
    @property
    def attribution(self) -> Union[None, "MetadataAttributionClass"]:
        """Information about who, why, and how this metadata was applied"""
        return self._inner_dict.get('attribution')  # type: ignore
    
    @attribution.setter
    def attribution(self, value: Union[None, "MetadataAttributionClass"]) -> None:
        self._inner_dict['attribution'] = value
    
    
class DocumentationPromptResponseClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.DocumentationPromptResponse")
    def __init__(self,
        documentation: str,
    ):
        super().__init__()
        
        self.documentation = documentation
    
    def _restore_defaults(self) -> None:
        self.documentation = str()
    
    
    @property
    def documentation(self) -> str:
        """The documentation provided for this specific response"""
        return self._inner_dict.get('documentation')  # type: ignore
    
    @documentation.setter
    def documentation(self, value: str) -> None:
        self._inner_dict['documentation'] = value
    
    
class DomainPromptResponseClass(DictWrapper):
    """Response for a domain type prompt"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.DomainPromptResponse")
    def __init__(self,
        domain: str,
    ):
        super().__init__()
        
        self.domain = domain
    
    def _restore_defaults(self) -> None:
        self.domain = str()
    
    
    @property
    def domain(self) -> str:
        """The domain applied to an asset from this prompt response"""
        return self._inner_dict.get('domain')  # type: ignore
    
    @domain.setter
    def domain(self, value: str) -> None:
        self._inner_dict['domain'] = value
    
    
class EdgeClass(DictWrapper):
    """A common structure to represent all edges to entities when used inside aspects as collections
    This ensures that all edges have common structure around audit-stamps and will support PATCH, time-travel automatically."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Edge")
    def __init__(self,
        destinationUrn: str,
        sourceUrn: Union[None, str]=None,
        created: Union[None, "AuditStampClass"]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
        properties: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.sourceUrn = sourceUrn
        self.destinationUrn = destinationUrn
        self.created = created
        self.lastModified = lastModified
        self.properties = properties
    
    def _restore_defaults(self) -> None:
        self.sourceUrn = self.RECORD_SCHEMA.fields_dict["sourceUrn"].default
        self.destinationUrn = str()
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.properties = self.RECORD_SCHEMA.fields_dict["properties"].default
    
    
    @property
    def sourceUrn(self) -> Union[None, str]:
        """Urn of the source of this relationship edge.
    If not specified, assumed to be the entity that this aspect belongs to."""
        return self._inner_dict.get('sourceUrn')  # type: ignore
    
    @sourceUrn.setter
    def sourceUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['sourceUrn'] = value
    
    
    @property
    def destinationUrn(self) -> str:
        """Urn of the destination of this relationship edge."""
        return self._inner_dict.get('destinationUrn')  # type: ignore
    
    @destinationUrn.setter
    def destinationUrn(self, value: str) -> None:
        self._inner_dict['destinationUrn'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp containing who created this relationship edge and when"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp containing who last modified this relationship edge and when"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def properties(self) -> Union[None, Dict[str, str]]:
        """A generic properties bag that allows us to store specific information on this graph edge."""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['properties'] = value
    
    
class EmbedClass(_Aspect):
    """Information regarding rendering an embed for an asset."""


    ASPECT_NAME = 'embed'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Embed")

    def __init__(self,
        renderUrl: Union[None, str]=None,
    ):
        super().__init__()
        
        self.renderUrl = renderUrl
    
    def _restore_defaults(self) -> None:
        self.renderUrl = self.RECORD_SCHEMA.fields_dict["renderUrl"].default
    
    
    @property
    def renderUrl(self) -> Union[None, str]:
        """An embed URL to be rendered inside of an iframe."""
        return self._inner_dict.get('renderUrl')  # type: ignore
    
    @renderUrl.setter
    def renderUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['renderUrl'] = value
    
    
class EmbeddingChunkClass(DictWrapper):
    """A single chunk of text with its embedding vector.
    
    Chunks enable semantic search over long documents by breaking them
    into smaller, semantically coherent pieces that fit within model
    context windows."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.EmbeddingChunk")
    def __init__(self,
        position: int,
        vector: List[float],
        characterOffset: Union[None, int]=None,
        characterLength: Union[None, int]=None,
        tokenCount: Union[None, int]=None,
        text: Union[None, str]=None,
    ):
        super().__init__()
        
        self.position = position
        self.vector = vector
        self.characterOffset = characterOffset
        self.characterLength = characterLength
        self.tokenCount = tokenCount
        self.text = text
    
    def _restore_defaults(self) -> None:
        self.position = int()
        self.vector = list()
        self.characterOffset = self.RECORD_SCHEMA.fields_dict["characterOffset"].default
        self.characterLength = self.RECORD_SCHEMA.fields_dict["characterLength"].default
        self.tokenCount = self.RECORD_SCHEMA.fields_dict["tokenCount"].default
        self.text = self.RECORD_SCHEMA.fields_dict["text"].default
    
    
    @property
    def position(self) -> int:
        """Zero-based position/index of this chunk within the document."""
        return self._inner_dict.get('position')  # type: ignore
    
    @position.setter
    def position(self, value: int) -> None:
        self._inner_dict['position'] = value
    
    
    @property
    def vector(self) -> List[float]:
        """The embedding vector for this chunk.
    Dimensionality depends on the model (e.g., 1024 for Cohere v3)."""
        return self._inner_dict.get('vector')  # type: ignore
    
    @vector.setter
    def vector(self, value: List[float]) -> None:
        self._inner_dict['vector'] = value
    
    
    @property
    def characterOffset(self) -> Union[None, int]:
        """Character offset from start of source text.
    Used for highlighting and navigation. Optional for privacy."""
        return self._inner_dict.get('characterOffset')  # type: ignore
    
    @characterOffset.setter
    def characterOffset(self, value: Union[None, int]) -> None:
        self._inner_dict['characterOffset'] = value
    
    
    @property
    def characterLength(self) -> Union[None, int]:
        """Character length of the chunk in source text.
    Optional for privacy-sensitive use cases."""
        return self._inner_dict.get('characterLength')  # type: ignore
    
    @characterLength.setter
    def characterLength(self, value: Union[None, int]) -> None:
        self._inner_dict['characterLength'] = value
    
    
    @property
    def tokenCount(self) -> Union[None, int]:
        """Estimated token count for this chunk."""
        return self._inner_dict.get('tokenCount')  # type: ignore
    
    @tokenCount.setter
    def tokenCount(self, value: Union[None, int]) -> None:
        self._inner_dict['tokenCount'] = value
    
    
    @property
    def text(self) -> Union[None, str]:
        """Original text of this chunk.
    OPTIONAL: May be omitted for privacy-sensitive data sources
    where only embeddings should be stored, not source text."""
        return self._inner_dict.get('text')  # type: ignore
    
    @text.setter
    def text(self, value: Union[None, str]) -> None:
        self._inner_dict['text'] = value
    
    
class EmbeddingModelDataClass(DictWrapper):
    """Embedding data for a specific model.
    Contains metadata about the embedding generation and the chunked vectors."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.EmbeddingModelData")
    def __init__(self,
        modelVersion: str,
        generatedAt: int,
        totalChunks: int,
        chunks: List["EmbeddingChunkClass"],
        chunkingStrategy: Union[None, str]=None,
        totalTokens: Union[None, int]=None,
    ):
        super().__init__()
        
        self.modelVersion = modelVersion
        self.generatedAt = generatedAt
        self.chunkingStrategy = chunkingStrategy
        self.totalChunks = totalChunks
        self.totalTokens = totalTokens
        self.chunks = chunks
    
    def _restore_defaults(self) -> None:
        self.modelVersion = str()
        self.generatedAt = int()
        self.chunkingStrategy = self.RECORD_SCHEMA.fields_dict["chunkingStrategy"].default
        self.totalChunks = int()
        self.totalTokens = self.RECORD_SCHEMA.fields_dict["totalTokens"].default
        self.chunks = list()
    
    
    @property
    def modelVersion(self) -> str:
        """Full model identifier including provider.
    Examples: bedrock/cohere.embed-english-v3, openai/text-embedding-ada-002"""
        return self._inner_dict.get('modelVersion')  # type: ignore
    
    @modelVersion.setter
    def modelVersion(self, value: str) -> None:
        self._inner_dict['modelVersion'] = value
    
    
    @property
    def generatedAt(self) -> int:
        """Timestamp when embeddings were generated (milliseconds since epoch)."""
        return self._inner_dict.get('generatedAt')  # type: ignore
    
    @generatedAt.setter
    def generatedAt(self, value: int) -> None:
        self._inner_dict['generatedAt'] = value
    
    
    @property
    def chunkingStrategy(self) -> Union[None, str]:
        """Description of the chunking strategy used.
    Examples: sentence_boundary_400t, fixed_512_chars, paragraph"""
        return self._inner_dict.get('chunkingStrategy')  # type: ignore
    
    @chunkingStrategy.setter
    def chunkingStrategy(self, value: Union[None, str]) -> None:
        self._inner_dict['chunkingStrategy'] = value
    
    
    @property
    def totalChunks(self) -> int:
        """Total number of chunks."""
        return self._inner_dict.get('totalChunks')  # type: ignore
    
    @totalChunks.setter
    def totalChunks(self, value: int) -> None:
        self._inner_dict['totalChunks'] = value
    
    
    @property
    def totalTokens(self) -> Union[None, int]:
        """Estimated total token count across all chunks."""
        return self._inner_dict.get('totalTokens')  # type: ignore
    
    @totalTokens.setter
    def totalTokens(self, value: Union[None, int]) -> None:
        self._inner_dict['totalTokens'] = value
    
    
    @property
    def chunks(self) -> List["EmbeddingChunkClass"]:
        """Individual chunks with their embedding vectors."""
        return self._inner_dict.get('chunks')  # type: ignore
    
    @chunks.setter
    def chunks(self, value: List["EmbeddingChunkClass"]) -> None:
        self._inner_dict['chunks'] = value
    
    
class FabricTypeClass(object):
    """Fabric group type"""
    
    DEV = "DEV"
    """Designates development fabrics"""
    
    TEST = "TEST"
    """Designates testing fabrics"""
    
    QA = "QA"
    """Designates quality assurance fabrics"""
    
    UAT = "UAT"
    """Designates user acceptance testing fabrics"""
    
    EI = "EI"
    """Designates early-integration fabrics"""
    
    PRE = "PRE"
    """Designates pre-production fabrics"""
    
    STG = "STG"
    """Designates staging fabrics"""
    
    NON_PROD = "NON_PROD"
    """Designates non-production fabrics"""
    
    PROD = "PROD"
    """Designates production fabrics"""
    
    CORP = "CORP"
    """Designates corporation fabrics"""
    
    RVW = "RVW"
    """Designates review fabrics"""
    
    PRD = "PRD"
    """Alternative Prod spelling"""
    
    TST = "TST"
    """Alternative Test spelling"""
    
    SIT = "SIT"
    """System Integration Testing"""
    
    SBX = "SBX"
    """Alternative spelling for sandbox"""
    
    SANDBOX = "SANDBOX"
    """Designates sandbox fabrics"""
    
    
    
class FieldFormPromptAssociationClass(DictWrapper):
    """Information about the status of a particular prompt for a specific schema field
    on an entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.FieldFormPromptAssociation")
    def __init__(self,
        fieldPath: str,
        lastModified: "AuditStampClass",
        response: Union[None, "FormPromptResponseClass"]=None,
    ):
        super().__init__()
        
        self.fieldPath = fieldPath
        self.lastModified = lastModified
        self.response = response
    
    def _restore_defaults(self) -> None:
        self.fieldPath = str()
        self.lastModified = AuditStampClass._construct_with_defaults()
        self.response = self.RECORD_SCHEMA.fields_dict["response"].default
    
    
    @property
    def fieldPath(self) -> str:
        """The field path on a schema field."""
        return self._inner_dict.get('fieldPath')  # type: ignore
    
    @fieldPath.setter
    def fieldPath(self, value: str) -> None:
        self._inner_dict['fieldPath'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """The last time this prompt was touched for the field on the entity (set, unset)"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def response(self) -> Union[None, "FormPromptResponseClass"]:
        """Optional record of what was actually submitted when a user responds to a field-level form prompt.
    This should be populated going forward."""
        return self._inner_dict.get('response')  # type: ignore
    
    @response.setter
    def response(self, value: Union[None, "FormPromptResponseClass"]) -> None:
        self._inner_dict['response'] = value
    
    
class FormAssociationClass(DictWrapper):
    """Properties of an applied form."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.FormAssociation")
    def __init__(self,
        urn: str,
        incompletePrompts: Optional[List["FormPromptAssociationClass"]]=None,
        completedPrompts: Optional[List["FormPromptAssociationClass"]]=None,
        created: Union[None, "AuditStampClass"]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.urn = urn
        if incompletePrompts is None:
            # default: []
            self.incompletePrompts = list()
        else:
            self.incompletePrompts = incompletePrompts
        if completedPrompts is None:
            # default: []
            self.completedPrompts = list()
        else:
            self.completedPrompts = completedPrompts
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.incompletePrompts = list()
        self.completedPrompts = list()
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
    
    
    @property
    def urn(self) -> str:
        """Urn of the applied form"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def incompletePrompts(self) -> List["FormPromptAssociationClass"]:
        """A list of prompts that are not yet complete for this form."""
        return self._inner_dict.get('incompletePrompts')  # type: ignore
    
    @incompletePrompts.setter
    def incompletePrompts(self, value: List["FormPromptAssociationClass"]) -> None:
        self._inner_dict['incompletePrompts'] = value
    
    
    @property
    def completedPrompts(self) -> List["FormPromptAssociationClass"]:
        """A list of prompts that have been completed for this form."""
        return self._inner_dict.get('completedPrompts')  # type: ignore
    
    @completedPrompts.setter
    def completedPrompts(self, value: List["FormPromptAssociationClass"]) -> None:
        self._inner_dict['completedPrompts'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """An audit stamp of when this form association was created"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """An audit stamp of the last time this form association was modified"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
class FormPromptAssociationClass(DictWrapper):
    """Information about the status of a particular prompt.
    Note that this is where we can add additional information about individual responses:
    actor, timestamp, and the response itself."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.FormPromptAssociation")
    def __init__(self,
        id: str,
        lastModified: "AuditStampClass",
        fieldAssociations: Union[None, "FormPromptFieldAssociationsClass"]=None,
        response: Union[None, "FormPromptResponseClass"]=None,
    ):
        super().__init__()
        
        self.id = id
        self.lastModified = lastModified
        self.fieldAssociations = fieldAssociations
        self.response = response
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.lastModified = AuditStampClass._construct_with_defaults()
        self.fieldAssociations = self.RECORD_SCHEMA.fields_dict["fieldAssociations"].default
        self.response = self.RECORD_SCHEMA.fields_dict["response"].default
    
    
    @property
    def id(self) -> str:
        """The id for the prompt. This must be GLOBALLY UNIQUE."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """The last time this prompt was touched for the entity (set, unset)"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def fieldAssociations(self) -> Union[None, "FormPromptFieldAssociationsClass"]:
        """Optional information about the field-level prompt associations."""
        return self._inner_dict.get('fieldAssociations')  # type: ignore
    
    @fieldAssociations.setter
    def fieldAssociations(self, value: Union[None, "FormPromptFieldAssociationsClass"]) -> None:
        self._inner_dict['fieldAssociations'] = value
    
    
    @property
    def response(self) -> Union[None, "FormPromptResponseClass"]:
        """Optional record of what was actually submitted when a user responds to a form prompt.
    This should be populated going forward."""
        return self._inner_dict.get('response')  # type: ignore
    
    @response.setter
    def response(self, value: Union[None, "FormPromptResponseClass"]) -> None:
        self._inner_dict['response'] = value
    
    
class FormPromptFieldAssociationsClass(DictWrapper):
    """Information about the field-level prompt associations on a top-level prompt association."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.FormPromptFieldAssociations")
    def __init__(self,
        completedFieldPrompts: Union[None, List["FieldFormPromptAssociationClass"]]=None,
        incompleteFieldPrompts: Union[None, List["FieldFormPromptAssociationClass"]]=None,
    ):
        super().__init__()
        
        self.completedFieldPrompts = completedFieldPrompts
        self.incompleteFieldPrompts = incompleteFieldPrompts
    
    def _restore_defaults(self) -> None:
        self.completedFieldPrompts = self.RECORD_SCHEMA.fields_dict["completedFieldPrompts"].default
        self.incompleteFieldPrompts = self.RECORD_SCHEMA.fields_dict["incompleteFieldPrompts"].default
    
    
    @property
    def completedFieldPrompts(self) -> Union[None, List["FieldFormPromptAssociationClass"]]:
        """A list of field-level prompt associations that are not yet complete for this form."""
        return self._inner_dict.get('completedFieldPrompts')  # type: ignore
    
    @completedFieldPrompts.setter
    def completedFieldPrompts(self, value: Union[None, List["FieldFormPromptAssociationClass"]]) -> None:
        self._inner_dict['completedFieldPrompts'] = value
    
    
    @property
    def incompleteFieldPrompts(self) -> Union[None, List["FieldFormPromptAssociationClass"]]:
        """A list of field-level prompt associations that are complete for this form."""
        return self._inner_dict.get('incompleteFieldPrompts')  # type: ignore
    
    @incompleteFieldPrompts.setter
    def incompleteFieldPrompts(self, value: Union[None, List["FieldFormPromptAssociationClass"]]) -> None:
        self._inner_dict['incompleteFieldPrompts'] = value
    
    
class FormPromptResponseClass(DictWrapper):
    """A record of what was actually submitted when a user responds to a form prompt"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.FormPromptResponse")
    def __init__(self,
        structuredPropertyResponse: Union[None, "StructuredPropertyPromptResponseClass"]=None,
        ownershipResponse: Union[None, "OwnershipPromptResponseClass"]=None,
        documentationResponse: Union[None, "DocumentationPromptResponseClass"]=None,
        glossaryTermsResponse: Union[None, "GlossaryTermsPromptResponseClass"]=None,
        domainResponse: Union[None, "DomainPromptResponseClass"]=None,
    ):
        super().__init__()
        
        self.structuredPropertyResponse = structuredPropertyResponse
        self.ownershipResponse = ownershipResponse
        self.documentationResponse = documentationResponse
        self.glossaryTermsResponse = glossaryTermsResponse
        self.domainResponse = domainResponse
    
    def _restore_defaults(self) -> None:
        self.structuredPropertyResponse = self.RECORD_SCHEMA.fields_dict["structuredPropertyResponse"].default
        self.ownershipResponse = self.RECORD_SCHEMA.fields_dict["ownershipResponse"].default
        self.documentationResponse = self.RECORD_SCHEMA.fields_dict["documentationResponse"].default
        self.glossaryTermsResponse = self.RECORD_SCHEMA.fields_dict["glossaryTermsResponse"].default
        self.domainResponse = self.RECORD_SCHEMA.fields_dict["domainResponse"].default
    
    
    @property
    def structuredPropertyResponse(self) -> Union[None, "StructuredPropertyPromptResponseClass"]:
        """Response for a structured property type prompt"""
        return self._inner_dict.get('structuredPropertyResponse')  # type: ignore
    
    @structuredPropertyResponse.setter
    def structuredPropertyResponse(self, value: Union[None, "StructuredPropertyPromptResponseClass"]) -> None:
        self._inner_dict['structuredPropertyResponse'] = value
    
    
    @property
    def ownershipResponse(self) -> Union[None, "OwnershipPromptResponseClass"]:
        """Response for an ownership type prompt"""
        return self._inner_dict.get('ownershipResponse')  # type: ignore
    
    @ownershipResponse.setter
    def ownershipResponse(self, value: Union[None, "OwnershipPromptResponseClass"]) -> None:
        self._inner_dict['ownershipResponse'] = value
    
    
    @property
    def documentationResponse(self) -> Union[None, "DocumentationPromptResponseClass"]:
        """Response for a documentation type prompt"""
        return self._inner_dict.get('documentationResponse')  # type: ignore
    
    @documentationResponse.setter
    def documentationResponse(self, value: Union[None, "DocumentationPromptResponseClass"]) -> None:
        self._inner_dict['documentationResponse'] = value
    
    
    @property
    def glossaryTermsResponse(self) -> Union[None, "GlossaryTermsPromptResponseClass"]:
        """Response for a glossary terms type prompt"""
        return self._inner_dict.get('glossaryTermsResponse')  # type: ignore
    
    @glossaryTermsResponse.setter
    def glossaryTermsResponse(self, value: Union[None, "GlossaryTermsPromptResponseClass"]) -> None:
        self._inner_dict['glossaryTermsResponse'] = value
    
    
    @property
    def domainResponse(self) -> Union[None, "DomainPromptResponseClass"]:
        """Response for a domain type prompt"""
        return self._inner_dict.get('domainResponse')  # type: ignore
    
    @domainResponse.setter
    def domainResponse(self, value: Union[None, "DomainPromptResponseClass"]) -> None:
        self._inner_dict['domainResponse'] = value
    
    
class FormVerificationAssociationClass(DictWrapper):
    """An association between a verification and an entity that has been granted
    via completion of one or more forms of type 'VERIFICATION'."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.FormVerificationAssociation")
    def __init__(self,
        form: str,
        lastModified: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.form = form
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.form = str()
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
    
    
    @property
    def form(self) -> str:
        """The urn of the form that granted this verification."""
        return self._inner_dict.get('form')  # type: ignore
    
    @form.setter
    def form(self, value: str) -> None:
        self._inner_dict['form'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """An audit stamp capturing who and when verification was applied for this form."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
class FormsClass(_Aspect):
    """Forms that are assigned to this entity to be filled out"""


    ASPECT_NAME = 'forms'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Forms")

    def __init__(self,
        incompleteForms: List["FormAssociationClass"],
        completedForms: List["FormAssociationClass"],
        verifications: Optional[List["FormVerificationAssociationClass"]]=None,
    ):
        super().__init__()
        
        self.incompleteForms = incompleteForms
        self.completedForms = completedForms
        if verifications is None:
            # default: []
            self.verifications = list()
        else:
            self.verifications = verifications
    
    def _restore_defaults(self) -> None:
        self.incompleteForms = list()
        self.completedForms = list()
        self.verifications = list()
    
    
    @property
    def incompleteForms(self) -> List["FormAssociationClass"]:
        """All incomplete forms assigned to the entity."""
        return self._inner_dict.get('incompleteForms')  # type: ignore
    
    @incompleteForms.setter
    def incompleteForms(self, value: List["FormAssociationClass"]) -> None:
        self._inner_dict['incompleteForms'] = value
    
    
    @property
    def completedForms(self) -> List["FormAssociationClass"]:
        """All complete forms assigned to the entity."""
        return self._inner_dict.get('completedForms')  # type: ignore
    
    @completedForms.setter
    def completedForms(self, value: List["FormAssociationClass"]) -> None:
        self._inner_dict['completedForms'] = value
    
    
    @property
    def verifications(self) -> List["FormVerificationAssociationClass"]:
        """Verifications that have been applied to the entity via completed forms."""
        return self._inner_dict.get('verifications')  # type: ignore
    
    @verifications.setter
    def verifications(self, value: List["FormVerificationAssociationClass"]) -> None:
        self._inner_dict['verifications'] = value
    
    
class GlobalTagsClass(_Aspect):
    """Tag aspect used for applying tags to an entity"""


    ASPECT_NAME = 'globalTags'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.GlobalTags")

    def __init__(self,
        tags: List["TagAssociationClass"],
    ):
        super().__init__()
        
        self.tags = tags
    
    def _restore_defaults(self) -> None:
        self.tags = list()
    
    
    @property
    def tags(self) -> List["TagAssociationClass"]:
        """Tags associated with a given entity"""
        return self._inner_dict.get('tags')  # type: ignore
    
    @tags.setter
    def tags(self, value: List["TagAssociationClass"]) -> None:
        self._inner_dict['tags'] = value
    
    
class GlossaryTermAssociationClass(DictWrapper):
    """Properties of an applied glossary term."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.GlossaryTermAssociation")
    def __init__(self,
        urn: str,
        actor: Union[None, str]=None,
        context: Union[None, str]=None,
        attribution: Union[None, "MetadataAttributionClass"]=None,
    ):
        super().__init__()
        
        self.urn = urn
        self.actor = actor
        self.context = context
        self.attribution = attribution
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.actor = self.RECORD_SCHEMA.fields_dict["actor"].default
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
        self.attribution = self.RECORD_SCHEMA.fields_dict["attribution"].default
    
    
    @property
    def urn(self) -> str:
        """Urn of the applied glossary term"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def actor(self) -> Union[None, str]:
        """The user URN which will be credited for adding associating this term to the entity"""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: Union[None, str]) -> None:
        self._inner_dict['actor'] = value
    
    
    @property
    def context(self) -> Union[None, str]:
        """Additional context about the association"""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, str]) -> None:
        self._inner_dict['context'] = value
    
    
    @property
    def attribution(self) -> Union[None, "MetadataAttributionClass"]:
        """Information about who, why, and how this metadata was applied"""
        return self._inner_dict.get('attribution')  # type: ignore
    
    @attribution.setter
    def attribution(self, value: Union[None, "MetadataAttributionClass"]) -> None:
        self._inner_dict['attribution'] = value
    
    
class GlossaryTermsClass(_Aspect):
    """Related business terms information"""


    ASPECT_NAME = 'glossaryTerms'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.GlossaryTerms")

    def __init__(self,
        terms: List["GlossaryTermAssociationClass"],
        auditStamp: "AuditStampClass",
    ):
        super().__init__()
        
        self.terms = terms
        self.auditStamp = auditStamp
    
    def _restore_defaults(self) -> None:
        self.terms = list()
        self.auditStamp = AuditStampClass._construct_with_defaults()
    
    
    @property
    def terms(self) -> List["GlossaryTermAssociationClass"]:
        """The related business terms"""
        return self._inner_dict.get('terms')  # type: ignore
    
    @terms.setter
    def terms(self, value: List["GlossaryTermAssociationClass"]) -> None:
        self._inner_dict['terms'] = value
    
    
    @property
    def auditStamp(self) -> "AuditStampClass":
        """Audit stamp containing who reported the related business term"""
        return self._inner_dict.get('auditStamp')  # type: ignore
    
    @auditStamp.setter
    def auditStamp(self, value: "AuditStampClass") -> None:
        self._inner_dict['auditStamp'] = value
    
    
class GlossaryTermsPromptResponseClass(DictWrapper):
    """Response for a glossary terms type prompt"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.GlossaryTermsPromptResponse")
    def __init__(self,
        glossaryTerms: List[str],
    ):
        super().__init__()
        
        self.glossaryTerms = glossaryTerms
    
    def _restore_defaults(self) -> None:
        self.glossaryTerms = list()
    
    
    @property
    def glossaryTerms(self) -> List[str]:
        """The glossaryTerms applied to an asset from this prompt response"""
        return self._inner_dict.get('glossaryTerms')  # type: ignore
    
    @glossaryTerms.setter
    def glossaryTerms(self, value: List[str]) -> None:
        self._inner_dict['glossaryTerms'] = value
    
    
class IconLibraryClass(object):
    """Enum of possible icon sources"""
    
    MATERIAL = "MATERIAL"
    """Material UI"""
    
    
    
class IconPropertiesClass(DictWrapper):
    """Properties describing an icon associated with an entity"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.IconProperties")
    def __init__(self,
        iconLibrary: Union[str, "IconLibraryClass"],
        name: str,
        style: str,
    ):
        super().__init__()
        
        self.iconLibrary = iconLibrary
        self.name = name
        self.style = style
    
    def _restore_defaults(self) -> None:
        self.iconLibrary = IconLibraryClass.MATERIAL
        self.name = str()
        self.style = str()
    
    
    @property
    def iconLibrary(self) -> Union[str, "IconLibraryClass"]:
        """The source of the icon: e.g. Antd, Material, etc"""
        return self._inner_dict.get('iconLibrary')  # type: ignore
    
    @iconLibrary.setter
    def iconLibrary(self, value: Union[str, "IconLibraryClass"]) -> None:
        self._inner_dict['iconLibrary'] = value
    
    
    @property
    def name(self) -> str:
        """The name of the icon"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def style(self) -> str:
        """Any modifier for the icon, this will be library-specific, e.g. filled/outlined, etc"""
        return self._inner_dict.get('style')  # type: ignore
    
    @style.setter
    def style(self, value: str) -> None:
        self._inner_dict['style'] = value
    
    
class IncidentSummaryDetailsClass(DictWrapper):
    """Summary statistics about incidents on an entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.IncidentSummaryDetails")
    def __init__(self,
        urn: str,
        type: str,
        createdAt: int,
        resolvedAt: Union[None, int]=None,
        priority: Union[None, int]=None,
    ):
        super().__init__()
        
        self.urn = urn
        self.type = type
        self.createdAt = createdAt
        self.resolvedAt = resolvedAt
        self.priority = priority
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.type = str()
        self.createdAt = int()
        self.resolvedAt = self.RECORD_SCHEMA.fields_dict["resolvedAt"].default
        self.priority = self.RECORD_SCHEMA.fields_dict["priority"].default
    
    
    @property
    def urn(self) -> str:
        """The urn of the incident"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def type(self) -> str:
        """The type of an incident"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def createdAt(self) -> int:
        """The time at which the incident was raised in milliseconds since epoch."""
        return self._inner_dict.get('createdAt')  # type: ignore
    
    @createdAt.setter
    def createdAt(self, value: int) -> None:
        self._inner_dict['createdAt'] = value
    
    
    @property
    def resolvedAt(self) -> Union[None, int]:
        """The time at which the incident was marked as resolved in milliseconds since epoch. Null if the incident is still active."""
        return self._inner_dict.get('resolvedAt')  # type: ignore
    
    @resolvedAt.setter
    def resolvedAt(self, value: Union[None, int]) -> None:
        self._inner_dict['resolvedAt'] = value
    
    
    @property
    def priority(self) -> Union[None, int]:
        """The priority of the incident"""
        return self._inner_dict.get('priority')  # type: ignore
    
    @priority.setter
    def priority(self, value: Union[None, int]) -> None:
        self._inner_dict['priority'] = value
    
    
class IncidentsSummaryClass(_Aspect):
    """Summary related incidents on an entity."""


    ASPECT_NAME = 'incidentsSummary'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.IncidentsSummary")

    def __init__(self,
        resolvedIncidents: Optional[List[str]]=None,
        activeIncidents: Optional[List[str]]=None,
        resolvedIncidentDetails: Optional[List["IncidentSummaryDetailsClass"]]=None,
        activeIncidentDetails: Optional[List["IncidentSummaryDetailsClass"]]=None,
    ):
        super().__init__()
        
        if resolvedIncidents is None:
            # default: []
            self.resolvedIncidents = list()
        else:
            self.resolvedIncidents = resolvedIncidents
        if activeIncidents is None:
            # default: []
            self.activeIncidents = list()
        else:
            self.activeIncidents = activeIncidents
        if resolvedIncidentDetails is None:
            # default: []
            self.resolvedIncidentDetails = list()
        else:
            self.resolvedIncidentDetails = resolvedIncidentDetails
        if activeIncidentDetails is None:
            # default: []
            self.activeIncidentDetails = list()
        else:
            self.activeIncidentDetails = activeIncidentDetails
    
    def _restore_defaults(self) -> None:
        self.resolvedIncidents = list()
        self.activeIncidents = list()
        self.resolvedIncidentDetails = list()
        self.activeIncidentDetails = list()
    
    
    @property
    def resolvedIncidents(self) -> List[str]:
        """Resolved incidents for an asset
    Deprecated! Use the richer resolvedIncidentsDetails instead."""
        return self._inner_dict.get('resolvedIncidents')  # type: ignore
    
    @resolvedIncidents.setter
    def resolvedIncidents(self, value: List[str]) -> None:
        self._inner_dict['resolvedIncidents'] = value
    
    
    @property
    def activeIncidents(self) -> List[str]:
        """Active incidents for an asset
    Deprecated! Use the richer activeIncidentsDetails instead."""
        return self._inner_dict.get('activeIncidents')  # type: ignore
    
    @activeIncidents.setter
    def activeIncidents(self, value: List[str]) -> None:
        self._inner_dict['activeIncidents'] = value
    
    
    @property
    def resolvedIncidentDetails(self) -> List["IncidentSummaryDetailsClass"]:
        """Summary details about the set of resolved incidents"""
        return self._inner_dict.get('resolvedIncidentDetails')  # type: ignore
    
    @resolvedIncidentDetails.setter
    def resolvedIncidentDetails(self, value: List["IncidentSummaryDetailsClass"]) -> None:
        self._inner_dict['resolvedIncidentDetails'] = value
    
    
    @property
    def activeIncidentDetails(self) -> List["IncidentSummaryDetailsClass"]:
        """Summary details about the set of active incidents"""
        return self._inner_dict.get('activeIncidentDetails')  # type: ignore
    
    @activeIncidentDetails.setter
    def activeIncidentDetails(self, value: List["IncidentSummaryDetailsClass"]) -> None:
        self._inner_dict['activeIncidentDetails'] = value
    
    
class InputFieldClass(DictWrapper):
    """Information about a field a chart or dashboard references"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.InputField")
    def __init__(self,
        schemaFieldUrn: str,
        schemaField: Union[None, "SchemaFieldClass"]=None,
    ):
        super().__init__()
        
        self.schemaFieldUrn = schemaFieldUrn
        self.schemaField = schemaField
    
    def _restore_defaults(self) -> None:
        self.schemaFieldUrn = str()
        self.schemaField = self.RECORD_SCHEMA.fields_dict["schemaField"].default
    
    
    @property
    def schemaFieldUrn(self) -> str:
        """Urn of the schema being referenced for lineage purposes"""
        return self._inner_dict.get('schemaFieldUrn')  # type: ignore
    
    @schemaFieldUrn.setter
    def schemaFieldUrn(self, value: str) -> None:
        self._inner_dict['schemaFieldUrn'] = value
    
    
    @property
    def schemaField(self) -> Union[None, "SchemaFieldClass"]:
        """Copied version of the referenced schema field object for indexing purposes"""
        return self._inner_dict.get('schemaField')  # type: ignore
    
    @schemaField.setter
    def schemaField(self, value: Union[None, "SchemaFieldClass"]) -> None:
        self._inner_dict['schemaField'] = value
    
    
class InputFieldsClass(_Aspect):
    """Information about the fields a chart or dashboard references"""


    ASPECT_NAME = 'inputFields'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.InputFields")

    def __init__(self,
        fields: List["InputFieldClass"],
    ):
        super().__init__()
        
        self.fields = fields
    
    def _restore_defaults(self) -> None:
        self.fields = list()
    
    
    @property
    def fields(self) -> List["InputFieldClass"]:
        """List of fields being referenced"""
        return self._inner_dict.get('fields')  # type: ignore
    
    @fields.setter
    def fields(self, value: List["InputFieldClass"]) -> None:
        self._inner_dict['fields'] = value
    
    
class InstitutionalMemoryClass(_Aspect):
    """Institutional memory of an entity. This is a way to link to relevant documentation and provide description of the documentation. Institutional or tribal knowledge is very important for users to leverage the entity."""


    ASPECT_NAME = 'institutionalMemory'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.InstitutionalMemory")

    def __init__(self,
        elements: List["InstitutionalMemoryMetadataClass"],
    ):
        super().__init__()
        
        self.elements = elements
    
    def _restore_defaults(self) -> None:
        self.elements = list()
    
    
    @property
    def elements(self) -> List["InstitutionalMemoryMetadataClass"]:
        """List of records that represent institutional memory of an entity. Each record consists of a link, description, creator and timestamps associated with that record."""
        return self._inner_dict.get('elements')  # type: ignore
    
    @elements.setter
    def elements(self, value: List["InstitutionalMemoryMetadataClass"]) -> None:
        self._inner_dict['elements'] = value
    
    
class InstitutionalMemoryMetadataClass(DictWrapper):
    """Metadata corresponding to a record of institutional memory."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.InstitutionalMemoryMetadata")
    def __init__(self,
        url: str,
        description: str,
        createStamp: "AuditStampClass",
        updateStamp: Union[None, "AuditStampClass"]=None,
        settings: Union[None, "InstitutionalMemoryMetadataSettingsClass"]=None,
    ):
        super().__init__()
        
        self.url = url
        self.description = description
        self.createStamp = createStamp
        self.updateStamp = updateStamp
        self.settings = settings
    
    def _restore_defaults(self) -> None:
        self.url = str()
        self.description = str()
        self.createStamp = AuditStampClass._construct_with_defaults()
        self.updateStamp = self.RECORD_SCHEMA.fields_dict["updateStamp"].default
        self.settings = self.RECORD_SCHEMA.fields_dict["settings"].default
    
    
    @property
    def url(self) -> str:
        """Link to an engineering design document or a wiki page."""
        return self._inner_dict.get('url')  # type: ignore
    
    @url.setter
    def url(self, value: str) -> None:
        self._inner_dict['url'] = value
    
    
    @property
    def description(self) -> str:
        """Description of the link."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: str) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def createStamp(self) -> "AuditStampClass":
        """Audit stamp associated with creation of this record"""
        return self._inner_dict.get('createStamp')  # type: ignore
    
    @createStamp.setter
    def createStamp(self, value: "AuditStampClass") -> None:
        self._inner_dict['createStamp'] = value
    
    
    @property
    def updateStamp(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp associated with updation of this record"""
        return self._inner_dict.get('updateStamp')  # type: ignore
    
    @updateStamp.setter
    def updateStamp(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['updateStamp'] = value
    
    
    @property
    def settings(self) -> Union[None, "InstitutionalMemoryMetadataSettingsClass"]:
        """Settings for this record"""
        return self._inner_dict.get('settings')  # type: ignore
    
    @settings.setter
    def settings(self, value: Union[None, "InstitutionalMemoryMetadataSettingsClass"]) -> None:
        self._inner_dict['settings'] = value
    
    
class InstitutionalMemoryMetadataSettingsClass(DictWrapper):
    """Settings related to a record of InstitutionalMemoryMetadata"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.InstitutionalMemoryMetadataSettings")
    def __init__(self,
        showInAssetPreview: Optional[bool]=None,
    ):
        super().__init__()
        
        if showInAssetPreview is None:
            # default: False
            self.showInAssetPreview = self.RECORD_SCHEMA.fields_dict["showInAssetPreview"].default
        else:
            self.showInAssetPreview = showInAssetPreview
    
    def _restore_defaults(self) -> None:
        self.showInAssetPreview = self.RECORD_SCHEMA.fields_dict["showInAssetPreview"].default
    
    
    @property
    def showInAssetPreview(self) -> bool:
        """Show record in asset preview like on entity header and search previews"""
        return self._inner_dict.get('showInAssetPreview')  # type: ignore
    
    @showInAssetPreview.setter
    def showInAssetPreview(self, value: bool) -> None:
        self._inner_dict['showInAssetPreview'] = value
    
    
class MLFeatureDataTypeClass(object):
    """MLFeature Data Type"""
    
    USELESS = "USELESS"
    """Useless data is unique, discrete data with no potential relationship with the outcome variable.
    A useless feature has high cardinality. An example would be bank account numbers that were generated randomly."""
    
    NOMINAL = "NOMINAL"
    """Nominal data is made of discrete values with no numerical relationship between the different categories - mean and median are meaningless.
    Animal species is one example. For example, pig is not higher than bird and lower than fish."""
    
    ORDINAL = "ORDINAL"
    """Ordinal data are discrete integers that can be ranked or sorted.
    For example, the distance between first and second may not be the same as the distance between second and third."""
    
    BINARY = "BINARY"
    """Binary data is discrete data that can be in only one of two categories - either yes or no, 1 or 0, off or on, etc"""
    
    COUNT = "COUNT"
    """Count data is discrete whole number data - no negative numbers here.
    Count data often has many small values, such as zero and one."""
    
    TIME = "TIME"
    """Time data is a cyclical, repeating continuous form of data.
    The relevant time features can be any period- daily, weekly, monthly, annual, etc."""
    
    INTERVAL = "INTERVAL"
    """Interval data has equal spaces between the numbers and does not represent a temporal pattern.
    Examples include percentages, temperatures, and income."""
    
    IMAGE = "IMAGE"
    """Image Data"""
    
    VIDEO = "VIDEO"
    """Video Data"""
    
    AUDIO = "AUDIO"
    """Audio Data"""
    
    TEXT = "TEXT"
    """Text Data"""
    
    MAP = "MAP"
    """Mapping Data Type ex: dict, map"""
    
    SEQUENCE = "SEQUENCE"
    """Sequence Data Type ex: list, tuple, range"""
    
    SET = "SET"
    """Set Data Type ex: set, frozenset"""
    
    CONTINUOUS = "CONTINUOUS"
    """Continuous data are made of uncountable values, often the result of a measurement such as height, weight, age etc."""
    
    BYTE = "BYTE"
    """Bytes data are binary-encoded values that can represent complex objects."""
    
    UNKNOWN = "UNKNOWN"
    """Unknown data are data that we don't know the type for."""
    
    
    
class MediaClass(DictWrapper):
    """Carries information about which roles a user is assigned to."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Media")
    def __init__(self,
        type: Union[str, "MediaTypeClass"],
        location: str,
    ):
        super().__init__()
        
        self.type = type
        self.location = location
    
    def _restore_defaults(self) -> None:
        self.type = MediaTypeClass.IMAGE
        self.location = str()
    
    
    @property
    def type(self) -> Union[str, "MediaTypeClass"]:
        """Type of content the Media is storing, e.g. image, video, etc."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "MediaTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def location(self) -> str:
        """Where the media content is stored."""
        return self._inner_dict.get('location')  # type: ignore
    
    @location.setter
    def location(self, value: str) -> None:
        self._inner_dict['location'] = value
    
    
class MediaTypeClass(object):
    """Enum defining the type of content a Media object holds."""
    
    IMAGE = "IMAGE"
    """The Media holds an image."""
    
    
    
class MetadataAttributionClass(DictWrapper):
    """Information about who, why, and how this metadata was applied"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.MetadataAttribution")
    def __init__(self,
        time: int,
        actor: str,
        source: Union[None, str]=None,
        sourceDetail: Optional[Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.time = time
        self.actor = actor
        self.source = source
        if sourceDetail is None:
            # default: {}
            self.sourceDetail = dict()
        else:
            self.sourceDetail = sourceDetail
    
    def _restore_defaults(self) -> None:
        self.time = int()
        self.actor = str()
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
        self.sourceDetail = dict()
    
    
    @property
    def time(self) -> int:
        """When this metadata was updated."""
        return self._inner_dict.get('time')  # type: ignore
    
    @time.setter
    def time(self, value: int) -> None:
        self._inner_dict['time'] = value
    
    
    @property
    def actor(self) -> str:
        """The entity (e.g. a member URN) responsible for applying the assocated metadata. This can
    either be a user (in case of UI edits) or the datahub system for automation."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: str) -> None:
        self._inner_dict['actor'] = value
    
    
    @property
    def source(self) -> Union[None, str]:
        """The DataHub source responsible for applying the associated metadata. This will only be filled out
    when a DataHub source is responsible. This includes the specific metadata test urn, the automation urn."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, str]) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def sourceDetail(self) -> Dict[str, str]:
        """The details associated with why this metadata was applied. For example, this could include
    the actual regex rule, sql statement, ingestion pipeline ID, etc.
    Also can include flags like 'propagated'=true or 'inferred'=true."""
        return self._inner_dict.get('sourceDetail')  # type: ignore
    
    @sourceDetail.setter
    def sourceDetail(self, value: Dict[str, str]) -> None:
        self._inner_dict['sourceDetail'] = value
    
    
class MetadataProducerTypeClass(object):
    """The type of the producer of the metadata, e.g. reflective of the process that produced the metadata."""
    
    INGESTION_SOURCE = "INGESTION_SOURCE"
    """Operation was produced during a normal ingestion source run."""
    
    MONITOR = "MONITOR"
    """A running monitor produced the metadata."""
    
    
    
class OperationClass(_Aspect):
    """Operational info for an entity."""


    ASPECT_NAME = 'operation'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Operation")

    def __init__(self,
        timestampMillis: int,
        operationType: Union[str, "OperationTypeClass"],
        lastUpdatedTimestamp: int,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        actor: Union[None, str]=None,
        customOperationType: Union[None, str]=None,
        numAffectedRows: Union[None, int]=None,
        affectedDatasets: Union[None, List[str]]=None,
        sourceType: Union[None, Union[str, "OperationSourceTypeClass"]]=None,
        source: Union[None, "OperationSourceDetailsClass"]=None,
        customProperties: Union[None, Dict[str, str]]=None,
        queries: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.actor = actor
        self.operationType = operationType
        self.customOperationType = customOperationType
        self.numAffectedRows = numAffectedRows
        self.affectedDatasets = affectedDatasets
        self.sourceType = sourceType
        self.source = source
        self.customProperties = customProperties
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.queries = queries
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.actor = self.RECORD_SCHEMA.fields_dict["actor"].default
        self.operationType = OperationTypeClass.INSERT
        self.customOperationType = self.RECORD_SCHEMA.fields_dict["customOperationType"].default
        self.numAffectedRows = self.RECORD_SCHEMA.fields_dict["numAffectedRows"].default
        self.affectedDatasets = self.RECORD_SCHEMA.fields_dict["affectedDatasets"].default
        self.sourceType = self.RECORD_SCHEMA.fields_dict["sourceType"].default
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
        self.customProperties = self.RECORD_SCHEMA.fields_dict["customProperties"].default
        self.lastUpdatedTimestamp = int()
        self.queries = self.RECORD_SCHEMA.fields_dict["queries"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def actor(self) -> Union[None, str]:
        """Actor who issued this operation."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: Union[None, str]) -> None:
        self._inner_dict['actor'] = value
    
    
    @property
    def operationType(self) -> Union[str, "OperationTypeClass"]:
        """Operation type of change."""
        return self._inner_dict.get('operationType')  # type: ignore
    
    @operationType.setter
    def operationType(self, value: Union[str, "OperationTypeClass"]) -> None:
        self._inner_dict['operationType'] = value
    
    
    @property
    def customOperationType(self) -> Union[None, str]:
        """A custom type of operation. Required if operationType is CUSTOM."""
        return self._inner_dict.get('customOperationType')  # type: ignore
    
    @customOperationType.setter
    def customOperationType(self, value: Union[None, str]) -> None:
        self._inner_dict['customOperationType'] = value
    
    
    @property
    def numAffectedRows(self) -> Union[None, int]:
        """How many rows were affected by this operation."""
        return self._inner_dict.get('numAffectedRows')  # type: ignore
    
    @numAffectedRows.setter
    def numAffectedRows(self, value: Union[None, int]) -> None:
        self._inner_dict['numAffectedRows'] = value
    
    
    @property
    def affectedDatasets(self) -> Union[None, List[str]]:
        """Which other datasets were affected by this operation."""
        return self._inner_dict.get('affectedDatasets')  # type: ignore
    
    @affectedDatasets.setter
    def affectedDatasets(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['affectedDatasets'] = value
    
    
    @property
    def sourceType(self) -> Union[None, Union[str, "OperationSourceTypeClass"]]:
        """Source Type - E.g. which process produced this operation. Note that this field will be superseded by the richer information
    provided inside the "source" field (e.g source > producerType)"""
        return self._inner_dict.get('sourceType')  # type: ignore
    
    @sourceType.setter
    def sourceType(self, value: Union[None, Union[str, "OperationSourceTypeClass"]]) -> None:
        self._inner_dict['sourceType'] = value
    
    
    @property
    def source(self) -> Union[None, "OperationSourceDetailsClass"]:
        """More detailed information about the source of the operation."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "OperationSourceDetailsClass"]) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def customProperties(self) -> Union[None, Dict[str, str]]:
        """Custom properties"""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def lastUpdatedTimestamp(self) -> int:
        """The time at which the operation occurred. Would be better named 'operationTime'"""
        return self._inner_dict.get('lastUpdatedTimestamp')  # type: ignore
    
    @lastUpdatedTimestamp.setter
    def lastUpdatedTimestamp(self, value: int) -> None:
        self._inner_dict['lastUpdatedTimestamp'] = value
    
    
    @property
    def queries(self) -> Union[None, List[str]]:
        """Which queries were used in this operation."""
        return self._inner_dict.get('queries')  # type: ignore
    
    @queries.setter
    def queries(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['queries'] = value
    
    
class OperationSourceDetailsClass(DictWrapper):
    """Additional details about the origins of a captured source-platform Operation."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.OperationSourceDetails")
    def __init__(self,
        producerType: Union[str, "MetadataProducerTypeClass"],
        originType: Union[str, "OperationSourceOriginTypeClass"],
        producerUrn: Union[None, str]=None,
        field: Union[None, "FreshnessFieldSpecClass"]=None,
    ):
        super().__init__()
        
        self.producerType = producerType
        self.producerUrn = producerUrn
        self.originType = originType
        self.field = field
    
    def _restore_defaults(self) -> None:
        self.producerType = MetadataProducerTypeClass.INGESTION_SOURCE
        self.producerUrn = self.RECORD_SCHEMA.fields_dict["producerUrn"].default
        self.originType = OperationSourceOriginTypeClass.FIELD_VALUE
        self.field = self.RECORD_SCHEMA.fields_dict["field"].default
    
    
    @property
    def producerType(self) -> Union[str, "MetadataProducerTypeClass"]:
        """The specific type of producer for the operation."""
        return self._inner_dict.get('producerType')  # type: ignore
    
    @producerType.setter
    def producerType(self, value: Union[str, "MetadataProducerTypeClass"]) -> None:
        self._inner_dict['producerType'] = value
    
    
    @property
    def producerUrn(self) -> Union[None, str]:
        """The producer urn for the operation. Only provided is producerType == MONITOR currently,
    where it will be set to the monitor urn that sampled the operation. Ideally, this also contains
    the ingestion source urn if applicable."""
        return self._inner_dict.get('producerUrn')  # type: ignore
    
    @producerUrn.setter
    def producerUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['producerUrn'] = value
    
    
    @property
    def originType(self) -> Union[str, "OperationSourceOriginTypeClass"]:
        """The specific origin of the operation with regards to the source platform."""
        return self._inner_dict.get('originType')  # type: ignore
    
    @originType.setter
    def originType(self, value: Union[str, "OperationSourceOriginTypeClass"]) -> None:
        self._inner_dict['originType'] = value
    
    
    @property
    def field(self) -> Union[None, "FreshnessFieldSpecClass"]:
        """Information about the field / column. May be present when originType is FIELD_VALUE"""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: Union[None, "FreshnessFieldSpecClass"]) -> None:
        self._inner_dict['field'] = value
    
    
class OperationSourceOriginTypeClass(object):
    # No docs available.
    
    FIELD_VALUE = "FIELD_VALUE"
    """Operation was identified by querying a particular field / column value."""
    
    INFORMATION_SCHEMA = "INFORMATION_SCHEMA"
    """Operation was identified by inspecting an information schema table, or other system metadata table."""
    
    AUDIT_LOG = "AUDIT_LOG"
    """Operation was identified by inspecting an audit log API"""
    
    FILE_METADATA = "FILE_METADATA"
    """Operation was identified by inspecting underlying file system."""
    
    
    
class OperationSourceTypeClass(object):
    """The source of an operation. Note that this may be superceded by sourceDetails > producerType."""
    
    DATA_PROCESS = "DATA_PROCESS"
    """Provided by a Data Process"""
    
    DATA_PLATFORM = "DATA_PLATFORM"
    """Update was provided by consulting the data platform  itself."""
    
    
    
class OperationTypeClass(object):
    """Enum to define the operation type when an entity changes."""
    
    INSERT = "INSERT"
    """Rows were inserted"""
    
    UPDATE = "UPDATE"
    """Rows were updated"""
    
    DELETE = "DELETE"
    """Rows were deleted"""
    
    CREATE = "CREATE"
    """Asset was created"""
    
    ALTER = "ALTER"
    """Asset was altered"""
    
    DROP = "DROP"
    """Asset was dropped"""
    
    CUSTOM = "CUSTOM"
    """Custom asset operation. If this is set, ensure customOperationType is filled out."""
    
    UNKNOWN = "UNKNOWN"
    
    
    
class OriginClass(_Aspect):
    """Carries information about where an entity originated from."""


    ASPECT_NAME = 'origin'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Origin")

    def __init__(self,
        type: Union[str, "OriginTypeClass"],
        externalType: Union[None, str]=None,
        sourceDetails: Union[None, List["SourceDetailsClass"]]=None,
    ):
        super().__init__()
        
        self.type = type
        self.externalType = externalType
        self.sourceDetails = sourceDetails
    
    def _restore_defaults(self) -> None:
        self.type = OriginTypeClass.NATIVE
        self.externalType = self.RECORD_SCHEMA.fields_dict["externalType"].default
        self.sourceDetails = self.RECORD_SCHEMA.fields_dict["sourceDetails"].default
    
    
    @property
    def type(self) -> Union[str, "OriginTypeClass"]:
        """Where an entity originated from. Either NATIVE or EXTERNAL."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "OriginTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def externalType(self) -> Union[None, str]:
        """Only populated if type is EXTERNAL. The externalType of the entity, such as the name of the identity provider."""
        return self._inner_dict.get('externalType')  # type: ignore
    
    @externalType.setter
    def externalType(self, value: Union[None, str]) -> None:
        self._inner_dict['externalType'] = value
    
    
    @property
    def sourceDetails(self) -> Union[None, List["SourceDetailsClass"]]:
        """Details about the source(s) by which this asset was originated"""
        return self._inner_dict.get('sourceDetails')  # type: ignore
    
    @sourceDetails.setter
    def sourceDetails(self, value: Union[None, List["SourceDetailsClass"]]) -> None:
        self._inner_dict['sourceDetails'] = value
    
    
class OriginTypeClass(object):
    """Enum to define where an entity originated from."""
    
    NATIVE = "NATIVE"
    """The entity is native to DataHub."""
    
    EXTERNAL = "EXTERNAL"
    """The entity is external to DataHub."""
    
    
    
class OwnerClass(DictWrapper):
    """Ownership information"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Owner")
    def __init__(self,
        owner: str,
        type: Union[str, "OwnershipTypeClass"],
        typeUrn: Union[None, str]=None,
        source: Union[None, "OwnershipSourceClass"]=None,
        attribution: Union[None, "MetadataAttributionClass"]=None,
    ):
        super().__init__()
        
        self.owner = owner
        self.type = type
        self.typeUrn = typeUrn
        self.source = source
        self.attribution = attribution
    
    def _restore_defaults(self) -> None:
        self.owner = str()
        self.type = OwnershipTypeClass.CUSTOM
        self.typeUrn = self.RECORD_SCHEMA.fields_dict["typeUrn"].default
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
        self.attribution = self.RECORD_SCHEMA.fields_dict["attribution"].default
    
    
    @property
    def owner(self) -> str:
        """Owner URN, e.g. urn:li:corpuser:ldap, urn:li:corpGroup:group_name, and urn:li:multiProduct:mp_name
    (Caveat: only corpuser is currently supported in the frontend.)"""
        return self._inner_dict.get('owner')  # type: ignore
    
    @owner.setter
    def owner(self, value: str) -> None:
        self._inner_dict['owner'] = value
    
    
    @property
    def type(self) -> Union[str, "OwnershipTypeClass"]:
        """The type of the ownership"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "OwnershipTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def typeUrn(self) -> Union[None, str]:
        """The type of the ownership
    Urn of type O"""
        return self._inner_dict.get('typeUrn')  # type: ignore
    
    @typeUrn.setter
    def typeUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['typeUrn'] = value
    
    
    @property
    def source(self) -> Union[None, "OwnershipSourceClass"]:
        """Source information for the ownership"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "OwnershipSourceClass"]) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def attribution(self) -> Union[None, "MetadataAttributionClass"]:
        """Information about who, why, and how this metadata was applied"""
        return self._inner_dict.get('attribution')  # type: ignore
    
    @attribution.setter
    def attribution(self, value: Union[None, "MetadataAttributionClass"]) -> None:
        self._inner_dict['attribution'] = value
    
    
class OwnershipClass(_Aspect):
    """Ownership information of an entity."""


    ASPECT_NAME = 'ownership'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Ownership")

    def __init__(self,
        owners: List["OwnerClass"],
        ownerTypes: Optional[Union[Dict[str, List[str]], None]]=None,
        lastModified: Optional["AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.owners = owners
        if ownerTypes is None:
            # default: {}
            self.ownerTypes = dict()
        else:
            self.ownerTypes = ownerTypes
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.owners = list()
        self.ownerTypes = dict()
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
    
    
    @property
    def owners(self) -> List["OwnerClass"]:
        """List of owners of the entity."""
        return self._inner_dict.get('owners')  # type: ignore
    
    @owners.setter
    def owners(self, value: List["OwnerClass"]) -> None:
        self._inner_dict['owners'] = value
    
    
    @property
    def ownerTypes(self) -> Union[Dict[str, List[str]], None]:
        """Ownership type to Owners map, populated via mutation hook."""
        return self._inner_dict.get('ownerTypes')  # type: ignore
    
    @ownerTypes.setter
    def ownerTypes(self, value: Union[Dict[str, List[str]], None]) -> None:
        self._inner_dict['ownerTypes'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp containing who last modified the record and when. A value of 0 in the time field indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class OwnershipPromptResponseClass(DictWrapper):
    """Response for an ownership type prompt"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.OwnershipPromptResponse")
    def __init__(self,
        owners: List[str],
        ownershipTypeUrn: str,
    ):
        super().__init__()
        
        self.owners = owners
        self.ownershipTypeUrn = ownershipTypeUrn
    
    def _restore_defaults(self) -> None:
        self.owners = list()
        self.ownershipTypeUrn = str()
    
    
    @property
    def owners(self) -> List[str]:
        """The owners applied to an asset from this prompt response"""
        return self._inner_dict.get('owners')  # type: ignore
    
    @owners.setter
    def owners(self, value: List[str]) -> None:
        self._inner_dict['owners'] = value
    
    
    @property
    def ownershipTypeUrn(self) -> str:
        """The type of ownership applied from this prompt response"""
        return self._inner_dict.get('ownershipTypeUrn')  # type: ignore
    
    @ownershipTypeUrn.setter
    def ownershipTypeUrn(self, value: str) -> None:
        self._inner_dict['ownershipTypeUrn'] = value
    
    
class OwnershipSourceClass(DictWrapper):
    """Source/provider of the ownership information"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.OwnershipSource")
    def __init__(self,
        type: Union[str, "OwnershipSourceTypeClass"],
        url: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.url = url
    
    def _restore_defaults(self) -> None:
        self.type = OwnershipSourceTypeClass.AUDIT
        self.url = self.RECORD_SCHEMA.fields_dict["url"].default
    
    
    @property
    def type(self) -> Union[str, "OwnershipSourceTypeClass"]:
        """The type of the source"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "OwnershipSourceTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def url(self) -> Union[None, str]:
        """A reference URL for the source"""
        return self._inner_dict.get('url')  # type: ignore
    
    @url.setter
    def url(self, value: Union[None, str]) -> None:
        self._inner_dict['url'] = value
    
    
class OwnershipSourceTypeClass(object):
    # No docs available.
    
    AUDIT = "AUDIT"
    """Auditing system or audit logs"""
    
    DATABASE = "DATABASE"
    """Database, e.g. GRANTS table"""
    
    FILE_SYSTEM = "FILE_SYSTEM"
    """File system, e.g. file/directory owner"""
    
    ISSUE_TRACKING_SYSTEM = "ISSUE_TRACKING_SYSTEM"
    """Issue tracking system, e.g. Jira"""
    
    MANUAL = "MANUAL"
    """Manually provided by a user"""
    
    SERVICE = "SERVICE"
    """Other ownership-like service, e.g. Nuage, ACL service etc"""
    
    SOURCE_CONTROL = "SOURCE_CONTROL"
    """SCM system, e.g. GIT, SVN"""
    
    OTHER = "OTHER"
    """Other sources"""
    
    
    
class OwnershipTypeClass(object):
    """Asset owner types"""
    
    CUSTOM = "CUSTOM"
    """Set when ownership type is unknown or a when new one is specified as an ownership type entity for which we have no
    enum value for. This is used for backwards compatibility"""
    
    TECHNICAL_OWNER = "TECHNICAL_OWNER"
    """person or group who is responsible for technical aspects of the asset."""
    
    BUSINESS_OWNER = "BUSINESS_OWNER"
    """A person or group who is responsible for logical, or business related, aspects of the asset."""
    
    DATA_STEWARD = "DATA_STEWARD"
    """A steward, expert, or delegate responsible for the asset."""
    
    NONE = "NONE"
    """No specific type associated to the owner."""
    
    DEVELOPER = "DEVELOPER"
    """A person or group that is in charge of developing the code
    Deprecated! Use TECHNICAL_OWNER instead."""
    
    DATAOWNER = "DATAOWNER"
    """A person or group that is owning the data
    Deprecated! Use TECHNICAL_OWNER instead."""
    
    DELEGATE = "DELEGATE"
    """A person or a group that overseas the operation, e.g. a DBA or SRE.
    Deprecated! Use TECHNICAL_OWNER instead."""
    
    PRODUCER = "PRODUCER"
    """A person, group, or service that produces/generates the data
    Deprecated! Use TECHNICAL_OWNER instead."""
    
    CONSUMER = "CONSUMER"
    """A person, group, or service that consumes the data
    Deprecated! Use TECHNICAL_OWNER or BUSINESS_OWNER instead."""
    
    STAKEHOLDER = "STAKEHOLDER"
    """A person or a group that has direct business interest
    Deprecated! Use TECHNICAL_OWNER, BUSINESS_OWNER, or STEWARD instead."""
    
    
    
class ProposalsClass(_Aspect):
    """Proposals aspect for proposed tags and glossary terms for an entity.
    These are secondary indices and ActionRequests remain the source of truth."""


    ASPECT_NAME = 'proposals'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Proposals")

    def __init__(self,
        proposedTags: Union[None, List[str]]=None,
        proposedGlossaryTerms: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.proposedTags = proposedTags
        self.proposedGlossaryTerms = proposedGlossaryTerms
    
    def _restore_defaults(self) -> None:
        self.proposedTags = self.RECORD_SCHEMA.fields_dict["proposedTags"].default
        self.proposedGlossaryTerms = self.RECORD_SCHEMA.fields_dict["proposedGlossaryTerms"].default
    
    
    @property
    def proposedTags(self) -> Union[None, List[str]]:
        """Proposed tags for a given entity"""
        return self._inner_dict.get('proposedTags')  # type: ignore
    
    @proposedTags.setter
    def proposedTags(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['proposedTags'] = value
    
    
    @property
    def proposedGlossaryTerms(self) -> Union[None, List[str]]:
        """Proposed glossary terms for a given entity"""
        return self._inner_dict.get('proposedGlossaryTerms')  # type: ignore
    
    @proposedGlossaryTerms.setter
    def proposedGlossaryTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['proposedGlossaryTerms'] = value
    
    
class RoleAssociationClass(DictWrapper):
    """Properties of an applied Role. For now, just an Urn"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.RoleAssociation")
    def __init__(self,
        urn: str,
    ):
        super().__init__()
        
        self.urn = urn
    
    def _restore_defaults(self) -> None:
        self.urn = str()
    
    
    @property
    def urn(self) -> str:
        """Urn of the External Role"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
class SemanticContentClass(_Aspect):
    """Semantic content for enabling vector similarity search.
    
    This aspect stores chunked text and embedding vectors for any entity that supports semantic search. Generation of the data for this aspect should be built in tight collaboration with the embedding generator during semantic search query processing. Chunk determination and generation can happen somewhat independently
    The data in this aspect is directly passed along to the semantic search index.
    
    Design notes:
    - Supports multiple embedding models (e.g., different providers or versions)
    - Supports chunked content for long documents
    - Text field is optional to support privacy-sensitive use cases where
      only embeddings (not source text) are shared with DataHub"""


    ASPECT_NAME = 'semanticContent'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.SemanticContent")

    def __init__(self,
        embeddings: Dict[str, "EmbeddingModelDataClass"],
    ):
        super().__init__()
        
        self.embeddings = embeddings
    
    def _restore_defaults(self) -> None:
        self.embeddings = dict()
    
    
    @property
    def embeddings(self) -> Dict[str, "EmbeddingModelDataClass"]:
        """Map of embedding model name to embedding data.
    Key is the model identifier (e.g., cohere_embed_v3, openai_ada_002).
    Allows storing embeddings from multiple models simultaneously."""
        return self._inner_dict.get('embeddings')  # type: ignore
    
    @embeddings.setter
    def embeddings(self, value: Dict[str, "EmbeddingModelDataClass"]) -> None:
        self._inner_dict['embeddings'] = value
    
    
class SerializedValueClass(DictWrapper):
    """Captures the serialized value of a (usually) schema-d blob."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.SerializedValue")
    def __init__(self,
        blob: bytes,
        contentType: Optional[Union[str, "SerializedValueContentTypeClass"]]=None,
        schemaType: Union[None, Union[str, "SerializedValueSchemaTypeClass"]]=None,
        schemaRef: Union[None, str]=None,
    ):
        super().__init__()
        
        self.blob = blob
        if contentType is None:
            # default: 'JSON'
            self.contentType = self.RECORD_SCHEMA.fields_dict["contentType"].default
        else:
            self.contentType = contentType
        self.schemaType = schemaType
        self.schemaRef = schemaRef
    
    def _restore_defaults(self) -> None:
        self.blob = bytes()
        self.contentType = self.RECORD_SCHEMA.fields_dict["contentType"].default
        self.schemaType = self.RECORD_SCHEMA.fields_dict["schemaType"].default
        self.schemaRef = self.RECORD_SCHEMA.fields_dict["schemaRef"].default
    
    
    @property
    def blob(self) -> bytes:
        """The serialized blob value."""
        return self._inner_dict.get('blob')  # type: ignore
    
    @blob.setter
    def blob(self, value: bytes) -> None:
        self._inner_dict['blob'] = value
    
    
    @property
    def contentType(self) -> Union[str, "SerializedValueContentTypeClass"]:
        """The content-type of the serialized blob value."""
        return self._inner_dict.get('contentType')  # type: ignore
    
    @contentType.setter
    def contentType(self, value: Union[str, "SerializedValueContentTypeClass"]) -> None:
        self._inner_dict['contentType'] = value
    
    
    @property
    def schemaType(self) -> Union[None, Union[str, "SerializedValueSchemaTypeClass"]]:
        """The schema type for the schema that models the object that was serialized
           into the blob.
    Absence of this field indicates that the schema is not known.
    If the schema is known, the value should be set to the appropriate schema
    type.
    Use the NONE value if the existing schema categories do not apply."""
        return self._inner_dict.get('schemaType')  # type: ignore
    
    @schemaType.setter
    def schemaType(self, value: Union[None, Union[str, "SerializedValueSchemaTypeClass"]]) -> None:
        self._inner_dict['schemaType'] = value
    
    
    @property
    def schemaRef(self) -> Union[None, str]:
        """An optional reference to the schema that models the object.
    e.g., 'com.linkedin.pegasus2avro.platformresource.slack.SlackConversation'"""
        return self._inner_dict.get('schemaRef')  # type: ignore
    
    @schemaRef.setter
    def schemaRef(self, value: Union[None, str]) -> None:
        self._inner_dict['schemaRef'] = value
    
    
class SerializedValueContentTypeClass(object):
    # No docs available.
    
    JSON = "JSON"
    BINARY = "BINARY"
    
    
class SerializedValueSchemaTypeClass(object):
    # No docs available.
    
    AVRO = "AVRO"
    PROTOBUF = "PROTOBUF"
    PEGASUS = "PEGASUS"
    THRIFT = "THRIFT"
    JSON = "JSON"
    NONE = "NONE"
    
    
class ShareClass(_Aspect):
    """Aspect used for keeping track of metadata sharing info"""


    ASPECT_NAME = 'share'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Share")

    def __init__(self,
        lastShareResults: List["ShareResultClass"],
        lastUnshareResults: Union[None, List["ShareResultClass"]]=None,
    ):
        super().__init__()
        
        self.lastShareResults = lastShareResults
        self.lastUnshareResults = lastUnshareResults
    
    def _restore_defaults(self) -> None:
        self.lastShareResults = list()
        self.lastUnshareResults = self.RECORD_SCHEMA.fields_dict["lastUnshareResults"].default
    
    
    @property
    def lastShareResults(self) -> List["ShareResultClass"]:
        """The last share result for each destination that this entity has been shared with"""
        return self._inner_dict.get('lastShareResults')  # type: ignore
    
    @lastShareResults.setter
    def lastShareResults(self, value: List["ShareResultClass"]) -> None:
        self._inner_dict['lastShareResults'] = value
    
    
    @property
    def lastUnshareResults(self) -> Union[None, List["ShareResultClass"]]:
        """The last unshare result for each destination that this entity was
    previously shared with. A successfully unshared destination should not
    appear in the lastShareResults field."""
        return self._inner_dict.get('lastUnshareResults')  # type: ignore
    
    @lastUnshareResults.setter
    def lastUnshareResults(self, value: Union[None, List["ShareResultClass"]]) -> None:
        self._inner_dict['lastUnshareResults'] = value
    
    
class ShareConfigClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.ShareConfig")
    def __init__(self,
        enableUpstreamLineage: Union[None, bool]=None,
        enableDownstreamLineage: Union[None, bool]=None,
    ):
        super().__init__()
        
        self.enableUpstreamLineage = enableUpstreamLineage
        self.enableDownstreamLineage = enableDownstreamLineage
    
    def _restore_defaults(self) -> None:
        self.enableUpstreamLineage = self.RECORD_SCHEMA.fields_dict["enableUpstreamLineage"].default
        self.enableDownstreamLineage = self.RECORD_SCHEMA.fields_dict["enableDownstreamLineage"].default
    
    
    @property
    def enableUpstreamLineage(self) -> Union[None, bool]:
        """Upstream lineage was shared"""
        return self._inner_dict.get('enableUpstreamLineage')  # type: ignore
    
    @enableUpstreamLineage.setter
    def enableUpstreamLineage(self, value: Union[None, bool]) -> None:
        self._inner_dict['enableUpstreamLineage'] = value
    
    
    @property
    def enableDownstreamLineage(self) -> Union[None, bool]:
        """Downstream lineage was shared"""
        return self._inner_dict.get('enableDownstreamLineage')  # type: ignore
    
    @enableDownstreamLineage.setter
    def enableDownstreamLineage(self, value: Union[None, bool]) -> None:
        self._inner_dict['enableDownstreamLineage'] = value
    
    
class ShareResultClass(DictWrapper):
    """Info about the results from sharing metadata for a given entity"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.ShareResult")
    def __init__(self,
        destination: str,
        created: "AuditStampClass",
        lastAttempt: "AuditStampClass",
        status: Union[str, "ShareResultStateClass"],
        implicitShareEntity: Union[None, str]=None,
        lastAttemptRequestId: Union[None, str]=None,
        shareConfig: Union[None, "ShareConfigClass"]=None,
        lastSuccess: Union[None, "AuditStampClass"]=None,
        statusLastUpdated: Union[None, int]=None,
        message: Union[None, str]=None,
    ):
        super().__init__()
        
        self.destination = destination
        self.implicitShareEntity = implicitShareEntity
        self.created = created
        self.lastAttempt = lastAttempt
        self.lastAttemptRequestId = lastAttemptRequestId
        self.shareConfig = shareConfig
        self.lastSuccess = lastSuccess
        self.status = status
        self.statusLastUpdated = statusLastUpdated
        self.message = message
    
    def _restore_defaults(self) -> None:
        self.destination = str()
        self.implicitShareEntity = self.RECORD_SCHEMA.fields_dict["implicitShareEntity"].default
        self.created = AuditStampClass._construct_with_defaults()
        self.lastAttempt = AuditStampClass._construct_with_defaults()
        self.lastAttemptRequestId = self.RECORD_SCHEMA.fields_dict["lastAttemptRequestId"].default
        self.shareConfig = self.RECORD_SCHEMA.fields_dict["shareConfig"].default
        self.lastSuccess = self.RECORD_SCHEMA.fields_dict["lastSuccess"].default
        self.status = ShareResultStateClass.RUNNING
        self.statusLastUpdated = self.RECORD_SCHEMA.fields_dict["statusLastUpdated"].default
        self.message = self.RECORD_SCHEMA.fields_dict["message"].default
    
    
    @property
    def destination(self) -> str:
        """Urn of the DataHubConnection related to another Acryl instance"""
        return self._inner_dict.get('destination')  # type: ignore
    
    @destination.setter
    def destination(self, value: str) -> None:
        self._inner_dict['destination'] = value
    
    
    @property
    def implicitShareEntity(self) -> Union[None, str]:
        """If this share happened implicitly due to another entity being shared, this field
    will be populated with that entity urn. Example: if a dataset is shared, its containers
    will also be shared. The share result for the container will have the dataset urn here."""
        return self._inner_dict.get('implicitShareEntity')  # type: ignore
    
    @implicitShareEntity.setter
    def implicitShareEntity(self, value: Union[None, str]) -> None:
        self._inner_dict['implicitShareEntity'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp for when the first share request for the given destination occurred."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastAttempt(self) -> "AuditStampClass":
        """When did we get this share result and who requested the share. This will be the time
    that we try and execute the share on the backend, regardless of success."""
        return self._inner_dict.get('lastAttempt')  # type: ignore
    
    @lastAttempt.setter
    def lastAttempt(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastAttempt'] = value
    
    
    @property
    def lastAttemptRequestId(self) -> Union[None, str]:
        """The request id that generated this share result. This is the id of the request that triggered this share.
    This is primarily used for debugging purposes."""
        return self._inner_dict.get('lastAttemptRequestId')  # type: ignore
    
    @lastAttemptRequestId.setter
    def lastAttemptRequestId(self, value: Union[None, str]) -> None:
        self._inner_dict['lastAttemptRequestId'] = value
    
    
    @property
    def shareConfig(self) -> Union[None, "ShareConfigClass"]:
        """The config for this particular share result"""
        return self._inner_dict.get('shareConfig')  # type: ignore
    
    @shareConfig.setter
    def shareConfig(self, value: Union[None, "ShareConfigClass"]) -> None:
        self._inner_dict['shareConfig'] = value
    
    
    @property
    def lastSuccess(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp for the last time a share to this above destination successfully occurred"""
        return self._inner_dict.get('lastSuccess')  # type: ignore
    
    @lastSuccess.setter
    def lastSuccess(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastSuccess'] = value
    
    
    @property
    def status(self) -> Union[str, "ShareResultStateClass"]:
        """Status for this share result - whether or not it succeeded"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "ShareResultStateClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def statusLastUpdated(self) -> Union[None, int]:
        """The last time the status was updated. Timestamp in milliseconds since epoch.
    Useful for monitoring if the status is stale."""
        return self._inner_dict.get('statusLastUpdated')  # type: ignore
    
    @statusLastUpdated.setter
    def statusLastUpdated(self, value: Union[None, int]) -> None:
        self._inner_dict['statusLastUpdated'] = value
    
    
    @property
    def message(self) -> Union[None, str]:
        """Optional message for this share result. Error messages will be stored here.
    This message will be presented to the end user, so it should not include stack traces etc."""
        return self._inner_dict.get('message')  # type: ignore
    
    @message.setter
    def message(self, value: Union[None, str]) -> None:
        self._inner_dict['message'] = value
    
    
class ShareResultStateClass(object):
    # No docs available.
    
    RUNNING = "RUNNING"
    """The share request is still in progress"""
    
    SUCCESS = "SUCCESS"
    """The share was successful"""
    
    PARTIAL_SUCCESS = "PARTIAL_SUCCESS"
    """The share was partially successful. Some, but not all, aspects were shared."""
    
    FAILURE = "FAILURE"
    """The share was a failure"""
    
    
    
class SiblingsClass(_Aspect):
    """Siblings information of an entity."""


    ASPECT_NAME = 'siblings'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Siblings")

    def __init__(self,
        siblings: List[str],
        primary: bool,
    ):
        super().__init__()
        
        self.siblings = siblings
        self.primary = primary
    
    def _restore_defaults(self) -> None:
        self.siblings = list()
        self.primary = bool()
    
    
    @property
    def siblings(self) -> List[str]:
        """List of sibling entities"""
        return self._inner_dict.get('siblings')  # type: ignore
    
    @siblings.setter
    def siblings(self, value: List[str]) -> None:
        self._inner_dict['siblings'] = value
    
    
    @property
    def primary(self) -> bool:
        """If this is the leader entity of the set of siblings"""
        return self._inner_dict.get('primary')  # type: ignore
    
    @primary.setter
    def primary(self, value: bool) -> None:
        self._inner_dict['primary'] = value
    
    
class SourceDetailsClass(DictWrapper):
    """Info about how this asset was brought into DataHub"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.SourceDetails")
    def __init__(self,
        source: str,
        platform: str,
        lastModified: "AuditStampClass",
        mechanism: Union[str, "SyncMechanismClass"],
        properties: Optional[Union[Dict[str, str], None]]=None,
    ):
        super().__init__()
        
        self.source = source
        self.platform = platform
        self.lastModified = lastModified
        self.mechanism = mechanism
        if properties is None:
            # default: {}
            self.properties = dict()
        else:
            self.properties = properties
    
    def _restore_defaults(self) -> None:
        self.source = str()
        self.platform = str()
        self.lastModified = AuditStampClass._construct_with_defaults()
        self.mechanism = SyncMechanismClass.INGEST
        self.properties = dict()
    
    
    @property
    def source(self) -> str:
        """Urn of the source of this asset. Could be an ingestion source (e.g. urn:li:dataHubIngestionSource:1234), an acryl
        platform instance, etc."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: str) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def platform(self) -> str:
        """Urn of the platform this asset originated from ie. urn:li:dataPlatform:snowflake for snowflake ingestion
    or urn:li:dataPlatform:acryl for assets synced from another catalog instance."""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp for when this asset was synced"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def mechanism(self) -> Union[str, "SyncMechanismClass"]:
        """The means by which this asset got synchronized"""
        return self._inner_dict.get('mechanism')  # type: ignore
    
    @mechanism.setter
    def mechanism(self, value: Union[str, "SyncMechanismClass"]) -> None:
        self._inner_dict['mechanism'] = value
    
    
    @property
    def properties(self) -> Union[Dict[str, str], None]:
        """Additional information related to the origin of this metadata"""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Union[Dict[str, str], None]) -> None:
        self._inner_dict['properties'] = value
    
    
class StatusClass(_Aspect):
    """The lifecycle status metadata of an entity, e.g. dataset, metric, feature, etc.
    This aspect is used to represent soft deletes conventionally."""


    ASPECT_NAME = 'status'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.Status")

    def __init__(self,
        removed: Optional[bool]=None,
    ):
        super().__init__()
        
        if removed is None:
            # default: False
            self.removed = self.RECORD_SCHEMA.fields_dict["removed"].default
        else:
            self.removed = removed
    
    def _restore_defaults(self) -> None:
        self.removed = self.RECORD_SCHEMA.fields_dict["removed"].default
    
    
    @property
    def removed(self) -> bool:
        """Whether the entity has been removed (soft-deleted)."""
        return self._inner_dict.get('removed')  # type: ignore
    
    @removed.setter
    def removed(self, value: bool) -> None:
        self._inner_dict['removed'] = value
    
    
class StructuredPropertyPromptResponseClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.StructuredPropertyPromptResponse")
    def __init__(self,
        propertyUrn: str,
        values: List[Union[str, float]],
    ):
        super().__init__()
        
        self.propertyUrn = propertyUrn
        self.values = values
    
    def _restore_defaults(self) -> None:
        self.propertyUrn = str()
        self.values = list()
    
    
    @property
    def propertyUrn(self) -> str:
        """Which property was applied from this prompt response"""
        return self._inner_dict.get('propertyUrn')  # type: ignore
    
    @propertyUrn.setter
    def propertyUrn(self, value: str) -> None:
        self._inner_dict['propertyUrn'] = value
    
    
    @property
    def values(self) -> List[Union[str, float]]:
        """Which values for the given property were applied from this prompt response"""
        return self._inner_dict.get('values')  # type: ignore
    
    @values.setter
    def values(self, value: List[Union[str, float]]) -> None:
        self._inner_dict['values'] = value
    
    
class SubTypesClass(_Aspect):
    """Sub Types. Use this aspect to specialize a generic Entity
    e.g. Making a Dataset also be a View or also be a LookerExplore"""


    ASPECT_NAME = 'subTypes'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.SubTypes")

    def __init__(self,
        typeNames: List[str],
    ):
        super().__init__()
        
        self.typeNames = typeNames
    
    def _restore_defaults(self) -> None:
        self.typeNames = list()
    
    
    @property
    def typeNames(self) -> List[str]:
        """The names of the specific types."""
        return self._inner_dict.get('typeNames')  # type: ignore
    
    @typeNames.setter
    def typeNames(self, value: List[str]) -> None:
        self._inner_dict['typeNames'] = value
    
    
class SyncMechanismClass(object):
    # No docs available.
    
    INGEST = "INGEST"
    """Synced via ingestion recipes"""
    
    SHARE = "SHARE"
    """Synced via metadata sharing with another Acryl instance"""
    
    API = "API"
    """Synced via the API (pushed from clients using the API directly)"""
    
    OTHER = "OTHER"
    """Synced via some other mechanism (used as a placeholder for incubating
          future mechanisms)"""
    
    
    
class TagAssociationClass(DictWrapper):
    """Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.
    propagation parameters."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.TagAssociation")
    def __init__(self,
        tag: str,
        context: Union[None, str]=None,
        attribution: Union[None, "MetadataAttributionClass"]=None,
    ):
        super().__init__()
        
        self.tag = tag
        self.context = context
        self.attribution = attribution
    
    def _restore_defaults(self) -> None:
        self.tag = str()
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
        self.attribution = self.RECORD_SCHEMA.fields_dict["attribution"].default
    
    
    @property
    def tag(self) -> str:
        """Urn of the applied tag"""
        return self._inner_dict.get('tag')  # type: ignore
    
    @tag.setter
    def tag(self, value: str) -> None:
        self._inner_dict['tag'] = value
    
    
    @property
    def context(self) -> Union[None, str]:
        """Additional context about the association"""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, str]) -> None:
        self._inner_dict['context'] = value
    
    
    @property
    def attribution(self) -> Union[None, "MetadataAttributionClass"]:
        """Information about who, why, and how this metadata was applied"""
        return self._inner_dict.get('attribution')  # type: ignore
    
    @attribution.setter
    def attribution(self, value: Union[None, "MetadataAttributionClass"]) -> None:
        self._inner_dict['attribution'] = value
    
    
class TimeStampClass(DictWrapper):
    """A standard event timestamp"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.TimeStamp")
    def __init__(self,
        time: int,
        actor: Union[None, str]=None,
    ):
        super().__init__()
        
        self.time = time
        self.actor = actor
    
    def _restore_defaults(self) -> None:
        self.time = int()
        self.actor = self.RECORD_SCHEMA.fields_dict["actor"].default
    
    
    @property
    def time(self) -> int:
        """When did the event occur"""
        return self._inner_dict.get('time')  # type: ignore
    
    @time.setter
    def time(self, value: int) -> None:
        self._inner_dict['time'] = value
    
    
    @property
    def actor(self) -> Union[None, str]:
        """Optional: The actor urn involved in the event."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: Union[None, str]) -> None:
        self._inner_dict['actor'] = value
    
    
class VersionPropertiesClass(_Aspect):
    """Properties about a versioned asset i.e. dataset, ML Model, etc."""


    ASPECT_NAME = 'versionProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.VersionProperties")

    def __init__(self,
        versionSet: str,
        version: "VersionTagClass",
        sortId: str,
        aliases: Optional[List["VersionTagClass"]]=None,
        comment: Union[None, str]=None,
        versioningScheme: Optional[Union[str, "VersioningSchemeClass"]]=None,
        sourceCreatedTimestamp: Union[None, "AuditStampClass"]=None,
        metadataCreatedTimestamp: Union[None, "AuditStampClass"]=None,
        isLatest: Union[None, bool]=None,
    ):
        super().__init__()
        
        self.versionSet = versionSet
        self.version = version
        if aliases is None:
            # default: []
            self.aliases = list()
        else:
            self.aliases = aliases
        self.comment = comment
        self.sortId = sortId
        if versioningScheme is None:
            # default: 'LEXICOGRAPHIC_STRING'
            self.versioningScheme = self.RECORD_SCHEMA.fields_dict["versioningScheme"].default
        else:
            self.versioningScheme = versioningScheme
        self.sourceCreatedTimestamp = sourceCreatedTimestamp
        self.metadataCreatedTimestamp = metadataCreatedTimestamp
        self.isLatest = isLatest
    
    def _restore_defaults(self) -> None:
        self.versionSet = str()
        self.version = VersionTagClass._construct_with_defaults()
        self.aliases = list()
        self.comment = self.RECORD_SCHEMA.fields_dict["comment"].default
        self.sortId = str()
        self.versioningScheme = self.RECORD_SCHEMA.fields_dict["versioningScheme"].default
        self.sourceCreatedTimestamp = self.RECORD_SCHEMA.fields_dict["sourceCreatedTimestamp"].default
        self.metadataCreatedTimestamp = self.RECORD_SCHEMA.fields_dict["metadataCreatedTimestamp"].default
        self.isLatest = self.RECORD_SCHEMA.fields_dict["isLatest"].default
    
    
    @property
    def versionSet(self) -> str:
        """The linked Version Set entity that ties multiple versioned assets together"""
        return self._inner_dict.get('versionSet')  # type: ignore
    
    @versionSet.setter
    def versionSet(self, value: str) -> None:
        self._inner_dict['versionSet'] = value
    
    
    @property
    def version(self) -> "VersionTagClass":
        """Label for this versioned asset, is unique within a version set"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: "VersionTagClass") -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def aliases(self) -> List["VersionTagClass"]:
        """Associated aliases for this versioned asset"""
        return self._inner_dict.get('aliases')  # type: ignore
    
    @aliases.setter
    def aliases(self, value: List["VersionTagClass"]) -> None:
        self._inner_dict['aliases'] = value
    
    
    @property
    def comment(self) -> Union[None, str]:
        """Comment documenting what this version was created for, changes, or represents"""
        return self._inner_dict.get('comment')  # type: ignore
    
    @comment.setter
    def comment(self, value: Union[None, str]) -> None:
        self._inner_dict['comment'] = value
    
    
    @property
    def sortId(self) -> str:
        """Sort identifier that determines where a version lives in the order of the Version Set.
    What this looks like depends on the Version Scheme. For sort ids generated by DataHub we use an 8 character string representation."""
        return self._inner_dict.get('sortId')  # type: ignore
    
    @sortId.setter
    def sortId(self, value: str) -> None:
        self._inner_dict['sortId'] = value
    
    
    @property
    def versioningScheme(self) -> Union[str, "VersioningSchemeClass"]:
        """What versioning scheme `sortId` belongs to.
    Defaults to a plain string that is lexicographically sorted."""
        return self._inner_dict.get('versioningScheme')  # type: ignore
    
    @versioningScheme.setter
    def versioningScheme(self, value: Union[str, "VersioningSchemeClass"]) -> None:
        self._inner_dict['versioningScheme'] = value
    
    
    @property
    def sourceCreatedTimestamp(self) -> Union[None, "AuditStampClass"]:
        """Timestamp reflecting when this asset version was created in the source system."""
        return self._inner_dict.get('sourceCreatedTimestamp')  # type: ignore
    
    @sourceCreatedTimestamp.setter
    def sourceCreatedTimestamp(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['sourceCreatedTimestamp'] = value
    
    
    @property
    def metadataCreatedTimestamp(self) -> Union[None, "AuditStampClass"]:
        """Timestamp reflecting when the metadata for this version was created in DataHub"""
        return self._inner_dict.get('metadataCreatedTimestamp')  # type: ignore
    
    @metadataCreatedTimestamp.setter
    def metadataCreatedTimestamp(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['metadataCreatedTimestamp'] = value
    
    
    @property
    def isLatest(self) -> Union[None, bool]:
        """Marks whether this version is currently the latest. Set by a side effect and should not be modified by API."""
        return self._inner_dict.get('isLatest')  # type: ignore
    
    @isLatest.setter
    def isLatest(self, value: Union[None, bool]) -> None:
        self._inner_dict['isLatest'] = value
    
    
class VersionTagClass(DictWrapper):
    """A resource-defined string representing the resource state for the purpose of concurrency control"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.VersionTag")
    def __init__(self,
        versionTag: Union[None, str]=None,
        metadataAttribution: Union[None, "MetadataAttributionClass"]=None,
    ):
        super().__init__()
        
        self.versionTag = versionTag
        self.metadataAttribution = metadataAttribution
    
    def _restore_defaults(self) -> None:
        self.versionTag = self.RECORD_SCHEMA.fields_dict["versionTag"].default
        self.metadataAttribution = self.RECORD_SCHEMA.fields_dict["metadataAttribution"].default
    
    
    @property
    def versionTag(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('versionTag')  # type: ignore
    
    @versionTag.setter
    def versionTag(self, value: Union[None, str]) -> None:
        self._inner_dict['versionTag'] = value
    
    
    @property
    def metadataAttribution(self) -> Union[None, "MetadataAttributionClass"]:
        # No docs available.
        return self._inner_dict.get('metadataAttribution')  # type: ignore
    
    @metadataAttribution.setter
    def metadataAttribution(self, value: Union[None, "MetadataAttributionClass"]) -> None:
        self._inner_dict['metadataAttribution'] = value
    
    
class WindowDurationClass(object):
    """Enum to define the length of a bucket when doing aggregations"""
    
    YEAR = "YEAR"
    MONTH = "MONTH"
    WEEK = "WEEK"
    DAY = "DAY"
    HOUR = "HOUR"
    
    
class TransformationTypeClass(object):
    """Type of the transformation involved in generating destination fields from source fields."""
    
    BLACKBOX = "BLACKBOX"
    """Field transformation expressed as unknown black box function."""
    
    IDENTITY = "IDENTITY"
    """Field transformation expressed as Identity function."""
    
    
    
class UDFTransformerClass(DictWrapper):
    """Field transformation expressed in UDF"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.common.fieldtransformer.UDFTransformer")
    def __init__(self,
        udf: str,
    ):
        super().__init__()
        
        self.udf = udf
    
    def _restore_defaults(self) -> None:
        self.udf = str()
    
    
    @property
    def udf(self) -> str:
        """A UDF mentioning how the source fields got transformed to destination field. This is the FQCN(Fully Qualified Class Name) of the udf."""
        return self._inner_dict.get('udf')  # type: ignore
    
    @udf.setter
    def udf(self, value: str) -> None:
        self._inner_dict['udf'] = value
    
    
class DataHubConnectionDetailsClass(_Aspect):
    """Information about a connection to an external platform."""


    ASPECT_NAME = 'dataHubConnectionDetails'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.connection.DataHubConnectionDetails")

    def __init__(self,
        type: Union[str, "DataHubConnectionDetailsTypeClass"],
        name: Union[None, str]=None,
        json: Union[None, "DataHubJsonConnectionClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.name = name
        self.json = json
    
    def _restore_defaults(self) -> None:
        self.type = DataHubConnectionDetailsTypeClass.JSON
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.json = self.RECORD_SCHEMA.fields_dict["json"].default
    
    
    @property
    def type(self) -> Union[str, "DataHubConnectionDetailsTypeClass"]:
        """The type of the connection. This defines the schema / encoding of the connection details."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DataHubConnectionDetailsTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the connection"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def json(self) -> Union[None, "DataHubJsonConnectionClass"]:
        """An JSON payload containing raw connection details.
    This will be present if the type is JSON."""
        return self._inner_dict.get('json')  # type: ignore
    
    @json.setter
    def json(self, value: Union[None, "DataHubJsonConnectionClass"]) -> None:
        self._inner_dict['json'] = value
    
    
class DataHubConnectionDetailsTypeClass(object):
    # No docs available.
    
    JSON = "JSON"
    """A json-encoded set of connection details"""
    
    
    
class DataHubJsonConnectionClass(DictWrapper):
    """A set of connection details consisting of an encrypted JSON blob."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.connection.DataHubJsonConnection")
    def __init__(self,
        encryptedBlob: str,
    ):
        super().__init__()
        
        self.encryptedBlob = encryptedBlob
    
    def _restore_defaults(self) -> None:
        self.encryptedBlob = str()
    
    
    @property
    def encryptedBlob(self) -> str:
        """The encrypted JSON connection details."""
        return self._inner_dict.get('encryptedBlob')  # type: ignore
    
    @encryptedBlob.setter
    def encryptedBlob(self, value: str) -> None:
        self._inner_dict['encryptedBlob'] = value
    
    
class ConstraintInfoClass(_Aspect):
    """Information about a constraint."""


    ASPECT_NAME = 'constraintInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.constraint.ConstraintInfo")

    def __init__(self,
        displayName: str,
        type: str,
        description: Union[None, str]=None,
        resources: Union[None, "DataHubResourceFilterClass"]=None,
        params: Union[None, "ConstraintParamsClass"]=None,
    ):
        super().__init__()
        
        self.displayName = displayName
        self.description = description
        self.type = type
        self.resources = resources
        self.params = params
    
    def _restore_defaults(self) -> None:
        self.displayName = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.type = str()
        self.resources = self.RECORD_SCHEMA.fields_dict["resources"].default
        self.params = self.RECORD_SCHEMA.fields_dict["params"].default
    
    
    @property
    def displayName(self) -> str:
        """Display name of the constraint"""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: str) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the Constraint"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def type(self) -> str:
        """The type of constraint"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def resources(self) -> Union[None, "DataHubResourceFilterClass"]:
        """The resource that the policy applies to. Not required for some 'Platform' privileges."""
        return self._inner_dict.get('resources')  # type: ignore
    
    @resources.setter
    def resources(self, value: Union[None, "DataHubResourceFilterClass"]) -> None:
        self._inner_dict['resources'] = value
    
    
    @property
    def params(self) -> Union[None, "ConstraintParamsClass"]:
        """Parameters specific for a particular Constraint type"""
        return self._inner_dict.get('params')  # type: ignore
    
    @params.setter
    def params(self, value: Union[None, "ConstraintParamsClass"]) -> None:
        self._inner_dict['params'] = value
    
    
class ConstraintParamsClass(DictWrapper):
    """Params provided for a specific instance of a constraint."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.constraint.ConstraintParams")
    def __init__(self,
        hasGlossaryTermInNodeParams: Union[None, "GlossaryTermInNodeConstraintClass"]=None,
    ):
        super().__init__()
        
        self.hasGlossaryTermInNodeParams = hasGlossaryTermInNodeParams
    
    def _restore_defaults(self) -> None:
        self.hasGlossaryTermInNodeParams = self.RECORD_SCHEMA.fields_dict["hasGlossaryTermInNodeParams"].default
    
    
    @property
    def hasGlossaryTermInNodeParams(self) -> Union[None, "GlossaryTermInNodeConstraintClass"]:
        """An optional set of information specific to glossary node constraints."""
        return self._inner_dict.get('hasGlossaryTermInNodeParams')  # type: ignore
    
    @hasGlossaryTermInNodeParams.setter
    def hasGlossaryTermInNodeParams(self, value: Union[None, "GlossaryTermInNodeConstraintClass"]) -> None:
        self._inner_dict['hasGlossaryTermInNodeParams'] = value
    
    
class GlossaryTermInNodeConstraintClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.constraint.GlossaryTermInNodeConstraint")
    def __init__(self,
        glossaryNode: str,
    ):
        super().__init__()
        
        self.glossaryNode = glossaryNode
    
    def _restore_defaults(self) -> None:
        self.glossaryNode = str()
    
    
    @property
    def glossaryNode(self) -> str:
        """The glossary node which the constrained entities must have attached to them"""
        return self._inner_dict.get('glossaryNode')  # type: ignore
    
    @glossaryNode.setter
    def glossaryNode(self, value: str) -> None:
        self._inner_dict['glossaryNode'] = value
    
    
class ContainerClass(_Aspect):
    """Link from an asset to its parent container"""


    ASPECT_NAME = 'container'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.container.Container")

    def __init__(self,
        container: str,
    ):
        super().__init__()
        
        self.container = container
    
    def _restore_defaults(self) -> None:
        self.container = str()
    
    
    @property
    def container(self) -> str:
        """The parent container of an asset"""
        return self._inner_dict.get('container')  # type: ignore
    
    @container.setter
    def container(self, value: str) -> None:
        self._inner_dict['container'] = value
    
    
class ContainerPropertiesClass(_Aspect):
    """Information about a Asset Container as received from a 3rd party source system"""


    ASPECT_NAME = 'containerProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.container.ContainerProperties")

    def __init__(self,
        name: str,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        qualifiedName: Union[None, str]=None,
        description: Union[None, str]=None,
        env: Union[None, Union[str, "FabricTypeClass"]]=None,
        created: Union[None, "TimeStampClass"]=None,
        lastModified: Union[None, "TimeStampClass"]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.name = name
        self.qualifiedName = qualifiedName
        self.description = description
        self.env = env
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = str()
        self.qualifiedName = self.RECORD_SCHEMA.fields_dict["qualifiedName"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.env = self.RECORD_SCHEMA.fields_dict["env"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> str:
        """Display name of the Asset Container"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def qualifiedName(self) -> Union[None, str]:
        """Fully-qualified name of the Container"""
        return self._inner_dict.get('qualifiedName')  # type: ignore
    
    @qualifiedName.setter
    def qualifiedName(self, value: Union[None, str]) -> None:
        self._inner_dict['qualifiedName'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the Asset Container as it exists inside a source system"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def env(self) -> Union[None, Union[str, "FabricTypeClass"]]:
        """Environment for this flow"""
        return self._inner_dict.get('env')  # type: ignore
    
    @env.setter
    def env(self, value: Union[None, Union[str, "FabricTypeClass"]]) -> None:
        self._inner_dict['env'] = value
    
    
    @property
    def created(self) -> Union[None, "TimeStampClass"]:
        """A timestamp documenting when the asset was created in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "TimeStampClass"]:
        """A timestamp documenting when the asset was last modified in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
class EditableContainerPropertiesClass(_Aspect):
    """Editable information about an Asset Container as defined on the DataHub Platform"""


    ASPECT_NAME = 'editableContainerProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.container.EditableContainerProperties")

    def __init__(self,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the Asset Container as its received on the DataHub Platform"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class DataHubAiConversationActorClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.conversation.DataHubAiConversationActor")
    def __init__(self,
        type: Union[str, "DataHubAiConversationActorTypeClass"],
        actor: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.actor = actor
    
    def _restore_defaults(self) -> None:
        self.type = DataHubAiConversationActorTypeClass.USER
        self.actor = self.RECORD_SCHEMA.fields_dict["actor"].default
    
    
    @property
    def type(self) -> Union[str, "DataHubAiConversationActorTypeClass"]:
        """The type of actor """
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DataHubAiConversationActorTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def actor(self) -> Union[None, str]:
        """The actor that has sent the message.
    Required if type is not AGENT."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: Union[None, str]) -> None:
        self._inner_dict['actor'] = value
    
    
class DataHubAiConversationActorTypeClass(object):
    # No docs available.
    
    USER = "USER"
    """A user initiated message. """
    
    AGENT = "AGENT"
    """An agent initiated message. """
    
    
    
class DataHubAiConversationContextClass(DictWrapper):
    """Context about where and how a conversation is being used.
    This helps the AI agent understand what the user is looking at and working on."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.conversation.DataHubAiConversationContext")
    def __init__(self,
        text: str,
        entityUrns: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.text = text
        self.entityUrns = entityUrns
    
    def _restore_defaults(self) -> None:
        self.text = str()
        self.entityUrns = self.RECORD_SCHEMA.fields_dict["entityUrns"].default
    
    
    @property
    def text(self) -> str:
        """Natural language context description for the AI agent.
    This will be included in the system prompt to help the agent
    understand what the user is looking at and working on.
    Example use cases: troubleshooting execution runs, configuring ingestion sources."""
        return self._inner_dict.get('text')  # type: ignore
    
    @text.setter
    def text(self, value: str) -> None:
        self._inner_dict['text'] = value
    
    
    @property
    def entityUrns(self) -> Union[None, List[str]]:
        """Optional URNs of the entities this conversation is about.
    Useful for linking conversations to specific entities such as execution runs or datasets."""
        return self._inner_dict.get('entityUrns')  # type: ignore
    
    @entityUrns.setter
    def entityUrns(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['entityUrns'] = value
    
    
class DataHubAiConversationInfoClass(_Aspect):
    """Conversation info """


    ASPECT_NAME = 'dataHubAiConversationInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.conversation.DataHubAiConversationInfo")

    def __init__(self,
        messages: List["DataHubAiConversationMessageClass"],
        created: "AuditStampClass",
        title: Union[None, str]=None,
        originType: Optional[Union[str, "DataHubAiConversationOriginTypeClass"]]=None,
        context: Union[None, "DataHubAiConversationContextClass"]=None,
    ):
        super().__init__()
        
        self.title = title
        self.messages = messages
        self.created = created
        if originType is None:
            # default: 'DATAHUB_UI'
            self.originType = self.RECORD_SCHEMA.fields_dict["originType"].default
        else:
            self.originType = originType
        self.context = context
    
    def _restore_defaults(self) -> None:
        self.title = self.RECORD_SCHEMA.fields_dict["title"].default
        self.messages = list()
        self.created = AuditStampClass._construct_with_defaults()
        self.originType = self.RECORD_SCHEMA.fields_dict["originType"].default
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
    
    
    @property
    def title(self) -> Union[None, str]:
        """Optional title for the conversation. """
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: Union[None, str]) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def messages(self) -> List["DataHubAiConversationMessageClass"]:
        """Messages in the conversation"""
        return self._inner_dict.get('messages')  # type: ignore
    
    @messages.setter
    def messages(self, value: List["DataHubAiConversationMessageClass"]) -> None:
        self._inner_dict['messages'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """The time and actor who initiated the conversation"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def originType(self) -> Union[str, "DataHubAiConversationOriginTypeClass"]:
        """Origin type for the chat session"""
        return self._inner_dict.get('originType')  # type: ignore
    
    @originType.setter
    def originType(self, value: Union[str, "DataHubAiConversationOriginTypeClass"]) -> None:
        self._inner_dict['originType'] = value
    
    
    @property
    def context(self) -> Union[None, "DataHubAiConversationContextClass"]:
        """Optional context about where and how this conversation is being used.
    Provides natural language context to help the AI agent understand
    what the user is looking at and working on."""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, "DataHubAiConversationContextClass"]) -> None:
        self._inner_dict['context'] = value
    
    
class DataHubAiConversationMessageClass(DictWrapper):
    """Conversation info """
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.conversation.DataHubAiConversationMessage")
    def __init__(self,
        type: Union[str, "DataHubAiConversationMessageTypeClass"],
        time: int,
        actor: "DataHubAiConversationActorClass",
        content: "DataHubAiConversationMessageContentClass",
        agentName: Union[None, str]=None,
        context: Union[None, "DataHubAiConversationContextClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.time = time
        self.actor = actor
        self.content = content
        self.agentName = agentName
        self.context = context
    
    def _restore_defaults(self) -> None:
        self.type = DataHubAiConversationMessageTypeClass.TEXT
        self.time = int()
        self.actor = DataHubAiConversationActorClass._construct_with_defaults()
        self.content = DataHubAiConversationMessageContentClass._construct_with_defaults()
        self.agentName = self.RECORD_SCHEMA.fields_dict["agentName"].default
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
    
    
    @property
    def type(self) -> Union[str, "DataHubAiConversationMessageTypeClass"]:
        """The type of message"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DataHubAiConversationMessageTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def time(self) -> int:
        """Timestamp in milliseconds"""
        return self._inner_dict.get('time')  # type: ignore
    
    @time.setter
    def time(self, value: int) -> None:
        self._inner_dict['time'] = value
    
    
    @property
    def actor(self) -> "DataHubAiConversationActorClass":
        """Messages in the conversation"""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: "DataHubAiConversationActorClass") -> None:
        self._inner_dict['actor'] = value
    
    
    @property
    def content(self) -> "DataHubAiConversationMessageContentClass":
        """The contents of the message."""
        return self._inner_dict.get('content')  # type: ignore
    
    @content.setter
    def content(self, value: "DataHubAiConversationMessageContentClass") -> None:
        self._inner_dict['content'] = value
    
    
    @property
    def agentName(self) -> Union[None, str]:
        """The name of the agent that generated this message (if applicable)."""
        return self._inner_dict.get('agentName')  # type: ignore
    
    @agentName.setter
    def agentName(self, value: Union[None, str]) -> None:
        self._inner_dict['agentName'] = value
    
    
    @property
    def context(self) -> Union[None, "DataHubAiConversationContextClass"]:
        """Optional context about where and how this message is being sent.
    When provided, this context is combined with the conversation-level context
    to give the AI agent the most up-to-date information about what the user is working on.
    This allows for dynamic context that changes as the user navigates through different screens or steps."""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, "DataHubAiConversationContextClass"]) -> None:
        self._inner_dict['context'] = value
    
    
class DataHubAiConversationMessageContentClass(DictWrapper):
    """Conversation message content info """
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.conversation.DataHubAiConversationMessageContent")
    def __init__(self,
        text: str,
    ):
        super().__init__()
        
        self.text = text
    
    def _restore_defaults(self) -> None:
        self.text = str()
    
    
    @property
    def text(self) -> str:
        """Raw message text"""
        return self._inner_dict.get('text')  # type: ignore
    
    @text.setter
    def text(self, value: str) -> None:
        self._inner_dict['text'] = value
    
    
class DataHubAiConversationMessageTypeClass(object):
    # No docs available.
    
    TEXT = "TEXT"
    TOOL_CALL = "TOOL_CALL"
    TOOL_RESULT = "TOOL_RESULT"
    THINKING = "THINKING"
    
    
class DataHubAiConversationOriginTypeClass(object):
    # No docs available.
    
    DATAHUB_UI = "DATAHUB_UI"
    """Chat session originated in DataHub UI"""
    
    INGESTION_UI = "INGESTION_UI"
    """Chat session originated in Ingestion UI"""
    
    
    
class DashboardInfoClass(_Aspect):
    """Information about a dashboard"""


    ASPECT_NAME = 'dashboardInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dashboard.DashboardInfo")

    def __init__(self,
        title: str,
        description: str,
        lastModified: "ChangeAuditStampsClass",
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        charts: Optional[List[str]]=None,
        chartEdges: Union[None, List["EdgeClass"]]=None,
        datasets: Optional[List[str]]=None,
        datasetEdges: Union[None, List["EdgeClass"]]=None,
        dashboards: Optional[List["EdgeClass"]]=None,
        dashboardUrl: Union[None, str]=None,
        access: Union[None, Union[str, "AccessLevelClass"]]=None,
        lastRefreshed: Union[None, int]=None,
        lastRefreshedBy: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.title = title
        self.description = description
        if charts is None:
            # default: []
            self.charts = list()
        else:
            self.charts = charts
        self.chartEdges = chartEdges
        if datasets is None:
            # default: []
            self.datasets = list()
        else:
            self.datasets = datasets
        self.datasetEdges = datasetEdges
        if dashboards is None:
            # default: []
            self.dashboards = list()
        else:
            self.dashboards = dashboards
        self.lastModified = lastModified
        self.dashboardUrl = dashboardUrl
        self.access = access
        self.lastRefreshed = lastRefreshed
        self.lastRefreshedBy = lastRefreshedBy
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.title = str()
        self.description = str()
        self.charts = list()
        self.chartEdges = self.RECORD_SCHEMA.fields_dict["chartEdges"].default
        self.datasets = list()
        self.datasetEdges = self.RECORD_SCHEMA.fields_dict["datasetEdges"].default
        self.dashboards = list()
        self.lastModified = ChangeAuditStampsClass._construct_with_defaults()
        self.dashboardUrl = self.RECORD_SCHEMA.fields_dict["dashboardUrl"].default
        self.access = self.RECORD_SCHEMA.fields_dict["access"].default
        self.lastRefreshed = self.RECORD_SCHEMA.fields_dict["lastRefreshed"].default
        self.lastRefreshedBy = self.RECORD_SCHEMA.fields_dict["lastRefreshedBy"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def title(self) -> str:
        """Title of the dashboard"""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: str) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def description(self) -> str:
        """Detailed description about the dashboard"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: str) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def charts(self) -> List[str]:
        """Charts in a dashboard
    Deprecated! Use chartEdges instead."""
        return self._inner_dict.get('charts')  # type: ignore
    
    @charts.setter
    def charts(self, value: List[str]) -> None:
        self._inner_dict['charts'] = value
    
    
    @property
    def chartEdges(self) -> Union[None, List["EdgeClass"]]:
        """Charts in a dashboard"""
        return self._inner_dict.get('chartEdges')  # type: ignore
    
    @chartEdges.setter
    def chartEdges(self, value: Union[None, List["EdgeClass"]]) -> None:
        self._inner_dict['chartEdges'] = value
    
    
    @property
    def datasets(self) -> List[str]:
        """Datasets consumed by a dashboard
    Deprecated! Use datasetEdges instead."""
        return self._inner_dict.get('datasets')  # type: ignore
    
    @datasets.setter
    def datasets(self, value: List[str]) -> None:
        self._inner_dict['datasets'] = value
    
    
    @property
    def datasetEdges(self) -> Union[None, List["EdgeClass"]]:
        """Datasets consumed by a dashboard"""
        return self._inner_dict.get('datasetEdges')  # type: ignore
    
    @datasetEdges.setter
    def datasetEdges(self, value: Union[None, List["EdgeClass"]]) -> None:
        self._inner_dict['datasetEdges'] = value
    
    
    @property
    def dashboards(self) -> List["EdgeClass"]:
        """Dashboards included by this dashboard.
    Some dashboard entities (e.g. PowerBI Apps) can contain other dashboards.
    
    The Edge's sourceUrn should never be set, as it will always be the base dashboard."""
        return self._inner_dict.get('dashboards')  # type: ignore
    
    @dashboards.setter
    def dashboards(self, value: List["EdgeClass"]) -> None:
        self._inner_dict['dashboards'] = value
    
    
    @property
    def lastModified(self) -> "ChangeAuditStampsClass":
        """Captures information about who created/last modified/deleted this dashboard and when"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "ChangeAuditStampsClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def dashboardUrl(self) -> Union[None, str]:
        """URL for the dashboard. This could be used as an external link on DataHub to allow users access/view the dashboard"""
        return self._inner_dict.get('dashboardUrl')  # type: ignore
    
    @dashboardUrl.setter
    def dashboardUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['dashboardUrl'] = value
    
    
    @property
    def access(self) -> Union[None, Union[str, "AccessLevelClass"]]:
        """Access level for the dashboard"""
        return self._inner_dict.get('access')  # type: ignore
    
    @access.setter
    def access(self, value: Union[None, Union[str, "AccessLevelClass"]]) -> None:
        self._inner_dict['access'] = value
    
    
    @property
    def lastRefreshed(self) -> Union[None, int]:
        """The time when this dashboard last refreshed"""
        return self._inner_dict.get('lastRefreshed')  # type: ignore
    
    @lastRefreshed.setter
    def lastRefreshed(self, value: Union[None, int]) -> None:
        self._inner_dict['lastRefreshed'] = value
    
    
    @property
    def lastRefreshedBy(self) -> Union[None, str]:
        """The actor who last refreshed this dashboard"""
        return self._inner_dict.get('lastRefreshedBy')  # type: ignore
    
    @lastRefreshedBy.setter
    def lastRefreshedBy(self, value: Union[None, str]) -> None:
        self._inner_dict['lastRefreshedBy'] = value
    
    
class DashboardUsageStatisticsClass(_Aspect):
    """Experimental (Subject to breaking change) -- Stats corresponding to dashboard's usage.
    
    If this aspect represents the latest snapshot of the statistics about a Dashboard, the eventGranularity field should be null. 
    If this aspect represents a bucketed window of usage statistics (e.g. over a day), then the eventGranularity field should be set accordingly. """


    ASPECT_NAME = 'dashboardUsageStatistics'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dashboard.DashboardUsageStatistics")

    def __init__(self,
        timestampMillis: int,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        viewsCount: Union[None, int]=None,
        executionsCount: Union[None, int]=None,
        uniqueUserCount: Union[None, int]=None,
        userCounts: Union[None, List["DashboardUserUsageCountsClass"]]=None,
        favoritesCount: Union[None, int]=None,
        lastViewedAt: Union[None, int]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.viewsCount = viewsCount
        self.executionsCount = executionsCount
        self.uniqueUserCount = uniqueUserCount
        self.userCounts = userCounts
        self.favoritesCount = favoritesCount
        self.lastViewedAt = lastViewedAt
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.viewsCount = self.RECORD_SCHEMA.fields_dict["viewsCount"].default
        self.executionsCount = self.RECORD_SCHEMA.fields_dict["executionsCount"].default
        self.uniqueUserCount = self.RECORD_SCHEMA.fields_dict["uniqueUserCount"].default
        self.userCounts = self.RECORD_SCHEMA.fields_dict["userCounts"].default
        self.favoritesCount = self.RECORD_SCHEMA.fields_dict["favoritesCount"].default
        self.lastViewedAt = self.RECORD_SCHEMA.fields_dict["lastViewedAt"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def viewsCount(self) -> Union[None, int]:
        """The total number of times dashboard has been viewed"""
        return self._inner_dict.get('viewsCount')  # type: ignore
    
    @viewsCount.setter
    def viewsCount(self, value: Union[None, int]) -> None:
        self._inner_dict['viewsCount'] = value
    
    
    @property
    def executionsCount(self) -> Union[None, int]:
        """The total number of dashboard executions (refreshes / syncs) """
        return self._inner_dict.get('executionsCount')  # type: ignore
    
    @executionsCount.setter
    def executionsCount(self, value: Union[None, int]) -> None:
        self._inner_dict['executionsCount'] = value
    
    
    @property
    def uniqueUserCount(self) -> Union[None, int]:
        """Unique user count"""
        return self._inner_dict.get('uniqueUserCount')  # type: ignore
    
    @uniqueUserCount.setter
    def uniqueUserCount(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueUserCount'] = value
    
    
    @property
    def userCounts(self) -> Union[None, List["DashboardUserUsageCountsClass"]]:
        """Users within this bucket, with frequency counts"""
        return self._inner_dict.get('userCounts')  # type: ignore
    
    @userCounts.setter
    def userCounts(self, value: Union[None, List["DashboardUserUsageCountsClass"]]) -> None:
        self._inner_dict['userCounts'] = value
    
    
    @property
    def favoritesCount(self) -> Union[None, int]:
        """The total number of times that the dashboard has been favorited """
        return self._inner_dict.get('favoritesCount')  # type: ignore
    
    @favoritesCount.setter
    def favoritesCount(self, value: Union[None, int]) -> None:
        self._inner_dict['favoritesCount'] = value
    
    
    @property
    def lastViewedAt(self) -> Union[None, int]:
        """Last viewed at
    
    This should not be set in cases where statistics are windowed. """
        return self._inner_dict.get('lastViewedAt')  # type: ignore
    
    @lastViewedAt.setter
    def lastViewedAt(self, value: Union[None, int]) -> None:
        self._inner_dict['lastViewedAt'] = value
    
    
class DashboardUserUsageCountsClass(DictWrapper):
    """Records a single user's usage counts for a given resource"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dashboard.DashboardUserUsageCounts")
    def __init__(self,
        user: str,
        viewsCount: Union[None, int]=None,
        executionsCount: Union[None, int]=None,
        usageCount: Union[None, int]=None,
        userEmail: Union[None, str]=None,
    ):
        super().__init__()
        
        self.user = user
        self.viewsCount = viewsCount
        self.executionsCount = executionsCount
        self.usageCount = usageCount
        self.userEmail = userEmail
    
    def _restore_defaults(self) -> None:
        self.user = str()
        self.viewsCount = self.RECORD_SCHEMA.fields_dict["viewsCount"].default
        self.executionsCount = self.RECORD_SCHEMA.fields_dict["executionsCount"].default
        self.usageCount = self.RECORD_SCHEMA.fields_dict["usageCount"].default
        self.userEmail = self.RECORD_SCHEMA.fields_dict["userEmail"].default
    
    
    @property
    def user(self) -> str:
        """The unique id of the user."""
        return self._inner_dict.get('user')  # type: ignore
    
    @user.setter
    def user(self, value: str) -> None:
        self._inner_dict['user'] = value
    
    
    @property
    def viewsCount(self) -> Union[None, int]:
        """The number of times the user has viewed the dashboard"""
        return self._inner_dict.get('viewsCount')  # type: ignore
    
    @viewsCount.setter
    def viewsCount(self, value: Union[None, int]) -> None:
        self._inner_dict['viewsCount'] = value
    
    
    @property
    def executionsCount(self) -> Union[None, int]:
        """The number of times the user has executed (refreshed) the dashboard"""
        return self._inner_dict.get('executionsCount')  # type: ignore
    
    @executionsCount.setter
    def executionsCount(self, value: Union[None, int]) -> None:
        self._inner_dict['executionsCount'] = value
    
    
    @property
    def usageCount(self) -> Union[None, int]:
        """Normalized numeric metric representing user's dashboard usage -- the number of times the user executed or viewed the dashboard. """
        return self._inner_dict.get('usageCount')  # type: ignore
    
    @usageCount.setter
    def usageCount(self, value: Union[None, int]) -> None:
        self._inner_dict['usageCount'] = value
    
    
    @property
    def userEmail(self) -> Union[None, str]:
        """If user_email is set, we attempt to resolve the user's urn upon ingest"""
        return self._inner_dict.get('userEmail')  # type: ignore
    
    @userEmail.setter
    def userEmail(self, value: Union[None, str]) -> None:
        self._inner_dict['userEmail'] = value
    
    
class EditableDashboardPropertiesClass(_Aspect):
    """Stores editable changes made to properties. This separates changes made from
    ingestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"""


    ASPECT_NAME = 'editableDashboardProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dashboard.EditableDashboardProperties")

    def __init__(self,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Edited documentation of the dashboard"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class DataContractPropertiesClass(_Aspect):
    """Information about a data contract"""


    ASPECT_NAME = 'dataContractProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datacontract.DataContractProperties")

    def __init__(self,
        entity: str,
        sla: Union[None, List["SlaContractClass"]]=None,
        schema: Union[None, List["SchemaContractClass"]]=None,
        freshness: Union[None, List["FreshnessContractClass"]]=None,
        dataQuality: Union[None, List["DataQualityContractClass"]]=None,
        rawContract: Union[None, str]=None,
    ):
        super().__init__()
        
        self.entity = entity
        self.sla = sla
        self.schema = schema
        self.freshness = freshness
        self.dataQuality = dataQuality
        self.rawContract = rawContract
    
    def _restore_defaults(self) -> None:
        self.entity = str()
        self.sla = self.RECORD_SCHEMA.fields_dict["sla"].default
        self.schema = self.RECORD_SCHEMA.fields_dict["schema"].default
        self.freshness = self.RECORD_SCHEMA.fields_dict["freshness"].default
        self.dataQuality = self.RECORD_SCHEMA.fields_dict["dataQuality"].default
        self.rawContract = self.RECORD_SCHEMA.fields_dict["rawContract"].default
    
    
    @property
    def entity(self) -> str:
        """The entity that this contract is associated with. Currently, we only support Dataset contracts, but
    in the future we may also support Data Product level contracts."""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def sla(self) -> Union[None, List["SlaContractClass"]]:
        """An optional set of SLA contracts. If this is a dataset contract, there will only be one."""
        return self._inner_dict.get('sla')  # type: ignore
    
    @sla.setter
    def sla(self, value: Union[None, List["SlaContractClass"]]) -> None:
        self._inner_dict['sla'] = value
    
    
    @property
    def schema(self) -> Union[None, List["SchemaContractClass"]]:
        """An optional set of schema contracts. If this is a dataset contract, there will only be one."""
        return self._inner_dict.get('schema')  # type: ignore
    
    @schema.setter
    def schema(self, value: Union[None, List["SchemaContractClass"]]) -> None:
        self._inner_dict['schema'] = value
    
    
    @property
    def freshness(self) -> Union[None, List["FreshnessContractClass"]]:
        """An optional set of FRESHNESS contracts. If this is a dataset contract, there will only be one."""
        return self._inner_dict.get('freshness')  # type: ignore
    
    @freshness.setter
    def freshness(self, value: Union[None, List["FreshnessContractClass"]]) -> None:
        self._inner_dict['freshness'] = value
    
    
    @property
    def dataQuality(self) -> Union[None, List["DataQualityContractClass"]]:
        """An optional set of Data Quality contracts, e.g. table and column level contract constraints."""
        return self._inner_dict.get('dataQuality')  # type: ignore
    
    @dataQuality.setter
    def dataQuality(self, value: Union[None, List["DataQualityContractClass"]]) -> None:
        self._inner_dict['dataQuality'] = value
    
    
    @property
    def rawContract(self) -> Union[None, str]:
        """YAML-formatted contract definition"""
        return self._inner_dict.get('rawContract')  # type: ignore
    
    @rawContract.setter
    def rawContract(self, value: Union[None, str]) -> None:
        self._inner_dict['rawContract'] = value
    
    
class DataContractStateClass(object):
    # No docs available.
    
    ACTIVE = "ACTIVE"
    """The data contract is active."""
    
    PENDING = "PENDING"
    """The data contract is pending implementation."""
    
    
    
class DataContractStatusClass(_Aspect):
    """Information about the status of a data contract"""


    ASPECT_NAME = 'dataContractStatus'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datacontract.DataContractStatus")

    def __init__(self,
        state: Union[str, "DataContractStateClass"],
        customProperties: Optional[Dict[str, str]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.state = state
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.state = DataContractStateClass.ACTIVE
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def state(self) -> Union[str, "DataContractStateClass"]:
        """The latest state of the data contract"""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[str, "DataContractStateClass"]) -> None:
        self._inner_dict['state'] = value
    
    
class DataQualityContractClass(DictWrapper):
    """A data quality contract pertaining to a physical data asset
    Data Quality contracts are used to make assertions about data quality metrics for a physical data asset"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datacontract.DataQualityContract")
    def __init__(self,
        assertion: str,
    ):
        super().__init__()
        
        self.assertion = assertion
    
    def _restore_defaults(self) -> None:
        self.assertion = str()
    
    
    @property
    def assertion(self) -> str:
        """The assertion representing the Data Quality contract.
    E.g. a table or column-level assertion."""
        return self._inner_dict.get('assertion')  # type: ignore
    
    @assertion.setter
    def assertion(self, value: str) -> None:
        self._inner_dict['assertion'] = value
    
    
class FreshnessContractClass(DictWrapper):
    """A contract pertaining to the operational SLAs of a physical data asset"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datacontract.FreshnessContract")
    def __init__(self,
        assertion: str,
    ):
        super().__init__()
        
        self.assertion = assertion
    
    def _restore_defaults(self) -> None:
        self.assertion = str()
    
    
    @property
    def assertion(self) -> str:
        """The assertion representing the SLA contract."""
        return self._inner_dict.get('assertion')  # type: ignore
    
    @assertion.setter
    def assertion(self, value: str) -> None:
        self._inner_dict['assertion'] = value
    
    
class SchemaContractClass(DictWrapper):
    """Expectations for a logical schema"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datacontract.SchemaContract")
    def __init__(self,
        assertion: str,
    ):
        super().__init__()
        
        self.assertion = assertion
    
    def _restore_defaults(self) -> None:
        self.assertion = str()
    
    
    @property
    def assertion(self) -> str:
        """The assertion representing the schema contract."""
        return self._inner_dict.get('assertion')  # type: ignore
    
    @assertion.setter
    def assertion(self, value: str) -> None:
        self._inner_dict['assertion'] = value
    
    
class SlaContractClass(DictWrapper):
    """A contract pertaining to the operational SLAs of a physical data asset"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datacontract.SlaContract")
    def __init__(self,
        assertion: str,
    ):
        super().__init__()
        
        self.assertion = assertion
    
    def _restore_defaults(self) -> None:
        self.assertion = str()
    
    
    @property
    def assertion(self) -> str:
        """The assertion representing the SLA contract."""
        return self._inner_dict.get('assertion')  # type: ignore
    
    @assertion.setter
    def assertion(self, value: str) -> None:
        self._inner_dict['assertion'] = value
    
    
class DataHubSearchConfigClass(DictWrapper):
    """Configuration for how any given field should be indexed and matched in the DataHub search index."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datahub.DataHubSearchConfig")
    def __init__(self,
        fieldName: Union[None, str]=None,
        fieldType: Union[None, Union[str, "SearchFieldTypeClass"]]=None,
        queryByDefault: Optional[bool]=None,
        enableAutocomplete: Optional[bool]=None,
        addToFilters: Optional[bool]=None,
        addHasValuesToFilters: Optional[bool]=None,
        filterNameOverride: Union[None, str]=None,
        hasValuesFilterNameOverride: Union[None, str]=None,
        boostScore: Optional[float]=None,
        hasValuesFieldName: Union[None, str]=None,
        numValuesFieldName: Union[None, str]=None,
        weightsPerFieldValue: Union[None, Dict[str, float]]=None,
        fieldNameAliases: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.fieldName = fieldName
        self.fieldType = fieldType
        if queryByDefault is None:
            # default: False
            self.queryByDefault = self.RECORD_SCHEMA.fields_dict["queryByDefault"].default
        else:
            self.queryByDefault = queryByDefault
        if enableAutocomplete is None:
            # default: False
            self.enableAutocomplete = self.RECORD_SCHEMA.fields_dict["enableAutocomplete"].default
        else:
            self.enableAutocomplete = enableAutocomplete
        if addToFilters is None:
            # default: False
            self.addToFilters = self.RECORD_SCHEMA.fields_dict["addToFilters"].default
        else:
            self.addToFilters = addToFilters
        if addHasValuesToFilters is None:
            # default: True
            self.addHasValuesToFilters = self.RECORD_SCHEMA.fields_dict["addHasValuesToFilters"].default
        else:
            self.addHasValuesToFilters = addHasValuesToFilters
        self.filterNameOverride = filterNameOverride
        self.hasValuesFilterNameOverride = hasValuesFilterNameOverride
        if boostScore is None:
            # default: 1.0
            self.boostScore = self.RECORD_SCHEMA.fields_dict["boostScore"].default
        else:
            self.boostScore = boostScore
        self.hasValuesFieldName = hasValuesFieldName
        self.numValuesFieldName = numValuesFieldName
        self.weightsPerFieldValue = weightsPerFieldValue
        self.fieldNameAliases = fieldNameAliases
    
    def _restore_defaults(self) -> None:
        self.fieldName = self.RECORD_SCHEMA.fields_dict["fieldName"].default
        self.fieldType = self.RECORD_SCHEMA.fields_dict["fieldType"].default
        self.queryByDefault = self.RECORD_SCHEMA.fields_dict["queryByDefault"].default
        self.enableAutocomplete = self.RECORD_SCHEMA.fields_dict["enableAutocomplete"].default
        self.addToFilters = self.RECORD_SCHEMA.fields_dict["addToFilters"].default
        self.addHasValuesToFilters = self.RECORD_SCHEMA.fields_dict["addHasValuesToFilters"].default
        self.filterNameOverride = self.RECORD_SCHEMA.fields_dict["filterNameOverride"].default
        self.hasValuesFilterNameOverride = self.RECORD_SCHEMA.fields_dict["hasValuesFilterNameOverride"].default
        self.boostScore = self.RECORD_SCHEMA.fields_dict["boostScore"].default
        self.hasValuesFieldName = self.RECORD_SCHEMA.fields_dict["hasValuesFieldName"].default
        self.numValuesFieldName = self.RECORD_SCHEMA.fields_dict["numValuesFieldName"].default
        self.weightsPerFieldValue = self.RECORD_SCHEMA.fields_dict["weightsPerFieldValue"].default
        self.fieldNameAliases = self.RECORD_SCHEMA.fields_dict["fieldNameAliases"].default
    
    
    @property
    def fieldName(self) -> Union[None, str]:
        """Name of the field in the search index. Defaults to the field name otherwise"""
        return self._inner_dict.get('fieldName')  # type: ignore
    
    @fieldName.setter
    def fieldName(self, value: Union[None, str]) -> None:
        self._inner_dict['fieldName'] = value
    
    
    @property
    def fieldType(self) -> Union[None, Union[str, "SearchFieldTypeClass"]]:
        """Type of the field. Defines how the field is indexed and matched"""
        return self._inner_dict.get('fieldType')  # type: ignore
    
    @fieldType.setter
    def fieldType(self, value: Union[None, Union[str, "SearchFieldTypeClass"]]) -> None:
        self._inner_dict['fieldType'] = value
    
    
    @property
    def queryByDefault(self) -> bool:
        """Whether we should match the field for the default search query"""
        return self._inner_dict.get('queryByDefault')  # type: ignore
    
    @queryByDefault.setter
    def queryByDefault(self, value: bool) -> None:
        self._inner_dict['queryByDefault'] = value
    
    
    @property
    def enableAutocomplete(self) -> bool:
        """Whether we should use the field for default autocomplete"""
        return self._inner_dict.get('enableAutocomplete')  # type: ignore
    
    @enableAutocomplete.setter
    def enableAutocomplete(self, value: bool) -> None:
        self._inner_dict['enableAutocomplete'] = value
    
    
    @property
    def addToFilters(self) -> bool:
        """Whether or not to add field to filters."""
        return self._inner_dict.get('addToFilters')  # type: ignore
    
    @addToFilters.setter
    def addToFilters(self, value: bool) -> None:
        self._inner_dict['addToFilters'] = value
    
    
    @property
    def addHasValuesToFilters(self) -> bool:
        """Whether or not to add the "has values" to filters.
    check if this is conditional on addToFilters being true"""
        return self._inner_dict.get('addHasValuesToFilters')  # type: ignore
    
    @addHasValuesToFilters.setter
    def addHasValuesToFilters(self, value: bool) -> None:
        self._inner_dict['addHasValuesToFilters'] = value
    
    
    @property
    def filterNameOverride(self) -> Union[None, str]:
        """Display name of the filter"""
        return self._inner_dict.get('filterNameOverride')  # type: ignore
    
    @filterNameOverride.setter
    def filterNameOverride(self, value: Union[None, str]) -> None:
        self._inner_dict['filterNameOverride'] = value
    
    
    @property
    def hasValuesFilterNameOverride(self) -> Union[None, str]:
        """Display name of the has values filter"""
        return self._inner_dict.get('hasValuesFilterNameOverride')  # type: ignore
    
    @hasValuesFilterNameOverride.setter
    def hasValuesFilterNameOverride(self, value: Union[None, str]) -> None:
        self._inner_dict['hasValuesFilterNameOverride'] = value
    
    
    @property
    def boostScore(self) -> float:
        """Boost multiplier to the match score. Matches on fields with higher boost score ranks higher"""
        return self._inner_dict.get('boostScore')  # type: ignore
    
    @boostScore.setter
    def boostScore(self, value: float) -> None:
        self._inner_dict['boostScore'] = value
    
    
    @property
    def hasValuesFieldName(self) -> Union[None, str]:
        """If set, add a index field of the given name that checks whether the field exists"""
        return self._inner_dict.get('hasValuesFieldName')  # type: ignore
    
    @hasValuesFieldName.setter
    def hasValuesFieldName(self, value: Union[None, str]) -> None:
        self._inner_dict['hasValuesFieldName'] = value
    
    
    @property
    def numValuesFieldName(self) -> Union[None, str]:
        """If set, add a index field of the given name that checks the number of elements"""
        return self._inner_dict.get('numValuesFieldName')  # type: ignore
    
    @numValuesFieldName.setter
    def numValuesFieldName(self, value: Union[None, str]) -> None:
        self._inner_dict['numValuesFieldName'] = value
    
    
    @property
    def weightsPerFieldValue(self) -> Union[None, Dict[str, float]]:
        """(Optional) Weights to apply to score for a given value"""
        return self._inner_dict.get('weightsPerFieldValue')  # type: ignore
    
    @weightsPerFieldValue.setter
    def weightsPerFieldValue(self, value: Union[None, Dict[str, float]]) -> None:
        self._inner_dict['weightsPerFieldValue'] = value
    
    
    @property
    def fieldNameAliases(self) -> Union[None, List[str]]:
        """(Optional) Aliases for this given field that can be used for sorting etc."""
        return self._inner_dict.get('fieldNameAliases')  # type: ignore
    
    @fieldNameAliases.setter
    def fieldNameAliases(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['fieldNameAliases'] = value
    
    
class SearchFieldTypeClass(object):
    # No docs available.
    
    KEYWORD = "KEYWORD"
    TEXT = "TEXT"
    TEXT_PARTIAL = "TEXT_PARTIAL"
    BROWSE_PATH = "BROWSE_PATH"
    URN = "URN"
    URN_PARTIAL = "URN_PARTIAL"
    BOOLEAN = "BOOLEAN"
    COUNT = "COUNT"
    DATETIME = "DATETIME"
    OBJECT = "OBJECT"
    BROWSE_PATH_V2 = "BROWSE_PATH_V2"
    WORD_GRAM = "WORD_GRAM"
    
    
class DataFlowInfoClass(_Aspect):
    """Information about a Data processing flow"""


    ASPECT_NAME = 'dataFlowInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.DataFlowInfo")

    def __init__(self,
        name: str,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        description: Union[None, str]=None,
        project: Union[None, str]=None,
        created: Union[None, "TimeStampClass"]=None,
        lastModified: Union[None, "TimeStampClass"]=None,
        env: Union[None, Union[str, "FabricTypeClass"]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.name = name
        self.description = description
        self.project = project
        self.created = created
        self.lastModified = lastModified
        self.env = env
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.project = self.RECORD_SCHEMA.fields_dict["project"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.env = self.RECORD_SCHEMA.fields_dict["env"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> str:
        """Flow name"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Flow description"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def project(self) -> Union[None, str]:
        """Optional project/namespace associated with the flow"""
        return self._inner_dict.get('project')  # type: ignore
    
    @project.setter
    def project(self, value: Union[None, str]) -> None:
        self._inner_dict['project'] = value
    
    
    @property
    def created(self) -> Union[None, "TimeStampClass"]:
        """A timestamp documenting when the asset was created in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "TimeStampClass"]:
        """A timestamp documenting when the asset was last modified in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def env(self) -> Union[None, Union[str, "FabricTypeClass"]]:
        """Environment for this flow"""
        return self._inner_dict.get('env')  # type: ignore
    
    @env.setter
    def env(self, value: Union[None, Union[str, "FabricTypeClass"]]) -> None:
        self._inner_dict['env'] = value
    
    
class DataJobInfoClass(_Aspect):
    """Information about a Data processing job"""


    ASPECT_NAME = 'dataJobInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.DataJobInfo")

    def __init__(self,
        name: str,
        type: Union[Union[str, "AzkabanJobTypeClass"], str],
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        description: Union[None, str]=None,
        flowUrn: Union[None, str]=None,
        created: Union[None, "TimeStampClass"]=None,
        lastModified: Union[None, "TimeStampClass"]=None,
        status: Union[None, Union[str, "JobStatusClass"]]=None,
        env: Union[None, Union[str, "FabricTypeClass"]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.name = name
        self.description = description
        self.type = type
        self.flowUrn = flowUrn
        self.created = created
        self.lastModified = lastModified
        self.status = status
        self.env = env
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.type = AzkabanJobTypeClass.COMMAND
        self.flowUrn = self.RECORD_SCHEMA.fields_dict["flowUrn"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.status = self.RECORD_SCHEMA.fields_dict["status"].default
        self.env = self.RECORD_SCHEMA.fields_dict["env"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> str:
        """Job name"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Job description"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def type(self) -> Union[Union[str, "AzkabanJobTypeClass"], str]:
        """Datajob type
    *NOTE**: AzkabanJobType is deprecated. Please use strings instead."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[Union[str, "AzkabanJobTypeClass"], str]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def flowUrn(self) -> Union[None, str]:
        """DataFlow urn that this job is part of"""
        return self._inner_dict.get('flowUrn')  # type: ignore
    
    @flowUrn.setter
    def flowUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['flowUrn'] = value
    
    
    @property
    def created(self) -> Union[None, "TimeStampClass"]:
        """A timestamp documenting when the asset was created in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "TimeStampClass"]:
        """A timestamp documenting when the asset was last modified in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def status(self) -> Union[None, Union[str, "JobStatusClass"]]:
        """Status of the job - Deprecated for Data Process Instance model."""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[None, Union[str, "JobStatusClass"]]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def env(self) -> Union[None, Union[str, "FabricTypeClass"]]:
        """Environment for this job"""
        return self._inner_dict.get('env')  # type: ignore
    
    @env.setter
    def env(self, value: Union[None, Union[str, "FabricTypeClass"]]) -> None:
        self._inner_dict['env'] = value
    
    
class DataJobInputOutputClass(_Aspect):
    """Information about the inputs and outputs of a Data processing job"""


    ASPECT_NAME = 'dataJobInputOutput'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.DataJobInputOutput")

    def __init__(self,
        inputDatasets: List[str],
        outputDatasets: List[str],
        inputDatasetEdges: Union[None, List["EdgeClass"]]=None,
        outputDatasetEdges: Union[None, List["EdgeClass"]]=None,
        inputDatajobs: Union[None, List[str]]=None,
        inputDatajobEdges: Union[None, List["EdgeClass"]]=None,
        inputDatasetFields: Union[None, List[str]]=None,
        outputDatasetFields: Union[None, List[str]]=None,
        fineGrainedLineages: Union[None, List["FineGrainedLineageClass"]]=None,
    ):
        super().__init__()
        
        self.inputDatasets = inputDatasets
        self.inputDatasetEdges = inputDatasetEdges
        self.outputDatasets = outputDatasets
        self.outputDatasetEdges = outputDatasetEdges
        self.inputDatajobs = inputDatajobs
        self.inputDatajobEdges = inputDatajobEdges
        self.inputDatasetFields = inputDatasetFields
        self.outputDatasetFields = outputDatasetFields
        self.fineGrainedLineages = fineGrainedLineages
    
    def _restore_defaults(self) -> None:
        self.inputDatasets = list()
        self.inputDatasetEdges = self.RECORD_SCHEMA.fields_dict["inputDatasetEdges"].default
        self.outputDatasets = list()
        self.outputDatasetEdges = self.RECORD_SCHEMA.fields_dict["outputDatasetEdges"].default
        self.inputDatajobs = self.RECORD_SCHEMA.fields_dict["inputDatajobs"].default
        self.inputDatajobEdges = self.RECORD_SCHEMA.fields_dict["inputDatajobEdges"].default
        self.inputDatasetFields = self.RECORD_SCHEMA.fields_dict["inputDatasetFields"].default
        self.outputDatasetFields = self.RECORD_SCHEMA.fields_dict["outputDatasetFields"].default
        self.fineGrainedLineages = self.RECORD_SCHEMA.fields_dict["fineGrainedLineages"].default
    
    
    @property
    def inputDatasets(self) -> List[str]:
        """Input datasets consumed by the data job during processing
    Deprecated! Use inputDatasetEdges instead."""
        return self._inner_dict.get('inputDatasets')  # type: ignore
    
    @inputDatasets.setter
    def inputDatasets(self, value: List[str]) -> None:
        self._inner_dict['inputDatasets'] = value
    
    
    @property
    def inputDatasetEdges(self) -> Union[None, List["EdgeClass"]]:
        """Input datasets consumed by the data job during processing"""
        return self._inner_dict.get('inputDatasetEdges')  # type: ignore
    
    @inputDatasetEdges.setter
    def inputDatasetEdges(self, value: Union[None, List["EdgeClass"]]) -> None:
        self._inner_dict['inputDatasetEdges'] = value
    
    
    @property
    def outputDatasets(self) -> List[str]:
        """Output datasets produced by the data job during processing
    Deprecated! Use outputDatasetEdges instead."""
        return self._inner_dict.get('outputDatasets')  # type: ignore
    
    @outputDatasets.setter
    def outputDatasets(self, value: List[str]) -> None:
        self._inner_dict['outputDatasets'] = value
    
    
    @property
    def outputDatasetEdges(self) -> Union[None, List["EdgeClass"]]:
        """Output datasets produced by the data job during processing"""
        return self._inner_dict.get('outputDatasetEdges')  # type: ignore
    
    @outputDatasetEdges.setter
    def outputDatasetEdges(self, value: Union[None, List["EdgeClass"]]) -> None:
        self._inner_dict['outputDatasetEdges'] = value
    
    
    @property
    def inputDatajobs(self) -> Union[None, List[str]]:
        """Input datajobs that this data job depends on
    Deprecated! Use inputDatajobEdges instead."""
        return self._inner_dict.get('inputDatajobs')  # type: ignore
    
    @inputDatajobs.setter
    def inputDatajobs(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['inputDatajobs'] = value
    
    
    @property
    def inputDatajobEdges(self) -> Union[None, List["EdgeClass"]]:
        """Input datajobs that this data job depends on"""
        return self._inner_dict.get('inputDatajobEdges')  # type: ignore
    
    @inputDatajobEdges.setter
    def inputDatajobEdges(self, value: Union[None, List["EdgeClass"]]) -> None:
        self._inner_dict['inputDatajobEdges'] = value
    
    
    @property
    def inputDatasetFields(self) -> Union[None, List[str]]:
        """Fields of the input datasets used by this job"""
        return self._inner_dict.get('inputDatasetFields')  # type: ignore
    
    @inputDatasetFields.setter
    def inputDatasetFields(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['inputDatasetFields'] = value
    
    
    @property
    def outputDatasetFields(self) -> Union[None, List[str]]:
        """Fields of the output datasets this job writes to"""
        return self._inner_dict.get('outputDatasetFields')  # type: ignore
    
    @outputDatasetFields.setter
    def outputDatasetFields(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['outputDatasetFields'] = value
    
    
    @property
    def fineGrainedLineages(self) -> Union[None, List["FineGrainedLineageClass"]]:
        """Fine-grained column-level lineages
    Not currently supported in the UI
    Use UpstreamLineage aspect for datasets to express Column Level Lineage for the UI"""
        return self._inner_dict.get('fineGrainedLineages')  # type: ignore
    
    @fineGrainedLineages.setter
    def fineGrainedLineages(self, value: Union[None, List["FineGrainedLineageClass"]]) -> None:
        self._inner_dict['fineGrainedLineages'] = value
    
    
class EditableDataFlowPropertiesClass(_Aspect):
    """Stores editable changes made to properties. This separates changes made from
    ingestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"""


    ASPECT_NAME = 'editableDataFlowProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.EditableDataFlowProperties")

    def __init__(self,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Edited documentation of the data flow"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class EditableDataJobPropertiesClass(_Aspect):
    """Stores editable changes made to properties. This separates changes made from
    ingestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"""


    ASPECT_NAME = 'editableDataJobProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.EditableDataJobProperties")

    def __init__(self,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Edited documentation of the data job """
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class JobStatusClass(object):
    """Job statuses"""
    
    STARTING = "STARTING"
    """Jobs being initialized."""
    
    IN_PROGRESS = "IN_PROGRESS"
    """Jobs currently running."""
    
    STOPPING = "STOPPING"
    """Jobs being stopped."""
    
    STOPPED = "STOPPED"
    """Jobs that have stopped."""
    
    COMPLETED = "COMPLETED"
    """Jobs with successful completion."""
    
    FAILED = "FAILED"
    """Jobs that have failed."""
    
    UNKNOWN = "UNKNOWN"
    """Jobs with unknown status (either unmappable or unavailable)"""
    
    SKIPPED = "SKIPPED"
    """Jobs that have been skipped."""
    
    
    
class VersionInfoClass(_Aspect):
    """Information about a Data processing job"""


    ASPECT_NAME = 'versionInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.VersionInfo")

    def __init__(self,
        version: str,
        versionType: str,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.version = version
        self.versionType = versionType
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.version = str()
        self.versionType = str()
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def version(self) -> str:
        """The version which can indentify a job version like a commit hash or md5 hash"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: str) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def versionType(self) -> str:
        """The type of the version like git hash or md5 hash"""
        return self._inner_dict.get('versionType')  # type: ignore
    
    @versionType.setter
    def versionType(self, value: str) -> None:
        self._inner_dict['versionType'] = value
    
    
class AzkabanJobTypeClass(object):
    """The various types of support azkaban jobs"""
    
    COMMAND = "COMMAND"
    """The command job type is one of the basic built-in types. It runs multiple UNIX commands using java processbuilder.
    Upon execution, Azkaban spawns off a process to run the command."""
    
    HADOOP_JAVA = "HADOOP_JAVA"
    """Runs a java program with ability to access Hadoop cluster.
    https://azkaban.readthedocs.io/en/latest/jobTypes.html#java-job-type"""
    
    HADOOP_SHELL = "HADOOP_SHELL"
    """In large part, this is the same Command type. The difference is its ability to talk to a Hadoop cluster
    securely, via Hadoop tokens."""
    
    HIVE = "HIVE"
    """Hive type is for running Hive jobs."""
    
    PIG = "PIG"
    """Pig type is for running Pig jobs."""
    
    SQL = "SQL"
    """SQL is for running Presto, mysql queries etc"""
    
    GLUE = "GLUE"
    """Glue type is for running AWS Glue job transforms."""
    
    
    
class DatahubIngestionCheckpointClass(_Aspect):
    """Checkpoint of a datahub ingestion run for a given job."""


    ASPECT_NAME = 'datahubIngestionCheckpoint'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.datahub.DatahubIngestionCheckpoint")

    def __init__(self,
        timestampMillis: int,
        pipelineName: str,
        platformInstanceId: str,
        config: str,
        state: "IngestionCheckpointStateClass",
        runId: str,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.pipelineName = pipelineName
        self.platformInstanceId = platformInstanceId
        self.config = config
        self.state = state
        self.runId = runId
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.pipelineName = str()
        self.platformInstanceId = str()
        self.config = str()
        self.state = IngestionCheckpointStateClass._construct_with_defaults()
        self.runId = str()
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def pipelineName(self) -> str:
        """The name of the pipeline that ran ingestion, a stable unique user provided identifier.
     e.g. my_snowflake1-to-datahub."""
        return self._inner_dict.get('pipelineName')  # type: ignore
    
    @pipelineName.setter
    def pipelineName(self, value: str) -> None:
        self._inner_dict['pipelineName'] = value
    
    
    @property
    def platformInstanceId(self) -> str:
        """The id of the instance against which the ingestion pipeline ran.
    e.g.: Bigquery project ids, MySQL hostnames etc."""
        return self._inner_dict.get('platformInstanceId')  # type: ignore
    
    @platformInstanceId.setter
    def platformInstanceId(self, value: str) -> None:
        self._inner_dict['platformInstanceId'] = value
    
    
    @property
    def config(self) -> str:
        """Json-encoded string representation of the non-secret members of the config ."""
        return self._inner_dict.get('config')  # type: ignore
    
    @config.setter
    def config(self, value: str) -> None:
        self._inner_dict['config'] = value
    
    
    @property
    def state(self) -> "IngestionCheckpointStateClass":
        """Opaque blob of the state representation."""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: "IngestionCheckpointStateClass") -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def runId(self) -> str:
        """The run identifier of this job."""
        return self._inner_dict.get('runId')  # type: ignore
    
    @runId.setter
    def runId(self, value: str) -> None:
        self._inner_dict['runId'] = value
    
    
class DatahubIngestionRunSummaryClass(_Aspect):
    """Summary of a datahub ingestion run for a given platform."""


    ASPECT_NAME = 'datahubIngestionRunSummary'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.datahub.DatahubIngestionRunSummary")

    def __init__(self,
        timestampMillis: int,
        pipelineName: str,
        platformInstanceId: str,
        runId: str,
        runStatus: Union[str, "JobStatusClass"],
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        numWorkUnitsCommitted: Union[None, int]=None,
        numWorkUnitsCreated: Union[None, int]=None,
        numEvents: Union[None, int]=None,
        numEntities: Union[None, int]=None,
        numAspects: Union[None, int]=None,
        numSourceAPICalls: Union[None, int]=None,
        totalLatencySourceAPICalls: Union[None, int]=None,
        numSinkAPICalls: Union[None, int]=None,
        totalLatencySinkAPICalls: Union[None, int]=None,
        numWarnings: Union[None, int]=None,
        numErrors: Union[None, int]=None,
        numEntitiesSkipped: Union[None, int]=None,
        config: Union[None, str]=None,
        custom_summary: Union[None, str]=None,
        softwareVersion: Union[None, str]=None,
        systemHostName: Union[None, str]=None,
        operatingSystemName: Union[None, str]=None,
        numProcessors: Union[None, int]=None,
        totalMemory: Union[None, int]=None,
        availableMemory: Union[None, int]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.pipelineName = pipelineName
        self.platformInstanceId = platformInstanceId
        self.runId = runId
        self.runStatus = runStatus
        self.numWorkUnitsCommitted = numWorkUnitsCommitted
        self.numWorkUnitsCreated = numWorkUnitsCreated
        self.numEvents = numEvents
        self.numEntities = numEntities
        self.numAspects = numAspects
        self.numSourceAPICalls = numSourceAPICalls
        self.totalLatencySourceAPICalls = totalLatencySourceAPICalls
        self.numSinkAPICalls = numSinkAPICalls
        self.totalLatencySinkAPICalls = totalLatencySinkAPICalls
        self.numWarnings = numWarnings
        self.numErrors = numErrors
        self.numEntitiesSkipped = numEntitiesSkipped
        self.config = config
        self.custom_summary = custom_summary
        self.softwareVersion = softwareVersion
        self.systemHostName = systemHostName
        self.operatingSystemName = operatingSystemName
        self.numProcessors = numProcessors
        self.totalMemory = totalMemory
        self.availableMemory = availableMemory
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.pipelineName = str()
        self.platformInstanceId = str()
        self.runId = str()
        self.runStatus = JobStatusClass.STARTING
        self.numWorkUnitsCommitted = self.RECORD_SCHEMA.fields_dict["numWorkUnitsCommitted"].default
        self.numWorkUnitsCreated = self.RECORD_SCHEMA.fields_dict["numWorkUnitsCreated"].default
        self.numEvents = self.RECORD_SCHEMA.fields_dict["numEvents"].default
        self.numEntities = self.RECORD_SCHEMA.fields_dict["numEntities"].default
        self.numAspects = self.RECORD_SCHEMA.fields_dict["numAspects"].default
        self.numSourceAPICalls = self.RECORD_SCHEMA.fields_dict["numSourceAPICalls"].default
        self.totalLatencySourceAPICalls = self.RECORD_SCHEMA.fields_dict["totalLatencySourceAPICalls"].default
        self.numSinkAPICalls = self.RECORD_SCHEMA.fields_dict["numSinkAPICalls"].default
        self.totalLatencySinkAPICalls = self.RECORD_SCHEMA.fields_dict["totalLatencySinkAPICalls"].default
        self.numWarnings = self.RECORD_SCHEMA.fields_dict["numWarnings"].default
        self.numErrors = self.RECORD_SCHEMA.fields_dict["numErrors"].default
        self.numEntitiesSkipped = self.RECORD_SCHEMA.fields_dict["numEntitiesSkipped"].default
        self.config = self.RECORD_SCHEMA.fields_dict["config"].default
        self.custom_summary = self.RECORD_SCHEMA.fields_dict["custom_summary"].default
        self.softwareVersion = self.RECORD_SCHEMA.fields_dict["softwareVersion"].default
        self.systemHostName = self.RECORD_SCHEMA.fields_dict["systemHostName"].default
        self.operatingSystemName = self.RECORD_SCHEMA.fields_dict["operatingSystemName"].default
        self.numProcessors = self.RECORD_SCHEMA.fields_dict["numProcessors"].default
        self.totalMemory = self.RECORD_SCHEMA.fields_dict["totalMemory"].default
        self.availableMemory = self.RECORD_SCHEMA.fields_dict["availableMemory"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def pipelineName(self) -> str:
        """The name of the pipeline that ran ingestion, a stable unique user provided identifier.
     e.g. my_snowflake1-to-datahub."""
        return self._inner_dict.get('pipelineName')  # type: ignore
    
    @pipelineName.setter
    def pipelineName(self, value: str) -> None:
        self._inner_dict['pipelineName'] = value
    
    
    @property
    def platformInstanceId(self) -> str:
        """The id of the instance against which the ingestion pipeline ran.
    e.g.: Bigquery project ids, MySQL hostnames etc."""
        return self._inner_dict.get('platformInstanceId')  # type: ignore
    
    @platformInstanceId.setter
    def platformInstanceId(self, value: str) -> None:
        self._inner_dict['platformInstanceId'] = value
    
    
    @property
    def runId(self) -> str:
        """The runId for this pipeline instance."""
        return self._inner_dict.get('runId')  # type: ignore
    
    @runId.setter
    def runId(self, value: str) -> None:
        self._inner_dict['runId'] = value
    
    
    @property
    def runStatus(self) -> Union[str, "JobStatusClass"]:
        """Run Status - Succeeded/Skipped/Failed etc."""
        return self._inner_dict.get('runStatus')  # type: ignore
    
    @runStatus.setter
    def runStatus(self, value: Union[str, "JobStatusClass"]) -> None:
        self._inner_dict['runStatus'] = value
    
    
    @property
    def numWorkUnitsCommitted(self) -> Union[None, int]:
        """The number of workunits written to sink."""
        return self._inner_dict.get('numWorkUnitsCommitted')  # type: ignore
    
    @numWorkUnitsCommitted.setter
    def numWorkUnitsCommitted(self, value: Union[None, int]) -> None:
        self._inner_dict['numWorkUnitsCommitted'] = value
    
    
    @property
    def numWorkUnitsCreated(self) -> Union[None, int]:
        """The number of workunits that are produced."""
        return self._inner_dict.get('numWorkUnitsCreated')  # type: ignore
    
    @numWorkUnitsCreated.setter
    def numWorkUnitsCreated(self, value: Union[None, int]) -> None:
        self._inner_dict['numWorkUnitsCreated'] = value
    
    
    @property
    def numEvents(self) -> Union[None, int]:
        """The number of events produced (MCE + MCP)."""
        return self._inner_dict.get('numEvents')  # type: ignore
    
    @numEvents.setter
    def numEvents(self, value: Union[None, int]) -> None:
        self._inner_dict['numEvents'] = value
    
    
    @property
    def numEntities(self) -> Union[None, int]:
        """The total number of entities produced (unique entity urns)."""
        return self._inner_dict.get('numEntities')  # type: ignore
    
    @numEntities.setter
    def numEntities(self, value: Union[None, int]) -> None:
        self._inner_dict['numEntities'] = value
    
    
    @property
    def numAspects(self) -> Union[None, int]:
        """The total number of aspects produced across all entities."""
        return self._inner_dict.get('numAspects')  # type: ignore
    
    @numAspects.setter
    def numAspects(self, value: Union[None, int]) -> None:
        self._inner_dict['numAspects'] = value
    
    
    @property
    def numSourceAPICalls(self) -> Union[None, int]:
        """Total number of source API calls."""
        return self._inner_dict.get('numSourceAPICalls')  # type: ignore
    
    @numSourceAPICalls.setter
    def numSourceAPICalls(self, value: Union[None, int]) -> None:
        self._inner_dict['numSourceAPICalls'] = value
    
    
    @property
    def totalLatencySourceAPICalls(self) -> Union[None, int]:
        """Total latency across all source API calls."""
        return self._inner_dict.get('totalLatencySourceAPICalls')  # type: ignore
    
    @totalLatencySourceAPICalls.setter
    def totalLatencySourceAPICalls(self, value: Union[None, int]) -> None:
        self._inner_dict['totalLatencySourceAPICalls'] = value
    
    
    @property
    def numSinkAPICalls(self) -> Union[None, int]:
        """Total number of sink API calls."""
        return self._inner_dict.get('numSinkAPICalls')  # type: ignore
    
    @numSinkAPICalls.setter
    def numSinkAPICalls(self, value: Union[None, int]) -> None:
        self._inner_dict['numSinkAPICalls'] = value
    
    
    @property
    def totalLatencySinkAPICalls(self) -> Union[None, int]:
        """Total latency across all sink API calls."""
        return self._inner_dict.get('totalLatencySinkAPICalls')  # type: ignore
    
    @totalLatencySinkAPICalls.setter
    def totalLatencySinkAPICalls(self, value: Union[None, int]) -> None:
        self._inner_dict['totalLatencySinkAPICalls'] = value
    
    
    @property
    def numWarnings(self) -> Union[None, int]:
        """Number of warnings generated."""
        return self._inner_dict.get('numWarnings')  # type: ignore
    
    @numWarnings.setter
    def numWarnings(self, value: Union[None, int]) -> None:
        self._inner_dict['numWarnings'] = value
    
    
    @property
    def numErrors(self) -> Union[None, int]:
        """Number of errors generated."""
        return self._inner_dict.get('numErrors')  # type: ignore
    
    @numErrors.setter
    def numErrors(self, value: Union[None, int]) -> None:
        self._inner_dict['numErrors'] = value
    
    
    @property
    def numEntitiesSkipped(self) -> Union[None, int]:
        """Number of entities skipped."""
        return self._inner_dict.get('numEntitiesSkipped')  # type: ignore
    
    @numEntitiesSkipped.setter
    def numEntitiesSkipped(self, value: Union[None, int]) -> None:
        self._inner_dict['numEntitiesSkipped'] = value
    
    
    @property
    def config(self) -> Union[None, str]:
        """The non-sensitive key-value pairs of the yaml config used as json string."""
        return self._inner_dict.get('config')  # type: ignore
    
    @config.setter
    def config(self, value: Union[None, str]) -> None:
        self._inner_dict['config'] = value
    
    
    @property
    def custom_summary(self) -> Union[None, str]:
        """Custom value."""
        return self._inner_dict.get('custom_summary')  # type: ignore
    
    @custom_summary.setter
    def custom_summary(self, value: Union[None, str]) -> None:
        self._inner_dict['custom_summary'] = value
    
    
    @property
    def softwareVersion(self) -> Union[None, str]:
        """The software version of this ingestion."""
        return self._inner_dict.get('softwareVersion')  # type: ignore
    
    @softwareVersion.setter
    def softwareVersion(self, value: Union[None, str]) -> None:
        self._inner_dict['softwareVersion'] = value
    
    
    @property
    def systemHostName(self) -> Union[None, str]:
        """The hostname the ingestion pipeline ran on."""
        return self._inner_dict.get('systemHostName')  # type: ignore
    
    @systemHostName.setter
    def systemHostName(self, value: Union[None, str]) -> None:
        self._inner_dict['systemHostName'] = value
    
    
    @property
    def operatingSystemName(self) -> Union[None, str]:
        """The os the ingestion pipeline ran on."""
        return self._inner_dict.get('operatingSystemName')  # type: ignore
    
    @operatingSystemName.setter
    def operatingSystemName(self, value: Union[None, str]) -> None:
        self._inner_dict['operatingSystemName'] = value
    
    
    @property
    def numProcessors(self) -> Union[None, int]:
        """The number of processors on the host the ingestion pipeline ran on."""
        return self._inner_dict.get('numProcessors')  # type: ignore
    
    @numProcessors.setter
    def numProcessors(self, value: Union[None, int]) -> None:
        self._inner_dict['numProcessors'] = value
    
    
    @property
    def totalMemory(self) -> Union[None, int]:
        """The total amount of memory on the host the ingestion pipeline ran on."""
        return self._inner_dict.get('totalMemory')  # type: ignore
    
    @totalMemory.setter
    def totalMemory(self, value: Union[None, int]) -> None:
        self._inner_dict['totalMemory'] = value
    
    
    @property
    def availableMemory(self) -> Union[None, int]:
        """The available memory on the host the ingestion pipeline ran on."""
        return self._inner_dict.get('availableMemory')  # type: ignore
    
    @availableMemory.setter
    def availableMemory(self, value: Union[None, int]) -> None:
        self._inner_dict['availableMemory'] = value
    
    
class IngestionCheckpointStateClass(DictWrapper):
    """The checkpoint state object of a datahub ingestion run for a given job."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datajob.datahub.IngestionCheckpointState")
    def __init__(self,
        formatVersion: str,
        serde: str,
        payload: Union[None, bytes]=None,
    ):
        super().__init__()
        
        self.formatVersion = formatVersion
        self.serde = serde
        self.payload = payload
    
    def _restore_defaults(self) -> None:
        self.formatVersion = str()
        self.serde = str()
        self.payload = self.RECORD_SCHEMA.fields_dict["payload"].default
    
    
    @property
    def formatVersion(self) -> str:
        """The version of the state format."""
        return self._inner_dict.get('formatVersion')  # type: ignore
    
    @formatVersion.setter
    def formatVersion(self, value: str) -> None:
        self._inner_dict['formatVersion'] = value
    
    
    @property
    def serde(self) -> str:
        """The serialization/deserialization protocol."""
        return self._inner_dict.get('serde')  # type: ignore
    
    @serde.setter
    def serde(self, value: str) -> None:
        self._inner_dict['serde'] = value
    
    
    @property
    def payload(self) -> Union[None, bytes]:
        """Opaque blob of the state representation."""
        return self._inner_dict.get('payload')  # type: ignore
    
    @payload.setter
    def payload(self, value: Union[None, bytes]) -> None:
        self._inner_dict['payload'] = value
    
    
class DataPlatformInfoClass(_Aspect):
    """Information about a data platform"""


    ASPECT_NAME = 'dataPlatformInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataplatform.DataPlatformInfo")

    def __init__(self,
        name: str,
        type: Union[str, "PlatformTypeClass"],
        datasetNameDelimiter: str,
        displayName: Union[None, str]=None,
        logoUrl: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.displayName = displayName
        self.type = type
        self.datasetNameDelimiter = datasetNameDelimiter
        self.logoUrl = logoUrl
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.type = PlatformTypeClass.FILE_SYSTEM
        self.datasetNameDelimiter = str()
        self.logoUrl = self.RECORD_SCHEMA.fields_dict["logoUrl"].default
    
    
    @property
    def name(self) -> str:
        """Name of the data platform"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """The name that will be used for displaying a platform type."""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def type(self) -> Union[str, "PlatformTypeClass"]:
        """Platform type this data platform describes"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "PlatformTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def datasetNameDelimiter(self) -> str:
        """The delimiter in the dataset names on the data platform, e.g. '/' for HDFS and '.' for Oracle"""
        return self._inner_dict.get('datasetNameDelimiter')  # type: ignore
    
    @datasetNameDelimiter.setter
    def datasetNameDelimiter(self, value: str) -> None:
        self._inner_dict['datasetNameDelimiter'] = value
    
    
    @property
    def logoUrl(self) -> Union[None, str]:
        """The URL for a logo associated with the platform"""
        return self._inner_dict.get('logoUrl')  # type: ignore
    
    @logoUrl.setter
    def logoUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['logoUrl'] = value
    
    
class PlatformTypeClass(object):
    """Platform types available at LinkedIn"""
    
    FILE_SYSTEM = "FILE_SYSTEM"
    """Value for a file system, e.g. hdfs"""
    
    KEY_VALUE_STORE = "KEY_VALUE_STORE"
    """Value for a key value store, e.g. espresso, voldemort"""
    
    MESSAGE_BROKER = "MESSAGE_BROKER"
    """Value for a message broker, e.g. kafka"""
    
    OBJECT_STORE = "OBJECT_STORE"
    """Value for an object store, e.g. ambry"""
    
    OLAP_DATASTORE = "OLAP_DATASTORE"
    """Value for an OLAP datastore, e.g. pinot"""
    
    OTHERS = "OTHERS"
    """Value for other platforms, e.g salesforce, dovetail"""
    
    QUERY_ENGINE = "QUERY_ENGINE"
    """Value for a query engine, e.g. presto"""
    
    RELATIONAL_DB = "RELATIONAL_DB"
    """Value for a relational database, e.g. oracle, mysql"""
    
    SEARCH_ENGINE = "SEARCH_ENGINE"
    """Value for a search engine, e.g seas"""
    
    
    
class SlackUserInfoClass(_Aspect):
    """Information about a Slack user."""


    ASPECT_NAME = 'slackUserInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataplatform.slack.SlackUserInfo")

    def __init__(self,
        slackInstance: str,
        id: str,
        name: str,
        realName: str,
        displayName: str,
        teamId: str,
        isDeleted: bool,
        isAdmin: bool,
        isOwner: bool,
        isPrimaryOwner: bool,
        isBot: bool,
        email: Union[None, str]=None,
        timezone: Union[None, str]=None,
        timezoneOffset: Union[None, int]=None,
        title: Union[None, str]=None,
        phone: Union[None, str]=None,
        profilePictureUrl: Union[None, str]=None,
        statusText: Union[None, str]=None,
        statusEmoji: Union[None, str]=None,
        lastUpdatedSeconds: Union[None, int]=None,
    ):
        super().__init__()
        
        self.slackInstance = slackInstance
        self.id = id
        self.name = name
        self.realName = realName
        self.displayName = displayName
        self.email = email
        self.teamId = teamId
        self.isDeleted = isDeleted
        self.isAdmin = isAdmin
        self.isOwner = isOwner
        self.isPrimaryOwner = isPrimaryOwner
        self.isBot = isBot
        self.timezone = timezone
        self.timezoneOffset = timezoneOffset
        self.title = title
        self.phone = phone
        self.profilePictureUrl = profilePictureUrl
        self.statusText = statusText
        self.statusEmoji = statusEmoji
        self.lastUpdatedSeconds = lastUpdatedSeconds
    
    def _restore_defaults(self) -> None:
        self.slackInstance = str()
        self.id = str()
        self.name = str()
        self.realName = str()
        self.displayName = str()
        self.email = self.RECORD_SCHEMA.fields_dict["email"].default
        self.teamId = str()
        self.isDeleted = bool()
        self.isAdmin = bool()
        self.isOwner = bool()
        self.isPrimaryOwner = bool()
        self.isBot = bool()
        self.timezone = self.RECORD_SCHEMA.fields_dict["timezone"].default
        self.timezoneOffset = self.RECORD_SCHEMA.fields_dict["timezoneOffset"].default
        self.title = self.RECORD_SCHEMA.fields_dict["title"].default
        self.phone = self.RECORD_SCHEMA.fields_dict["phone"].default
        self.profilePictureUrl = self.RECORD_SCHEMA.fields_dict["profilePictureUrl"].default
        self.statusText = self.RECORD_SCHEMA.fields_dict["statusText"].default
        self.statusEmoji = self.RECORD_SCHEMA.fields_dict["statusEmoji"].default
        self.lastUpdatedSeconds = self.RECORD_SCHEMA.fields_dict["lastUpdatedSeconds"].default
    
    
    @property
    def slackInstance(self) -> str:
        """The dataplatform instance that this Slack member belongs to."""
        return self._inner_dict.get('slackInstance')  # type: ignore
    
    @slackInstance.setter
    def slackInstance(self, value: str) -> None:
        self._inner_dict['slackInstance'] = value
    
    
    @property
    def id(self) -> str:
        """The unique identifier for the Slack member."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def name(self) -> str:
        """The username of the Slack member."""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def realName(self) -> str:
        """The real name of the Slack member."""
        return self._inner_dict.get('realName')  # type: ignore
    
    @realName.setter
    def realName(self, value: str) -> None:
        self._inner_dict['realName'] = value
    
    
    @property
    def displayName(self) -> str:
        """The display name of the Slack member."""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: str) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def email(self) -> Union[None, str]:
        """The email associated with the Slack member."""
        return self._inner_dict.get('email')  # type: ignore
    
    @email.setter
    def email(self, value: Union[None, str]) -> None:
        self._inner_dict['email'] = value
    
    
    @property
    def teamId(self) -> str:
        """The ID associated with the Slack team."""
        return self._inner_dict.get('teamId')  # type: ignore
    
    @teamId.setter
    def teamId(self, value: str) -> None:
        self._inner_dict['teamId'] = value
    
    
    @property
    def isDeleted(self) -> bool:
        """Whether the member is deleted or not."""
        return self._inner_dict.get('isDeleted')  # type: ignore
    
    @isDeleted.setter
    def isDeleted(self, value: bool) -> None:
        self._inner_dict['isDeleted'] = value
    
    
    @property
    def isAdmin(self) -> bool:
        """Whether the member is an admin."""
        return self._inner_dict.get('isAdmin')  # type: ignore
    
    @isAdmin.setter
    def isAdmin(self, value: bool) -> None:
        self._inner_dict['isAdmin'] = value
    
    
    @property
    def isOwner(self) -> bool:
        """Whether the member is an owner."""
        return self._inner_dict.get('isOwner')  # type: ignore
    
    @isOwner.setter
    def isOwner(self, value: bool) -> None:
        self._inner_dict['isOwner'] = value
    
    
    @property
    def isPrimaryOwner(self) -> bool:
        """Whether the member is a primary owner."""
        return self._inner_dict.get('isPrimaryOwner')  # type: ignore
    
    @isPrimaryOwner.setter
    def isPrimaryOwner(self, value: bool) -> None:
        self._inner_dict['isPrimaryOwner'] = value
    
    
    @property
    def isBot(self) -> bool:
        """Whether the member is a bot."""
        return self._inner_dict.get('isBot')  # type: ignore
    
    @isBot.setter
    def isBot(self, value: bool) -> None:
        self._inner_dict['isBot'] = value
    
    
    @property
    def timezone(self) -> Union[None, str]:
        """The timezone of the Slack member."""
        return self._inner_dict.get('timezone')  # type: ignore
    
    @timezone.setter
    def timezone(self, value: Union[None, str]) -> None:
        self._inner_dict['timezone'] = value
    
    
    @property
    def timezoneOffset(self) -> Union[None, int]:
        """The timezone offset of the Slack member."""
        return self._inner_dict.get('timezoneOffset')  # type: ignore
    
    @timezoneOffset.setter
    def timezoneOffset(self, value: Union[None, int]) -> None:
        self._inner_dict['timezoneOffset'] = value
    
    
    @property
    def title(self) -> Union[None, str]:
        """The title of the Slack member."""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: Union[None, str]) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def phone(self) -> Union[None, str]:
        """The phone number of the Slack member."""
        return self._inner_dict.get('phone')  # type: ignore
    
    @phone.setter
    def phone(self, value: Union[None, str]) -> None:
        self._inner_dict['phone'] = value
    
    
    @property
    def profilePictureUrl(self) -> Union[None, str]:
        """The URL of the member's profile picture."""
        return self._inner_dict.get('profilePictureUrl')  # type: ignore
    
    @profilePictureUrl.setter
    def profilePictureUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['profilePictureUrl'] = value
    
    
    @property
    def statusText(self) -> Union[None, str]:
        """The status text of the Slack member."""
        return self._inner_dict.get('statusText')  # type: ignore
    
    @statusText.setter
    def statusText(self, value: Union[None, str]) -> None:
        self._inner_dict['statusText'] = value
    
    
    @property
    def statusEmoji(self) -> Union[None, str]:
        """The status emoji of the Slack member."""
        return self._inner_dict.get('statusEmoji')  # type: ignore
    
    @statusEmoji.setter
    def statusEmoji(self, value: Union[None, str]) -> None:
        self._inner_dict['statusEmoji'] = value
    
    
    @property
    def lastUpdatedSeconds(self) -> Union[None, int]:
        """The timestamp of when the member was last updated. (in seconds)"""
        return self._inner_dict.get('lastUpdatedSeconds')  # type: ignore
    
    @lastUpdatedSeconds.setter
    def lastUpdatedSeconds(self, value: Union[None, int]) -> None:
        self._inner_dict['lastUpdatedSeconds'] = value
    
    
class DataPlatformInstancePropertiesClass(_Aspect):
    """Properties associated with a Data Platform Instance"""


    ASPECT_NAME = 'dataPlatformInstanceProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataplatforminstance.DataPlatformInstanceProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        name: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.name = name
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the Data Platform Instance"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the Data Platform Instance"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class IcebergWarehouseInfoClass(_Aspect):
    """An Iceberg warehouse location and credentails whose read/writes are governed by datahub catalog."""


    ASPECT_NAME = 'icebergWarehouseInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataplatforminstance.IcebergWarehouseInfo")

    def __init__(self,
        dataRoot: str,
        clientId: str,
        clientSecret: str,
        region: str,
        env: Union[str, "FabricTypeClass"],
        role: Union[None, str]=None,
        tempCredentialExpirationSeconds: Union[None, int]=None,
    ):
        super().__init__()
        
        self.dataRoot = dataRoot
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.region = region
        self.role = role
        self.tempCredentialExpirationSeconds = tempCredentialExpirationSeconds
        self.env = env
    
    def _restore_defaults(self) -> None:
        self.dataRoot = str()
        self.clientId = str()
        self.clientSecret = str()
        self.region = str()
        self.role = self.RECORD_SCHEMA.fields_dict["role"].default
        self.tempCredentialExpirationSeconds = self.RECORD_SCHEMA.fields_dict["tempCredentialExpirationSeconds"].default
        self.env = FabricTypeClass.DEV
    
    
    @property
    def dataRoot(self) -> str:
        """Path of the root for the backing store of the tables in the warehouse."""
        return self._inner_dict.get('dataRoot')  # type: ignore
    
    @dataRoot.setter
    def dataRoot(self, value: str) -> None:
        self._inner_dict['dataRoot'] = value
    
    
    @property
    def clientId(self) -> str:
        """clientId to be used to authenticate with storage hosting this warehouse"""
        return self._inner_dict.get('clientId')  # type: ignore
    
    @clientId.setter
    def clientId(self, value: str) -> None:
        self._inner_dict['clientId'] = value
    
    
    @property
    def clientSecret(self) -> str:
        """client secret to authenticate with storage hosting this warehouse"""
        return self._inner_dict.get('clientSecret')  # type: ignore
    
    @clientSecret.setter
    def clientSecret(self, value: str) -> None:
        self._inner_dict['clientSecret'] = value
    
    
    @property
    def region(self) -> str:
        """region where the warehouse is located."""
        return self._inner_dict.get('region')  # type: ignore
    
    @region.setter
    def region(self, value: str) -> None:
        self._inner_dict['region'] = value
    
    
    @property
    def role(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('role')  # type: ignore
    
    @role.setter
    def role(self, value: Union[None, str]) -> None:
        self._inner_dict['role'] = value
    
    
    @property
    def tempCredentialExpirationSeconds(self) -> Union[None, int]:
        # No docs available.
        return self._inner_dict.get('tempCredentialExpirationSeconds')  # type: ignore
    
    @tempCredentialExpirationSeconds.setter
    def tempCredentialExpirationSeconds(self, value: Union[None, int]) -> None:
        self._inner_dict['tempCredentialExpirationSeconds'] = value
    
    
    @property
    def env(self) -> Union[str, "FabricTypeClass"]:
        # No docs available.
        return self._inner_dict.get('env')  # type: ignore
    
    @env.setter
    def env(self, value: Union[str, "FabricTypeClass"]) -> None:
        self._inner_dict['env'] = value
    
    
class DataProcessInfoClass(_Aspect):
    """The inputs and outputs of this data process"""


    ASPECT_NAME = 'dataProcessInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataprocess.DataProcessInfo")

    def __init__(self,
        inputs: Union[None, List[str]]=None,
        outputs: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.inputs = inputs
        self.outputs = outputs
    
    def _restore_defaults(self) -> None:
        self.inputs = self.RECORD_SCHEMA.fields_dict["inputs"].default
        self.outputs = self.RECORD_SCHEMA.fields_dict["outputs"].default
    
    
    @property
    def inputs(self) -> Union[None, List[str]]:
        """the inputs of the data process"""
        return self._inner_dict.get('inputs')  # type: ignore
    
    @inputs.setter
    def inputs(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['inputs'] = value
    
    
    @property
    def outputs(self) -> Union[None, List[str]]:
        """the outputs of the data process"""
        return self._inner_dict.get('outputs')  # type: ignore
    
    @outputs.setter
    def outputs(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['outputs'] = value
    
    
class DataProcessInstanceInputClass(_Aspect):
    """Information about the inputs datasets of a Data process"""


    ASPECT_NAME = 'dataProcessInstanceInput'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceInput")

    def __init__(self,
        inputs: List[str],
        inputEdges: Union[None, List["EdgeClass"]]=None,
    ):
        super().__init__()
        
        self.inputs = inputs
        self.inputEdges = inputEdges
    
    def _restore_defaults(self) -> None:
        self.inputs = list()
        self.inputEdges = self.RECORD_SCHEMA.fields_dict["inputEdges"].default
    
    
    @property
    def inputs(self) -> List[str]:
        """Input assets consumed"""
        return self._inner_dict.get('inputs')  # type: ignore
    
    @inputs.setter
    def inputs(self, value: List[str]) -> None:
        self._inner_dict['inputs'] = value
    
    
    @property
    def inputEdges(self) -> Union[None, List["EdgeClass"]]:
        """Input assets consumed by the data process instance, with additional metadata.
    Counts as lineage.
    Will eventually deprecate the inputs field."""
        return self._inner_dict.get('inputEdges')  # type: ignore
    
    @inputEdges.setter
    def inputEdges(self, value: Union[None, List["EdgeClass"]]) -> None:
        self._inner_dict['inputEdges'] = value
    
    
class DataProcessInstanceOutputClass(_Aspect):
    """Information about the outputs of a Data process"""


    ASPECT_NAME = 'dataProcessInstanceOutput'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceOutput")

    def __init__(self,
        outputs: List[str],
        outputEdges: Union[None, List["EdgeClass"]]=None,
    ):
        super().__init__()
        
        self.outputs = outputs
        self.outputEdges = outputEdges
    
    def _restore_defaults(self) -> None:
        self.outputs = list()
        self.outputEdges = self.RECORD_SCHEMA.fields_dict["outputEdges"].default
    
    
    @property
    def outputs(self) -> List[str]:
        """Output assets produced"""
        return self._inner_dict.get('outputs')  # type: ignore
    
    @outputs.setter
    def outputs(self, value: List[str]) -> None:
        self._inner_dict['outputs'] = value
    
    
    @property
    def outputEdges(self) -> Union[None, List["EdgeClass"]]:
        """Output assets produced by the data process instance during processing, with additional metadata.
    Counts as lineage.
    Will eventually deprecate the outputs field."""
        return self._inner_dict.get('outputEdges')  # type: ignore
    
    @outputEdges.setter
    def outputEdges(self, value: Union[None, List["EdgeClass"]]) -> None:
        self._inner_dict['outputEdges'] = value
    
    
class DataProcessInstancePropertiesClass(_Aspect):
    """The inputs and outputs of this data process"""


    ASPECT_NAME = 'dataProcessInstanceProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceProperties")

    def __init__(self,
        name: str,
        created: "AuditStampClass",
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        type: Union[None, Union[str, "DataProcessTypeClass"]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.name = name
        self.type = type
        self.created = created
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = str()
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        self.created = AuditStampClass._construct_with_defaults()
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> str:
        """Process name"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def type(self) -> Union[None, Union[str, "DataProcessTypeClass"]]:
        """Process type"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[None, Union[str, "DataProcessTypeClass"]]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp containing who reported the lineage and when"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
class DataProcessInstanceRelationshipsClass(_Aspect):
    """Information about Data process relationships"""


    ASPECT_NAME = 'dataProcessInstanceRelationships'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceRelationships")

    def __init__(self,
        upstreamInstances: List[str],
        parentTemplate: Union[None, str]=None,
        parentInstance: Union[None, str]=None,
    ):
        super().__init__()
        
        self.parentTemplate = parentTemplate
        self.parentInstance = parentInstance
        self.upstreamInstances = upstreamInstances
    
    def _restore_defaults(self) -> None:
        self.parentTemplate = self.RECORD_SCHEMA.fields_dict["parentTemplate"].default
        self.parentInstance = self.RECORD_SCHEMA.fields_dict["parentInstance"].default
        self.upstreamInstances = list()
    
    
    @property
    def parentTemplate(self) -> Union[None, str]:
        """The parent entity whose run instance it is"""
        return self._inner_dict.get('parentTemplate')  # type: ignore
    
    @parentTemplate.setter
    def parentTemplate(self, value: Union[None, str]) -> None:
        self._inner_dict['parentTemplate'] = value
    
    
    @property
    def parentInstance(self) -> Union[None, str]:
        """The parent DataProcessInstance where it belongs to.
    If it is a Airflow Task then it should belong to an Airflow Dag run as well
    which will be another DataProcessInstance"""
        return self._inner_dict.get('parentInstance')  # type: ignore
    
    @parentInstance.setter
    def parentInstance(self, value: Union[None, str]) -> None:
        self._inner_dict['parentInstance'] = value
    
    
    @property
    def upstreamInstances(self) -> List[str]:
        """Input DataProcessInstance which triggered this dataprocess instance"""
        return self._inner_dict.get('upstreamInstances')  # type: ignore
    
    @upstreamInstances.setter
    def upstreamInstances(self, value: List[str]) -> None:
        self._inner_dict['upstreamInstances'] = value
    
    
class DataProcessInstanceRunEventClass(_Aspect):
    """An event representing the current status of data process run.
    DataProcessRunEvent should be used for reporting the status of a dataProcess' run."""


    ASPECT_NAME = 'dataProcessInstanceRunEvent'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceRunEvent")

    def __init__(self,
        timestampMillis: int,
        status: Union[str, "DataProcessRunStatusClass"],
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        externalUrl: Union[None, str]=None,
        attempt: Union[None, int]=None,
        result: Union[None, "DataProcessInstanceRunResultClass"]=None,
        durationMillis: Union[None, int]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.externalUrl = externalUrl
        self.status = status
        self.attempt = attempt
        self.result = result
        self.durationMillis = durationMillis
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.status = DataProcessRunStatusClass.STARTED
        self.attempt = self.RECORD_SCHEMA.fields_dict["attempt"].default
        self.result = self.RECORD_SCHEMA.fields_dict["result"].default
        self.durationMillis = self.RECORD_SCHEMA.fields_dict["durationMillis"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def status(self) -> Union[str, "DataProcessRunStatusClass"]:
        # No docs available.
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "DataProcessRunStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def attempt(self) -> Union[None, int]:
        """Return the try number that this Instance Run is in"""
        return self._inner_dict.get('attempt')  # type: ignore
    
    @attempt.setter
    def attempt(self, value: Union[None, int]) -> None:
        self._inner_dict['attempt'] = value
    
    
    @property
    def result(self) -> Union[None, "DataProcessInstanceRunResultClass"]:
        """The final result of the Data Processing run."""
        return self._inner_dict.get('result')  # type: ignore
    
    @result.setter
    def result(self, value: Union[None, "DataProcessInstanceRunResultClass"]) -> None:
        self._inner_dict['result'] = value
    
    
    @property
    def durationMillis(self) -> Union[None, int]:
        """The duration of the run in milliseconds."""
        return self._inner_dict.get('durationMillis')  # type: ignore
    
    @durationMillis.setter
    def durationMillis(self, value: Union[None, int]) -> None:
        self._inner_dict['durationMillis'] = value
    
    
class DataProcessInstanceRunResultClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceRunResult")
    def __init__(self,
        type: Union[str, "RunResultTypeClass"],
        nativeResultType: str,
    ):
        super().__init__()
        
        self.type = type
        self.nativeResultType = nativeResultType
    
    def _restore_defaults(self) -> None:
        self.type = RunResultTypeClass.SUCCESS
        self.nativeResultType = str()
    
    
    @property
    def type(self) -> Union[str, "RunResultTypeClass"]:
        """ The final result, e.g. SUCCESS, FAILURE, SKIPPED, or UP_FOR_RETRY."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "RunResultTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def nativeResultType(self) -> str:
        """It identifies the system where the native result comes from like Airflow, Azkaban, etc.."""
        return self._inner_dict.get('nativeResultType')  # type: ignore
    
    @nativeResultType.setter
    def nativeResultType(self, value: str) -> None:
        self._inner_dict['nativeResultType'] = value
    
    
class DataProcessRunStatusClass(object):
    # No docs available.
    
    STARTED = "STARTED"
    """The status where the Data processing run is in."""
    
    COMPLETE = "COMPLETE"
    
    
    
class DataProcessTypeClass(object):
    # No docs available.
    
    BATCH_SCHEDULED = "BATCH_SCHEDULED"
    BATCH_AD_HOC = "BATCH_AD_HOC"
    STREAMING = "STREAMING"
    
    
class RunResultTypeClass(object):
    # No docs available.
    
    SUCCESS = "SUCCESS"
    """ The Run Succeeded"""
    
    FAILURE = "FAILURE"
    """ The Run Failed"""
    
    SKIPPED = "SKIPPED"
    """ The Run Skipped"""
    
    UP_FOR_RETRY = "UP_FOR_RETRY"
    """ The Run Failed and will Retry"""
    
    
    
class DataProductAssociationClass(DictWrapper):
    """Represents an association of assets to a Data Product."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataproduct.DataProductAssociation")
    def __init__(self,
        destinationUrn: str,
        sourceUrn: Union[None, str]=None,
        created: Union[None, "AuditStampClass"]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
        properties: Union[None, Dict[str, str]]=None,
        outputPort: Optional[bool]=None,
    ):
        super().__init__()
        
        self.sourceUrn = sourceUrn
        self.destinationUrn = destinationUrn
        self.created = created
        self.lastModified = lastModified
        self.properties = properties
        if outputPort is None:
            # default: False
            self.outputPort = self.RECORD_SCHEMA.fields_dict["outputPort"].default
        else:
            self.outputPort = outputPort
    
    def _restore_defaults(self) -> None:
        self.sourceUrn = self.RECORD_SCHEMA.fields_dict["sourceUrn"].default
        self.destinationUrn = str()
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.properties = self.RECORD_SCHEMA.fields_dict["properties"].default
        self.outputPort = self.RECORD_SCHEMA.fields_dict["outputPort"].default
    
    
    @property
    def sourceUrn(self) -> Union[None, str]:
        """Urn of the source of this relationship edge.
    If not specified, assumed to be the entity that this aspect belongs to."""
        return self._inner_dict.get('sourceUrn')  # type: ignore
    
    @sourceUrn.setter
    def sourceUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['sourceUrn'] = value
    
    
    @property
    def destinationUrn(self) -> str:
        """Urn of the destination of this relationship edge."""
        return self._inner_dict.get('destinationUrn')  # type: ignore
    
    @destinationUrn.setter
    def destinationUrn(self, value: str) -> None:
        self._inner_dict['destinationUrn'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp containing who created this relationship edge and when"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp containing who last modified this relationship edge and when"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def properties(self) -> Union[None, Dict[str, str]]:
        """A generic properties bag that allows us to store specific information on this graph edge."""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['properties'] = value
    
    
    @property
    def outputPort(self) -> bool:
        """If set to true, this asset is an output port of the Data Product."""
        return self._inner_dict.get('outputPort')  # type: ignore
    
    @outputPort.setter
    def outputPort(self, value: bool) -> None:
        self._inner_dict['outputPort'] = value
    
    
class DataProductKeyClass(_Aspect):
    """Key for a Query"""


    ASPECT_NAME = 'dataProductKey'
    ASPECT_INFO = {'keyForEntity': 'dataProduct', 'entityCategory': 'core', 'entityAspects': ['ownership', 'glossaryTerms', 'globalTags', 'domains', 'applications', 'dataProductProperties', 'institutionalMemory', 'status', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'assetSettings', 'share', 'origin']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataproduct.DataProductKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the Data Product."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataProductPropertiesClass(_Aspect):
    """The main properties of a Data Product"""


    ASPECT_NAME = 'dataProductProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataproduct.DataProductProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        name: Union[None, str]=None,
        description: Union[None, str]=None,
        assets: Union[None, List["DataProductAssociationClass"]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.name = name
        self.description = description
        self.assets = assets
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.assets = self.RECORD_SCHEMA.fields_dict["assets"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the Data Product"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the data product"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def assets(self) -> Union[None, List["DataProductAssociationClass"]]:
        """A list of assets that are part of this Data Product"""
        return self._inner_dict.get('assets')  # type: ignore
    
    @assets.setter
    def assets(self, value: Union[None, List["DataProductAssociationClass"]]) -> None:
        self._inner_dict['assets'] = value
    
    
class DatasetDeprecationClass(_Aspect):
    """Dataset deprecation status
    Deprecated! This aspect is deprecated in favor of the more-general-purpose 'Deprecation' aspect."""


    ASPECT_NAME = 'datasetDeprecation'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetDeprecation")

    def __init__(self,
        deprecated: bool,
        note: str,
        decommissionTime: Union[None, int]=None,
        actor: Union[None, str]=None,
    ):
        super().__init__()
        
        self.deprecated = deprecated
        self.decommissionTime = decommissionTime
        self.note = note
        self.actor = actor
    
    def _restore_defaults(self) -> None:
        self.deprecated = bool()
        self.decommissionTime = self.RECORD_SCHEMA.fields_dict["decommissionTime"].default
        self.note = str()
        self.actor = self.RECORD_SCHEMA.fields_dict["actor"].default
    
    
    @property
    def deprecated(self) -> bool:
        """Whether the dataset is deprecated by owner."""
        return self._inner_dict.get('deprecated')  # type: ignore
    
    @deprecated.setter
    def deprecated(self, value: bool) -> None:
        self._inner_dict['deprecated'] = value
    
    
    @property
    def decommissionTime(self) -> Union[None, int]:
        """The time user plan to decommission this dataset."""
        return self._inner_dict.get('decommissionTime')  # type: ignore
    
    @decommissionTime.setter
    def decommissionTime(self, value: Union[None, int]) -> None:
        self._inner_dict['decommissionTime'] = value
    
    
    @property
    def note(self) -> str:
        """Additional information about the dataset deprecation plan, such as the wiki, doc, RB."""
        return self._inner_dict.get('note')  # type: ignore
    
    @note.setter
    def note(self, value: str) -> None:
        self._inner_dict['note'] = value
    
    
    @property
    def actor(self) -> Union[None, str]:
        """The corpuser URN which will be credited for modifying this deprecation content."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: Union[None, str]) -> None:
        self._inner_dict['actor'] = value
    
    
class DatasetFieldMappingClass(DictWrapper):
    """Representation of mapping between fields in source dataset to the field in destination dataset"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetFieldMapping")
    def __init__(self,
        created: "AuditStampClass",
        transformation: Union[Union[str, "TransformationTypeClass"], "UDFTransformerClass"],
        sourceFields: List[str],
        destinationField: str,
    ):
        super().__init__()
        
        self.created = created
        self.transformation = transformation
        self.sourceFields = sourceFields
        self.destinationField = destinationField
    
    def _restore_defaults(self) -> None:
        self.created = AuditStampClass._construct_with_defaults()
        self.transformation = TransformationTypeClass.BLACKBOX
        self.sourceFields = list()
        self.destinationField = str()
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp containing who reported the field mapping and when"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def transformation(self) -> Union[Union[str, "TransformationTypeClass"], "UDFTransformerClass"]:
        """Transfomration function between the fields involved"""
        return self._inner_dict.get('transformation')  # type: ignore
    
    @transformation.setter
    def transformation(self, value: Union[Union[str, "TransformationTypeClass"], "UDFTransformerClass"]) -> None:
        self._inner_dict['transformation'] = value
    
    
    @property
    def sourceFields(self) -> List[str]:
        """Source fields from which the fine grained lineage is derived"""
        return self._inner_dict.get('sourceFields')  # type: ignore
    
    @sourceFields.setter
    def sourceFields(self, value: List[str]) -> None:
        self._inner_dict['sourceFields'] = value
    
    
    @property
    def destinationField(self) -> str:
        """Destination field which is derived from source fields"""
        return self._inner_dict.get('destinationField')  # type: ignore
    
    @destinationField.setter
    def destinationField(self, value: str) -> None:
        self._inner_dict['destinationField'] = value
    
    
class DatasetFieldProfileClass(DictWrapper):
    """Stats corresponding to fields in a dataset"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetFieldProfile")
    def __init__(self,
        fieldPath: str,
        uniqueCount: Union[None, int]=None,
        uniqueProportion: Union[None, float]=None,
        nullCount: Union[None, int]=None,
        nullProportion: Union[None, float]=None,
        min: Union[None, str]=None,
        max: Union[None, str]=None,
        mean: Union[None, str]=None,
        median: Union[None, str]=None,
        stdev: Union[None, str]=None,
        quantiles: Union[None, List["QuantileClass"]]=None,
        histogram: Union[None, "HistogramClass"]=None,
        distinctValueFrequencies: Union[None, List["ValueFrequencyClass"]]=None,
        sampleValues: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.uniqueCount = uniqueCount
        self.uniqueProportion = uniqueProportion
        self.nullCount = nullCount
        self.nullProportion = nullProportion
        self.min = min
        self.max = max
        self.mean = mean
        self.median = median
        self.stdev = stdev
        self.quantiles = quantiles
        self.histogram = histogram
        self.distinctValueFrequencies = distinctValueFrequencies
        self.sampleValues = sampleValues
        self.fieldPath = fieldPath
    
    def _restore_defaults(self) -> None:
        self.uniqueCount = self.RECORD_SCHEMA.fields_dict["uniqueCount"].default
        self.uniqueProportion = self.RECORD_SCHEMA.fields_dict["uniqueProportion"].default
        self.nullCount = self.RECORD_SCHEMA.fields_dict["nullCount"].default
        self.nullProportion = self.RECORD_SCHEMA.fields_dict["nullProportion"].default
        self.min = self.RECORD_SCHEMA.fields_dict["min"].default
        self.max = self.RECORD_SCHEMA.fields_dict["max"].default
        self.mean = self.RECORD_SCHEMA.fields_dict["mean"].default
        self.median = self.RECORD_SCHEMA.fields_dict["median"].default
        self.stdev = self.RECORD_SCHEMA.fields_dict["stdev"].default
        self.quantiles = self.RECORD_SCHEMA.fields_dict["quantiles"].default
        self.histogram = self.RECORD_SCHEMA.fields_dict["histogram"].default
        self.distinctValueFrequencies = self.RECORD_SCHEMA.fields_dict["distinctValueFrequencies"].default
        self.sampleValues = self.RECORD_SCHEMA.fields_dict["sampleValues"].default
        self.fieldPath = str()
    
    
    @property
    def uniqueCount(self) -> Union[None, int]:
        """The count of unique values for the field across the dataset.
    Useful for understanding the diversity of field values."""
        return self._inner_dict.get('uniqueCount')  # type: ignore
    
    @uniqueCount.setter
    def uniqueCount(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueCount'] = value
    
    
    @property
    def uniqueProportion(self) -> Union[None, float]:
        """The proportion of unique values over the total number of non-null entries.
    Helps in assessing the uniqueness of the data in the field."""
        return self._inner_dict.get('uniqueProportion')  # type: ignore
    
    @uniqueProportion.setter
    def uniqueProportion(self, value: Union[None, float]) -> None:
        self._inner_dict['uniqueProportion'] = value
    
    
    @property
    def nullCount(self) -> Union[None, int]:
        """The count of null or missing entries for the field.
    Important for data quality assessments."""
        return self._inner_dict.get('nullCount')  # type: ignore
    
    @nullCount.setter
    def nullCount(self, value: Union[None, int]) -> None:
        self._inner_dict['nullCount'] = value
    
    
    @property
    def nullProportion(self) -> Union[None, float]:
        """The proportion of null entries over the total number of entries in the field.
    Useful for identifying fields with a high rate of missing values."""
        return self._inner_dict.get('nullProportion')  # type: ignore
    
    @nullProportion.setter
    def nullProportion(self, value: Union[None, float]) -> None:
        self._inner_dict['nullProportion'] = value
    
    
    @property
    def min(self) -> Union[None, str]:
        """The minimum value in the field for string-representable data types.
    Provides a sense of the lower bound of field values."""
        return self._inner_dict.get('min')  # type: ignore
    
    @min.setter
    def min(self, value: Union[None, str]) -> None:
        self._inner_dict['min'] = value
    
    
    @property
    def max(self) -> Union[None, str]:
        """The maximum value in the field for string-representable data types.
    Provides a sense of the upper bound of field values."""
        return self._inner_dict.get('max')  # type: ignore
    
    @max.setter
    def max(self, value: Union[None, str]) -> None:
        self._inner_dict['max'] = value
    
    
    @property
    def mean(self) -> Union[None, str]:
        """The mean (average) value of the field, represented as a string.
    Useful for numerical fields to understand the central tendency."""
        return self._inner_dict.get('mean')  # type: ignore
    
    @mean.setter
    def mean(self, value: Union[None, str]) -> None:
        self._inner_dict['mean'] = value
    
    
    @property
    def median(self) -> Union[None, str]:
        """The median value of the field, represented as a string.
    Useful for understanding the middle value when data is sorted."""
        return self._inner_dict.get('median')  # type: ignore
    
    @median.setter
    def median(self, value: Union[None, str]) -> None:
        self._inner_dict['median'] = value
    
    
    @property
    def stdev(self) -> Union[None, str]:
        """The standard deviation of the field values, represented as a string.
    Indicates the amount of variation or dispersion of field values."""
        return self._inner_dict.get('stdev')  # type: ignore
    
    @stdev.setter
    def stdev(self, value: Union[None, str]) -> None:
        self._inner_dict['stdev'] = value
    
    
    @property
    def quantiles(self) -> Union[None, List["QuantileClass"]]:
        """Only for numerical columns. Sorted list of quantile cutoffs for the field, in ascending order.
    Helps in assessing the diversity of the data in the field.
    Expect both the quantile and the value field to be string-ified floats.
    Ex: quantile: "0.25", value: "1.0" means the 25th percentile of values falls at 1.0"""
        return self._inner_dict.get('quantiles')  # type: ignore
    
    @quantiles.setter
    def quantiles(self, value: Union[None, List["QuantileClass"]]) -> None:
        self._inner_dict['quantiles'] = value
    
    
    @property
    def histogram(self) -> Union[None, "HistogramClass"]:
        """Only for numerical columns. A histogram where a range of values in a numerical column
    are rolled up into bins, with the heights representing the number of values in that bin.
    Divided into k bin boundaries, with k-1 frequencies; first+last frequency values are tail weights
    Currently unused in the product."""
        return self._inner_dict.get('histogram')  # type: ignore
    
    @histogram.setter
    def histogram(self, value: Union[None, "HistogramClass"]) -> None:
        self._inner_dict['histogram'] = value
    
    
    @property
    def distinctValueFrequencies(self) -> Union[None, List["ValueFrequencyClass"]]:
        """Volume of each column value for a low-cardinality / categorical field.
    Useful for understanding the distribution of values in the field, and monitoring for changes
    in specific value volumes.
    For numeric colums, the value will contain a strigified value."""
        return self._inner_dict.get('distinctValueFrequencies')  # type: ignore
    
    @distinctValueFrequencies.setter
    def distinctValueFrequencies(self, value: Union[None, List["ValueFrequencyClass"]]) -> None:
        self._inner_dict['distinctValueFrequencies'] = value
    
    
    @property
    def sampleValues(self) -> Union[None, List[str]]:
        """N randomly sampled values of the column. Useful for showing rough preview of the column."""
        return self._inner_dict.get('sampleValues')  # type: ignore
    
    @sampleValues.setter
    def sampleValues(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['sampleValues'] = value
    
    
    @property
    def fieldPath(self) -> str:
        """The standard path to the field"""
        return self._inner_dict.get('fieldPath')  # type: ignore
    
    @fieldPath.setter
    def fieldPath(self, value: str) -> None:
        self._inner_dict['fieldPath'] = value
    
    
class DatasetFieldUsageCountsClass(DictWrapper):
    """Records field-level usage counts for a given dataset"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetFieldUsageCounts")
    def __init__(self,
        fieldPath: str,
        count: int,
    ):
        super().__init__()
        
        self.fieldPath = fieldPath
        self.count = count
    
    def _restore_defaults(self) -> None:
        self.fieldPath = str()
        self.count = int()
    
    
    @property
    def fieldPath(self) -> str:
        """The name of the field."""
        return self._inner_dict.get('fieldPath')  # type: ignore
    
    @fieldPath.setter
    def fieldPath(self, value: str) -> None:
        self._inner_dict['fieldPath'] = value
    
    
    @property
    def count(self) -> int:
        """Number of times the field has been used."""
        return self._inner_dict.get('count')  # type: ignore
    
    @count.setter
    def count(self, value: int) -> None:
        self._inner_dict['count'] = value
    
    
class DatasetFilterClass(DictWrapper):
    """A definition of filters that should be used when
    querying an external Dataset or Table.
    
    Note that this models should NOT be used for working with
    search / filter on DataHub Platform itself."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetFilter")
    def __init__(self,
        type: Union[str, "DatasetFilterTypeClass"],
        sql: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.sql = sql
    
    def _restore_defaults(self) -> None:
        self.type = DatasetFilterTypeClass.SQL
        self.sql = self.RECORD_SCHEMA.fields_dict["sql"].default
    
    
    @property
    def type(self) -> Union[str, "DatasetFilterTypeClass"]:
        """How the partition will be represented in this model.
    
    In the future, we'll likely add support for more structured
    predicates."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DatasetFilterTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def sql(self) -> Union[None, str]:
        """The raw where clause string which will be used for monitoring.
    Required if the type is SQL."""
        return self._inner_dict.get('sql')  # type: ignore
    
    @sql.setter
    def sql(self, value: Union[None, str]) -> None:
        self._inner_dict['sql'] = value
    
    
class DatasetFilterTypeClass(object):
    # No docs available.
    
    SQL = "SQL"
    """The partition is represented as a an opaque, raw SQL
    clause."""
    
    
    
class DatasetLineageTypeClass(object):
    """The various types of supported dataset lineage"""
    
    COPY = "COPY"
    """Direct copy without modification"""
    
    TRANSFORMED = "TRANSFORMED"
    """Transformed data with modification (format or content change)"""
    
    VIEW = "VIEW"
    """Represents a view defined on the sources e.g. Hive view defined on underlying hive tables or a Hive table pointing to a HDFS dataset or DALI view defined on multiple sources"""
    
    
    
class DatasetMetricsOriginTypeClass(object):
    # No docs available.
    
    ALL_ROWS_QUERY = "ALL_ROWS_QUERY"
    """Issue a query to the table to obtain the metric or values across
    all rows."""
    
    CHANGED_ROWS_QUERY = "CHANGED_ROWS_QUERY"
    """Issue a query to the table to obtain the metric values across
    only the rows which have changed since the previous evaluation."""
    
    INFORMATION_SCHEMA = "INFORMATION_SCHEMA"
    """Operation was identified by inspecting an information schema table, or other system metadata table."""
    
    AUDIT_LOG = "AUDIT_LOG"
    """Operation was identified by inspecting an audit log API"""
    
    FILE_METADATA = "FILE_METADATA"
    """Operation was identified by inspecting underlying file system."""
    
    
    
class DatasetMetricsSourceDetailsClass(DictWrapper):
    """Additional details about the origins of a captured source-platform Metric or Metric Set."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetMetricsSourceDetails")
    def __init__(self,
        producerType: Union[str, "MetadataProducerTypeClass"],
        originType: Union[str, "DatasetMetricsOriginTypeClass"],
        producerUrn: Union[None, str]=None,
        changedRowsField: Union[None, "FreshnessFieldSpecClass"]=None,
        filter: Union[None, "DatasetFilterClass"]=None,
    ):
        super().__init__()
        
        self.producerType = producerType
        self.producerUrn = producerUrn
        self.originType = originType
        self.changedRowsField = changedRowsField
        self.filter = filter
    
    def _restore_defaults(self) -> None:
        self.producerType = MetadataProducerTypeClass.INGESTION_SOURCE
        self.producerUrn = self.RECORD_SCHEMA.fields_dict["producerUrn"].default
        self.originType = DatasetMetricsOriginTypeClass.ALL_ROWS_QUERY
        self.changedRowsField = self.RECORD_SCHEMA.fields_dict["changedRowsField"].default
        self.filter = self.RECORD_SCHEMA.fields_dict["filter"].default
    
    
    @property
    def producerType(self) -> Union[str, "MetadataProducerTypeClass"]:
        """The specific type of producer for the operation."""
        return self._inner_dict.get('producerType')  # type: ignore
    
    @producerType.setter
    def producerType(self, value: Union[str, "MetadataProducerTypeClass"]) -> None:
        self._inner_dict['producerType'] = value
    
    
    @property
    def producerUrn(self) -> Union[None, str]:
        """The producer urn for the operation. Only provided is producerType == MONITOR currently,
    where it will be set to the monitor urn that sampled the operation. Ideally, this also contains
    the ingestion source urn if applicable."""
        return self._inner_dict.get('producerUrn')  # type: ignore
    
    @producerUrn.setter
    def producerUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['producerUrn'] = value
    
    
    @property
    def originType(self) -> Union[str, "DatasetMetricsOriginTypeClass"]:
        """The specific origin of the metric with regards to the source platform."""
        return self._inner_dict.get('originType')  # type: ignore
    
    @originType.setter
    def originType(self, value: Union[str, "DatasetMetricsOriginTypeClass"]) -> None:
        self._inner_dict['originType'] = value
    
    
    @property
    def changedRowsField(self) -> Union[None, "FreshnessFieldSpecClass"]:
        """A field that can be used to filter for the fresh rows since the previous assertion
    evaluation. This should be present when sourceType = CHANGED_ROWS_QUERY.
    
    If not provided, or the metricSourceType is not QUERY, then the assertion will be evaluated against the
    entire dataset."""
        return self._inner_dict.get('changedRowsField')  # type: ignore
    
    @changedRowsField.setter
    def changedRowsField(self, value: Union[None, "FreshnessFieldSpecClass"]) -> None:
        self._inner_dict['changedRowsField'] = value
    
    
    @property
    def filter(self) -> Union[None, "DatasetFilterClass"]:
        """Any additional filters that were applied in a query to retrieve the metric.
    Only possible to be present if originType is ALL_ROWS_QUERY or CHANGED_ROWS_QUERY."""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: Union[None, "DatasetFilterClass"]) -> None:
        self._inner_dict['filter'] = value
    
    
class DatasetProfileClass(_Aspect):
    """Metrics corresponding to datasets.
    
    Notice that this aspect may be partially completed so the user
    should filter for existence of the stats they need when querying."""


    ASPECT_NAME = 'datasetProfile'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetProfile")

    def __init__(self,
        timestampMillis: int,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        rowCount: Union[None, int]=None,
        columnCount: Union[None, int]=None,
        sizeInBytes: Union[None, int]=None,
        fieldProfiles: Union[None, List["DatasetFieldProfileClass"]]=None,
        source: Union[None, "DatasetMetricsSourceDetailsClass"]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.rowCount = rowCount
        self.columnCount = columnCount
        self.sizeInBytes = sizeInBytes
        self.fieldProfiles = fieldProfiles
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.rowCount = self.RECORD_SCHEMA.fields_dict["rowCount"].default
        self.columnCount = self.RECORD_SCHEMA.fields_dict["columnCount"].default
        self.sizeInBytes = self.RECORD_SCHEMA.fields_dict["sizeInBytes"].default
        self.fieldProfiles = self.RECORD_SCHEMA.fields_dict["fieldProfiles"].default
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def rowCount(self) -> Union[None, int]:
        """The total number of rows"""
        return self._inner_dict.get('rowCount')  # type: ignore
    
    @rowCount.setter
    def rowCount(self, value: Union[None, int]) -> None:
        self._inner_dict['rowCount'] = value
    
    
    @property
    def columnCount(self) -> Union[None, int]:
        """The total number of columns (or schema fields)"""
        return self._inner_dict.get('columnCount')  # type: ignore
    
    @columnCount.setter
    def columnCount(self, value: Union[None, int]) -> None:
        self._inner_dict['columnCount'] = value
    
    
    @property
    def sizeInBytes(self) -> Union[None, int]:
        """Storage size in bytes"""
        return self._inner_dict.get('sizeInBytes')  # type: ignore
    
    @sizeInBytes.setter
    def sizeInBytes(self, value: Union[None, int]) -> None:
        self._inner_dict['sizeInBytes'] = value
    
    
    @property
    def fieldProfiles(self) -> Union[None, List["DatasetFieldProfileClass"]]:
        """Profiles for each column (or schema field). Notice that we are moving away from
    using this model and moving toward DatasetFieldProfiles attached to the dataset
    field urn directly. This field is kept for backward compatibility."""
        return self._inner_dict.get('fieldProfiles')  # type: ignore
    
    @fieldProfiles.setter
    def fieldProfiles(self, value: Union[None, List["DatasetFieldProfileClass"]]) -> None:
        self._inner_dict['fieldProfiles'] = value
    
    
    @property
    def source(self) -> Union[None, "DatasetMetricsSourceDetailsClass"]:
        """Rich details about the source of the metrics provided in this profile."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "DatasetMetricsSourceDetailsClass"]) -> None:
        self._inner_dict['source'] = value
    
    
class DatasetPropertiesClass(_Aspect):
    """Properties associated with a Dataset"""


    ASPECT_NAME = 'datasetProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        name: Union[None, str]=None,
        qualifiedName: Union[None, str]=None,
        description: Union[None, str]=None,
        uri: Union[None, str]=None,
        created: Union[None, "TimeStampClass"]=None,
        lastModified: Union[None, "TimeStampClass"]=None,
        tags: Optional[List[str]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.name = name
        self.qualifiedName = qualifiedName
        self.description = description
        self.uri = uri
        self.created = created
        self.lastModified = lastModified
        if tags is None:
            # default: []
            self.tags = list()
        else:
            self.tags = tags
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.qualifiedName = self.RECORD_SCHEMA.fields_dict["qualifiedName"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.uri = self.RECORD_SCHEMA.fields_dict["uri"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.tags = list()
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the Dataset"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def qualifiedName(self) -> Union[None, str]:
        """Fully-qualified name of the Dataset"""
        return self._inner_dict.get('qualifiedName')  # type: ignore
    
    @qualifiedName.setter
    def qualifiedName(self, value: Union[None, str]) -> None:
        self._inner_dict['qualifiedName'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the dataset"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def uri(self) -> Union[None, str]:
        """The abstracted URI such as hdfs:///data/tracking/PageViewEvent, file:///dir/file_name. Uri should not include any environment specific properties. Some datasets might not have a standardized uri, which makes this field optional (i.e. kafka topic)."""
        return self._inner_dict.get('uri')  # type: ignore
    
    @uri.setter
    def uri(self, value: Union[None, str]) -> None:
        self._inner_dict['uri'] = value
    
    
    @property
    def created(self) -> Union[None, "TimeStampClass"]:
        """A timestamp documenting when the asset was created in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "TimeStampClass"]:
        """A timestamp documenting when the asset was last modified in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def tags(self) -> List[str]:
        """[Legacy] Unstructured tags for the dataset. Structured tags can be applied via the `GlobalTags` aspect.
    This is now deprecated."""
        return self._inner_dict.get('tags')  # type: ignore
    
    @tags.setter
    def tags(self, value: List[str]) -> None:
        self._inner_dict['tags'] = value
    
    
class DatasetUpstreamLineageClass(_Aspect):
    """Fine Grained upstream lineage for fields in a dataset"""


    ASPECT_NAME = 'datasetUpstreamLineage'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetUpstreamLineage")

    def __init__(self,
        fieldMappings: List["DatasetFieldMappingClass"],
    ):
        super().__init__()
        
        self.fieldMappings = fieldMappings
    
    def _restore_defaults(self) -> None:
        self.fieldMappings = list()
    
    
    @property
    def fieldMappings(self) -> List["DatasetFieldMappingClass"]:
        """Upstream to downstream field level lineage mappings"""
        return self._inner_dict.get('fieldMappings')  # type: ignore
    
    @fieldMappings.setter
    def fieldMappings(self, value: List["DatasetFieldMappingClass"]) -> None:
        self._inner_dict['fieldMappings'] = value
    
    
class DatasetUsageStatisticsClass(_Aspect):
    """Stats corresponding to dataset's usage."""


    ASPECT_NAME = 'datasetUsageStatistics'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetUsageStatistics")

    def __init__(self,
        timestampMillis: int,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        uniqueUserCount: Union[None, int]=None,
        totalSqlQueries: Union[None, int]=None,
        topSqlQueries: Union[None, List[str]]=None,
        userCounts: Union[None, List["DatasetUserUsageCountsClass"]]=None,
        fieldCounts: Union[None, List["DatasetFieldUsageCountsClass"]]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.uniqueUserCount = uniqueUserCount
        self.totalSqlQueries = totalSqlQueries
        self.topSqlQueries = topSqlQueries
        self.userCounts = userCounts
        self.fieldCounts = fieldCounts
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.uniqueUserCount = self.RECORD_SCHEMA.fields_dict["uniqueUserCount"].default
        self.totalSqlQueries = self.RECORD_SCHEMA.fields_dict["totalSqlQueries"].default
        self.topSqlQueries = self.RECORD_SCHEMA.fields_dict["topSqlQueries"].default
        self.userCounts = self.RECORD_SCHEMA.fields_dict["userCounts"].default
        self.fieldCounts = self.RECORD_SCHEMA.fields_dict["fieldCounts"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def uniqueUserCount(self) -> Union[None, int]:
        """Unique user count"""
        return self._inner_dict.get('uniqueUserCount')  # type: ignore
    
    @uniqueUserCount.setter
    def uniqueUserCount(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueUserCount'] = value
    
    
    @property
    def totalSqlQueries(self) -> Union[None, int]:
        """Total SQL query count"""
        return self._inner_dict.get('totalSqlQueries')  # type: ignore
    
    @totalSqlQueries.setter
    def totalSqlQueries(self, value: Union[None, int]) -> None:
        self._inner_dict['totalSqlQueries'] = value
    
    
    @property
    def topSqlQueries(self) -> Union[None, List[str]]:
        """Frequent SQL queries; mostly makes sense for datasets in SQL databases"""
        return self._inner_dict.get('topSqlQueries')  # type: ignore
    
    @topSqlQueries.setter
    def topSqlQueries(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['topSqlQueries'] = value
    
    
    @property
    def userCounts(self) -> Union[None, List["DatasetUserUsageCountsClass"]]:
        """Users within this bucket, with frequency counts"""
        return self._inner_dict.get('userCounts')  # type: ignore
    
    @userCounts.setter
    def userCounts(self, value: Union[None, List["DatasetUserUsageCountsClass"]]) -> None:
        self._inner_dict['userCounts'] = value
    
    
    @property
    def fieldCounts(self) -> Union[None, List["DatasetFieldUsageCountsClass"]]:
        """Field-level usage stats"""
        return self._inner_dict.get('fieldCounts')  # type: ignore
    
    @fieldCounts.setter
    def fieldCounts(self, value: Union[None, List["DatasetFieldUsageCountsClass"]]) -> None:
        self._inner_dict['fieldCounts'] = value
    
    
class DatasetUserUsageCountsClass(DictWrapper):
    """Records a single user's usage counts for a given resource"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.DatasetUserUsageCounts")
    def __init__(self,
        user: str,
        count: int,
        userEmail: Union[None, str]=None,
    ):
        super().__init__()
        
        self.user = user
        self.count = count
        self.userEmail = userEmail
    
    def _restore_defaults(self) -> None:
        self.user = str()
        self.count = int()
        self.userEmail = self.RECORD_SCHEMA.fields_dict["userEmail"].default
    
    
    @property
    def user(self) -> str:
        """The unique id of the user."""
        return self._inner_dict.get('user')  # type: ignore
    
    @user.setter
    def user(self, value: str) -> None:
        self._inner_dict['user'] = value
    
    
    @property
    def count(self) -> int:
        """Number of times the dataset has been used by the user."""
        return self._inner_dict.get('count')  # type: ignore
    
    @count.setter
    def count(self, value: int) -> None:
        self._inner_dict['count'] = value
    
    
    @property
    def userEmail(self) -> Union[None, str]:
        """If user_email is set, we attempt to resolve the user's urn upon ingest"""
        return self._inner_dict.get('userEmail')  # type: ignore
    
    @userEmail.setter
    def userEmail(self, value: Union[None, str]) -> None:
        self._inner_dict['userEmail'] = value
    
    
class EditableDatasetPropertiesClass(_Aspect):
    """EditableDatasetProperties stores editable changes made to dataset properties. This separates changes made from
    ingestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"""


    ASPECT_NAME = 'editableDatasetProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.EditableDatasetProperties")

    def __init__(self,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        description: Union[None, str]=None,
        name: Union[None, str]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.description = description
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the dataset"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Editable display name of the Dataset"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
class FineGrainedLineageClass(DictWrapper):
    """A fine-grained lineage from upstream fields/datasets to downstream field(s)"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.FineGrainedLineage")
    def __init__(self,
        upstreamType: Union[str, "FineGrainedLineageUpstreamTypeClass"],
        downstreamType: Union[str, "FineGrainedLineageDownstreamTypeClass"],
        upstreams: Union[None, List[str]]=None,
        downstreams: Union[None, List[str]]=None,
        transformOperation: Union[None, str]=None,
        confidenceScore: Optional[float]=None,
        query: Union[None, str]=None,
    ):
        super().__init__()
        
        self.upstreamType = upstreamType
        self.upstreams = upstreams
        self.downstreamType = downstreamType
        self.downstreams = downstreams
        self.transformOperation = transformOperation
        if confidenceScore is None:
            # default: 1.0
            self.confidenceScore = self.RECORD_SCHEMA.fields_dict["confidenceScore"].default
        else:
            self.confidenceScore = confidenceScore
        self.query = query
    
    def _restore_defaults(self) -> None:
        self.upstreamType = FineGrainedLineageUpstreamTypeClass.FIELD_SET
        self.upstreams = self.RECORD_SCHEMA.fields_dict["upstreams"].default
        self.downstreamType = FineGrainedLineageDownstreamTypeClass.FIELD
        self.downstreams = self.RECORD_SCHEMA.fields_dict["downstreams"].default
        self.transformOperation = self.RECORD_SCHEMA.fields_dict["transformOperation"].default
        self.confidenceScore = self.RECORD_SCHEMA.fields_dict["confidenceScore"].default
        self.query = self.RECORD_SCHEMA.fields_dict["query"].default
    
    
    @property
    def upstreamType(self) -> Union[str, "FineGrainedLineageUpstreamTypeClass"]:
        """The type of upstream entity"""
        return self._inner_dict.get('upstreamType')  # type: ignore
    
    @upstreamType.setter
    def upstreamType(self, value: Union[str, "FineGrainedLineageUpstreamTypeClass"]) -> None:
        self._inner_dict['upstreamType'] = value
    
    
    @property
    def upstreams(self) -> Union[None, List[str]]:
        """Upstream entities in the lineage"""
        return self._inner_dict.get('upstreams')  # type: ignore
    
    @upstreams.setter
    def upstreams(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['upstreams'] = value
    
    
    @property
    def downstreamType(self) -> Union[str, "FineGrainedLineageDownstreamTypeClass"]:
        """The type of downstream field(s)"""
        return self._inner_dict.get('downstreamType')  # type: ignore
    
    @downstreamType.setter
    def downstreamType(self, value: Union[str, "FineGrainedLineageDownstreamTypeClass"]) -> None:
        self._inner_dict['downstreamType'] = value
    
    
    @property
    def downstreams(self) -> Union[None, List[str]]:
        """Downstream fields in the lineage"""
        return self._inner_dict.get('downstreams')  # type: ignore
    
    @downstreams.setter
    def downstreams(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['downstreams'] = value
    
    
    @property
    def transformOperation(self) -> Union[None, str]:
        """The transform operation applied to the upstream entities to produce the downstream field(s)"""
        return self._inner_dict.get('transformOperation')  # type: ignore
    
    @transformOperation.setter
    def transformOperation(self, value: Union[None, str]) -> None:
        self._inner_dict['transformOperation'] = value
    
    
    @property
    def confidenceScore(self) -> float:
        """The confidence in this lineage between 0 (low confidence) and 1 (high confidence)"""
        return self._inner_dict.get('confidenceScore')  # type: ignore
    
    @confidenceScore.setter
    def confidenceScore(self, value: float) -> None:
        self._inner_dict['confidenceScore'] = value
    
    
    @property
    def query(self) -> Union[None, str]:
        """The query that was used to generate this lineage. 
    Present only if the lineage was generated from a detected query."""
        return self._inner_dict.get('query')  # type: ignore
    
    @query.setter
    def query(self, value: Union[None, str]) -> None:
        self._inner_dict['query'] = value
    
    
class FineGrainedLineageDownstreamTypeClass(object):
    """The type of downstream field(s) in a fine-grained lineage"""
    
    FIELD = "FIELD"
    """ Indicates that the lineage is for a single, specific, downstream field"""
    
    FIELD_SET = "FIELD_SET"
    """ Indicates that the lineage is for a set of downstream fields"""
    
    
    
class FineGrainedLineageUpstreamTypeClass(object):
    """The type of upstream entity in a fine-grained lineage"""
    
    FIELD_SET = "FIELD_SET"
    """ Indicates that this lineage is originating from upstream field(s)"""
    
    DATASET = "DATASET"
    """ Indicates that this lineage is originating from upstream dataset(s)"""
    
    NONE = "NONE"
    """ Indicates that there is no upstream lineage i.e. the downstream field is not a derived field"""
    
    
    
class HistogramClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.Histogram")
    def __init__(self,
        boundaries: List[str],
        heights: List[float],
    ):
        super().__init__()
        
        self.boundaries = boundaries
        self.heights = heights
    
    def _restore_defaults(self) -> None:
        self.boundaries = list()
        self.heights = list()
    
    
    @property
    def boundaries(self) -> List[str]:
        # No docs available.
        return self._inner_dict.get('boundaries')  # type: ignore
    
    @boundaries.setter
    def boundaries(self, value: List[str]) -> None:
        self._inner_dict['boundaries'] = value
    
    
    @property
    def heights(self) -> List[float]:
        # No docs available.
        return self._inner_dict.get('heights')  # type: ignore
    
    @heights.setter
    def heights(self, value: List[float]) -> None:
        self._inner_dict['heights'] = value
    
    
class IcebergCatalogInfoClass(_Aspect):
    """Iceberg Catalog metadata associated with an Iceberg table/view"""


    ASPECT_NAME = 'icebergCatalogInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.IcebergCatalogInfo")

    def __init__(self,
        metadataPointer: Union[None, str]=None,
        view: Union[None, bool]=None,
    ):
        super().__init__()
        
        self.metadataPointer = metadataPointer
        self.view = view
    
    def _restore_defaults(self) -> None:
        self.metadataPointer = self.RECORD_SCHEMA.fields_dict["metadataPointer"].default
        self.view = self.RECORD_SCHEMA.fields_dict["view"].default
    
    
    @property
    def metadataPointer(self) -> Union[None, str]:
        """When Datahub is the REST Catalog for an Iceberg Table, stores the current metadata pointer.
    If the Iceberg table is managed by an external catalog, the metadata pointer is not set."""
        return self._inner_dict.get('metadataPointer')  # type: ignore
    
    @metadataPointer.setter
    def metadataPointer(self, value: Union[None, str]) -> None:
        self._inner_dict['metadataPointer'] = value
    
    
    @property
    def view(self) -> Union[None, bool]:
        # No docs available.
        return self._inner_dict.get('view')  # type: ignore
    
    @view.setter
    def view(self, value: Union[None, bool]) -> None:
        self._inner_dict['view'] = value
    
    
class PartitionSummaryClass(DictWrapper):
    """Defines how the data is partitioned"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.PartitionSummary")
    def __init__(self,
        partition: str,
        createdTime: Union[None, int]=None,
        lastModifiedTime: Union[None, int]=None,
    ):
        super().__init__()
        
        self.partition = partition
        self.createdTime = createdTime
        self.lastModifiedTime = lastModifiedTime
    
    def _restore_defaults(self) -> None:
        self.partition = str()
        self.createdTime = self.RECORD_SCHEMA.fields_dict["createdTime"].default
        self.lastModifiedTime = self.RECORD_SCHEMA.fields_dict["lastModifiedTime"].default
    
    
    @property
    def partition(self) -> str:
        """A unique id / value for the partition for which statistics were collected,
    generated by applying the key definition to a given row."""
        return self._inner_dict.get('partition')  # type: ignore
    
    @partition.setter
    def partition(self, value: str) -> None:
        self._inner_dict['partition'] = value
    
    
    @property
    def createdTime(self) -> Union[None, int]:
        """The created time for a given partition."""
        return self._inner_dict.get('createdTime')  # type: ignore
    
    @createdTime.setter
    def createdTime(self, value: Union[None, int]) -> None:
        self._inner_dict['createdTime'] = value
    
    
    @property
    def lastModifiedTime(self) -> Union[None, int]:
        """The last modified / touched time for a given partition."""
        return self._inner_dict.get('lastModifiedTime')  # type: ignore
    
    @lastModifiedTime.setter
    def lastModifiedTime(self, value: Union[None, int]) -> None:
        self._inner_dict['lastModifiedTime'] = value
    
    
class PartitionsSummaryClass(_Aspect):
    """Defines how the data is partitioned for Data Lake tables (e.g. Hive, S3, Iceberg, Delta, Hudi, etc)."""


    ASPECT_NAME = 'partitionsSummary'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.PartitionsSummary")

    def __init__(self,
        minPartition: Union[None, "PartitionSummaryClass"]=None,
        maxPartition: Union[None, "PartitionSummaryClass"]=None,
    ):
        super().__init__()
        
        self.minPartition = minPartition
        self.maxPartition = maxPartition
    
    def _restore_defaults(self) -> None:
        self.minPartition = self.RECORD_SCHEMA.fields_dict["minPartition"].default
        self.maxPartition = self.RECORD_SCHEMA.fields_dict["maxPartition"].default
    
    
    @property
    def minPartition(self) -> Union[None, "PartitionSummaryClass"]:
        """The minimum partition as ordered"""
        return self._inner_dict.get('minPartition')  # type: ignore
    
    @minPartition.setter
    def minPartition(self, value: Union[None, "PartitionSummaryClass"]) -> None:
        self._inner_dict['minPartition'] = value
    
    
    @property
    def maxPartition(self) -> Union[None, "PartitionSummaryClass"]:
        """The maximum partition as ordered"""
        return self._inner_dict.get('maxPartition')  # type: ignore
    
    @maxPartition.setter
    def maxPartition(self, value: Union[None, "PartitionSummaryClass"]) -> None:
        self._inner_dict['maxPartition'] = value
    
    
class QuantileClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.Quantile")
    def __init__(self,
        quantile: str,
        value: str,
    ):
        super().__init__()
        
        self.quantile = quantile
        self.value = value
    
    def _restore_defaults(self) -> None:
        self.quantile = str()
        self.value = str()
    
    
    @property
    def quantile(self) -> str:
        # No docs available.
        return self._inner_dict.get('quantile')  # type: ignore
    
    @quantile.setter
    def quantile(self, value: str) -> None:
        self._inner_dict['quantile'] = value
    
    
    @property
    def value(self) -> str:
        # No docs available.
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: str) -> None:
        self._inner_dict['value'] = value
    
    
class SchemaFieldProfileClass(_Aspect):
    """Metrics corresponding to a single schema field.
    Notice that this aspect may be partially completed so the user
    should filter for existence of the stats they need when querying.
    
    In the long term, this serves as a replacement for the DatasetFieldProfile object.
    Note that it does not yet support quantiles, histograms, etc, but may evolve to in the future."""


    ASPECT_NAME = 'schemaFieldProfile'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.SchemaFieldProfile")

    def __init__(self,
        timestampMillis: int,
        uniqueCount: Union[None, int]=None,
        uniqueProportion: Union[None, float]=None,
        nullCount: Union[None, int]=None,
        nullProportion: Union[None, float]=None,
        min: Union[None, str]=None,
        max: Union[None, str]=None,
        mean: Union[None, str]=None,
        median: Union[None, str]=None,
        stdev: Union[None, str]=None,
        quantiles: Union[None, List["QuantileClass"]]=None,
        histogram: Union[None, "HistogramClass"]=None,
        distinctValueFrequencies: Union[None, List["ValueFrequencyClass"]]=None,
        sampleValues: Union[None, List[str]]=None,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        source: Union[None, "DatasetMetricsSourceDetailsClass"]=None,
    ):
        super().__init__()
        
        self.uniqueCount = uniqueCount
        self.uniqueProportion = uniqueProportion
        self.nullCount = nullCount
        self.nullProportion = nullProportion
        self.min = min
        self.max = max
        self.mean = mean
        self.median = median
        self.stdev = stdev
        self.quantiles = quantiles
        self.histogram = histogram
        self.distinctValueFrequencies = distinctValueFrequencies
        self.sampleValues = sampleValues
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.uniqueCount = self.RECORD_SCHEMA.fields_dict["uniqueCount"].default
        self.uniqueProportion = self.RECORD_SCHEMA.fields_dict["uniqueProportion"].default
        self.nullCount = self.RECORD_SCHEMA.fields_dict["nullCount"].default
        self.nullProportion = self.RECORD_SCHEMA.fields_dict["nullProportion"].default
        self.min = self.RECORD_SCHEMA.fields_dict["min"].default
        self.max = self.RECORD_SCHEMA.fields_dict["max"].default
        self.mean = self.RECORD_SCHEMA.fields_dict["mean"].default
        self.median = self.RECORD_SCHEMA.fields_dict["median"].default
        self.stdev = self.RECORD_SCHEMA.fields_dict["stdev"].default
        self.quantiles = self.RECORD_SCHEMA.fields_dict["quantiles"].default
        self.histogram = self.RECORD_SCHEMA.fields_dict["histogram"].default
        self.distinctValueFrequencies = self.RECORD_SCHEMA.fields_dict["distinctValueFrequencies"].default
        self.sampleValues = self.RECORD_SCHEMA.fields_dict["sampleValues"].default
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
    
    
    @property
    def uniqueCount(self) -> Union[None, int]:
        """The count of unique values for the field across the dataset.
    Useful for understanding the diversity of field values."""
        return self._inner_dict.get('uniqueCount')  # type: ignore
    
    @uniqueCount.setter
    def uniqueCount(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueCount'] = value
    
    
    @property
    def uniqueProportion(self) -> Union[None, float]:
        """The proportion of unique values over the total number of non-null entries.
    Helps in assessing the uniqueness of the data in the field."""
        return self._inner_dict.get('uniqueProportion')  # type: ignore
    
    @uniqueProportion.setter
    def uniqueProportion(self, value: Union[None, float]) -> None:
        self._inner_dict['uniqueProportion'] = value
    
    
    @property
    def nullCount(self) -> Union[None, int]:
        """The count of null or missing entries for the field.
    Important for data quality assessments."""
        return self._inner_dict.get('nullCount')  # type: ignore
    
    @nullCount.setter
    def nullCount(self, value: Union[None, int]) -> None:
        self._inner_dict['nullCount'] = value
    
    
    @property
    def nullProportion(self) -> Union[None, float]:
        """The proportion of null entries over the total number of entries in the field.
    Useful for identifying fields with a high rate of missing values."""
        return self._inner_dict.get('nullProportion')  # type: ignore
    
    @nullProportion.setter
    def nullProportion(self, value: Union[None, float]) -> None:
        self._inner_dict['nullProportion'] = value
    
    
    @property
    def min(self) -> Union[None, str]:
        """The minimum value in the field for string-representable data types.
    Provides a sense of the lower bound of field values."""
        return self._inner_dict.get('min')  # type: ignore
    
    @min.setter
    def min(self, value: Union[None, str]) -> None:
        self._inner_dict['min'] = value
    
    
    @property
    def max(self) -> Union[None, str]:
        """The maximum value in the field for string-representable data types.
    Provides a sense of the upper bound of field values."""
        return self._inner_dict.get('max')  # type: ignore
    
    @max.setter
    def max(self, value: Union[None, str]) -> None:
        self._inner_dict['max'] = value
    
    
    @property
    def mean(self) -> Union[None, str]:
        """The mean (average) value of the field, represented as a string.
    Useful for numerical fields to understand the central tendency."""
        return self._inner_dict.get('mean')  # type: ignore
    
    @mean.setter
    def mean(self, value: Union[None, str]) -> None:
        self._inner_dict['mean'] = value
    
    
    @property
    def median(self) -> Union[None, str]:
        """The median value of the field, represented as a string.
    Useful for understanding the middle value when data is sorted."""
        return self._inner_dict.get('median')  # type: ignore
    
    @median.setter
    def median(self, value: Union[None, str]) -> None:
        self._inner_dict['median'] = value
    
    
    @property
    def stdev(self) -> Union[None, str]:
        """The standard deviation of the field values, represented as a string.
    Indicates the amount of variation or dispersion of field values."""
        return self._inner_dict.get('stdev')  # type: ignore
    
    @stdev.setter
    def stdev(self, value: Union[None, str]) -> None:
        self._inner_dict['stdev'] = value
    
    
    @property
    def quantiles(self) -> Union[None, List["QuantileClass"]]:
        """Only for numerical columns. Sorted list of quantile cutoffs for the field, in ascending order.
    Helps in assessing the diversity of the data in the field.
    Expect both the quantile and the value field to be string-ified floats.
    Ex: quantile: "0.25", value: "1.0" means the 25th percentile of values falls at 1.0"""
        return self._inner_dict.get('quantiles')  # type: ignore
    
    @quantiles.setter
    def quantiles(self, value: Union[None, List["QuantileClass"]]) -> None:
        self._inner_dict['quantiles'] = value
    
    
    @property
    def histogram(self) -> Union[None, "HistogramClass"]:
        """Only for numerical columns. A histogram where a range of values in a numerical column
    are rolled up into bins, with the heights representing the number of values in that bin.
    Divided into k bin boundaries, with k-1 frequencies; first+last frequency values are tail weights
    Currently unused in the product."""
        return self._inner_dict.get('histogram')  # type: ignore
    
    @histogram.setter
    def histogram(self, value: Union[None, "HistogramClass"]) -> None:
        self._inner_dict['histogram'] = value
    
    
    @property
    def distinctValueFrequencies(self) -> Union[None, List["ValueFrequencyClass"]]:
        """Volume of each column value for a low-cardinality / categorical field.
    Useful for understanding the distribution of values in the field, and monitoring for changes
    in specific value volumes.
    For numeric colums, the value will contain a strigified value."""
        return self._inner_dict.get('distinctValueFrequencies')  # type: ignore
    
    @distinctValueFrequencies.setter
    def distinctValueFrequencies(self, value: Union[None, List["ValueFrequencyClass"]]) -> None:
        self._inner_dict['distinctValueFrequencies'] = value
    
    
    @property
    def sampleValues(self) -> Union[None, List[str]]:
        """N randomly sampled values of the column. Useful for showing rough preview of the column."""
        return self._inner_dict.get('sampleValues')  # type: ignore
    
    @sampleValues.setter
    def sampleValues(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['sampleValues'] = value
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def source(self) -> Union[None, "DatasetMetricsSourceDetailsClass"]:
        """Rich details about the source of the metrics provided in this profile."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "DatasetMetricsSourceDetailsClass"]) -> None:
        self._inner_dict['source'] = value
    
    
class UpstreamClass(DictWrapper):
    """Upstream lineage information about a dataset including the source reporting the lineage"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.Upstream")
    def __init__(self,
        dataset: str,
        type: Union[str, "DatasetLineageTypeClass"],
        auditStamp: Optional["AuditStampClass"]=None,
        created: Union[None, "AuditStampClass"]=None,
        properties: Union[None, Dict[str, str]]=None,
        query: Union[None, str]=None,
    ):
        super().__init__()
        
        if auditStamp is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.auditStamp = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["auditStamp"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["auditStamp"].type)
        else:
            self.auditStamp = auditStamp
        self.created = created
        self.dataset = dataset
        self.type = type
        self.properties = properties
        self.query = query
    
    def _restore_defaults(self) -> None:
        self.auditStamp = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["auditStamp"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["auditStamp"].type)
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.dataset = str()
        self.type = DatasetLineageTypeClass.COPY
        self.properties = self.RECORD_SCHEMA.fields_dict["properties"].default
        self.query = self.RECORD_SCHEMA.fields_dict["query"].default
    
    
    @property
    def auditStamp(self) -> "AuditStampClass":
        """Audit stamp containing who reported the lineage and when."""
        return self._inner_dict.get('auditStamp')  # type: ignore
    
    @auditStamp.setter
    def auditStamp(self, value: "AuditStampClass") -> None:
        self._inner_dict['auditStamp'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp containing who created the lineage and when."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def dataset(self) -> str:
        """The upstream dataset the lineage points to"""
        return self._inner_dict.get('dataset')  # type: ignore
    
    @dataset.setter
    def dataset(self, value: str) -> None:
        self._inner_dict['dataset'] = value
    
    
    @property
    def type(self) -> Union[str, "DatasetLineageTypeClass"]:
        """The type of the lineage"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DatasetLineageTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def properties(self) -> Union[None, Dict[str, str]]:
        """A generic properties bag that allows us to store specific information on this graph edge."""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['properties'] = value
    
    
    @property
    def query(self) -> Union[None, str]:
        """If the lineage is generated by a query, a reference to the query"""
        return self._inner_dict.get('query')  # type: ignore
    
    @query.setter
    def query(self, value: Union[None, str]) -> None:
        self._inner_dict['query'] = value
    
    
class UpstreamLineageClass(_Aspect):
    """Upstream lineage of a dataset"""


    ASPECT_NAME = 'upstreamLineage'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.UpstreamLineage")

    def __init__(self,
        upstreams: List["UpstreamClass"],
        fineGrainedLineages: Union[None, List["FineGrainedLineageClass"]]=None,
    ):
        super().__init__()
        
        self.upstreams = upstreams
        self.fineGrainedLineages = fineGrainedLineages
    
    def _restore_defaults(self) -> None:
        self.upstreams = list()
        self.fineGrainedLineages = self.RECORD_SCHEMA.fields_dict["fineGrainedLineages"].default
    
    
    @property
    def upstreams(self) -> List["UpstreamClass"]:
        """List of upstream dataset lineage information"""
        return self._inner_dict.get('upstreams')  # type: ignore
    
    @upstreams.setter
    def upstreams(self, value: List["UpstreamClass"]) -> None:
        self._inner_dict['upstreams'] = value
    
    
    @property
    def fineGrainedLineages(self) -> Union[None, List["FineGrainedLineageClass"]]:
        """ List of fine-grained lineage information, including field-level lineage"""
        return self._inner_dict.get('fineGrainedLineages')  # type: ignore
    
    @fineGrainedLineages.setter
    def fineGrainedLineages(self, value: Union[None, List["FineGrainedLineageClass"]]) -> None:
        self._inner_dict['fineGrainedLineages'] = value
    
    
class ValueFrequencyClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.ValueFrequency")
    def __init__(self,
        value: str,
        frequency: int,
    ):
        super().__init__()
        
        self.value = value
        self.frequency = frequency
    
    def _restore_defaults(self) -> None:
        self.value = str()
        self.frequency = int()
    
    
    @property
    def value(self) -> str:
        # No docs available.
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: str) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def frequency(self) -> int:
        # No docs available.
        return self._inner_dict.get('frequency')  # type: ignore
    
    @frequency.setter
    def frequency(self, value: int) -> None:
        self._inner_dict['frequency'] = value
    
    
class ViewPropertiesClass(_Aspect):
    """Details about a View. 
    e.g. Gets activated when subTypes is view"""


    ASPECT_NAME = 'viewProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.dataset.ViewProperties")

    def __init__(self,
        materialized: bool,
        viewLogic: str,
        viewLanguage: str,
        formattedViewLogic: Union[None, str]=None,
    ):
        super().__init__()
        
        self.materialized = materialized
        self.viewLogic = viewLogic
        self.formattedViewLogic = formattedViewLogic
        self.viewLanguage = viewLanguage
    
    def _restore_defaults(self) -> None:
        self.materialized = bool()
        self.viewLogic = str()
        self.formattedViewLogic = self.RECORD_SCHEMA.fields_dict["formattedViewLogic"].default
        self.viewLanguage = str()
    
    
    @property
    def materialized(self) -> bool:
        """Whether the view is materialized"""
        return self._inner_dict.get('materialized')  # type: ignore
    
    @materialized.setter
    def materialized(self, value: bool) -> None:
        self._inner_dict['materialized'] = value
    
    
    @property
    def viewLogic(self) -> str:
        """The view logic"""
        return self._inner_dict.get('viewLogic')  # type: ignore
    
    @viewLogic.setter
    def viewLogic(self, value: str) -> None:
        self._inner_dict['viewLogic'] = value
    
    
    @property
    def formattedViewLogic(self) -> Union[None, str]:
        """The formatted view logic. This is particularly used for SQL sources, where the SQL
    logic is formatted for better readability, and with dbt, where this contains the
    compiled SQL logic."""
        return self._inner_dict.get('formattedViewLogic')  # type: ignore
    
    @formattedViewLogic.setter
    def formattedViewLogic(self, value: Union[None, str]) -> None:
        self._inner_dict['formattedViewLogic'] = value
    
    
    @property
    def viewLanguage(self) -> str:
        """The view logic language / dialect"""
        return self._inner_dict.get('viewLanguage')  # type: ignore
    
    @viewLanguage.setter
    def viewLanguage(self, value: str) -> None:
        self._inner_dict['viewLanguage'] = value
    
    
class DataTypeInfoClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'dataTypeInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datatype.DataTypeInfo")

    def __init__(self,
        qualifiedName: str,
        displayName: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.qualifiedName = qualifiedName
        self.displayName = displayName
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.qualifiedName = str()
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def qualifiedName(self) -> str:
        """The qualified name for the data type. Usually a unique namespace + name, e.g. datahub.string"""
        return self._inner_dict.get('qualifiedName')  # type: ignore
    
    @qualifiedName.setter
    def qualifiedName(self, value: str) -> None:
        self._inner_dict['qualifiedName'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """An optional display name for the data type."""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """An optional description for the data type."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class DataTypeKeyClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'dataTypeKey'
    ASPECT_INFO = {'keyForEntity': 'dataType', 'entityCategory': 'core', 'entityAspects': ['dataTypeInfo', 'institutionalMemory', 'status'], 'entityDoc': 'A type of data element stored within DataHub.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.datatype.DataTypeKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for a data type. Usually this will be a unique namespace + data type name."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DomainPropertiesClass(_Aspect):
    """Information about a Domain"""


    ASPECT_NAME = 'domainProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.domain.DomainProperties")

    def __init__(self,
        name: str,
        customProperties: Optional[Dict[str, str]]=None,
        description: Union[None, str]=None,
        created: Union[None, "AuditStampClass"]=None,
        parentDomain: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.name = name
        self.description = description
        self.created = created
        self.parentDomain = parentDomain
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.parentDomain = self.RECORD_SCHEMA.fields_dict["parentDomain"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def name(self) -> str:
        """Display name of the Domain"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the Domain"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def parentDomain(self) -> Union[None, str]:
        """Optional: Parent of the domain"""
        return self._inner_dict.get('parentDomain')  # type: ignore
    
    @parentDomain.setter
    def parentDomain(self, value: Union[None, str]) -> None:
        self._inner_dict['parentDomain'] = value
    
    
class DomainsClass(_Aspect):
    """Links from an Asset to its Domains"""


    ASPECT_NAME = 'domains'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.domain.Domains")

    def __init__(self,
        domains: List[str],
    ):
        super().__init__()
        
        self.domains = domains
    
    def _restore_defaults(self) -> None:
        self.domains = list()
    
    
    @property
    def domains(self) -> List[str]:
        """The Domains attached to an Asset"""
        return self._inner_dict.get('domains')  # type: ignore
    
    @domains.setter
    def domains(self, value: List[str]) -> None:
        self._inner_dict['domains'] = value
    
    
class EntityTypeInfoClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'entityTypeInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.entitytype.EntityTypeInfo")

    def __init__(self,
        qualifiedName: str,
        displayName: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.qualifiedName = qualifiedName
        self.displayName = displayName
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.qualifiedName = str()
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def qualifiedName(self) -> str:
        """The fully qualified name for the entity type, which usually consists of a namespace
    plus an identifier or name, e.g. datahub.dataset"""
        return self._inner_dict.get('qualifiedName')  # type: ignore
    
    @qualifiedName.setter
    def qualifiedName(self, value: str) -> None:
        self._inner_dict['qualifiedName'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """The display name for the Entity Type."""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """A description for the Entity Type: what is it for?"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class EntityTypeKeyClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'entityTypeKey'
    ASPECT_INFO = {'keyForEntity': 'entityType', 'entityCategory': 'core', 'entityAspects': ['entityTypeInfo', 'institutionalMemory', 'status'], 'entityDoc': 'A type of entity in the DataHub Metadata Model.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.entitytype.EntityTypeKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for an entity type. Usually this will be a unique namespace + entity name."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class ERModelRelationshipCardinalityClass(object):
    # No docs available.
    
    ONE_ONE = "ONE_ONE"
    ONE_N = "ONE_N"
    N_ONE = "N_ONE"
    N_N = "N_N"
    
    
class ERModelRelationshipPropertiesClass(_Aspect):
    """Properties associated with a ERModelRelationship"""


    ASPECT_NAME = 'erModelRelationshipProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ermodelrelation.ERModelRelationshipProperties")

    def __init__(self,
        name: str,
        source: str,
        destination: str,
        relationshipFieldMappings: List["RelationshipFieldMappingClass"],
        customProperties: Optional[Dict[str, str]]=None,
        created: Union[None, "AuditStampClass"]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
        cardinality: Optional[Union[str, "ERModelRelationshipCardinalityClass"]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.name = name
        self.source = source
        self.destination = destination
        self.relationshipFieldMappings = relationshipFieldMappings
        self.created = created
        self.lastModified = lastModified
        if cardinality is None:
            # default: 'N_N'
            self.cardinality = self.RECORD_SCHEMA.fields_dict["cardinality"].default
        else:
            self.cardinality = cardinality
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.name = str()
        self.source = str()
        self.destination = str()
        self.relationshipFieldMappings = list()
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.cardinality = self.RECORD_SCHEMA.fields_dict["cardinality"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def name(self) -> str:
        """Name of the ERModelRelation"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def source(self) -> str:
        """First dataset in the erModelRelationship (no directionality)"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: str) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def destination(self) -> str:
        """Second dataset in the erModelRelationship (no directionality)"""
        return self._inner_dict.get('destination')  # type: ignore
    
    @destination.setter
    def destination(self, value: str) -> None:
        self._inner_dict['destination'] = value
    
    
    @property
    def relationshipFieldMappings(self) -> List["RelationshipFieldMappingClass"]:
        """ERModelRelationFieldMapping (in future we can make it an array)"""
        return self._inner_dict.get('relationshipFieldMappings')  # type: ignore
    
    @relationshipFieldMappings.setter
    def relationshipFieldMappings(self, value: List["RelationshipFieldMappingClass"]) -> None:
        self._inner_dict['relationshipFieldMappings'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """A timestamp documenting when the asset was created in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """A timestamp documenting when the asset was last modified in the source Data Platform (not on DataHub)"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def cardinality(self) -> Union[str, "ERModelRelationshipCardinalityClass"]:
        """Cardinality of the relationship"""
        return self._inner_dict.get('cardinality')  # type: ignore
    
    @cardinality.setter
    def cardinality(self, value: Union[str, "ERModelRelationshipCardinalityClass"]) -> None:
        self._inner_dict['cardinality'] = value
    
    
class EditableERModelRelationshipPropertiesClass(_Aspect):
    """EditableERModelRelationProperties stores editable changes made to erModelRelationship properties. This separates changes made from
    ingestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines"""


    ASPECT_NAME = 'editableERModelRelationshipProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ermodelrelation.EditableERModelRelationshipProperties")

    def __init__(self,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        description: Union[None, str]=None,
        name: Union[None, str]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.description = description
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the erModelRelationship"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the ERModelRelation"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
class RelationshipFieldMappingClass(DictWrapper):
    """Individual Field Mapping of a relationship- one of several"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ermodelrelation.RelationshipFieldMapping")
    def __init__(self,
        sourceField: str,
        destinationField: str,
    ):
        super().__init__()
        
        self.sourceField = sourceField
        self.destinationField = destinationField
    
    def _restore_defaults(self) -> None:
        self.sourceField = str()
        self.destinationField = str()
    
    
    @property
    def sourceField(self) -> str:
        """All fields from dataset A that are required for the join, maps to bFields 1:1"""
        return self._inner_dict.get('sourceField')  # type: ignore
    
    @sourceField.setter
    def sourceField(self, value: str) -> None:
        self._inner_dict['sourceField'] = value
    
    
    @property
    def destinationField(self) -> str:
        """All fields from dataset B that are required for the join, maps to aFields 1:1"""
        return self._inner_dict.get('destinationField')  # type: ignore
    
    @destinationField.setter
    def destinationField(self, value: str) -> None:
        self._inner_dict['destinationField'] = value
    
    
class NotificationContextClass(DictWrapper):
    """Additional context about the notification."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.NotificationContext")
    def __init__(self,
        runId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.runId = runId
    
    def _restore_defaults(self) -> None:
        self.runId = self.RECORD_SCHEMA.fields_dict["runId"].default
    
    
    @property
    def runId(self) -> Union[None, str]:
        """The run-id that triggered the notification. If it was triggered by a manual action,
    this may be set to the default "no-run-id-provided" value."""
        return self._inner_dict.get('runId')  # type: ignore
    
    @runId.setter
    def runId(self, value: Union[None, str]) -> None:
        self._inner_dict['runId'] = value
    
    
class NotificationMessageClass(DictWrapper):
    """A message to send via notification."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.NotificationMessage")
    def __init__(self,
        template: Union[str, "NotificationTemplateTypeClass"],
        parameters: Union[None, Dict[str, str]]=None,
        ownershipParameters: Union[None, "OwnershipParametersClass"]=None,
    ):
        super().__init__()
        
        self.template = template
        self.parameters = parameters
        self.ownershipParameters = ownershipParameters
    
    def _restore_defaults(self) -> None:
        self.template = NotificationTemplateTypeClass.OWNERSHIP_CHANGE
        self.parameters = self.RECORD_SCHEMA.fields_dict["parameters"].default
        self.ownershipParameters = self.RECORD_SCHEMA.fields_dict["ownershipParameters"].default
    
    
    @property
    def template(self) -> Union[str, "NotificationTemplateTypeClass"]:
        """The name of a notification template to use, e.g. INCIDENT_CREATED, INCIDENT_STATUS_UPDATED, CUSTOM.
    Each sink may support a different set of template types."""
        return self._inner_dict.get('template')  # type: ignore
    
    @template.setter
    def template(self, value: Union[str, "NotificationTemplateTypeClass"]) -> None:
        self._inner_dict['template'] = value
    
    
    @property
    def parameters(self) -> Union[None, Dict[str, str]]:
        """Parameters serving as input to the template, validated and substituted based on the selected template."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['parameters'] = value
    
    
    @property
    def ownershipParameters(self) -> Union[None, "OwnershipParametersClass"]:
        """Input parameters for ownership notification template. Only filled when templateType is OWNERSHIP_CHANGE."""
        return self._inner_dict.get('ownershipParameters')  # type: ignore
    
    @ownershipParameters.setter
    def ownershipParameters(self, value: Union[None, "OwnershipParametersClass"]) -> None:
        self._inner_dict['ownershipParameters'] = value
    
    
class NotificationRecipientClass(DictWrapper):
    """The targeted recipient of a notification, either a specific User or a specific channel."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.NotificationRecipient")
    def __init__(self,
        type: Union[str, "NotificationRecipientTypeClass"],
        customType: Union[None, str]=None,
        id: Union[None, str]=None,
        origin: Union[None, Union[str, "NotificationRecipientOriginTypeClass"]]=None,
        actor: Union[None, str]=None,
        displayName: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.customType = customType
        self.id = id
        self.origin = origin
        self.actor = actor
        self.displayName = displayName
    
    def _restore_defaults(self) -> None:
        self.type = NotificationRecipientTypeClass.EMAIL
        self.customType = self.RECORD_SCHEMA.fields_dict["customType"].default
        self.id = self.RECORD_SCHEMA.fields_dict["id"].default
        self.origin = self.RECORD_SCHEMA.fields_dict["origin"].default
        self.actor = self.RECORD_SCHEMA.fields_dict["actor"].default
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
    
    
    @property
    def type(self) -> Union[str, "NotificationRecipientTypeClass"]:
        """The type of a notification recipient, e.g. the channel type."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "NotificationRecipientTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def customType(self) -> Union[None, str]:
        """A custom notification recipient type. Required if recipient type is CUSTOM."""
        return self._inner_dict.get('customType')  # type: ignore
    
    @customType.setter
    def customType(self, value: Union[None, str]) -> None:
        self._inner_dict['customType'] = value
    
    
    @property
    def id(self) -> Union[None, str]:
        """A unique channel / target id that the sink can pick up.
    For slack sink, this will contain the channel or user id to send to.
    For email sink, this will contain the email address to send to."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: Union[None, str]) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def origin(self) -> Union[None, Union[str, "NotificationRecipientOriginTypeClass"]]:
        """The origin of the recipient notification, for tracking."""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: Union[None, Union[str, "NotificationRecipientOriginTypeClass"]]) -> None:
        self._inner_dict['origin'] = value
    
    
    @property
    def actor(self) -> Union[None, str]:
        """The URN of the actor associated with the recipient (personal or subscription related notifications)."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: Union[None, str]) -> None:
        self._inner_dict['actor'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """An optional display name to use when addressing the recipient. Available only for subscription or personal notifications."""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
class NotificationRecipientOriginTypeClass(object):
    # No docs available.
    
    SUBSCRIPTION = "SUBSCRIPTION"
    """The notification originated from a subscription."""
    
    GLOBAL_NOTIFICATION = "GLOBAL_NOTIFICATION"
    """The notification originated from a global change."""
    
    ACTOR_NOTIFICATION = "ACTOR_NOTIFICATION"
    """The notification originated from an actor-oriented default notification.
    For example, proposal task or ownership assignment notifications."""
    
    
    
class NotificationRecipientTypeClass(object):
    """A type of target (recipient) channel for a notification. Typically a single recipient
    maps to a single sink type. Each sink can support one or more recipient types.
    
    Each type of Notification Sink exposes the recipient types that they support sinking to. This
    is used by the notification manager to filter out recipients that are not supported by a given sink."""
    
    EMAIL = "EMAIL"
    """A specific email address to send a notification to."""
    
    SLACK_CHANNEL = "SLACK_CHANNEL"
    """A slack channel to send a notification to."""
    
    SLACK_DM = "SLACK_DM"
    """A slack member to send a notification to."""
    
    TEAMS_CHANNEL = "TEAMS_CHANNEL"
    """A Microsoft Teams channel to send a notification to."""
    
    TEAMS_DM = "TEAMS_DM"
    """A Microsoft Teams member to send a notification to."""
    
    CUSTOM = "CUSTOM"
    """A custom target, e.g. a slack channel or dm, that a specific sink can handle. Sinks are expected to handle custom
    types appropriately."""
    
    USER = "USER"
    """Deprecated! A DataHub user (via urn.). Currently this is NOT USED and may be removed in future versions.
    Recipient type should correspond to the sink type, and the sink should understand how to handle the recipient type appropriately.
    Instead, typically notifications have specific recipients as Slack handles, slack channels, or email addresses."""
    
    
    
class NotificationRequestClass(DictWrapper):
    """A request to send a notification."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.NotificationRequest")
    def __init__(self,
        message: "NotificationMessageClass",
        recipients: List["NotificationRecipientClass"],
        sinks: Union[None, List["NotificationSinkClass"]]=None,
        context: Union[None, "NotificationContextClass"]=None,
    ):
        super().__init__()
        
        self.message = message
        self.recipients = recipients
        self.sinks = sinks
        self.context = context
    
    def _restore_defaults(self) -> None:
        self.message = NotificationMessageClass._construct_with_defaults()
        self.recipients = list()
        self.sinks = self.RECORD_SCHEMA.fields_dict["sinks"].default
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
    
    
    @property
    def message(self) -> "NotificationMessageClass":
        """A message to send."""
        return self._inner_dict.get('message')  # type: ignore
    
    @message.setter
    def message(self, value: "NotificationMessageClass") -> None:
        self._inner_dict['message'] = value
    
    
    @property
    def recipients(self) -> List["NotificationRecipientClass"]:
        """The target (receiver) of the notification, in DataHub Terms."""
        return self._inner_dict.get('recipients')  # type: ignore
    
    @recipients.setter
    def recipients(self, value: List["NotificationRecipientClass"]) -> None:
        self._inner_dict['recipients'] = value
    
    
    @property
    def sinks(self) -> Union[None, List["NotificationSinkClass"]]:
        """Optional: A specific sink / set of sinks to send to. If not specified, all enabled sinks
    will be attemped and will be expected to handle the notification if they are able to send
    to a given recipient type."""
        return self._inner_dict.get('sinks')  # type: ignore
    
    @sinks.setter
    def sinks(self, value: Union[None, List["NotificationSinkClass"]]) -> None:
        self._inner_dict['sinks'] = value
    
    
    @property
    def context(self) -> Union[None, "NotificationContextClass"]:
        """Additional context about the notification."""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, "NotificationContextClass"]) -> None:
        self._inner_dict['context'] = value
    
    
class NotificationSinkClass(DictWrapper):
    """Information about the sink of a notification, e.g. HOW the notification is sent."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.NotificationSink")
    def __init__(self,
        type: Union[str, "NotificationSinkTypeClass"],
    ):
        super().__init__()
        
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.type = NotificationSinkTypeClass.SLACK
    
    
    @property
    def type(self) -> Union[str, "NotificationSinkTypeClass"]:
        """The type of the sink."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "NotificationSinkTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class NotificationSinkTypeClass(object):
    """A type of sink / platform to send a notification to."""
    
    SLACK = "SLACK"
    """Slack target type."""
    
    EMAIL = "EMAIL"
    """Email target type."""
    
    TEAMS = "TEAMS"
    """Microsoft Teams target type."""
    
    
    
class EmailNotificationSettingsClass(DictWrapper):
    """Email Notification settings for an actor."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.settings.EmailNotificationSettings")
    def __init__(self,
        email: str,
    ):
        super().__init__()
        
        self.email = email
    
    def _restore_defaults(self) -> None:
        self.email = str()
    
    
    @property
    def email(self) -> str:
        """Optional user or group email address"""
        return self._inner_dict.get('email')  # type: ignore
    
    @email.setter
    def email(self, value: str) -> None:
        self._inner_dict['email'] = value
    
    
class NotificationSettingsClass(DictWrapper):
    """Notification settings for an actor or subscription."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.settings.NotificationSettings")
    def __init__(self,
        sinkTypes: List[Union[str, "NotificationSinkTypeClass"]],
        slackSettings: Union[None, "SlackNotificationSettingsClass"]=None,
        emailSettings: Union[None, "EmailNotificationSettingsClass"]=None,
        teamsSettings: Union[None, "TeamsNotificationSettingsClass"]=None,
        settings: Union[None, Dict[str, "NotificationSettingClass"]]=None,
    ):
        super().__init__()
        
        self.sinkTypes = sinkTypes
        self.slackSettings = slackSettings
        self.emailSettings = emailSettings
        self.teamsSettings = teamsSettings
        self.settings = settings
    
    def _restore_defaults(self) -> None:
        self.sinkTypes = list()
        self.slackSettings = self.RECORD_SCHEMA.fields_dict["slackSettings"].default
        self.emailSettings = self.RECORD_SCHEMA.fields_dict["emailSettings"].default
        self.teamsSettings = self.RECORD_SCHEMA.fields_dict["teamsSettings"].default
        self.settings = self.RECORD_SCHEMA.fields_dict["settings"].default
    
    
    @property
    def sinkTypes(self) -> List[Union[str, "NotificationSinkTypeClass"]]:
        """Sink types that notifications are sent to. This is a top-level on/off switch."""
        return self._inner_dict.get('sinkTypes')  # type: ignore
    
    @sinkTypes.setter
    def sinkTypes(self, value: List[Union[str, "NotificationSinkTypeClass"]]) -> None:
        self._inner_dict['sinkTypes'] = value
    
    
    @property
    def slackSettings(self) -> Union[None, "SlackNotificationSettingsClass"]:
        """Slack Notification Settings"""
        return self._inner_dict.get('slackSettings')  # type: ignore
    
    @slackSettings.setter
    def slackSettings(self, value: Union[None, "SlackNotificationSettingsClass"]) -> None:
        self._inner_dict['slackSettings'] = value
    
    
    @property
    def emailSettings(self) -> Union[None, "EmailNotificationSettingsClass"]:
        """Email Notification Settings"""
        return self._inner_dict.get('emailSettings')  # type: ignore
    
    @emailSettings.setter
    def emailSettings(self, value: Union[None, "EmailNotificationSettingsClass"]) -> None:
        self._inner_dict['emailSettings'] = value
    
    
    @property
    def teamsSettings(self) -> Union[None, "TeamsNotificationSettingsClass"]:
        """Microsoft Teams Notification Settings"""
        return self._inner_dict.get('teamsSettings')  # type: ignore
    
    @teamsSettings.setter
    def teamsSettings(self, value: Union[None, "TeamsNotificationSettingsClass"]) -> None:
        self._inner_dict['teamsSettings'] = value
    
    
    @property
    def settings(self) -> Union[None, Dict[str, "NotificationSettingClass"]]:
        """User or Group Notification Scenario Settings.
    
    A map of notification scenario type to the settings associated with it.
    For a list of all scenario types to notify on, check out NotificationScenarioType enum."""
        return self._inner_dict.get('settings')  # type: ignore
    
    @settings.setter
    def settings(self, value: Union[None, Dict[str, "NotificationSettingClass"]]) -> None:
        self._inner_dict['settings'] = value
    
    
class SlackNotificationSettingsClass(DictWrapper):
    """Slack Notification settings for an actor."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.settings.SlackNotificationSettings")
    def __init__(self,
        userHandle: Union[None, str]=None,
        channels: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.userHandle = userHandle
        self.channels = channels
    
    def _restore_defaults(self) -> None:
        self.userHandle = self.RECORD_SCHEMA.fields_dict["userHandle"].default
        self.channels = self.RECORD_SCHEMA.fields_dict["channels"].default
    
    
    @property
    def userHandle(self) -> Union[None, str]:
        """Optional user handle"""
        return self._inner_dict.get('userHandle')  # type: ignore
    
    @userHandle.setter
    def userHandle(self, value: Union[None, str]) -> None:
        self._inner_dict['userHandle'] = value
    
    
    @property
    def channels(self) -> Union[None, List[str]]:
        """Optional list of channels to send notifications to"""
        return self._inner_dict.get('channels')  # type: ignore
    
    @channels.setter
    def channels(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['channels'] = value
    
    
class TeamsNotificationSettingsClass(DictWrapper):
    """Microsoft Teams Notification settings for an actor."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.settings.TeamsNotificationSettings")
    def __init__(self,
        user: Union[None, "TeamsUserClass"]=None,
        channels: Union[None, List["TeamsChannelClass"]]=None,
    ):
        super().__init__()
        
        self.user = user
        self.channels = channels
    
    def _restore_defaults(self) -> None:
        self.user = self.RECORD_SCHEMA.fields_dict["user"].default
        self.channels = self.RECORD_SCHEMA.fields_dict["channels"].default
    
    
    @property
    def user(self) -> Union[None, "TeamsUserClass"]:
        """Optional structured user information with cached metadata.
    Supports both Azure AD user ID and Teams user ID with cached display name."""
        return self._inner_dict.get('user')  # type: ignore
    
    @user.setter
    def user(self, value: Union[None, "TeamsUserClass"]) -> None:
        self._inner_dict['user'] = value
    
    
    @property
    def channels(self) -> Union[None, List["TeamsChannelClass"]]:
        """Optional list of structured channels with cached metadata"""
        return self._inner_dict.get('channels')  # type: ignore
    
    @channels.setter
    def channels(self, value: Union[None, List["TeamsChannelClass"]]) -> None:
        self._inner_dict['channels'] = value
    
    
class NotificationTemplateTypeClass(object):
    """Possible notification template types."""
    
    OWNERSHIP_CHANGE = "OWNERSHIP_CHANGE"
    """Ownership change notification template."""
    
    BROADCAST_ASSERTION_STATUS_CHANGE = "BROADCAST_ASSERTION_STATUS_CHANGE"
    """Assertion change notification template."""
    
    INVITATION = "INVITATION"
    """User invitation notification template."""
    
    CUSTOM = "CUSTOM"
    """Legacy template types to support backwards compatibility."""
    
    BROADCAST_NEW_INCIDENT = "BROADCAST_NEW_INCIDENT"
    
    BROADCAST_NEW_INCIDENT_UPDATE = "BROADCAST_NEW_INCIDENT_UPDATE"
    """Updates the broadcasted incident if possible."""
    
    BROADCAST_INCIDENT_STATUS_CHANGE = "BROADCAST_INCIDENT_STATUS_CHANGE"
    
    BROADCAST_ENTITY_CHANGE = "BROADCAST_ENTITY_CHANGE"
    
    BROADCAST_INGESTION_RUN_CHANGE = "BROADCAST_INGESTION_RUN_CHANGE"
    
    BROADCAST_NEW_PROPOSAL = "BROADCAST_NEW_PROPOSAL"
    
    BROADCAST_PROPOSAL_STATUS_CHANGE = "BROADCAST_PROPOSAL_STATUS_CHANGE"
    
    BROADCAST_COMPLIANCE_FORM_PUBLISH = "BROADCAST_COMPLIANCE_FORM_PUBLISH"
    
    BROADCAST_NEW_ACTION_WORKFLOW_FORM_REQUEST = "BROADCAST_NEW_ACTION_WORKFLOW_FORM_REQUEST"
    """Broadcast that a new action workflow form request has been created or needs review."""
    
    BROADCAST_ACTION_WORKFLOW_FORM_REQUEST_STATUS_CHANGE = "BROADCAST_ACTION_WORKFLOW_FORM_REQUEST_STATUS_CHANGE"
    """Broadcast that an action workflow form request has been completed (approved or denied)."""
    
    RELEASE_NOTIFICATION = "RELEASE_NOTIFICATION"
    """Release notification template for announcing new releases."""
    
    SUPPORT_LOGIN = "SUPPORT_LOGIN"
    """Support login notification template."""
    
    INVALID_TEMPLATE = "INVALID_TEMPLATE"
    
    
    
class OwnershipParametersClass(DictWrapper):
    """A message to send via notification."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.event.notification.template.OwnershipParameters")
    def __init__(self,
        ownersAdded: Union[None, List["OwnerClass"]]=None,
        ownersRemoved: Union[None, List["OwnerClass"]]=None,
    ):
        super().__init__()
        
        self.ownersAdded = ownersAdded
        self.ownersRemoved = ownersRemoved
    
    def _restore_defaults(self) -> None:
        self.ownersAdded = self.RECORD_SCHEMA.fields_dict["ownersAdded"].default
        self.ownersRemoved = self.RECORD_SCHEMA.fields_dict["ownersRemoved"].default
    
    
    @property
    def ownersAdded(self) -> Union[None, List["OwnerClass"]]:
        """The owners that were added."""
        return self._inner_dict.get('ownersAdded')  # type: ignore
    
    @ownersAdded.setter
    def ownersAdded(self, value: Union[None, List["OwnerClass"]]) -> None:
        self._inner_dict['ownersAdded'] = value
    
    
    @property
    def ownersRemoved(self) -> Union[None, List["OwnerClass"]]:
        """The owners that were removed."""
        return self._inner_dict.get('ownersRemoved')  # type: ignore
    
    @ownersRemoved.setter
    def ownersRemoved(self, value: Union[None, List["OwnerClass"]]) -> None:
        self._inner_dict['ownersRemoved'] = value
    
    
class ChangeTypeClass(object):
    """Descriptor for a change action"""
    
    UPSERT = "UPSERT"
    """insert if not exists. otherwise update"""
    
    CREATE = "CREATE"
    """insert if not exists. otherwise fail"""
    
    UPDATE = "UPDATE"
    """NOT SUPPORTED YET
    update if exists. otherwise fail"""
    
    DELETE = "DELETE"
    """delete action"""
    
    PATCH = "PATCH"
    """patch the changes instead of full replace"""
    
    RESTATE = "RESTATE"
    """Restate an aspect, eg. in a index refresh."""
    
    CREATE_ENTITY = "CREATE_ENTITY"
    """insert if entity not exists. otherwise fail"""
    
    
    
class ExecutionRequestArtifactsLocationClass(_Aspect):
    """The result location of an execution request"""


    ASPECT_NAME = 'dataHubExecutionRequestArtifactsLocation'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.execution.ExecutionRequestArtifactsLocation")

    def __init__(self,
        location: str,
    ):
        super().__init__()
        
        self.location = location
    
    def _restore_defaults(self) -> None:
        self.location = str()
    
    
    @property
    def location(self) -> str:
        """The location where artifacts are present"""
        return self._inner_dict.get('location')  # type: ignore
    
    @location.setter
    def location(self, value: str) -> None:
        self._inner_dict['location'] = value
    
    
class ExecutionRequestInputClass(_Aspect):
    """An request to execution some remote logic or action.
    TODO: Determine who is responsible for emitting execution request success or failure. Executor?"""


    ASPECT_NAME = 'dataHubExecutionRequestInput'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.execution.ExecutionRequestInput")

    def __init__(self,
        task: str,
        args: Dict[str, str],
        executorId: str,
        source: "ExecutionRequestSourceClass",
        requestedAt: int,
        actorUrn: Union[None, str]=None,
        attempts: Union[None, int]=None,
    ):
        super().__init__()
        
        self.task = task
        self.args = args
        self.executorId = executorId
        self.source = source
        self.requestedAt = requestedAt
        self.actorUrn = actorUrn
        self.attempts = attempts
    
    def _restore_defaults(self) -> None:
        self.task = str()
        self.args = dict()
        self.executorId = str()
        self.source = ExecutionRequestSourceClass._construct_with_defaults()
        self.requestedAt = int()
        self.actorUrn = self.RECORD_SCHEMA.fields_dict["actorUrn"].default
        self.attempts = self.RECORD_SCHEMA.fields_dict["attempts"].default
    
    
    @property
    def task(self) -> str:
        """The name of the task to execute, for example RUN_INGEST"""
        return self._inner_dict.get('task')  # type: ignore
    
    @task.setter
    def task(self, value: str) -> None:
        self._inner_dict['task'] = value
    
    
    @property
    def args(self) -> Dict[str, str]:
        """Arguments provided to the task"""
        return self._inner_dict.get('args')  # type: ignore
    
    @args.setter
    def args(self, value: Dict[str, str]) -> None:
        self._inner_dict['args'] = value
    
    
    @property
    def executorId(self) -> str:
        """Advanced: specify a specific executor pool to route the request to. If none is provided, a "default" embedded executor is used."""
        return self._inner_dict.get('executorId')  # type: ignore
    
    @executorId.setter
    def executorId(self, value: str) -> None:
        self._inner_dict['executorId'] = value
    
    
    @property
    def source(self) -> "ExecutionRequestSourceClass":
        """Source which created the execution request"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: "ExecutionRequestSourceClass") -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def requestedAt(self) -> int:
        """Time at which the execution request input was created"""
        return self._inner_dict.get('requestedAt')  # type: ignore
    
    @requestedAt.setter
    def requestedAt(self, value: int) -> None:
        self._inner_dict['requestedAt'] = value
    
    
    @property
    def actorUrn(self) -> Union[None, str]:
        """Urn of the actor who created this execution request."""
        return self._inner_dict.get('actorUrn')  # type: ignore
    
    @actorUrn.setter
    def actorUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['actorUrn'] = value
    
    
    @property
    def attempts(self) -> Union[None, int]:
        """Field tracking number of previously unsuccessful attempts for the given execution request"""
        return self._inner_dict.get('attempts')  # type: ignore
    
    @attempts.setter
    def attempts(self, value: Union[None, int]) -> None:
        self._inner_dict['attempts'] = value
    
    
class ExecutionRequestResultClass(_Aspect):
    """The result of an execution request"""


    ASPECT_NAME = 'dataHubExecutionRequestResult'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.execution.ExecutionRequestResult")

    def __init__(self,
        status: str,
        executorInstanceId: Union[None, str]=None,
        report: Union[None, str]=None,
        structuredReport: Union[None, "StructuredExecutionReportClass"]=None,
        startTimeMs: Union[None, int]=None,
        durationMs: Union[None, int]=None,
    ):
        super().__init__()
        
        self.status = status
        self.executorInstanceId = executorInstanceId
        self.report = report
        self.structuredReport = structuredReport
        self.startTimeMs = startTimeMs
        self.durationMs = durationMs
    
    def _restore_defaults(self) -> None:
        self.status = str()
        self.executorInstanceId = self.RECORD_SCHEMA.fields_dict["executorInstanceId"].default
        self.report = self.RECORD_SCHEMA.fields_dict["report"].default
        self.structuredReport = self.RECORD_SCHEMA.fields_dict["structuredReport"].default
        self.startTimeMs = self.RECORD_SCHEMA.fields_dict["startTimeMs"].default
        self.durationMs = self.RECORD_SCHEMA.fields_dict["durationMs"].default
    
    
    @property
    def status(self) -> str:
        """The status of the execution request"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: str) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def executorInstanceId(self) -> Union[None, str]:
        """Identity of the executor instance handling the request"""
        return self._inner_dict.get('executorInstanceId')  # type: ignore
    
    @executorInstanceId.setter
    def executorInstanceId(self, value: Union[None, str]) -> None:
        self._inner_dict['executorInstanceId'] = value
    
    
    @property
    def report(self) -> Union[None, str]:
        """The pretty-printed execution report."""
        return self._inner_dict.get('report')  # type: ignore
    
    @report.setter
    def report(self, value: Union[None, str]) -> None:
        self._inner_dict['report'] = value
    
    
    @property
    def structuredReport(self) -> Union[None, "StructuredExecutionReportClass"]:
        """A structured report if available."""
        return self._inner_dict.get('structuredReport')  # type: ignore
    
    @structuredReport.setter
    def structuredReport(self, value: Union[None, "StructuredExecutionReportClass"]) -> None:
        self._inner_dict['structuredReport'] = value
    
    
    @property
    def startTimeMs(self) -> Union[None, int]:
        """Time at which the request was created"""
        return self._inner_dict.get('startTimeMs')  # type: ignore
    
    @startTimeMs.setter
    def startTimeMs(self, value: Union[None, int]) -> None:
        self._inner_dict['startTimeMs'] = value
    
    
    @property
    def durationMs(self) -> Union[None, int]:
        """Duration in milliseconds"""
        return self._inner_dict.get('durationMs')  # type: ignore
    
    @durationMs.setter
    def durationMs(self, value: Union[None, int]) -> None:
        self._inner_dict['durationMs'] = value
    
    
class ExecutionRequestSignalClass(_Aspect):
    """An signal sent to a running execution request"""


    ASPECT_NAME = 'dataHubExecutionRequestSignal'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.execution.ExecutionRequestSignal")

    def __init__(self,
        signal: str,
        createdAt: "AuditStampClass",
        executorId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.signal = signal
        self.executorId = executorId
        self.createdAt = createdAt
    
    def _restore_defaults(self) -> None:
        self.signal = str()
        self.executorId = self.RECORD_SCHEMA.fields_dict["executorId"].default
        self.createdAt = AuditStampClass._construct_with_defaults()
    
    
    @property
    def signal(self) -> str:
        """The signal to issue, e.g. KILL"""
        return self._inner_dict.get('signal')  # type: ignore
    
    @signal.setter
    def signal(self, value: str) -> None:
        self._inner_dict['signal'] = value
    
    
    @property
    def executorId(self) -> Union[None, str]:
        """Advanced: specify a specific executor pool to route the request to. If none is provided, a default embedded executor is used."""
        return self._inner_dict.get('executorId')  # type: ignore
    
    @executorId.setter
    def executorId(self, value: Union[None, str]) -> None:
        self._inner_dict['executorId'] = value
    
    
    @property
    def createdAt(self) -> "AuditStampClass":
        """Audit Stamp"""
        return self._inner_dict.get('createdAt')  # type: ignore
    
    @createdAt.setter
    def createdAt(self, value: "AuditStampClass") -> None:
        self._inner_dict['createdAt'] = value
    
    
class ExecutionRequestSourceClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.execution.ExecutionRequestSource")
    def __init__(self,
        type: str,
        ingestionSource: Union[None, str]=None,
        connection: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.ingestionSource = ingestionSource
        self.connection = connection
    
    def _restore_defaults(self) -> None:
        self.type = str()
        self.ingestionSource = self.RECORD_SCHEMA.fields_dict["ingestionSource"].default
        self.connection = self.RECORD_SCHEMA.fields_dict["connection"].default
    
    
    @property
    def type(self) -> str:
        """The type of the execution request source, e.g. INGESTION_SOURCE"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def ingestionSource(self) -> Union[None, str]:
        """The urn of the ingestion source associated with the ingestion request. Present if type is INGESTION_SOURCE"""
        return self._inner_dict.get('ingestionSource')  # type: ignore
    
    @ingestionSource.setter
    def ingestionSource(self, value: Union[None, str]) -> None:
        self._inner_dict['ingestionSource'] = value
    
    
    @property
    def connection(self) -> Union[None, str]:
        """The urn of the connection source associated with the connection request. Present if type is CONNECTION"""
        return self._inner_dict.get('connection')  # type: ignore
    
    @connection.setter
    def connection(self, value: Union[None, str]) -> None:
        self._inner_dict['connection'] = value
    
    
class StructuredExecutionReportClass(DictWrapper):
    """A flexible carrier for structured results of an execution request.
    The goal is to allow for free flow of structured responses from execution tasks to the orchestrator or observer.
    The full spectrum of different execution report types is not intended to be modeled by this object."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.execution.StructuredExecutionReport")
    def __init__(self,
        type: str,
        serializedValue: str,
        contentType: str,
    ):
        super().__init__()
        
        self.type = type
        self.serializedValue = serializedValue
        self.contentType = contentType
    
    def _restore_defaults(self) -> None:
        self.type = str()
        self.serializedValue = str()
        self.contentType = str()
    
    
    @property
    def type(self) -> str:
        """The type of the structured report. (e.g. INGESTION_REPORT, TEST_CONNECTION_REPORT, etc.)"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def serializedValue(self) -> str:
        """The serialized value of the structured report"""
        return self._inner_dict.get('serializedValue')  # type: ignore
    
    @serializedValue.setter
    def serializedValue(self, value: str) -> None:
        self._inner_dict['serializedValue'] = value
    
    
    @property
    def contentType(self) -> str:
        """The content-type of the serialized value (e.g. application/json, application/json;gzip etc.)"""
        return self._inner_dict.get('contentType')  # type: ignore
    
    @contentType.setter
    def contentType(self, value: str) -> None:
        self._inner_dict['contentType'] = value
    
    
class RemoteExecutorStatusClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'dataHubRemoteExecutorStatus'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.executor.RemoteExecutorStatus")

    def __init__(self,
        executorPoolId: str,
        executorReleaseVersion: str,
        executorAddress: str,
        executorHostname: str,
        executorUptime: float,
        reportedAt: int,
        executorExpired: Optional[bool]=None,
        executorStopped: Optional[bool]=None,
        executorEmbedded: Optional[bool]=None,
        executorInternal: Optional[bool]=None,
        logDeliveryEnabled: Optional[bool]=None,
    ):
        super().__init__()
        
        self.executorPoolId = executorPoolId
        self.executorReleaseVersion = executorReleaseVersion
        self.executorAddress = executorAddress
        self.executorHostname = executorHostname
        self.executorUptime = executorUptime
        if executorExpired is None:
            # default: False
            self.executorExpired = self.RECORD_SCHEMA.fields_dict["executorExpired"].default
        else:
            self.executorExpired = executorExpired
        if executorStopped is None:
            # default: False
            self.executorStopped = self.RECORD_SCHEMA.fields_dict["executorStopped"].default
        else:
            self.executorStopped = executorStopped
        if executorEmbedded is None:
            # default: False
            self.executorEmbedded = self.RECORD_SCHEMA.fields_dict["executorEmbedded"].default
        else:
            self.executorEmbedded = executorEmbedded
        if executorInternal is None:
            # default: False
            self.executorInternal = self.RECORD_SCHEMA.fields_dict["executorInternal"].default
        else:
            self.executorInternal = executorInternal
        if logDeliveryEnabled is None:
            # default: False
            self.logDeliveryEnabled = self.RECORD_SCHEMA.fields_dict["logDeliveryEnabled"].default
        else:
            self.logDeliveryEnabled = logDeliveryEnabled
        self.reportedAt = reportedAt
    
    def _restore_defaults(self) -> None:
        self.executorPoolId = str()
        self.executorReleaseVersion = str()
        self.executorAddress = str()
        self.executorHostname = str()
        self.executorUptime = float()
        self.executorExpired = self.RECORD_SCHEMA.fields_dict["executorExpired"].default
        self.executorStopped = self.RECORD_SCHEMA.fields_dict["executorStopped"].default
        self.executorEmbedded = self.RECORD_SCHEMA.fields_dict["executorEmbedded"].default
        self.executorInternal = self.RECORD_SCHEMA.fields_dict["executorInternal"].default
        self.logDeliveryEnabled = self.RECORD_SCHEMA.fields_dict["logDeliveryEnabled"].default
        self.reportedAt = int()
    
    
    @property
    def executorPoolId(self) -> str:
        """References the 'id' defined in RemoteExecutorPoolKey"""
        return self._inner_dict.get('executorPoolId')  # type: ignore
    
    @executorPoolId.setter
    def executorPoolId(self, value: str) -> None:
        self._inner_dict['executorPoolId'] = value
    
    
    @property
    def executorReleaseVersion(self) -> str:
        """ Release Version (Tag) embedded into remote executor image"""
        return self._inner_dict.get('executorReleaseVersion')  # type: ignore
    
    @executorReleaseVersion.setter
    def executorReleaseVersion(self, value: str) -> None:
        self._inner_dict['executorReleaseVersion'] = value
    
    
    @property
    def executorAddress(self) -> str:
        """ IP address of the host where remote executor is running"""
        return self._inner_dict.get('executorAddress')  # type: ignore
    
    @executorAddress.setter
    def executorAddress(self, value: str) -> None:
        self._inner_dict['executorAddress'] = value
    
    
    @property
    def executorHostname(self) -> str:
        """Hostname of the host where remote executor is running"""
        return self._inner_dict.get('executorHostname')  # type: ignore
    
    @executorHostname.setter
    def executorHostname(self, value: str) -> None:
        self._inner_dict['executorHostname'] = value
    
    
    @property
    def executorUptime(self) -> float:
        """Uptime of the remote executor master process"""
        return self._inner_dict.get('executorUptime')  # type: ignore
    
    @executorUptime.setter
    def executorUptime(self, value: float) -> None:
        self._inner_dict['executorUptime'] = value
    
    
    @property
    def executorExpired(self) -> bool:
        """Flag indicating whether remote executor status record is stale.
    This means executor no longer sends heartbeats and considered dead."""
        return self._inner_dict.get('executorExpired')  # type: ignore
    
    @executorExpired.setter
    def executorExpired(self, value: bool) -> None:
        self._inner_dict['executorExpired'] = value
    
    
    @property
    def executorStopped(self) -> bool:
        """Flag indicating whether remote executor is stopped, and properly reported its termination."""
        return self._inner_dict.get('executorStopped')  # type: ignore
    
    @executorStopped.setter
    def executorStopped(self, value: bool) -> None:
        self._inner_dict['executorStopped'] = value
    
    
    @property
    def executorEmbedded(self) -> bool:
        """Flag indicating whether remote executor is embedded into the coordinator pod"""
        return self._inner_dict.get('executorEmbedded')  # type: ignore
    
    @executorEmbedded.setter
    def executorEmbedded(self, value: bool) -> None:
        self._inner_dict['executorEmbedded'] = value
    
    
    @property
    def executorInternal(self) -> bool:
        """Flag indicating whether remote executor is Acryl managed executor"""
        return self._inner_dict.get('executorInternal')  # type: ignore
    
    @executorInternal.setter
    def executorInternal(self, value: bool) -> None:
        self._inner_dict['executorInternal'] = value
    
    
    @property
    def logDeliveryEnabled(self) -> bool:
        """Flag indicating whether log delivery is enabled by the customer in the given
    remote executor instance."""
        return self._inner_dict.get('logDeliveryEnabled')  # type: ignore
    
    @logDeliveryEnabled.setter
    def logDeliveryEnabled(self, value: bool) -> None:
        self._inner_dict['logDeliveryEnabled'] = value
    
    
    @property
    def reportedAt(self) -> int:
        """UTC-based timestamp of the last reported status"""
        return self._inner_dict.get('reportedAt')  # type: ignore
    
    @reportedAt.setter
    def reportedAt(self, value: int) -> None:
        self._inner_dict['reportedAt'] = value
    
    
class RemoteExecutorPoolGlobalConfigClass(_Aspect):
    """Global singleton storing configs for remote executor pools."""


    ASPECT_NAME = 'dataHubRemoteExecutorPoolGlobalConfig'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.executorglobalconfig.RemoteExecutorPoolGlobalConfig")

    def __init__(self,
        defaultExecutorPoolId: str,
    ):
        super().__init__()
        
        self.defaultExecutorPoolId = defaultExecutorPoolId
    
    def _restore_defaults(self) -> None:
        self.defaultExecutorPoolId = str()
    
    
    @property
    def defaultExecutorPoolId(self) -> str:
        """The default pool to use for tasks that require remote executors.
    References 'id' in com.linkedin.pegasus2avro.metadata.key.RemoteExecutorPoolKey"""
        return self._inner_dict.get('defaultExecutorPoolId')  # type: ignore
    
    @defaultExecutorPoolId.setter
    def defaultExecutorPoolId(self, value: str) -> None:
        self._inner_dict['defaultExecutorPoolId'] = value
    
    
class RemoteExecutorPoolInfoClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'dataHubRemoteExecutorPoolInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.executorpool.RemoteExecutorPoolInfo")

    def __init__(self,
        createdAt: int,
        creator: Union[None, str]=None,
        description: Union[None, str]=None,
        queueUrl: Union[None, str]=None,
        queueRegion: Union[None, str]=None,
        isEmbedded: Union[None, bool]=None,
        state: Union[None, "RemoteExecutorPoolStateClass"]=None,
    ):
        super().__init__()
        
        self.createdAt = createdAt
        self.creator = creator
        self.description = description
        self.queueUrl = queueUrl
        self.queueRegion = queueRegion
        self.isEmbedded = isEmbedded
        self.state = state
    
    def _restore_defaults(self) -> None:
        self.createdAt = int()
        self.creator = self.RECORD_SCHEMA.fields_dict["creator"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.queueUrl = self.RECORD_SCHEMA.fields_dict["queueUrl"].default
        self.queueRegion = self.RECORD_SCHEMA.fields_dict["queueRegion"].default
        self.isEmbedded = self.RECORD_SCHEMA.fields_dict["isEmbedded"].default
        self.state = self.RECORD_SCHEMA.fields_dict["state"].default
    
    
    @property
    def createdAt(self) -> int:
        """UTC-based timestamp of when this pool was created"""
        return self._inner_dict.get('createdAt')  # type: ignore
    
    @createdAt.setter
    def createdAt(self, value: int) -> None:
        self._inner_dict['createdAt'] = value
    
    
    @property
    def creator(self) -> Union[None, str]:
        """The creator of this pool"""
        return self._inner_dict.get('creator')  # type: ignore
    
    @creator.setter
    def creator(self, value: Union[None, str]) -> None:
        self._inner_dict['creator'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """A description for this pool"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def queueUrl(self) -> Union[None, str]:
        """The url to the task queue for this pool. I.e., SQS queue url."""
        return self._inner_dict.get('queueUrl')  # type: ignore
    
    @queueUrl.setter
    def queueUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['queueUrl'] = value
    
    
    @property
    def queueRegion(self) -> Union[None, str]:
        """The region of the sqs queue for this pool for backwards compatibility."""
        return self._inner_dict.get('queueRegion')  # type: ignore
    
    @queueRegion.setter
    def queueRegion(self, value: Union[None, str]) -> None:
        self._inner_dict['queueRegion'] = value
    
    
    @property
    def isEmbedded(self) -> Union[None, bool]:
        """Only set true if this is the pool embedded within the DataHub Cloud deployment"""
        return self._inner_dict.get('isEmbedded')  # type: ignore
    
    @isEmbedded.setter
    def isEmbedded(self, value: Union[None, bool]) -> None:
        self._inner_dict['isEmbedded'] = value
    
    
    @property
    def state(self) -> Union[None, "RemoteExecutorPoolStateClass"]:
        """The status of the remote executor pool"""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[None, "RemoteExecutorPoolStateClass"]) -> None:
        self._inner_dict['state'] = value
    
    
class RemoteExecutorPoolStateClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.executorpool.RemoteExecutorPoolState")
    def __init__(self,
        status: Union[str, "RemoteExecutorPoolStatusClass"],
        message: Union[None, str]=None,
    ):
        super().__init__()
        
        self.status = status
        self.message = message
    
    def _restore_defaults(self) -> None:
        self.status = RemoteExecutorPoolStatusClass.PROVISIONING_PENDING
        self.message = self.RECORD_SCHEMA.fields_dict["message"].default
    
    
    @property
    def status(self) -> Union[str, "RemoteExecutorPoolStatusClass"]:
        """The status of the remote executor pool"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "RemoteExecutorPoolStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def message(self) -> Union[None, str]:
        """The message associated with the status. I.e., an error message explaining failure."""
        return self._inner_dict.get('message')  # type: ignore
    
    @message.setter
    def message(self, value: Union[None, str]) -> None:
        self._inner_dict['message'] = value
    
    
class RemoteExecutorPoolStatusClass(object):
    # No docs available.
    
    PROVISIONING_PENDING = "PROVISIONING_PENDING"
    """The pool is pending provisioning. Default state on creation."""
    
    PROVISIONING_IN_PROGRESS = "PROVISIONING_IN_PROGRESS"
    """The pool has been picked up by DataHub and is in the process of being provisioned."""
    
    PROVISIONING_FAILED = "PROVISIONING_FAILED"
    """The pool has failed to be provisioned."""
    
    READY = "READY"
    """The pool has been successfully provisioned and is ready to accept tasks."""
    
    
    
class BucketStorageLocationClass(DictWrapper):
    """Information where a file is stored"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.file.BucketStorageLocation")
    def __init__(self,
        storageBucket: str,
        storageKey: str,
    ):
        super().__init__()
        
        self.storageBucket = storageBucket
        self.storageKey = storageKey
    
    def _restore_defaults(self) -> None:
        self.storageBucket = str()
        self.storageKey = str()
    
    
    @property
    def storageBucket(self) -> str:
        """The storage bucket this file is stored in"""
        return self._inner_dict.get('storageBucket')  # type: ignore
    
    @storageBucket.setter
    def storageBucket(self, value: str) -> None:
        self._inner_dict['storageBucket'] = value
    
    
    @property
    def storageKey(self) -> str:
        """The key for where this file is stored inside of the given bucket"""
        return self._inner_dict.get('storageKey')  # type: ignore
    
    @storageKey.setter
    def storageKey(self, value: str) -> None:
        self._inner_dict['storageKey'] = value
    
    
class DataHubFileInfoClass(_Aspect):
    """Information about a DataHub file - a file stored in S3 for use within DataHub platform features like documentation, home pages, and announcements."""


    ASPECT_NAME = 'dataHubFileInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.file.DataHubFileInfo")

    def __init__(self,
        bucketStorageLocation: "BucketStorageLocationClass",
        originalFileName: str,
        mimeType: str,
        sizeInBytes: int,
        scenario: Union[str, "FileUploadScenarioClass"],
        created: "AuditStampClass",
        referencedByAsset: Union[None, str]=None,
        schemaField: Union[None, str]=None,
        contentHash: Union[None, str]=None,
    ):
        super().__init__()
        
        self.bucketStorageLocation = bucketStorageLocation
        self.originalFileName = originalFileName
        self.mimeType = mimeType
        self.sizeInBytes = sizeInBytes
        self.scenario = scenario
        self.referencedByAsset = referencedByAsset
        self.schemaField = schemaField
        self.created = created
        self.contentHash = contentHash
    
    def _restore_defaults(self) -> None:
        self.bucketStorageLocation = BucketStorageLocationClass._construct_with_defaults()
        self.originalFileName = str()
        self.mimeType = str()
        self.sizeInBytes = int()
        self.scenario = FileUploadScenarioClass.ASSET_DOCUMENTATION
        self.referencedByAsset = self.RECORD_SCHEMA.fields_dict["referencedByAsset"].default
        self.schemaField = self.RECORD_SCHEMA.fields_dict["schemaField"].default
        self.created = AuditStampClass._construct_with_defaults()
        self.contentHash = self.RECORD_SCHEMA.fields_dict["contentHash"].default
    
    
    @property
    def bucketStorageLocation(self) -> "BucketStorageLocationClass":
        """Info about where a file is stored"""
        return self._inner_dict.get('bucketStorageLocation')  # type: ignore
    
    @bucketStorageLocation.setter
    def bucketStorageLocation(self, value: "BucketStorageLocationClass") -> None:
        self._inner_dict['bucketStorageLocation'] = value
    
    
    @property
    def originalFileName(self) -> str:
        """The original filename as uploaded by the user"""
        return self._inner_dict.get('originalFileName')  # type: ignore
    
    @originalFileName.setter
    def originalFileName(self, value: str) -> None:
        self._inner_dict['originalFileName'] = value
    
    
    @property
    def mimeType(self) -> str:
        """MIME type of the file (e.g., image/png, application/pdf)"""
        return self._inner_dict.get('mimeType')  # type: ignore
    
    @mimeType.setter
    def mimeType(self, value: str) -> None:
        self._inner_dict['mimeType'] = value
    
    
    @property
    def sizeInBytes(self) -> int:
        """Size of the file in bytes"""
        return self._inner_dict.get('sizeInBytes')  # type: ignore
    
    @sizeInBytes.setter
    def sizeInBytes(self, value: int) -> None:
        self._inner_dict['sizeInBytes'] = value
    
    
    @property
    def scenario(self) -> Union[str, "FileUploadScenarioClass"]:
        """The scenario/context in which this file was uploaded"""
        return self._inner_dict.get('scenario')  # type: ignore
    
    @scenario.setter
    def scenario(self, value: Union[str, "FileUploadScenarioClass"]) -> None:
        self._inner_dict['scenario'] = value
    
    
    @property
    def referencedByAsset(self) -> Union[None, str]:
        """Optional URN of the entity this file is associated with (e.g., the dataset whose docs contain this file)"""
        return self._inner_dict.get('referencedByAsset')  # type: ignore
    
    @referencedByAsset.setter
    def referencedByAsset(self, value: Union[None, str]) -> None:
        self._inner_dict['referencedByAsset'] = value
    
    
    @property
    def schemaField(self) -> Union[None, str]:
        """The dataset schema field urn this file is referenced by"""
        return self._inner_dict.get('schemaField')  # type: ignore
    
    @schemaField.setter
    def schemaField(self, value: Union[None, str]) -> None:
        self._inner_dict['schemaField'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Timestamp when this file was created and by whom"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def contentHash(self) -> Union[None, str]:
        """SHA-256 hash of file contents"""
        return self._inner_dict.get('contentHash')  # type: ignore
    
    @contentHash.setter
    def contentHash(self, value: Union[None, str]) -> None:
        self._inner_dict['contentHash'] = value
    
    
class FileUploadScenarioClass(object):
    # No docs available.
    
    ASSET_DOCUMENTATION = "ASSET_DOCUMENTATION"
    """File uploaded for entity documentation"""
    
    ASSET_DOCUMENTATION_LINKS = "ASSET_DOCUMENTATION_LINKS"
    """Upload for asset documentation links."""
    
    
    
class AssignmentStatusClass(object):
    # No docs available.
    
    IN_PROGRESS = "IN_PROGRESS"
    """Assets are currently being assigned"""
    
    COMPLETE = "COMPLETE"
    """Assets assignment is complete"""
    
    
    
class DomainParamsClass(DictWrapper):
    """Information specific to glossary terms prompts."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.DomainParams")
    def __init__(self,
        allowedDomains: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.allowedDomains = allowedDomains
    
    def _restore_defaults(self) -> None:
        self.allowedDomains = self.RECORD_SCHEMA.fields_dict["allowedDomains"].default
    
    
    @property
    def allowedDomains(self) -> Union[None, List[str]]:
        """An optional list of allowed domains to choose from"""
        return self._inner_dict.get('allowedDomains')  # type: ignore
    
    @allowedDomains.setter
    def allowedDomains(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['allowedDomains'] = value
    
    
class DynamicFormAssignmentClass(_Aspect):
    """Information about how a form is assigned to entities dynamically. Provide a filter to
    match a set of entities instead of explicitly applying a form to specific entities."""


    ASPECT_NAME = 'dynamicFormAssignment'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.DynamicFormAssignment")

    def __init__(self,
        filter: "FilterClass",
        json: Union[None, str]=None,
    ):
        super().__init__()
        
        self.filter = filter
        self.json = json
    
    def _restore_defaults(self) -> None:
        self.filter = FilterClass._construct_with_defaults()
        self.json = self.RECORD_SCHEMA.fields_dict["json"].default
    
    
    @property
    def filter(self) -> "FilterClass":
        """The filter applied when assigning this form to entities. Entities that match this filter
    will have this form applied to them. Right now this filter only supports filtering by
    platform, entity type, container, and domain through the UI."""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: "FilterClass") -> None:
        self._inner_dict['filter'] = value
    
    
    @property
    def json(self) -> Union[None, str]:
        """The stringified json representing the logical predicate built in the UI to select assets.
    This predicate is turned into orFilters to send through graphql since graphql doesn't support
    arbitrary nesting. This string is used to restore the UI for this logical predicate."""
        return self._inner_dict.get('json')  # type: ignore
    
    @json.setter
    def json(self, value: Union[None, str]) -> None:
        self._inner_dict['json'] = value
    
    
class FormActorAssignmentClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.FormActorAssignment")
    def __init__(self,
        owners: Optional[bool]=None,
        groups: Union[None, List[str]]=None,
        users: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        if owners is None:
            # default: True
            self.owners = self.RECORD_SCHEMA.fields_dict["owners"].default
        else:
            self.owners = owners
        self.groups = groups
        self.users = users
    
    def _restore_defaults(self) -> None:
        self.owners = self.RECORD_SCHEMA.fields_dict["owners"].default
        self.groups = self.RECORD_SCHEMA.fields_dict["groups"].default
        self.users = self.RECORD_SCHEMA.fields_dict["users"].default
    
    
    @property
    def owners(self) -> bool:
        """Whether the form should be assigned to the owners of assets that it is applied to.
    This is the default."""
        return self._inner_dict.get('owners')  # type: ignore
    
    @owners.setter
    def owners(self, value: bool) -> None:
        self._inner_dict['owners'] = value
    
    
    @property
    def groups(self) -> Union[None, List[str]]:
        """Optional: Specific set of groups that are targeted by this form assignment."""
        return self._inner_dict.get('groups')  # type: ignore
    
    @groups.setter
    def groups(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['groups'] = value
    
    
    @property
    def users(self) -> Union[None, List[str]]:
        """Optional: Specific set of users that are targeted by this form assignment."""
        return self._inner_dict.get('users')  # type: ignore
    
    @users.setter
    def users(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['users'] = value
    
    
class FormAssignmentStatusClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'formAssignmentStatus'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.FormAssignmentStatus")

    def __init__(self,
        status: Union[str, "AssignmentStatusClass"],
        timestamp: Union[None, int]=None,
    ):
        super().__init__()
        
        self.status = status
        self.timestamp = timestamp
    
    def _restore_defaults(self) -> None:
        self.status = AssignmentStatusClass.IN_PROGRESS
        self.timestamp = self.RECORD_SCHEMA.fields_dict["timestamp"].default
    
    
    @property
    def status(self) -> Union[str, "AssignmentStatusClass"]:
        """Notification settings for a form"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "AssignmentStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def timestamp(self) -> Union[None, int]:
        """Timestamp this aspect was last updated at"""
        return self._inner_dict.get('timestamp')  # type: ignore
    
    @timestamp.setter
    def timestamp(self, value: Union[None, int]) -> None:
        self._inner_dict['timestamp'] = value
    
    
class FormInfoClass(_Aspect):
    """Information about a form to help with filling out metadata on entities."""


    ASPECT_NAME = 'formInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.FormInfo")

    def __init__(self,
        name: str,
        description: Union[None, str]=None,
        type: Optional[Union[str, "FormTypeClass"]]=None,
        prompts: Optional[List["FormPromptClass"]]=None,
        actors: Optional["FormActorAssignmentClass"]=None,
        status: Optional["FormStatusClass"]=None,
        created: Union[None, "AuditStampClass"]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.name = name
        self.description = description
        if type is None:
            # default: 'COMPLETION'
            self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        else:
            self.type = type
        if prompts is None:
            # default: []
            self.prompts = list()
        else:
            self.prompts = prompts
        if actors is None:
            # default: {'groups': None, 'owners': True, 'users': None}
            self.actors = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["actors"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["actors"].type)
        else:
            self.actors = actors
        if status is None:
            # default: {'state': 'PUBLISHED', 'lastModified': None}
            self.status = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["status"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["status"].type)
        else:
            self.status = status
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        self.prompts = list()
        self.actors = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["actors"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["actors"].type)
        self.status = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["status"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["status"].type)
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
    
    
    @property
    def name(self) -> str:
        """Display name of the form"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the form"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def type(self) -> Union[str, "FormTypeClass"]:
        """The type of this form"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "FormTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def prompts(self) -> List["FormPromptClass"]:
        """List of prompts to present to the user to encourage filling out metadata"""
        return self._inner_dict.get('prompts')  # type: ignore
    
    @prompts.setter
    def prompts(self, value: List["FormPromptClass"]) -> None:
        self._inner_dict['prompts'] = value
    
    
    @property
    def actors(self) -> "FormActorAssignmentClass":
        """Who the form is assigned to, e.g. who should see the form when visiting the entity page or governance center"""
        return self._inner_dict.get('actors')  # type: ignore
    
    @actors.setter
    def actors(self, value: "FormActorAssignmentClass") -> None:
        self._inner_dict['actors'] = value
    
    
    @property
    def status(self) -> "FormStatusClass":
        """Information about the state and status of this form"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: "FormStatusClass") -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """Last Modified Audit stamp"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
class FormNotificationSettingsClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.FormNotificationSettings")
    def __init__(self,
        notifyAssigneesOnPublish: Optional[bool]=None,
    ):
        super().__init__()
        
        if notifyAssigneesOnPublish is None:
            # default: False
            self.notifyAssigneesOnPublish = self.RECORD_SCHEMA.fields_dict["notifyAssigneesOnPublish"].default
        else:
            self.notifyAssigneesOnPublish = notifyAssigneesOnPublish
    
    def _restore_defaults(self) -> None:
        self.notifyAssigneesOnPublish = self.RECORD_SCHEMA.fields_dict["notifyAssigneesOnPublish"].default
    
    
    @property
    def notifyAssigneesOnPublish(self) -> bool:
        """Whether to notify the assignees of the form when it is published."""
        return self._inner_dict.get('notifyAssigneesOnPublish')  # type: ignore
    
    @notifyAssigneesOnPublish.setter
    def notifyAssigneesOnPublish(self, value: bool) -> None:
        self._inner_dict['notifyAssigneesOnPublish'] = value
    
    
class FormPromptClass(DictWrapper):
    """A prompt to present to the user to encourage filling out metadata"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.FormPrompt")
    def __init__(self,
        id: str,
        title: str,
        type: Union[str, "FormPromptTypeClass"],
        description: Union[None, str]=None,
        structuredPropertyParams: Union[None, "StructuredPropertyParamsClass"]=None,
        ownershipParams: Union[None, "OwnershipParamsClass"]=None,
        glossaryTermsParams: Union[None, "GlossaryTermsParamsClass"]=None,
        domainParams: Union[None, "DomainParamsClass"]=None,
        required: Optional[bool]=None,
    ):
        super().__init__()
        
        self.id = id
        self.title = title
        self.description = description
        self.type = type
        self.structuredPropertyParams = structuredPropertyParams
        self.ownershipParams = ownershipParams
        self.glossaryTermsParams = glossaryTermsParams
        self.domainParams = domainParams
        if required is None:
            # default: False
            self.required = self.RECORD_SCHEMA.fields_dict["required"].default
        else:
            self.required = required
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.title = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.type = FormPromptTypeClass.STRUCTURED_PROPERTY
        self.structuredPropertyParams = self.RECORD_SCHEMA.fields_dict["structuredPropertyParams"].default
        self.ownershipParams = self.RECORD_SCHEMA.fields_dict["ownershipParams"].default
        self.glossaryTermsParams = self.RECORD_SCHEMA.fields_dict["glossaryTermsParams"].default
        self.domainParams = self.RECORD_SCHEMA.fields_dict["domainParams"].default
        self.required = self.RECORD_SCHEMA.fields_dict["required"].default
    
    
    @property
    def id(self) -> str:
        """The unique id for this prompt. This must be GLOBALLY unique."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def title(self) -> str:
        """The title of this prompt"""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: str) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """The description of this prompt"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def type(self) -> Union[str, "FormPromptTypeClass"]:
        """The type of prompt"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "FormPromptTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def structuredPropertyParams(self) -> Union[None, "StructuredPropertyParamsClass"]:
        """An optional set of information specific to structured properties prompts.
    This should be filled out if the prompt is type STRUCTURED_PROPERTY or FIELDS_STRUCTURED_PROPERTY."""
        return self._inner_dict.get('structuredPropertyParams')  # type: ignore
    
    @structuredPropertyParams.setter
    def structuredPropertyParams(self, value: Union[None, "StructuredPropertyParamsClass"]) -> None:
        self._inner_dict['structuredPropertyParams'] = value
    
    
    @property
    def ownershipParams(self) -> Union[None, "OwnershipParamsClass"]:
        """An optional set of information specific to ownership prompts.
    This should be filled out if the prompt is type OWNERSHIP."""
        return self._inner_dict.get('ownershipParams')  # type: ignore
    
    @ownershipParams.setter
    def ownershipParams(self, value: Union[None, "OwnershipParamsClass"]) -> None:
        self._inner_dict['ownershipParams'] = value
    
    
    @property
    def glossaryTermsParams(self) -> Union[None, "GlossaryTermsParamsClass"]:
        """An optional set of information specific to glossary terms prompts.
    This should be filled out if the prompt is type GLOSSARY_TERMS or FIELDS_GLOSSARY_TERM."""
        return self._inner_dict.get('glossaryTermsParams')  # type: ignore
    
    @glossaryTermsParams.setter
    def glossaryTermsParams(self, value: Union[None, "GlossaryTermsParamsClass"]) -> None:
        self._inner_dict['glossaryTermsParams'] = value
    
    
    @property
    def domainParams(self) -> Union[None, "DomainParamsClass"]:
        """An optional set of information specific to domain prompts.
    This should be filled out if the prompt is type DOMAIN."""
        return self._inner_dict.get('domainParams')  # type: ignore
    
    @domainParams.setter
    def domainParams(self, value: Union[None, "DomainParamsClass"]) -> None:
        self._inner_dict['domainParams'] = value
    
    
    @property
    def required(self) -> bool:
        """Whether the prompt is required to be completed, in order for the form to be marked as complete."""
        return self._inner_dict.get('required')  # type: ignore
    
    @required.setter
    def required(self, value: bool) -> None:
        self._inner_dict['required'] = value
    
    
class FormPromptTypeClass(object):
    # No docs available.
    
    STRUCTURED_PROPERTY = "STRUCTURED_PROPERTY"
    """This prompt is meant to apply a structured property to an entity"""
    
    FIELDS_STRUCTURED_PROPERTY = "FIELDS_STRUCTURED_PROPERTY"
    """This prompt is meant to apply a structured property to a schema field entity"""
    
    OWNERSHIP = "OWNERSHIP"
    """This prompt is meant to apply ownership to an entity"""
    
    DOCUMENTATION = "DOCUMENTATION"
    """This prompt is meant to apply documentation to an entity"""
    
    FIELDS_DOCUMENTATION = "FIELDS_DOCUMENTATION"
    """This prompt is meant to apply documentation to a schema field entity"""
    
    GLOSSARY_TERMS = "GLOSSARY_TERMS"
    """This prompt is meant to apply glossary terms to an entity"""
    
    FIELDS_GLOSSARY_TERMS = "FIELDS_GLOSSARY_TERMS"
    """This prompt is meant to apply glossary terms to a schema field entity"""
    
    DOMAIN = "DOMAIN"
    """This prompt is meant to apply a domain to an entity"""
    
    
    
class FormSettingsClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'formSettings'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.FormSettings")

    def __init__(self,
        notificationSettings: "FormNotificationSettingsClass",
    ):
        super().__init__()
        
        self.notificationSettings = notificationSettings
    
    def _restore_defaults(self) -> None:
        self.notificationSettings = FormNotificationSettingsClass._construct_with_defaults()
    
    
    @property
    def notificationSettings(self) -> "FormNotificationSettingsClass":
        """Notification settings for a form"""
        return self._inner_dict.get('notificationSettings')  # type: ignore
    
    @notificationSettings.setter
    def notificationSettings(self, value: "FormNotificationSettingsClass") -> None:
        self._inner_dict['notificationSettings'] = value
    
    
class FormStateClass(object):
    # No docs available.
    
    DRAFT = "DRAFT"
    """This form is in draft state and is not viewable by any users"""
    
    PUBLISHED = "PUBLISHED"
    """This form is published and viewable by users to fill it out"""
    
    UNPUBLISHED = "UNPUBLISHED"
    """This form is unpublished and is not viewable by users"""
    
    
    
class FormStatusClass(DictWrapper):
    """Information about the state of a form"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.FormStatus")
    def __init__(self,
        state: Union[str, "FormStateClass"],
        lastModified: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.state = state
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.state = FormStateClass.DRAFT
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
    
    
    @property
    def state(self) -> Union[str, "FormStateClass"]:
        """The state of this form. Draft means no users are prompted to fill it out yet and unpublished is hidden.
    Published forms are out in the world for users to see. Setting default to PUBLISHED for old data."""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[str, "FormStateClass"]) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp containing who last modified the form state and when."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
class FormTypeClass(object):
    # No docs available.
    
    COMPLETION = "COMPLETION"
    """A form simply used for collecting metadata fields for an entity."""
    
    VERIFICATION = "VERIFICATION"
    """This form is used for "verifying" that entities comply with a policy via presence of a specific set of metadata fields."""
    
    
    
class GlossaryTermsParamsClass(DictWrapper):
    """Information specific to glossary terms prompts."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.GlossaryTermsParams")
    def __init__(self,
        cardinality: Optional[Union[str, "PromptCardinalityClass"]]=None,
        allowedTerms: Union[None, List[str]]=None,
        allowedTermGroups: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        if cardinality is None:
            # default: 'MULTIPLE'
            self.cardinality = self.RECORD_SCHEMA.fields_dict["cardinality"].default
        else:
            self.cardinality = cardinality
        self.allowedTerms = allowedTerms
        self.allowedTermGroups = allowedTermGroups
    
    def _restore_defaults(self) -> None:
        self.cardinality = self.RECORD_SCHEMA.fields_dict["cardinality"].default
        self.allowedTerms = self.RECORD_SCHEMA.fields_dict["allowedTerms"].default
        self.allowedTermGroups = self.RECORD_SCHEMA.fields_dict["allowedTermGroups"].default
    
    
    @property
    def cardinality(self) -> Union[str, "PromptCardinalityClass"]:
        """Whether one or multiple terms are accepted as a response."""
        return self._inner_dict.get('cardinality')  # type: ignore
    
    @cardinality.setter
    def cardinality(self, value: Union[str, "PromptCardinalityClass"]) -> None:
        self._inner_dict['cardinality'] = value
    
    
    @property
    def allowedTerms(self) -> Union[None, List[str]]:
        """An optional list of allowed glossary terms to choose from"""
        return self._inner_dict.get('allowedTerms')  # type: ignore
    
    @allowedTerms.setter
    def allowedTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['allowedTerms'] = value
    
    
    @property
    def allowedTermGroups(self) -> Union[None, List[str]]:
        """An optional list of glossary term groups where a selection set of terms are underneath.
    Right now this is not recursive. Provided a term group, we will display its direct children as options."""
        return self._inner_dict.get('allowedTermGroups')  # type: ignore
    
    @allowedTermGroups.setter
    def allowedTermGroups(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['allowedTermGroups'] = value
    
    
class OwnershipParamsClass(DictWrapper):
    """Information specific to glossary terms prompts."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.OwnershipParams")
    def __init__(self,
        cardinality: Optional[Union[str, "PromptCardinalityClass"]]=None,
        allowedOwners: Union[None, List[str]]=None,
        allowedOwnershipTypes: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        if cardinality is None:
            # default: 'MULTIPLE'
            self.cardinality = self.RECORD_SCHEMA.fields_dict["cardinality"].default
        else:
            self.cardinality = cardinality
        self.allowedOwners = allowedOwners
        self.allowedOwnershipTypes = allowedOwnershipTypes
    
    def _restore_defaults(self) -> None:
        self.cardinality = self.RECORD_SCHEMA.fields_dict["cardinality"].default
        self.allowedOwners = self.RECORD_SCHEMA.fields_dict["allowedOwners"].default
        self.allowedOwnershipTypes = self.RECORD_SCHEMA.fields_dict["allowedOwnershipTypes"].default
    
    
    @property
    def cardinality(self) -> Union[str, "PromptCardinalityClass"]:
        """Whether one or multiple owners are accepted as a response."""
        return self._inner_dict.get('cardinality')  # type: ignore
    
    @cardinality.setter
    def cardinality(self, value: Union[str, "PromptCardinalityClass"]) -> None:
        self._inner_dict['cardinality'] = value
    
    
    @property
    def allowedOwners(self) -> Union[None, List[str]]:
        """An optional list of allowed owners to choose from"""
        return self._inner_dict.get('allowedOwners')  # type: ignore
    
    @allowedOwners.setter
    def allowedOwners(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['allowedOwners'] = value
    
    
    @property
    def allowedOwnershipTypes(self) -> Union[None, List[str]]:
        """An optional list of ownership type urns to choose from. If this is empty, all types will be allowed.
    If only one type is provided, the user will be required to set that type when responding."""
        return self._inner_dict.get('allowedOwnershipTypes')  # type: ignore
    
    @allowedOwnershipTypes.setter
    def allowedOwnershipTypes(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['allowedOwnershipTypes'] = value
    
    
class PromptCardinalityClass(object):
    """The cardinality of the prompt."""
    
    SINGLE = "SINGLE"
    """The prompt accepts a singular value as a response"""
    
    MULTIPLE = "MULTIPLE"
    """The prompt accepts multiple values as a response"""
    
    
    
class StructuredPropertyParamsClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.form.StructuredPropertyParams")
    def __init__(self,
        urn: str,
    ):
        super().__init__()
        
        self.urn = urn
    
    def _restore_defaults(self) -> None:
        self.urn = str()
    
    
    @property
    def urn(self) -> str:
        """The structured property that is required on this entity"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
class GlossaryNodeInfoClass(_Aspect):
    """Properties associated with a GlossaryNode"""


    ASPECT_NAME = 'glossaryNodeInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.glossary.GlossaryNodeInfo")

    def __init__(self,
        definition: str,
        customProperties: Optional[Dict[str, str]]=None,
        parentNode: Union[None, str]=None,
        name: Union[None, str]=None,
        id: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.definition = definition
        self.parentNode = parentNode
        self.name = name
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.definition = str()
        self.parentNode = self.RECORD_SCHEMA.fields_dict["parentNode"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.id = self.RECORD_SCHEMA.fields_dict["id"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def definition(self) -> str:
        """Definition of business node"""
        return self._inner_dict.get('definition')  # type: ignore
    
    @definition.setter
    def definition(self, value: str) -> None:
        self._inner_dict['definition'] = value
    
    
    @property
    def parentNode(self) -> Union[None, str]:
        """Parent node of the glossary term"""
        return self._inner_dict.get('parentNode')  # type: ignore
    
    @parentNode.setter
    def parentNode(self, value: Union[None, str]) -> None:
        self._inner_dict['parentNode'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the node"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def id(self) -> Union[None, str]:
        """Optional id for the GlossaryNode"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: Union[None, str]) -> None:
        self._inner_dict['id'] = value
    
    
class GlossaryRelatedTermsClass(_Aspect):
    """Has A / Is A lineage information about a glossary Term reporting the lineage"""


    ASPECT_NAME = 'glossaryRelatedTerms'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.glossary.GlossaryRelatedTerms")

    def __init__(self,
        isRelatedTerms: Union[None, List[str]]=None,
        hasRelatedTerms: Union[None, List[str]]=None,
        values: Union[None, List[str]]=None,
        relatedTerms: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.isRelatedTerms = isRelatedTerms
        self.hasRelatedTerms = hasRelatedTerms
        self.values = values
        self.relatedTerms = relatedTerms
    
    def _restore_defaults(self) -> None:
        self.isRelatedTerms = self.RECORD_SCHEMA.fields_dict["isRelatedTerms"].default
        self.hasRelatedTerms = self.RECORD_SCHEMA.fields_dict["hasRelatedTerms"].default
        self.values = self.RECORD_SCHEMA.fields_dict["values"].default
        self.relatedTerms = self.RECORD_SCHEMA.fields_dict["relatedTerms"].default
    
    
    @property
    def isRelatedTerms(self) -> Union[None, List[str]]:
        """The relationship Is A with glossary term"""
        return self._inner_dict.get('isRelatedTerms')  # type: ignore
    
    @isRelatedTerms.setter
    def isRelatedTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['isRelatedTerms'] = value
    
    
    @property
    def hasRelatedTerms(self) -> Union[None, List[str]]:
        """The relationship Has A with glossary term"""
        return self._inner_dict.get('hasRelatedTerms')  # type: ignore
    
    @hasRelatedTerms.setter
    def hasRelatedTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['hasRelatedTerms'] = value
    
    
    @property
    def values(self) -> Union[None, List[str]]:
        """The relationship Has Value with glossary term.
    These are fixed value a term has. For example a ColorEnum where RED, GREEN and YELLOW are fixed values."""
        return self._inner_dict.get('values')  # type: ignore
    
    @values.setter
    def values(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['values'] = value
    
    
    @property
    def relatedTerms(self) -> Union[None, List[str]]:
        """The relationship isRelatedTo with glossary term"""
        return self._inner_dict.get('relatedTerms')  # type: ignore
    
    @relatedTerms.setter
    def relatedTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['relatedTerms'] = value
    
    
class GlossaryTermInfoClass(_Aspect):
    """Properties associated with a GlossaryTerm"""


    ASPECT_NAME = 'glossaryTermInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.glossary.GlossaryTermInfo")

    def __init__(self,
        definition: str,
        termSource: str,
        customProperties: Optional[Dict[str, str]]=None,
        id: Union[None, str]=None,
        name: Union[None, str]=None,
        parentNode: Union[None, str]=None,
        sourceRef: Union[None, str]=None,
        sourceUrl: Union[None, str]=None,
        rawSchema: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.id = id
        self.name = name
        self.definition = definition
        self.parentNode = parentNode
        self.termSource = termSource
        self.sourceRef = sourceRef
        self.sourceUrl = sourceUrl
        self.rawSchema = rawSchema
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.id = self.RECORD_SCHEMA.fields_dict["id"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.definition = str()
        self.parentNode = self.RECORD_SCHEMA.fields_dict["parentNode"].default
        self.termSource = str()
        self.sourceRef = self.RECORD_SCHEMA.fields_dict["sourceRef"].default
        self.sourceUrl = self.RECORD_SCHEMA.fields_dict["sourceUrl"].default
        self.rawSchema = self.RECORD_SCHEMA.fields_dict["rawSchema"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def id(self) -> Union[None, str]:
        """Optional id for the term"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: Union[None, str]) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the term"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def definition(self) -> str:
        """Definition of business term."""
        return self._inner_dict.get('definition')  # type: ignore
    
    @definition.setter
    def definition(self, value: str) -> None:
        self._inner_dict['definition'] = value
    
    
    @property
    def parentNode(self) -> Union[None, str]:
        """Parent node of the glossary term"""
        return self._inner_dict.get('parentNode')  # type: ignore
    
    @parentNode.setter
    def parentNode(self, value: Union[None, str]) -> None:
        self._inner_dict['parentNode'] = value
    
    
    @property
    def termSource(self) -> str:
        """Source of the Business Term (INTERNAL or EXTERNAL) with default value as INTERNAL"""
        return self._inner_dict.get('termSource')  # type: ignore
    
    @termSource.setter
    def termSource(self, value: str) -> None:
        self._inner_dict['termSource'] = value
    
    
    @property
    def sourceRef(self) -> Union[None, str]:
        """External Reference to the business-term"""
        return self._inner_dict.get('sourceRef')  # type: ignore
    
    @sourceRef.setter
    def sourceRef(self, value: Union[None, str]) -> None:
        self._inner_dict['sourceRef'] = value
    
    
    @property
    def sourceUrl(self) -> Union[None, str]:
        """The abstracted URL such as https://spec.edmcouncil.org/fibo/ontology/FBC/FinancialInstruments/FinancialInstruments/CashInstrument."""
        return self._inner_dict.get('sourceUrl')  # type: ignore
    
    @sourceUrl.setter
    def sourceUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['sourceUrl'] = value
    
    
    @property
    def rawSchema(self) -> Union[None, str]:
        """Schema definition of the glossary term"""
        return self._inner_dict.get('rawSchema')  # type: ignore
    
    @rawSchema.setter
    def rawSchema(self, value: Union[None, str]) -> None:
        self._inner_dict['rawSchema'] = value
    
    
class CorpGroupEditableInfoClass(_Aspect):
    """Group information that can be edited from UI"""


    ASPECT_NAME = 'corpGroupEditableInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpGroupEditableInfo")

    def __init__(self,
        description: Union[None, str]=None,
        pictureLink: Optional[str]=None,
        slack: Union[None, str]=None,
        email: Union[None, str]=None,
    ):
        super().__init__()
        
        self.description = description
        if pictureLink is None:
            # default: 'https://raw.githubusercontent.com/datahub-project/datahub/master/datahub-web-react/src/images/default_avatar.png'
            self.pictureLink = self.RECORD_SCHEMA.fields_dict["pictureLink"].default
        else:
            self.pictureLink = pictureLink
        self.slack = slack
        self.email = email
    
    def _restore_defaults(self) -> None:
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.pictureLink = self.RECORD_SCHEMA.fields_dict["pictureLink"].default
        self.slack = self.RECORD_SCHEMA.fields_dict["slack"].default
        self.email = self.RECORD_SCHEMA.fields_dict["email"].default
    
    
    @property
    def description(self) -> Union[None, str]:
        """A description of the group"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def pictureLink(self) -> str:
        """A URL which points to a picture which user wants to set as the photo for the group"""
        return self._inner_dict.get('pictureLink')  # type: ignore
    
    @pictureLink.setter
    def pictureLink(self, value: str) -> None:
        self._inner_dict['pictureLink'] = value
    
    
    @property
    def slack(self) -> Union[None, str]:
        """Slack channel for the group"""
        return self._inner_dict.get('slack')  # type: ignore
    
    @slack.setter
    def slack(self, value: Union[None, str]) -> None:
        self._inner_dict['slack'] = value
    
    
    @property
    def email(self) -> Union[None, str]:
        """Email address to contact the group"""
        return self._inner_dict.get('email')  # type: ignore
    
    @email.setter
    def email(self, value: Union[None, str]) -> None:
        self._inner_dict['email'] = value
    
    
class CorpGroupInfoClass(_Aspect):
    """Information about a Corp Group ingested from a third party source"""


    ASPECT_NAME = 'corpGroupInfo'
    ASPECT_INFO = {'EntityUrns': ['com.linkedin.pegasus2avro.common.CorpGroupUrn']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpGroupInfo")

    def __init__(self,
        admins: List[str],
        members: List[str],
        groups: List[str],
        displayName: Union[None, str]=None,
        email: Union[None, str]=None,
        description: Union[None, str]=None,
        slack: Union[None, str]=None,
        created: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.displayName = displayName
        self.email = email
        self.admins = admins
        self.members = members
        self.groups = groups
        self.description = description
        self.slack = slack
        self.created = created
    
    def _restore_defaults(self) -> None:
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.email = self.RECORD_SCHEMA.fields_dict["email"].default
        self.admins = list()
        self.members = list()
        self.groups = list()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.slack = self.RECORD_SCHEMA.fields_dict["slack"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """The name of the group."""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def email(self) -> Union[None, str]:
        """email of this group"""
        return self._inner_dict.get('email')  # type: ignore
    
    @email.setter
    def email(self, value: Union[None, str]) -> None:
        self._inner_dict['email'] = value
    
    
    @property
    def admins(self) -> List[str]:
        """owners of this group
    Deprecated! Replaced by Ownership aspect."""
        return self._inner_dict.get('admins')  # type: ignore
    
    @admins.setter
    def admins(self, value: List[str]) -> None:
        self._inner_dict['admins'] = value
    
    
    @property
    def members(self) -> List[str]:
        """List of ldap urn in this group.
    Deprecated! Replaced by GroupMembership aspect."""
        return self._inner_dict.get('members')  # type: ignore
    
    @members.setter
    def members(self, value: List[str]) -> None:
        self._inner_dict['members'] = value
    
    
    @property
    def groups(self) -> List[str]:
        """List of groups in this group.
    Deprecated! This field is unused."""
        return self._inner_dict.get('groups')  # type: ignore
    
    @groups.setter
    def groups(self, value: List[str]) -> None:
        self._inner_dict['groups'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """A description of the group."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def slack(self) -> Union[None, str]:
        """Slack channel for the group"""
        return self._inner_dict.get('slack')  # type: ignore
    
    @slack.setter
    def slack(self, value: Union[None, str]) -> None:
        self._inner_dict['slack'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
class CorpGroupSettingsClass(_Aspect):
    """Settings that a group can customize through the DataHub UI"""


    ASPECT_NAME = 'corpGroupSettings'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpGroupSettings")

    def __init__(self,
        notificationSettings: Union[None, "NotificationSettingsClass"]=None,
    ):
        super().__init__()
        
        self.notificationSettings = notificationSettings
    
    def _restore_defaults(self) -> None:
        self.notificationSettings = self.RECORD_SCHEMA.fields_dict["notificationSettings"].default
    
    
    @property
    def notificationSettings(self) -> Union[None, "NotificationSettingsClass"]:
        """Notification settings for a group"""
        return self._inner_dict.get('notificationSettings')  # type: ignore
    
    @notificationSettings.setter
    def notificationSettings(self, value: Union[None, "NotificationSettingsClass"]) -> None:
        self._inner_dict['notificationSettings'] = value
    
    
class CorpUserAppearanceSettingsClass(DictWrapper):
    """Settings for a user around the appearance of their DataHub UI"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserAppearanceSettings")
    def __init__(self,
        showSimplifiedHomepage: Union[None, bool]=None,
        showThemeV2: Union[None, bool]=None,
    ):
        super().__init__()
        
        self.showSimplifiedHomepage = showSimplifiedHomepage
        self.showThemeV2 = showThemeV2
    
    def _restore_defaults(self) -> None:
        self.showSimplifiedHomepage = self.RECORD_SCHEMA.fields_dict["showSimplifiedHomepage"].default
        self.showThemeV2 = self.RECORD_SCHEMA.fields_dict["showThemeV2"].default
    
    
    @property
    def showSimplifiedHomepage(self) -> Union[None, bool]:
        """Flag whether the user should see a homepage with only datasets, charts and dashboards. Intended for users
    who have less operational use cases for the datahub tool."""
        return self._inner_dict.get('showSimplifiedHomepage')  # type: ignore
    
    @showSimplifiedHomepage.setter
    def showSimplifiedHomepage(self, value: Union[None, bool]) -> None:
        self._inner_dict['showSimplifiedHomepage'] = value
    
    
    @property
    def showThemeV2(self) -> Union[None, bool]:
        """Flag controlling whether the V2 UI for DataHub is shown."""
        return self._inner_dict.get('showThemeV2')  # type: ignore
    
    @showThemeV2.setter
    def showThemeV2(self, value: Union[None, bool]) -> None:
        self._inner_dict['showThemeV2'] = value
    
    
class CorpUserCredentialsClass(_Aspect):
    """Corp user credentials"""


    ASPECT_NAME = 'corpUserCredentials'
    ASPECT_INFO = {'EntityUrns': ['com.linkedin.pegasus2avro.common.CorpuserUrn']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserCredentials")

    def __init__(self,
        salt: str,
        hashedPassword: str,
        passwordResetToken: Union[None, str]=None,
        passwordResetTokenExpirationTimeMillis: Union[None, int]=None,
    ):
        super().__init__()
        
        self.salt = salt
        self.hashedPassword = hashedPassword
        self.passwordResetToken = passwordResetToken
        self.passwordResetTokenExpirationTimeMillis = passwordResetTokenExpirationTimeMillis
    
    def _restore_defaults(self) -> None:
        self.salt = str()
        self.hashedPassword = str()
        self.passwordResetToken = self.RECORD_SCHEMA.fields_dict["passwordResetToken"].default
        self.passwordResetTokenExpirationTimeMillis = self.RECORD_SCHEMA.fields_dict["passwordResetTokenExpirationTimeMillis"].default
    
    
    @property
    def salt(self) -> str:
        """Salt used to hash password"""
        return self._inner_dict.get('salt')  # type: ignore
    
    @salt.setter
    def salt(self, value: str) -> None:
        self._inner_dict['salt'] = value
    
    
    @property
    def hashedPassword(self) -> str:
        """Hashed password generated by concatenating salt and password, then hashing"""
        return self._inner_dict.get('hashedPassword')  # type: ignore
    
    @hashedPassword.setter
    def hashedPassword(self, value: str) -> None:
        self._inner_dict['hashedPassword'] = value
    
    
    @property
    def passwordResetToken(self) -> Union[None, str]:
        """Optional token needed to reset a user's password. Can only be set by the admin."""
        return self._inner_dict.get('passwordResetToken')  # type: ignore
    
    @passwordResetToken.setter
    def passwordResetToken(self, value: Union[None, str]) -> None:
        self._inner_dict['passwordResetToken'] = value
    
    
    @property
    def passwordResetTokenExpirationTimeMillis(self) -> Union[None, int]:
        """When the password reset token expires."""
        return self._inner_dict.get('passwordResetTokenExpirationTimeMillis')  # type: ignore
    
    @passwordResetTokenExpirationTimeMillis.setter
    def passwordResetTokenExpirationTimeMillis(self, value: Union[None, int]) -> None:
        self._inner_dict['passwordResetTokenExpirationTimeMillis'] = value
    
    
class CorpUserEditableInfoClass(_Aspect):
    """Linkedin corp user information that can be edited from UI"""


    ASPECT_NAME = 'corpUserEditableInfo'
    ASPECT_INFO = {'EntityUrns': ['com.linkedin.pegasus2avro.common.CorpuserUrn']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserEditableInfo")

    def __init__(self,
        aboutMe: Union[None, str]=None,
        teams: Optional[List[str]]=None,
        skills: Optional[List[str]]=None,
        pictureLink: Optional[str]=None,
        displayName: Union[None, str]=None,
        title: Union[None, str]=None,
        platforms: Union[None, List[str]]=None,
        persona: Union[None, str]=None,
        slack: Union[None, str]=None,
        phone: Union[None, str]=None,
        email: Union[None, str]=None,
        informationSources: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.aboutMe = aboutMe
        if teams is None:
            # default: []
            self.teams = list()
        else:
            self.teams = teams
        if skills is None:
            # default: []
            self.skills = list()
        else:
            self.skills = skills
        if pictureLink is None:
            # default: 'assets/platforms/default_avatar.png'
            self.pictureLink = self.RECORD_SCHEMA.fields_dict["pictureLink"].default
        else:
            self.pictureLink = pictureLink
        self.displayName = displayName
        self.title = title
        self.platforms = platforms
        self.persona = persona
        self.slack = slack
        self.phone = phone
        self.email = email
        self.informationSources = informationSources
    
    def _restore_defaults(self) -> None:
        self.aboutMe = self.RECORD_SCHEMA.fields_dict["aboutMe"].default
        self.teams = list()
        self.skills = list()
        self.pictureLink = self.RECORD_SCHEMA.fields_dict["pictureLink"].default
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.title = self.RECORD_SCHEMA.fields_dict["title"].default
        self.platforms = self.RECORD_SCHEMA.fields_dict["platforms"].default
        self.persona = self.RECORD_SCHEMA.fields_dict["persona"].default
        self.slack = self.RECORD_SCHEMA.fields_dict["slack"].default
        self.phone = self.RECORD_SCHEMA.fields_dict["phone"].default
        self.email = self.RECORD_SCHEMA.fields_dict["email"].default
        self.informationSources = self.RECORD_SCHEMA.fields_dict["informationSources"].default
    
    
    @property
    def aboutMe(self) -> Union[None, str]:
        """About me section of the user"""
        return self._inner_dict.get('aboutMe')  # type: ignore
    
    @aboutMe.setter
    def aboutMe(self, value: Union[None, str]) -> None:
        self._inner_dict['aboutMe'] = value
    
    
    @property
    def teams(self) -> List[str]:
        """Teams that the user belongs to e.g. Metadata"""
        return self._inner_dict.get('teams')  # type: ignore
    
    @teams.setter
    def teams(self, value: List[str]) -> None:
        self._inner_dict['teams'] = value
    
    
    @property
    def skills(self) -> List[str]:
        """Skills that the user possesses e.g. Machine Learning"""
        return self._inner_dict.get('skills')  # type: ignore
    
    @skills.setter
    def skills(self, value: List[str]) -> None:
        self._inner_dict['skills'] = value
    
    
    @property
    def pictureLink(self) -> str:
        """A URL which points to a picture which user wants to set as a profile photo"""
        return self._inner_dict.get('pictureLink')  # type: ignore
    
    @pictureLink.setter
    def pictureLink(self, value: str) -> None:
        self._inner_dict['pictureLink'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """DataHub-native display name"""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def title(self) -> Union[None, str]:
        """DataHub-native Title, e.g. 'Software Engineer'"""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: Union[None, str]) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def platforms(self) -> Union[None, List[str]]:
        """The platforms that the user commonly works with"""
        return self._inner_dict.get('platforms')  # type: ignore
    
    @platforms.setter
    def platforms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['platforms'] = value
    
    
    @property
    def persona(self) -> Union[None, str]:
        """The user's persona type, based on their role"""
        return self._inner_dict.get('persona')  # type: ignore
    
    @persona.setter
    def persona(self, value: Union[None, str]) -> None:
        self._inner_dict['persona'] = value
    
    
    @property
    def slack(self) -> Union[None, str]:
        """Slack handle for the user"""
        return self._inner_dict.get('slack')  # type: ignore
    
    @slack.setter
    def slack(self, value: Union[None, str]) -> None:
        self._inner_dict['slack'] = value
    
    
    @property
    def phone(self) -> Union[None, str]:
        """Phone number to contact the user"""
        return self._inner_dict.get('phone')  # type: ignore
    
    @phone.setter
    def phone(self, value: Union[None, str]) -> None:
        self._inner_dict['phone'] = value
    
    
    @property
    def email(self) -> Union[None, str]:
        """Email address to contact the user"""
        return self._inner_dict.get('email')  # type: ignore
    
    @email.setter
    def email(self, value: Union[None, str]) -> None:
        self._inner_dict['email'] = value
    
    
    @property
    def informationSources(self) -> Union[None, List[str]]:
        """Information sources that have been used to populate this CorpUserEditableInfo.
    These include platform resources, such as Slack members or Looker users.
    They can also refer to other semantic urns in the future."""
        return self._inner_dict.get('informationSources')  # type: ignore
    
    @informationSources.setter
    def informationSources(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['informationSources'] = value
    
    
class CorpUserHomePageSettingsClass(DictWrapper):
    """Settings related to the home page for a user"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserHomePageSettings")
    def __init__(self,
        pageTemplate: Union[None, str]=None,
        dismissedAnnouncements: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.pageTemplate = pageTemplate
        self.dismissedAnnouncements = dismissedAnnouncements
    
    def _restore_defaults(self) -> None:
        self.pageTemplate = self.RECORD_SCHEMA.fields_dict["pageTemplate"].default
        self.dismissedAnnouncements = self.RECORD_SCHEMA.fields_dict["dismissedAnnouncements"].default
    
    
    @property
    def pageTemplate(self) -> Union[None, str]:
        """The page template that will be rendered in the UI by default for this user"""
        return self._inner_dict.get('pageTemplate')  # type: ignore
    
    @pageTemplate.setter
    def pageTemplate(self, value: Union[None, str]) -> None:
        self._inner_dict['pageTemplate'] = value
    
    
    @property
    def dismissedAnnouncements(self) -> Union[None, List[str]]:
        """The list of announcement urns that have been dismissed by the user"""
        return self._inner_dict.get('dismissedAnnouncements')  # type: ignore
    
    @dismissedAnnouncements.setter
    def dismissedAnnouncements(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['dismissedAnnouncements'] = value
    
    
class CorpUserInfoClass(_Aspect):
    """Linkedin corp user information"""


    ASPECT_NAME = 'corpUserInfo'
    ASPECT_INFO = {'EntityUrns': ['com.linkedin.pegasus2avro.common.CorpuserUrn']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserInfo")

    def __init__(self,
        active: bool,
        customProperties: Optional[Dict[str, str]]=None,
        displayName: Union[None, str]=None,
        email: Union[None, str]=None,
        title: Union[None, str]=None,
        managerUrn: Union[None, str]=None,
        departmentId: Union[None, int]=None,
        departmentName: Union[None, str]=None,
        firstName: Union[None, str]=None,
        lastName: Union[None, str]=None,
        fullName: Union[None, str]=None,
        countryCode: Union[None, str]=None,
        system: Optional[Union[bool, None]]=None,
        isSupportUser: Union[None, bool]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.active = active
        self.displayName = displayName
        self.email = email
        self.title = title
        self.managerUrn = managerUrn
        self.departmentId = departmentId
        self.departmentName = departmentName
        self.firstName = firstName
        self.lastName = lastName
        self.fullName = fullName
        self.countryCode = countryCode
        if system is None:
            # default: False
            self.system = self.RECORD_SCHEMA.fields_dict["system"].default
        else:
            self.system = system
        self.isSupportUser = isSupportUser
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.active = bool()
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.email = self.RECORD_SCHEMA.fields_dict["email"].default
        self.title = self.RECORD_SCHEMA.fields_dict["title"].default
        self.managerUrn = self.RECORD_SCHEMA.fields_dict["managerUrn"].default
        self.departmentId = self.RECORD_SCHEMA.fields_dict["departmentId"].default
        self.departmentName = self.RECORD_SCHEMA.fields_dict["departmentName"].default
        self.firstName = self.RECORD_SCHEMA.fields_dict["firstName"].default
        self.lastName = self.RECORD_SCHEMA.fields_dict["lastName"].default
        self.fullName = self.RECORD_SCHEMA.fields_dict["fullName"].default
        self.countryCode = self.RECORD_SCHEMA.fields_dict["countryCode"].default
        self.system = self.RECORD_SCHEMA.fields_dict["system"].default
        self.isSupportUser = self.RECORD_SCHEMA.fields_dict["isSupportUser"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def active(self) -> bool:
        """Deprecated! Use CorpUserStatus instead. Whether the corpUser is active, ref: https://iwww.corp.linkedin.com/wiki/cf/display/GTSD/Accessing+Active+Directory+via+LDAP+tools"""
        return self._inner_dict.get('active')  # type: ignore
    
    @active.setter
    def active(self, value: bool) -> None:
        self._inner_dict['active'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """displayName of this user ,  e.g.  Hang Zhang(DataHQ)"""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def email(self) -> Union[None, str]:
        """email address of this user"""
        return self._inner_dict.get('email')  # type: ignore
    
    @email.setter
    def email(self, value: Union[None, str]) -> None:
        self._inner_dict['email'] = value
    
    
    @property
    def title(self) -> Union[None, str]:
        """title of this user"""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: Union[None, str]) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def managerUrn(self) -> Union[None, str]:
        """direct manager of this user"""
        return self._inner_dict.get('managerUrn')  # type: ignore
    
    @managerUrn.setter
    def managerUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['managerUrn'] = value
    
    
    @property
    def departmentId(self) -> Union[None, int]:
        """department id this user belong to"""
        return self._inner_dict.get('departmentId')  # type: ignore
    
    @departmentId.setter
    def departmentId(self, value: Union[None, int]) -> None:
        self._inner_dict['departmentId'] = value
    
    
    @property
    def departmentName(self) -> Union[None, str]:
        """department name this user belong to"""
        return self._inner_dict.get('departmentName')  # type: ignore
    
    @departmentName.setter
    def departmentName(self, value: Union[None, str]) -> None:
        self._inner_dict['departmentName'] = value
    
    
    @property
    def firstName(self) -> Union[None, str]:
        """first name of this user"""
        return self._inner_dict.get('firstName')  # type: ignore
    
    @firstName.setter
    def firstName(self, value: Union[None, str]) -> None:
        self._inner_dict['firstName'] = value
    
    
    @property
    def lastName(self) -> Union[None, str]:
        """last name of this user"""
        return self._inner_dict.get('lastName')  # type: ignore
    
    @lastName.setter
    def lastName(self, value: Union[None, str]) -> None:
        self._inner_dict['lastName'] = value
    
    
    @property
    def fullName(self) -> Union[None, str]:
        """Common name of this user, format is firstName + lastName (split by a whitespace)"""
        return self._inner_dict.get('fullName')  # type: ignore
    
    @fullName.setter
    def fullName(self, value: Union[None, str]) -> None:
        self._inner_dict['fullName'] = value
    
    
    @property
    def countryCode(self) -> Union[None, str]:
        """two uppercase letters country code. e.g.  US"""
        return self._inner_dict.get('countryCode')  # type: ignore
    
    @countryCode.setter
    def countryCode(self, value: Union[None, str]) -> None:
        self._inner_dict['countryCode'] = value
    
    
    @property
    def system(self) -> Union[bool, None]:
        """Whether the corpUser is a system user."""
        return self._inner_dict.get('system')  # type: ignore
    
    @system.setter
    def system(self, value: Union[bool, None]) -> None:
        self._inner_dict['system'] = value
    
    
    @property
    def isSupportUser(self) -> Union[None, bool]:
        """Whether the corpUser is a support user authenticated through the support OIDC flow."""
        return self._inner_dict.get('isSupportUser')  # type: ignore
    
    @isSupportUser.setter
    def isSupportUser(self, value: Union[None, bool]) -> None:
        self._inner_dict['isSupportUser'] = value
    
    
class CorpUserInvitationStatusClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'corpUserInvitationStatus'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserInvitationStatus")

    def __init__(self,
        created: "AuditStampClass",
        status: Union[str, "InvitationStatusClass"],
        lastUpdated: "AuditStampClass",
        invitationToken: str,
        role: Union[None, str]=None,
    ):
        super().__init__()
        
        self.role = role
        self.created = created
        self.status = status
        self.lastUpdated = lastUpdated
        self.invitationToken = invitationToken
    
    def _restore_defaults(self) -> None:
        self.role = self.RECORD_SCHEMA.fields_dict["role"].default
        self.created = AuditStampClass._construct_with_defaults()
        self.status = InvitationStatusClass.SENT
        self.lastUpdated = AuditStampClass._construct_with_defaults()
        self.invitationToken = str()
    
    
    @property
    def role(self) -> Union[None, str]:
        """Role will only work in non-sso environments today."""
        return self._inner_dict.get('role')  # type: ignore
    
    @role.setter
    def role(self, value: Union[None, str]) -> None:
        self._inner_dict['role'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Created Audit"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def status(self) -> Union[str, "InvitationStatusClass"]:
        """The status of the invitation"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "InvitationStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def lastUpdated(self) -> "AuditStampClass":
        """Last Status Change Audit"""
        return self._inner_dict.get('lastUpdated')  # type: ignore
    
    @lastUpdated.setter
    def lastUpdated(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastUpdated'] = value
    
    
    @property
    def invitationToken(self) -> str:
        """Unique token for the invitation URL - hashed via SecretService """
        return self._inner_dict.get('invitationToken')  # type: ignore
    
    @invitationToken.setter
    def invitationToken(self, value: str) -> None:
        self._inner_dict['invitationToken'] = value
    
    
class CorpUserSettingsClass(_Aspect):
    """Settings that a user can customize through the DataHub UI"""


    ASPECT_NAME = 'corpUserSettings'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserSettings")

    def __init__(self,
        appearance: "CorpUserAppearanceSettingsClass",
        views: Union[None, "CorpUserViewsSettingsClass"]=None,
        notificationSettings: Union[None, "NotificationSettingsClass"]=None,
        homePage: Union[None, "CorpUserHomePageSettingsClass"]=None,
        aiAssistant: Union[None, "AiAssistantSettingsClass"]=None,
    ):
        super().__init__()
        
        self.appearance = appearance
        self.views = views
        self.notificationSettings = notificationSettings
        self.homePage = homePage
        self.aiAssistant = aiAssistant
    
    def _restore_defaults(self) -> None:
        self.appearance = CorpUserAppearanceSettingsClass._construct_with_defaults()
        self.views = self.RECORD_SCHEMA.fields_dict["views"].default
        self.notificationSettings = self.RECORD_SCHEMA.fields_dict["notificationSettings"].default
        self.homePage = self.RECORD_SCHEMA.fields_dict["homePage"].default
        self.aiAssistant = self.RECORD_SCHEMA.fields_dict["aiAssistant"].default
    
    
    @property
    def appearance(self) -> "CorpUserAppearanceSettingsClass":
        """Settings for a user around the appearance of their DataHub UI"""
        return self._inner_dict.get('appearance')  # type: ignore
    
    @appearance.setter
    def appearance(self, value: "CorpUserAppearanceSettingsClass") -> None:
        self._inner_dict['appearance'] = value
    
    
    @property
    def views(self) -> Union[None, "CorpUserViewsSettingsClass"]:
        """User preferences for the Views feature."""
        return self._inner_dict.get('views')  # type: ignore
    
    @views.setter
    def views(self, value: Union[None, "CorpUserViewsSettingsClass"]) -> None:
        self._inner_dict['views'] = value
    
    
    @property
    def notificationSettings(self) -> Union[None, "NotificationSettingsClass"]:
        """Notification settings for a user"""
        return self._inner_dict.get('notificationSettings')  # type: ignore
    
    @notificationSettings.setter
    def notificationSettings(self, value: Union[None, "NotificationSettingsClass"]) -> None:
        self._inner_dict['notificationSettings'] = value
    
    
    @property
    def homePage(self) -> Union[None, "CorpUserHomePageSettingsClass"]:
        """Settings related to the home page for a user"""
        return self._inner_dict.get('homePage')  # type: ignore
    
    @homePage.setter
    def homePage(self, value: Union[None, "CorpUserHomePageSettingsClass"]) -> None:
        self._inner_dict['homePage'] = value
    
    
    @property
    def aiAssistant(self) -> Union[None, "AiAssistantSettingsClass"]:
        """Settings related to AI-powered chat assistant (Ask DataHub)."""
        return self._inner_dict.get('aiAssistant')  # type: ignore
    
    @aiAssistant.setter
    def aiAssistant(self, value: Union[None, "AiAssistantSettingsClass"]) -> None:
        self._inner_dict['aiAssistant'] = value
    
    
class CorpUserStatusClass(_Aspect):
    """The status of the user, e.g. provisioned, active, suspended, etc."""


    ASPECT_NAME = 'corpUserStatus'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserStatus")

    def __init__(self,
        status: str,
        lastModified: "AuditStampClass",
    ):
        super().__init__()
        
        self.status = status
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.status = str()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def status(self) -> str:
        """Status of the user, e.g. PROVISIONED / ACTIVE / SUSPENDED"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: str) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp containing who last modified the status and when."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class CorpUserViewsSettingsClass(DictWrapper):
    """Settings related to the 'Views' feature."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.CorpUserViewsSettings")
    def __init__(self,
        defaultView: Union[None, str]=None,
    ):
        super().__init__()
        
        self.defaultView = defaultView
    
    def _restore_defaults(self) -> None:
        self.defaultView = self.RECORD_SCHEMA.fields_dict["defaultView"].default
    
    
    @property
    def defaultView(self) -> Union[None, str]:
        """The default View which is selected for the user.
    If none is chosen, then this value will be left blank."""
        return self._inner_dict.get('defaultView')  # type: ignore
    
    @defaultView.setter
    def defaultView(self, value: Union[None, str]) -> None:
        self._inner_dict['defaultView'] = value
    
    
class GroupMembershipClass(_Aspect):
    """Carries information about the CorpGroups a user is in."""


    ASPECT_NAME = 'groupMembership'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.GroupMembership")

    def __init__(self,
        groups: List[str],
    ):
        super().__init__()
        
        self.groups = groups
    
    def _restore_defaults(self) -> None:
        self.groups = list()
    
    
    @property
    def groups(self) -> List[str]:
        # No docs available.
        return self._inner_dict.get('groups')  # type: ignore
    
    @groups.setter
    def groups(self, value: List[str]) -> None:
        self._inner_dict['groups'] = value
    
    
class InvitationStatusClass(object):
    # No docs available.
    
    SENT = "SENT"
    ACCEPTED = "ACCEPTED"
    REVOKED = "REVOKED"
    SUGGESTION_DISMISSED = "SUGGESTION_DISMISSED"
    
    
class InviteTokenClass(_Aspect):
    """Aspect used to store invite tokens."""


    ASPECT_NAME = 'inviteToken'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.InviteToken")

    def __init__(self,
        token: str,
        role: Union[None, str]=None,
        tokenType: Optional[Union[Union[str, "TokenTypeClass"], None]]=None,
    ):
        super().__init__()
        
        self.token = token
        self.role = role
        if tokenType is None:
            # default: 'SHARED'
            self.tokenType = self.RECORD_SCHEMA.fields_dict["tokenType"].default
        else:
            self.tokenType = tokenType
    
    def _restore_defaults(self) -> None:
        self.token = str()
        self.role = self.RECORD_SCHEMA.fields_dict["role"].default
        self.tokenType = self.RECORD_SCHEMA.fields_dict["tokenType"].default
    
    
    @property
    def token(self) -> str:
        """The encrypted invite token."""
        return self._inner_dict.get('token')  # type: ignore
    
    @token.setter
    def token(self, value: str) -> None:
        self._inner_dict['token'] = value
    
    
    @property
    def role(self) -> Union[None, str]:
        """The role that this invite token may be associated with"""
        return self._inner_dict.get('role')  # type: ignore
    
    @role.setter
    def role(self, value: Union[None, str]) -> None:
        self._inner_dict['role'] = value
    
    
    @property
    def tokenType(self) -> Union[Union[str, "TokenTypeClass"], None]:
        """The type of invite token - shared (admin managed) or individual (single-use)"""
        return self._inner_dict.get('tokenType')  # type: ignore
    
    @tokenType.setter
    def tokenType(self, value: Union[Union[str, "TokenTypeClass"], None]) -> None:
        self._inner_dict['tokenType'] = value
    
    
class NativeGroupMembershipClass(_Aspect):
    """Carries information about the native CorpGroups a user is in."""


    ASPECT_NAME = 'nativeGroupMembership'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.NativeGroupMembership")

    def __init__(self,
        nativeGroups: List[str],
    ):
        super().__init__()
        
        self.nativeGroups = nativeGroups
    
    def _restore_defaults(self) -> None:
        self.nativeGroups = list()
    
    
    @property
    def nativeGroups(self) -> List[str]:
        # No docs available.
        return self._inner_dict.get('nativeGroups')  # type: ignore
    
    @nativeGroups.setter
    def nativeGroups(self, value: List[str]) -> None:
        self._inner_dict['nativeGroups'] = value
    
    
class RoleMembershipClass(_Aspect):
    """Carries information about which roles a user or group is assigned to."""


    ASPECT_NAME = 'roleMembership'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.identity.RoleMembership")

    def __init__(self,
        roles: List[str],
    ):
        super().__init__()
        
        self.roles = roles
    
    def _restore_defaults(self) -> None:
        self.roles = list()
    
    
    @property
    def roles(self) -> List[str]:
        # No docs available.
        return self._inner_dict.get('roles')  # type: ignore
    
    @roles.setter
    def roles(self, value: List[str]) -> None:
        self._inner_dict['roles'] = value
    
    
class TokenTypeClass(object):
    """Token types for different invitation workflows"""
    
    SHARED = "SHARED"
    """Shared token that admin can copy and share manually. Reusable until admin regenerates."""
    
    INDIVIDUAL = "INDIVIDUAL"
    """Individual token generated for bulk invitations. Single-use, consumed on signup."""
    
    
    
class IncidentActivityChangeClass(DictWrapper):
    """Incident Activity Change is a record that represents the changes that occurred in the incident activity event."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.IncidentActivityChange")
    def __init__(self,
        type: Union[str, "IncidentActivityChangeTypeClass"],
    ):
        super().__init__()
        
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.type = IncidentActivityChangeTypeClass.ASSIGNEES
    
    
    @property
    def type(self) -> Union[str, "IncidentActivityChangeTypeClass"]:
        """The type of change. TODO: Determine if description change should be included in this aspect.
    This is a timeseries field so you can filter by a given change type!"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "IncidentActivityChangeTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class IncidentActivityChangeTypeClass(object):
    # No docs available.
    
    ASSIGNEES = "ASSIGNEES"
    """Assignees were added or removed"""
    
    STATE = "STATE"
    """State of the incident changed"""
    
    STAGE = "STAGE"
    """Lifecycle stage of the incident changes"""
    
    PRIORITY = "PRIORITY"
    """The priority of the incident changed"""
    
    
    
class IncidentActivityEventClass(_Aspect):
    """A lifecycle event for an incident lifecycle change event
    that should be visible in the incident activity log."""


    ASPECT_NAME = 'incidentActivityEvent'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.IncidentActivityEvent")

    def __init__(self,
        timestampMillis: int,
        previousInfo: "IncidentInfoClass",
        newInfo: "IncidentInfoClass",
        actorUrn: str,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        changes: Optional[List["IncidentActivityChangeClass"]]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        if changes is None:
            # default: []
            self.changes = list()
        else:
            self.changes = changes
        self.previousInfo = previousInfo
        self.newInfo = newInfo
        self.actorUrn = actorUrn
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.changes = list()
        self.previousInfo = IncidentInfoClass._construct_with_defaults()
        self.newInfo = IncidentInfoClass._construct_with_defaults()
        self.actorUrn = str()
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def changes(self) -> List["IncidentActivityChangeClass"]:
        """The actual changes that occurred in the incident activity event."""
        return self._inner_dict.get('changes')  # type: ignore
    
    @changes.setter
    def changes(self, value: List["IncidentActivityChangeClass"]) -> None:
        self._inner_dict['changes'] = value
    
    
    @property
    def previousInfo(self) -> "IncidentInfoClass":
        """The raw previous incident info. Removed all annotations."""
        return self._inner_dict.get('previousInfo')  # type: ignore
    
    @previousInfo.setter
    def previousInfo(self, value: "IncidentInfoClass") -> None:
        self._inner_dict['previousInfo'] = value
    
    
    @property
    def newInfo(self) -> "IncidentInfoClass":
        """The raw new incident info. Removed all annotations."""
        return self._inner_dict.get('newInfo')  # type: ignore
    
    @newInfo.setter
    def newInfo(self, value: "IncidentInfoClass") -> None:
        self._inner_dict['newInfo'] = value
    
    
    @property
    def actorUrn(self) -> str:
        """The actor who performed the activity."""
        return self._inner_dict.get('actorUrn')  # type: ignore
    
    @actorUrn.setter
    def actorUrn(self, value: str) -> None:
        self._inner_dict['actorUrn'] = value
    
    
class IncidentAssigneeClass(DictWrapper):
    """The incident assignee type.
    This is in a record so that we can add additional fields if we need to later (e.g.
    the type of the assignee."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.IncidentAssignee")
    def __init__(self,
        actor: str,
        assignedAt: "AuditStampClass",
    ):
        super().__init__()
        
        self.actor = actor
        self.assignedAt = assignedAt
    
    def _restore_defaults(self) -> None:
        self.actor = str()
        self.assignedAt = AuditStampClass._construct_with_defaults()
    
    
    @property
    def actor(self) -> str:
        """The user or group assigned to the incident."""
        return self._inner_dict.get('actor')  # type: ignore
    
    @actor.setter
    def actor(self, value: str) -> None:
        self._inner_dict['actor'] = value
    
    
    @property
    def assignedAt(self) -> "AuditStampClass":
        """The time & actor responsible for assiging the assignee."""
        return self._inner_dict.get('assignedAt')  # type: ignore
    
    @assignedAt.setter
    def assignedAt(self, value: "AuditStampClass") -> None:
        self._inner_dict['assignedAt'] = value
    
    
class IncidentInfoClass(_Aspect):
    """Information about an incident raised on an asset.
    
    NOTE: When this file is changed, update IncidentActivityEvent.pdl to remove searchable and relationship annotations."""


    ASPECT_NAME = 'incidentInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.IncidentInfo")

    def __init__(self,
        type: Union[str, "IncidentTypeClass"],
        entities: List[str],
        status: "IncidentStatusClass",
        created: "AuditStampClass",
        customType: Union[None, str]=None,
        title: Union[None, str]=None,
        description: Union[None, str]=None,
        priority: Union[None, int]=None,
        assignees: Union[None, List["IncidentAssigneeClass"]]=None,
        source: Union[None, "IncidentSourceClass"]=None,
        startedAt: Union[None, int]=None,
    ):
        super().__init__()
        
        self.type = type
        self.customType = customType
        self.title = title
        self.description = description
        self.entities = entities
        self.priority = priority
        self.assignees = assignees
        self.status = status
        self.source = source
        self.startedAt = startedAt
        self.created = created
    
    def _restore_defaults(self) -> None:
        self.type = IncidentTypeClass.FRESHNESS
        self.customType = self.RECORD_SCHEMA.fields_dict["customType"].default
        self.title = self.RECORD_SCHEMA.fields_dict["title"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.entities = list()
        self.priority = self.RECORD_SCHEMA.fields_dict["priority"].default
        self.assignees = self.RECORD_SCHEMA.fields_dict["assignees"].default
        self.status = IncidentStatusClass._construct_with_defaults()
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
        self.startedAt = self.RECORD_SCHEMA.fields_dict["startedAt"].default
        self.created = AuditStampClass._construct_with_defaults()
    
    
    @property
    def type(self) -> Union[str, "IncidentTypeClass"]:
        """The type of incident"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "IncidentTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def customType(self) -> Union[None, str]:
        """An optional custom incident type. Present only if type is 'CUSTOM'."""
        return self._inner_dict.get('customType')  # type: ignore
    
    @customType.setter
    def customType(self, value: Union[None, str]) -> None:
        self._inner_dict['customType'] = value
    
    
    @property
    def title(self) -> Union[None, str]:
        """Optional title associated with the incident"""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: Union[None, str]) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Optional description associated with the incident"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def entities(self) -> List[str]:
        """A reference to the entity associated with the incident."""
        return self._inner_dict.get('entities')  # type: ignore
    
    @entities.setter
    def entities(self, value: List[str]) -> None:
        self._inner_dict['entities'] = value
    
    
    @property
    def priority(self) -> Union[None, int]:
        """A numeric severity or priority for the incident. On the UI we will translate this into something easy to understand.
    Currently supported: 0 - CRITICAL, 1 - HIGH, 2 - MED, 3 - LOW
    (We probably should have modeled as an enum)"""
        return self._inner_dict.get('priority')  # type: ignore
    
    @priority.setter
    def priority(self, value: Union[None, int]) -> None:
        self._inner_dict['priority'] = value
    
    
    @property
    def assignees(self) -> Union[None, List["IncidentAssigneeClass"]]:
        """The parties assigned with resolving the incident"""
        return self._inner_dict.get('assignees')  # type: ignore
    
    @assignees.setter
    def assignees(self, value: Union[None, List["IncidentAssigneeClass"]]) -> None:
        self._inner_dict['assignees'] = value
    
    
    @property
    def status(self) -> "IncidentStatusClass":
        """The current status of an incident, i.e. active or inactive."""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: "IncidentStatusClass") -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def source(self) -> Union[None, "IncidentSourceClass"]:
        """The source of an incident, i.e. how it was generated."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "IncidentSourceClass"]) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def startedAt(self) -> Union[None, int]:
        """The time at which the incident actually started (may be before the date it was raised)."""
        return self._inner_dict.get('startedAt')  # type: ignore
    
    @startedAt.setter
    def startedAt(self, value: Union[None, int]) -> None:
        self._inner_dict['startedAt'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """The time at which the request was initially created"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
class IncidentNotificationDetailsClass(_Aspect):
    """Information about the notification context for an incident (where we notified)"""


    ASPECT_NAME = 'incidentNotificationDetails'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.IncidentNotificationDetails")

    def __init__(self,
        slack: Union[None, "SlackIncidentDetailsClass"]=None,
    ):
        super().__init__()
        
        self.slack = slack
    
    def _restore_defaults(self) -> None:
        self.slack = self.RECORD_SCHEMA.fields_dict["slack"].default
    
    
    @property
    def slack(self) -> Union[None, "SlackIncidentDetailsClass"]:
        """Details related to Slack."""
        return self._inner_dict.get('slack')  # type: ignore
    
    @slack.setter
    def slack(self, value: Union[None, "SlackIncidentDetailsClass"]) -> None:
        self._inner_dict['slack'] = value
    
    
class IncidentSourceClass(_Aspect):
    """Information about the source of an incident raised on an asset."""


    ASPECT_NAME = 'incidentSource'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.IncidentSource")

    def __init__(self,
        type: Union[str, "IncidentSourceTypeClass"],
        sourceUrn: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.sourceUrn = sourceUrn
    
    def _restore_defaults(self) -> None:
        self.type = IncidentSourceTypeClass.MANUAL
        self.sourceUrn = self.RECORD_SCHEMA.fields_dict["sourceUrn"].default
    
    
    @property
    def type(self) -> Union[str, "IncidentSourceTypeClass"]:
        """Message associated with the incident"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "IncidentSourceTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def sourceUrn(self) -> Union[None, str]:
        """Reference to an URN related to the source of an incident. Currently populated when the type of the incident
    is ASSERTION_FAILURE.
    
    If this incident was raised due to an assertion failure, then this will contain the urn of the source Assertion."""
        return self._inner_dict.get('sourceUrn')  # type: ignore
    
    @sourceUrn.setter
    def sourceUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['sourceUrn'] = value
    
    
class IncidentSourceTypeClass(object):
    # No docs available.
    
    MANUAL = "MANUAL"
    """Manually created incident, via UI or API."""
    
    ASSERTION_FAILURE = "ASSERTION_FAILURE"
    """An assertion has failed, triggering the incident."""
    
    
    
class IncidentStageClass(object):
    # No docs available.
    
    TRIAGE = "TRIAGE"
    """The impact and priority of the incident is being actively assessed."""
    
    INVESTIGATION = "INVESTIGATION"
    """The incident root cause is being investigated."""
    
    WORK_IN_PROGRESS = "WORK_IN_PROGRESS"
    """The incident is in the remediation stage."""
    
    FIXED = "FIXED"
    """The incident is in the resolved as completed stage."""
    
    NO_ACTION_REQUIRED = "NO_ACTION_REQUIRED"
    """The incident is in the resolved with no action required state, e.g. the
    incident was a false positive, or was expected."""
    
    
    
class IncidentStateClass(object):
    # No docs available.
    
    ACTIVE = "ACTIVE"
    """The incident is ongoing, or active."""
    
    RESOLVED = "RESOLVED"
    """The incident is resolved."""
    
    
    
class IncidentStatusClass(DictWrapper):
    """Information about an incident raised on an asset"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.IncidentStatus")
    def __init__(self,
        state: Union[str, "IncidentStateClass"],
        lastUpdated: "AuditStampClass",
        stage: Union[None, Union[str, "IncidentStageClass"]]=None,
        message: Union[None, str]=None,
    ):
        super().__init__()
        
        self.state = state
        self.stage = stage
        self.message = message
        self.lastUpdated = lastUpdated
    
    def _restore_defaults(self) -> None:
        self.state = IncidentStateClass.ACTIVE
        self.stage = self.RECORD_SCHEMA.fields_dict["stage"].default
        self.message = self.RECORD_SCHEMA.fields_dict["message"].default
        self.lastUpdated = AuditStampClass._construct_with_defaults()
    
    
    @property
    def state(self) -> Union[str, "IncidentStateClass"]:
        """The top-level state of the incident, whether it's active or resolved."""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[str, "IncidentStateClass"]) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def stage(self) -> Union[None, Union[str, "IncidentStageClass"]]:
        """The lifecycle stage for the incident - Null means no stage was assigned yet.
    In the future, we may add CUSTOM here with a customStage string field for user-defined stages."""
        return self._inner_dict.get('stage')  # type: ignore
    
    @stage.setter
    def stage(self, value: Union[None, Union[str, "IncidentStageClass"]]) -> None:
        self._inner_dict['stage'] = value
    
    
    @property
    def message(self) -> Union[None, str]:
        """Optional message associated with the incident"""
        return self._inner_dict.get('message')  # type: ignore
    
    @message.setter
    def message(self, value: Union[None, str]) -> None:
        self._inner_dict['message'] = value
    
    
    @property
    def lastUpdated(self) -> "AuditStampClass":
        """The time at which the request was initially created"""
        return self._inner_dict.get('lastUpdated')  # type: ignore
    
    @lastUpdated.setter
    def lastUpdated(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastUpdated'] = value
    
    
class IncidentTypeClass(object):
    """A type of asset incident"""
    
    FRESHNESS = "FRESHNESS"
    """An Freshness Assertion has failed, triggering the incident.
    Raised on entities where assertions are configured to generate incidents."""
    
    VOLUME = "VOLUME"
    """An Volume Assertion has failed, triggering the incident.
    Raised on entities where assertions are configured to generate incidents."""
    
    FIELD = "FIELD"
    """A Field Assertion has failed, triggering the incident.
    Raised on entities where assertions are configured to generate incidents."""
    
    SQL = "SQL"
    """A raw SQL-statement based assertion has failed, triggering the incident.
    Raised on entities where assertions are configured to generate incidents."""
    
    DATA_SCHEMA = "DATA_SCHEMA"
    """A Data Schema assertion has failed, triggering the incident.
    Raised on entities where assertions are configured to generate incidents."""
    
    OPERATIONAL = "OPERATIONAL"
    """A misc. operational incident, e.g. failure to materialize a dataset."""
    
    CUSTOM = "CUSTOM"
    """A custom type of incident"""
    
    DATASET_COLUMN = "DATASET_COLUMN"
    """An assertion on a particular column(s) of a Dataset has triggered the incident.
    Raised on Datasets where assertions are configured to generate incidents.
    Deprecated! Use FIELD instead. Will be removed."""
    
    DATASET_ROWS = "DATASET_ROWS"
    """An assertion on the row count of a Dataset has triggered the incident.
    Raised on datasets where assertions are configured to generate incidents.
    Deprecated! Use VOLUME instead. Will be removed."""
    
    
    
class SlackIncidentDetailsClass(DictWrapper):
    """Slack-specific details about incident notifications"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.SlackIncidentDetails")
    def __init__(self,
        messages: Optional[List["SlackMessageDetailsClass"]]=None,
    ):
        super().__init__()
        
        if messages is None:
            # default: []
            self.messages = list()
        else:
            self.messages = messages
    
    def _restore_defaults(self) -> None:
        self.messages = list()
    
    
    @property
    def messages(self) -> List["SlackMessageDetailsClass"]:
        """The Slack messages that contain the incident information"""
        return self._inner_dict.get('messages')  # type: ignore
    
    @messages.setter
    def messages(self, value: List["SlackMessageDetailsClass"]) -> None:
        self._inner_dict['messages'] = value
    
    
class SlackMessageDetailsClass(DictWrapper):
    """Slack-specific message that contains the incident information.
    Note that we will NOT capture slack message details
    for DMs.
    This object will be created by the integrations service once a
    notification message about an incident is posted to a specific channel."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.incident.SlackMessageDetails")
    def __init__(self,
        channelId: str,
        messageId: str,
        channelName: Union[None, str]=None,
    ):
        super().__init__()
        
        self.channelId = channelId
        self.channelName = channelName
        self.messageId = messageId
    
    def _restore_defaults(self) -> None:
        self.channelId = str()
        self.channelName = self.RECORD_SCHEMA.fields_dict["channelName"].default
        self.messageId = str()
    
    
    @property
    def channelId(self) -> str:
        """The original Slack channel id or user id associated with the incident message."""
        return self._inner_dict.get('channelId')  # type: ignore
    
    @channelId.setter
    def channelId(self, value: str) -> None:
        self._inner_dict['channelId'] = value
    
    
    @property
    def channelName(self) -> Union[None, str]:
        """The human-readable channel name associated with the incident message.
    This is attempted to be resolved by the integrations service.
    
    If it cannot be found, it will be left empty."""
        return self._inner_dict.get('channelName')  # type: ignore
    
    @channelName.setter
    def channelName(self, value: Union[None, str]) -> None:
        self._inner_dict['channelName'] = value
    
    
    @property
    def messageId(self) -> str:
        """The Slack message id associated with the incident."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: str) -> None:
        self._inner_dict['messageId'] = value
    
    
class InferredDescriptionClass(DictWrapper):
    """Records inferred description and its provenance"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.InferredDescription")
    def __init__(self,
        description: str,
        source: "InferredMetadataSourceClass",
    ):
        super().__init__()
        
        self.description = description
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.description = str()
        self.source = InferredMetadataSourceClass._construct_with_defaults()
    
    
    @property
    def description(self) -> str:
        """Inferred description text"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: str) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def source(self) -> "InferredMetadataSourceClass":
        """Provenance details about this inference"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: "InferredMetadataSourceClass") -> None:
        self._inner_dict['source'] = value
    
    
class InferredGlossaryTermsClass(DictWrapper):
    """Records inferred glossary terms along with their provenance
    All glossary terms from this record share same provenance"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.InferredGlossaryTerms")
    def __init__(self,
        glossaryTerms: List[str],
        source: "InferredMetadataSourceClass",
    ):
        super().__init__()
        
        self.glossaryTerms = glossaryTerms
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.glossaryTerms = list()
        self.source = InferredMetadataSourceClass._construct_with_defaults()
    
    
    @property
    def glossaryTerms(self) -> List[str]:
        """Urn of inferred glossary term"""
        return self._inner_dict.get('glossaryTerms')  # type: ignore
    
    @glossaryTerms.setter
    def glossaryTerms(self, value: List[str]) -> None:
        self._inner_dict['glossaryTerms'] = value
    
    
    @property
    def source(self) -> "InferredMetadataSourceClass":
        """Provenance details about this inference"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: "InferredMetadataSourceClass") -> None:
        self._inner_dict['source'] = value
    
    
class InferredMetadataClass(_Aspect):
    """Inferred Metadata for entities"""


    ASPECT_NAME = 'inferredMetadata'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.InferredMetadata")

    def __init__(self,
        inferredDescriptions: Union[None, List["InferredDescriptionClass"]]=None,
        inferredTags: Union[None, List["InferredTagsClass"]]=None,
        inferredGlossaryTerms: Union[None, List["InferredGlossaryTermsClass"]]=None,
        inferredOwners: Union[None, List["InferredOwnersClass"]]=None,
    ):
        super().__init__()
        
        self.inferredDescriptions = inferredDescriptions
        self.inferredTags = inferredTags
        self.inferredGlossaryTerms = inferredGlossaryTerms
        self.inferredOwners = inferredOwners
    
    def _restore_defaults(self) -> None:
        self.inferredDescriptions = self.RECORD_SCHEMA.fields_dict["inferredDescriptions"].default
        self.inferredTags = self.RECORD_SCHEMA.fields_dict["inferredTags"].default
        self.inferredGlossaryTerms = self.RECORD_SCHEMA.fields_dict["inferredGlossaryTerms"].default
        self.inferredOwners = self.RECORD_SCHEMA.fields_dict["inferredOwners"].default
    
    
    @property
    def inferredDescriptions(self) -> Union[None, List["InferredDescriptionClass"]]:
        """Inferred descriptions for entity"""
        return self._inner_dict.get('inferredDescriptions')  # type: ignore
    
    @inferredDescriptions.setter
    def inferredDescriptions(self, value: Union[None, List["InferredDescriptionClass"]]) -> None:
        self._inner_dict['inferredDescriptions'] = value
    
    
    @property
    def inferredTags(self) -> Union[None, List["InferredTagsClass"]]:
        """Inferred tags for entity"""
        return self._inner_dict.get('inferredTags')  # type: ignore
    
    @inferredTags.setter
    def inferredTags(self, value: Union[None, List["InferredTagsClass"]]) -> None:
        self._inner_dict['inferredTags'] = value
    
    
    @property
    def inferredGlossaryTerms(self) -> Union[None, List["InferredGlossaryTermsClass"]]:
        """Inferred glossary terms for entity"""
        return self._inner_dict.get('inferredGlossaryTerms')  # type: ignore
    
    @inferredGlossaryTerms.setter
    def inferredGlossaryTerms(self, value: Union[None, List["InferredGlossaryTermsClass"]]) -> None:
        self._inner_dict['inferredGlossaryTerms'] = value
    
    
    @property
    def inferredOwners(self) -> Union[None, List["InferredOwnersClass"]]:
        """Inferred owners for entity"""
        return self._inner_dict.get('inferredOwners')  # type: ignore
    
    @inferredOwners.setter
    def inferredOwners(self, value: Union[None, List["InferredOwnersClass"]]) -> None:
        self._inner_dict['inferredOwners'] = value
    
    
class InferredMetadataSourceClass(DictWrapper):
    """Provenace details corresponding to an inference"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.InferredMetadataSource")
    def __init__(self,
        algorithm: str,
        score: Union[None, float]=None,
        context: Union[None, Dict[str, str]]=None,
        similarityFactors: Union[None, List[Union[str, "SimilarityFactorClass"]]]=None,
    ):
        super().__init__()
        
        self.algorithm = algorithm
        self.score = score
        self.context = context
        self.similarityFactors = similarityFactors
    
    def _restore_defaults(self) -> None:
        self.algorithm = str()
        self.score = self.RECORD_SCHEMA.fields_dict["score"].default
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
        self.similarityFactors = self.RECORD_SCHEMA.fields_dict["similarityFactors"].default
    
    
    @property
    def algorithm(self) -> str:
        """Algorithm used for inference"""
        return self._inner_dict.get('algorithm')  # type: ignore
    
    @algorithm.setter
    def algorithm(self, value: str) -> None:
        self._inner_dict['algorithm'] = value
    
    
    @property
    def score(self) -> Union[None, float]:
        """Inference score - can be used to decide rank of inference
    For same algorithm, higher score represents higher confidence in inference.
    This score is not intended to be compared across multiple algorithms."""
        return self._inner_dict.get('score')  # type: ignore
    
    @score.setter
    def score(self, value: Union[None, float]) -> None:
        self._inner_dict['score'] = value
    
    
    @property
    def context(self) -> Union[None, Dict[str, str]]:
        """Additional details about this inference"""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['context'] = value
    
    
    @property
    def similarityFactors(self) -> Union[None, List[Union[str, "SimilarityFactorClass"]]]:
        """Primary factors contributing to this inference
    Ordering of the array indicates rank."""
        return self._inner_dict.get('similarityFactors')  # type: ignore
    
    @similarityFactors.setter
    def similarityFactors(self, value: Union[None, List[Union[str, "SimilarityFactorClass"]]]) -> None:
        self._inner_dict['similarityFactors'] = value
    
    
class InferredNeighborClass(DictWrapper):
    """Records Urn of inferred neighbor entity and its provenance"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.InferredNeighbor")
    def __init__(self,
        urn: str,
        source: "InferredMetadataSourceClass",
    ):
        super().__init__()
        
        self.urn = urn
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.source = InferredMetadataSourceClass._construct_with_defaults()
    
    
    @property
    def urn(self) -> str:
        """Urn of inferred neighbor entity"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def source(self) -> "InferredMetadataSourceClass":
        """Provenance details about this inference"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: "InferredMetadataSourceClass") -> None:
        self._inner_dict['source'] = value
    
    
class InferredNeighborsClass(_Aspect):
    """Aspect for representing neighbor entities as inferred by various algorithms"""


    ASPECT_NAME = 'inferredNeighbors'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.InferredNeighbors")

    def __init__(self,
        inferredNeighbors: List["InferredNeighborClass"],
    ):
        super().__init__()
        
        self.inferredNeighbors = inferredNeighbors
    
    def _restore_defaults(self) -> None:
        self.inferredNeighbors = list()
    
    
    @property
    def inferredNeighbors(self) -> List["InferredNeighborClass"]:
        """Neighbors of an entity as determined by algorithm"""
        return self._inner_dict.get('inferredNeighbors')  # type: ignore
    
    @inferredNeighbors.setter
    def inferredNeighbors(self, value: List["InferredNeighborClass"]) -> None:
        self._inner_dict['inferredNeighbors'] = value
    
    
class InferredOwnersClass(DictWrapper):
    """Records inferred ownership information along with its provenance
    All owners in this record share same provenance"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.InferredOwners")
    def __init__(self,
        owners: List["OwnerClass"],
        source: "InferredMetadataSourceClass",
    ):
        super().__init__()
        
        self.owners = owners
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.owners = list()
        self.source = InferredMetadataSourceClass._construct_with_defaults()
    
    
    @property
    def owners(self) -> List["OwnerClass"]:
        """Inferred ownership details"""
        return self._inner_dict.get('owners')  # type: ignore
    
    @owners.setter
    def owners(self, value: List["OwnerClass"]) -> None:
        self._inner_dict['owners'] = value
    
    
    @property
    def source(self) -> "InferredMetadataSourceClass":
        """Provenance details about this inference"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: "InferredMetadataSourceClass") -> None:
        self._inner_dict['source'] = value
    
    
class InferredTagsClass(DictWrapper):
    """Records inferred tags along with their provenance
    All tags in this record share same provenance"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.InferredTags")
    def __init__(self,
        tags: List[str],
        source: "InferredMetadataSourceClass",
    ):
        super().__init__()
        
        self.tags = tags
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.tags = list()
        self.source = InferredMetadataSourceClass._construct_with_defaults()
    
    
    @property
    def tags(self) -> List[str]:
        """Urns of inferred Tag"""
        return self._inner_dict.get('tags')  # type: ignore
    
    @tags.setter
    def tags(self, value: List[str]) -> None:
        self._inner_dict['tags'] = value
    
    
    @property
    def source(self) -> "InferredMetadataSourceClass":
        """Provenance details about this inference"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: "InferredMetadataSourceClass") -> None:
        self._inner_dict['source'] = value
    
    
class SchemaFieldInferredMetadataClass(DictWrapper):
    """Inferred Metadata for dataset schema fields"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.SchemaFieldInferredMetadata")
    def __init__(self,
        fieldUrn: str,
        inferredDescriptions: Union[None, List["InferredDescriptionClass"]]=None,
        inferredTags: Union[None, List["InferredTagsClass"]]=None,
        inferredGlossaryTerms: Union[None, List["InferredGlossaryTermsClass"]]=None,
    ):
        super().__init__()
        
        self.fieldUrn = fieldUrn
        self.inferredDescriptions = inferredDescriptions
        self.inferredTags = inferredTags
        self.inferredGlossaryTerms = inferredGlossaryTerms
    
    def _restore_defaults(self) -> None:
        self.fieldUrn = str()
        self.inferredDescriptions = self.RECORD_SCHEMA.fields_dict["inferredDescriptions"].default
        self.inferredTags = self.RECORD_SCHEMA.fields_dict["inferredTags"].default
        self.inferredGlossaryTerms = self.RECORD_SCHEMA.fields_dict["inferredGlossaryTerms"].default
    
    
    @property
    def fieldUrn(self) -> str:
        """SchemaField Urn this metadata is associated with"""
        return self._inner_dict.get('fieldUrn')  # type: ignore
    
    @fieldUrn.setter
    def fieldUrn(self, value: str) -> None:
        self._inner_dict['fieldUrn'] = value
    
    
    @property
    def inferredDescriptions(self) -> Union[None, List["InferredDescriptionClass"]]:
        """Inferred descriptions for schema field"""
        return self._inner_dict.get('inferredDescriptions')  # type: ignore
    
    @inferredDescriptions.setter
    def inferredDescriptions(self, value: Union[None, List["InferredDescriptionClass"]]) -> None:
        self._inner_dict['inferredDescriptions'] = value
    
    
    @property
    def inferredTags(self) -> Union[None, List["InferredTagsClass"]]:
        """Inferred tags for schema field"""
        return self._inner_dict.get('inferredTags')  # type: ignore
    
    @inferredTags.setter
    def inferredTags(self, value: Union[None, List["InferredTagsClass"]]) -> None:
        self._inner_dict['inferredTags'] = value
    
    
    @property
    def inferredGlossaryTerms(self) -> Union[None, List["InferredGlossaryTermsClass"]]:
        """Inferred glossary terms for schema field"""
        return self._inner_dict.get('inferredGlossaryTerms')  # type: ignore
    
    @inferredGlossaryTerms.setter
    def inferredGlossaryTerms(self, value: Union[None, List["InferredGlossaryTermsClass"]]) -> None:
        self._inner_dict['inferredGlossaryTerms'] = value
    
    
class SchemaFieldInferredNeighborsClass(DictWrapper):
    """Neighbors for a particular schema field as inferred by various algorithms"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.SchemaFieldInferredNeighbors")
    def __init__(self,
        fieldUrn: str,
        inferredNeighbors: List["InferredNeighborClass"],
    ):
        super().__init__()
        
        self.fieldUrn = fieldUrn
        self.inferredNeighbors = inferredNeighbors
    
    def _restore_defaults(self) -> None:
        self.fieldUrn = str()
        self.inferredNeighbors = list()
    
    
    @property
    def fieldUrn(self) -> str:
        """SchemaField Urn"""
        return self._inner_dict.get('fieldUrn')  # type: ignore
    
    @fieldUrn.setter
    def fieldUrn(self, value: str) -> None:
        self._inner_dict['fieldUrn'] = value
    
    
    @property
    def inferredNeighbors(self) -> List["InferredNeighborClass"]:
        """Neighbors of a schema field as determined by algorithm"""
        return self._inner_dict.get('inferredNeighbors')  # type: ignore
    
    @inferredNeighbors.setter
    def inferredNeighbors(self, value: List["InferredNeighborClass"]) -> None:
        self._inner_dict['inferredNeighbors'] = value
    
    
class SchemaFieldsInferredMetadataClass(_Aspect):
    """Aspect for representing Inferred Metadata for dataset's schema fields"""


    ASPECT_NAME = 'schemaFieldsInferredMetadata'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.SchemaFieldsInferredMetadata")

    def __init__(self,
        schemaFieldsInferredMetadata: List["SchemaFieldInferredMetadataClass"],
    ):
        super().__init__()
        
        self.schemaFieldsInferredMetadata = schemaFieldsInferredMetadata
    
    def _restore_defaults(self) -> None:
        self.schemaFieldsInferredMetadata = list()
    
    
    @property
    def schemaFieldsInferredMetadata(self) -> List["SchemaFieldInferredMetadataClass"]:
        """Inferred Metadata for dataset's schema fields"""
        return self._inner_dict.get('schemaFieldsInferredMetadata')  # type: ignore
    
    @schemaFieldsInferredMetadata.setter
    def schemaFieldsInferredMetadata(self, value: List["SchemaFieldInferredMetadataClass"]) -> None:
        self._inner_dict['schemaFieldsInferredMetadata'] = value
    
    
class SchemaFieldsInferredNeighborsClass(_Aspect):
    """Aspect for representing Neighbors of dataset's schema fields as determined by algorithm"""


    ASPECT_NAME = 'schemaFieldsInferredNeighbors'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.inferred.SchemaFieldsInferredNeighbors")

    def __init__(self,
        schemaFieldsInferredNeighbors: List["SchemaFieldInferredNeighborsClass"],
    ):
        super().__init__()
        
        self.schemaFieldsInferredNeighbors = schemaFieldsInferredNeighbors
    
    def _restore_defaults(self) -> None:
        self.schemaFieldsInferredNeighbors = list()
    
    
    @property
    def schemaFieldsInferredNeighbors(self) -> List["SchemaFieldInferredNeighborsClass"]:
        """Neighbors of dataset's schema fields as determined by algorithm"""
        return self._inner_dict.get('schemaFieldsInferredNeighbors')  # type: ignore
    
    @schemaFieldsInferredNeighbors.setter
    def schemaFieldsInferredNeighbors(self, value: List["SchemaFieldInferredNeighborsClass"]) -> None:
        self._inner_dict['schemaFieldsInferredNeighbors'] = value
    
    
class SimilarityFactorClass(object):
    """Factors related to an entity"""
    
    ENTITY_NAME = "ENTITY_NAME"
    """Name of entity"""
    
    ENTITY_DESCRIPTION = "ENTITY_DESCRIPTION"
    """Description of entity"""
    
    LINEAGE = "LINEAGE"
    """Lineage of entity"""
    
    DATASET_SCHEMA = "DATASET_SCHEMA"
    """Schema of dataset"""
    
    DATASET_PLATFORM = "DATASET_PLATFORM"
    """Platform of dataset"""
    
    FIELD_NAME = "FIELD_NAME"
    """Name of dataset field"""
    
    FIELD_DESCRIPTION = "FIELD_DESCRIPTION"
    """Description of dataset field"""
    
    FIELD_DATA_TYPE = "FIELD_DATA_TYPE"
    """Datatype of dataset field"""
    
    FIELD_PARENT_DATASET = "FIELD_PARENT_DATASET"
    """Dataset containing the field"""
    
    
    
class DataHubIngestionSourceConfigClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceConfig")
    def __init__(self,
        recipe: str,
        version: Union[None, str]=None,
        executorId: Union[None, str]=None,
        debugMode: Union[None, bool]=None,
        extraArgs: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.recipe = recipe
        self.version = version
        self.executorId = executorId
        self.debugMode = debugMode
        self.extraArgs = extraArgs
    
    def _restore_defaults(self) -> None:
        self.recipe = str()
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
        self.executorId = self.RECORD_SCHEMA.fields_dict["executorId"].default
        self.debugMode = self.RECORD_SCHEMA.fields_dict["debugMode"].default
        self.extraArgs = self.RECORD_SCHEMA.fields_dict["extraArgs"].default
    
    
    @property
    def recipe(self) -> str:
        """The JSON recipe to use for ingestion"""
        return self._inner_dict.get('recipe')  # type: ignore
    
    @recipe.setter
    def recipe(self, value: str) -> None:
        self._inner_dict['recipe'] = value
    
    
    @property
    def version(self) -> Union[None, str]:
        """The PyPI version of the datahub CLI to use when executing a recipe"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, str]) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def executorId(self) -> Union[None, str]:
        """The id of the executor pool to use to execute the ingestion run"""
        return self._inner_dict.get('executorId')  # type: ignore
    
    @executorId.setter
    def executorId(self, value: Union[None, str]) -> None:
        self._inner_dict['executorId'] = value
    
    
    @property
    def debugMode(self) -> Union[None, bool]:
        """Whether or not to run this ingestion source in debug mode"""
        return self._inner_dict.get('debugMode')  # type: ignore
    
    @debugMode.setter
    def debugMode(self, value: Union[None, bool]) -> None:
        self._inner_dict['debugMode'] = value
    
    
    @property
    def extraArgs(self) -> Union[None, Dict[str, str]]:
        """Extra arguments for the ingestion run."""
        return self._inner_dict.get('extraArgs')  # type: ignore
    
    @extraArgs.setter
    def extraArgs(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['extraArgs'] = value
    
    
class DataHubIngestionSourceInfoClass(_Aspect):
    """Info about a DataHub ingestion source"""


    ASPECT_NAME = 'dataHubIngestionSourceInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceInfo")

    def __init__(self,
        name: str,
        type: str,
        config: "DataHubIngestionSourceConfigClass",
        platform: Union[None, str]=None,
        schedule: Union[None, "DataHubIngestionSourceScheduleClass"]=None,
        source: Union[None, "DataHubIngestionSourceSourceClass"]=None,
    ):
        super().__init__()
        
        self.name = name
        self.type = type
        self.platform = platform
        self.schedule = schedule
        self.config = config
        self.source = source
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.type = str()
        self.platform = self.RECORD_SCHEMA.fields_dict["platform"].default
        self.schedule = self.RECORD_SCHEMA.fields_dict["schedule"].default
        self.config = DataHubIngestionSourceConfigClass._construct_with_defaults()
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
    
    
    @property
    def name(self) -> str:
        """The display name of the ingestion source"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def type(self) -> str:
        """The type of the source itself, e.g. mysql, bigquery, bigquery-usage. Should match the recipe."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def platform(self) -> Union[None, str]:
        """Data Platform URN associated with the source"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: Union[None, str]) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def schedule(self) -> Union[None, "DataHubIngestionSourceScheduleClass"]:
        """The schedule on which the ingestion source is executed"""
        return self._inner_dict.get('schedule')  # type: ignore
    
    @schedule.setter
    def schedule(self, value: Union[None, "DataHubIngestionSourceScheduleClass"]) -> None:
        self._inner_dict['schedule'] = value
    
    
    @property
    def config(self) -> "DataHubIngestionSourceConfigClass":
        """Parameters associated with the Ingestion Source"""
        return self._inner_dict.get('config')  # type: ignore
    
    @config.setter
    def config(self, value: "DataHubIngestionSourceConfigClass") -> None:
        self._inner_dict['config'] = value
    
    
    @property
    def source(self) -> Union[None, "DataHubIngestionSourceSourceClass"]:
        """The source or origin of the Ingestion Source
    
    Currently CLI and UI do not provide an explicit source."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "DataHubIngestionSourceSourceClass"]) -> None:
        self._inner_dict['source'] = value
    
    
class DataHubIngestionSourceScheduleClass(DictWrapper):
    """The schedule associated with an ingestion source."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceSchedule")
    def __init__(self,
        interval: str,
        timezone: str,
    ):
        super().__init__()
        
        self.interval = interval
        self.timezone = timezone
    
    def _restore_defaults(self) -> None:
        self.interval = str()
        self.timezone = str()
    
    
    @property
    def interval(self) -> str:
        """A cron-formatted execution interval, as a cron string, e.g. * * * * *"""
        return self._inner_dict.get('interval')  # type: ignore
    
    @interval.setter
    def interval(self, value: str) -> None:
        self._inner_dict['interval'] = value
    
    
    @property
    def timezone(self) -> str:
        """Timezone in which the cron interval applies, e.g. America/Los Angeles"""
        return self._inner_dict.get('timezone')  # type: ignore
    
    @timezone.setter
    def timezone(self, value: str) -> None:
        self._inner_dict['timezone'] = value
    
    
class DataHubIngestionSourceSourceClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceSource")
    def __init__(self,
        type: Union[str, "DataHubIngestionSourceSourceTypeClass"],
    ):
        super().__init__()
        
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.type = DataHubIngestionSourceSourceTypeClass.SYSTEM
    
    
    @property
    def type(self) -> Union[str, "DataHubIngestionSourceSourceTypeClass"]:
        """The source type of the ingestion source"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DataHubIngestionSourceSourceTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class DataHubIngestionSourceSourceTypeClass(object):
    # No docs available.
    
    SYSTEM = "SYSTEM"
    """A system internal source, e.g. for running search indexing operations, feature computation, etc."""
    
    
    
class DocumentContentsClass(DictWrapper):
    """The contents of a document"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.knowledge.DocumentContents")
    def __init__(self,
        text: str,
    ):
        super().__init__()
        
        self.text = text
    
    def _restore_defaults(self) -> None:
        self.text = str()
    
    
    @property
    def text(self) -> str:
        """The text contents of the document.
    This needs to be added to semantic search! """
        return self._inner_dict.get('text')  # type: ignore
    
    @text.setter
    def text(self, value: str) -> None:
        self._inner_dict['text'] = value
    
    
class DocumentInfoClass(_Aspect):
    """Information about a document"""


    ASPECT_NAME = 'documentInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.knowledge.DocumentInfo")

    def __init__(self,
        status: "DocumentStatusClass",
        contents: "DocumentContentsClass",
        created: "AuditStampClass",
        lastModified: "AuditStampClass",
        customProperties: Optional[Dict[str, str]]=None,
        title: Union[None, str]=None,
        source: Union[None, "DocumentSourceClass"]=None,
        relatedAssets: Union[None, List["RelatedAssetClass"]]=None,
        relatedDocuments: Union[None, List["RelatedDocumentClass"]]=None,
        parentDocument: Union[None, "ParentDocumentClass"]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.title = title
        self.source = source
        self.status = status
        self.contents = contents
        self.created = created
        self.lastModified = lastModified
        self.relatedAssets = relatedAssets
        self.relatedDocuments = relatedDocuments
        self.parentDocument = parentDocument
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.title = self.RECORD_SCHEMA.fields_dict["title"].default
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
        self.status = DocumentStatusClass._construct_with_defaults()
        self.contents = DocumentContentsClass._construct_with_defaults()
        self.created = AuditStampClass._construct_with_defaults()
        self.lastModified = AuditStampClass._construct_with_defaults()
        self.relatedAssets = self.RECORD_SCHEMA.fields_dict["relatedAssets"].default
        self.relatedDocuments = self.RECORD_SCHEMA.fields_dict["relatedDocuments"].default
        self.parentDocument = self.RECORD_SCHEMA.fields_dict["parentDocument"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def title(self) -> Union[None, str]:
        """Optional title for the document. """
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: Union[None, str]) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def source(self) -> Union[None, "DocumentSourceClass"]:
        """Information about the external source of this document. 
    Only populated for third-party documents ingested from external systems."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "DocumentSourceClass"]) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def status(self) -> "DocumentStatusClass":
        """Status of the document (published, unpublished.)"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: "DocumentStatusClass") -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def contents(self) -> "DocumentContentsClass":
        """Content of the document"""
        return self._inner_dict.get('contents')  # type: ignore
    
    @contents.setter
    def contents(self, value: "DocumentContentsClass") -> None:
        self._inner_dict['contents'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """The time and actor who created the document"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """The time and actor who last modified the document (any field)"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def relatedAssets(self) -> Union[None, List["RelatedAssetClass"]]:
        """Assets referenced by or related to this document. """
        return self._inner_dict.get('relatedAssets')  # type: ignore
    
    @relatedAssets.setter
    def relatedAssets(self, value: Union[None, List["RelatedAssetClass"]]) -> None:
        self._inner_dict['relatedAssets'] = value
    
    
    @property
    def relatedDocuments(self) -> Union[None, List["RelatedDocumentClass"]]:
        """Documents referenced by or related to this document. """
        return self._inner_dict.get('relatedDocuments')  # type: ignore
    
    @relatedDocuments.setter
    def relatedDocuments(self, value: Union[None, List["RelatedDocumentClass"]]) -> None:
        self._inner_dict['relatedDocuments'] = value
    
    
    @property
    def parentDocument(self) -> Union[None, "ParentDocumentClass"]:
        """Parent article for this asset. """
        return self._inner_dict.get('parentDocument')  # type: ignore
    
    @parentDocument.setter
    def parentDocument(self, value: Union[None, "ParentDocumentClass"]) -> None:
        self._inner_dict['parentDocument'] = value
    
    
class DocumentSettingsClass(_Aspect):
    """Settings specific to a document entity"""


    ASPECT_NAME = 'documentSettings'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.knowledge.DocumentSettings")

    def __init__(self,
        showInGlobalContext: Optional[bool]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        if showInGlobalContext is None:
            # default: True
            self.showInGlobalContext = self.RECORD_SCHEMA.fields_dict["showInGlobalContext"].default
        else:
            self.showInGlobalContext = showInGlobalContext
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.showInGlobalContext = self.RECORD_SCHEMA.fields_dict["showInGlobalContext"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
    
    
    @property
    def showInGlobalContext(self) -> bool:
        """Whether or not this document should be visible in the global context (e.g., global navigation, knowledge base search).
    When false, the document is "private" and accessible primarily through the assets it is related to.
    When true, the document appears in the global documents space accessible to all users."""
        return self._inner_dict.get('showInGlobalContext')  # type: ignore
    
    @showInGlobalContext.setter
    def showInGlobalContext(self, value: bool) -> None:
        self._inner_dict['showInGlobalContext'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """Last Modified Audit stamp"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
class DocumentSourceClass(DictWrapper):
    """Information about the source of a document, especially for externally sourced documents.
    This record is embedded within DocumentInfo to track whether a document is first-party 
    (created in DataHub) or third-party (ingested from external sources like Slack, Notion, etc.)"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.knowledge.DocumentSource")
    def __init__(self,
        sourceType: Union[str, "DocumentSourceTypeClass"],
        externalUrl: Union[None, str]=None,
        externalId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.sourceType = sourceType
        self.externalUrl = externalUrl
        self.externalId = externalId
    
    def _restore_defaults(self) -> None:
        self.sourceType = DocumentSourceTypeClass.NATIVE
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.externalId = self.RECORD_SCHEMA.fields_dict["externalId"].default
    
    
    @property
    def sourceType(self) -> Union[str, "DocumentSourceTypeClass"]:
        """The type of the source (e.g., "Confluence", "Notion", "Google Docs", "SharePoint", "Slack")"""
        return self._inner_dict.get('sourceType')  # type: ignore
    
    @sourceType.setter
    def sourceType(self, value: Union[str, "DocumentSourceTypeClass"]) -> None:
        self._inner_dict['sourceType'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL to the external source where this document originated"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def externalId(self) -> Union[None, str]:
        """Unique identifier in the external system. Searchable in case we need to find ingested docs via filtering."""
        return self._inner_dict.get('externalId')  # type: ignore
    
    @externalId.setter
    def externalId(self, value: Union[None, str]) -> None:
        self._inner_dict['externalId'] = value
    
    
class DocumentSourceTypeClass(object):
    # No docs available.
    
    NATIVE = "NATIVE"
    """Created via the DataHub UI or API"""
    
    EXTERNAL = "EXTERNAL"
    """External - The document was ingested from an external source. """
    
    
    
class DocumentStateClass(object):
    """The state of a document"""
    
    PUBLISHED = "PUBLISHED"
    """Document is published and visible to others."""
    
    UNPUBLISHED = "UNPUBLISHED"
    """Document is not published to be consumed by others."""
    
    
    
class DocumentStatusClass(DictWrapper):
    """Visibility status information for a document"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.knowledge.DocumentStatus")
    def __init__(self,
        state: Union[str, "DocumentStateClass"],
    ):
        super().__init__()
        
        self.state = state
    
    def _restore_defaults(self) -> None:
        self.state = DocumentStateClass.PUBLISHED
    
    
    @property
    def state(self) -> Union[str, "DocumentStateClass"]:
        """The current visibility state of the document"""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[str, "DocumentStateClass"]) -> None:
        self._inner_dict['state'] = value
    
    
class ParentDocumentClass(DictWrapper):
    """The parent document of the document. """
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.knowledge.ParentDocument")
    def __init__(self,
        document: str,
    ):
        super().__init__()
        
        self.document = document
    
    def _restore_defaults(self) -> None:
        self.document = str()
    
    
    @property
    def document(self) -> str:
        """The hierarchical parent document for this document. """
        return self._inner_dict.get('document')  # type: ignore
    
    @document.setter
    def document(self, value: str) -> None:
        self._inner_dict['document'] = value
    
    
class RelatedAssetClass(DictWrapper):
    """A data asset referenced by a document."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.knowledge.RelatedAsset")
    def __init__(self,
        asset: str,
    ):
        super().__init__()
        
        self.asset = asset
    
    def _restore_defaults(self) -> None:
        self.asset = str()
    
    
    @property
    def asset(self) -> str:
        """The asset referenced by or related to the document. """
        return self._inner_dict.get('asset')  # type: ignore
    
    @asset.setter
    def asset(self, value: str) -> None:
        self._inner_dict['asset'] = value
    
    
class RelatedDocumentClass(DictWrapper):
    """An document referenced by or related to another document
    Note that this does NOT include child documents. """
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.knowledge.RelatedDocument")
    def __init__(self,
        document: str,
    ):
        super().__init__()
        
        self.document = document
    
    def _restore_defaults(self) -> None:
        self.document = str()
    
    
    @property
    def document(self) -> str:
        """The document referenced by or related to the document. """
        return self._inner_dict.get('document')  # type: ignore
    
    @document.setter
    def document(self, value: str) -> None:
        self._inner_dict['document'] = value
    
    
class LinkPreviewInfoClass(_Aspect):
    """Information about a Link Preview"""


    ASPECT_NAME = 'linkPreviewInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.link.LinkPreviewInfo")

    def __init__(self,
        type: Union[str, "LinkPreviewTypeClass"],
        json: str,
        lastRefreshedMs: int,
    ):
        super().__init__()
        
        self.type = type
        self.json = json
        self.lastRefreshedMs = lastRefreshedMs
    
    def _restore_defaults(self) -> None:
        self.type = LinkPreviewTypeClass.SLACK_MESSAGE
        self.json = str()
        self.lastRefreshedMs = int()
    
    
    @property
    def type(self) -> Union[str, "LinkPreviewTypeClass"]:
        """The type of the Link Preview"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "LinkPreviewTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def json(self) -> str:
        """The JSON-encoded preview. Understood and rendered by DataHub UI."""
        return self._inner_dict.get('json')  # type: ignore
    
    @json.setter
    def json(self, value: str) -> None:
        self._inner_dict['json'] = value
    
    
    @property
    def lastRefreshedMs(self) -> int:
        """The time at which the preview was last refreshed."""
        return self._inner_dict.get('lastRefreshedMs')  # type: ignore
    
    @lastRefreshedMs.setter
    def lastRefreshedMs(self, value: int) -> None:
        self._inner_dict['lastRefreshedMs'] = value
    
    
class LinkPreviewTypeClass(object):
    # No docs available.
    
    SLACK_MESSAGE = "SLACK_MESSAGE"
    """Preview of a Slack Message"""
    
    TEAMS_MESSAGE = "TEAMS_MESSAGE"
    """Preview of a Microsoft Teams Message"""
    
    
    
class LogicalParentClass(_Aspect):
    """Relates a physical asset to a logical model."""


    ASPECT_NAME = 'logicalParent'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.logical.LogicalParent")

    def __init__(self,
        parent: Union[None, "EdgeClass"]=None,
    ):
        super().__init__()
        
        self.parent = parent
    
    def _restore_defaults(self) -> None:
        self.parent = self.RECORD_SCHEMA.fields_dict["parent"].default
    
    
    @property
    def parent(self) -> Union[None, "EdgeClass"]:
        # No docs available.
        return self._inner_dict.get('parent')  # type: ignore
    
    @parent.setter
    def parent(self, value: Union[None, "EdgeClass"]) -> None:
        self._inner_dict['parent'] = value
    
    
class ActionRequestKeyClass(_Aspect):
    """Key for an ActionRequest"""


    ASPECT_NAME = 'actionRequestKey'
    ASPECT_INFO = {'keyForEntity': 'actionRequest', 'entityCategory': 'internal', 'entityAspects': ['actionRequestStatus', 'actionRequestInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.ActionRequestKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        # No docs available.
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class ActionWorkflowKeyClass(_Aspect):
    """Key for an ActionRequestWorkflow"""


    ASPECT_NAME = 'actionWorkflowKey'
    ASPECT_INFO = {'keyForEntity': 'actionWorkflow', 'entityCategory': 'internal', 'entityAspects': ['actionWorkflowInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.ActionWorkflowKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """ The unique identifier for the workflow """
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class AnomalyKeyClass(_Aspect):
    """Key for an asset Anomaly"""


    ASPECT_NAME = 'anomalyKey'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.AnomalyKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the anomaly. Generated on the server side at anomaly creation time."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class AssertionKeyClass(_Aspect):
    """Key for a Assertion"""


    ASPECT_NAME = 'assertionKey'
    ASPECT_INFO = {'keyForEntity': 'assertion', 'entityCategory': 'core', 'entityAspects': ['assertionInfo', 'dataPlatformInstance', 'assertionRunEvent', 'assertionActions', 'status', 'globalTags', 'lineageFeatures', 'assertionRunSummary', 'assertionAnalyticsRunEvent', 'assertionDryRunEvent', 'assertionInferenceDetails'], 'entityDoc': 'Assertion represents a data quality rule applied on one or more dataset.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.AssertionKey")

    def __init__(self,
        assertionId: str,
    ):
        super().__init__()
        
        self.assertionId = assertionId
    
    def _restore_defaults(self) -> None:
        self.assertionId = str()
    
    
    @property
    def assertionId(self) -> str:
        """Unique id for the assertion."""
        return self._inner_dict.get('assertionId')  # type: ignore
    
    @assertionId.setter
    def assertionId(self, value: str) -> None:
        self._inner_dict['assertionId'] = value
    
    
class ChartKeyClass(_Aspect):
    """Key for a Chart"""


    ASPECT_NAME = 'chartKey'
    ASPECT_INFO = {'keyForEntity': 'chart', 'entityCategory': 'core', 'entityAspects': ['chartInfo', 'editableChartProperties', 'chartQuery', 'inputFields', 'chartUsageStatistics', 'embed', 'browsePaths', 'domains', 'applications', 'container', 'deprecation', 'ownership', 'status', 'institutionalMemory', 'dataPlatformInstance', 'globalTags', 'glossaryTerms', 'browsePathsV2', 'subTypes', 'structuredProperties', 'incidentsSummary', 'forms', 'testResults', 'usageFeatures', 'lineageFeatures', 'proposals', 'share', 'origin', 'documentation']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.ChartKey")

    def __init__(self,
        dashboardTool: str,
        chartId: str,
    ):
        super().__init__()
        
        self.dashboardTool = dashboardTool
        self.chartId = chartId
    
    def _restore_defaults(self) -> None:
        self.dashboardTool = str()
        self.chartId = str()
    
    
    @property
    def dashboardTool(self) -> str:
        """The name of the dashboard tool such as looker, redash etc."""
        return self._inner_dict.get('dashboardTool')  # type: ignore
    
    @dashboardTool.setter
    def dashboardTool(self, value: str) -> None:
        self._inner_dict['dashboardTool'] = value
    
    
    @property
    def chartId(self) -> str:
        """Unique id for the chart. This id should be globally unique for a dashboarding tool even when there are multiple deployments of it. As an example, chart URL could be used here for Looker such as 'looker.linkedin.com/looks/1234'"""
        return self._inner_dict.get('chartId')  # type: ignore
    
    @chartId.setter
    def chartId(self, value: str) -> None:
        self._inner_dict['chartId'] = value
    
    
class ConstraintKeyClass(_Aspect):
    """Key for a Constraint"""


    ASPECT_NAME = 'constraintKey'
    ASPECT_INFO = {'keyForEntity': 'constraint', 'entityCategory': '_unset_', 'entityAspects': ['constraintInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.ConstraintKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        # No docs available.
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class ContainerKeyClass(_Aspect):
    """Key for an Asset Container"""


    ASPECT_NAME = 'containerKey'
    ASPECT_INFO = {'keyForEntity': 'container', 'entityCategory': 'core', 'entityAspects': ['containerProperties', 'editableContainerProperties', 'dataPlatformInstance', 'subTypes', 'ownership', 'deprecation', 'container', 'globalTags', 'glossaryTerms', 'institutionalMemory', 'browsePaths', 'status', 'domains', 'applications', 'browsePathsV2', 'structuredProperties', 'forms', 'testResults', 'access', 'proposals', 'share', 'origin', 'documentation'], 'entityDoc': 'A container of related data assets.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.ContainerKey")

    def __init__(self,
        guid: Union[None, str]=None,
    ):
        super().__init__()
        
        self.guid = guid
    
    def _restore_defaults(self) -> None:
        self.guid = self.RECORD_SCHEMA.fields_dict["guid"].default
    
    
    @property
    def guid(self) -> Union[None, str]:
        """Unique guid for container"""
        return self._inner_dict.get('guid')  # type: ignore
    
    @guid.setter
    def guid(self, value: Union[None, str]) -> None:
        self._inner_dict['guid'] = value
    
    
class CorpGroupKeyClass(_Aspect):
    """Key for a CorpGroup"""


    ASPECT_NAME = 'corpGroupKey'
    ASPECT_INFO = {'keyForEntity': 'corpGroup', 'entityCategory': '_unset_', 'entityAspects': ['corpGroupInfo', 'corpGroupEditableInfo', 'globalTags', 'ownership', 'status', 'origin', 'roleMembership', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'corpGroupSettings', 'share', 'formNotifications'], 'entityDoc': 'CorpGroup represents an identity of a group of users in the enterprise.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.CorpGroupKey")

    def __init__(self,
        name: str,
    ):
        super().__init__()
        
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.name = str()
    
    
    @property
    def name(self) -> str:
        """The URL-encoded name of the AD/LDAP group. Serves as a globally unique identifier within DataHub."""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class CorpUserKeyClass(_Aspect):
    """Key for a CorpUser"""


    ASPECT_NAME = 'corpUserKey'
    ASPECT_INFO = {'keyForEntity': 'corpuser', 'entityCategory': '_unset_', 'entityAspects': ['corpUserInfo', 'corpUserEditableInfo', 'corpUserStatus', 'groupMembership', 'globalTags', 'status', 'corpUserCredentials', 'nativeGroupMembership', 'corpUserSettings', 'origin', 'roleMembership', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'slackUserInfo', 'corpUserUsageFeatures', 'corpUserInvitationStatus', 'share', 'formNotifications'], 'entityDoc': 'CorpUser represents an identity of a person (or an account) in the enterprise.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.CorpUserKey")

    def __init__(self,
        username: str,
    ):
        super().__init__()
        
        self.username = username
    
    def _restore_defaults(self) -> None:
        self.username = str()
    
    
    @property
    def username(self) -> str:
        """The name of the AD/LDAP user."""
        return self._inner_dict.get('username')  # type: ignore
    
    @username.setter
    def username(self, value: str) -> None:
        self._inner_dict['username'] = value
    
    
class DashboardKeyClass(_Aspect):
    """Key for a Dashboard"""


    ASPECT_NAME = 'dashboardKey'
    ASPECT_INFO = {'keyForEntity': 'dashboard', 'entityCategory': '_unset_', 'entityAspects': ['domains', 'applications', 'container', 'deprecation', 'dashboardUsageStatistics', 'inputFields', 'subTypes', 'embed', 'dashboardInfo', 'editableDashboardProperties', 'ownership', 'status', 'globalTags', 'browsePaths', 'glossaryTerms', 'institutionalMemory', 'dataPlatformInstance', 'browsePathsV2', 'structuredProperties', 'incidentsSummary', 'forms', 'testResults', 'usageFeatures', 'lineageFeatures', 'proposals', 'share', 'origin', 'documentation']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DashboardKey")

    def __init__(self,
        dashboardTool: str,
        dashboardId: str,
    ):
        super().__init__()
        
        self.dashboardTool = dashboardTool
        self.dashboardId = dashboardId
    
    def _restore_defaults(self) -> None:
        self.dashboardTool = str()
        self.dashboardId = str()
    
    
    @property
    def dashboardTool(self) -> str:
        """The name of the dashboard tool such as looker, redash etc."""
        return self._inner_dict.get('dashboardTool')  # type: ignore
    
    @dashboardTool.setter
    def dashboardTool(self, value: str) -> None:
        self._inner_dict['dashboardTool'] = value
    
    
    @property
    def dashboardId(self) -> str:
        """Unique id for the dashboard. This id should be globally unique for a dashboarding tool even when there are multiple deployments of it. As an example, dashboard URL could be used here for Looker such as 'looker.linkedin.com/dashboards/1234'"""
        return self._inner_dict.get('dashboardId')  # type: ignore
    
    @dashboardId.setter
    def dashboardId(self, value: str) -> None:
        self._inner_dict['dashboardId'] = value
    
    
class DataContractKeyClass(_Aspect):
    """Key for a Data Contract"""


    ASPECT_NAME = 'dataContractKey'
    ASPECT_INFO = {'keyForEntity': 'dataContract', 'entityCategory': 'core', 'entityAspects': ['dataContractProperties', 'dataContractStatus', 'status', 'structuredProperties']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataContractKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique id for the contract"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataFlowKeyClass(_Aspect):
    """Key for a Data Flow"""


    ASPECT_NAME = 'dataFlowKey'
    ASPECT_INFO = {'keyForEntity': 'dataFlow', 'entityCategory': 'core', 'entityAspects': ['domains', 'applications', 'deprecation', 'versionInfo', 'dataFlowInfo', 'editableDataFlowProperties', 'ownership', 'status', 'globalTags', 'browsePaths', 'glossaryTerms', 'institutionalMemory', 'dataPlatformInstance', 'container', 'browsePathsV2', 'structuredProperties', 'incidentsSummary', 'forms', 'subTypes', 'testResults', 'proposals', 'share', 'origin', 'lineageFeatures', 'documentation']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataFlowKey")

    def __init__(self,
        orchestrator: str,
        flowId: str,
        cluster: str,
    ):
        super().__init__()
        
        self.orchestrator = orchestrator
        self.flowId = flowId
        self.cluster = cluster
    
    def _restore_defaults(self) -> None:
        self.orchestrator = str()
        self.flowId = str()
        self.cluster = str()
    
    
    @property
    def orchestrator(self) -> str:
        """Workflow manager like azkaban, airflow which orchestrates the flow"""
        return self._inner_dict.get('orchestrator')  # type: ignore
    
    @orchestrator.setter
    def orchestrator(self, value: str) -> None:
        self._inner_dict['orchestrator'] = value
    
    
    @property
    def flowId(self) -> str:
        """Unique Identifier of the data flow"""
        return self._inner_dict.get('flowId')  # type: ignore
    
    @flowId.setter
    def flowId(self, value: str) -> None:
        self._inner_dict['flowId'] = value
    
    
    @property
    def cluster(self) -> str:
        """Cluster where the flow is executed"""
        return self._inner_dict.get('cluster')  # type: ignore
    
    @cluster.setter
    def cluster(self, value: str) -> None:
        self._inner_dict['cluster'] = value
    
    
class DataHubAccessTokenKeyClass(_Aspect):
    """Key for a DataHub Access Token"""


    ASPECT_NAME = 'dataHubAccessTokenKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubAccessToken', 'entityCategory': 'internal', 'entityAspects': ['dataHubAccessTokenInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubAccessTokenKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Access token's SHA-256 hashed JWT signature"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubActionKeyClass(_Aspect):
    """Key for a DataHub Action Pipeline"""


    ASPECT_NAME = 'dataHubActionKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubAction', 'entityCategory': 'internal', 'entityAspects': ['dataHubActionInfo', 'dataHubActionStatus']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubActionKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the Action, either generated or provided"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubAiConversationKeyClass(_Aspect):
    """Key for a DataHub conversation"""


    ASPECT_NAME = 'dataHubAiConversationKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubAiConversation', 'entityCategory': 'core', 'entityAspects': ['dataHubAiConversationInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubAiConversationKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique identifier for the conversation"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubConnectionKeyClass(_Aspect):
    """Key for a Connection"""


    ASPECT_NAME = 'dataHubConnectionKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubConnection', 'entityCategory': 'internal', 'entityAspects': ['dataHubConnectionDetails', 'dataPlatformInstance', 'status']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubConnectionKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique identifier for the connection."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubFileKeyClass(_Aspect):
    """Key for a DataHubFile"""


    ASPECT_NAME = 'dataHubFileKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubFile', 'entityCategory': 'core', 'entityAspects': ['dataHubFileInfo', 'status']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubFileKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique id for the file."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubIngestionSourceKeyClass(_Aspect):
    """Key for a DataHub ingestion source"""


    ASPECT_NAME = 'dataHubIngestionSourceKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubIngestionSource', 'entityCategory': 'internal', 'entityAspects': ['dataHubIngestionSourceInfo', 'ownership']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubIngestionSourceKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the Ingestion Source, either generated or provided"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubMetricCubeKeyClass(_Aspect):
    """Key for a DataHub Metric Cube, e.g. an internal metric."""


    ASPECT_NAME = 'dataHubMetricCubeKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubMetricCube', 'entityCategory': 'internal', 'entityAspects': ['dataHubMetricCubeDefinition', 'dataHubMetricCubeEvent']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubMetricCubeKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique id for the cube type."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubOpenAPISchemaKeyClass(_Aspect):
    """Key for a Query"""


    ASPECT_NAME = 'dataHubOpenAPISchemaKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubOpenAPISchema', 'entityCategory': 'internal', 'entityAspects': ['systemMetadata'], 'entityDoc': 'Contains aspects which are used in OpenAPI requests/responses which are not otherwise present in the data model.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubOpenAPISchemaKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the DataHub OpenAPI schema."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubPageModuleKeyClass(_Aspect):
    """Key for a DataHubPageModule"""


    ASPECT_NAME = 'dataHubPageModuleKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubPageModule', 'entityCategory': 'core', 'entityAspects': ['dataHubPageModuleProperties']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubPageModuleKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique id for the module."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubPageTemplateKeyClass(_Aspect):
    """Key for a DataHubPageTemplate"""


    ASPECT_NAME = 'dataHubPageTemplateKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubPageTemplate', 'entityCategory': 'core', 'entityAspects': ['dataHubPageTemplateProperties']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubPageTemplateKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique id for the template."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubPersonaKeyClass(_Aspect):
    """Key for a persona type"""


    ASPECT_NAME = 'dataHubPersonaKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubPersona', 'entityCategory': 'internal', 'entityAspects': ['dataHubPersonaInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubPersonaKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the persona type"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubPolicyKeyClass(_Aspect):
    """Key for a DataHub Policy"""


    ASPECT_NAME = 'dataHubPolicyKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubPolicy', 'entityCategory': 'internal', 'entityAspects': ['dataHubPolicyInfo'], 'entityDoc': 'DataHub Policies represent access policies granted to users or groups on metadata operations like edit, view etc.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubPolicyKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the DataHub access policy record. Generated on the server side at policy creation time."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubRetentionKeyClass(_Aspect):
    """Key for a DataHub Retention"""


    ASPECT_NAME = 'dataHubRetentionKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubRetention', 'entityCategory': 'internal', 'entityAspects': ['dataHubRetentionConfig']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubRetentionKey")

    def __init__(self,
        entityName: str,
        aspectName: str,
    ):
        super().__init__()
        
        self.entityName = entityName
        self.aspectName = aspectName
    
    def _restore_defaults(self) -> None:
        self.entityName = str()
        self.aspectName = str()
    
    
    @property
    def entityName(self) -> str:
        """Entity name to apply retention to. * (or empty) for applying defaults."""
        return self._inner_dict.get('entityName')  # type: ignore
    
    @entityName.setter
    def entityName(self, value: str) -> None:
        self._inner_dict['entityName'] = value
    
    
    @property
    def aspectName(self) -> str:
        """Aspect name to apply retention to. * (or empty) for applying defaults."""
        return self._inner_dict.get('aspectName')  # type: ignore
    
    @aspectName.setter
    def aspectName(self, value: str) -> None:
        self._inner_dict['aspectName'] = value
    
    
class DataHubRoleKeyClass(_Aspect):
    """Key for a DataHub Role"""


    ASPECT_NAME = 'dataHubRoleKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubRole', 'entityCategory': 'core', 'entityAspects': ['dataHubRoleInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubRoleKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the DataHub role record. Generated on the server side at role creation time."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubSecretKeyClass(_Aspect):
    """Key for a DataHub Secret"""


    ASPECT_NAME = 'dataHubSecretKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubSecret', 'entityCategory': 'internal', 'entityAspects': ['dataHubSecretValue']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubSecretKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the Secret"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubStepStateKeyClass(_Aspect):
    """Key for a DataHub Step State"""


    ASPECT_NAME = 'dataHubStepStateKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubStepState', 'entityCategory': 'internal', 'entityAspects': ['dataHubStepStateProperties']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubStepStateKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the state"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubUpgradeKeyClass(_Aspect):
    """Key for a DataHubUpgrade"""


    ASPECT_NAME = 'dataHubUpgradeKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubUpgrade', 'entityCategory': 'internal', 'entityAspects': ['dataHubUpgradeRequest', 'dataHubUpgradeResult']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubUpgradeKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        # No docs available.
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubViewKeyClass(_Aspect):
    """Key for a DataHub View"""


    ASPECT_NAME = 'dataHubViewKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubView', 'entityCategory': 'core', 'entityAspects': ['dataHubViewInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataHubViewKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the View"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataJobKeyClass(_Aspect):
    """Key for a Data Job"""


    ASPECT_NAME = 'dataJobKey'
    ASPECT_INFO = {'keyForEntity': 'dataJob', 'entityCategory': '_unset_', 'entityAspects': ['datahubIngestionRunSummary', 'datahubIngestionCheckpoint', 'domains', 'applications', 'deprecation', 'versionInfo', 'dataJobInfo', 'dataJobInputOutput', 'editableDataJobProperties', 'ownership', 'status', 'globalTags', 'browsePaths', 'glossaryTerms', 'institutionalMemory', 'dataPlatformInstance', 'container', 'browsePathsV2', 'structuredProperties', 'forms', 'subTypes', 'incidentsSummary', 'testResults', 'dataTransformLogic', 'proposals', 'anomaliesSummary', 'share', 'origin', 'lineageFeatures', 'documentation']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataJobKey")

    def __init__(self,
        flow: str,
        jobId: str,
    ):
        super().__init__()
        
        self.flow = flow
        self.jobId = jobId
    
    def _restore_defaults(self) -> None:
        self.flow = str()
        self.jobId = str()
    
    
    @property
    def flow(self) -> str:
        """Standardized data processing flow urn representing the flow for the job"""
        return self._inner_dict.get('flow')  # type: ignore
    
    @flow.setter
    def flow(self, value: str) -> None:
        self._inner_dict['flow'] = value
    
    
    @property
    def jobId(self) -> str:
        """Unique Identifier of the data job"""
        return self._inner_dict.get('jobId')  # type: ignore
    
    @jobId.setter
    def jobId(self, value: str) -> None:
        self._inner_dict['jobId'] = value
    
    
class DataPlatformInstanceKeyClass(_Aspect):
    """Key for a Dataset"""


    ASPECT_NAME = 'dataPlatformInstanceKey'
    ASPECT_INFO = {'keyForEntity': 'dataPlatformInstance', 'entityCategory': 'internal', 'entityAspects': ['dataPlatformInstanceProperties', 'ownership', 'globalTags', 'institutionalMemory', 'deprecation', 'status', 'icebergWarehouseInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataPlatformInstanceKey")

    def __init__(self,
        platform: str,
        instance: str,
    ):
        super().__init__()
        
        self.platform = platform
        self.instance = instance
    
    def _restore_defaults(self) -> None:
        self.platform = str()
        self.instance = str()
    
    
    @property
    def platform(self) -> str:
        """Data platform urn associated with the instance"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def instance(self) -> str:
        """Unique instance id"""
        return self._inner_dict.get('instance')  # type: ignore
    
    @instance.setter
    def instance(self, value: str) -> None:
        self._inner_dict['instance'] = value
    
    
class DataPlatformKeyClass(_Aspect):
    """Key for a Data Platform"""


    ASPECT_NAME = 'dataPlatformKey'
    ASPECT_INFO = {'keyForEntity': 'dataPlatform', 'entityCategory': 'core', 'entityAspects': ['dataPlatformInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataPlatformKey")

    def __init__(self,
        platformName: str,
    ):
        super().__init__()
        
        self.platformName = platformName
    
    def _restore_defaults(self) -> None:
        self.platformName = str()
    
    
    @property
    def platformName(self) -> str:
        """Data platform name i.e. hdfs, oracle, espresso"""
        return self._inner_dict.get('platformName')  # type: ignore
    
    @platformName.setter
    def platformName(self, value: str) -> None:
        self._inner_dict['platformName'] = value
    
    
class DataProcessInstanceKeyClass(_Aspect):
    """Key for an Asset DataProcessInstance"""


    ASPECT_NAME = 'dataProcessInstanceKey'
    ASPECT_INFO = {'keyForEntity': 'dataProcessInstance', 'entityCategory': '_unset_', 'entityAspects': ['dataProcessInstanceInput', 'dataProcessInstanceOutput', 'dataProcessInstanceProperties', 'dataProcessInstanceRelationships', 'dataProcessInstanceRunEvent', 'status', 'testResults', 'dataPlatformInstance', 'subTypes', 'container', 'mlTrainingRunProperties', 'lineageFeatures'], 'entityDoc': 'DataProcessInstance represents an instance of a datajob/jobflow run'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataProcessInstanceKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the DataProcessInstance . Should be separate from the name used for displaying a DataProcessInstance."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataProcessKeyClass(_Aspect):
    """Key for a Data Process"""


    ASPECT_NAME = 'dataProcessKey'
    ASPECT_INFO = {'keyForEntity': 'dataProcess', 'entityCategory': '_unset_', 'entityAspects': ['dataProcessInfo', 'ownership', 'status', 'testResults', 'subTypes']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DataProcessKey")

    def __init__(self,
        name: str,
        orchestrator: str,
        origin: Union[str, "FabricTypeClass"],
    ):
        super().__init__()
        
        self.name = name
        self.orchestrator = orchestrator
        self.origin = origin
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.orchestrator = str()
        self.origin = FabricTypeClass.DEV
    
    
    @property
    def name(self) -> str:
        """Process name i.e. an ETL job name"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def orchestrator(self) -> str:
        """Standardized Orchestrator where data process is defined.
    TODO: Migrate towards something that can be validated like DataPlatform urn"""
        return self._inner_dict.get('orchestrator')  # type: ignore
    
    @orchestrator.setter
    def orchestrator(self, value: str) -> None:
        self._inner_dict['orchestrator'] = value
    
    
    @property
    def origin(self) -> Union[str, "FabricTypeClass"]:
        """Fabric type where dataset belongs to or where it was generated."""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: Union[str, "FabricTypeClass"]) -> None:
        self._inner_dict['origin'] = value
    
    
class DatasetKeyClass(_Aspect):
    """Key for a Dataset"""


    ASPECT_NAME = 'datasetKey'
    ASPECT_INFO = {'keyForEntity': 'dataset', 'entityCategory': 'core', 'entityAspects': ['viewProperties', 'subTypes', 'datasetProfile', 'datasetUsageStatistics', 'operation', 'domains', 'applications', 'schemaMetadata', 'status', 'container', 'deprecation', 'testResults', 'siblings', 'embed', 'incidentsSummary', 'datasetProperties', 'editableDatasetProperties', 'datasetDeprecation', 'datasetUpstreamLineage', 'upstreamLineage', 'institutionalMemory', 'ownership', 'editableSchemaMetadata', 'globalTags', 'glossaryTerms', 'browsePaths', 'dataPlatformInstance', 'browsePathsV2', 'access', 'structuredProperties', 'forms', 'partitionsSummary', 'versionProperties', 'icebergCatalogInfo', 'logicalParent', 'inferredNeighbors', 'inferredMetadata', 'schemaFieldsInferredMetadata', 'schemaFieldsInferredNeighbors', 'assertionsSummary', 'usageFeatures', 'storageFeatures', 'lineageFeatures', 'proposals', 'schemaProposals', 'anomaliesSummary', 'share', 'origin', 'documentation', 'entityInferenceMetadata', 'assetSettings'], 'entityDoc': 'Datasets represent logical or physical data assets stored or represented in various data platforms. Tables, Views, Streams are all instances of datasets.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DatasetKey")

    def __init__(self,
        platform: str,
        name: str,
        origin: Union[str, "FabricTypeClass"],
    ):
        super().__init__()
        
        self.platform = platform
        self.name = name
        self.origin = origin
    
    def _restore_defaults(self) -> None:
        self.platform = str()
        self.name = str()
        self.origin = FabricTypeClass.DEV
    
    
    @property
    def platform(self) -> str:
        """Data platform urn associated with the dataset"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def name(self) -> str:
        """Unique guid for dataset"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def origin(self) -> Union[str, "FabricTypeClass"]:
        """Fabric type where dataset belongs to or where it was generated."""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: Union[str, "FabricTypeClass"]) -> None:
        self._inner_dict['origin'] = value
    
    
class DocumentKeyClass(_Aspect):
    """Key for a Document"""


    ASPECT_NAME = 'documentKey'
    ASPECT_INFO = {'keyForEntity': 'document', 'entityCategory': 'core', 'entityAspects': ['documentInfo', 'documentSettings', 'status', 'ownership', 'domains', 'structuredProperties', 'subTypes', 'dataPlatformInstance', 'browsePathsV2', 'globalTags', 'glossaryTerms', 'semanticContent', 'institutionalMemory', 'documentation']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DocumentKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique identifier for the document."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DomainKeyClass(_Aspect):
    """Key for an Asset Domain"""


    ASPECT_NAME = 'domainKey'
    ASPECT_INFO = {'keyForEntity': 'domain', 'entityCategory': 'core', 'entityAspects': ['domainProperties', 'institutionalMemory', 'ownership', 'status', 'structuredProperties', 'forms', 'testResults', 'displayProperties', 'assetSettings', 'share', 'origin'], 'entityDoc': 'A data domain within an organization.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.DomainKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the domain. Should be separate from the name used for displaying a Domain."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class ERModelRelationshipKeyClass(_Aspect):
    """Key for a ERModelRelationship"""


    ASPECT_NAME = 'erModelRelationshipKey'
    ASPECT_INFO = {'keyForEntity': 'erModelRelationship', 'entityCategory': '_unset_', 'entityAspects': ['erModelRelationshipProperties', 'editableERModelRelationshipProperties', 'institutionalMemory', 'ownership', 'status', 'globalTags', 'glossaryTerms', 'lineageFeatures'], 'entityDoc': 'ER Model Relationship of  Dataset Fields'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.ERModelRelationshipKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        # No docs available.
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class ExecutionRequestKeyClass(_Aspect):
    """Key for an DataHub Execution Request"""


    ASPECT_NAME = 'dataHubExecutionRequestKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubExecutionRequest', 'entityCategory': 'internal', 'entityAspects': ['dataHubExecutionRequestInput', 'dataHubExecutionRequestSignal', 'dataHubExecutionRequestResult', 'dataHubExecutionRequestArtifactsLocation']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.ExecutionRequestKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the DataHub execution request."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class FormKeyClass(_Aspect):
    """Key for a Form"""


    ASPECT_NAME = 'formKey'
    ASPECT_INFO = {'keyForEntity': 'form', 'entityCategory': 'core', 'entityAspects': ['formInfo', 'dynamicFormAssignment', 'ownership', 'formSettings', 'formAssignmentStatus']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.FormKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique id for the form."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class GenericEntityKeyClass(_Aspect):
    """Key for a Generic Entity.
    These entities are for miscelaneous data that is used in non-core parts of the system.
    For instance, if we want to persist & retrieve data from auxiliary integrations such as Slack or Microsoft Teams."""


    ASPECT_NAME = 'genericEntityKey'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.GenericEntityKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for this entity. Generated on the server side at entity creation time.
    Format is '{namespace}-{guid}'. I.e., 'slack-dXJuOmxpOmRhdGFzZXQ6K'"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class GlobalSettingsKeyClass(_Aspect):
    """Key for a Global Settings"""


    ASPECT_NAME = 'globalSettingsKey'
    ASPECT_INFO = {'keyForEntity': 'globalSettings', 'entityCategory': 'internal', 'entityAspects': ['globalSettingsInfo'], 'entityDoc': 'Global settings for an the platform'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.GlobalSettingsKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Id for the settings. There should be only 1 global settings urn: urn:li:globalSettings:0"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class GlossaryNodeKeyClass(_Aspect):
    """Key for a GlossaryNode"""


    ASPECT_NAME = 'glossaryNodeKey'
    ASPECT_INFO = {'keyForEntity': 'glossaryNode', 'entityCategory': 'core', 'entityAspects': ['glossaryNodeInfo', 'institutionalMemory', 'ownership', 'status', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'displayProperties', 'assetSettings', 'share', 'origin']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.GlossaryNodeKey")

    def __init__(self,
        name: str,
    ):
        super().__init__()
        
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.name = str()
    
    
    @property
    def name(self) -> str:
        # No docs available.
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class GlossaryTermKeyClass(_Aspect):
    """Key for a GlossaryTerm"""


    ASPECT_NAME = 'glossaryTermKey'
    ASPECT_INFO = {'keyForEntity': 'glossaryTerm', 'entityCategory': 'core', 'entityAspects': ['glossaryTermInfo', 'glossaryRelatedTerms', 'institutionalMemory', 'schemaMetadata', 'ownership', 'deprecation', 'domains', 'applications', 'status', 'browsePaths', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'assetSettings', 'share', 'origin']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.GlossaryTermKey")

    def __init__(self,
        name: str,
    ):
        super().__init__()
        
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.name = str()
    
    
    @property
    def name(self) -> str:
        """The term name, which serves as a unique id"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class IncidentKeyClass(_Aspect):
    """Key for an asset Incident"""


    ASPECT_NAME = 'incidentKey'
    ASPECT_INFO = {'keyForEntity': 'incident', 'entityCategory': 'core', 'entityAspects': ['incidentInfo', 'globalTags', 'incidentNotificationDetails', 'incidentActivityEvent'], 'entityDoc': 'An incident for an asset.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.IncidentKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the incident. Generated on the server side at incident creation time."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class InviteTokenKeyClass(_Aspect):
    """Key for an InviteToken."""


    ASPECT_NAME = 'inviteTokenKey'
    ASPECT_INFO = {'keyForEntity': 'inviteToken', 'entityCategory': 'internal', 'entityAspects': ['inviteToken']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.InviteTokenKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the invite token."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class LinkPreviewKeyClass(_Aspect):
    """Key for an Link Preview"""


    ASPECT_NAME = 'linkPreviewKey'
    ASPECT_INFO = {'keyForEntity': 'linkPreview', 'entityCategory': 'internal', 'entityAspects': ['linkPreviewInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.LinkPreviewKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the Link Preview, derived by encoding the URL itself."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class MLFeatureKeyClass(_Aspect):
    """Key for an MLFeature"""


    ASPECT_NAME = 'mlFeatureKey'
    ASPECT_INFO = {'keyForEntity': 'mlFeature', 'entityCategory': 'core', 'entityAspects': ['glossaryTerms', 'editableMlFeatureProperties', 'domains', 'applications', 'mlFeatureProperties', 'ownership', 'institutionalMemory', 'status', 'deprecation', 'browsePaths', 'globalTags', 'dataPlatformInstance', 'browsePathsV2', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'proposals', 'share', 'origin', 'lineageFeatures', 'documentation', 'incidentsSummary']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.MLFeatureKey")

    def __init__(self,
        featureNamespace: str,
        name: str,
    ):
        super().__init__()
        
        self.featureNamespace = featureNamespace
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.featureNamespace = str()
        self.name = str()
    
    
    @property
    def featureNamespace(self) -> str:
        """Namespace for the feature"""
        return self._inner_dict.get('featureNamespace')  # type: ignore
    
    @featureNamespace.setter
    def featureNamespace(self, value: str) -> None:
        self._inner_dict['featureNamespace'] = value
    
    
    @property
    def name(self) -> str:
        """Name of the feature"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class MLFeatureTableKeyClass(_Aspect):
    """Key for an MLFeatureTable"""


    ASPECT_NAME = 'mlFeatureTableKey'
    ASPECT_INFO = {'keyForEntity': 'mlFeatureTable', 'entityCategory': 'core', 'entityAspects': ['glossaryTerms', 'editableMlFeatureTableProperties', 'domains', 'applications', 'mlFeatureTableProperties', 'ownership', 'institutionalMemory', 'status', 'deprecation', 'browsePaths', 'globalTags', 'dataPlatformInstance', 'browsePathsV2', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'proposals', 'share', 'origin', 'lineageFeatures', 'documentation']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.MLFeatureTableKey")

    def __init__(self,
        platform: str,
        name: str,
    ):
        super().__init__()
        
        self.platform = platform
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.platform = str()
        self.name = str()
    
    
    @property
    def platform(self) -> str:
        """Data platform urn associated with the feature table"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def name(self) -> str:
        """Name of the feature table"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class MLModelDeploymentKeyClass(_Aspect):
    """Key for an ML model deployment"""


    ASPECT_NAME = 'mlModelDeploymentKey'
    ASPECT_INFO = {'keyForEntity': 'mlModelDeployment', 'entityCategory': 'core', 'entityAspects': ['mlModelDeploymentProperties', 'ownership', 'status', 'deprecation', 'globalTags', 'dataPlatformInstance', 'testResults', 'container']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.MLModelDeploymentKey")

    def __init__(self,
        platform: str,
        name: str,
        origin: Union[str, "FabricTypeClass"],
    ):
        super().__init__()
        
        self.platform = platform
        self.name = name
        self.origin = origin
    
    def _restore_defaults(self) -> None:
        self.platform = str()
        self.name = str()
        self.origin = FabricTypeClass.DEV
    
    
    @property
    def platform(self) -> str:
        """Standardized platform urn for the model Deployment"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def name(self) -> str:
        """Name of the MLModelDeployment"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def origin(self) -> Union[str, "FabricTypeClass"]:
        """Fabric type where model Deployment belongs to or where it was generated"""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: Union[str, "FabricTypeClass"]) -> None:
        self._inner_dict['origin'] = value
    
    
class MLModelGroupKeyClass(_Aspect):
    """Key for an ML model group"""


    ASPECT_NAME = 'mlModelGroupKey'
    ASPECT_INFO = {'keyForEntity': 'mlModelGroup', 'entityCategory': 'core', 'entityAspects': ['glossaryTerms', 'editableMlModelGroupProperties', 'domains', 'applications', 'mlModelGroupProperties', 'ownership', 'status', 'deprecation', 'browsePaths', 'globalTags', 'dataPlatformInstance', 'browsePathsV2', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'container', 'institutionalMemory', 'proposals', 'share', 'origin', 'lineageFeatures', 'documentation']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.MLModelGroupKey")

    def __init__(self,
        platform: str,
        name: str,
        origin: Union[str, "FabricTypeClass"],
    ):
        super().__init__()
        
        self.platform = platform
        self.name = name
        self.origin = origin
    
    def _restore_defaults(self) -> None:
        self.platform = str()
        self.name = str()
        self.origin = FabricTypeClass.DEV
    
    
    @property
    def platform(self) -> str:
        """Standardized platform urn for the model group"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def name(self) -> str:
        """Name of the MLModelGroup"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def origin(self) -> Union[str, "FabricTypeClass"]:
        """Fabric type where model group belongs to or where it was generated"""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: Union[str, "FabricTypeClass"]) -> None:
        self._inner_dict['origin'] = value
    
    
class MLModelKeyClass(_Aspect):
    """Key for an ML model"""


    ASPECT_NAME = 'mlModelKey'
    ASPECT_INFO = {'keyForEntity': 'mlModel', 'entityCategory': 'core', 'entityAspects': ['glossaryTerms', 'editableMlModelProperties', 'domains', 'applications', 'ownership', 'mlModelProperties', 'intendedUse', 'mlModelFactorPrompts', 'mlModelMetrics', 'mlModelEvaluationData', 'mlModelTrainingData', 'mlModelQuantitativeAnalyses', 'mlModelEthicalConsiderations', 'mlModelCaveatsAndRecommendations', 'institutionalMemory', 'sourceCode', 'status', 'cost', 'deprecation', 'browsePaths', 'globalTags', 'dataPlatformInstance', 'browsePathsV2', 'structuredProperties', 'forms', 'testResults', 'versionProperties', 'subTypes', 'container', 'proposals', 'share', 'origin', 'lineageFeatures', 'documentation', 'incidentsSummary']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.MLModelKey")

    def __init__(self,
        platform: str,
        name: str,
        origin: Union[str, "FabricTypeClass"],
    ):
        super().__init__()
        
        self.platform = platform
        self.name = name
        self.origin = origin
    
    def _restore_defaults(self) -> None:
        self.platform = str()
        self.name = str()
        self.origin = FabricTypeClass.DEV
    
    
    @property
    def platform(self) -> str:
        """Standardized platform urn for the model"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def name(self) -> str:
        """Name of the MLModel"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def origin(self) -> Union[str, "FabricTypeClass"]:
        """Fabric type where model belongs to or where it was generated"""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: Union[str, "FabricTypeClass"]) -> None:
        self._inner_dict['origin'] = value
    
    
class MLPrimaryKeyKeyClass(_Aspect):
    """Key for an MLPrimaryKey"""


    ASPECT_NAME = 'mlPrimaryKeyKey'
    ASPECT_INFO = {'keyForEntity': 'mlPrimaryKey', 'entityCategory': 'core', 'entityAspects': ['glossaryTerms', 'editableMlPrimaryKeyProperties', 'domains', 'applications', 'mlPrimaryKeyProperties', 'ownership', 'institutionalMemory', 'status', 'deprecation', 'globalTags', 'dataPlatformInstance', 'structuredProperties', 'forms', 'testResults', 'subTypes', 'proposals', 'share', 'origin', 'lineageFeatures']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.MLPrimaryKeyKey")

    def __init__(self,
        featureNamespace: str,
        name: str,
    ):
        super().__init__()
        
        self.featureNamespace = featureNamespace
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.featureNamespace = str()
        self.name = str()
    
    
    @property
    def featureNamespace(self) -> str:
        """Namespace for the primary key"""
        return self._inner_dict.get('featureNamespace')  # type: ignore
    
    @featureNamespace.setter
    def featureNamespace(self, value: str) -> None:
        self._inner_dict['featureNamespace'] = value
    
    
    @property
    def name(self) -> str:
        """Name of the primary key"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class MonitorKeyClass(_Aspect):
    """Key for a Monitor"""


    ASPECT_NAME = 'monitorKey'
    ASPECT_INFO = {'keyForEntity': 'monitor', 'entityCategory': 'core', 'entityAspects': ['monitorInfo', 'monitorTimeseriesState', 'monitorAnomalyEvent', 'status']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.MonitorKey")

    def __init__(self,
        entity: str,
        id: str,
    ):
        super().__init__()
        
        self.entity = entity
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.entity = str()
        self.id = str()
    
    
    @property
    def entity(self) -> str:
        """The entity being monitored"""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def id(self) -> str:
        """Unique id for the monitor."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class MonitorSuiteKeyClass(_Aspect):
    """Key for a monitor suite."""


    ASPECT_NAME = 'monitorSuiteKey'
    ASPECT_INFO = {'keyForEntity': 'monitorSuite', 'entityCategory': 'core', 'entityAspects': ['monitorSuiteInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.MonitorSuiteKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique id for the monitor suite."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class NotebookKeyClass(_Aspect):
    """Key for a Notebook"""


    ASPECT_NAME = 'notebookKey'
    ASPECT_INFO = {'keyForEntity': 'notebook', 'entityCategory': '_unset_', 'entityAspects': ['notebookInfo', 'notebookContent', 'editableNotebookProperties', 'ownership', 'status', 'globalTags', 'glossaryTerms', 'browsePaths', 'institutionalMemory', 'domains', 'applications', 'subTypes', 'dataPlatformInstance', 'browsePathsV2', 'testResults', 'proposals', 'share', 'origin', 'documentation'], 'entityDoc': 'Notebook represents a combination of query, text, chart and etc. This is in BETA version'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.NotebookKey")

    def __init__(self,
        notebookTool: str,
        notebookId: str,
    ):
        super().__init__()
        
        self.notebookTool = notebookTool
        self.notebookId = notebookId
    
    def _restore_defaults(self) -> None:
        self.notebookTool = str()
        self.notebookId = str()
    
    
    @property
    def notebookTool(self) -> str:
        """The name of the Notebook tool such as QueryBook, etc."""
        return self._inner_dict.get('notebookTool')  # type: ignore
    
    @notebookTool.setter
    def notebookTool(self, value: str) -> None:
        self._inner_dict['notebookTool'] = value
    
    
    @property
    def notebookId(self) -> str:
        """Unique id for the Notebook. This id should be globally unique for a Notebook tool even when there are multiple deployments of it. As an example, Notebook URL could be used here for QueryBook such as 'querybook.com/notebook/773'"""
        return self._inner_dict.get('notebookId')  # type: ignore
    
    @notebookId.setter
    def notebookId(self, value: str) -> None:
        self._inner_dict['notebookId'] = value
    
    
class OwnershipTypeKeyClass(_Aspect):
    """Key for a Ownership Type"""


    ASPECT_NAME = 'ownershipTypeKey'
    ASPECT_INFO = {'keyForEntity': 'ownershipType', 'entityCategory': 'core', 'entityAspects': ['ownershipTypeInfo', 'status'], 'entityDoc': 'Ownership Type represents a user-created ownership category for a person or group who is responsible for an asset.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.OwnershipTypeKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique ID for the data ownership type name i.e. Business Owner, Data Steward, Technical Owner, etc..
    Should be separate from the name used for displaying an Ownership Type."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class PostKeyClass(_Aspect):
    """Key for a Post."""


    ASPECT_NAME = 'postKey'
    ASPECT_INFO = {'keyForEntity': 'post', 'entityCategory': 'core', 'entityAspects': ['postInfo', 'subTypes', 'status']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.PostKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the DataHub Post record. Generated on the server side at Post creation time."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class QueryKeyClass(_Aspect):
    """Key for a Query"""


    ASPECT_NAME = 'queryKey'
    ASPECT_INFO = {'keyForEntity': 'query', 'entityCategory': 'core', 'entityAspects': ['queryProperties', 'querySubjects', 'queryUsageStatistics', 'status', 'dataPlatformInstance', 'subTypes', 'queryUsageFeatures', 'lineageFeatures']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.QueryKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the Query."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class RecommendationModuleKeyClass(_Aspect):
    """Key for a recommendation module"""


    ASPECT_NAME = 'recommendationModuleKey'
    ASPECT_INFO = {'keyForEntity': 'recommendationModule', 'entityCategory': '_unset_', 'entityAspects': ['recommendationModule']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.RecommendationModuleKey")

    def __init__(self,
        moduleId: str,
        identifier: str,
    ):
        super().__init__()
        
        self.moduleId = moduleId
        self.identifier = identifier
    
    def _restore_defaults(self) -> None:
        self.moduleId = str()
        self.identifier = str()
    
    
    @property
    def moduleId(self) -> str:
        """Module ID for the recommendation module"""
        return self._inner_dict.get('moduleId')  # type: ignore
    
    @moduleId.setter
    def moduleId(self, value: str) -> None:
        self._inner_dict['moduleId'] = value
    
    
    @property
    def identifier(self) -> str:
        """Identifier for the specific module"""
        return self._inner_dict.get('identifier')  # type: ignore
    
    @identifier.setter
    def identifier(self, value: str) -> None:
        self._inner_dict['identifier'] = value
    
    
class RemoteExecutorGlobalConfigKeyClass(_Aspect):
    """Key for the *Singleton* DataHub Remote Executor Global Config"""


    ASPECT_NAME = 'dataHubRemoteExecutorGlobalConfigKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubRemoteExecutorGlobalConfig', 'entityCategory': 'internal', 'entityAspects': ['dataHubRemoteExecutorPoolGlobalConfig']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.RemoteExecutorGlobalConfigKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """The unique identifier for the remote executor global config
    NOTE: since this a singleton, there should be a hardcoded key in the AcrylConstants file"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class RemoteExecutorKeyClass(_Aspect):
    """Key for an DataHub Remote Executor"""


    ASPECT_NAME = 'dataHubRemoteExecutorKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubRemoteExecutor', 'entityCategory': 'internal', 'entityAspects': ['dataHubRemoteExecutorStatus']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.RemoteExecutorKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the DataHub Remote Executor."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class RemoteExecutorPoolKeyClass(_Aspect):
    """Key for an DataHub Remote Executor Pool"""


    ASPECT_NAME = 'dataHubRemoteExecutorPoolKey'
    ASPECT_INFO = {'keyForEntity': 'dataHubRemoteExecutorPool', 'entityCategory': 'internal', 'entityAspects': ['dataHubRemoteExecutorPoolInfo']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.RemoteExecutorPoolKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """The unique identifier for the remote executor pool"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class RoleKeyClass(_Aspect):
    """Key for a External AccessManagement"""


    ASPECT_NAME = 'roleKey'
    ASPECT_INFO = {'keyForEntity': 'role', 'entityCategory': 'core', 'entityAspects': ['roleProperties', 'actors']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.RoleKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for the access management IAM."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class SchemaFieldKeyClass(_Aspect):
    """Key for a SchemaField"""


    ASPECT_NAME = 'schemaFieldKey'
    ASPECT_INFO = {'keyForEntity': 'schemaField', 'entityCategory': 'core', 'entityAspects': ['schemafieldInfo', 'structuredProperties', 'forms', 'businessAttributes', 'status', 'schemaFieldAliases', 'documentation', 'testResults', 'deprecation', 'subTypes', 'logicalParent', 'globalTags', 'glossaryTerms', 'schemaFieldProfile', 'lineageFeatures']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.SchemaFieldKey")

    def __init__(self,
        parent: str,
        fieldPath: str,
    ):
        super().__init__()
        
        self.parent = parent
        self.fieldPath = fieldPath
    
    def _restore_defaults(self) -> None:
        self.parent = str()
        self.fieldPath = str()
    
    
    @property
    def parent(self) -> str:
        """Parent associated with the schema field"""
        return self._inner_dict.get('parent')  # type: ignore
    
    @parent.setter
    def parent(self, value: str) -> None:
        self._inner_dict['parent'] = value
    
    
    @property
    def fieldPath(self) -> str:
        """fieldPath identifying the schema field"""
        return self._inner_dict.get('fieldPath')  # type: ignore
    
    @fieldPath.setter
    def fieldPath(self, value: str) -> None:
        self._inner_dict['fieldPath'] = value
    
    
class SubscriptionKeyClass(_Aspect):
    """Key for a Subscription"""


    ASPECT_NAME = 'subscriptionKey'
    ASPECT_INFO = {'keyForEntity': 'subscription', 'entityCategory': 'core', 'entityAspects': ['subscriptionInfo', 'status']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.SubscriptionKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """UUID for the subscription. Generated server-side when the subscription is created."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class TagKeyClass(_Aspect):
    """Key for a Tag"""


    ASPECT_NAME = 'tagKey'
    ASPECT_INFO = {'keyForEntity': 'tag', 'entityCategory': 'core', 'entityAspects': ['tagProperties', 'ownership', 'deprecation', 'status', 'testResults', 'share', 'origin']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.TagKey")

    def __init__(self,
        name: str,
    ):
        super().__init__()
        
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.name = str()
    
    
    @property
    def name(self) -> str:
        """The tag name, which serves as a unique id"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class TelemetryKeyClass(_Aspect):
    """Key for the telemetry client ID, only one should ever exist"""


    ASPECT_NAME = 'telemetryKey'
    ASPECT_INFO = {'keyForEntity': 'telemetry', 'entityCategory': 'internal', 'entityAspects': ['telemetryClientId']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.TelemetryKey")

    def __init__(self,
        name: str,
    ):
        super().__init__()
        
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.name = str()
    
    
    @property
    def name(self) -> str:
        """The telemetry entity name, which serves as a unique id"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class TestKeyClass(_Aspect):
    """Key for a Test"""


    ASPECT_NAME = 'testKey'
    ASPECT_INFO = {'keyForEntity': 'test', 'entityCategory': 'core', 'entityAspects': ['testInfo', 'status', 'batchTestRunEvent'], 'entityDoc': 'A DataHub test'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.TestKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """Unique id for the test"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class VersionSetKeyClass(_Aspect):
    """Key for a Version Set entity"""


    ASPECT_NAME = 'versionSetKey'
    ASPECT_INFO = {'keyForEntity': 'versionSet', 'entityCategory': 'core', 'entityAspects': ['versionSetProperties']}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.key.VersionSetKey")

    def __init__(self,
        id: str,
        entityType: str,
    ):
        super().__init__()
        
        self.id = id
        self.entityType = entityType
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.entityType = str()
    
    
    @property
    def id(self) -> str:
        """ID of the Version Set, generated from platform + asset id / name"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def entityType(self) -> str:
        """Type of entities included in version set, limits to a single entity type between linked versioned entities"""
        return self._inner_dict.get('entityType')  # type: ignore
    
    @entityType.setter
    def entityType(self, value: str) -> None:
        self._inner_dict['entityType'] = value
    
    
class ConditionClass(object):
    """The matching condition in a filter criterion"""
    
    CONTAIN = "CONTAIN"
    """Represent the relation: String field contains value, e.g. name contains Profile"""
    
    END_WITH = "END_WITH"
    """Represent the relation: String field ends with value, e.g. name ends with Event"""
    
    EQUAL = "EQUAL"
    """Represent the relation: field = value, e.g. platform = hdfs"""
    
    IEQUAL = "IEQUAL"
    """Represent the relation: field = value and support case insensitive values, e.g. platform = hdfs"""
    
    IS_NULL = "IS_NULL"
    """Represent the relation: field is null, e.g. platform is null"""
    
    EXISTS = "EXISTS"
    """Represents the relation: field exists and is non-empty, e.g. owners is not null and != [] (empty)"""
    
    GREATER_THAN = "GREATER_THAN"
    """Represent the relation greater than, e.g. ownerCount > 5"""
    
    GREATER_THAN_OR_EQUAL_TO = "GREATER_THAN_OR_EQUAL_TO"
    """Represent the relation greater than or equal to, e.g. ownerCount >= 5"""
    
    IN = "IN"
    """Represent the relation: String field is one of the array values to, e.g. name in ["Profile", "Event"]"""
    
    LESS_THAN = "LESS_THAN"
    """Represent the relation less than, e.g. ownerCount < 3"""
    
    LESS_THAN_OR_EQUAL_TO = "LESS_THAN_OR_EQUAL_TO"
    """Represent the relation less than or equal to, e.g. ownerCount <= 3"""
    
    BETWEEN = "BETWEEN"
    """Represent the relation within an inclusive range, e.g. 3 <= ownerCount <= 5. Note that the values in Criterion must have two entries for a lower and upper bound."""
    
    START_WITH = "START_WITH"
    """Represent the relation: String field starts with value, e.g. name starts with PageView"""
    
    DESCENDANTS_INCL = "DESCENDANTS_INCL"
    """Represent the relation: URN field any nested children in addition to the given URN"""
    
    ANCESTORS_INCL = "ANCESTORS_INCL"
    """Represent the relation: URN field matches any nested parent in addition to the given URN"""
    
    RELATED_INCL = "RELATED_INCL"
    """Represent the relation: URN field matches any nested child or parent in addition to the given URN"""
    
    
    
class ConjunctiveCriterionClass(DictWrapper):
    """A list of criterion and'd together."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.query.filter.ConjunctiveCriterion")
    def __init__(self,
        and_: List["CriterionClass"],
    ):
        super().__init__()
        
        self.and_ = and_
    
    def _restore_defaults(self) -> None:
        self.and_ = list()
    
    
    @property
    def and_(self) -> List["CriterionClass"]:
        """A list of and criteria the filter applies to the query"""
        return self._inner_dict.get('and')  # type: ignore
    
    @and_.setter
    def and_(self, value: List["CriterionClass"]) -> None:
        self._inner_dict['and'] = value
    
    
class CriterionClass(DictWrapper):
    """A criterion for matching a field with given value"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.query.filter.Criterion")
    def __init__(self,
        field: str,
        value: str,
        values: Optional[List[str]]=None,
        condition: Optional[Union[str, "ConditionClass"]]=None,
        negated: Optional[bool]=None,
    ):
        super().__init__()
        
        self.field = field
        self.value = value
        if values is None:
            # default: []
            self.values = list()
        else:
            self.values = values
        if condition is None:
            # default: 'EQUAL'
            self.condition = self.RECORD_SCHEMA.fields_dict["condition"].default
        else:
            self.condition = condition
        if negated is None:
            # default: False
            self.negated = self.RECORD_SCHEMA.fields_dict["negated"].default
        else:
            self.negated = negated
    
    def _restore_defaults(self) -> None:
        self.field = str()
        self.value = str()
        self.values = list()
        self.condition = self.RECORD_SCHEMA.fields_dict["condition"].default
        self.negated = self.RECORD_SCHEMA.fields_dict["negated"].default
    
    
    @property
    def field(self) -> str:
        """The name of the field that the criterion refers to"""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: str) -> None:
        self._inner_dict['field'] = value
    
    
    @property
    def value(self) -> str:
        """The value of the intended field"""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: str) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def values(self) -> List[str]:
        """Values. one of which the intended field should match
    Note, if values is set, the above "value" field will be ignored"""
        return self._inner_dict.get('values')  # type: ignore
    
    @values.setter
    def values(self, value: List[str]) -> None:
        self._inner_dict['values'] = value
    
    
    @property
    def condition(self) -> Union[str, "ConditionClass"]:
        """The condition for the criterion, e.g. EQUAL, START_WITH"""
        return self._inner_dict.get('condition')  # type: ignore
    
    @condition.setter
    def condition(self, value: Union[str, "ConditionClass"]) -> None:
        self._inner_dict['condition'] = value
    
    
    @property
    def negated(self) -> bool:
        """Whether the condition should be negated"""
        return self._inner_dict.get('negated')  # type: ignore
    
    @negated.setter
    def negated(self, value: bool) -> None:
        self._inner_dict['negated'] = value
    
    
class FilterClass(DictWrapper):
    """The filter for finding a record or a collection of records"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.query.filter.Filter")
    def __init__(self,
        or_: Union[None, List["ConjunctiveCriterionClass"]]=None,
        criteria: Union[None, List["CriterionClass"]]=None,
    ):
        super().__init__()
        
        self.or_ = or_
        self.criteria = criteria
    
    def _restore_defaults(self) -> None:
        self.or_ = self.RECORD_SCHEMA.fields_dict["or"].default
        self.criteria = self.RECORD_SCHEMA.fields_dict["criteria"].default
    
    
    @property
    def or_(self) -> Union[None, List["ConjunctiveCriterionClass"]]:
        """A list of disjunctive criterion for the filter. (or operation to combine filters)"""
        return self._inner_dict.get('or')  # type: ignore
    
    @or_.setter
    def or_(self, value: Union[None, List["ConjunctiveCriterionClass"]]) -> None:
        self._inner_dict['or'] = value
    
    
    @property
    def criteria(self) -> Union[None, List["CriterionClass"]]:
        """Deprecated! A list of conjunctive criterion for the filter. If "or" field is provided, then this field is ignored."""
        return self._inner_dict.get('criteria')  # type: ignore
    
    @criteria.setter
    def criteria(self, value: Union[None, List["CriterionClass"]]) -> None:
        self._inner_dict['criteria'] = value
    
    
class ContentParamsClass(DictWrapper):
    """Params about the recommended content"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.recommendation.ContentParams")
    def __init__(self,
        count: int,
    ):
        super().__init__()
        
        self.count = count
    
    def _restore_defaults(self) -> None:
        self.count = int()
    
    
    @property
    def count(self) -> int:
        """Number of entities corresponding to the recommended content"""
        return self._inner_dict.get('count')  # type: ignore
    
    @count.setter
    def count(self, value: int) -> None:
        self._inner_dict['count'] = value
    
    
class EntityProfileParamsClass(DictWrapper):
    """Context to define the entity profile page"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.recommendation.EntityProfileParams")
    def __init__(self,
        urn: str,
    ):
        super().__init__()
        
        self.urn = urn
    
    def _restore_defaults(self) -> None:
        self.urn = str()
    
    
    @property
    def urn(self) -> str:
        """Urn of the entity being shown"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
class RecommendationContentClass(DictWrapper):
    """Content to display within each recommendation module"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.recommendation.RecommendationContent")
    def __init__(self,
        value: str,
        entity: Union[None, str]=None,
        params: Union[None, "RecommendationParamsClass"]=None,
    ):
        super().__init__()
        
        self.value = value
        self.entity = entity
        self.params = params
    
    def _restore_defaults(self) -> None:
        self.value = str()
        self.entity = self.RECORD_SCHEMA.fields_dict["entity"].default
        self.params = self.RECORD_SCHEMA.fields_dict["params"].default
    
    
    @property
    def value(self) -> str:
        """String representation of content"""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: str) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def entity(self) -> Union[None, str]:
        """Entity being recommended. Empty if the content being recommended is not an entity"""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: Union[None, str]) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def params(self) -> Union[None, "RecommendationParamsClass"]:
        """Additional context required to generate the the recommendation"""
        return self._inner_dict.get('params')  # type: ignore
    
    @params.setter
    def params(self, value: Union[None, "RecommendationParamsClass"]) -> None:
        self._inner_dict['params'] = value
    
    
class RecommendationModuleClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'recommendationModule'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.recommendation.RecommendationModule")

    def __init__(self,
        title: str,
        moduleId: str,
        renderType: Union[str, "RecommendationRenderTypeClass"],
        content: List["RecommendationContentClass"],
    ):
        super().__init__()
        
        self.title = title
        self.moduleId = moduleId
        self.renderType = renderType
        self.content = content
    
    def _restore_defaults(self) -> None:
        self.title = str()
        self.moduleId = str()
        self.renderType = RecommendationRenderTypeClass.ENTITY_NAME_LIST
        self.content = list()
    
    
    @property
    def title(self) -> str:
        """Title of the module to display"""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: str) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def moduleId(self) -> str:
        """Unique id of the module being recommended"""
        return self._inner_dict.get('moduleId')  # type: ignore
    
    @moduleId.setter
    def moduleId(self, value: str) -> None:
        self._inner_dict['moduleId'] = value
    
    
    @property
    def renderType(self) -> Union[str, "RecommendationRenderTypeClass"]:
        """Type of rendering that defines how the module should be rendered"""
        return self._inner_dict.get('renderType')  # type: ignore
    
    @renderType.setter
    def renderType(self, value: Union[str, "RecommendationRenderTypeClass"]) -> None:
        self._inner_dict['renderType'] = value
    
    
    @property
    def content(self) -> List["RecommendationContentClass"]:
        """List of content to display inside the module"""
        return self._inner_dict.get('content')  # type: ignore
    
    @content.setter
    def content(self, value: List["RecommendationContentClass"]) -> None:
        self._inner_dict['content'] = value
    
    
class RecommendationParamsClass(DictWrapper):
    """Parameters required to render a recommendation of a given type"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.recommendation.RecommendationParams")
    def __init__(self,
        searchParams: Union[None, "SearchParamsClass"]=None,
        entityProfileParams: Union[None, "EntityProfileParamsClass"]=None,
        contentParams: Union[None, "ContentParamsClass"]=None,
    ):
        super().__init__()
        
        self.searchParams = searchParams
        self.entityProfileParams = entityProfileParams
        self.contentParams = contentParams
    
    def _restore_defaults(self) -> None:
        self.searchParams = self.RECORD_SCHEMA.fields_dict["searchParams"].default
        self.entityProfileParams = self.RECORD_SCHEMA.fields_dict["entityProfileParams"].default
        self.contentParams = self.RECORD_SCHEMA.fields_dict["contentParams"].default
    
    
    @property
    def searchParams(self) -> Union[None, "SearchParamsClass"]:
        """Context to define the search recommendations"""
        return self._inner_dict.get('searchParams')  # type: ignore
    
    @searchParams.setter
    def searchParams(self, value: Union[None, "SearchParamsClass"]) -> None:
        self._inner_dict['searchParams'] = value
    
    
    @property
    def entityProfileParams(self) -> Union[None, "EntityProfileParamsClass"]:
        """Context to define the entity profile page"""
        return self._inner_dict.get('entityProfileParams')  # type: ignore
    
    @entityProfileParams.setter
    def entityProfileParams(self, value: Union[None, "EntityProfileParamsClass"]) -> None:
        self._inner_dict['entityProfileParams'] = value
    
    
    @property
    def contentParams(self) -> Union[None, "ContentParamsClass"]:
        """Context about the recommendation"""
        return self._inner_dict.get('contentParams')  # type: ignore
    
    @contentParams.setter
    def contentParams(self, value: Union[None, "ContentParamsClass"]) -> None:
        self._inner_dict['contentParams'] = value
    
    
class RecommendationRenderTypeClass(object):
    """Enum that defines how the modules should be rendered.
    There should be two frontend implementation of large and small modules per type."""
    
    ENTITY_NAME_LIST = "ENTITY_NAME_LIST"
    """Simple list of entities"""
    
    PLATFORM_SEARCH_LIST = "PLATFORM_SEARCH_LIST"
    """List of platforms to search"""
    
    TAG_SEARCH_LIST = "TAG_SEARCH_LIST"
    """Tag search list"""
    
    GLOSSARY_TERM_SEARCH_LIST = "GLOSSARY_TERM_SEARCH_LIST"
    """Glossary term search list"""
    
    SEARCH_QUERY_LIST = "SEARCH_QUERY_LIST"
    """A list of recommended searches"""
    
    DOMAIN_SEARCH_LIST = "DOMAIN_SEARCH_LIST"
    """List of domains to search"""
    
    
    
class SearchParamsClass(DictWrapper):
    """Context to define the search recommendations"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.recommendation.SearchParams")
    def __init__(self,
        query: str,
        types: Optional[List[str]]=None,
        filters: Optional[List["CriterionClass"]]=None,
    ):
        super().__init__()
        
        if types is None:
            # default: []
            self.types = list()
        else:
            self.types = types
        self.query = query
        if filters is None:
            # default: []
            self.filters = list()
        else:
            self.filters = filters
    
    def _restore_defaults(self) -> None:
        self.types = list()
        self.query = str()
        self.filters = list()
    
    
    @property
    def types(self) -> List[str]:
        """Entity types to be searched. If this is not provided, all entities will be searched."""
        return self._inner_dict.get('types')  # type: ignore
    
    @types.setter
    def types(self, value: List[str]) -> None:
        self._inner_dict['types'] = value
    
    
    @property
    def query(self) -> str:
        """Search query"""
        return self._inner_dict.get('query')  # type: ignore
    
    @query.setter
    def query(self, value: str) -> None:
        self._inner_dict['query'] = value
    
    
    @property
    def filters(self) -> List["CriterionClass"]:
        """Filters"""
        return self._inner_dict.get('filters')  # type: ignore
    
    @filters.setter
    def filters(self, value: List["CriterionClass"]) -> None:
        self._inner_dict['filters'] = value
    
    
class CorpUserUsageFeaturesClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'corpUserUsageFeatures'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.search.features.CorpUserUsageFeatures")

    def __init__(self,
        userUsageTotalPast30Days: Union[None, int]=None,
        userPlatformUsageTotalsPast30Days: Union[None, Dict[str, float]]=None,
        userPlatformUsagePercentilePast30Days: Union[None, Dict[str, float]]=None,
        userUsagePercentilePast30Days: Union[None, float]=None,
        userTopDatasetsByUsage: Union[None, Dict[str, float]]=None,
    ):
        super().__init__()
        
        self.userUsageTotalPast30Days = userUsageTotalPast30Days
        self.userPlatformUsageTotalsPast30Days = userPlatformUsageTotalsPast30Days
        self.userPlatformUsagePercentilePast30Days = userPlatformUsagePercentilePast30Days
        self.userUsagePercentilePast30Days = userUsagePercentilePast30Days
        self.userTopDatasetsByUsage = userTopDatasetsByUsage
    
    def _restore_defaults(self) -> None:
        self.userUsageTotalPast30Days = self.RECORD_SCHEMA.fields_dict["userUsageTotalPast30Days"].default
        self.userPlatformUsageTotalsPast30Days = self.RECORD_SCHEMA.fields_dict["userPlatformUsageTotalsPast30Days"].default
        self.userPlatformUsagePercentilePast30Days = self.RECORD_SCHEMA.fields_dict["userPlatformUsagePercentilePast30Days"].default
        self.userUsagePercentilePast30Days = self.RECORD_SCHEMA.fields_dict["userUsagePercentilePast30Days"].default
        self.userTopDatasetsByUsage = self.RECORD_SCHEMA.fields_dict["userTopDatasetsByUsage"].default
    
    
    @property
    def userUsageTotalPast30Days(self) -> Union[None, int]:
        """Total number of usage in the last 30 days"""
        return self._inner_dict.get('userUsageTotalPast30Days')  # type: ignore
    
    @userUsageTotalPast30Days.setter
    def userUsageTotalPast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['userUsageTotalPast30Days'] = value
    
    
    @property
    def userPlatformUsageTotalsPast30Days(self) -> Union[None, Dict[str, float]]:
        """usage broken down by platform so we can differentiate between top users of snowflake vs redshift
    key is supposed to be platform urn"""
        return self._inner_dict.get('userPlatformUsageTotalsPast30Days')  # type: ignore
    
    @userPlatformUsageTotalsPast30Days.setter
    def userPlatformUsageTotalsPast30Days(self, value: Union[None, Dict[str, float]]) -> None:
        self._inner_dict['userPlatformUsageTotalsPast30Days'] = value
    
    
    @property
    def userPlatformUsagePercentilePast30Days(self) -> Union[None, Dict[str, float]]:
        """usage broken down by platform so we can differentiate between top users of snowflake vs redshift"""
        return self._inner_dict.get('userPlatformUsagePercentilePast30Days')  # type: ignore
    
    @userPlatformUsagePercentilePast30Days.setter
    def userPlatformUsagePercentilePast30Days(self, value: Union[None, Dict[str, float]]) -> None:
        self._inner_dict['userPlatformUsagePercentilePast30Days'] = value
    
    
    @property
    def userUsagePercentilePast30Days(self) -> Union[None, float]:
        """Platform usage total percentile for ranking users across all platforms"""
        return self._inner_dict.get('userUsagePercentilePast30Days')  # type: ignore
    
    @userUsagePercentilePast30Days.setter
    def userUsagePercentilePast30Days(self, value: Union[None, float]) -> None:
        self._inner_dict['userUsagePercentilePast30Days'] = value
    
    
    @property
    def userTopDatasetsByUsage(self) -> Union[None, Dict[str, float]]:
        """Gather what are the top datasets per user so we can create a welcome module
    With links to the users top datasets with lineage (top 25)
    Map keys are dataset URN strings"""
        return self._inner_dict.get('userTopDatasetsByUsage')  # type: ignore
    
    @userTopDatasetsByUsage.setter
    def userTopDatasetsByUsage(self, value: Union[None, Dict[str, float]]) -> None:
        self._inner_dict['userTopDatasetsByUsage'] = value
    
    
class CostCurrencyCodeClass(object):
    """ Currency code for the cost """
    
    USD = "USD"
    
    
class CostFeaturesClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'costFeatures'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.search.features.CostFeatures")

    def __init__(self,
        costLast30Days: Union[None, float]=None,
        costCurrencyCode: Union[None, Union[str, "CostCurrencyCodeClass"]]=None,
    ):
        super().__init__()
        
        self.costLast30Days = costLast30Days
        self.costCurrencyCode = costCurrencyCode
    
    def _restore_defaults(self) -> None:
        self.costLast30Days = self.RECORD_SCHEMA.fields_dict["costLast30Days"].default
        self.costCurrencyCode = self.RECORD_SCHEMA.fields_dict["costCurrencyCode"].default
    
    
    @property
    def costLast30Days(self) -> Union[None, float]:
        """Cost over last 30 days. The currency type is set with costCurrencyCode."""
        return self._inner_dict.get('costLast30Days')  # type: ignore
    
    @costLast30Days.setter
    def costLast30Days(self, value: Union[None, float]) -> None:
        self._inner_dict['costLast30Days'] = value
    
    
    @property
    def costCurrencyCode(self) -> Union[None, Union[str, "CostCurrencyCodeClass"]]:
        """The currency code for the given cost."""
        return self._inner_dict.get('costCurrencyCode')  # type: ignore
    
    @costCurrencyCode.setter
    def costCurrencyCode(self, value: Union[None, Union[str, "CostCurrencyCodeClass"]]) -> None:
        self._inner_dict['costCurrencyCode'] = value
    
    
class LineageFeaturesClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'lineageFeatures'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.search.features.LineageFeatures")

    def __init__(self,
        upstreamCount: int,
        downstreamCount: int,
        hasAssetLevelLineage: Union[None, bool]=None,
        computedAt: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.upstreamCount = upstreamCount
        self.downstreamCount = downstreamCount
        self.hasAssetLevelLineage = hasAssetLevelLineage
        self.computedAt = computedAt
    
    def _restore_defaults(self) -> None:
        self.upstreamCount = int()
        self.downstreamCount = int()
        self.hasAssetLevelLineage = self.RECORD_SCHEMA.fields_dict["hasAssetLevelLineage"].default
        self.computedAt = self.RECORD_SCHEMA.fields_dict["computedAt"].default
    
    
    @property
    def upstreamCount(self) -> int:
        """Cached number of entities related by lineage, upstream."""
        return self._inner_dict.get('upstreamCount')  # type: ignore
    
    @upstreamCount.setter
    def upstreamCount(self, value: int) -> None:
        self._inner_dict['upstreamCount'] = value
    
    
    @property
    def downstreamCount(self) -> int:
        """Cached number of entities related by lineage, downstream."""
        return self._inner_dict.get('downstreamCount')  # type: ignore
    
    @downstreamCount.setter
    def downstreamCount(self, value: int) -> None:
        self._inner_dict['downstreamCount'] = value
    
    
    @property
    def hasAssetLevelLineage(self) -> Union[None, bool]:
        """Whether upstreamCount > 0 OR downstreamCount > 0
    stored to make filtering easier"""
        return self._inner_dict.get('hasAssetLevelLineage')  # type: ignore
    
    @hasAssetLevelLineage.setter
    def hasAssetLevelLineage(self, value: Union[None, bool]) -> None:
        self._inner_dict['hasAssetLevelLineage'] = value
    
    
    @property
    def computedAt(self) -> Union[None, "AuditStampClass"]:
        """Record of when and how lineage features were computed."""
        return self._inner_dict.get('computedAt')  # type: ignore
    
    @computedAt.setter
    def computedAt(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['computedAt'] = value
    
    
class StorageFeaturesClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'storageFeatures'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.search.features.StorageFeatures")

    def __init__(self,
        sizeInBytes: Union[None, int]=None,
        sizeInBytesPercentile: Union[None, int]=None,
        sizeInBytesRank: Union[None, int]=None,
        rowCount: Union[None, int]=None,
        rowCountPercentile: Union[None, int]=None,
        rowCountRank: Union[None, int]=None,
    ):
        super().__init__()
        
        self.sizeInBytes = sizeInBytes
        self.sizeInBytesPercentile = sizeInBytesPercentile
        self.sizeInBytesRank = sizeInBytesRank
        self.rowCount = rowCount
        self.rowCountPercentile = rowCountPercentile
        self.rowCountRank = rowCountRank
    
    def _restore_defaults(self) -> None:
        self.sizeInBytes = self.RECORD_SCHEMA.fields_dict["sizeInBytes"].default
        self.sizeInBytesPercentile = self.RECORD_SCHEMA.fields_dict["sizeInBytesPercentile"].default
        self.sizeInBytesRank = self.RECORD_SCHEMA.fields_dict["sizeInBytesRank"].default
        self.rowCount = self.RECORD_SCHEMA.fields_dict["rowCount"].default
        self.rowCountPercentile = self.RECORD_SCHEMA.fields_dict["rowCountPercentile"].default
        self.rowCountRank = self.RECORD_SCHEMA.fields_dict["rowCountRank"].default
    
    
    @property
    def sizeInBytes(self) -> Union[None, int]:
        """The total size in bytes."""
        return self._inner_dict.get('sizeInBytes')  # type: ignore
    
    @sizeInBytes.setter
    def sizeInBytes(self, value: Union[None, int]) -> None:
        self._inner_dict['sizeInBytes'] = value
    
    
    @property
    def sizeInBytesPercentile(self) -> Union[None, int]:
        """The percentile of size in bytes relative to other assets from the data plaform instance."""
        return self._inner_dict.get('sizeInBytesPercentile')  # type: ignore
    
    @sizeInBytesPercentile.setter
    def sizeInBytesPercentile(self, value: Union[None, int]) -> None:
        self._inner_dict['sizeInBytesPercentile'] = value
    
    
    @property
    def sizeInBytesRank(self) -> Union[None, int]:
        """The absolute rank of size in bytes relative to other assets from the data plaform instance."""
        return self._inner_dict.get('sizeInBytesRank')  # type: ignore
    
    @sizeInBytesRank.setter
    def sizeInBytesRank(self, value: Union[None, int]) -> None:
        self._inner_dict['sizeInBytesRank'] = value
    
    
    @property
    def rowCount(self) -> Union[None, int]:
        """The total row count."""
        return self._inner_dict.get('rowCount')  # type: ignore
    
    @rowCount.setter
    def rowCount(self, value: Union[None, int]) -> None:
        self._inner_dict['rowCount'] = value
    
    
    @property
    def rowCountPercentile(self) -> Union[None, int]:
        """The percentile of the total row / document count relative to other assets from the data platform instance."""
        return self._inner_dict.get('rowCountPercentile')  # type: ignore
    
    @rowCountPercentile.setter
    def rowCountPercentile(self, value: Union[None, int]) -> None:
        self._inner_dict['rowCountPercentile'] = value
    
    
    @property
    def rowCountRank(self) -> Union[None, int]:
        """The absolute rank of size in bytes relative to other assets from the data plaform instance."""
        return self._inner_dict.get('rowCountRank')  # type: ignore
    
    @rowCountRank.setter
    def rowCountRank(self, value: Union[None, int]) -> None:
        self._inner_dict['rowCountRank'] = value
    
    
class UsageFeaturesClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'usageFeatures'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.search.features.UsageFeatures")

    def __init__(self,
        viewCountLast30Days: Union[None, int]=None,
        viewCountTotal: Union[None, int]=None,
        viewCountPercentileLast30Days: Union[None, int]=None,
        usageCountLast30Days: Union[None, int]=None,
        queryCountLast30Days: Union[None, int]=None,
        uniqueUserCountLast30Days: Union[None, int]=None,
        writeCountLast30Days: Union[None, int]=None,
        queryCountPercentileLast30Days: Union[None, int]=None,
        queryCountRankLast30Days: Union[None, int]=None,
        uniqueUserPercentileLast30Days: Union[None, int]=None,
        uniqueUserRankLast30Days: Union[None, int]=None,
        writeCountPercentileLast30Days: Union[None, int]=None,
        writeCountRankLast30Days: Union[None, int]=None,
        topUsersLast30Days: Union[None, List[str]]=None,
        sizeInBytesPercentile: Union[None, int]=None,
        sizeInBytesRank: Union[None, int]=None,
        rowCountPercentile: Union[None, int]=None,
        usageSearchScoreMultiplier: Union[None, float]=None,
        usageFreshnessScoreMultiplier: Union[None, float]=None,
        customDatahubScoreMultiplier: Union[None, float]=None,
        combinedSearchRankingMultiplier: Union[None, float]=None,
    ):
        super().__init__()
        
        self.viewCountLast30Days = viewCountLast30Days
        self.viewCountTotal = viewCountTotal
        self.viewCountPercentileLast30Days = viewCountPercentileLast30Days
        self.usageCountLast30Days = usageCountLast30Days
        self.queryCountLast30Days = queryCountLast30Days
        self.uniqueUserCountLast30Days = uniqueUserCountLast30Days
        self.writeCountLast30Days = writeCountLast30Days
        self.queryCountPercentileLast30Days = queryCountPercentileLast30Days
        self.queryCountRankLast30Days = queryCountRankLast30Days
        self.uniqueUserPercentileLast30Days = uniqueUserPercentileLast30Days
        self.uniqueUserRankLast30Days = uniqueUserRankLast30Days
        self.writeCountPercentileLast30Days = writeCountPercentileLast30Days
        self.writeCountRankLast30Days = writeCountRankLast30Days
        self.topUsersLast30Days = topUsersLast30Days
        self.sizeInBytesPercentile = sizeInBytesPercentile
        self.sizeInBytesRank = sizeInBytesRank
        self.rowCountPercentile = rowCountPercentile
        self.usageSearchScoreMultiplier = usageSearchScoreMultiplier
        self.usageFreshnessScoreMultiplier = usageFreshnessScoreMultiplier
        self.customDatahubScoreMultiplier = customDatahubScoreMultiplier
        self.combinedSearchRankingMultiplier = combinedSearchRankingMultiplier
    
    def _restore_defaults(self) -> None:
        self.viewCountLast30Days = self.RECORD_SCHEMA.fields_dict["viewCountLast30Days"].default
        self.viewCountTotal = self.RECORD_SCHEMA.fields_dict["viewCountTotal"].default
        self.viewCountPercentileLast30Days = self.RECORD_SCHEMA.fields_dict["viewCountPercentileLast30Days"].default
        self.usageCountLast30Days = self.RECORD_SCHEMA.fields_dict["usageCountLast30Days"].default
        self.queryCountLast30Days = self.RECORD_SCHEMA.fields_dict["queryCountLast30Days"].default
        self.uniqueUserCountLast30Days = self.RECORD_SCHEMA.fields_dict["uniqueUserCountLast30Days"].default
        self.writeCountLast30Days = self.RECORD_SCHEMA.fields_dict["writeCountLast30Days"].default
        self.queryCountPercentileLast30Days = self.RECORD_SCHEMA.fields_dict["queryCountPercentileLast30Days"].default
        self.queryCountRankLast30Days = self.RECORD_SCHEMA.fields_dict["queryCountRankLast30Days"].default
        self.uniqueUserPercentileLast30Days = self.RECORD_SCHEMA.fields_dict["uniqueUserPercentileLast30Days"].default
        self.uniqueUserRankLast30Days = self.RECORD_SCHEMA.fields_dict["uniqueUserRankLast30Days"].default
        self.writeCountPercentileLast30Days = self.RECORD_SCHEMA.fields_dict["writeCountPercentileLast30Days"].default
        self.writeCountRankLast30Days = self.RECORD_SCHEMA.fields_dict["writeCountRankLast30Days"].default
        self.topUsersLast30Days = self.RECORD_SCHEMA.fields_dict["topUsersLast30Days"].default
        self.sizeInBytesPercentile = self.RECORD_SCHEMA.fields_dict["sizeInBytesPercentile"].default
        self.sizeInBytesRank = self.RECORD_SCHEMA.fields_dict["sizeInBytesRank"].default
        self.rowCountPercentile = self.RECORD_SCHEMA.fields_dict["rowCountPercentile"].default
        self.usageSearchScoreMultiplier = self.RECORD_SCHEMA.fields_dict["usageSearchScoreMultiplier"].default
        self.usageFreshnessScoreMultiplier = self.RECORD_SCHEMA.fields_dict["usageFreshnessScoreMultiplier"].default
        self.customDatahubScoreMultiplier = self.RECORD_SCHEMA.fields_dict["customDatahubScoreMultiplier"].default
        self.combinedSearchRankingMultiplier = self.RECORD_SCHEMA.fields_dict["combinedSearchRankingMultiplier"].default
    
    
    @property
    def viewCountLast30Days(self) -> Union[None, int]:
        """Usage count in the last 30 days
    This field is for Dashboard usage"""
        return self._inner_dict.get('viewCountLast30Days')  # type: ignore
    
    @viewCountLast30Days.setter
    def viewCountLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['viewCountLast30Days'] = value
    
    
    @property
    def viewCountTotal(self) -> Union[None, int]:
        """View count total 
    This field is for Dashboard usage"""
        return self._inner_dict.get('viewCountTotal')  # type: ignore
    
    @viewCountTotal.setter
    def viewCountTotal(self, value: Union[None, int]) -> None:
        self._inner_dict['viewCountTotal'] = value
    
    
    @property
    def viewCountPercentileLast30Days(self) -> Union[None, int]:
        """Percentile rank of the dashboard views based on the the last 30 days view count on a platform"""
        return self._inner_dict.get('viewCountPercentileLast30Days')  # type: ignore
    
    @viewCountPercentileLast30Days.setter
    def viewCountPercentileLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['viewCountPercentileLast30Days'] = value
    
    
    @property
    def usageCountLast30Days(self) -> Union[None, int]:
        """Deprecated - Use queryCountLast30Days instead. Usage count in the last 30 days"""
        return self._inner_dict.get('usageCountLast30Days')  # type: ignore
    
    @usageCountLast30Days.setter
    def usageCountLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['usageCountLast30Days'] = value
    
    
    @property
    def queryCountLast30Days(self) -> Union[None, int]:
        """Dataset Query count in the last 30 days"""
        return self._inner_dict.get('queryCountLast30Days')  # type: ignore
    
    @queryCountLast30Days.setter
    def queryCountLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['queryCountLast30Days'] = value
    
    
    @property
    def uniqueUserCountLast30Days(self) -> Union[None, int]:
        """Unique user count in the last 30 days"""
        return self._inner_dict.get('uniqueUserCountLast30Days')  # type: ignore
    
    @uniqueUserCountLast30Days.setter
    def uniqueUserCountLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueUserCountLast30Days'] = value
    
    
    @property
    def writeCountLast30Days(self) -> Union[None, int]:
        """Write (insert/update) count in the last 30 days"""
        return self._inner_dict.get('writeCountLast30Days')  # type: ignore
    
    @writeCountLast30Days.setter
    def writeCountLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['writeCountLast30Days'] = value
    
    
    @property
    def queryCountPercentileLast30Days(self) -> Union[None, int]:
        """Percentile rank of the dataset based on the the last 30 days usage count on a platform"""
        return self._inner_dict.get('queryCountPercentileLast30Days')  # type: ignore
    
    @queryCountPercentileLast30Days.setter
    def queryCountPercentileLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['queryCountPercentileLast30Days'] = value
    
    
    @property
    def queryCountRankLast30Days(self) -> Union[None, int]:
        """Overall rank of the dataset based on the the last 30 days usage count on a platform
    It returns one plus the number of rows proceeding or equals to the current row in the ordering. """
        return self._inner_dict.get('queryCountRankLast30Days')  # type: ignore
    
    @queryCountRankLast30Days.setter
    def queryCountRankLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['queryCountRankLast30Days'] = value
    
    
    @property
    def uniqueUserPercentileLast30Days(self) -> Union[None, int]:
        """Percentile rank of the dataset based on the the last 30 days of select queries by unique users on a platform"""
        return self._inner_dict.get('uniqueUserPercentileLast30Days')  # type: ignore
    
    @uniqueUserPercentileLast30Days.setter
    def uniqueUserPercentileLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueUserPercentileLast30Days'] = value
    
    
    @property
    def uniqueUserRankLast30Days(self) -> Union[None, int]:
        """Overall rank of the dataset based on the the last 30 days of select queries by unique users on a platform
    It returns one plus the number of rows proceeding or equals to the current row in the ordering. """
        return self._inner_dict.get('uniqueUserRankLast30Days')  # type: ignore
    
    @uniqueUserRankLast30Days.setter
    def uniqueUserRankLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueUserRankLast30Days'] = value
    
    
    @property
    def writeCountPercentileLast30Days(self) -> Union[None, int]:
        """Percentile rank of the dataset based on the the last 30 days insert/update operation count on a platform"""
        return self._inner_dict.get('writeCountPercentileLast30Days')  # type: ignore
    
    @writeCountPercentileLast30Days.setter
    def writeCountPercentileLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['writeCountPercentileLast30Days'] = value
    
    
    @property
    def writeCountRankLast30Days(self) -> Union[None, int]:
        """Overall rank of the dataset based on the the last 30 days insert/update operation count on a platform
    It returns one plus the number of rows proceeding or equals to the current row in the ordering. """
        return self._inner_dict.get('writeCountRankLast30Days')  # type: ignore
    
    @writeCountRankLast30Days.setter
    def writeCountRankLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['writeCountRankLast30Days'] = value
    
    
    @property
    def topUsersLast30Days(self) -> Union[None, List[str]]:
        """Ranked list of the top 10 users in past 30 days. 
    It is ranked by highest usage descending."""
        return self._inner_dict.get('topUsersLast30Days')  # type: ignore
    
    @topUsersLast30Days.setter
    def topUsersLast30Days(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['topUsersLast30Days'] = value
    
    
    @property
    def sizeInBytesPercentile(self) -> Union[None, int]:
        """Deprecated - use StorageFeatures.pdl instead. The percentile of size in bytes relative to other assets from the data plaform instance."""
        return self._inner_dict.get('sizeInBytesPercentile')  # type: ignore
    
    @sizeInBytesPercentile.setter
    def sizeInBytesPercentile(self, value: Union[None, int]) -> None:
        self._inner_dict['sizeInBytesPercentile'] = value
    
    
    @property
    def sizeInBytesRank(self) -> Union[None, int]:
        """Deprecated - use StorageFeatures.pdl instead. The percentile of size in bytes relative to other assets from the data plaform instance."""
        return self._inner_dict.get('sizeInBytesRank')  # type: ignore
    
    @sizeInBytesRank.setter
    def sizeInBytesRank(self, value: Union[None, int]) -> None:
        self._inner_dict['sizeInBytesRank'] = value
    
    
    @property
    def rowCountPercentile(self) -> Union[None, int]:
        """Deprecated - use StorageFeatures.pdl instead. The percentile of row count relative to other assets from the data platform instance."""
        return self._inner_dict.get('rowCountPercentile')  # type: ignore
    
    @rowCountPercentile.setter
    def rowCountPercentile(self, value: Union[None, int]) -> None:
        self._inner_dict['rowCountPercentile'] = value
    
    
    @property
    def usageSearchScoreMultiplier(self) -> Union[None, float]:
        """Multiplier for search score coming from usage"""
        return self._inner_dict.get('usageSearchScoreMultiplier')  # type: ignore
    
    @usageSearchScoreMultiplier.setter
    def usageSearchScoreMultiplier(self, value: Union[None, float]) -> None:
        self._inner_dict['usageSearchScoreMultiplier'] = value
    
    
    @property
    def usageFreshnessScoreMultiplier(self) -> Union[None, float]:
        """Multiplier for search score coming from freshness"""
        return self._inner_dict.get('usageFreshnessScoreMultiplier')  # type: ignore
    
    @usageFreshnessScoreMultiplier.setter
    def usageFreshnessScoreMultiplier(self, value: Union[None, float]) -> None:
        self._inner_dict['usageFreshnessScoreMultiplier'] = value
    
    
    @property
    def customDatahubScoreMultiplier(self) -> Union[None, float]:
        """Multiplier for search score coming from property based adjustment- e.g. URN"""
        return self._inner_dict.get('customDatahubScoreMultiplier')  # type: ignore
    
    @customDatahubScoreMultiplier.setter
    def customDatahubScoreMultiplier(self, value: Union[None, float]) -> None:
        self._inner_dict['customDatahubScoreMultiplier'] = value
    
    
    @property
    def combinedSearchRankingMultiplier(self) -> Union[None, float]:
        """Combined score of all multipliers"""
        return self._inner_dict.get('combinedSearchRankingMultiplier')  # type: ignore
    
    @combinedSearchRankingMultiplier.setter
    def combinedSearchRankingMultiplier(self, value: Union[None, float]) -> None:
        self._inner_dict['combinedSearchRankingMultiplier'] = value
    
    
class ActionRequestSnapshotClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.ActionRequestSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["ActionRequestKeyClass", "ActionRequestStatusClass", "ActionRequestInfoClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["ActionRequestKeyClass", "ActionRequestStatusClass", "ActionRequestInfoClass"]]:
        """The list of metadata aspects associated with the Action Request."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["ActionRequestKeyClass", "ActionRequestStatusClass", "ActionRequestInfoClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class ChartSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific Chart entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.ChartSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["ChartKeyClass", "ChartInfoClass", "ChartQueryClass", "EditableChartPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["ChartKeyClass", "ChartInfoClass", "ChartQueryClass", "EditableChartPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the chart. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["ChartKeyClass", "ChartInfoClass", "ChartQueryClass", "EditableChartPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class CorpGroupSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific CorpGroup entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.CorpGroupSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["CorpGroupKeyClass", "CorpGroupInfoClass", "GlobalTagsClass", "StatusClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["CorpGroupKeyClass", "CorpGroupInfoClass", "GlobalTagsClass", "StatusClass"]]:
        """The list of metadata aspects associated with the LdapUser. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["CorpGroupKeyClass", "CorpGroupInfoClass", "GlobalTagsClass", "StatusClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class CorpUserSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific CorpUser entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.CorpUserSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["CorpUserKeyClass", "CorpUserInfoClass", "CorpUserEditableInfoClass", "CorpUserStatusClass", "GroupMembershipClass", "GlobalTagsClass", "StatusClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["CorpUserKeyClass", "CorpUserInfoClass", "CorpUserEditableInfoClass", "CorpUserStatusClass", "GroupMembershipClass", "GlobalTagsClass", "StatusClass"]]:
        """The list of metadata aspects associated with the CorpUser. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["CorpUserKeyClass", "CorpUserInfoClass", "CorpUserEditableInfoClass", "CorpUserStatusClass", "GroupMembershipClass", "GlobalTagsClass", "StatusClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DashboardSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific Dashboard entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.DashboardSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["DashboardKeyClass", "DashboardInfoClass", "EditableDashboardPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["DashboardKeyClass", "DashboardInfoClass", "EditableDashboardPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the dashboard. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["DashboardKeyClass", "DashboardInfoClass", "EditableDashboardPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DataFlowSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific DataFlow entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.DataFlowSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["DataFlowKeyClass", "DataFlowInfoClass", "EditableDataFlowPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["DataFlowKeyClass", "DataFlowInfoClass", "EditableDataFlowPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the data flow. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["DataFlowKeyClass", "DataFlowInfoClass", "EditableDataFlowPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DataHubPolicySnapshotClass(DictWrapper):
    """A metadata snapshot for DataHub Access Policy data."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.DataHubPolicySnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["DataHubPolicyKeyClass", "DataHubPolicyInfoClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["DataHubPolicyKeyClass", "DataHubPolicyInfoClass"]]:
        """The list of metadata aspects associated with the DataHub access policy."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["DataHubPolicyKeyClass", "DataHubPolicyInfoClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DataHubRetentionSnapshotClass(DictWrapper):
    """A metadata snapshot for DataHub Access Policy data."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.DataHubRetentionSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["DataHubRetentionKeyClass", "DataHubRetentionConfigClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["DataHubRetentionKeyClass", "DataHubRetentionConfigClass"]]:
        """The list of metadata aspects associated with the DataHub access policy."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["DataHubRetentionKeyClass", "DataHubRetentionConfigClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DataJobSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific DataJob entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.DataJobSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["DataJobKeyClass", "DataJobInfoClass", "DataJobInputOutputClass", "EditableDataJobPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["DataJobKeyClass", "DataJobInfoClass", "DataJobInputOutputClass", "EditableDataJobPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the data job. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["DataJobKeyClass", "DataJobInfoClass", "DataJobInputOutputClass", "EditableDataJobPropertiesClass", "OwnershipClass", "StatusClass", "GlobalTagsClass", "BrowsePathsClass", "GlossaryTermsClass", "InstitutionalMemoryClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DataPlatformSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific dataplatform entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.DataPlatformSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["DataPlatformKeyClass", "DataPlatformInfoClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["DataPlatformKeyClass", "DataPlatformInfoClass"]]:
        """The list of metadata aspects associated with the data platform. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["DataPlatformKeyClass", "DataPlatformInfoClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DataProcessSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific Data process entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.DataProcessSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["DataProcessKeyClass", "OwnershipClass", "DataProcessInfoClass", "StatusClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["DataProcessKeyClass", "OwnershipClass", "DataProcessInfoClass", "StatusClass"]]:
        """The list of metadata aspects associated with the data process. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["DataProcessKeyClass", "OwnershipClass", "DataProcessInfoClass", "StatusClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DatasetSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific dataset entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.DatasetSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["DatasetKeyClass", "DatasetPropertiesClass", "EditableDatasetPropertiesClass", "DatasetDeprecationClass", "DatasetUpstreamLineageClass", "UpstreamLineageClass", "InstitutionalMemoryClass", "OwnershipClass", "StatusClass", "SchemaMetadataClass", "EditableSchemaMetadataClass", "GlobalTagsClass", "GlossaryTermsClass", "BrowsePathsClass", "DataPlatformInstanceClass", "ViewPropertiesClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["DatasetKeyClass", "DatasetPropertiesClass", "EditableDatasetPropertiesClass", "DatasetDeprecationClass", "DatasetUpstreamLineageClass", "UpstreamLineageClass", "InstitutionalMemoryClass", "OwnershipClass", "StatusClass", "SchemaMetadataClass", "EditableSchemaMetadataClass", "GlobalTagsClass", "GlossaryTermsClass", "BrowsePathsClass", "DataPlatformInstanceClass", "ViewPropertiesClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the dataset. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["DatasetKeyClass", "DatasetPropertiesClass", "EditableDatasetPropertiesClass", "DatasetDeprecationClass", "DatasetUpstreamLineageClass", "UpstreamLineageClass", "InstitutionalMemoryClass", "OwnershipClass", "StatusClass", "SchemaMetadataClass", "EditableSchemaMetadataClass", "GlobalTagsClass", "GlossaryTermsClass", "BrowsePathsClass", "DataPlatformInstanceClass", "ViewPropertiesClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class GlossaryNodeSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific GlossaryNode entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.GlossaryNodeSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["GlossaryNodeKeyClass", "GlossaryNodeInfoClass", "OwnershipClass", "StatusClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["GlossaryNodeKeyClass", "GlossaryNodeInfoClass", "OwnershipClass", "StatusClass"]]:
        """The list of metadata aspects associated with the GlossaryNode. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["GlossaryNodeKeyClass", "GlossaryNodeInfoClass", "OwnershipClass", "StatusClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class GlossaryTermSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific GlossaryTerm entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.GlossaryTermSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["GlossaryTermKeyClass", "GlossaryTermInfoClass", "OwnershipClass", "StatusClass", "BrowsePathsClass", "GlossaryRelatedTermsClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["GlossaryTermKeyClass", "GlossaryTermInfoClass", "OwnershipClass", "StatusClass", "BrowsePathsClass", "GlossaryRelatedTermsClass"]]:
        """The list of metadata aspects associated with the GlossaryTerm. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["GlossaryTermKeyClass", "GlossaryTermInfoClass", "OwnershipClass", "StatusClass", "BrowsePathsClass", "GlossaryRelatedTermsClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class MLFeatureSnapshotClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.MLFeatureSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["MLFeatureKeyClass", "MLFeaturePropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["MLFeatureKeyClass", "MLFeaturePropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the MLFeature. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["MLFeatureKeyClass", "MLFeaturePropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class MLFeatureTableSnapshotClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.MLFeatureTableSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["MLFeatureTableKeyClass", "MLFeatureTablePropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["MLFeatureTableKeyClass", "MLFeatureTablePropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the MLFeatureTable. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["MLFeatureTableKeyClass", "MLFeatureTablePropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class MLModelDeploymentSnapshotClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.MLModelDeploymentSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["MLModelDeploymentKeyClass", "MLModelDeploymentPropertiesClass", "OwnershipClass", "StatusClass", "DeprecationClass", "GlobalTagsClass", "DataPlatformInstanceClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["MLModelDeploymentKeyClass", "MLModelDeploymentPropertiesClass", "OwnershipClass", "StatusClass", "DeprecationClass", "GlobalTagsClass", "DataPlatformInstanceClass"]]:
        """The list of metadata aspects associated with the MLModelDeployment. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["MLModelDeploymentKeyClass", "MLModelDeploymentPropertiesClass", "OwnershipClass", "StatusClass", "DeprecationClass", "GlobalTagsClass", "DataPlatformInstanceClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class MLModelGroupSnapshotClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.MLModelGroupSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["MLModelGroupKeyClass", "MLModelGroupPropertiesClass", "OwnershipClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["MLModelGroupKeyClass", "MLModelGroupPropertiesClass", "OwnershipClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the MLModelGroup. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["MLModelGroupKeyClass", "MLModelGroupPropertiesClass", "OwnershipClass", "StatusClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class MLModelSnapshotClass(DictWrapper):
    """MLModel Snapshot entity details."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.MLModelSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["MLModelKeyClass", "OwnershipClass", "MLModelPropertiesClass", "IntendedUseClass", "MLModelFactorPromptsClass", "MetricsClass", "EvaluationDataClass", "TrainingDataClass", "QuantitativeAnalysesClass", "EthicalConsiderationsClass", "CaveatsAndRecommendationsClass", "InstitutionalMemoryClass", "SourceCodeClass", "StatusClass", "CostClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["MLModelKeyClass", "OwnershipClass", "MLModelPropertiesClass", "IntendedUseClass", "MLModelFactorPromptsClass", "MetricsClass", "EvaluationDataClass", "TrainingDataClass", "QuantitativeAnalysesClass", "EthicalConsiderationsClass", "CaveatsAndRecommendationsClass", "InstitutionalMemoryClass", "SourceCodeClass", "StatusClass", "CostClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]:
        """The list of metadata aspects associated with the MLModel. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["MLModelKeyClass", "OwnershipClass", "MLModelPropertiesClass", "IntendedUseClass", "MLModelFactorPromptsClass", "MetricsClass", "EvaluationDataClass", "TrainingDataClass", "QuantitativeAnalysesClass", "EthicalConsiderationsClass", "CaveatsAndRecommendationsClass", "InstitutionalMemoryClass", "SourceCodeClass", "StatusClass", "CostClass", "DeprecationClass", "BrowsePathsClass", "GlobalTagsClass", "DataPlatformInstanceClass", "BrowsePathsV2Class"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class MLPrimaryKeySnapshotClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.MLPrimaryKeySnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["MLPrimaryKeyKeyClass", "MLPrimaryKeyPropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "GlobalTagsClass", "DataPlatformInstanceClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["MLPrimaryKeyKeyClass", "MLPrimaryKeyPropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "GlobalTagsClass", "DataPlatformInstanceClass"]]:
        """The list of metadata aspects associated with the MLPrimaryKey. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["MLPrimaryKeyKeyClass", "MLPrimaryKeyPropertiesClass", "OwnershipClass", "InstitutionalMemoryClass", "StatusClass", "DeprecationClass", "GlobalTagsClass", "DataPlatformInstanceClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class SchemaFieldSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific schema field entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.SchemaFieldSnapshot")
    def __init__(self,
        urn: str,
        aspects: List["SchemaFieldKeyClass"],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List["SchemaFieldKeyClass"]:
        """The list of metadata aspects associated with the dataset. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List["SchemaFieldKeyClass"]) -> None:
        self._inner_dict['aspects'] = value
    
    
class TagSnapshotClass(DictWrapper):
    """A metadata snapshot for a specific dataset entity."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metadata.snapshot.TagSnapshot")
    def __init__(self,
        urn: str,
        aspects: List[Union["TagKeyClass", "OwnershipClass", "TagPropertiesClass", "StatusClass"]],
    ):
        super().__init__()
        
        self.urn = urn
        self.aspects = aspects
    
    def _restore_defaults(self) -> None:
        self.urn = str()
        self.aspects = list()
    
    
    @property
    def urn(self) -> str:
        """URN for the entity the metadata snapshot is associated with."""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: str) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def aspects(self) -> List[Union["TagKeyClass", "OwnershipClass", "TagPropertiesClass", "StatusClass"]]:
        """The list of metadata aspects associated with the dataset. Depending on the use case, this can either be all, or a selection, of supported aspects."""
        return self._inner_dict.get('aspects')  # type: ignore
    
    @aspects.setter
    def aspects(self, value: List[Union["TagKeyClass", "OwnershipClass", "TagPropertiesClass", "StatusClass"]]) -> None:
        self._inner_dict['aspects'] = value
    
    
class DataHubMetricCubeDefinitionClass(_Aspect):
    """The structure of an individual metric cube in DataHub."""


    ASPECT_NAME = 'dataHubMetricCubeDefinition'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metric.DataHubMetricCubeDefinition")

    def __init__(self,
        name: str,
        origin: "DataHubMetricCubeOriginClass",
        type: Optional[str]=None,
        description: Union[None, str]=None,
        entity: Union[None, str]=None,
        measures: Union[None, "DataHubMetricCubeMeasuresClass"]=None,
        dimensions: Union[None, "DataHubMetricCubeDimensionsClass"]=None,
    ):
        super().__init__()
        
        self.name = name
        if type is None:
            # default: 'custom'
            self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        else:
            self.type = type
        self.description = description
        self.entity = entity
        self.origin = origin
        self.measures = measures
        self.dimensions = dimensions
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.entity = self.RECORD_SCHEMA.fields_dict["entity"].default
        self.origin = DataHubMetricCubeOriginClass._construct_with_defaults()
        self.measures = self.RECORD_SCHEMA.fields_dict["measures"].default
        self.dimensions = self.RECORD_SCHEMA.fields_dict["dimensions"].default
    
    
    @property
    def name(self) -> str:
        """ Display name of the metric cube"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def type(self) -> str:
        """A type or category for the metric cube. This is used to categorize the metric cube & for filtering.
    
    This may be used to group similar types of metrics for a given entity, e.g. 'row_count', 'error_count', etc.
    that originated in different places."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """ Optional description for the metric"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def entity(self) -> Union[None, str]:
        """ An optional URN for the entity that this metric cube is associated with."""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: Union[None, str]) -> None:
        self._inner_dict['entity'] = value
    
    
    @property
    def origin(self) -> "DataHubMetricCubeOriginClass":
        """The origin of the metric cube."""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: "DataHubMetricCubeOriginClass") -> None:
        self._inner_dict['origin'] = value
    
    
    @property
    def measures(self) -> Union[None, "DataHubMetricCubeMeasuresClass"]:
        """ Optional - The measures of the cube for display purposes."""
        return self._inner_dict.get('measures')  # type: ignore
    
    @measures.setter
    def measures(self, value: Union[None, "DataHubMetricCubeMeasuresClass"]) -> None:
        self._inner_dict['measures'] = value
    
    
    @property
    def dimensions(self) -> Union[None, "DataHubMetricCubeDimensionsClass"]:
        """Optional - The dimensions of the cube for display purposes."""
        return self._inner_dict.get('dimensions')  # type: ignore
    
    @dimensions.setter
    def dimensions(self, value: Union[None, "DataHubMetricCubeDimensionsClass"]) -> None:
        self._inner_dict['dimensions'] = value
    
    
class DataHubMetricCubeDimensionClass(DictWrapper):
    """The definition of a metric cube dimension."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metric.DataHubMetricCubeDimension")
    def __init__(self,
        name: str,
    ):
        super().__init__()
        
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.name = str()
    
    
    @property
    def name(self) -> str:
        """ The name of the dimension"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class DataHubMetricCubeDimensionsClass(DictWrapper):
    """The dimensions of the cube. This is what you filter and group by.
    This is a record to allow for future expansion of the dimensions."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metric.DataHubMetricCubeDimensions")
    def __init__(self,
        dim1: Union[None, "DataHubMetricCubeDimensionClass"]=None,
        dim2: Union[None, "DataHubMetricCubeDimensionClass"]=None,
        dim3: Union[None, "DataHubMetricCubeDimensionClass"]=None,
    ):
        super().__init__()
        
        self.dim1 = dim1
        self.dim2 = dim2
        self.dim3 = dim3
    
    def _restore_defaults(self) -> None:
        self.dim1 = self.RECORD_SCHEMA.fields_dict["dim1"].default
        self.dim2 = self.RECORD_SCHEMA.fields_dict["dim2"].default
        self.dim3 = self.RECORD_SCHEMA.fields_dict["dim3"].default
    
    
    @property
    def dim1(self) -> Union[None, "DataHubMetricCubeDimensionClass"]:
        """ The first measure being tracked in the cube."""
        return self._inner_dict.get('dim1')  # type: ignore
    
    @dim1.setter
    def dim1(self, value: Union[None, "DataHubMetricCubeDimensionClass"]) -> None:
        self._inner_dict['dim1'] = value
    
    
    @property
    def dim2(self) -> Union[None, "DataHubMetricCubeDimensionClass"]:
        """Optional: A second measure being tracked in the cube."""
        return self._inner_dict.get('dim2')  # type: ignore
    
    @dim2.setter
    def dim2(self, value: Union[None, "DataHubMetricCubeDimensionClass"]) -> None:
        self._inner_dict['dim2'] = value
    
    
    @property
    def dim3(self) -> Union[None, "DataHubMetricCubeDimensionClass"]:
        """Optional: A third measure being tracked in the cube."""
        return self._inner_dict.get('dim3')  # type: ignore
    
    @dim3.setter
    def dim3(self, value: Union[None, "DataHubMetricCubeDimensionClass"]) -> None:
        self._inner_dict['dim3'] = value
    
    
class DataHubMetricCubeEventClass(_Aspect):
    """A timeseries measure event, e.g. a single observation."""


    ASPECT_NAME = 'dataHubMetricCubeEvent'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metric.DataHubMetricCubeEvent")

    def __init__(self,
        reportedTimeMillis: int,
        measure: float,
        timestampMillis: int,
        dim1: Union[None, List[str]]=None,
        dim2: Union[None, List[str]]=None,
        dim3: Union[None, List[str]]=None,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.reportedTimeMillis = reportedTimeMillis
        self.measure = measure
        self.dim1 = dim1
        self.dim2 = dim2
        self.dim3 = dim3
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
    
    def _restore_defaults(self) -> None:
        self.reportedTimeMillis = int()
        self.measure = float()
        self.dim1 = self.RECORD_SCHEMA.fields_dict["dim1"].default
        self.dim2 = self.RECORD_SCHEMA.fields_dict["dim2"].default
        self.dim3 = self.RECORD_SCHEMA.fields_dict["dim3"].default
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
    
    
    @property
    def reportedTimeMillis(self) -> int:
        """The event or bucket reported time field as epoch at UTC in milli seconds.
    This must be provided in order to pass validation."""
        return self._inner_dict.get('reportedTimeMillis')  # type: ignore
    
    @reportedTimeMillis.setter
    def reportedTimeMillis(self, value: int) -> None:
        self._inner_dict['reportedTimeMillis'] = value
    
    
    @property
    def measure(self) -> float:
        """The first measure value - Typically this is the primary metric."""
        return self._inner_dict.get('measure')  # type: ignore
    
    @measure.setter
    def measure(self, value: float) -> None:
        self._inner_dict['measure'] = value
    
    
    @property
    def dim1(self) -> Union[None, List[str]]:
        """The first dimension value(s). Array type to support multi-dimensionality."""
        return self._inner_dict.get('dim1')  # type: ignore
    
    @dim1.setter
    def dim1(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['dim1'] = value
    
    
    @property
    def dim2(self) -> Union[None, List[str]]:
        """The second dimension value(s). Array type to support multi-dimensionality."""
        return self._inner_dict.get('dim2')  # type: ignore
    
    @dim2.setter
    def dim2(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['dim2'] = value
    
    
    @property
    def dim3(self) -> Union[None, List[str]]:
        """The third dimension value(s). Array type to support multi-dimensionality."""
        return self._inner_dict.get('dim3')  # type: ignore
    
    @dim3.setter
    def dim3(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['dim3'] = value
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
class DataHubMetricCubeMeasureClass(DictWrapper):
    """The definition of a metric cube measure."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metric.DataHubMetricCubeMeasure")
    def __init__(self,
        name: str,
    ):
        super().__init__()
        
        self.name = name
    
    def _restore_defaults(self) -> None:
        self.name = str()
    
    
    @property
    def name(self) -> str:
        """ The name of the measure"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
class DataHubMetricCubeMeasuresClass(DictWrapper):
    """The definition of the measures of a metric cube.
    A measure is a metric that is being tracked in the cube."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metric.DataHubMetricCubeMeasures")
    def __init__(self,
        measure: "DataHubMetricCubeMeasureClass",
    ):
        super().__init__()
        
        self.measure = measure
    
    def _restore_defaults(self) -> None:
        self.measure = DataHubMetricCubeMeasureClass._construct_with_defaults()
    
    
    @property
    def measure(self) -> "DataHubMetricCubeMeasureClass":
        """ The first measure being tracked in the cube."""
        return self._inner_dict.get('measure')  # type: ignore
    
    @measure.setter
    def measure(self, value: "DataHubMetricCubeMeasureClass") -> None:
        self._inner_dict['measure'] = value
    
    
class DataHubMetricCubeOriginClass(DictWrapper):
    """Information about the origin of the metric cube"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.metric.DataHubMetricCubeOrigin")
    def __init__(self,
        type: Union[str, "DataHubMetricSourceTypeClass"],
        originUrn: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.originUrn = originUrn
    
    def _restore_defaults(self) -> None:
        self.type = DataHubMetricSourceTypeClass.MANUAL
        self.originUrn = self.RECORD_SCHEMA.fields_dict["originUrn"].default
    
    
    @property
    def type(self) -> Union[str, "DataHubMetricSourceTypeClass"]:
        """Message associated with the incident"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DataHubMetricSourceTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def originUrn(self) -> Union[None, str]:
        """Reference to the source that created the metric.
    In the case of assertion monitor, this is the URN of the assertion monitor."""
        return self._inner_dict.get('originUrn')  # type: ignore
    
    @originUrn.setter
    def originUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['originUrn'] = value
    
    
class DataHubMetricSourceTypeClass(object):
    # No docs available.
    
    MANUAL = "MANUAL"
    """Manually created metric, via UI or API."""
    
    ASSERTION_MONITOR = "ASSERTION_MONITOR"
    """Assertion monitor created the metric."""
    
    
    
class BaseDataClass(DictWrapper):
    """BaseData record"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.BaseData")
    def __init__(self,
        dataset: str,
        motivation: Union[None, str]=None,
        preProcessing: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.dataset = dataset
        self.motivation = motivation
        self.preProcessing = preProcessing
    
    def _restore_defaults(self) -> None:
        self.dataset = str()
        self.motivation = self.RECORD_SCHEMA.fields_dict["motivation"].default
        self.preProcessing = self.RECORD_SCHEMA.fields_dict["preProcessing"].default
    
    
    @property
    def dataset(self) -> str:
        """What dataset were used in the MLModel?"""
        return self._inner_dict.get('dataset')  # type: ignore
    
    @dataset.setter
    def dataset(self, value: str) -> None:
        self._inner_dict['dataset'] = value
    
    
    @property
    def motivation(self) -> Union[None, str]:
        """Why was this dataset chosen?"""
        return self._inner_dict.get('motivation')  # type: ignore
    
    @motivation.setter
    def motivation(self, value: Union[None, str]) -> None:
        self._inner_dict['motivation'] = value
    
    
    @property
    def preProcessing(self) -> Union[None, List[str]]:
        """How was the data preprocessed (e.g., tokenization of sentences, cropping of images, any filtering such as dropping images without faces)?"""
        return self._inner_dict.get('preProcessing')  # type: ignore
    
    @preProcessing.setter
    def preProcessing(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['preProcessing'] = value
    
    
class CaveatDetailsClass(DictWrapper):
    """This section should list additional concerns that were not covered in the previous sections. For example, did the results suggest any further testing? Were there any relevant groups that were not represented in the evaluation dataset? Are there additional recommendations for model use?"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.CaveatDetails")
    def __init__(self,
        needsFurtherTesting: Union[None, bool]=None,
        caveatDescription: Union[None, str]=None,
        groupsNotRepresented: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.needsFurtherTesting = needsFurtherTesting
        self.caveatDescription = caveatDescription
        self.groupsNotRepresented = groupsNotRepresented
    
    def _restore_defaults(self) -> None:
        self.needsFurtherTesting = self.RECORD_SCHEMA.fields_dict["needsFurtherTesting"].default
        self.caveatDescription = self.RECORD_SCHEMA.fields_dict["caveatDescription"].default
        self.groupsNotRepresented = self.RECORD_SCHEMA.fields_dict["groupsNotRepresented"].default
    
    
    @property
    def needsFurtherTesting(self) -> Union[None, bool]:
        """Did the results suggest any further testing?"""
        return self._inner_dict.get('needsFurtherTesting')  # type: ignore
    
    @needsFurtherTesting.setter
    def needsFurtherTesting(self, value: Union[None, bool]) -> None:
        self._inner_dict['needsFurtherTesting'] = value
    
    
    @property
    def caveatDescription(self) -> Union[None, str]:
        """Caveat Description
    For ex: Given gender classes are binary (male/not male), which we include as male/female. Further work needed to evaluate across a spectrum of genders."""
        return self._inner_dict.get('caveatDescription')  # type: ignore
    
    @caveatDescription.setter
    def caveatDescription(self, value: Union[None, str]) -> None:
        self._inner_dict['caveatDescription'] = value
    
    
    @property
    def groupsNotRepresented(self) -> Union[None, List[str]]:
        """Relevant groups that were not represented in the evaluation dataset?"""
        return self._inner_dict.get('groupsNotRepresented')  # type: ignore
    
    @groupsNotRepresented.setter
    def groupsNotRepresented(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['groupsNotRepresented'] = value
    
    
class CaveatsAndRecommendationsClass(_Aspect):
    """This section should list additional concerns that were not covered in the previous sections. For example, did the results suggest any further testing? Were there any relevant groups that were not represented in the evaluation dataset? Are there additional recommendations for model use?"""


    ASPECT_NAME = 'mlModelCaveatsAndRecommendations'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.CaveatsAndRecommendations")

    def __init__(self,
        caveats: Union[None, "CaveatDetailsClass"]=None,
        recommendations: Union[None, str]=None,
        idealDatasetCharacteristics: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.caveats = caveats
        self.recommendations = recommendations
        self.idealDatasetCharacteristics = idealDatasetCharacteristics
    
    def _restore_defaults(self) -> None:
        self.caveats = self.RECORD_SCHEMA.fields_dict["caveats"].default
        self.recommendations = self.RECORD_SCHEMA.fields_dict["recommendations"].default
        self.idealDatasetCharacteristics = self.RECORD_SCHEMA.fields_dict["idealDatasetCharacteristics"].default
    
    
    @property
    def caveats(self) -> Union[None, "CaveatDetailsClass"]:
        """This section should list additional concerns that were not covered in the previous sections. For example, did the results suggest any further testing? Were there any relevant groups that were not represented in the evaluation dataset?"""
        return self._inner_dict.get('caveats')  # type: ignore
    
    @caveats.setter
    def caveats(self, value: Union[None, "CaveatDetailsClass"]) -> None:
        self._inner_dict['caveats'] = value
    
    
    @property
    def recommendations(self) -> Union[None, str]:
        """Recommendations on where this MLModel should be used."""
        return self._inner_dict.get('recommendations')  # type: ignore
    
    @recommendations.setter
    def recommendations(self, value: Union[None, str]) -> None:
        self._inner_dict['recommendations'] = value
    
    
    @property
    def idealDatasetCharacteristics(self) -> Union[None, List[str]]:
        """Ideal characteristics of an evaluation dataset for this MLModel"""
        return self._inner_dict.get('idealDatasetCharacteristics')  # type: ignore
    
    @idealDatasetCharacteristics.setter
    def idealDatasetCharacteristics(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['idealDatasetCharacteristics'] = value
    
    
class DeploymentStatusClass(object):
    """Model endpoint statuses"""
    
    OUT_OF_SERVICE = "OUT_OF_SERVICE"
    """Deployments out of service."""
    
    CREATING = "CREATING"
    """Deployments being created."""
    
    UPDATING = "UPDATING"
    """Deployments being updated."""
    
    ROLLING_BACK = "ROLLING_BACK"
    """Deployments being reverted to a previous version."""
    
    IN_SERVICE = "IN_SERVICE"
    """Deployments that are active."""
    
    DELETING = "DELETING"
    """Deployments being deleted."""
    
    FAILED = "FAILED"
    """Deployments with an error state."""
    
    UNKNOWN = "UNKNOWN"
    """Deployments with unknown/unmappable state."""
    
    
    
class EditableMLFeaturePropertiesClass(_Aspect):
    """Properties associated with a MLFeature editable from the UI"""


    ASPECT_NAME = 'editableMlFeatureProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.EditableMLFeatureProperties")

    def __init__(self,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLFeature"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class EditableMLFeatureTablePropertiesClass(_Aspect):
    """Properties associated with a MLFeatureTable editable from the ui"""


    ASPECT_NAME = 'editableMlFeatureTableProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.EditableMLFeatureTableProperties")

    def __init__(self,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLFeatureTable"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class EditableMLModelGroupPropertiesClass(_Aspect):
    """Properties associated with an ML Model Group editable from the UI"""


    ASPECT_NAME = 'editableMlModelGroupProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.EditableMLModelGroupProperties")

    def __init__(self,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the ml model group"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class EditableMLModelPropertiesClass(_Aspect):
    """Properties associated with a ML Model editable from the UI"""


    ASPECT_NAME = 'editableMlModelProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.EditableMLModelProperties")

    def __init__(self,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the ml model"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class EditableMLPrimaryKeyPropertiesClass(_Aspect):
    """Properties associated with a MLPrimaryKey editable from the UI"""


    ASPECT_NAME = 'editableMlPrimaryKeyProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.EditableMLPrimaryKeyProperties")

    def __init__(self,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLPrimaryKey"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class EthicalConsiderationsClass(_Aspect):
    """This section is intended to demonstrate the ethical considerations that went into MLModel development, surfacing ethical challenges and solutions to stakeholders."""


    ASPECT_NAME = 'mlModelEthicalConsiderations'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.EthicalConsiderations")

    def __init__(self,
        data: Union[None, List[str]]=None,
        humanLife: Union[None, List[str]]=None,
        mitigations: Union[None, List[str]]=None,
        risksAndHarms: Union[None, List[str]]=None,
        useCases: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.data = data
        self.humanLife = humanLife
        self.mitigations = mitigations
        self.risksAndHarms = risksAndHarms
        self.useCases = useCases
    
    def _restore_defaults(self) -> None:
        self.data = self.RECORD_SCHEMA.fields_dict["data"].default
        self.humanLife = self.RECORD_SCHEMA.fields_dict["humanLife"].default
        self.mitigations = self.RECORD_SCHEMA.fields_dict["mitigations"].default
        self.risksAndHarms = self.RECORD_SCHEMA.fields_dict["risksAndHarms"].default
        self.useCases = self.RECORD_SCHEMA.fields_dict["useCases"].default
    
    
    @property
    def data(self) -> Union[None, List[str]]:
        """Does the MLModel use any sensitive data (e.g., protected classes)?"""
        return self._inner_dict.get('data')  # type: ignore
    
    @data.setter
    def data(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['data'] = value
    
    
    @property
    def humanLife(self) -> Union[None, List[str]]:
        """ Is the MLModel intended to inform decisions about matters central to human life or flourishing - e.g., health or safety? Or could it be used in such a way?"""
        return self._inner_dict.get('humanLife')  # type: ignore
    
    @humanLife.setter
    def humanLife(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['humanLife'] = value
    
    
    @property
    def mitigations(self) -> Union[None, List[str]]:
        """What risk mitigation strategies were used during MLModel development?"""
        return self._inner_dict.get('mitigations')  # type: ignore
    
    @mitigations.setter
    def mitigations(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['mitigations'] = value
    
    
    @property
    def risksAndHarms(self) -> Union[None, List[str]]:
        """What risks may be present in MLModel usage? Try to identify the potential recipients, likelihood, and magnitude of harms. If these cannot be determined, note that they were considered but remain unknown."""
        return self._inner_dict.get('risksAndHarms')  # type: ignore
    
    @risksAndHarms.setter
    def risksAndHarms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['risksAndHarms'] = value
    
    
    @property
    def useCases(self) -> Union[None, List[str]]:
        """Are there any known MLModel use cases that are especially fraught? This may connect directly to the intended use section"""
        return self._inner_dict.get('useCases')  # type: ignore
    
    @useCases.setter
    def useCases(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['useCases'] = value
    
    
class EvaluationDataClass(_Aspect):
    """All referenced datasets would ideally point to any set of documents that provide visibility into the source and composition of the dataset."""


    ASPECT_NAME = 'mlModelEvaluationData'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.EvaluationData")

    def __init__(self,
        evaluationData: List["BaseDataClass"],
    ):
        super().__init__()
        
        self.evaluationData = evaluationData
    
    def _restore_defaults(self) -> None:
        self.evaluationData = list()
    
    
    @property
    def evaluationData(self) -> List["BaseDataClass"]:
        """Details on the dataset(s) used for the quantitative analyses in the MLModel"""
        return self._inner_dict.get('evaluationData')  # type: ignore
    
    @evaluationData.setter
    def evaluationData(self, value: List["BaseDataClass"]) -> None:
        self._inner_dict['evaluationData'] = value
    
    
class IntendedUseClass(_Aspect):
    """Intended Use for the ML Model"""


    ASPECT_NAME = 'intendedUse'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.IntendedUse")

    def __init__(self,
        primaryUses: Union[None, List[str]]=None,
        primaryUsers: Union[None, List[Union[str, "IntendedUserTypeClass"]]]=None,
        outOfScopeUses: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.primaryUses = primaryUses
        self.primaryUsers = primaryUsers
        self.outOfScopeUses = outOfScopeUses
    
    def _restore_defaults(self) -> None:
        self.primaryUses = self.RECORD_SCHEMA.fields_dict["primaryUses"].default
        self.primaryUsers = self.RECORD_SCHEMA.fields_dict["primaryUsers"].default
        self.outOfScopeUses = self.RECORD_SCHEMA.fields_dict["outOfScopeUses"].default
    
    
    @property
    def primaryUses(self) -> Union[None, List[str]]:
        """Primary Use cases for the MLModel."""
        return self._inner_dict.get('primaryUses')  # type: ignore
    
    @primaryUses.setter
    def primaryUses(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['primaryUses'] = value
    
    
    @property
    def primaryUsers(self) -> Union[None, List[Union[str, "IntendedUserTypeClass"]]]:
        """Primary Intended Users - For example, was the MLModel developed for entertainment purposes, for hobbyists, or enterprise solutions?"""
        return self._inner_dict.get('primaryUsers')  # type: ignore
    
    @primaryUsers.setter
    def primaryUsers(self, value: Union[None, List[Union[str, "IntendedUserTypeClass"]]]) -> None:
        self._inner_dict['primaryUsers'] = value
    
    
    @property
    def outOfScopeUses(self) -> Union[None, List[str]]:
        """Highlight technology that the MLModel might easily be confused with, or related contexts that users could try to apply the MLModel to."""
        return self._inner_dict.get('outOfScopeUses')  # type: ignore
    
    @outOfScopeUses.setter
    def outOfScopeUses(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['outOfScopeUses'] = value
    
    
class IntendedUserTypeClass(object):
    # No docs available.
    
    ENTERPRISE = "ENTERPRISE"
    HOBBY = "HOBBY"
    ENTERTAINMENT = "ENTERTAINMENT"
    
    
class MLFeaturePropertiesClass(_Aspect):
    """Properties associated with a MLFeature"""


    ASPECT_NAME = 'mlFeatureProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLFeatureProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        description: Union[None, str]=None,
        dataType: Union[None, Union[str, "MLFeatureDataTypeClass"]]=None,
        version: Union[None, "VersionTagClass"]=None,
        sources: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.description = description
        self.dataType = dataType
        self.version = version
        self.sources = sources
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.dataType = self.RECORD_SCHEMA.fields_dict["dataType"].default
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
        self.sources = self.RECORD_SCHEMA.fields_dict["sources"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLFeature"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def dataType(self) -> Union[None, Union[str, "MLFeatureDataTypeClass"]]:
        """Data Type of the MLFeature"""
        return self._inner_dict.get('dataType')  # type: ignore
    
    @dataType.setter
    def dataType(self, value: Union[None, Union[str, "MLFeatureDataTypeClass"]]) -> None:
        self._inner_dict['dataType'] = value
    
    
    @property
    def version(self) -> Union[None, "VersionTagClass"]:
        """Version of the MLFeature"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, "VersionTagClass"]) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def sources(self) -> Union[None, List[str]]:
        """Source of the MLFeature"""
        return self._inner_dict.get('sources')  # type: ignore
    
    @sources.setter
    def sources(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['sources'] = value
    
    
class MLFeatureTablePropertiesClass(_Aspect):
    """Properties associated with a MLFeatureTable"""


    ASPECT_NAME = 'mlFeatureTableProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLFeatureTableProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        description: Union[None, str]=None,
        mlFeatures: Union[None, List[str]]=None,
        mlPrimaryKeys: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.description = description
        self.mlFeatures = mlFeatures
        self.mlPrimaryKeys = mlPrimaryKeys
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.mlFeatures = self.RECORD_SCHEMA.fields_dict["mlFeatures"].default
        self.mlPrimaryKeys = self.RECORD_SCHEMA.fields_dict["mlPrimaryKeys"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLFeatureTable"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def mlFeatures(self) -> Union[None, List[str]]:
        """List of features contained in the feature table"""
        return self._inner_dict.get('mlFeatures')  # type: ignore
    
    @mlFeatures.setter
    def mlFeatures(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['mlFeatures'] = value
    
    
    @property
    def mlPrimaryKeys(self) -> Union[None, List[str]]:
        """List of primary keys in the feature table (if multiple, assumed to act as a composite key)"""
        return self._inner_dict.get('mlPrimaryKeys')  # type: ignore
    
    @mlPrimaryKeys.setter
    def mlPrimaryKeys(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['mlPrimaryKeys'] = value
    
    
class MLHyperParamClass(_Aspect):
    """Properties associated with an ML Hyper Param"""


    ASPECT_NAME = 'mlHyperParam'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLHyperParam")

    def __init__(self,
        name: str,
        description: Union[None, str]=None,
        value: Union[None, str]=None,
        createdAt: Union[None, int]=None,
    ):
        super().__init__()
        
        self.name = name
        self.description = description
        self.value = value
        self.createdAt = createdAt
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.value = self.RECORD_SCHEMA.fields_dict["value"].default
        self.createdAt = self.RECORD_SCHEMA.fields_dict["createdAt"].default
    
    
    @property
    def name(self) -> str:
        """Name of the MLHyperParam"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLHyperParam"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def value(self) -> Union[None, str]:
        """The value of the MLHyperParam"""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: Union[None, str]) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def createdAt(self) -> Union[None, int]:
        """Date when the MLHyperParam was developed"""
        return self._inner_dict.get('createdAt')  # type: ignore
    
    @createdAt.setter
    def createdAt(self, value: Union[None, int]) -> None:
        self._inner_dict['createdAt'] = value
    
    
class MLMetricClass(_Aspect):
    """Properties associated with an ML Metric"""


    ASPECT_NAME = 'mlMetric'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLMetric")

    def __init__(self,
        name: str,
        description: Union[None, str]=None,
        value: Union[None, str]=None,
        createdAt: Union[None, int]=None,
    ):
        super().__init__()
        
        self.name = name
        self.description = description
        self.value = value
        self.createdAt = createdAt
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.value = self.RECORD_SCHEMA.fields_dict["value"].default
        self.createdAt = self.RECORD_SCHEMA.fields_dict["createdAt"].default
    
    
    @property
    def name(self) -> str:
        """Name of the mlMetric"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the mlMetric"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def value(self) -> Union[None, str]:
        """The value of the mlMetric"""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: Union[None, str]) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def createdAt(self) -> Union[None, int]:
        """Date when the mlMetric was developed"""
        return self._inner_dict.get('createdAt')  # type: ignore
    
    @createdAt.setter
    def createdAt(self, value: Union[None, int]) -> None:
        self._inner_dict['createdAt'] = value
    
    
class MLModelDeploymentPropertiesClass(_Aspect):
    """Properties associated with an ML Model Deployment"""


    ASPECT_NAME = 'mlModelDeploymentProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLModelDeploymentProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        description: Union[None, str]=None,
        createdAt: Union[None, int]=None,
        version: Union[None, "VersionTagClass"]=None,
        status: Union[None, Union[str, "DeploymentStatusClass"]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.description = description
        self.createdAt = createdAt
        self.version = version
        self.status = status
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.createdAt = self.RECORD_SCHEMA.fields_dict["createdAt"].default
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
        self.status = self.RECORD_SCHEMA.fields_dict["status"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLModelDeployment"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def createdAt(self) -> Union[None, int]:
        """Date when the MLModelDeployment was developed"""
        return self._inner_dict.get('createdAt')  # type: ignore
    
    @createdAt.setter
    def createdAt(self, value: Union[None, int]) -> None:
        self._inner_dict['createdAt'] = value
    
    
    @property
    def version(self) -> Union[None, "VersionTagClass"]:
        """Version of the MLModelDeployment"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, "VersionTagClass"]) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def status(self) -> Union[None, Union[str, "DeploymentStatusClass"]]:
        """Status of the deployment"""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[None, Union[str, "DeploymentStatusClass"]]) -> None:
        self._inner_dict['status'] = value
    
    
class MLModelFactorPromptsClass(_Aspect):
    """Prompts which affect the performance of the MLModel"""


    ASPECT_NAME = 'mlModelFactorPrompts'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLModelFactorPrompts")

    def __init__(self,
        relevantFactors: Union[None, List["MLModelFactorsClass"]]=None,
        evaluationFactors: Union[None, List["MLModelFactorsClass"]]=None,
    ):
        super().__init__()
        
        self.relevantFactors = relevantFactors
        self.evaluationFactors = evaluationFactors
    
    def _restore_defaults(self) -> None:
        self.relevantFactors = self.RECORD_SCHEMA.fields_dict["relevantFactors"].default
        self.evaluationFactors = self.RECORD_SCHEMA.fields_dict["evaluationFactors"].default
    
    
    @property
    def relevantFactors(self) -> Union[None, List["MLModelFactorsClass"]]:
        """What are foreseeable salient factors for which MLModel performance may vary, and how were these determined?"""
        return self._inner_dict.get('relevantFactors')  # type: ignore
    
    @relevantFactors.setter
    def relevantFactors(self, value: Union[None, List["MLModelFactorsClass"]]) -> None:
        self._inner_dict['relevantFactors'] = value
    
    
    @property
    def evaluationFactors(self) -> Union[None, List["MLModelFactorsClass"]]:
        """Which factors are being reported, and why were these chosen?"""
        return self._inner_dict.get('evaluationFactors')  # type: ignore
    
    @evaluationFactors.setter
    def evaluationFactors(self, value: Union[None, List["MLModelFactorsClass"]]) -> None:
        self._inner_dict['evaluationFactors'] = value
    
    
class MLModelFactorsClass(DictWrapper):
    """Factors affecting the performance of the MLModel."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLModelFactors")
    def __init__(self,
        groups: Union[None, List[str]]=None,
        instrumentation: Union[None, List[str]]=None,
        environment: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.groups = groups
        self.instrumentation = instrumentation
        self.environment = environment
    
    def _restore_defaults(self) -> None:
        self.groups = self.RECORD_SCHEMA.fields_dict["groups"].default
        self.instrumentation = self.RECORD_SCHEMA.fields_dict["instrumentation"].default
        self.environment = self.RECORD_SCHEMA.fields_dict["environment"].default
    
    
    @property
    def groups(self) -> Union[None, List[str]]:
        """Groups refers to distinct categories with similar characteristics that are present in the evaluation data instances.
    For human-centric machine learning MLModels, groups are people who share one or multiple characteristics."""
        return self._inner_dict.get('groups')  # type: ignore
    
    @groups.setter
    def groups(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['groups'] = value
    
    
    @property
    def instrumentation(self) -> Union[None, List[str]]:
        """The performance of a MLModel can vary depending on what instruments were used to capture the input to the MLModel.
    For example, a face detection model may perform differently depending on the camera's hardware and software,
    including lens, image stabilization, high dynamic range techniques, and background blurring for portrait mode."""
        return self._inner_dict.get('instrumentation')  # type: ignore
    
    @instrumentation.setter
    def instrumentation(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['instrumentation'] = value
    
    
    @property
    def environment(self) -> Union[None, List[str]]:
        """A further factor affecting MLModel performance is the environment in which it is deployed."""
        return self._inner_dict.get('environment')  # type: ignore
    
    @environment.setter
    def environment(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['environment'] = value
    
    
class MLModelGroupPropertiesClass(_Aspect):
    """Properties associated with an ML Model Group"""


    ASPECT_NAME = 'mlModelGroupProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLModelGroupProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        trainingJobs: Union[None, List[str]]=None,
        downstreamJobs: Union[None, List[str]]=None,
        externalUrl: Union[None, str]=None,
        name: Union[None, str]=None,
        description: Union[None, str]=None,
        createdAt: Union[None, int]=None,
        created: Union[None, "TimeStampClass"]=None,
        lastModified: Union[None, "TimeStampClass"]=None,
        version: Union[None, "VersionTagClass"]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.trainingJobs = trainingJobs
        self.downstreamJobs = downstreamJobs
        self.externalUrl = externalUrl
        self.name = name
        self.description = description
        self.createdAt = createdAt
        self.created = created
        self.lastModified = lastModified
        self.version = version
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.trainingJobs = self.RECORD_SCHEMA.fields_dict["trainingJobs"].default
        self.downstreamJobs = self.RECORD_SCHEMA.fields_dict["downstreamJobs"].default
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.createdAt = self.RECORD_SCHEMA.fields_dict["createdAt"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def trainingJobs(self) -> Union[None, List[str]]:
        """List of jobs or process instances (if any) used to train the model or group. Visible in Lineage. Note that ML Models can also be specified as the output of a specific Data Process Instances (runs) via the DataProcessInstanceOutputs aspect."""
        return self._inner_dict.get('trainingJobs')  # type: ignore
    
    @trainingJobs.setter
    def trainingJobs(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['trainingJobs'] = value
    
    
    @property
    def downstreamJobs(self) -> Union[None, List[str]]:
        """List of jobs or process instances (if any) that use the model or group."""
        return self._inner_dict.get('downstreamJobs')  # type: ignore
    
    @downstreamJobs.setter
    def downstreamJobs(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['downstreamJobs'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the MLModelGroup"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLModelGroup"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def createdAt(self) -> Union[None, int]:
        """Date when the MLModelGroup was developed"""
        return self._inner_dict.get('createdAt')  # type: ignore
    
    @createdAt.setter
    def createdAt(self, value: Union[None, int]) -> None:
        self._inner_dict['createdAt'] = value
    
    
    @property
    def created(self) -> Union[None, "TimeStampClass"]:
        """Time and Actor who created the MLModelGroup"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "TimeStampClass"]:
        """Date when the MLModelGroup was last modified"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def version(self) -> Union[None, "VersionTagClass"]:
        """Version of the MLModelGroup"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, "VersionTagClass"]) -> None:
        self._inner_dict['version'] = value
    
    
class MLModelPropertiesClass(_Aspect):
    """Properties associated with a ML Model"""


    ASPECT_NAME = 'mlModelProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLModelProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        trainingJobs: Union[None, List[str]]=None,
        downstreamJobs: Union[None, List[str]]=None,
        name: Union[None, str]=None,
        description: Union[None, str]=None,
        date: Union[None, int]=None,
        created: Union[None, "TimeStampClass"]=None,
        lastModified: Union[None, "TimeStampClass"]=None,
        version: Union[None, "VersionTagClass"]=None,
        type: Union[None, str]=None,
        hyperParameters: Union[None, Dict[str, Union[str, int, float, float, bool]]]=None,
        hyperParams: Union[None, List["MLHyperParamClass"]]=None,
        trainingMetrics: Union[None, List["MLMetricClass"]]=None,
        onlineMetrics: Union[None, List["MLMetricClass"]]=None,
        mlFeatures: Union[None, List[str]]=None,
        tags: Optional[List[str]]=None,
        deployments: Union[None, List[str]]=None,
        groups: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.trainingJobs = trainingJobs
        self.downstreamJobs = downstreamJobs
        self.name = name
        self.description = description
        self.date = date
        self.created = created
        self.lastModified = lastModified
        self.version = version
        self.type = type
        self.hyperParameters = hyperParameters
        self.hyperParams = hyperParams
        self.trainingMetrics = trainingMetrics
        self.onlineMetrics = onlineMetrics
        self.mlFeatures = mlFeatures
        if tags is None:
            # default: []
            self.tags = list()
        else:
            self.tags = tags
        self.deployments = deployments
        self.groups = groups
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.trainingJobs = self.RECORD_SCHEMA.fields_dict["trainingJobs"].default
        self.downstreamJobs = self.RECORD_SCHEMA.fields_dict["downstreamJobs"].default
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.date = self.RECORD_SCHEMA.fields_dict["date"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        self.hyperParameters = self.RECORD_SCHEMA.fields_dict["hyperParameters"].default
        self.hyperParams = self.RECORD_SCHEMA.fields_dict["hyperParams"].default
        self.trainingMetrics = self.RECORD_SCHEMA.fields_dict["trainingMetrics"].default
        self.onlineMetrics = self.RECORD_SCHEMA.fields_dict["onlineMetrics"].default
        self.mlFeatures = self.RECORD_SCHEMA.fields_dict["mlFeatures"].default
        self.tags = list()
        self.deployments = self.RECORD_SCHEMA.fields_dict["deployments"].default
        self.groups = self.RECORD_SCHEMA.fields_dict["groups"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def trainingJobs(self) -> Union[None, List[str]]:
        """List of jobs or process instances (if any) used to train the model or group. Visible in Lineage. Note that ML Models can also be specified as the output of a specific Data Process Instances (runs) via the DataProcessInstanceOutputs aspect."""
        return self._inner_dict.get('trainingJobs')  # type: ignore
    
    @trainingJobs.setter
    def trainingJobs(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['trainingJobs'] = value
    
    
    @property
    def downstreamJobs(self) -> Union[None, List[str]]:
        """List of jobs or process instances (if any) that use the model or group."""
        return self._inner_dict.get('downstreamJobs')  # type: ignore
    
    @downstreamJobs.setter
    def downstreamJobs(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['downstreamJobs'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Display name of the MLModel"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLModel"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def date(self) -> Union[None, int]:
        """Date when the MLModel was developed"""
        return self._inner_dict.get('date')  # type: ignore
    
    @date.setter
    def date(self, value: Union[None, int]) -> None:
        self._inner_dict['date'] = value
    
    
    @property
    def created(self) -> Union[None, "TimeStampClass"]:
        """Audit stamp containing who created this and when"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "TimeStampClass"]:
        """Date when the MLModel was last modified"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "TimeStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def version(self) -> Union[None, "VersionTagClass"]:
        """Version of the MLModel"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, "VersionTagClass"]) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def type(self) -> Union[None, str]:
        """Type of Algorithm or MLModel such as whether it is a Naive Bayes classifier, Convolutional Neural Network, etc"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[None, str]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def hyperParameters(self) -> Union[None, Dict[str, Union[str, int, float, float, bool]]]:
        """Hyper Parameters of the MLModel
    
    NOTE: these are deprecated in favor of hyperParams"""
        return self._inner_dict.get('hyperParameters')  # type: ignore
    
    @hyperParameters.setter
    def hyperParameters(self, value: Union[None, Dict[str, Union[str, int, float, float, bool]]]) -> None:
        self._inner_dict['hyperParameters'] = value
    
    
    @property
    def hyperParams(self) -> Union[None, List["MLHyperParamClass"]]:
        """Hyperparameters of the MLModel"""
        return self._inner_dict.get('hyperParams')  # type: ignore
    
    @hyperParams.setter
    def hyperParams(self, value: Union[None, List["MLHyperParamClass"]]) -> None:
        self._inner_dict['hyperParams'] = value
    
    
    @property
    def trainingMetrics(self) -> Union[None, List["MLMetricClass"]]:
        """Metrics of the MLModel used in training"""
        return self._inner_dict.get('trainingMetrics')  # type: ignore
    
    @trainingMetrics.setter
    def trainingMetrics(self, value: Union[None, List["MLMetricClass"]]) -> None:
        self._inner_dict['trainingMetrics'] = value
    
    
    @property
    def onlineMetrics(self) -> Union[None, List["MLMetricClass"]]:
        """Metrics of the MLModel used in production"""
        return self._inner_dict.get('onlineMetrics')  # type: ignore
    
    @onlineMetrics.setter
    def onlineMetrics(self, value: Union[None, List["MLMetricClass"]]) -> None:
        self._inner_dict['onlineMetrics'] = value
    
    
    @property
    def mlFeatures(self) -> Union[None, List[str]]:
        """List of features used for MLModel training"""
        return self._inner_dict.get('mlFeatures')  # type: ignore
    
    @mlFeatures.setter
    def mlFeatures(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['mlFeatures'] = value
    
    
    @property
    def tags(self) -> List[str]:
        """Tags for the MLModel"""
        return self._inner_dict.get('tags')  # type: ignore
    
    @tags.setter
    def tags(self, value: List[str]) -> None:
        self._inner_dict['tags'] = value
    
    
    @property
    def deployments(self) -> Union[None, List[str]]:
        """Deployments for the MLModel"""
        return self._inner_dict.get('deployments')  # type: ignore
    
    @deployments.setter
    def deployments(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['deployments'] = value
    
    
    @property
    def groups(self) -> Union[None, List[str]]:
        """Groups the model belongs to"""
        return self._inner_dict.get('groups')  # type: ignore
    
    @groups.setter
    def groups(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['groups'] = value
    
    
class MLPrimaryKeyPropertiesClass(_Aspect):
    """Properties associated with a MLPrimaryKey"""


    ASPECT_NAME = 'mlPrimaryKeyProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLPrimaryKeyProperties")

    def __init__(self,
        sources: List[str],
        customProperties: Optional[Dict[str, str]]=None,
        description: Union[None, str]=None,
        dataType: Union[None, Union[str, "MLFeatureDataTypeClass"]]=None,
        version: Union[None, "VersionTagClass"]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.description = description
        self.dataType = dataType
        self.version = version
        self.sources = sources
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.dataType = self.RECORD_SCHEMA.fields_dict["dataType"].default
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
        self.sources = list()
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the MLPrimaryKey"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def dataType(self) -> Union[None, Union[str, "MLFeatureDataTypeClass"]]:
        """Data Type of the MLPrimaryKey"""
        return self._inner_dict.get('dataType')  # type: ignore
    
    @dataType.setter
    def dataType(self, value: Union[None, Union[str, "MLFeatureDataTypeClass"]]) -> None:
        self._inner_dict['dataType'] = value
    
    
    @property
    def version(self) -> Union[None, "VersionTagClass"]:
        """Version of the MLPrimaryKey"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, "VersionTagClass"]) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def sources(self) -> List[str]:
        """Source of the MLPrimaryKey"""
        return self._inner_dict.get('sources')  # type: ignore
    
    @sources.setter
    def sources(self, value: List[str]) -> None:
        self._inner_dict['sources'] = value
    
    
class MLTrainingRunPropertiesClass(_Aspect):
    """The inputs and outputs of this training run"""


    ASPECT_NAME = 'mlTrainingRunProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.MLTrainingRunProperties")

    def __init__(self,
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        id: Union[None, str]=None,
        outputUrls: Union[None, List[str]]=None,
        hyperParams: Union[None, List["MLHyperParamClass"]]=None,
        trainingMetrics: Union[None, List["MLMetricClass"]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.id = id
        self.outputUrls = outputUrls
        self.hyperParams = hyperParams
        self.trainingMetrics = trainingMetrics
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.id = self.RECORD_SCHEMA.fields_dict["id"].default
        self.outputUrls = self.RECORD_SCHEMA.fields_dict["outputUrls"].default
        self.hyperParams = self.RECORD_SCHEMA.fields_dict["hyperParams"].default
        self.trainingMetrics = self.RECORD_SCHEMA.fields_dict["trainingMetrics"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def id(self) -> Union[None, str]:
        """Run Id of the ML Training Run"""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: Union[None, str]) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def outputUrls(self) -> Union[None, List[str]]:
        """List of URLs for the Outputs of the ML Training Run"""
        return self._inner_dict.get('outputUrls')  # type: ignore
    
    @outputUrls.setter
    def outputUrls(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['outputUrls'] = value
    
    
    @property
    def hyperParams(self) -> Union[None, List["MLHyperParamClass"]]:
        """Hyperparameters of the ML Training Run"""
        return self._inner_dict.get('hyperParams')  # type: ignore
    
    @hyperParams.setter
    def hyperParams(self, value: Union[None, List["MLHyperParamClass"]]) -> None:
        self._inner_dict['hyperParams'] = value
    
    
    @property
    def trainingMetrics(self) -> Union[None, List["MLMetricClass"]]:
        """Metrics of the ML Training Run"""
        return self._inner_dict.get('trainingMetrics')  # type: ignore
    
    @trainingMetrics.setter
    def trainingMetrics(self, value: Union[None, List["MLMetricClass"]]) -> None:
        self._inner_dict['trainingMetrics'] = value
    
    
class MetricsClass(_Aspect):
    """Metrics to be featured for the MLModel."""


    ASPECT_NAME = 'mlModelMetrics'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.Metrics")

    def __init__(self,
        performanceMeasures: Union[None, List[str]]=None,
        decisionThreshold: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.performanceMeasures = performanceMeasures
        self.decisionThreshold = decisionThreshold
    
    def _restore_defaults(self) -> None:
        self.performanceMeasures = self.RECORD_SCHEMA.fields_dict["performanceMeasures"].default
        self.decisionThreshold = self.RECORD_SCHEMA.fields_dict["decisionThreshold"].default
    
    
    @property
    def performanceMeasures(self) -> Union[None, List[str]]:
        """Measures of MLModel performance"""
        return self._inner_dict.get('performanceMeasures')  # type: ignore
    
    @performanceMeasures.setter
    def performanceMeasures(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['performanceMeasures'] = value
    
    
    @property
    def decisionThreshold(self) -> Union[None, List[str]]:
        """Decision Thresholds used (if any)?"""
        return self._inner_dict.get('decisionThreshold')  # type: ignore
    
    @decisionThreshold.setter
    def decisionThreshold(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['decisionThreshold'] = value
    
    
class QuantitativeAnalysesClass(_Aspect):
    """Quantitative analyses should be disaggregated, that is, broken down by the chosen factors. Quantitative analyses should provide the results of evaluating the MLModel according to the chosen metrics, providing confidence interval values when possible."""


    ASPECT_NAME = 'mlModelQuantitativeAnalyses'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.QuantitativeAnalyses")

    def __init__(self,
        unitaryResults: Union[None, str]=None,
        intersectionalResults: Union[None, str]=None,
    ):
        super().__init__()
        
        self.unitaryResults = unitaryResults
        self.intersectionalResults = intersectionalResults
    
    def _restore_defaults(self) -> None:
        self.unitaryResults = self.RECORD_SCHEMA.fields_dict["unitaryResults"].default
        self.intersectionalResults = self.RECORD_SCHEMA.fields_dict["intersectionalResults"].default
    
    
    @property
    def unitaryResults(self) -> Union[None, str]:
        """Link to a dashboard with results showing how the MLModel performed with respect to each factor"""
        return self._inner_dict.get('unitaryResults')  # type: ignore
    
    @unitaryResults.setter
    def unitaryResults(self, value: Union[None, str]) -> None:
        self._inner_dict['unitaryResults'] = value
    
    
    @property
    def intersectionalResults(self) -> Union[None, str]:
        """Link to a dashboard with results showing how the MLModel performed with respect to the intersection of evaluated factors?"""
        return self._inner_dict.get('intersectionalResults')  # type: ignore
    
    @intersectionalResults.setter
    def intersectionalResults(self, value: Union[None, str]) -> None:
        self._inner_dict['intersectionalResults'] = value
    
    
class SourceCodeClass(_Aspect):
    """Source Code"""


    ASPECT_NAME = 'sourceCode'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.SourceCode")

    def __init__(self,
        sourceCode: List["SourceCodeUrlClass"],
    ):
        super().__init__()
        
        self.sourceCode = sourceCode
    
    def _restore_defaults(self) -> None:
        self.sourceCode = list()
    
    
    @property
    def sourceCode(self) -> List["SourceCodeUrlClass"]:
        """Source Code along with types"""
        return self._inner_dict.get('sourceCode')  # type: ignore
    
    @sourceCode.setter
    def sourceCode(self, value: List["SourceCodeUrlClass"]) -> None:
        self._inner_dict['sourceCode'] = value
    
    
class SourceCodeUrlClass(DictWrapper):
    """Source Code Url Entity"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.SourceCodeUrl")
    def __init__(self,
        type: Union[str, "SourceCodeUrlTypeClass"],
        sourceCodeUrl: str,
    ):
        super().__init__()
        
        self.type = type
        self.sourceCodeUrl = sourceCodeUrl
    
    def _restore_defaults(self) -> None:
        self.type = SourceCodeUrlTypeClass.ML_MODEL_SOURCE_CODE
        self.sourceCodeUrl = str()
    
    
    @property
    def type(self) -> Union[str, "SourceCodeUrlTypeClass"]:
        """Source Code Url Types"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "SourceCodeUrlTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def sourceCodeUrl(self) -> str:
        """Source Code Url"""
        return self._inner_dict.get('sourceCodeUrl')  # type: ignore
    
    @sourceCodeUrl.setter
    def sourceCodeUrl(self, value: str) -> None:
        self._inner_dict['sourceCodeUrl'] = value
    
    
class SourceCodeUrlTypeClass(object):
    # No docs available.
    
    ML_MODEL_SOURCE_CODE = "ML_MODEL_SOURCE_CODE"
    TRAINING_PIPELINE_SOURCE_CODE = "TRAINING_PIPELINE_SOURCE_CODE"
    EVALUATION_PIPELINE_SOURCE_CODE = "EVALUATION_PIPELINE_SOURCE_CODE"
    
    
class TrainingDataClass(_Aspect):
    """Ideally, the MLModel card would contain as much information about the training data as the evaluation data. However, there might be cases where it is not feasible to provide this level of detailed information about the training data. For example, the data may be proprietary, or require a non-disclosure agreement. In these cases, we advocate for basic details about the distributions over groups in the data, as well as any other details that could inform stakeholders on the kinds of biases the model may have encoded."""


    ASPECT_NAME = 'mlModelTrainingData'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ml.metadata.TrainingData")

    def __init__(self,
        trainingData: List["BaseDataClass"],
    ):
        super().__init__()
        
        self.trainingData = trainingData
    
    def _restore_defaults(self) -> None:
        self.trainingData = list()
    
    
    @property
    def trainingData(self) -> List["BaseDataClass"]:
        """Details on the dataset(s) used for training the MLModel"""
        return self._inner_dict.get('trainingData')  # type: ignore
    
    @trainingData.setter
    def trainingData(self, value: List["BaseDataClass"]) -> None:
        self._inner_dict['trainingData'] = value
    
    
class AssetCollectionModuleParamsClass(DictWrapper):
    """The params required if the module is type ASSET_COLLECTION"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.module.AssetCollectionModuleParams")
    def __init__(self,
        assetUrns: List[str],
        dynamicFilterJson: Union[None, str]=None,
    ):
        super().__init__()
        
        self.assetUrns = assetUrns
        self.dynamicFilterJson = dynamicFilterJson
    
    def _restore_defaults(self) -> None:
        self.assetUrns = list()
        self.dynamicFilterJson = self.RECORD_SCHEMA.fields_dict["dynamicFilterJson"].default
    
    
    @property
    def assetUrns(self) -> List[str]:
        # No docs available.
        return self._inner_dict.get('assetUrns')  # type: ignore
    
    @assetUrns.setter
    def assetUrns(self, value: List[str]) -> None:
        self._inner_dict['assetUrns'] = value
    
    
    @property
    def dynamicFilterJson(self) -> Union[None, str]:
        """Optional dynamic filters
    
    The stringified json representing the logical predicate built in the UI to select assets.
    This predicate is turned into orFilters to send through graphql since graphql doesn't support
    arbitrary nesting. This string is used to restore the UI for this logical predicate."""
        return self._inner_dict.get('dynamicFilterJson')  # type: ignore
    
    @dynamicFilterJson.setter
    def dynamicFilterJson(self, value: Union[None, str]) -> None:
        self._inner_dict['dynamicFilterJson'] = value
    
    
class DataHubPageModuleParamsClass(DictWrapper):
    """The specific parameters stored for a module"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.module.DataHubPageModuleParams")
    def __init__(self,
        linkParams: Union[None, "LinkModuleParamsClass"]=None,
        richTextParams: Union[None, "RichTextModuleParamsClass"]=None,
        assetCollectionParams: Union[None, "AssetCollectionModuleParamsClass"]=None,
        hierarchyViewParams: Union[None, "HierarchyModuleParamsClass"]=None,
    ):
        super().__init__()
        
        self.linkParams = linkParams
        self.richTextParams = richTextParams
        self.assetCollectionParams = assetCollectionParams
        self.hierarchyViewParams = hierarchyViewParams
    
    def _restore_defaults(self) -> None:
        self.linkParams = self.RECORD_SCHEMA.fields_dict["linkParams"].default
        self.richTextParams = self.RECORD_SCHEMA.fields_dict["richTextParams"].default
        self.assetCollectionParams = self.RECORD_SCHEMA.fields_dict["assetCollectionParams"].default
        self.hierarchyViewParams = self.RECORD_SCHEMA.fields_dict["hierarchyViewParams"].default
    
    
    @property
    def linkParams(self) -> Union[None, "LinkModuleParamsClass"]:
        """The params required if the module is type LINK"""
        return self._inner_dict.get('linkParams')  # type: ignore
    
    @linkParams.setter
    def linkParams(self, value: Union[None, "LinkModuleParamsClass"]) -> None:
        self._inner_dict['linkParams'] = value
    
    
    @property
    def richTextParams(self) -> Union[None, "RichTextModuleParamsClass"]:
        """The params required if the module is type RICH_TEXT"""
        return self._inner_dict.get('richTextParams')  # type: ignore
    
    @richTextParams.setter
    def richTextParams(self, value: Union[None, "RichTextModuleParamsClass"]) -> None:
        self._inner_dict['richTextParams'] = value
    
    
    @property
    def assetCollectionParams(self) -> Union[None, "AssetCollectionModuleParamsClass"]:
        """The params required if the module is type ASSET_COLLECTION"""
        return self._inner_dict.get('assetCollectionParams')  # type: ignore
    
    @assetCollectionParams.setter
    def assetCollectionParams(self, value: Union[None, "AssetCollectionModuleParamsClass"]) -> None:
        self._inner_dict['assetCollectionParams'] = value
    
    
    @property
    def hierarchyViewParams(self) -> Union[None, "HierarchyModuleParamsClass"]:
        """The params required if the module is type HIERARCHY_VIEW"""
        return self._inner_dict.get('hierarchyViewParams')  # type: ignore
    
    @hierarchyViewParams.setter
    def hierarchyViewParams(self, value: Union[None, "HierarchyModuleParamsClass"]) -> None:
        self._inner_dict['hierarchyViewParams'] = value
    
    
class DataHubPageModulePropertiesClass(_Aspect):
    """The main properties of a DataHub page module"""


    ASPECT_NAME = 'dataHubPageModuleProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.module.DataHubPageModuleProperties")

    def __init__(self,
        name: str,
        type: Union[str, "DataHubPageModuleTypeClass"],
        visibility: "DataHubPageModuleVisibilityClass",
        params: "DataHubPageModuleParamsClass",
        created: "AuditStampClass",
        lastModified: "AuditStampClass",
    ):
        super().__init__()
        
        self.name = name
        self.type = type
        self.visibility = visibility
        self.params = params
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.type = DataHubPageModuleTypeClass.LINK
        self.visibility = DataHubPageModuleVisibilityClass._construct_with_defaults()
        self.params = DataHubPageModuleParamsClass._construct_with_defaults()
        self.created = AuditStampClass._construct_with_defaults()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def name(self) -> str:
        """The display name of this module"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def type(self) -> Union[str, "DataHubPageModuleTypeClass"]:
        """The type of this module - the purpose it serves"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DataHubPageModuleTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def visibility(self) -> "DataHubPageModuleVisibilityClass":
        """Info about the visibility of this module"""
        return self._inner_dict.get('visibility')  # type: ignore
    
    @visibility.setter
    def visibility(self, value: "DataHubPageModuleVisibilityClass") -> None:
        self._inner_dict['visibility'] = value
    
    
    @property
    def params(self) -> "DataHubPageModuleParamsClass":
        """The specific parameters stored for this module"""
        return self._inner_dict.get('params')  # type: ignore
    
    @params.setter
    def params(self, value: "DataHubPageModuleParamsClass") -> None:
        self._inner_dict['params'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp for when and by whom this template was created"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp for when and by whom this template was last updated"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class DataHubPageModuleTypeClass(object):
    """Enum containing the types of page modules that there are"""
    
    LINK = "LINK"
    """Link type module"""
    
    RICH_TEXT = "RICH_TEXT"
    """Module containing rich text to be rendered"""
    
    ASSET_COLLECTION = "ASSET_COLLECTION"
    """A module with a collection of assets"""
    
    HIERARCHY = "HIERARCHY"
    """A module displaying a hierarchy to navigate"""
    
    OWNED_ASSETS = "OWNED_ASSETS"
    """Module displaying assets owned by a user"""
    
    DOMAINS = "DOMAINS"
    """Module displaying the top domains"""
    
    ASSETS = "ASSETS"
    """Module displaying the assets of parent entity"""
    
    CHILD_HIERARCHY = "CHILD_HIERARCHY"
    """Module displaying the hierarchy of the children of a given entity. Glossary or Domains."""
    
    DATA_PRODUCTS = "DATA_PRODUCTS"
    """Module displaying child data products of a given domain"""
    
    RELATED_TERMS = "RELATED_TERMS"
    """Module displaying the related terms of a given glossary term"""
    
    SUBSCRIBED_ASSETS = "SUBSCRIBED_ASSETS"
    """Module displaying assets subscribed to by a given user"""
    
    WORKFLOWS = "WORKFLOWS"
    """Module displaying workflows that can be started"""
    
    PLATFORMS = "PLATFORMS"
    """Module displaying the platforms in an instance"""
    
    LINEAGE = "LINEAGE"
    """Module displaying the lineage of an asset"""
    
    COLUMNS = "COLUMNS"
    """Module displaying the columns of a dataset"""
    
    UNKNOWN = "UNKNOWN"
    """Unknown module type - this can occur with corrupted data or rolling back to versions without new modules"""
    
    
    
class DataHubPageModuleVisibilityClass(DictWrapper):
    """Info about the visibility of this module"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.module.DataHubPageModuleVisibility")
    def __init__(self,
        scope: Union[str, "PageModuleScopeClass"],
    ):
        super().__init__()
        
        self.scope = scope
    
    def _restore_defaults(self) -> None:
        self.scope = PageModuleScopeClass.PERSONAL
    
    
    @property
    def scope(self) -> Union[str, "PageModuleScopeClass"]:
        """Audit stamp for when and by whom this module was created"""
        return self._inner_dict.get('scope')  # type: ignore
    
    @scope.setter
    def scope(self, value: Union[str, "PageModuleScopeClass"]) -> None:
        self._inner_dict['scope'] = value
    
    
class HierarchyModuleParamsClass(DictWrapper):
    """The params required if the module is type HIERARCHY_VIEW"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.module.HierarchyModuleParams")
    def __init__(self,
        showRelatedEntities: bool,
        assetUrns: Union[None, List[str]]=None,
        relatedEntitiesFilterJson: Union[None, str]=None,
    ):
        super().__init__()
        
        self.assetUrns = assetUrns
        self.showRelatedEntities = showRelatedEntities
        self.relatedEntitiesFilterJson = relatedEntitiesFilterJson
    
    def _restore_defaults(self) -> None:
        self.assetUrns = self.RECORD_SCHEMA.fields_dict["assetUrns"].default
        self.showRelatedEntities = bool()
        self.relatedEntitiesFilterJson = self.RECORD_SCHEMA.fields_dict["relatedEntitiesFilterJson"].default
    
    
    @property
    def assetUrns(self) -> Union[None, List[str]]:
        # No docs available.
        return self._inner_dict.get('assetUrns')  # type: ignore
    
    @assetUrns.setter
    def assetUrns(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['assetUrns'] = value
    
    
    @property
    def showRelatedEntities(self) -> bool:
        # No docs available.
        return self._inner_dict.get('showRelatedEntities')  # type: ignore
    
    @showRelatedEntities.setter
    def showRelatedEntities(self, value: bool) -> None:
        self._inner_dict['showRelatedEntities'] = value
    
    
    @property
    def relatedEntitiesFilterJson(self) -> Union[None, str]:
        """Optional filters to filter relatedEntities (assetUrns) out
    
    The stringified json representing the logical predicate built in the UI to select assets.
    This predicate is turned into orFilters to send through graphql since graphql doesn't support
    arbitrary nesting. This string is used to restore the UI for this logical predicate."""
        return self._inner_dict.get('relatedEntitiesFilterJson')  # type: ignore
    
    @relatedEntitiesFilterJson.setter
    def relatedEntitiesFilterJson(self, value: Union[None, str]) -> None:
        self._inner_dict['relatedEntitiesFilterJson'] = value
    
    
class LinkModuleParamsClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.module.LinkModuleParams")
    def __init__(self,
        linkUrl: str,
        imageUrl: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.linkUrl = linkUrl
        self.imageUrl = imageUrl
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.linkUrl = str()
        self.imageUrl = self.RECORD_SCHEMA.fields_dict["imageUrl"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def linkUrl(self) -> str:
        # No docs available.
        return self._inner_dict.get('linkUrl')  # type: ignore
    
    @linkUrl.setter
    def linkUrl(self, value: str) -> None:
        self._inner_dict['linkUrl'] = value
    
    
    @property
    def imageUrl(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('imageUrl')  # type: ignore
    
    @imageUrl.setter
    def imageUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['imageUrl'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class PageModuleScopeClass(object):
    # No docs available.
    
    PERSONAL = "PERSONAL"
    """This module is used for individual use only"""
    
    GLOBAL = "GLOBAL"
    """This module is discoverable and can be used by any user on the platform"""
    
    
    
class RichTextModuleParamsClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.module.RichTextModuleParams")
    def __init__(self,
        content: str,
    ):
        super().__init__()
        
        self.content = content
    
    def _restore_defaults(self) -> None:
        self.content = str()
    
    
    @property
    def content(self) -> str:
        # No docs available.
        return self._inner_dict.get('content')  # type: ignore
    
    @content.setter
    def content(self, value: str) -> None:
        self._inner_dict['content'] = value
    
    
class AssertionEvaluationContextClass(DictWrapper):
    """Additional context about assertion being evaluated."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.AssertionEvaluationContext")
    def __init__(self,
        embeddedAssertions: Union[None, List["EmbeddedAssertionClass"]]=None,
        inferenceDetails: Union[None, "AssertionInferenceDetailsClass"]=None,
        stdDev: Union[None, float]=None,
    ):
        super().__init__()
        
        self.embeddedAssertions = embeddedAssertions
        self.inferenceDetails = inferenceDetails
        self.stdDev = stdDev
    
    def _restore_defaults(self) -> None:
        self.embeddedAssertions = self.RECORD_SCHEMA.fields_dict["embeddedAssertions"].default
        self.inferenceDetails = self.RECORD_SCHEMA.fields_dict["inferenceDetails"].default
        self.stdDev = self.RECORD_SCHEMA.fields_dict["stdDev"].default
    
    
    @property
    def embeddedAssertions(self) -> Union[None, List["EmbeddedAssertionClass"]]:
        """Currently used for Smart Assertions
    An embedded copy of the assertion used to evaluate which will overwrite the referenced assertion
    if present and if the EmbeddedAssertion's evaluationTimeWindow period is valid"""
        return self._inner_dict.get('embeddedAssertions')  # type: ignore
    
    @embeddedAssertions.setter
    def embeddedAssertions(self, value: Union[None, List["EmbeddedAssertionClass"]]) -> None:
        self._inner_dict['embeddedAssertions'] = value
    
    
    @property
    def inferenceDetails(self) -> Union[None, "AssertionInferenceDetailsClass"]:
        """Details about the assertion inference."""
        return self._inner_dict.get('inferenceDetails')  # type: ignore
    
    @inferenceDetails.setter
    def inferenceDetails(self, value: Union[None, "AssertionInferenceDetailsClass"]) -> None:
        self._inner_dict['inferenceDetails'] = value
    
    
    @property
    def stdDev(self) -> Union[None, float]:
        """The std deviation of the metric values used for training.
    This is used to determine the final adjusted threshold for the assertion."""
        return self._inner_dict.get('stdDev')  # type: ignore
    
    @stdDev.setter
    def stdDev(self, value: Union[None, float]) -> None:
        self._inner_dict['stdDev'] = value
    
    
class AssertionEvaluationParametersClass(DictWrapper):
    """Information about the parameters required to evaluate an assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.AssertionEvaluationParameters")
    def __init__(self,
        type: Union[str, "AssertionEvaluationParametersTypeClass"],
        datasetFreshnessParameters: Union[None, "DatasetFreshnessAssertionParametersClass"]=None,
        datasetVolumeParameters: Union[None, "DatasetVolumeAssertionParametersClass"]=None,
        datasetFieldParameters: Union[None, "DatasetFieldAssertionParametersClass"]=None,
        datasetSchemaParameters: Union[None, "DatasetSchemaAssertionParametersClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.datasetFreshnessParameters = datasetFreshnessParameters
        self.datasetVolumeParameters = datasetVolumeParameters
        self.datasetFieldParameters = datasetFieldParameters
        self.datasetSchemaParameters = datasetSchemaParameters
    
    def _restore_defaults(self) -> None:
        self.type = AssertionEvaluationParametersTypeClass.DATASET_FRESHNESS
        self.datasetFreshnessParameters = self.RECORD_SCHEMA.fields_dict["datasetFreshnessParameters"].default
        self.datasetVolumeParameters = self.RECORD_SCHEMA.fields_dict["datasetVolumeParameters"].default
        self.datasetFieldParameters = self.RECORD_SCHEMA.fields_dict["datasetFieldParameters"].default
        self.datasetSchemaParameters = self.RECORD_SCHEMA.fields_dict["datasetSchemaParameters"].default
    
    
    @property
    def type(self) -> Union[str, "AssertionEvaluationParametersTypeClass"]:
        """The type of parameters"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AssertionEvaluationParametersTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def datasetFreshnessParameters(self) -> Union[None, "DatasetFreshnessAssertionParametersClass"]:
        """Parameters required to evaluate a Dataset Freshness Assertion. Present if type is DATASET_FRESHNESS."""
        return self._inner_dict.get('datasetFreshnessParameters')  # type: ignore
    
    @datasetFreshnessParameters.setter
    def datasetFreshnessParameters(self, value: Union[None, "DatasetFreshnessAssertionParametersClass"]) -> None:
        self._inner_dict['datasetFreshnessParameters'] = value
    
    
    @property
    def datasetVolumeParameters(self) -> Union[None, "DatasetVolumeAssertionParametersClass"]:
        """Parameters required to evaluate a Dataset Volume Assertion. Present if type is DATASET_VOLUME."""
        return self._inner_dict.get('datasetVolumeParameters')  # type: ignore
    
    @datasetVolumeParameters.setter
    def datasetVolumeParameters(self, value: Union[None, "DatasetVolumeAssertionParametersClass"]) -> None:
        self._inner_dict['datasetVolumeParameters'] = value
    
    
    @property
    def datasetFieldParameters(self) -> Union[None, "DatasetFieldAssertionParametersClass"]:
        """Parameters required to evaluate a Dataset Field (Column) Assertion. Present if type is DATASET_FIELD."""
        return self._inner_dict.get('datasetFieldParameters')  # type: ignore
    
    @datasetFieldParameters.setter
    def datasetFieldParameters(self, value: Union[None, "DatasetFieldAssertionParametersClass"]) -> None:
        self._inner_dict['datasetFieldParameters'] = value
    
    
    @property
    def datasetSchemaParameters(self) -> Union[None, "DatasetSchemaAssertionParametersClass"]:
        """Parameters required to evaluate a Dataset Schema Assertion. Present if type is DATASET_SCHEMA."""
        return self._inner_dict.get('datasetSchemaParameters')  # type: ignore
    
    @datasetSchemaParameters.setter
    def datasetSchemaParameters(self, value: Union[None, "DatasetSchemaAssertionParametersClass"]) -> None:
        self._inner_dict['datasetSchemaParameters'] = value
    
    
class AssertionEvaluationParametersTypeClass(object):
    # No docs available.
    
    DATASET_FRESHNESS = "DATASET_FRESHNESS"
    """Parameters required to evaluate a Dataset Freshness Assertion"""
    
    DATASET_VOLUME = "DATASET_VOLUME"
    """Parameters required to evaluate a Dataset Volume Assertion"""
    
    DATASET_SQL = "DATASET_SQL"
    """Parameters required to evaluate a Dataset SQL Assertion"""
    
    DATASET_FIELD = "DATASET_FIELD"
    """Parameters required to evaluate a Dataset Field (Column) Assertion"""
    
    DATASET_SCHEMA = "DATASET_SCHEMA"
    """Parameters required to evaluate a Dataset Schema Assertion"""
    
    
    
class AssertionEvaluationSpecClass(DictWrapper):
    """Information required for a monitor to evaluate an assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.AssertionEvaluationSpec")
    def __init__(self,
        assertion: str,
        schedule: "CronScheduleClass",
        parameters: Union[None, "AssertionEvaluationParametersClass"]=None,
        context: Union[None, "AssertionEvaluationContextClass"]=None,
    ):
        super().__init__()
        
        self.assertion = assertion
        self.schedule = schedule
        self.parameters = parameters
        self.context = context
    
    def _restore_defaults(self) -> None:
        self.assertion = str()
        self.schedule = CronScheduleClass._construct_with_defaults()
        self.parameters = self.RECORD_SCHEMA.fields_dict["parameters"].default
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
    
    
    @property
    def assertion(self) -> str:
        """The urn of the assertion itself"""
        return self._inner_dict.get('assertion')  # type: ignore
    
    @assertion.setter
    def assertion(self, value: str) -> None:
        self._inner_dict['assertion'] = value
    
    
    @property
    def schedule(self) -> "CronScheduleClass":
        """The evaluation schedule for the assertion"""
        return self._inner_dict.get('schedule')  # type: ignore
    
    @schedule.setter
    def schedule(self, value: "CronScheduleClass") -> None:
        self._inner_dict['schedule'] = value
    
    
    @property
    def parameters(self) -> Union[None, "AssertionEvaluationParametersClass"]:
        """Parameters required to evaluate the assertion"""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: Union[None, "AssertionEvaluationParametersClass"]) -> None:
        self._inner_dict['parameters'] = value
    
    
    @property
    def context(self) -> Union[None, "AssertionEvaluationContextClass"]:
        """Additional context about assertion being evaluated."""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, "AssertionEvaluationContextClass"]) -> None:
        self._inner_dict['context'] = value
    
    
class AssertionMonitorClass(DictWrapper):
    """Information about an Assertion monitor."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.AssertionMonitor")
    def __init__(self,
        assertions: List["AssertionEvaluationSpecClass"],
        settings: Union[None, "AssertionMonitorSettingsClass"]=None,
        bootstrapStatus: Union[None, "AssertionMonitorBootstrapStatusClass"]=None,
    ):
        super().__init__()
        
        self.assertions = assertions
        self.settings = settings
        self.bootstrapStatus = bootstrapStatus
    
    def _restore_defaults(self) -> None:
        self.assertions = list()
        self.settings = self.RECORD_SCHEMA.fields_dict["settings"].default
        self.bootstrapStatus = self.RECORD_SCHEMA.fields_dict["bootstrapStatus"].default
    
    
    @property
    def assertions(self) -> List["AssertionEvaluationSpecClass"]:
        """Specs for each assertion to evaluate
    This will always have 1 reference. Modelling error caused it to be an array.
    If it is != 1 then we have data corruption."""
        return self._inner_dict.get('assertions')  # type: ignore
    
    @assertions.setter
    def assertions(self, value: List["AssertionEvaluationSpecClass"]) -> None:
        self._inner_dict['assertions'] = value
    
    
    @property
    def settings(self) -> Union[None, "AssertionMonitorSettingsClass"]:
        """Specific settings for an assertion monitor"""
        return self._inner_dict.get('settings')  # type: ignore
    
    @settings.setter
    def settings(self, value: Union[None, "AssertionMonitorSettingsClass"]) -> None:
        self._inner_dict['settings'] = value
    
    
    @property
    def bootstrapStatus(self) -> Union[None, "AssertionMonitorBootstrapStatusClass"]:
        """The status of the bootstrap actions performed on the assertion."""
        return self._inner_dict.get('bootstrapStatus')  # type: ignore
    
    @bootstrapStatus.setter
    def bootstrapStatus(self, value: Union[None, "AssertionMonitorBootstrapStatusClass"]) -> None:
        self._inner_dict['bootstrapStatus'] = value
    
    
class AssertionMonitorBootstrapStatusClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.AssertionMonitorBootstrapStatus")
    def __init__(self,
        metricsCubeBootstrapStatus: Union[None, "AssertionMonitorMetricsCubeBootstrapStatusClass"]=None,
    ):
        super().__init__()
        
        self.metricsCubeBootstrapStatus = metricsCubeBootstrapStatus
    
    def _restore_defaults(self) -> None:
        self.metricsCubeBootstrapStatus = self.RECORD_SCHEMA.fields_dict["metricsCubeBootstrapStatus"].default
    
    
    @property
    def metricsCubeBootstrapStatus(self) -> Union[None, "AssertionMonitorMetricsCubeBootstrapStatusClass"]:
        """Whether the metrics cube for this monitor has been bootstrapped."""
        return self._inner_dict.get('metricsCubeBootstrapStatus')  # type: ignore
    
    @metricsCubeBootstrapStatus.setter
    def metricsCubeBootstrapStatus(self, value: Union[None, "AssertionMonitorMetricsCubeBootstrapStatusClass"]) -> None:
        self._inner_dict['metricsCubeBootstrapStatus'] = value
    
    
class AssertionMonitorCapabilityClass(object):
    """Individual toggle-able capability for an assertion monitor."""
    
    ASSERTION_EVALUATION = "ASSERTION_EVALUATION"
    """Whether the metrics used for evaluating an assertion should be collected and saved. These metrics
    can be used for training, debugging, and even display in other contexts of the application.
    
    This is particularly useful for smart assertion evaluation, where the assertion is evaluated based on the metrics collected."""
    
    METRIC_COLLECTION = "METRIC_COLLECTION"
    """Whether the metrics used for evaluating an assertion should be collected and saved in a shared, globally accessible location (e.g. asset profiles).
    These metrics can be used for training, debugging, and even display in other contexts of the application.
    
    This is particularly useful for offline smart assertion training, where the smart assertion inference pipeline
    is de-coupled process that trains and updates the assertion itself based on historical metric values."""
    
    
    
class AssertionMonitorMetricsCubeBootstrapStateClass(object):
    # No docs available.
    
    PENDING = "PENDING"
    """The metrics cube for this monitor has not been bootstrapped."""
    
    FAILED = "FAILED"
    """The metrics cube for this monitor has failed to bootstrap."""
    
    COMPLETED = "COMPLETED"
    """The metrics cube for this monitor has been bootstrapped."""
    
    
    
class AssertionMonitorMetricsCubeBootstrapStatusClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.AssertionMonitorMetricsCubeBootstrapStatus")
    def __init__(self,
        state: Union[str, "AssertionMonitorMetricsCubeBootstrapStateClass"],
        message: Union[None, str]=None,
    ):
        super().__init__()
        
        self.state = state
        self.message = message
    
    def _restore_defaults(self) -> None:
        self.state = AssertionMonitorMetricsCubeBootstrapStateClass.PENDING
        self.message = self.RECORD_SCHEMA.fields_dict["message"].default
    
    
    @property
    def state(self) -> Union[str, "AssertionMonitorMetricsCubeBootstrapStateClass"]:
        """Whether the metrics cube for this monitor has been bootstrapped."""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[str, "AssertionMonitorMetricsCubeBootstrapStateClass"]) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def message(self) -> Union[None, str]:
        """The message associated with the bootstrap status.
    I.e., an error message if the bootstrap failed."""
        return self._inner_dict.get('message')  # type: ignore
    
    @message.setter
    def message(self, value: Union[None, str]) -> None:
        self._inner_dict['message'] = value
    
    
class AssertionMonitorSettingsClass(DictWrapper):
    """General purpose settings for the assertion monitor."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.AssertionMonitorSettings")
    def __init__(self,
        adjustmentSettings: Union[None, "AssertionAdjustmentSettingsClass"]=None,
        capabilities: Optional[List[Union[str, "AssertionMonitorCapabilityClass"]]]=None,
    ):
        super().__init__()
        
        self.adjustmentSettings = adjustmentSettings
        if capabilities is None:
            # default: ['ASSERTION_EVALUATION']
            self.capabilities = list()
        else:
            self.capabilities = capabilities
    
    def _restore_defaults(self) -> None:
        self.adjustmentSettings = self.RECORD_SCHEMA.fields_dict["adjustmentSettings"].default
        self.capabilities = list()
    
    
    @property
    def adjustmentSettings(self) -> Union[None, "AssertionAdjustmentSettingsClass"]:
        """In adjustment settings, the settings"""
        return self._inner_dict.get('adjustmentSettings')  # type: ignore
    
    @adjustmentSettings.setter
    def adjustmentSettings(self, value: Union[None, "AssertionAdjustmentSettingsClass"]) -> None:
        self._inner_dict['adjustmentSettings'] = value
    
    
    @property
    def capabilities(self) -> List[Union[str, "AssertionMonitorCapabilityClass"]]:
        """Capabilities that are currently enabled for the assertion monitor."""
        return self._inner_dict.get('capabilities')  # type: ignore
    
    @capabilities.setter
    def capabilities(self, value: List[Union[str, "AssertionMonitorCapabilityClass"]]) -> None:
        self._inner_dict['capabilities'] = value
    
    
class AuditLogSpecClass(DictWrapper):
    """Information about the Audit Log operation to use in evaluating an assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.AuditLogSpec")
    def __init__(self,
        operationTypes: Union[None, List[str]]=None,
        userName: Union[None, str]=None,
    ):
        super().__init__()
        
        self.operationTypes = operationTypes
        self.userName = userName
    
    def _restore_defaults(self) -> None:
        self.operationTypes = self.RECORD_SCHEMA.fields_dict["operationTypes"].default
        self.userName = self.RECORD_SCHEMA.fields_dict["userName"].default
    
    
    @property
    def operationTypes(self) -> Union[None, List[str]]:
        """The list of operation types that should be monitored. If not provided, a default set will be used."""
        return self._inner_dict.get('operationTypes')  # type: ignore
    
    @operationTypes.setter
    def operationTypes(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['operationTypes'] = value
    
    
    @property
    def userName(self) -> Union[None, str]:
        """Optional: The user name associated with the operation."""
        return self._inner_dict.get('userName')  # type: ignore
    
    @userName.setter
    def userName(self, value: Union[None, str]) -> None:
        self._inner_dict['userName'] = value
    
    
class DataHubOperationSpecClass(DictWrapper):
    """Information about the DataHub Operation aspect used to evaluate a freshness assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.DataHubOperationSpec")
    def __init__(self,
        operationTypes: Union[None, List[str]]=None,
        customOperationTypes: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.operationTypes = operationTypes
        self.customOperationTypes = customOperationTypes
    
    def _restore_defaults(self) -> None:
        self.operationTypes = self.RECORD_SCHEMA.fields_dict["operationTypes"].default
        self.customOperationTypes = self.RECORD_SCHEMA.fields_dict["customOperationTypes"].default
    
    
    @property
    def operationTypes(self) -> Union[None, List[str]]:
        """The list of operation types that should be monitored. If not provided, a default set will be used."""
        return self._inner_dict.get('operationTypes')  # type: ignore
    
    @operationTypes.setter
    def operationTypes(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['operationTypes'] = value
    
    
    @property
    def customOperationTypes(self) -> Union[None, List[str]]:
        """The list of custom operation types that should be monitored. If not provided, no custom operation types will be used."""
        return self._inner_dict.get('customOperationTypes')  # type: ignore
    
    @customOperationTypes.setter
    def customOperationTypes(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['customOperationTypes'] = value
    
    
class DatasetFieldAssertionParametersClass(DictWrapper):
    """Information about the parameters required to evaluate a field / column assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.DatasetFieldAssertionParameters")
    def __init__(self,
        sourceType: Union[str, "DatasetFieldAssertionSourceTypeClass"],
        changedRowsField: Union[None, "FreshnessFieldSpecClass"]=None,
    ):
        super().__init__()
        
        self.sourceType = sourceType
        self.changedRowsField = changedRowsField
    
    def _restore_defaults(self) -> None:
        self.sourceType = DatasetFieldAssertionSourceTypeClass.ALL_ROWS_QUERY
        self.changedRowsField = self.RECORD_SCHEMA.fields_dict["changedRowsField"].default
    
    
    @property
    def sourceType(self) -> Union[str, "DatasetFieldAssertionSourceTypeClass"]:
        """The source of the information used to evaluate
    a column values or metric assertion"""
        return self._inner_dict.get('sourceType')  # type: ignore
    
    @sourceType.setter
    def sourceType(self, value: Union[str, "DatasetFieldAssertionSourceTypeClass"]) -> None:
        self._inner_dict['sourceType'] = value
    
    
    @property
    def changedRowsField(self) -> Union[None, "FreshnessFieldSpecClass"]:
        """A field that can be used to filter for the fresh rows since the previous assertion
    evaluation. This should be present when sourceType = CHANGED_ROWS_QUERY.
    
    If not provided, or the metricSourceType is not QUERY, then the assertion will be evaluated against the
    entire dataset."""
        return self._inner_dict.get('changedRowsField')  # type: ignore
    
    @changedRowsField.setter
    def changedRowsField(self, value: Union[None, "FreshnessFieldSpecClass"]) -> None:
        self._inner_dict['changedRowsField'] = value
    
    
class DatasetFieldAssertionSourceTypeClass(object):
    # No docs available.
    
    ALL_ROWS_QUERY = "ALL_ROWS_QUERY"
    """Issue a query to the table to obtain the metric or values across
    all rows."""
    
    CHANGED_ROWS_QUERY = "CHANGED_ROWS_QUERY"
    """Issue a query to the table to obtain the metric values across
    only the rows which have changed since the previous evaluation."""
    
    DATAHUB_DATASET_PROFILE = "DATAHUB_DATASET_PROFILE"
    """Determine the metric value using the DataHub dataset profile. Only applicable
    for Column Metric assertions, not Column Value assertions."""
    
    
    
class DatasetFreshnessAssertionParametersClass(DictWrapper):
    """Information about the parameters required to evaluate an assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.DatasetFreshnessAssertionParameters")
    def __init__(self,
        sourceType: Union[str, "DatasetFreshnessSourceTypeClass"],
        field: Union[None, "FreshnessFieldSpecClass"]=None,
        auditLog: Union[None, "AuditLogSpecClass"]=None,
        dataHubOperation: Union[None, "DataHubOperationSpecClass"]=None,
    ):
        super().__init__()
        
        self.sourceType = sourceType
        self.field = field
        self.auditLog = auditLog
        self.dataHubOperation = dataHubOperation
    
    def _restore_defaults(self) -> None:
        self.sourceType = DatasetFreshnessSourceTypeClass.FIELD_VALUE
        self.field = self.RECORD_SCHEMA.fields_dict["field"].default
        self.auditLog = self.RECORD_SCHEMA.fields_dict["auditLog"].default
        self.dataHubOperation = self.RECORD_SCHEMA.fields_dict["dataHubOperation"].default
    
    
    @property
    def sourceType(self) -> Union[str, "DatasetFreshnessSourceTypeClass"]:
        """The source of the change operation."""
        return self._inner_dict.get('sourceType')  # type: ignore
    
    @sourceType.setter
    def sourceType(self, value: Union[str, "DatasetFreshnessSourceTypeClass"]) -> None:
        self._inner_dict['sourceType'] = value
    
    
    @property
    def field(self) -> Union[None, "FreshnessFieldSpecClass"]:
        """Information about the field to use. Present when sourceType is FIELD_VALUE"""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: Union[None, "FreshnessFieldSpecClass"]) -> None:
        self._inner_dict['field'] = value
    
    
    @property
    def auditLog(self) -> Union[None, "AuditLogSpecClass"]:
        """Information about the audit log operation to use. Present when sourceType is AUDIT_LOG"""
        return self._inner_dict.get('auditLog')  # type: ignore
    
    @auditLog.setter
    def auditLog(self, value: Union[None, "AuditLogSpecClass"]) -> None:
        self._inner_dict['auditLog'] = value
    
    
    @property
    def dataHubOperation(self) -> Union[None, "DataHubOperationSpecClass"]:
        """Information about the DataHub operation. Present when sourceType is DATAHUB_OPERATION"""
        return self._inner_dict.get('dataHubOperation')  # type: ignore
    
    @dataHubOperation.setter
    def dataHubOperation(self, value: Union[None, "DataHubOperationSpecClass"]) -> None:
        self._inner_dict['dataHubOperation'] = value
    
    
class DatasetFreshnessSourceTypeClass(object):
    # No docs available.
    
    FIELD_VALUE = "FIELD_VALUE"
    """Determine that a change has occurred by inspecting a particular field's value."""
    
    INFORMATION_SCHEMA = "INFORMATION_SCHEMA"
    """Determine that a change has occurred by inspecting an information schema table, or other system metadata table."""
    
    AUDIT_LOG = "AUDIT_LOG"
    """Determine that a change has occurred by inspecting an audit log API"""
    
    FILE_METADATA = "FILE_METADATA"
    """Determine that a change has occurred by inspecting underlying file system."""
    
    DATAHUB_OPERATION = "DATAHUB_OPERATION"
    """Determine whether the table has changed using an Operation aspect"""
    
    
    
class DatasetSchemaAssertionParametersClass(DictWrapper):
    """Information about the parameters required to evaluate a schema assertion."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.DatasetSchemaAssertionParameters")
    def __init__(self,
        sourceType: Union[str, "DatasetSchemaSourceTypeClass"],
    ):
        super().__init__()
        
        self.sourceType = sourceType
    
    def _restore_defaults(self) -> None:
        self.sourceType = DatasetSchemaSourceTypeClass.DATAHUB_SCHEMA
    
    
    @property
    def sourceType(self) -> Union[str, "DatasetSchemaSourceTypeClass"]:
        """The source of the actual schema."""
        return self._inner_dict.get('sourceType')  # type: ignore
    
    @sourceType.setter
    def sourceType(self, value: Union[str, "DatasetSchemaSourceTypeClass"]) -> None:
        self._inner_dict['sourceType'] = value
    
    
class DatasetSchemaSourceTypeClass(object):
    # No docs available.
    
    DATAHUB_SCHEMA = "DATAHUB_SCHEMA"
    """Validate the expected columns against the DataHub Schema Metadata aspect (the only option currently)"""
    
    
    
class DatasetVolumeAssertionParametersClass(DictWrapper):
    """Information about the parameters required to evaluate a volume assertion"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.DatasetVolumeAssertionParameters")
    def __init__(self,
        sourceType: Union[str, "DatasetVolumeSourceTypeClass"],
    ):
        super().__init__()
        
        self.sourceType = sourceType
    
    def _restore_defaults(self) -> None:
        self.sourceType = DatasetVolumeSourceTypeClass.INFORMATION_SCHEMA
    
    
    @property
    def sourceType(self) -> Union[str, "DatasetVolumeSourceTypeClass"]:
        """The source of the change operation."""
        return self._inner_dict.get('sourceType')  # type: ignore
    
    @sourceType.setter
    def sourceType(self, value: Union[str, "DatasetVolumeSourceTypeClass"]) -> None:
        self._inner_dict['sourceType'] = value
    
    
class DatasetVolumeSourceTypeClass(object):
    # No docs available.
    
    INFORMATION_SCHEMA = "INFORMATION_SCHEMA"
    """Determine the row count using an information schema query - not applicable to all platforms."""
    
    QUERY = "QUERY"
    """Determine the row count using a COUNT(*) query"""
    
    DATAHUB_DATASET_PROFILE = "DATAHUB_DATASET_PROFILE"
    """Determine the row count using the DataHub Dataset Profile aspect"""
    
    
    
class EmbeddedAssertionClass(DictWrapper):
    """Embedded assertion to be evaluated"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.EmbeddedAssertion")
    def __init__(self,
        assertion: Union[None, "AssertionInfoClass"]=None,
        evaluationTimeWindow: Union[None, "TimeWindowClass"]=None,
        context: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.assertion = assertion
        self.evaluationTimeWindow = evaluationTimeWindow
        self.context = context
    
    def _restore_defaults(self) -> None:
        self.assertion = self.RECORD_SCHEMA.fields_dict["assertion"].default
        self.evaluationTimeWindow = self.RECORD_SCHEMA.fields_dict["evaluationTimeWindow"].default
        self.context = self.RECORD_SCHEMA.fields_dict["context"].default
    
    
    @property
    def assertion(self) -> Union[None, "AssertionInfoClass"]:
        """Acryl Only! An assertion without any searchable or relationship annotations."""
        return self._inner_dict.get('assertion')  # type: ignore
    
    @assertion.setter
    def assertion(self, value: Union[None, "AssertionInfoClass"]) -> None:
        self._inner_dict['assertion'] = value
    
    
    @property
    def evaluationTimeWindow(self) -> Union[None, "TimeWindowClass"]:
        """Validity period of the assertion, ie the window of time where it should be used in evaluation"""
        return self._inner_dict.get('evaluationTimeWindow')  # type: ignore
    
    @evaluationTimeWindow.setter
    def evaluationTimeWindow(self, value: Union[None, "TimeWindowClass"]) -> None:
        self._inner_dict['evaluationTimeWindow'] = value
    
    
    @property
    def context(self) -> Union[None, Dict[str, str]]:
        """Context about the embedded assertion prediction"""
        return self._inner_dict.get('context')  # type: ignore
    
    @context.setter
    def context(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['context'] = value
    
    
class MonitorErrorClass(DictWrapper):
    """Error details for the monitor"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.MonitorError")
    def __init__(self,
        type: Union[str, "MonitorErrorTypeClass"],
        message: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.message = message
    
    def _restore_defaults(self) -> None:
        self.type = MonitorErrorTypeClass.UNKNOWN
        self.message = self.RECORD_SCHEMA.fields_dict["message"].default
    
    
    @property
    def type(self) -> Union[str, "MonitorErrorTypeClass"]:
        """The error for the monitor"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "MonitorErrorTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def message(self) -> Union[None, str]:
        """Optional custom message for the error"""
        return self._inner_dict.get('message')  # type: ignore
    
    @message.setter
    def message(self, value: Union[None, str]) -> None:
        self._inner_dict['message'] = value
    
    
class MonitorErrorTypeClass(object):
    # No docs available.
    
    UNKNOWN = "UNKNOWN"
    """An unknown error occurred"""
    
    
    
class MonitorInfoClass(_Aspect):
    """Information about an asset monitor."""


    ASPECT_NAME = 'monitorInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.MonitorInfo")

    def __init__(self,
        type: Union[str, "MonitorTypeClass"],
        status: "MonitorStatusClass",
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        assertionMonitor: Union[None, "AssertionMonitorClass"]=None,
        executorId: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.type = type
        self.status = status
        self.assertionMonitor = assertionMonitor
        self.executorId = executorId
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.type = MonitorTypeClass.ASSERTION
        self.status = MonitorStatusClass._construct_with_defaults()
        self.assertionMonitor = self.RECORD_SCHEMA.fields_dict["assertionMonitor"].default
        self.executorId = self.RECORD_SCHEMA.fields_dict["executorId"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def type(self) -> Union[str, "MonitorTypeClass"]:
        """Type of monitor."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "MonitorTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def status(self) -> "MonitorStatusClass":
        """Information about the status of a monitor."""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: "MonitorStatusClass") -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def assertionMonitor(self) -> Union[None, "AssertionMonitorClass"]:
        """Information about the assertions being monitored. Required if type is ASSERTION."""
        return self._inner_dict.get('assertionMonitor')  # type: ignore
    
    @assertionMonitor.setter
    def assertionMonitor(self, value: Union[None, "AssertionMonitorClass"]) -> None:
        self._inner_dict['assertionMonitor'] = value
    
    
    @property
    def executorId(self) -> Union[None, str]:
        """Advanced: The executor pool id of the remote monitor service, if any."""
        return self._inner_dict.get('executorId')  # type: ignore
    
    @executorId.setter
    def executorId(self, value: Union[None, str]) -> None:
        self._inner_dict['executorId'] = value
    
    
class MonitorModeClass(object):
    # No docs available.
    
    ACTIVE = "ACTIVE"
    """The monitor should be actively operating."""
    
    INACTIVE = "INACTIVE"
    """The monitor is not actively operating."""
    
    PASSIVE = "PASSIVE"
    """The monitor is running in passive mode.
    For assertion monitors, this means that assertions will be run in dry mode.
    This is for internal troubleshooting purposes."""
    
    
    
class MonitorStateClass(object):
    # No docs available.
    
    TRAINING = "TRAINING"
    """The monitor is in the training stage."""
    
    EVALUATION = "EVALUATION"
    """The monitor is in the evaluation stage."""
    
    ERROR = "ERROR"
    """The monitor is in the evaluation stage."""
    
    
    
class MonitorStatusClass(DictWrapper):
    """The status of an asset monitor"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.MonitorStatus")
    def __init__(self,
        mode: Union[str, "MonitorModeClass"],
        state: Union[None, Union[str, "MonitorStateClass"]]=None,
        error: Union[None, "MonitorErrorClass"]=None,
        reviewedAt: Union[None, int]=None,
    ):
        super().__init__()
        
        self.mode = mode
        self.state = state
        self.error = error
        self.reviewedAt = reviewedAt
    
    def _restore_defaults(self) -> None:
        self.mode = MonitorModeClass.ACTIVE
        self.state = self.RECORD_SCHEMA.fields_dict["state"].default
        self.error = self.RECORD_SCHEMA.fields_dict["error"].default
        self.reviewedAt = self.RECORD_SCHEMA.fields_dict["reviewedAt"].default
    
    
    @property
    def mode(self) -> Union[str, "MonitorModeClass"]:
        """The current operation mode of the monitor"""
        return self._inner_dict.get('mode')  # type: ignore
    
    @mode.setter
    def mode(self, value: Union[str, "MonitorModeClass"]) -> None:
        self._inner_dict['mode'] = value
    
    
    @property
    def state(self) -> Union[None, Union[str, "MonitorStateClass"]]:
        """The start time of the monitor"""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[None, Union[str, "MonitorStateClass"]]) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def error(self) -> Union[None, "MonitorErrorClass"]:
        """The last time the monitor was started"""
        return self._inner_dict.get('error')  # type: ignore
    
    @error.setter
    def error(self, value: Union[None, "MonitorErrorClass"]) -> None:
        self._inner_dict['error'] = value
    
    
    @property
    def reviewedAt(self) -> Union[None, int]:
        """The last time the monitor was started"""
        return self._inner_dict.get('reviewedAt')  # type: ignore
    
    @reviewedAt.setter
    def reviewedAt(self, value: Union[None, int]) -> None:
        self._inner_dict['reviewedAt'] = value
    
    
class MonitorSuiteAssertionSettingsClass(DictWrapper):
    """Settings for assertion monitors within a monitor suite."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.MonitorSuiteAssertionSettings")
    def __init__(self,
        schedule: Union[None, "FixedIntervalScheduleClass"]=None,
        trainingDataLookbackWindowDays: Optional[int]=None,
        action: Union[None, "AssertionActionClass"]=None,
        exclusionWindows: Union[None, List["AssertionExclusionWindowClass"]]=None,
    ):
        super().__init__()
        
        self.schedule = schedule
        if trainingDataLookbackWindowDays is None:
            # default: 60
            self.trainingDataLookbackWindowDays = self.RECORD_SCHEMA.fields_dict["trainingDataLookbackWindowDays"].default
        else:
            self.trainingDataLookbackWindowDays = trainingDataLookbackWindowDays
        self.action = action
        self.exclusionWindows = exclusionWindows
    
    def _restore_defaults(self) -> None:
        self.schedule = self.RECORD_SCHEMA.fields_dict["schedule"].default
        self.trainingDataLookbackWindowDays = self.RECORD_SCHEMA.fields_dict["trainingDataLookbackWindowDays"].default
        self.action = self.RECORD_SCHEMA.fields_dict["action"].default
        self.exclusionWindows = self.RECORD_SCHEMA.fields_dict["exclusionWindows"].default
    
    
    @property
    def schedule(self) -> Union[None, "FixedIntervalScheduleClass"]:
        """The schedule for the assertion monitors within this group.
    Not applicable for freshness anomaly monitors."""
        return self._inner_dict.get('schedule')  # type: ignore
    
    @schedule.setter
    def schedule(self, value: Union[None, "FixedIntervalScheduleClass"]) -> None:
        self._inner_dict['schedule'] = value
    
    
    @property
    def trainingDataLookbackWindowDays(self) -> int:
        """The lookback window configuration for retrieving training data points.
    Defines how far back in time to look when gathering data for training.
    Defaults to 60 days if not specified."""
        return self._inner_dict.get('trainingDataLookbackWindowDays')  # type: ignore
    
    @trainingDataLookbackWindowDays.setter
    def trainingDataLookbackWindowDays(self, value: int) -> None:
        self._inner_dict['trainingDataLookbackWindowDays'] = value
    
    
    @property
    def action(self) -> Union[None, "AssertionActionClass"]:
        """The action to take when an assertion evaluates.
    I.e., raise an incident if the assertion fails."""
        return self._inner_dict.get('action')  # type: ignore
    
    @action.setter
    def action(self, value: Union[None, "AssertionActionClass"]) -> None:
        self._inner_dict['action'] = value
    
    
    @property
    def exclusionWindows(self) -> Union[None, List["AssertionExclusionWindowClass"]]:
        """The exclusion windows for the assertion monitors within this group."""
        return self._inner_dict.get('exclusionWindows')  # type: ignore
    
    @exclusionWindows.setter
    def exclusionWindows(self, value: Union[None, List["AssertionExclusionWindowClass"]]) -> None:
        self._inner_dict['exclusionWindows'] = value
    
    
class MonitorSuiteAssignmentSpecClass(DictWrapper):
    """Information about entities that should be monitored by a monitor suite."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.MonitorSuiteAssignmentSpec")
    def __init__(self,
        filter: "FilterClass",
        json: Union[None, str]=None,
    ):
        super().__init__()
        
        self.filter = filter
        self.json = json
    
    def _restore_defaults(self) -> None:
        self.filter = FilterClass._construct_with_defaults()
        self.json = self.RECORD_SCHEMA.fields_dict["json"].default
    
    
    @property
    def filter(self) -> "FilterClass":
        """The filter applied when assigning this form to entities. Entities that match this filter
    will have this form applied to them. Right now this filter only supports filtering by
    platform, entity type, container, term, tag, domain, and urns through the UI."""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: "FilterClass") -> None:
        self._inner_dict['filter'] = value
    
    
    @property
    def json(self) -> Union[None, str]:
        """The stringified json representing the logical predicate built in the UI to select assets.
    This predicate is turned into orFilters to send through graphql since graphql doesn't support
    arbitrary nesting. This string is used to restore the UI for this logical predicate."""
        return self._inner_dict.get('json')  # type: ignore
    
    @json.setter
    def json(self, value: Union[None, str]) -> None:
        self._inner_dict['json'] = value
    
    
class MonitorSuiteInfoClass(_Aspect):
    """Information about an asset monitor."""


    ASPECT_NAME = 'monitorSuiteInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.MonitorSuiteInfo")

    def __init__(self,
        type: Union[str, "MonitorSuiteTypeClass"],
        assignment: "MonitorSuiteAssignmentSpecClass",
        assertionSettings: Union[None, "MonitorSuiteAssertionSettingsClass"]=None,
        notificationSettings: Union[None, "MonitorSuiteNotificationSettingsClass"]=None,
        created: Union[None, "AuditStampClass"]=None,
        updated: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.assignment = assignment
        self.assertionSettings = assertionSettings
        self.notificationSettings = notificationSettings
        self.created = created
        self.updated = updated
    
    def _restore_defaults(self) -> None:
        self.type = MonitorSuiteTypeClass.FRESHNESS
        self.assignment = MonitorSuiteAssignmentSpecClass._construct_with_defaults()
        self.assertionSettings = self.RECORD_SCHEMA.fields_dict["assertionSettings"].default
        self.notificationSettings = self.RECORD_SCHEMA.fields_dict["notificationSettings"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.updated = self.RECORD_SCHEMA.fields_dict["updated"].default
    
    
    @property
    def type(self) -> Union[str, "MonitorSuiteTypeClass"]:
        """Type of monitor suite."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "MonitorSuiteTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def assignment(self) -> "MonitorSuiteAssignmentSpecClass":
        """The assignment rule to define the entities that are monitored by this group."""
        return self._inner_dict.get('assignment')  # type: ignore
    
    @assignment.setter
    def assignment(self, value: "MonitorSuiteAssignmentSpecClass") -> None:
        self._inner_dict['assignment'] = value
    
    
    @property
    def assertionSettings(self) -> Union[None, "MonitorSuiteAssertionSettingsClass"]:
        """Settings for assertion monitors within this group."""
        return self._inner_dict.get('assertionSettings')  # type: ignore
    
    @assertionSettings.setter
    def assertionSettings(self, value: Union[None, "MonitorSuiteAssertionSettingsClass"]) -> None:
        self._inner_dict['assertionSettings'] = value
    
    
    @property
    def notificationSettings(self) -> Union[None, "MonitorSuiteNotificationSettingsClass"]:
        """Settings for notifications from monitors within this group."""
        return self._inner_dict.get('notificationSettings')  # type: ignore
    
    @notificationSettings.setter
    def notificationSettings(self, value: Union[None, "MonitorSuiteNotificationSettingsClass"]) -> None:
        self._inner_dict['notificationSettings'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def updated(self) -> Union[None, "AuditStampClass"]:
        """Updated Audit stamp"""
        return self._inner_dict.get('updated')  # type: ignore
    
    @updated.setter
    def updated(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['updated'] = value
    
    
class MonitorSuiteNotificationSettingsClass(DictWrapper):
    """Settings for notifications from monitors within a monitor suite."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.MonitorSuiteNotificationSettings")
    def __init__(self,
        entityChangeTypes: List["EntityChangeDetailsClass"],
        notificationConfig: "SubscriptionNotificationConfigClass",
    ):
        super().__init__()
        
        self.entityChangeTypes = entityChangeTypes
        self.notificationConfig = notificationConfig
    
    def _restore_defaults(self) -> None:
        self.entityChangeTypes = list()
        self.notificationConfig = SubscriptionNotificationConfigClass._construct_with_defaults()
    
    
    @property
    def entityChangeTypes(self) -> List["EntityChangeDetailsClass"]:
        """The change types that trigger a notification for the monitor suite.
    NOTE: only use Assertion and Incident change types for monitor suites."""
        return self._inner_dict.get('entityChangeTypes')  # type: ignore
    
    @entityChangeTypes.setter
    def entityChangeTypes(self, value: List["EntityChangeDetailsClass"]) -> None:
        self._inner_dict['entityChangeTypes'] = value
    
    
    @property
    def notificationConfig(self) -> "SubscriptionNotificationConfigClass":
        """The notification config for the monitor suite."""
        return self._inner_dict.get('notificationConfig')  # type: ignore
    
    @notificationConfig.setter
    def notificationConfig(self, value: "SubscriptionNotificationConfigClass") -> None:
        self._inner_dict['notificationConfig'] = value
    
    
class MonitorSuiteTypeClass(object):
    # No docs available.
    
    FRESHNESS = "FRESHNESS"
    """A monitor responsible for evaluating freshness anomalies."""
    
    VOLUME = "VOLUME"
    """A monitor responsible for evaluating volume anomalies."""
    
    DATA_SCHEMA = "DATA_SCHEMA"
    """A monitor responsible for evaluating schema changes."""
    
    
    
class MonitorTimeseriesStateClass(_Aspect):
    """Stats required to evaluate continuous monitors."""


    ASPECT_NAME = 'monitorTimeseriesState'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.monitor.MonitorTimeseriesState")

    def __init__(self,
        timestampMillis: int,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        customProperties: Optional[Dict[str, str]]=None,
        id: Union[None, str]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.customProperties = dict()
        self.id = self.RECORD_SCHEMA.fields_dict["id"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def id(self) -> Union[None, str]:
        """An optional identifier for the state. Useful for partitioning + filtering state."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: Union[None, str]) -> None:
        self._inner_dict['id'] = value
    
    
class MonitorTypeClass(object):
    # No docs available.
    
    ASSERTION = "ASSERTION"
    """A monitor responsible for evaluating Assertions."""
    
    FRESHNESS = "FRESHNESS"
    """A monitor responsible for evaluating system freshness monitors - This is not used"""
    
    
    
class GenericAspectClass(DictWrapper):
    """Generic record structure for serializing an Aspect"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.mxe.GenericAspect")
    def __init__(self,
        value: bytes,
        contentType: str,
    ):
        super().__init__()
        
        self.value = value
        self.contentType = contentType
    
    def _restore_defaults(self) -> None:
        self.value = bytes()
        self.contentType = str()
    
    
    @property
    def value(self) -> bytes:
        """The value of the aspect, serialized as bytes."""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: bytes) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def contentType(self) -> str:
        """The content type, which represents the fashion in which the aspect was serialized.
    The only type currently supported is application/json."""
        return self._inner_dict.get('contentType')  # type: ignore
    
    @contentType.setter
    def contentType(self, value: str) -> None:
        self._inner_dict['contentType'] = value
    
    
class GenericPayloadClass(DictWrapper):
    """Generic payload record structure for serializing a Platform Event."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.mxe.GenericPayload")
    def __init__(self,
        value: bytes,
        contentType: str,
    ):
        super().__init__()
        
        self.value = value
        self.contentType = contentType
    
    def _restore_defaults(self) -> None:
        self.value = bytes()
        self.contentType = str()
    
    
    @property
    def value(self) -> bytes:
        """The value of the event, serialized as bytes."""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: bytes) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def contentType(self) -> str:
        """The content type, which represents the fashion in which the event was serialized.
    The only type currently supported is application/json."""
        return self._inner_dict.get('contentType')  # type: ignore
    
    @contentType.setter
    def contentType(self, value: str) -> None:
        self._inner_dict['contentType'] = value
    
    
class MetadataChangeEventClass(DictWrapper):
    """Kafka event for proposing a metadata change for an entity. A corresponding MetadataAuditEvent is emitted when the change is accepted and committed, otherwise a FailedMetadataChangeEvent will be emitted instead."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.mxe.MetadataChangeEvent")
    def __init__(self,
        proposedSnapshot: Union["ActionRequestSnapshotClass", "ChartSnapshotClass", "CorpGroupSnapshotClass", "CorpUserSnapshotClass", "DashboardSnapshotClass", "DataFlowSnapshotClass", "DataJobSnapshotClass", "DatasetSnapshotClass", "DataProcessSnapshotClass", "DataPlatformSnapshotClass", "MLModelSnapshotClass", "MLPrimaryKeySnapshotClass", "MLFeatureSnapshotClass", "MLFeatureTableSnapshotClass", "MLModelDeploymentSnapshotClass", "MLModelGroupSnapshotClass", "TagSnapshotClass", "GlossaryTermSnapshotClass", "GlossaryNodeSnapshotClass", "DataHubPolicySnapshotClass", "SchemaFieldSnapshotClass", "DataHubRetentionSnapshotClass"],
        auditHeader: Union[None, "KafkaAuditHeaderClass"]=None,
        proposedDelta: None=None,
        systemMetadata: Union[None, "SystemMetadataClass"]=None,
    ):
        super().__init__()
        
        self.auditHeader = auditHeader
        self.proposedSnapshot = proposedSnapshot
        self.proposedDelta = proposedDelta
        self.systemMetadata = systemMetadata
    
    def _restore_defaults(self) -> None:
        self.auditHeader = self.RECORD_SCHEMA.fields_dict["auditHeader"].default
        self.proposedSnapshot = ActionRequestSnapshotClass._construct_with_defaults()
        self.proposedDelta = self.RECORD_SCHEMA.fields_dict["proposedDelta"].default
        self.systemMetadata = self.RECORD_SCHEMA.fields_dict["systemMetadata"].default
    
    
    @property
    def auditHeader(self) -> Union[None, "KafkaAuditHeaderClass"]:
        """Kafka audit header. See go/kafkaauditheader for more info."""
        return self._inner_dict.get('auditHeader')  # type: ignore
    
    @auditHeader.setter
    def auditHeader(self, value: Union[None, "KafkaAuditHeaderClass"]) -> None:
        self._inner_dict['auditHeader'] = value
    
    
    @property
    def proposedSnapshot(self) -> Union["ActionRequestSnapshotClass", "ChartSnapshotClass", "CorpGroupSnapshotClass", "CorpUserSnapshotClass", "DashboardSnapshotClass", "DataFlowSnapshotClass", "DataJobSnapshotClass", "DatasetSnapshotClass", "DataProcessSnapshotClass", "DataPlatformSnapshotClass", "MLModelSnapshotClass", "MLPrimaryKeySnapshotClass", "MLFeatureSnapshotClass", "MLFeatureTableSnapshotClass", "MLModelDeploymentSnapshotClass", "MLModelGroupSnapshotClass", "TagSnapshotClass", "GlossaryTermSnapshotClass", "GlossaryNodeSnapshotClass", "DataHubPolicySnapshotClass", "SchemaFieldSnapshotClass", "DataHubRetentionSnapshotClass"]:
        """Snapshot of the proposed metadata change. Include only the aspects affected by the change in the snapshot."""
        return self._inner_dict.get('proposedSnapshot')  # type: ignore
    
    @proposedSnapshot.setter
    def proposedSnapshot(self, value: Union["ActionRequestSnapshotClass", "ChartSnapshotClass", "CorpGroupSnapshotClass", "CorpUserSnapshotClass", "DashboardSnapshotClass", "DataFlowSnapshotClass", "DataJobSnapshotClass", "DatasetSnapshotClass", "DataProcessSnapshotClass", "DataPlatformSnapshotClass", "MLModelSnapshotClass", "MLPrimaryKeySnapshotClass", "MLFeatureSnapshotClass", "MLFeatureTableSnapshotClass", "MLModelDeploymentSnapshotClass", "MLModelGroupSnapshotClass", "TagSnapshotClass", "GlossaryTermSnapshotClass", "GlossaryNodeSnapshotClass", "DataHubPolicySnapshotClass", "SchemaFieldSnapshotClass", "DataHubRetentionSnapshotClass"]) -> None:
        self._inner_dict['proposedSnapshot'] = value
    
    
    @property
    def proposedDelta(self) -> None:
        """Delta of the proposed metadata partial update."""
        return self._inner_dict.get('proposedDelta')  # type: ignore
    
    @proposedDelta.setter
    def proposedDelta(self, value: None) -> None:
        self._inner_dict['proposedDelta'] = value
    
    
    @property
    def systemMetadata(self) -> Union[None, "SystemMetadataClass"]:
        """Metadata around how the snapshot was ingested"""
        return self._inner_dict.get('systemMetadata')  # type: ignore
    
    @systemMetadata.setter
    def systemMetadata(self, value: Union[None, "SystemMetadataClass"]) -> None:
        self._inner_dict['systemMetadata'] = value
    
    
class MetadataChangeLogClass(DictWrapper):
    """Kafka event for capturing update made to an entity's metadata."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.mxe.MetadataChangeLog")
    def __init__(self,
        entityType: str,
        changeType: Union[str, "ChangeTypeClass"],
        auditHeader: Union[None, "KafkaAuditHeaderClass"]=None,
        entityUrn: Union[None, str]=None,
        entityKeyAspect: Union[None, "GenericAspectClass"]=None,
        aspectName: Union[None, str]=None,
        aspect: Union[None, "GenericAspectClass"]=None,
        systemMetadata: Union[None, "SystemMetadataClass"]=None,
        headers: Union[None, Dict[str, str]]=None,
        previousAspectValue: Union[None, "GenericAspectClass"]=None,
        previousSystemMetadata: Union[None, "SystemMetadataClass"]=None,
        created: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.auditHeader = auditHeader
        self.entityType = entityType
        self.entityUrn = entityUrn
        self.entityKeyAspect = entityKeyAspect
        self.changeType = changeType
        self.aspectName = aspectName
        self.aspect = aspect
        self.systemMetadata = systemMetadata
        self.headers = headers
        self.previousAspectValue = previousAspectValue
        self.previousSystemMetadata = previousSystemMetadata
        self.created = created
    
    def _restore_defaults(self) -> None:
        self.auditHeader = self.RECORD_SCHEMA.fields_dict["auditHeader"].default
        self.entityType = str()
        self.entityUrn = self.RECORD_SCHEMA.fields_dict["entityUrn"].default
        self.entityKeyAspect = self.RECORD_SCHEMA.fields_dict["entityKeyAspect"].default
        self.changeType = ChangeTypeClass.UPSERT
        self.aspectName = self.RECORD_SCHEMA.fields_dict["aspectName"].default
        self.aspect = self.RECORD_SCHEMA.fields_dict["aspect"].default
        self.systemMetadata = self.RECORD_SCHEMA.fields_dict["systemMetadata"].default
        self.headers = self.RECORD_SCHEMA.fields_dict["headers"].default
        self.previousAspectValue = self.RECORD_SCHEMA.fields_dict["previousAspectValue"].default
        self.previousSystemMetadata = self.RECORD_SCHEMA.fields_dict["previousSystemMetadata"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
    
    
    @property
    def auditHeader(self) -> Union[None, "KafkaAuditHeaderClass"]:
        """Kafka audit header. Currently remains unused in the open source."""
        return self._inner_dict.get('auditHeader')  # type: ignore
    
    @auditHeader.setter
    def auditHeader(self, value: Union[None, "KafkaAuditHeaderClass"]) -> None:
        self._inner_dict['auditHeader'] = value
    
    
    @property
    def entityType(self) -> str:
        """Type of the entity being written to"""
        return self._inner_dict.get('entityType')  # type: ignore
    
    @entityType.setter
    def entityType(self, value: str) -> None:
        self._inner_dict['entityType'] = value
    
    
    @property
    def entityUrn(self) -> Union[None, str]:
        """Urn of the entity being written"""
        return self._inner_dict.get('entityUrn')  # type: ignore
    
    @entityUrn.setter
    def entityUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['entityUrn'] = value
    
    
    @property
    def entityKeyAspect(self) -> Union[None, "GenericAspectClass"]:
        """Key aspect of the entity being written"""
        return self._inner_dict.get('entityKeyAspect')  # type: ignore
    
    @entityKeyAspect.setter
    def entityKeyAspect(self, value: Union[None, "GenericAspectClass"]) -> None:
        self._inner_dict['entityKeyAspect'] = value
    
    
    @property
    def changeType(self) -> Union[str, "ChangeTypeClass"]:
        """Type of change being proposed"""
        return self._inner_dict.get('changeType')  # type: ignore
    
    @changeType.setter
    def changeType(self, value: Union[str, "ChangeTypeClass"]) -> None:
        self._inner_dict['changeType'] = value
    
    
    @property
    def aspectName(self) -> Union[None, str]:
        """Aspect of the entity being written to
    Not filling this out implies that the writer wants to affect the entire entity
    Note: This is only valid for CREATE, UPSERT, and DELETE operations."""
        return self._inner_dict.get('aspectName')  # type: ignore
    
    @aspectName.setter
    def aspectName(self, value: Union[None, str]) -> None:
        self._inner_dict['aspectName'] = value
    
    
    @property
    def aspect(self) -> Union[None, "GenericAspectClass"]:
        """The value of the new aspect."""
        return self._inner_dict.get('aspect')  # type: ignore
    
    @aspect.setter
    def aspect(self, value: Union[None, "GenericAspectClass"]) -> None:
        self._inner_dict['aspect'] = value
    
    
    @property
    def systemMetadata(self) -> Union[None, "SystemMetadataClass"]:
        """System properties that one might want to attach to an event"""
        return self._inner_dict.get('systemMetadata')  # type: ignore
    
    @systemMetadata.setter
    def systemMetadata(self, value: Union[None, "SystemMetadataClass"]) -> None:
        self._inner_dict['systemMetadata'] = value
    
    
    @property
    def headers(self) -> Union[None, Dict[str, str]]:
        """Headers - intended to mimic http headers"""
        return self._inner_dict.get('headers')  # type: ignore
    
    @headers.setter
    def headers(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['headers'] = value
    
    
    @property
    def previousAspectValue(self) -> Union[None, "GenericAspectClass"]:
        """The previous value of the aspect that has changed."""
        return self._inner_dict.get('previousAspectValue')  # type: ignore
    
    @previousAspectValue.setter
    def previousAspectValue(self, value: Union[None, "GenericAspectClass"]) -> None:
        self._inner_dict['previousAspectValue'] = value
    
    
    @property
    def previousSystemMetadata(self) -> Union[None, "SystemMetadataClass"]:
        """The previous value of the system metadata field that has changed."""
        return self._inner_dict.get('previousSystemMetadata')  # type: ignore
    
    @previousSystemMetadata.setter
    def previousSystemMetadata(self, value: Union[None, "SystemMetadataClass"]) -> None:
        self._inner_dict['previousSystemMetadata'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """An audit stamp detailing who and when the aspect was changed by. Required for all intents and purposes."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
class MetadataChangeProposalClass(DictWrapper):
    """Kafka event for proposing a metadata change for an entity. A corresponding MetadataChangeLog is emitted when the change is accepted and committed, otherwise a FailedMetadataChangeProposal will be emitted instead."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.mxe.MetadataChangeProposal")
    def __init__(self,
        entityType: str,
        changeType: Union[str, "ChangeTypeClass"],
        auditHeader: Union[None, "KafkaAuditHeaderClass"]=None,
        entityUrn: Union[None, str]=None,
        entityKeyAspect: Union[None, "GenericAspectClass"]=None,
        aspectName: Union[None, str]=None,
        aspect: Union[None, "GenericAspectClass"]=None,
        systemMetadata: Union[None, "SystemMetadataClass"]=None,
        headers: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.auditHeader = auditHeader
        self.entityType = entityType
        self.entityUrn = entityUrn
        self.entityKeyAspect = entityKeyAspect
        self.changeType = changeType
        self.aspectName = aspectName
        self.aspect = aspect
        self.systemMetadata = systemMetadata
        self.headers = headers
    
    def _restore_defaults(self) -> None:
        self.auditHeader = self.RECORD_SCHEMA.fields_dict["auditHeader"].default
        self.entityType = str()
        self.entityUrn = self.RECORD_SCHEMA.fields_dict["entityUrn"].default
        self.entityKeyAspect = self.RECORD_SCHEMA.fields_dict["entityKeyAspect"].default
        self.changeType = ChangeTypeClass.UPSERT
        self.aspectName = self.RECORD_SCHEMA.fields_dict["aspectName"].default
        self.aspect = self.RECORD_SCHEMA.fields_dict["aspect"].default
        self.systemMetadata = self.RECORD_SCHEMA.fields_dict["systemMetadata"].default
        self.headers = self.RECORD_SCHEMA.fields_dict["headers"].default
    
    
    @property
    def auditHeader(self) -> Union[None, "KafkaAuditHeaderClass"]:
        """Kafka audit header. Currently remains unused in the open source."""
        return self._inner_dict.get('auditHeader')  # type: ignore
    
    @auditHeader.setter
    def auditHeader(self, value: Union[None, "KafkaAuditHeaderClass"]) -> None:
        self._inner_dict['auditHeader'] = value
    
    
    @property
    def entityType(self) -> str:
        """Type of the entity being written to"""
        return self._inner_dict.get('entityType')  # type: ignore
    
    @entityType.setter
    def entityType(self, value: str) -> None:
        self._inner_dict['entityType'] = value
    
    
    @property
    def entityUrn(self) -> Union[None, str]:
        """Urn of the entity being written"""
        return self._inner_dict.get('entityUrn')  # type: ignore
    
    @entityUrn.setter
    def entityUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['entityUrn'] = value
    
    
    @property
    def entityKeyAspect(self) -> Union[None, "GenericAspectClass"]:
        """Key aspect of the entity being written"""
        return self._inner_dict.get('entityKeyAspect')  # type: ignore
    
    @entityKeyAspect.setter
    def entityKeyAspect(self, value: Union[None, "GenericAspectClass"]) -> None:
        self._inner_dict['entityKeyAspect'] = value
    
    
    @property
    def changeType(self) -> Union[str, "ChangeTypeClass"]:
        """Type of change being proposed"""
        return self._inner_dict.get('changeType')  # type: ignore
    
    @changeType.setter
    def changeType(self, value: Union[str, "ChangeTypeClass"]) -> None:
        self._inner_dict['changeType'] = value
    
    
    @property
    def aspectName(self) -> Union[None, str]:
        """Aspect of the entity being written to
    Not filling this out implies that the writer wants to affect the entire entity
    Note: This is only valid for CREATE, UPSERT, and DELETE operations."""
        return self._inner_dict.get('aspectName')  # type: ignore
    
    @aspectName.setter
    def aspectName(self, value: Union[None, str]) -> None:
        self._inner_dict['aspectName'] = value
    
    
    @property
    def aspect(self) -> Union[None, "GenericAspectClass"]:
        """The value of the new aspect."""
        return self._inner_dict.get('aspect')  # type: ignore
    
    @aspect.setter
    def aspect(self, value: Union[None, "GenericAspectClass"]) -> None:
        self._inner_dict['aspect'] = value
    
    
    @property
    def systemMetadata(self) -> Union[None, "SystemMetadataClass"]:
        """System properties that one might want to attach to an event"""
        return self._inner_dict.get('systemMetadata')  # type: ignore
    
    @systemMetadata.setter
    def systemMetadata(self, value: Union[None, "SystemMetadataClass"]) -> None:
        self._inner_dict['systemMetadata'] = value
    
    
    @property
    def headers(self) -> Union[None, Dict[str, str]]:
        """Headers - intended to mimic http headers"""
        return self._inner_dict.get('headers')  # type: ignore
    
    @headers.setter
    def headers(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['headers'] = value
    
    
class PlatformEventClass(DictWrapper):
    """A DataHub Platform Event."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.mxe.PlatformEvent")
    def __init__(self,
        header: "PlatformEventHeaderClass",
        name: str,
        payload: "GenericPayloadClass",
    ):
        super().__init__()
        
        self.header = header
        self.name = name
        self.payload = payload
    
    def _restore_defaults(self) -> None:
        self.header = PlatformEventHeaderClass._construct_with_defaults()
        self.name = str()
        self.payload = GenericPayloadClass._construct_with_defaults()
    
    
    @property
    def header(self) -> "PlatformEventHeaderClass":
        """Header information stored with the event."""
        return self._inner_dict.get('header')  # type: ignore
    
    @header.setter
    def header(self, value: "PlatformEventHeaderClass") -> None:
        self._inner_dict['header'] = value
    
    
    @property
    def name(self) -> str:
        """The name of the event, e.g. the type of event. For example, 'notificationRequestEvent', 'entityChangeEvent'"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def payload(self) -> "GenericPayloadClass":
        """The event payload."""
        return self._inner_dict.get('payload')  # type: ignore
    
    @payload.setter
    def payload(self, value: "GenericPayloadClass") -> None:
        self._inner_dict['payload'] = value
    
    
class PlatformEventHeaderClass(DictWrapper):
    """A header included with each DataHub platform event."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.mxe.PlatformEventHeader")
    def __init__(self,
        timestampMillis: int,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
class SystemMetadataClass(_Aspect):
    """Metadata associated with each metadata change that is processed by the system"""


    ASPECT_NAME = 'systemMetadata'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.mxe.SystemMetadata")

    def __init__(self,
        lastObserved: Optional[Union[int, None]]=None,
        runId: Optional[Union[str, None]]=None,
        lastRunId: Optional[Union[str, None]]=None,
        pipelineName: Union[None, str]=None,
        registryName: Union[None, str]=None,
        registryVersion: Union[None, str]=None,
        properties: Union[None, Dict[str, str]]=None,
        version: Union[None, str]=None,
        aspectCreated: Union[None, "AuditStampClass"]=None,
        aspectModified: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        if lastObserved is None:
            # default: 0
            self.lastObserved = self.RECORD_SCHEMA.fields_dict["lastObserved"].default
        else:
            self.lastObserved = lastObserved
        if runId is None:
            # default: 'no-run-id-provided'
            self.runId = self.RECORD_SCHEMA.fields_dict["runId"].default
        else:
            self.runId = runId
        if lastRunId is None:
            # default: 'no-run-id-provided'
            self.lastRunId = self.RECORD_SCHEMA.fields_dict["lastRunId"].default
        else:
            self.lastRunId = lastRunId
        self.pipelineName = pipelineName
        self.registryName = registryName
        self.registryVersion = registryVersion
        self.properties = properties
        self.version = version
        self.aspectCreated = aspectCreated
        self.aspectModified = aspectModified
    
    def _restore_defaults(self) -> None:
        self.lastObserved = self.RECORD_SCHEMA.fields_dict["lastObserved"].default
        self.runId = self.RECORD_SCHEMA.fields_dict["runId"].default
        self.lastRunId = self.RECORD_SCHEMA.fields_dict["lastRunId"].default
        self.pipelineName = self.RECORD_SCHEMA.fields_dict["pipelineName"].default
        self.registryName = self.RECORD_SCHEMA.fields_dict["registryName"].default
        self.registryVersion = self.RECORD_SCHEMA.fields_dict["registryVersion"].default
        self.properties = self.RECORD_SCHEMA.fields_dict["properties"].default
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
        self.aspectCreated = self.RECORD_SCHEMA.fields_dict["aspectCreated"].default
        self.aspectModified = self.RECORD_SCHEMA.fields_dict["aspectModified"].default
    
    
    @property
    def lastObserved(self) -> Union[int, None]:
        """The timestamp the metadata was observed at"""
        return self._inner_dict.get('lastObserved')  # type: ignore
    
    @lastObserved.setter
    def lastObserved(self, value: Union[int, None]) -> None:
        self._inner_dict['lastObserved'] = value
    
    
    @property
    def runId(self) -> Union[str, None]:
        """The original run id that produced the metadata. Populated in case of batch-ingestion."""
        return self._inner_dict.get('runId')  # type: ignore
    
    @runId.setter
    def runId(self, value: Union[str, None]) -> None:
        self._inner_dict['runId'] = value
    
    
    @property
    def lastRunId(self) -> Union[str, None]:
        """The last run id that produced the metadata. Populated in case of batch-ingestion."""
        return self._inner_dict.get('lastRunId')  # type: ignore
    
    @lastRunId.setter
    def lastRunId(self, value: Union[str, None]) -> None:
        self._inner_dict['lastRunId'] = value
    
    
    @property
    def pipelineName(self) -> Union[None, str]:
        """The ingestion pipeline id that produced the metadata. Populated in case of batch ingestion."""
        return self._inner_dict.get('pipelineName')  # type: ignore
    
    @pipelineName.setter
    def pipelineName(self, value: Union[None, str]) -> None:
        self._inner_dict['pipelineName'] = value
    
    
    @property
    def registryName(self) -> Union[None, str]:
        """The model registry name that was used to process this event"""
        return self._inner_dict.get('registryName')  # type: ignore
    
    @registryName.setter
    def registryName(self, value: Union[None, str]) -> None:
        self._inner_dict['registryName'] = value
    
    
    @property
    def registryVersion(self) -> Union[None, str]:
        """The model registry version that was used to process this event"""
        return self._inner_dict.get('registryVersion')  # type: ignore
    
    @registryVersion.setter
    def registryVersion(self, value: Union[None, str]) -> None:
        self._inner_dict['registryVersion'] = value
    
    
    @property
    def properties(self) -> Union[None, Dict[str, str]]:
        """Additional properties"""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['properties'] = value
    
    
    @property
    def version(self) -> Union[None, str]:
        """Aspect version
       Initial implementation will use the aspect version's number, however stored as
       a string in the case where a different aspect versioning scheme is later adopted."""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, str]) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def aspectCreated(self) -> Union[None, "AuditStampClass"]:
        """When the aspect was initially created and who created it, detected by version 0 -> 1 change"""
        return self._inner_dict.get('aspectCreated')  # type: ignore
    
    @aspectCreated.setter
    def aspectCreated(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['aspectCreated'] = value
    
    
    @property
    def aspectModified(self) -> Union[None, "AuditStampClass"]:
        """When the aspect was last modified and the actor that performed the modification"""
        return self._inner_dict.get('aspectModified')  # type: ignore
    
    @aspectModified.setter
    def aspectModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['aspectModified'] = value
    
    
class ChartCellClass(DictWrapper):
    """Chart cell in a notebook, which will present content in chart format"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notebook.ChartCell")
    def __init__(self,
        cellId: str,
        changeAuditStamps: "ChangeAuditStampsClass",
        cellTitle: Union[None, str]=None,
    ):
        super().__init__()
        
        self.cellTitle = cellTitle
        self.cellId = cellId
        self.changeAuditStamps = changeAuditStamps
    
    def _restore_defaults(self) -> None:
        self.cellTitle = self.RECORD_SCHEMA.fields_dict["cellTitle"].default
        self.cellId = str()
        self.changeAuditStamps = ChangeAuditStampsClass._construct_with_defaults()
    
    
    @property
    def cellTitle(self) -> Union[None, str]:
        """Title of the cell"""
        return self._inner_dict.get('cellTitle')  # type: ignore
    
    @cellTitle.setter
    def cellTitle(self, value: Union[None, str]) -> None:
        self._inner_dict['cellTitle'] = value
    
    
    @property
    def cellId(self) -> str:
        """Unique id for the cell. This id should be globally unique for a Notebook tool even when there are multiple deployments of it. As an example, Notebook URL could be used here for QueryBook such as 'querybook.com/notebook/773/?cellId=1234'"""
        return self._inner_dict.get('cellId')  # type: ignore
    
    @cellId.setter
    def cellId(self, value: str) -> None:
        self._inner_dict['cellId'] = value
    
    
    @property
    def changeAuditStamps(self) -> "ChangeAuditStampsClass":
        """Captures information about who created/last modified/deleted this Notebook cell and when"""
        return self._inner_dict.get('changeAuditStamps')  # type: ignore
    
    @changeAuditStamps.setter
    def changeAuditStamps(self, value: "ChangeAuditStampsClass") -> None:
        self._inner_dict['changeAuditStamps'] = value
    
    
class EditableNotebookPropertiesClass(_Aspect):
    """Stores editable changes made to properties. This separates changes made from
    ingestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines
    Note: This is IN BETA version"""


    ASPECT_NAME = 'editableNotebookProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notebook.EditableNotebookProperties")

    def __init__(self,
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Edited documentation of the Notebook"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class NotebookCellClass(DictWrapper):
    """A record of all supported cells for a Notebook. Only one type of cell will be non-null."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notebook.NotebookCell")
    def __init__(self,
        type: Union[str, "NotebookCellTypeClass"],
        textCell: Union[None, "TextCellClass"]=None,
        queryCell: Union[None, "QueryCellClass"]=None,
        chartCell: Union[None, "ChartCellClass"]=None,
    ):
        super().__init__()
        
        self.textCell = textCell
        self.queryCell = queryCell
        self.chartCell = chartCell
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.textCell = self.RECORD_SCHEMA.fields_dict["textCell"].default
        self.queryCell = self.RECORD_SCHEMA.fields_dict["queryCell"].default
        self.chartCell = self.RECORD_SCHEMA.fields_dict["chartCell"].default
        self.type = NotebookCellTypeClass.TEXT_CELL
    
    
    @property
    def textCell(self) -> Union[None, "TextCellClass"]:
        """The text cell content. The will be non-null only when all other cell field is null."""
        return self._inner_dict.get('textCell')  # type: ignore
    
    @textCell.setter
    def textCell(self, value: Union[None, "TextCellClass"]) -> None:
        self._inner_dict['textCell'] = value
    
    
    @property
    def queryCell(self) -> Union[None, "QueryCellClass"]:
        """The query cell content. The will be non-null only when all other cell field is null."""
        return self._inner_dict.get('queryCell')  # type: ignore
    
    @queryCell.setter
    def queryCell(self, value: Union[None, "QueryCellClass"]) -> None:
        self._inner_dict['queryCell'] = value
    
    
    @property
    def chartCell(self) -> Union[None, "ChartCellClass"]:
        """The chart cell content. The will be non-null only when all other cell field is null."""
        return self._inner_dict.get('chartCell')  # type: ignore
    
    @chartCell.setter
    def chartCell(self, value: Union[None, "ChartCellClass"]) -> None:
        self._inner_dict['chartCell'] = value
    
    
    @property
    def type(self) -> Union[str, "NotebookCellTypeClass"]:
        """The type of this Notebook cell"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "NotebookCellTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class NotebookCellTypeClass(object):
    """Type of Notebook Cell"""
    
    TEXT_CELL = "TEXT_CELL"
    """TEXT Notebook cell type. The cell context is text only."""
    
    QUERY_CELL = "QUERY_CELL"
    """QUERY Notebook cell type. The cell context is query only."""
    
    CHART_CELL = "CHART_CELL"
    """CHART Notebook cell type. The cell content is chart only."""
    
    
    
class NotebookContentClass(_Aspect):
    """Content in a Notebook
    Note: This is IN BETA version"""


    ASPECT_NAME = 'notebookContent'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notebook.NotebookContent")

    def __init__(self,
        cells: Optional[List["NotebookCellClass"]]=None,
    ):
        super().__init__()
        
        if cells is None:
            # default: []
            self.cells = list()
        else:
            self.cells = cells
    
    def _restore_defaults(self) -> None:
        self.cells = list()
    
    
    @property
    def cells(self) -> List["NotebookCellClass"]:
        """The content of a Notebook which is composed by a list of NotebookCell"""
        return self._inner_dict.get('cells')  # type: ignore
    
    @cells.setter
    def cells(self, value: List["NotebookCellClass"]) -> None:
        self._inner_dict['cells'] = value
    
    
class NotebookInfoClass(_Aspect):
    """Information about a Notebook
    Note: This is IN BETA version"""


    ASPECT_NAME = 'notebookInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notebook.NotebookInfo")

    def __init__(self,
        title: str,
        changeAuditStamps: "ChangeAuditStampsClass",
        customProperties: Optional[Dict[str, str]]=None,
        externalUrl: Union[None, str]=None,
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.externalUrl = externalUrl
        self.title = title
        self.description = description
        self.changeAuditStamps = changeAuditStamps
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.externalUrl = self.RECORD_SCHEMA.fields_dict["externalUrl"].default
        self.title = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.changeAuditStamps = ChangeAuditStampsClass._construct_with_defaults()
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def externalUrl(self) -> Union[None, str]:
        """URL where the reference exist"""
        return self._inner_dict.get('externalUrl')  # type: ignore
    
    @externalUrl.setter
    def externalUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['externalUrl'] = value
    
    
    @property
    def title(self) -> str:
        """Title of the Notebook"""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: str) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Detailed description about the Notebook"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def changeAuditStamps(self) -> "ChangeAuditStampsClass":
        """Captures information about who created/last modified/deleted this Notebook and when"""
        return self._inner_dict.get('changeAuditStamps')  # type: ignore
    
    @changeAuditStamps.setter
    def changeAuditStamps(self, value: "ChangeAuditStampsClass") -> None:
        self._inner_dict['changeAuditStamps'] = value
    
    
class QueryCellClass(DictWrapper):
    """Query cell in a Notebook, which will present content in query format"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notebook.QueryCell")
    def __init__(self,
        cellId: str,
        changeAuditStamps: "ChangeAuditStampsClass",
        rawQuery: str,
        cellTitle: Union[None, str]=None,
        lastExecuted: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.cellTitle = cellTitle
        self.cellId = cellId
        self.changeAuditStamps = changeAuditStamps
        self.rawQuery = rawQuery
        self.lastExecuted = lastExecuted
    
    def _restore_defaults(self) -> None:
        self.cellTitle = self.RECORD_SCHEMA.fields_dict["cellTitle"].default
        self.cellId = str()
        self.changeAuditStamps = ChangeAuditStampsClass._construct_with_defaults()
        self.rawQuery = str()
        self.lastExecuted = self.RECORD_SCHEMA.fields_dict["lastExecuted"].default
    
    
    @property
    def cellTitle(self) -> Union[None, str]:
        """Title of the cell"""
        return self._inner_dict.get('cellTitle')  # type: ignore
    
    @cellTitle.setter
    def cellTitle(self, value: Union[None, str]) -> None:
        self._inner_dict['cellTitle'] = value
    
    
    @property
    def cellId(self) -> str:
        """Unique id for the cell. This id should be globally unique for a Notebook tool even when there are multiple deployments of it. As an example, Notebook URL could be used here for QueryBook such as 'querybook.com/notebook/773/?cellId=1234'"""
        return self._inner_dict.get('cellId')  # type: ignore
    
    @cellId.setter
    def cellId(self, value: str) -> None:
        self._inner_dict['cellId'] = value
    
    
    @property
    def changeAuditStamps(self) -> "ChangeAuditStampsClass":
        """Captures information about who created/last modified/deleted this Notebook cell and when"""
        return self._inner_dict.get('changeAuditStamps')  # type: ignore
    
    @changeAuditStamps.setter
    def changeAuditStamps(self, value: "ChangeAuditStampsClass") -> None:
        self._inner_dict['changeAuditStamps'] = value
    
    
    @property
    def rawQuery(self) -> str:
        """Raw query to explain some specific logic in a Notebook"""
        return self._inner_dict.get('rawQuery')  # type: ignore
    
    @rawQuery.setter
    def rawQuery(self, value: str) -> None:
        self._inner_dict['rawQuery'] = value
    
    
    @property
    def lastExecuted(self) -> Union[None, "AuditStampClass"]:
        """Captures information about who last executed this query cell and when"""
        return self._inner_dict.get('lastExecuted')  # type: ignore
    
    @lastExecuted.setter
    def lastExecuted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastExecuted'] = value
    
    
class TextCellClass(DictWrapper):
    """Text cell in a Notebook, which will present content in text format"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notebook.TextCell")
    def __init__(self,
        cellId: str,
        changeAuditStamps: "ChangeAuditStampsClass",
        text: str,
        cellTitle: Union[None, str]=None,
    ):
        super().__init__()
        
        self.cellTitle = cellTitle
        self.cellId = cellId
        self.changeAuditStamps = changeAuditStamps
        self.text = text
    
    def _restore_defaults(self) -> None:
        self.cellTitle = self.RECORD_SCHEMA.fields_dict["cellTitle"].default
        self.cellId = str()
        self.changeAuditStamps = ChangeAuditStampsClass._construct_with_defaults()
        self.text = str()
    
    
    @property
    def cellTitle(self) -> Union[None, str]:
        """Title of the cell"""
        return self._inner_dict.get('cellTitle')  # type: ignore
    
    @cellTitle.setter
    def cellTitle(self, value: Union[None, str]) -> None:
        self._inner_dict['cellTitle'] = value
    
    
    @property
    def cellId(self) -> str:
        """Unique id for the cell. This id should be globally unique for a Notebook tool even when there are multiple deployments of it. As an example, Notebook URL could be used here for QueryBook such as 'querybook.com/notebook/773/?cellId=1234'"""
        return self._inner_dict.get('cellId')  # type: ignore
    
    @cellId.setter
    def cellId(self, value: str) -> None:
        self._inner_dict['cellId'] = value
    
    
    @property
    def changeAuditStamps(self) -> "ChangeAuditStampsClass":
        """Captures information about who created/last modified/deleted this Notebook cell and when"""
        return self._inner_dict.get('changeAuditStamps')  # type: ignore
    
    @changeAuditStamps.setter
    def changeAuditStamps(self, value: "ChangeAuditStampsClass") -> None:
        self._inner_dict['changeAuditStamps'] = value
    
    
    @property
    def text(self) -> str:
        """The actual text in a TextCell in a Notebook"""
        return self._inner_dict.get('text')  # type: ignore
    
    @text.setter
    def text(self, value: str) -> None:
        self._inner_dict['text'] = value
    
    
class FormNotificationDetailsClass(DictWrapper):
    """Info about all of the notifications a user has received for a given form"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notification.FormNotificationDetails")
    def __init__(self,
        formUrn: str,
        notificationLog: Optional[List["FormNotificationEntryClass"]]=None,
    ):
        super().__init__()
        
        self.formUrn = formUrn
        if notificationLog is None:
            # default: []
            self.notificationLog = list()
        else:
            self.notificationLog = notificationLog
    
    def _restore_defaults(self) -> None:
        self.formUrn = str()
        self.notificationLog = list()
    
    
    @property
    def formUrn(self) -> str:
        """The urn of the form that these notification details are on behalf of"""
        return self._inner_dict.get('formUrn')  # type: ignore
    
    @formUrn.setter
    def formUrn(self, value: str) -> None:
        self._inner_dict['formUrn'] = value
    
    
    @property
    def notificationLog(self) -> List["FormNotificationEntryClass"]:
        """The list of details per notification sent on behalf of this form"""
        return self._inner_dict.get('notificationLog')  # type: ignore
    
    @notificationLog.setter
    def notificationLog(self, value: List["FormNotificationEntryClass"]) -> None:
        self._inner_dict['notificationLog'] = value
    
    
class FormNotificationEntryClass(DictWrapper):
    """Info about a specific form notification"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notification.FormNotificationEntry")
    def __init__(self,
        time: int,
        notificationType: str,
    ):
        super().__init__()
        
        self.time = time
        self.notificationType = notificationType
    
    def _restore_defaults(self) -> None:
        self.time = int()
        self.notificationType = str()
    
    
    @property
    def time(self) -> int:
        """The time at which this notification was sent in milliseconds"""
        return self._inner_dict.get('time')  # type: ignore
    
    @time.setter
    def time(self, value: int) -> None:
        self._inner_dict['time'] = value
    
    
    @property
    def notificationType(self) -> str:
        """The notification scenario type for this notification record"""
        return self._inner_dict.get('notificationType')  # type: ignore
    
    @notificationType.setter
    def notificationType(self, value: str) -> None:
        self._inner_dict['notificationType'] = value
    
    
class FormNotificationsClass(_Aspect):
    """The history of notifications sent to this actor on behalf of forms"""


    ASPECT_NAME = 'formNotifications'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.notification.FormNotifications")

    def __init__(self,
        notificationDetails: Optional[List["FormNotificationDetailsClass"]]=None,
    ):
        super().__init__()
        
        if notificationDetails is None:
            # default: []
            self.notificationDetails = list()
        else:
            self.notificationDetails = notificationDetails
    
    def _restore_defaults(self) -> None:
        self.notificationDetails = list()
    
    
    @property
    def notificationDetails(self) -> List["FormNotificationDetailsClass"]:
        """List of details for notifications for each form"""
        return self._inner_dict.get('notificationDetails')  # type: ignore
    
    @notificationDetails.setter
    def notificationDetails(self, value: List["FormNotificationDetailsClass"]) -> None:
        self._inner_dict['notificationDetails'] = value
    
    
class OwnershipTypeInfoClass(_Aspect):
    """Information about an ownership type"""


    ASPECT_NAME = 'ownershipTypeInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.ownership.OwnershipTypeInfo")

    def __init__(self,
        name: str,
        created: "AuditStampClass",
        lastModified: "AuditStampClass",
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.description = description
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.created = AuditStampClass._construct_with_defaults()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def name(self) -> str:
        """Display name of the Ownership Type"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the Ownership Type"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp capturing the time and actor who created the Ownership Type."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp capturing the time and actor who last modified the Ownership Type."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class DataHubPersonaInfoClass(_Aspect):
    """Placeholder aspect for persona type info"""


    ASPECT_NAME = 'dataHubPersonaInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.persona.DataHubPersonaInfo")

    def __init__(self,
        view: Union[None, str]=None,
    ):
        super().__init__()
        
        self.view = view
    
    def _restore_defaults(self) -> None:
        self.view = self.RECORD_SCHEMA.fields_dict["view"].default
    
    
    @property
    def view(self) -> Union[None, str]:
        """The urn of the search view associated with the persona."""
        return self._inner_dict.get('view')  # type: ignore
    
    @view.setter
    def view(self, value: Union[None, str]) -> None:
        self._inner_dict['view'] = value
    
    
class EntityChangeEventClass(DictWrapper):
    """Shared fields for all entity change events."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.platform.event.v1.EntityChangeEvent")
    def __init__(self,
        entityType: str,
        entityUrn: str,
        category: str,
        operation: str,
        auditStamp: "AuditStampClass",
        version: int,
        modifier: Union[None, str]=None,
        parameters: Union[None, "ParametersClass"]=None,
    ):
        super().__init__()
        
        self.entityType = entityType
        self.entityUrn = entityUrn
        self.category = category
        self.operation = operation
        self.modifier = modifier
        self.parameters = parameters
        self.auditStamp = auditStamp
        self.version = version
    
    def _restore_defaults(self) -> None:
        self.entityType = str()
        self.entityUrn = str()
        self.category = str()
        self.operation = str()
        self.modifier = self.RECORD_SCHEMA.fields_dict["modifier"].default
        self.parameters = self.RECORD_SCHEMA.fields_dict["parameters"].default
        self.auditStamp = AuditStampClass._construct_with_defaults()
        self.version = int()
    
    
    @property
    def entityType(self) -> str:
        """The type of the entity affected. Corresponds to the entity registry, e.g. 'dataset', 'chart', 'dashboard', etc."""
        return self._inner_dict.get('entityType')  # type: ignore
    
    @entityType.setter
    def entityType(self, value: str) -> None:
        self._inner_dict['entityType'] = value
    
    
    @property
    def entityUrn(self) -> str:
        """The urn of the entity which was affected."""
        return self._inner_dict.get('entityUrn')  # type: ignore
    
    @entityUrn.setter
    def entityUrn(self, value: str) -> None:
        self._inner_dict['entityUrn'] = value
    
    
    @property
    def category(self) -> str:
        """The category type (TAG, GLOSSARY_TERM, OWNERSHIP, TECHNICAL_SCHEMA, etc). This is used to determine what the rest of the schema will look like."""
        return self._inner_dict.get('category')  # type: ignore
    
    @category.setter
    def category(self, value: str) -> None:
        self._inner_dict['category'] = value
    
    
    @property
    def operation(self) -> str:
        """The operation type. This is used to determine what the rest of the schema will look like."""
        return self._inner_dict.get('operation')  # type: ignore
    
    @operation.setter
    def operation(self, value: str) -> None:
        self._inner_dict['operation'] = value
    
    
    @property
    def modifier(self) -> Union[None, str]:
        """The urn of the entity which was affected."""
        return self._inner_dict.get('modifier')  # type: ignore
    
    @modifier.setter
    def modifier(self, value: Union[None, str]) -> None:
        self._inner_dict['modifier'] = value
    
    
    @property
    def parameters(self) -> Union[None, "ParametersClass"]:
        """Arbitrary key-value parameters corresponding to the event."""
        return self._inner_dict.get('parameters')  # type: ignore
    
    @parameters.setter
    def parameters(self, value: Union[None, "ParametersClass"]) -> None:
        self._inner_dict['parameters'] = value
    
    
    @property
    def auditStamp(self) -> "AuditStampClass":
        """Audit stamp of the operation"""
        return self._inner_dict.get('auditStamp')  # type: ignore
    
    @auditStamp.setter
    def auditStamp(self, value: "AuditStampClass") -> None:
        self._inner_dict['auditStamp'] = value
    
    
    @property
    def version(self) -> int:
        """The version of the event type, incremented in integers."""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: int) -> None:
        self._inner_dict['version'] = value
    
    
class ParametersClass(DictWrapper):
    """Arbitrary key-value parameters for an Entity Change Event. (any record)."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.platform.event.v1.Parameters")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class RelationshipChangeEventClass(DictWrapper):
    """Kafka event for proposing a relationship change between two entities.
    For example, when dataset1 establishes a new downstream relationship with dataset2."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.platform.event.v1.RelationshipChangeEvent")
    def __init__(self,
        sourceUrn: str,
        destinationUrn: str,
        operation: Union[str, "RelationshipChangeOperationClass"],
        relationshipType: str,
        auditStamp: "AuditStampClass",
        auditHeader: Union[None, "KafkaAuditHeaderClass"]=None,
        lifecycleOwner: Union[None, str]=None,
        via: Union[None, str]=None,
        properties: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.auditHeader = auditHeader
        self.sourceUrn = sourceUrn
        self.destinationUrn = destinationUrn
        self.operation = operation
        self.relationshipType = relationshipType
        self.lifecycleOwner = lifecycleOwner
        self.via = via
        self.properties = properties
        self.auditStamp = auditStamp
    
    def _restore_defaults(self) -> None:
        self.auditHeader = self.RECORD_SCHEMA.fields_dict["auditHeader"].default
        self.sourceUrn = str()
        self.destinationUrn = str()
        self.operation = RelationshipChangeOperationClass.ADD
        self.relationshipType = str()
        self.lifecycleOwner = self.RECORD_SCHEMA.fields_dict["lifecycleOwner"].default
        self.via = self.RECORD_SCHEMA.fields_dict["via"].default
        self.properties = self.RECORD_SCHEMA.fields_dict["properties"].default
        self.auditStamp = AuditStampClass._construct_with_defaults()
    
    
    @property
    def auditHeader(self) -> Union[None, "KafkaAuditHeaderClass"]:
        """Kafka audit header containing metadata about the message itself.
    Includes information like message ID, timestamp, and server details."""
        return self._inner_dict.get('auditHeader')  # type: ignore
    
    @auditHeader.setter
    def auditHeader(self, value: Union[None, "KafkaAuditHeaderClass"]) -> None:
        self._inner_dict['auditHeader'] = value
    
    
    @property
    def sourceUrn(self) -> str:
        """The URN (Uniform Resource Name) of the source entity in the relationship.
    In a downstream relationship example, this would be the URN of the upstream dataset."""
        return self._inner_dict.get('sourceUrn')  # type: ignore
    
    @sourceUrn.setter
    def sourceUrn(self, value: str) -> None:
        self._inner_dict['sourceUrn'] = value
    
    
    @property
    def destinationUrn(self) -> str:
        """The URN of the destination entity in the relationship.
    In a downstream relationship example, this would be the URN of the downstream dataset."""
        return self._inner_dict.get('destinationUrn')  # type: ignore
    
    @destinationUrn.setter
    def destinationUrn(self, value: str) -> None:
        self._inner_dict['destinationUrn'] = value
    
    
    @property
    def operation(self) -> Union[str, "RelationshipChangeOperationClass"]:
        """The operation being performed on this relationship.
    Typically includes operations like ADD, REMOVE, or RESTATE."""
        return self._inner_dict.get('operation')  # type: ignore
    
    @operation.setter
    def operation(self, value: Union[str, "RelationshipChangeOperationClass"]) -> None:
        self._inner_dict['operation'] = value
    
    
    @property
    def relationshipType(self) -> str:
        """The type/category of relationship being established or modified.
    Examples: "DownstreamOf", "Contains", "OwnedBy", "DerivedFrom", etc."""
        return self._inner_dict.get('relationshipType')  # type: ignore
    
    @relationshipType.setter
    def relationshipType(self, value: str) -> None:
        self._inner_dict['relationshipType'] = value
    
    
    @property
    def lifecycleOwner(self) -> Union[None, str]:
        """The system or service responsible for managing the lifecycle of this relationship.
    This helps identify which component has authority over the relationship."""
        return self._inner_dict.get('lifecycleOwner')  # type: ignore
    
    @lifecycleOwner.setter
    def lifecycleOwner(self, value: Union[None, str]) -> None:
        self._inner_dict['lifecycleOwner'] = value
    
    
    @property
    def via(self) -> Union[None, str]:
        """Information about how or through what means this relationship was established.
    Could indicate a specific pipeline, process, or tool that discovered/created the relationship."""
        return self._inner_dict.get('via')  # type: ignore
    
    @via.setter
    def via(self, value: Union[None, str]) -> None:
        self._inner_dict['via'] = value
    
    
    @property
    def properties(self) -> Union[None, Dict[str, str]]:
        """Additional custom properties associated with this relationship.
    Allows for flexible extension without changing the schema."""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['properties'] = value
    
    
    @property
    def auditStamp(self) -> "AuditStampClass":
        """Stores information about who made this change and when.
    Contains the actor (user or system) that performed the action and the timestamp."""
        return self._inner_dict.get('auditStamp')  # type: ignore
    
    @auditStamp.setter
    def auditStamp(self, value: "AuditStampClass") -> None:
        self._inner_dict['auditStamp'] = value
    
    
class RelationshipChangeOperationClass(object):
    # No docs available.
    
    ADD = "ADD"
    REMOVE = "REMOVE"
    RESTATE = "RESTATE"
    
    
class PlatformResourceInfoClass(_Aspect):
    """Platform Resource Info.
    These entities are for miscelaneous data that is used in non-core parts of the system.
    For instance, if we want to persist & retrieve data from auxiliary integrations such as Slack or Microsoft Teams."""


    ASPECT_NAME = 'platformResourceInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.platformresource.PlatformResourceInfo")

    def __init__(self,
        resourceType: str,
        primaryKey: str,
        secondaryKeys: Union[None, List[str]]=None,
        value: Union[None, "SerializedValueClass"]=None,
    ):
        super().__init__()
        
        self.resourceType = resourceType
        self.primaryKey = primaryKey
        self.secondaryKeys = secondaryKeys
        self.value = value
    
    def _restore_defaults(self) -> None:
        self.resourceType = str()
        self.primaryKey = str()
        self.secondaryKeys = self.RECORD_SCHEMA.fields_dict["secondaryKeys"].default
        self.value = self.RECORD_SCHEMA.fields_dict["value"].default
    
    
    @property
    def resourceType(self) -> str:
        """The type of the resource. 
    Intended as a loose specifier of the generic type of the resource.
    Producer is not forced to conform to a specific set of symbols for
    resource types.
    The @PlatformResourceType enumeration offers a paved path for agreed upon
    common terms, but is not required to be followed.
    Example values could be: conversation, user, grant, etc.
    Resource types are indexed for ease of access. 
    e.g. Get me all platform resources of type user for the platform looker"""
        return self._inner_dict.get('resourceType')  # type: ignore
    
    @resourceType.setter
    def resourceType(self, value: str) -> None:
        self._inner_dict['resourceType'] = value
    
    
    @property
    def primaryKey(self) -> str:
        """The primary key for this platform resource.
    e.g. for a slack member this would be the memberID.
    primary keys specified here don't need to include any additional specificity for the
         dataPlatform
    The @PlatformResourceKey is supposed to represent that"""
        return self._inner_dict.get('primaryKey')  # type: ignore
    
    @primaryKey.setter
    def primaryKey(self, value: str) -> None:
        self._inner_dict['primaryKey'] = value
    
    
    @property
    def secondaryKeys(self) -> Union[None, List[str]]:
        """The secondary keys this platform resource can be located by.
    I.e., for a slack member this would be email or phone."""
        return self._inner_dict.get('secondaryKeys')  # type: ignore
    
    @secondaryKeys.setter
    def secondaryKeys(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['secondaryKeys'] = value
    
    
    @property
    def value(self) -> Union[None, "SerializedValueClass"]:
        """The serialized value of this platform resource item."""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: Union[None, "SerializedValueClass"]) -> None:
        self._inner_dict['value'] = value
    
    
class PlatformResourceKeyClass(_Aspect):
    """Key for a Platform Resource.
    Platform Resources are assets that are not part of the core data model.
    They are stored in DataHub primarily to help with application-specific
    use-cases that are not sufficiently generalized to move into the core data model.
    For instance, if we want to persist & retrieve additional user profile data 
    from auxiliary integrations such as Slack or Microsoft Teams for resolving details later."""


    ASPECT_NAME = 'platformResourceKey'
    ASPECT_INFO = {'keyForEntity': 'platformResource', 'entityCategory': 'core', 'entityAspects': ['dataPlatformInstance', 'platformResourceInfo', 'status'], 'entityDoc': 'Platform Resources are assets that are unmodeled and stored outside of the core data model. They are stored in DataHub primarily to help with application-specific use-cases that are not sufficiently generalized to move into the core data model.'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.platformresource.PlatformResourceKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """A unique id for this entity.
    There are no constraints on the format of this id, but most implementations
    will choose to use a UUID.
    This id should be globally unique for the entire DataHub instance and
         uniquely identify the resource that is being stored, so most
         implementations
    will combine logical attributes like platform name, platform instance,
    platform-specific-id and the resource type to create the unique id.
    e.g. slack:slack-instance:slack-user-id:user-info 
    or guid(slack, slack-instance, slack-user-id, user-info) etc."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class DataHubActorFilterClass(DictWrapper):
    """Information used to filter DataHub actors."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.policy.DataHubActorFilter")
    def __init__(self,
        users: Union[None, List[str]]=None,
        groups: Union[None, List[str]]=None,
        resourceOwners: Optional[bool]=None,
        resourceOwnersTypes: Union[None, List[str]]=None,
        allUsers: Optional[bool]=None,
        allGroups: Optional[bool]=None,
        roles: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.users = users
        self.groups = groups
        if resourceOwners is None:
            # default: False
            self.resourceOwners = self.RECORD_SCHEMA.fields_dict["resourceOwners"].default
        else:
            self.resourceOwners = resourceOwners
        self.resourceOwnersTypes = resourceOwnersTypes
        if allUsers is None:
            # default: False
            self.allUsers = self.RECORD_SCHEMA.fields_dict["allUsers"].default
        else:
            self.allUsers = allUsers
        if allGroups is None:
            # default: False
            self.allGroups = self.RECORD_SCHEMA.fields_dict["allGroups"].default
        else:
            self.allGroups = allGroups
        self.roles = roles
    
    def _restore_defaults(self) -> None:
        self.users = self.RECORD_SCHEMA.fields_dict["users"].default
        self.groups = self.RECORD_SCHEMA.fields_dict["groups"].default
        self.resourceOwners = self.RECORD_SCHEMA.fields_dict["resourceOwners"].default
        self.resourceOwnersTypes = self.RECORD_SCHEMA.fields_dict["resourceOwnersTypes"].default
        self.allUsers = self.RECORD_SCHEMA.fields_dict["allUsers"].default
        self.allGroups = self.RECORD_SCHEMA.fields_dict["allGroups"].default
        self.roles = self.RECORD_SCHEMA.fields_dict["roles"].default
    
    
    @property
    def users(self) -> Union[None, List[str]]:
        """A specific set of users to apply the policy to (disjunctive)"""
        return self._inner_dict.get('users')  # type: ignore
    
    @users.setter
    def users(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['users'] = value
    
    
    @property
    def groups(self) -> Union[None, List[str]]:
        """A specific set of groups to apply the policy to (disjunctive)"""
        return self._inner_dict.get('groups')  # type: ignore
    
    @groups.setter
    def groups(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['groups'] = value
    
    
    @property
    def resourceOwners(self) -> bool:
        """Whether the filter should return true for owners of a particular resource.
    Only applies to policies of type 'Metadata', which have a resource associated with them."""
        return self._inner_dict.get('resourceOwners')  # type: ignore
    
    @resourceOwners.setter
    def resourceOwners(self, value: bool) -> None:
        self._inner_dict['resourceOwners'] = value
    
    
    @property
    def resourceOwnersTypes(self) -> Union[None, List[str]]:
        """Define type of ownership for the policy"""
        return self._inner_dict.get('resourceOwnersTypes')  # type: ignore
    
    @resourceOwnersTypes.setter
    def resourceOwnersTypes(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['resourceOwnersTypes'] = value
    
    
    @property
    def allUsers(self) -> bool:
        """Whether the filter should apply to all users."""
        return self._inner_dict.get('allUsers')  # type: ignore
    
    @allUsers.setter
    def allUsers(self, value: bool) -> None:
        self._inner_dict['allUsers'] = value
    
    
    @property
    def allGroups(self) -> bool:
        """Whether the filter should apply to all groups."""
        return self._inner_dict.get('allGroups')  # type: ignore
    
    @allGroups.setter
    def allGroups(self, value: bool) -> None:
        self._inner_dict['allGroups'] = value
    
    
    @property
    def roles(self) -> Union[None, List[str]]:
        """A specific set of roles to apply the policy to (disjunctive)."""
        return self._inner_dict.get('roles')  # type: ignore
    
    @roles.setter
    def roles(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['roles'] = value
    
    
class DataHubPolicyInfoClass(_Aspect):
    """Information about a DataHub (UI) access policy."""


    ASPECT_NAME = 'dataHubPolicyInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.policy.DataHubPolicyInfo")

    def __init__(self,
        displayName: str,
        description: str,
        type: str,
        state: str,
        privileges: List[str],
        actors: "DataHubActorFilterClass",
        resources: Union[None, "DataHubResourceFilterClass"]=None,
        editable: Optional[bool]=None,
        lastUpdatedTimestamp: Union[None, int]=None,
    ):
        super().__init__()
        
        self.displayName = displayName
        self.description = description
        self.type = type
        self.state = state
        self.resources = resources
        self.privileges = privileges
        self.actors = actors
        if editable is None:
            # default: True
            self.editable = self.RECORD_SCHEMA.fields_dict["editable"].default
        else:
            self.editable = editable
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
    
    def _restore_defaults(self) -> None:
        self.displayName = str()
        self.description = str()
        self.type = str()
        self.state = str()
        self.resources = self.RECORD_SCHEMA.fields_dict["resources"].default
        self.privileges = list()
        self.actors = DataHubActorFilterClass._construct_with_defaults()
        self.editable = self.RECORD_SCHEMA.fields_dict["editable"].default
        self.lastUpdatedTimestamp = self.RECORD_SCHEMA.fields_dict["lastUpdatedTimestamp"].default
    
    
    @property
    def displayName(self) -> str:
        """Display name of the Policy"""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: str) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def description(self) -> str:
        """Description of the Policy"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: str) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def type(self) -> str:
        """The type of policy"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def state(self) -> str:
        """The state of policy, ACTIVE or INACTIVE"""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: str) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def resources(self) -> Union[None, "DataHubResourceFilterClass"]:
        """The resource that the policy applies to. Not required for some 'Platform' privileges."""
        return self._inner_dict.get('resources')  # type: ignore
    
    @resources.setter
    def resources(self, value: Union[None, "DataHubResourceFilterClass"]) -> None:
        self._inner_dict['resources'] = value
    
    
    @property
    def privileges(self) -> List[str]:
        """The privileges that the policy grants."""
        return self._inner_dict.get('privileges')  # type: ignore
    
    @privileges.setter
    def privileges(self, value: List[str]) -> None:
        self._inner_dict['privileges'] = value
    
    
    @property
    def actors(self) -> "DataHubActorFilterClass":
        """The actors that the policy applies to."""
        return self._inner_dict.get('actors')  # type: ignore
    
    @actors.setter
    def actors(self, value: "DataHubActorFilterClass") -> None:
        self._inner_dict['actors'] = value
    
    
    @property
    def editable(self) -> bool:
        """Whether the policy should be editable via the UI"""
        return self._inner_dict.get('editable')  # type: ignore
    
    @editable.setter
    def editable(self, value: bool) -> None:
        self._inner_dict['editable'] = value
    
    
    @property
    def lastUpdatedTimestamp(self) -> Union[None, int]:
        """Timestamp when the policy was last updated"""
        return self._inner_dict.get('lastUpdatedTimestamp')  # type: ignore
    
    @lastUpdatedTimestamp.setter
    def lastUpdatedTimestamp(self, value: Union[None, int]) -> None:
        self._inner_dict['lastUpdatedTimestamp'] = value
    
    
class DataHubResourceFilterClass(DictWrapper):
    """Information used to filter DataHub resource."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.policy.DataHubResourceFilter")
    def __init__(self,
        type: Union[None, str]=None,
        resources: Union[None, List[str]]=None,
        allResources: Optional[bool]=None,
        filter: Union[None, "PolicyMatchFilterClass"]=None,
        privilegeConstraints: Union[None, "PolicyMatchFilterClass"]=None,
    ):
        super().__init__()
        
        self.type = type
        self.resources = resources
        if allResources is None:
            # default: False
            self.allResources = self.RECORD_SCHEMA.fields_dict["allResources"].default
        else:
            self.allResources = allResources
        self.filter = filter
        self.privilegeConstraints = privilegeConstraints
    
    def _restore_defaults(self) -> None:
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        self.resources = self.RECORD_SCHEMA.fields_dict["resources"].default
        self.allResources = self.RECORD_SCHEMA.fields_dict["allResources"].default
        self.filter = self.RECORD_SCHEMA.fields_dict["filter"].default
        self.privilegeConstraints = self.RECORD_SCHEMA.fields_dict["privilegeConstraints"].default
    
    
    @property
    def type(self) -> Union[None, str]:
        """The type of resource that the policy applies to. This will most often be a data asset entity name, for
    example 'dataset'. It is not strictly required because in the future we will want to support filtering a resource
    by domain, as well."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[None, str]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def resources(self) -> Union[None, List[str]]:
        """A specific set of resources to apply the policy to, e.g. asset urns"""
        return self._inner_dict.get('resources')  # type: ignore
    
    @resources.setter
    def resources(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['resources'] = value
    
    
    @property
    def allResources(self) -> bool:
        """Whether the policy should be applied to all assets matching the filter."""
        return self._inner_dict.get('allResources')  # type: ignore
    
    @allResources.setter
    def allResources(self, value: bool) -> None:
        self._inner_dict['allResources'] = value
    
    
    @property
    def filter(self) -> Union[None, "PolicyMatchFilterClass"]:
        """Filter to apply privileges to"""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: Union[None, "PolicyMatchFilterClass"]) -> None:
        self._inner_dict['filter'] = value
    
    
    @property
    def privilegeConstraints(self) -> Union[None, "PolicyMatchFilterClass"]:
        """Constraints around what sub-resources operations are allowed to modify, i.e. NOT_EQUALS - cannot modify a particular defined tag, EQUALS - can only modify a particular defined tag, STARTS_WITH - can only modify a tag starting with xyz"""
        return self._inner_dict.get('privilegeConstraints')  # type: ignore
    
    @privilegeConstraints.setter
    def privilegeConstraints(self, value: Union[None, "PolicyMatchFilterClass"]) -> None:
        self._inner_dict['privilegeConstraints'] = value
    
    
class DataHubRoleInfoClass(_Aspect):
    """Information about a DataHub Role."""


    ASPECT_NAME = 'dataHubRoleInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.policy.DataHubRoleInfo")

    def __init__(self,
        name: str,
        description: str,
        editable: Optional[bool]=None,
    ):
        super().__init__()
        
        self.name = name
        self.description = description
        if editable is None:
            # default: False
            self.editable = self.RECORD_SCHEMA.fields_dict["editable"].default
        else:
            self.editable = editable
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.description = str()
        self.editable = self.RECORD_SCHEMA.fields_dict["editable"].default
    
    
    @property
    def name(self) -> str:
        """Name of the Role"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> str:
        """Description of the Role"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: str) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def editable(self) -> bool:
        """Whether the role should be editable via the UI"""
        return self._inner_dict.get('editable')  # type: ignore
    
    @editable.setter
    def editable(self, value: bool) -> None:
        self._inner_dict['editable'] = value
    
    
class PolicyMatchConditionClass(object):
    """The matching condition in a filter criterion"""
    
    EQUALS = "EQUALS"
    """Whether the field matches the value"""
    
    STARTS_WITH = "STARTS_WITH"
    """Whether the field value starts with the value"""
    
    NOT_EQUALS = "NOT_EQUALS"
    """Whether the field does not match the value"""
    
    
    
class PolicyMatchCriterionClass(DictWrapper):
    """A criterion for matching a field with given value"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.policy.PolicyMatchCriterion")
    def __init__(self,
        field: str,
        values: List[str],
        condition: Optional[Union[str, "PolicyMatchConditionClass"]]=None,
    ):
        super().__init__()
        
        self.field = field
        self.values = values
        if condition is None:
            # default: 'EQUALS'
            self.condition = self.RECORD_SCHEMA.fields_dict["condition"].default
        else:
            self.condition = condition
    
    def _restore_defaults(self) -> None:
        self.field = str()
        self.values = list()
        self.condition = self.RECORD_SCHEMA.fields_dict["condition"].default
    
    
    @property
    def field(self) -> str:
        """The name of the field that the criterion refers to"""
        return self._inner_dict.get('field')  # type: ignore
    
    @field.setter
    def field(self, value: str) -> None:
        self._inner_dict['field'] = value
    
    
    @property
    def values(self) -> List[str]:
        """Values. Matches criterion if any one of the values matches condition (OR-relationship)"""
        return self._inner_dict.get('values')  # type: ignore
    
    @values.setter
    def values(self, value: List[str]) -> None:
        self._inner_dict['values'] = value
    
    
    @property
    def condition(self) -> Union[str, "PolicyMatchConditionClass"]:
        """The condition for the criterion"""
        return self._inner_dict.get('condition')  # type: ignore
    
    @condition.setter
    def condition(self, value: Union[str, "PolicyMatchConditionClass"]) -> None:
        self._inner_dict['condition'] = value
    
    
class PolicyMatchFilterClass(DictWrapper):
    """The filter for specifying the resource or actor to apply privileges to"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.policy.PolicyMatchFilter")
    def __init__(self,
        criteria: List["PolicyMatchCriterionClass"],
    ):
        super().__init__()
        
        self.criteria = criteria
    
    def _restore_defaults(self) -> None:
        self.criteria = list()
    
    
    @property
    def criteria(self) -> List["PolicyMatchCriterionClass"]:
        """A list of criteria to apply conjunctively (so all criteria must pass)"""
        return self._inner_dict.get('criteria')  # type: ignore
    
    @criteria.setter
    def criteria(self, value: List["PolicyMatchCriterionClass"]) -> None:
        self._inner_dict['criteria'] = value
    
    
class PostContentClass(DictWrapper):
    """Content stored inside a Post."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.post.PostContent")
    def __init__(self,
        title: str,
        type: Union[str, "PostContentTypeClass"],
        description: Union[None, str]=None,
        link: Union[None, str]=None,
        media: Union[None, "MediaClass"]=None,
    ):
        super().__init__()
        
        self.title = title
        self.type = type
        self.description = description
        self.link = link
        self.media = media
    
    def _restore_defaults(self) -> None:
        self.title = str()
        self.type = PostContentTypeClass.TEXT
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.link = self.RECORD_SCHEMA.fields_dict["link"].default
        self.media = self.RECORD_SCHEMA.fields_dict["media"].default
    
    
    @property
    def title(self) -> str:
        """Title of the post."""
        return self._inner_dict.get('title')  # type: ignore
    
    @title.setter
    def title(self, value: str) -> None:
        self._inner_dict['title'] = value
    
    
    @property
    def type(self) -> Union[str, "PostContentTypeClass"]:
        """Type of content held in the post."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "PostContentTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Optional description of the post."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def link(self) -> Union[None, str]:
        """Optional link that the post is associated with."""
        return self._inner_dict.get('link')  # type: ignore
    
    @link.setter
    def link(self, value: Union[None, str]) -> None:
        self._inner_dict['link'] = value
    
    
    @property
    def media(self) -> Union[None, "MediaClass"]:
        """Optional media that the post is storing"""
        return self._inner_dict.get('media')  # type: ignore
    
    @media.setter
    def media(self, value: Union[None, "MediaClass"]) -> None:
        self._inner_dict['media'] = value
    
    
class PostContentTypeClass(object):
    """Enum defining the type of content held in a Post."""
    
    TEXT = "TEXT"
    """Text content"""
    
    LINK = "LINK"
    """Link content"""
    
    
    
class PostInfoClass(_Aspect):
    """Information about a DataHub Post."""


    ASPECT_NAME = 'postInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.post.PostInfo")

    def __init__(self,
        type: Union[str, "PostTypeClass"],
        content: "PostContentClass",
        created: int,
        lastModified: int,
        auditStamp: Union[None, "AuditStampClass"]=None,
        target: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.content = content
        self.created = created
        self.lastModified = lastModified
        self.auditStamp = auditStamp
        self.target = target
    
    def _restore_defaults(self) -> None:
        self.type = PostTypeClass.HOME_PAGE_ANNOUNCEMENT
        self.content = PostContentClass._construct_with_defaults()
        self.created = int()
        self.lastModified = int()
        self.auditStamp = self.RECORD_SCHEMA.fields_dict["auditStamp"].default
        self.target = self.RECORD_SCHEMA.fields_dict["target"].default
    
    
    @property
    def type(self) -> Union[str, "PostTypeClass"]:
        """Type of the Post."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "PostTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def content(self) -> "PostContentClass":
        """Content stored in the post."""
        return self._inner_dict.get('content')  # type: ignore
    
    @content.setter
    def content(self, value: "PostContentClass") -> None:
        self._inner_dict['content'] = value
    
    
    @property
    def created(self) -> int:
        """The time at which the post was initially created"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: int) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> int:
        """The time at which the post was last modified"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: int) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def auditStamp(self) -> Union[None, "AuditStampClass"]:
        """The audit stamp at which the request was last updated"""
        return self._inner_dict.get('auditStamp')  # type: ignore
    
    @auditStamp.setter
    def auditStamp(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['auditStamp'] = value
    
    
    @property
    def target(self) -> Union[None, str]:
        """Optional Entity URN that the post is associated with."""
        return self._inner_dict.get('target')  # type: ignore
    
    @target.setter
    def target(self, value: Union[None, str]) -> None:
        self._inner_dict['target'] = value
    
    
class PostTypeClass(object):
    """Enum defining types of Posts."""
    
    HOME_PAGE_ANNOUNCEMENT = "HOME_PAGE_ANNOUNCEMENT"
    """The Post is an Home Page announcement."""
    
    ENTITY_ANNOUNCEMENT = "ENTITY_ANNOUNCEMENT"
    """The Post is an Entity level announcement."""
    
    
    
class QueryLanguageClass(object):
    # No docs available.
    
    SQL = "SQL"
    """A SQL Query"""
    
    UNKNOWN = "UNKNOWN"
    """Unknown query language"""
    
    
    
class QueryPropertiesClass(_Aspect):
    """Information about a Query against one or more data assets (e.g. Tables or Views)."""


    ASPECT_NAME = 'queryProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.query.QueryProperties")

    def __init__(self,
        statement: "QueryStatementClass",
        source: Union[str, "QuerySourceClass"],
        created: "AuditStampClass",
        lastModified: "AuditStampClass",
        customProperties: Optional[Dict[str, str]]=None,
        name: Union[None, str]=None,
        description: Union[None, str]=None,
        origin: Union[None, str]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.statement = statement
        self.source = source
        self.name = name
        self.description = description
        self.created = created
        self.lastModified = lastModified
        self.origin = origin
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.statement = QueryStatementClass._construct_with_defaults()
        self.source = QuerySourceClass.MANUAL
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.created = AuditStampClass._construct_with_defaults()
        self.lastModified = AuditStampClass._construct_with_defaults()
        self.origin = self.RECORD_SCHEMA.fields_dict["origin"].default
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def statement(self) -> "QueryStatementClass":
        """The Query Statement."""
        return self._inner_dict.get('statement')  # type: ignore
    
    @statement.setter
    def statement(self, value: "QueryStatementClass") -> None:
        self._inner_dict['statement'] = value
    
    
    @property
    def source(self) -> Union[str, "QuerySourceClass"]:
        """The source of the Query"""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[str, "QuerySourceClass"]) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """Optional display name to identify the query."""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """The Query description."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp capturing the time and actor who created the Query."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp capturing the time and actor who last modified the Query."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def origin(self) -> Union[None, str]:
        """The origin of the Query.
    This is the source of the Query (e.g. a View, Stored Procedure, dbt Model, etc.) that the Query was created from."""
        return self._inner_dict.get('origin')  # type: ignore
    
    @origin.setter
    def origin(self, value: Union[None, str]) -> None:
        self._inner_dict['origin'] = value
    
    
class QuerySourceClass(object):
    # No docs available.
    
    MANUAL = "MANUAL"
    """The query was entered manually by a user (via the UI)."""
    
    SYSTEM = "SYSTEM"
    """The query was discovered by a crawler."""
    
    
    
class QueryStatementClass(DictWrapper):
    """A query statement against one or more data assets."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.query.QueryStatement")
    def __init__(self,
        value: str,
        language: Optional[Union[str, "QueryLanguageClass"]]=None,
    ):
        super().__init__()
        
        self.value = value
        if language is None:
            # default: 'SQL'
            self.language = self.RECORD_SCHEMA.fields_dict["language"].default
        else:
            self.language = language
    
    def _restore_defaults(self) -> None:
        self.value = str()
        self.language = self.RECORD_SCHEMA.fields_dict["language"].default
    
    
    @property
    def value(self) -> str:
        """The query text"""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: str) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def language(self) -> Union[str, "QueryLanguageClass"]:
        """The language of the Query, e.g. SQL."""
        return self._inner_dict.get('language')  # type: ignore
    
    @language.setter
    def language(self, value: Union[str, "QueryLanguageClass"]) -> None:
        self._inner_dict['language'] = value
    
    
class QuerySubjectClass(DictWrapper):
    """A single subject of a particular query.
    In the future, we may evolve this model to include richer details
    about the Query Subject in relation to the query."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.query.QuerySubject")
    def __init__(self,
        entity: str,
    ):
        super().__init__()
        
        self.entity = entity
    
    def _restore_defaults(self) -> None:
        self.entity = str()
    
    
    @property
    def entity(self) -> str:
        """An entity which is the subject of a query."""
        return self._inner_dict.get('entity')  # type: ignore
    
    @entity.setter
    def entity(self, value: str) -> None:
        self._inner_dict['entity'] = value
    
    
class QuerySubjectsClass(_Aspect):
    """Information about the subjects of a particular Query, i.e. the assets
    being queried."""


    ASPECT_NAME = 'querySubjects'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.query.QuerySubjects")

    def __init__(self,
        subjects: List["QuerySubjectClass"],
    ):
        super().__init__()
        
        self.subjects = subjects
    
    def _restore_defaults(self) -> None:
        self.subjects = list()
    
    
    @property
    def subjects(self) -> List["QuerySubjectClass"]:
        """One or more subjects of the query.
    
    In single-asset queries (e.g. table select), this will contain the Table reference
    and optionally schema field references.
    
    In multi-asset queries (e.g. table joins), this may contain multiple Table references
    and optionally schema field references."""
        return self._inner_dict.get('subjects')  # type: ignore
    
    @subjects.setter
    def subjects(self, value: List["QuerySubjectClass"]) -> None:
        self._inner_dict['subjects'] = value
    
    
class QueryUsageFeaturesClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'queryUsageFeatures'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.query.QueryUsageFeatures")

    def __init__(self,
        queryCountLast30Days: Union[None, int]=None,
        queryCountTotal: Union[None, int]=None,
        topUsersLast30Days: Union[None, List[str]]=None,
        queryCostLast30Days: Union[None, float]=None,
        runsPercentileLast30days: Union[None, int]=None,
        lastExecutedAt: Union[None, int]=None,
    ):
        super().__init__()
        
        self.queryCountLast30Days = queryCountLast30Days
        self.queryCountTotal = queryCountTotal
        self.topUsersLast30Days = topUsersLast30Days
        self.queryCostLast30Days = queryCostLast30Days
        self.runsPercentileLast30days = runsPercentileLast30days
        self.lastExecutedAt = lastExecutedAt
    
    def _restore_defaults(self) -> None:
        self.queryCountLast30Days = self.RECORD_SCHEMA.fields_dict["queryCountLast30Days"].default
        self.queryCountTotal = self.RECORD_SCHEMA.fields_dict["queryCountTotal"].default
        self.topUsersLast30Days = self.RECORD_SCHEMA.fields_dict["topUsersLast30Days"].default
        self.queryCostLast30Days = self.RECORD_SCHEMA.fields_dict["queryCostLast30Days"].default
        self.runsPercentileLast30days = self.RECORD_SCHEMA.fields_dict["runsPercentileLast30days"].default
        self.lastExecutedAt = self.RECORD_SCHEMA.fields_dict["lastExecutedAt"].default
    
    
    @property
    def queryCountLast30Days(self) -> Union[None, int]:
        """Number of times this query was executed in the last 30 days"""
        return self._inner_dict.get('queryCountLast30Days')  # type: ignore
    
    @queryCountLast30Days.setter
    def queryCountLast30Days(self, value: Union[None, int]) -> None:
        self._inner_dict['queryCountLast30Days'] = value
    
    
    @property
    def queryCountTotal(self) -> Union[None, int]:
        """Query count total 
    Total number of executions of this query"""
        return self._inner_dict.get('queryCountTotal')  # type: ignore
    
    @queryCountTotal.setter
    def queryCountTotal(self, value: Union[None, int]) -> None:
        self._inner_dict['queryCountTotal'] = value
    
    
    @property
    def topUsersLast30Days(self) -> Union[None, List[str]]:
        """Top users of this query in the last 30 days"""
        return self._inner_dict.get('topUsersLast30Days')  # type: ignore
    
    @topUsersLast30Days.setter
    def topUsersLast30Days(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['topUsersLast30Days'] = value
    
    
    @property
    def queryCostLast30Days(self) -> Union[None, float]:
        """Total cost of this query in the last 30 days"""
        return self._inner_dict.get('queryCostLast30Days')  # type: ignore
    
    @queryCostLast30Days.setter
    def queryCostLast30Days(self, value: Union[None, float]) -> None:
        self._inner_dict['queryCostLast30Days'] = value
    
    
    @property
    def runsPercentileLast30days(self) -> Union[None, int]:
        """The percentile rank of this query based on runs last 30 days"""
        return self._inner_dict.get('runsPercentileLast30days')  # type: ignore
    
    @runsPercentileLast30days.setter
    def runsPercentileLast30days(self, value: Union[None, int]) -> None:
        self._inner_dict['runsPercentileLast30days'] = value
    
    
    @property
    def lastExecutedAt(self) -> Union[None, int]:
        """Last time this query was executed"""
        return self._inner_dict.get('lastExecutedAt')  # type: ignore
    
    @lastExecutedAt.setter
    def lastExecutedAt(self, value: Union[None, int]) -> None:
        self._inner_dict['lastExecutedAt'] = value
    
    
class QueryUsageStatisticsClass(_Aspect):
    """Stats corresponding to dataset's usage."""


    ASPECT_NAME = 'queryUsageStatistics'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.query.QueryUsageStatistics")

    def __init__(self,
        timestampMillis: int,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
        queryCount: Union[None, int]=None,
        queryCost: Union[None, float]=None,
        lastExecutedAt: Union[None, int]=None,
        uniqueUserCount: Union[None, int]=None,
        userCounts: Union[None, List["DatasetUserUsageCountsClass"]]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
        self.queryCount = queryCount
        self.queryCost = queryCost
        self.lastExecutedAt = lastExecutedAt
        self.uniqueUserCount = uniqueUserCount
        self.userCounts = userCounts
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
        self.queryCount = self.RECORD_SCHEMA.fields_dict["queryCount"].default
        self.queryCost = self.RECORD_SCHEMA.fields_dict["queryCost"].default
        self.lastExecutedAt = self.RECORD_SCHEMA.fields_dict["lastExecutedAt"].default
        self.uniqueUserCount = self.RECORD_SCHEMA.fields_dict["uniqueUserCount"].default
        self.userCounts = self.RECORD_SCHEMA.fields_dict["userCounts"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
    @property
    def queryCount(self) -> Union[None, int]:
        """Total query count in this bucket"""
        return self._inner_dict.get('queryCount')  # type: ignore
    
    @queryCount.setter
    def queryCount(self, value: Union[None, int]) -> None:
        self._inner_dict['queryCount'] = value
    
    
    @property
    def queryCost(self) -> Union[None, float]:
        """Query cost for this query and bucket"""
        return self._inner_dict.get('queryCost')  # type: ignore
    
    @queryCost.setter
    def queryCost(self, value: Union[None, float]) -> None:
        self._inner_dict['queryCost'] = value
    
    
    @property
    def lastExecutedAt(self) -> Union[None, int]:
        """Last executed timestamp"""
        return self._inner_dict.get('lastExecutedAt')  # type: ignore
    
    @lastExecutedAt.setter
    def lastExecutedAt(self, value: Union[None, int]) -> None:
        self._inner_dict['lastExecutedAt'] = value
    
    
    @property
    def uniqueUserCount(self) -> Union[None, int]:
        """Unique user count"""
        return self._inner_dict.get('uniqueUserCount')  # type: ignore
    
    @uniqueUserCount.setter
    def uniqueUserCount(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueUserCount'] = value
    
    
    @property
    def userCounts(self) -> Union[None, List["DatasetUserUsageCountsClass"]]:
        """Users within this bucket, with frequency counts"""
        return self._inner_dict.get('userCounts')  # type: ignore
    
    @userCounts.setter
    def userCounts(self, value: Union[None, List["DatasetUserUsageCountsClass"]]) -> None:
        self._inner_dict['userCounts'] = value
    
    
class DataHubRetentionConfigClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'dataHubRetentionConfig'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.retention.DataHubRetentionConfig")

    def __init__(self,
        retention: "RetentionClass",
    ):
        super().__init__()
        
        self.retention = retention
    
    def _restore_defaults(self) -> None:
        self.retention = RetentionClass._construct_with_defaults()
    
    
    @property
    def retention(self) -> "RetentionClass":
        # No docs available.
        return self._inner_dict.get('retention')  # type: ignore
    
    @retention.setter
    def retention(self, value: "RetentionClass") -> None:
        self._inner_dict['retention'] = value
    
    
class RetentionClass(DictWrapper):
    """Base class that encapsulates different retention policies.
    Only one of the fields should be set"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.retention.Retention")
    def __init__(self,
        version: Union[None, "VersionBasedRetentionClass"]=None,
        time: Union[None, "TimeBasedRetentionClass"]=None,
    ):
        super().__init__()
        
        self.version = version
        self.time = time
    
    def _restore_defaults(self) -> None:
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
        self.time = self.RECORD_SCHEMA.fields_dict["time"].default
    
    
    @property
    def version(self) -> Union[None, "VersionBasedRetentionClass"]:
        # No docs available.
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, "VersionBasedRetentionClass"]) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def time(self) -> Union[None, "TimeBasedRetentionClass"]:
        # No docs available.
        return self._inner_dict.get('time')  # type: ignore
    
    @time.setter
    def time(self, value: Union[None, "TimeBasedRetentionClass"]) -> None:
        self._inner_dict['time'] = value
    
    
class TimeBasedRetentionClass(DictWrapper):
    """Keep records that are less than X seconds old"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.retention.TimeBasedRetention")
    def __init__(self,
        maxAgeInSeconds: int,
    ):
        super().__init__()
        
        self.maxAgeInSeconds = maxAgeInSeconds
    
    def _restore_defaults(self) -> None:
        self.maxAgeInSeconds = int()
    
    
    @property
    def maxAgeInSeconds(self) -> int:
        # No docs available.
        return self._inner_dict.get('maxAgeInSeconds')  # type: ignore
    
    @maxAgeInSeconds.setter
    def maxAgeInSeconds(self, value: int) -> None:
        self._inner_dict['maxAgeInSeconds'] = value
    
    
class VersionBasedRetentionClass(DictWrapper):
    """Keep max N latest records"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.retention.VersionBasedRetention")
    def __init__(self,
        maxVersions: int,
    ):
        super().__init__()
        
        self.maxVersions = maxVersions
    
    def _restore_defaults(self) -> None:
        self.maxVersions = int()
    
    
    @property
    def maxVersions(self) -> int:
        # No docs available.
        return self._inner_dict.get('maxVersions')  # type: ignore
    
    @maxVersions.setter
    def maxVersions(self, value: int) -> None:
        self._inner_dict['maxVersions'] = value
    
    
class ActorsClass(_Aspect):
    """Provisioned users and groups of a role"""


    ASPECT_NAME = 'actors'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.role.Actors")

    def __init__(self,
        users: Union[None, List["RoleUserClass"]]=None,
        groups: Union[None, List["RoleGroupClass"]]=None,
    ):
        super().__init__()
        
        self.users = users
        self.groups = groups
    
    def _restore_defaults(self) -> None:
        self.users = self.RECORD_SCHEMA.fields_dict["users"].default
        self.groups = self.RECORD_SCHEMA.fields_dict["groups"].default
    
    
    @property
    def users(self) -> Union[None, List["RoleUserClass"]]:
        """List of provisioned users of a role"""
        return self._inner_dict.get('users')  # type: ignore
    
    @users.setter
    def users(self, value: Union[None, List["RoleUserClass"]]) -> None:
        self._inner_dict['users'] = value
    
    
    @property
    def groups(self) -> Union[None, List["RoleGroupClass"]]:
        """List of provisioned groups of a role"""
        return self._inner_dict.get('groups')  # type: ignore
    
    @groups.setter
    def groups(self, value: Union[None, List["RoleGroupClass"]]) -> None:
        self._inner_dict['groups'] = value
    
    
class RoleGroupClass(DictWrapper):
    """Provisioned groups of a role"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.role.RoleGroup")
    def __init__(self,
        group: str,
    ):
        super().__init__()
        
        self.group = group
    
    def _restore_defaults(self) -> None:
        self.group = str()
    
    
    @property
    def group(self) -> str:
        """Link provisioned corp group for a role"""
        return self._inner_dict.get('group')  # type: ignore
    
    @group.setter
    def group(self, value: str) -> None:
        self._inner_dict['group'] = value
    
    
class RolePropertiesClass(_Aspect):
    """Information about a ExternalRoleProperties"""


    ASPECT_NAME = 'roleProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.role.RoleProperties")

    def __init__(self,
        name: str,
        type: str,
        description: Union[None, str]=None,
        requestUrl: Union[None, str]=None,
        created: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.name = name
        self.description = description
        self.type = type
        self.requestUrl = requestUrl
        self.created = created
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.type = str()
        self.requestUrl = self.RECORD_SCHEMA.fields_dict["requestUrl"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
    
    
    @property
    def name(self) -> str:
        """Display name of the IAM Role in the external system"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the IAM Role"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def type(self) -> str:
        """Can be READ, ADMIN, WRITE"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def requestUrl(self) -> Union[None, str]:
        """Link to access external access management"""
        return self._inner_dict.get('requestUrl')  # type: ignore
    
    @requestUrl.setter
    def requestUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['requestUrl'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
class RoleUserClass(DictWrapper):
    """Provisioned users of a role"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.role.RoleUser")
    def __init__(self,
        user: str,
    ):
        super().__init__()
        
        self.user = user
    
    def _restore_defaults(self) -> None:
        self.user = str()
    
    
    @property
    def user(self) -> str:
        """Link provisioned corp user for a role"""
        return self._inner_dict.get('user')  # type: ignore
    
    @user.setter
    def user(self, value: str) -> None:
        self._inner_dict['user'] = value
    
    
class ArrayTypeClass(DictWrapper):
    """Array field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.ArrayType")
    def __init__(self,
        nestedType: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.nestedType = nestedType
    
    def _restore_defaults(self) -> None:
        self.nestedType = self.RECORD_SCHEMA.fields_dict["nestedType"].default
    
    
    @property
    def nestedType(self) -> Union[None, List[str]]:
        """List of types this array holds."""
        return self._inner_dict.get('nestedType')  # type: ignore
    
    @nestedType.setter
    def nestedType(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['nestedType'] = value
    
    
class BinaryJsonSchemaClass(DictWrapper):
    """Schema text of binary JSON schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.BinaryJsonSchema")
    def __init__(self,
        schema: str,
    ):
        super().__init__()
        
        self.schema = schema
    
    def _restore_defaults(self) -> None:
        self.schema = str()
    
    
    @property
    def schema(self) -> str:
        """The native schema text for binary JSON file format."""
        return self._inner_dict.get('schema')  # type: ignore
    
    @schema.setter
    def schema(self, value: str) -> None:
        self._inner_dict['schema'] = value
    
    
class BooleanTypeClass(DictWrapper):
    """Boolean field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.BooleanType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class BytesTypeClass(DictWrapper):
    """Bytes field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.BytesType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class DatasetFieldForeignKeyClass(DictWrapper):
    """For non-urn based foregin keys."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.DatasetFieldForeignKey")
    def __init__(self,
        parentDataset: str,
        currentFieldPaths: List[str],
        parentField: str,
    ):
        super().__init__()
        
        self.parentDataset = parentDataset
        self.currentFieldPaths = currentFieldPaths
        self.parentField = parentField
    
    def _restore_defaults(self) -> None:
        self.parentDataset = str()
        self.currentFieldPaths = list()
        self.parentField = str()
    
    
    @property
    def parentDataset(self) -> str:
        """dataset that stores the resource."""
        return self._inner_dict.get('parentDataset')  # type: ignore
    
    @parentDataset.setter
    def parentDataset(self, value: str) -> None:
        self._inner_dict['parentDataset'] = value
    
    
    @property
    def currentFieldPaths(self) -> List[str]:
        """List of fields in hosting(current) SchemaMetadata that conform a foreign key. List can contain a single entry or multiple entries if several entries in hosting schema conform a foreign key in a single parent dataset."""
        return self._inner_dict.get('currentFieldPaths')  # type: ignore
    
    @currentFieldPaths.setter
    def currentFieldPaths(self, value: List[str]) -> None:
        self._inner_dict['currentFieldPaths'] = value
    
    
    @property
    def parentField(self) -> str:
        """SchemaField@fieldPath that uniquely identify field in parent dataset that this field references."""
        return self._inner_dict.get('parentField')  # type: ignore
    
    @parentField.setter
    def parentField(self, value: str) -> None:
        self._inner_dict['parentField'] = value
    
    
class DateTypeClass(DictWrapper):
    """Date field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.DateType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class EditableSchemaFieldInfoClass(DictWrapper):
    """SchemaField to describe metadata related to dataset schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.EditableSchemaFieldInfo")
    def __init__(self,
        fieldPath: str,
        description: Union[None, str]=None,
        globalTags: Union[None, "GlobalTagsClass"]=None,
        glossaryTerms: Union[None, "GlossaryTermsClass"]=None,
    ):
        super().__init__()
        
        self.fieldPath = fieldPath
        self.description = description
        self.globalTags = globalTags
        self.glossaryTerms = glossaryTerms
    
    def _restore_defaults(self) -> None:
        self.fieldPath = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.globalTags = self.RECORD_SCHEMA.fields_dict["globalTags"].default
        self.glossaryTerms = self.RECORD_SCHEMA.fields_dict["glossaryTerms"].default
    
    
    @property
    def fieldPath(self) -> str:
        """FieldPath uniquely identifying the SchemaField this metadata is associated with"""
        return self._inner_dict.get('fieldPath')  # type: ignore
    
    @fieldPath.setter
    def fieldPath(self, value: str) -> None:
        self._inner_dict['fieldPath'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def globalTags(self) -> Union[None, "GlobalTagsClass"]:
        """Tags associated with the field"""
        return self._inner_dict.get('globalTags')  # type: ignore
    
    @globalTags.setter
    def globalTags(self, value: Union[None, "GlobalTagsClass"]) -> None:
        self._inner_dict['globalTags'] = value
    
    
    @property
    def glossaryTerms(self) -> Union[None, "GlossaryTermsClass"]:
        """Glossary terms associated with the field"""
        return self._inner_dict.get('glossaryTerms')  # type: ignore
    
    @glossaryTerms.setter
    def glossaryTerms(self, value: Union[None, "GlossaryTermsClass"]) -> None:
        self._inner_dict['glossaryTerms'] = value
    
    
class EditableSchemaMetadataClass(_Aspect):
    """EditableSchemaMetadata stores editable changes made to schema metadata. This separates changes made from
    ingestion pipelines and edits in the UI to avoid accidental overwrites of user-provided data by ingestion pipelines."""


    ASPECT_NAME = 'editableSchemaMetadata'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.EditableSchemaMetadata")

    def __init__(self,
        editableSchemaFieldInfo: List["EditableSchemaFieldInfoClass"],
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.editableSchemaFieldInfo = editableSchemaFieldInfo
    
    def _restore_defaults(self) -> None:
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.editableSchemaFieldInfo = list()
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def editableSchemaFieldInfo(self) -> List["EditableSchemaFieldInfoClass"]:
        """Client provided a list of fields from document schema."""
        return self._inner_dict.get('editableSchemaFieldInfo')  # type: ignore
    
    @editableSchemaFieldInfo.setter
    def editableSchemaFieldInfo(self, value: List["EditableSchemaFieldInfoClass"]) -> None:
        self._inner_dict['editableSchemaFieldInfo'] = value
    
    
class EnumTypeClass(DictWrapper):
    """Enum field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.EnumType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class EspressoSchemaClass(DictWrapper):
    """Schema text of an espresso table schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.EspressoSchema")
    def __init__(self,
        documentSchema: str,
        tableSchema: str,
    ):
        super().__init__()
        
        self.documentSchema = documentSchema
        self.tableSchema = tableSchema
    
    def _restore_defaults(self) -> None:
        self.documentSchema = str()
        self.tableSchema = str()
    
    
    @property
    def documentSchema(self) -> str:
        """The native espresso document schema."""
        return self._inner_dict.get('documentSchema')  # type: ignore
    
    @documentSchema.setter
    def documentSchema(self, value: str) -> None:
        self._inner_dict['documentSchema'] = value
    
    
    @property
    def tableSchema(self) -> str:
        """The espresso table schema definition."""
        return self._inner_dict.get('tableSchema')  # type: ignore
    
    @tableSchema.setter
    def tableSchema(self, value: str) -> None:
        self._inner_dict['tableSchema'] = value
    
    
class FixedTypeClass(DictWrapper):
    """Fixed field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.FixedType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class ForeignKeyConstraintClass(DictWrapper):
    """Description of a foreign key constraint in a schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.ForeignKeyConstraint")
    def __init__(self,
        name: str,
        foreignFields: List[str],
        sourceFields: List[str],
        foreignDataset: str,
    ):
        super().__init__()
        
        self.name = name
        self.foreignFields = foreignFields
        self.sourceFields = sourceFields
        self.foreignDataset = foreignDataset
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.foreignFields = list()
        self.sourceFields = list()
        self.foreignDataset = str()
    
    
    @property
    def name(self) -> str:
        """Name of the constraint, likely provided from the source"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def foreignFields(self) -> List[str]:
        """Fields the constraint maps to on the foreign dataset"""
        return self._inner_dict.get('foreignFields')  # type: ignore
    
    @foreignFields.setter
    def foreignFields(self, value: List[str]) -> None:
        self._inner_dict['foreignFields'] = value
    
    
    @property
    def sourceFields(self) -> List[str]:
        """Fields the constraint maps to on the source dataset"""
        return self._inner_dict.get('sourceFields')  # type: ignore
    
    @sourceFields.setter
    def sourceFields(self, value: List[str]) -> None:
        self._inner_dict['sourceFields'] = value
    
    
    @property
    def foreignDataset(self) -> str:
        """Reference to the foreign dataset for ease of lookup"""
        return self._inner_dict.get('foreignDataset')  # type: ignore
    
    @foreignDataset.setter
    def foreignDataset(self, value: str) -> None:
        self._inner_dict['foreignDataset'] = value
    
    
class ForeignKeySpecClass(DictWrapper):
    """Description of a foreign key in a schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.ForeignKeySpec")
    def __init__(self,
        foreignKey: Union["DatasetFieldForeignKeyClass", "UrnForeignKeyClass"],
    ):
        super().__init__()
        
        self.foreignKey = foreignKey
    
    def _restore_defaults(self) -> None:
        self.foreignKey = DatasetFieldForeignKeyClass._construct_with_defaults()
    
    
    @property
    def foreignKey(self) -> Union["DatasetFieldForeignKeyClass", "UrnForeignKeyClass"]:
        """Foreign key definition in metadata schema."""
        return self._inner_dict.get('foreignKey')  # type: ignore
    
    @foreignKey.setter
    def foreignKey(self, value: Union["DatasetFieldForeignKeyClass", "UrnForeignKeyClass"]) -> None:
        self._inner_dict['foreignKey'] = value
    
    
class KafkaSchemaClass(DictWrapper):
    """Schema holder for kafka schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.KafkaSchema")
    def __init__(self,
        documentSchema: str,
        documentSchemaType: Union[None, str]=None,
        keySchema: Union[None, str]=None,
        keySchemaType: Union[None, str]=None,
    ):
        super().__init__()
        
        self.documentSchema = documentSchema
        self.documentSchemaType = documentSchemaType
        self.keySchema = keySchema
        self.keySchemaType = keySchemaType
    
    def _restore_defaults(self) -> None:
        self.documentSchema = str()
        self.documentSchemaType = self.RECORD_SCHEMA.fields_dict["documentSchemaType"].default
        self.keySchema = self.RECORD_SCHEMA.fields_dict["keySchema"].default
        self.keySchemaType = self.RECORD_SCHEMA.fields_dict["keySchemaType"].default
    
    
    @property
    def documentSchema(self) -> str:
        """The native kafka document schema. This is a human readable avro document schema."""
        return self._inner_dict.get('documentSchema')  # type: ignore
    
    @documentSchema.setter
    def documentSchema(self, value: str) -> None:
        self._inner_dict['documentSchema'] = value
    
    
    @property
    def documentSchemaType(self) -> Union[None, str]:
        """The native kafka document schema type. This can be AVRO/PROTOBUF/JSON."""
        return self._inner_dict.get('documentSchemaType')  # type: ignore
    
    @documentSchemaType.setter
    def documentSchemaType(self, value: Union[None, str]) -> None:
        self._inner_dict['documentSchemaType'] = value
    
    
    @property
    def keySchema(self) -> Union[None, str]:
        """The native kafka key schema as retrieved from Schema Registry"""
        return self._inner_dict.get('keySchema')  # type: ignore
    
    @keySchema.setter
    def keySchema(self, value: Union[None, str]) -> None:
        self._inner_dict['keySchema'] = value
    
    
    @property
    def keySchemaType(self) -> Union[None, str]:
        """The native kafka key schema type. This can be AVRO/PROTOBUF/JSON."""
        return self._inner_dict.get('keySchemaType')  # type: ignore
    
    @keySchemaType.setter
    def keySchemaType(self, value: Union[None, str]) -> None:
        self._inner_dict['keySchemaType'] = value
    
    
class KeyValueSchemaClass(DictWrapper):
    """Schema text of a key-value store schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.KeyValueSchema")
    def __init__(self,
        keySchema: str,
        valueSchema: str,
    ):
        super().__init__()
        
        self.keySchema = keySchema
        self.valueSchema = valueSchema
    
    def _restore_defaults(self) -> None:
        self.keySchema = str()
        self.valueSchema = str()
    
    
    @property
    def keySchema(self) -> str:
        """The raw schema for the key in the key-value store."""
        return self._inner_dict.get('keySchema')  # type: ignore
    
    @keySchema.setter
    def keySchema(self, value: str) -> None:
        self._inner_dict['keySchema'] = value
    
    
    @property
    def valueSchema(self) -> str:
        """The raw schema for the value in the key-value store."""
        return self._inner_dict.get('valueSchema')  # type: ignore
    
    @valueSchema.setter
    def valueSchema(self, value: str) -> None:
        self._inner_dict['valueSchema'] = value
    
    
class MapTypeClass(DictWrapper):
    """Map field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.MapType")
    def __init__(self,
        keyType: Union[None, str]=None,
        valueType: Union[None, str]=None,
    ):
        super().__init__()
        
        self.keyType = keyType
        self.valueType = valueType
    
    def _restore_defaults(self) -> None:
        self.keyType = self.RECORD_SCHEMA.fields_dict["keyType"].default
        self.valueType = self.RECORD_SCHEMA.fields_dict["valueType"].default
    
    
    @property
    def keyType(self) -> Union[None, str]:
        """Key type in a map"""
        return self._inner_dict.get('keyType')  # type: ignore
    
    @keyType.setter
    def keyType(self, value: Union[None, str]) -> None:
        self._inner_dict['keyType'] = value
    
    
    @property
    def valueType(self) -> Union[None, str]:
        """Type of the value in a map"""
        return self._inner_dict.get('valueType')  # type: ignore
    
    @valueType.setter
    def valueType(self, value: Union[None, str]) -> None:
        self._inner_dict['valueType'] = value
    
    
class MySqlDDLClass(DictWrapper):
    """Schema holder for MySql data definition language that describes an MySql table."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.MySqlDDL")
    def __init__(self,
        tableSchema: str,
    ):
        super().__init__()
        
        self.tableSchema = tableSchema
    
    def _restore_defaults(self) -> None:
        self.tableSchema = str()
    
    
    @property
    def tableSchema(self) -> str:
        """The native schema in the dataset's platform. This is a human readable (json blob) table schema."""
        return self._inner_dict.get('tableSchema')  # type: ignore
    
    @tableSchema.setter
    def tableSchema(self, value: str) -> None:
        self._inner_dict['tableSchema'] = value
    
    
class NullTypeClass(DictWrapper):
    """Null field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.NullType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class NumberTypeClass(DictWrapper):
    """Number data type: long, integer, short, etc.."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.NumberType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class OracleDDLClass(DictWrapper):
    """Schema holder for oracle data definition language that describes an oracle table."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.OracleDDL")
    def __init__(self,
        tableSchema: str,
    ):
        super().__init__()
        
        self.tableSchema = tableSchema
    
    def _restore_defaults(self) -> None:
        self.tableSchema = str()
    
    
    @property
    def tableSchema(self) -> str:
        """The native schema in the dataset's platform. This is a human readable (json blob) table schema."""
        return self._inner_dict.get('tableSchema')  # type: ignore
    
    @tableSchema.setter
    def tableSchema(self, value: str) -> None:
        self._inner_dict['tableSchema'] = value
    
    
class OrcSchemaClass(DictWrapper):
    """Schema text of an ORC schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.OrcSchema")
    def __init__(self,
        schema: str,
    ):
        super().__init__()
        
        self.schema = schema
    
    def _restore_defaults(self) -> None:
        self.schema = str()
    
    
    @property
    def schema(self) -> str:
        """The native schema for ORC file format."""
        return self._inner_dict.get('schema')  # type: ignore
    
    @schema.setter
    def schema(self, value: str) -> None:
        self._inner_dict['schema'] = value
    
    
class OtherSchemaClass(DictWrapper):
    """Schema holder for undefined schema types."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.OtherSchema")
    def __init__(self,
        rawSchema: str,
    ):
        super().__init__()
        
        self.rawSchema = rawSchema
    
    def _restore_defaults(self) -> None:
        self.rawSchema = str()
    
    
    @property
    def rawSchema(self) -> str:
        """The native schema in the dataset's platform."""
        return self._inner_dict.get('rawSchema')  # type: ignore
    
    @rawSchema.setter
    def rawSchema(self, value: str) -> None:
        self._inner_dict['rawSchema'] = value
    
    
class PrestoDDLClass(DictWrapper):
    """Schema holder for presto data definition language that describes a presto view."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.PrestoDDL")
    def __init__(self,
        rawSchema: str,
    ):
        super().__init__()
        
        self.rawSchema = rawSchema
    
    def _restore_defaults(self) -> None:
        self.rawSchema = str()
    
    
    @property
    def rawSchema(self) -> str:
        """The raw schema in the dataset's platform. This includes the DDL and the columns extracted from DDL."""
        return self._inner_dict.get('rawSchema')  # type: ignore
    
    @rawSchema.setter
    def rawSchema(self, value: str) -> None:
        self._inner_dict['rawSchema'] = value
    
    
class RecordTypeClass(DictWrapper):
    """Record field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.RecordType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class SchemaFieldClass(DictWrapper):
    """SchemaField to describe metadata related to dataset schema."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.SchemaField")
    def __init__(self,
        fieldPath: str,
        type: "SchemaFieldDataTypeClass",
        nativeDataType: str,
        jsonPath: Union[None, str]=None,
        nullable: Optional[bool]=None,
        description: Union[None, str]=None,
        label: Union[None, str]=None,
        created: Union[None, "AuditStampClass"]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
        recursive: Optional[bool]=None,
        globalTags: Union[None, "GlobalTagsClass"]=None,
        glossaryTerms: Union[None, "GlossaryTermsClass"]=None,
        isPartOfKey: Optional[bool]=None,
        isPartitioningKey: Union[None, bool]=None,
        jsonProps: Union[None, str]=None,
    ):
        super().__init__()
        
        self.fieldPath = fieldPath
        self.jsonPath = jsonPath
        if nullable is None:
            # default: False
            self.nullable = self.RECORD_SCHEMA.fields_dict["nullable"].default
        else:
            self.nullable = nullable
        self.description = description
        self.label = label
        self.created = created
        self.lastModified = lastModified
        self.type = type
        self.nativeDataType = nativeDataType
        if recursive is None:
            # default: False
            self.recursive = self.RECORD_SCHEMA.fields_dict["recursive"].default
        else:
            self.recursive = recursive
        self.globalTags = globalTags
        self.glossaryTerms = glossaryTerms
        if isPartOfKey is None:
            # default: False
            self.isPartOfKey = self.RECORD_SCHEMA.fields_dict["isPartOfKey"].default
        else:
            self.isPartOfKey = isPartOfKey
        self.isPartitioningKey = isPartitioningKey
        self.jsonProps = jsonProps
    
    def _restore_defaults(self) -> None:
        self.fieldPath = str()
        self.jsonPath = self.RECORD_SCHEMA.fields_dict["jsonPath"].default
        self.nullable = self.RECORD_SCHEMA.fields_dict["nullable"].default
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.label = self.RECORD_SCHEMA.fields_dict["label"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.type = SchemaFieldDataTypeClass._construct_with_defaults()
        self.nativeDataType = str()
        self.recursive = self.RECORD_SCHEMA.fields_dict["recursive"].default
        self.globalTags = self.RECORD_SCHEMA.fields_dict["globalTags"].default
        self.glossaryTerms = self.RECORD_SCHEMA.fields_dict["glossaryTerms"].default
        self.isPartOfKey = self.RECORD_SCHEMA.fields_dict["isPartOfKey"].default
        self.isPartitioningKey = self.RECORD_SCHEMA.fields_dict["isPartitioningKey"].default
        self.jsonProps = self.RECORD_SCHEMA.fields_dict["jsonProps"].default
    
    
    @property
    def fieldPath(self) -> str:
        """Flattened name of the field. Field is computed from jsonPath field."""
        return self._inner_dict.get('fieldPath')  # type: ignore
    
    @fieldPath.setter
    def fieldPath(self, value: str) -> None:
        self._inner_dict['fieldPath'] = value
    
    
    @property
    def jsonPath(self) -> Union[None, str]:
        """Flattened name of a field in JSON Path notation."""
        return self._inner_dict.get('jsonPath')  # type: ignore
    
    @jsonPath.setter
    def jsonPath(self, value: Union[None, str]) -> None:
        self._inner_dict['jsonPath'] = value
    
    
    @property
    def nullable(self) -> bool:
        """Indicates if this field is optional or nullable"""
        return self._inner_dict.get('nullable')  # type: ignore
    
    @nullable.setter
    def nullable(self, value: bool) -> None:
        self._inner_dict['nullable'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def label(self) -> Union[None, str]:
        """Label of the field. Provides a more human-readable name for the field than field path. Some sources will
    provide this metadata but not all sources have the concept of a label. If just one string is associated with
    a field in a source, that is most likely a description.
    
    Note that this field is deprecated and is not surfaced in the UI."""
        return self._inner_dict.get('label')  # type: ignore
    
    @label.setter
    def label(self, value: Union[None, str]) -> None:
        self._inner_dict['label'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the creation of this schema field."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the last modification of this schema field."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def type(self) -> "SchemaFieldDataTypeClass":
        """Platform independent field type of the field."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: "SchemaFieldDataTypeClass") -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def nativeDataType(self) -> str:
        """The native type of the field in the dataset's platform as declared by platform schema."""
        return self._inner_dict.get('nativeDataType')  # type: ignore
    
    @nativeDataType.setter
    def nativeDataType(self, value: str) -> None:
        self._inner_dict['nativeDataType'] = value
    
    
    @property
    def recursive(self) -> bool:
        """There are use cases when a field in type B references type A. A field in A references field of type B. In such cases, we will mark the first field as recursive."""
        return self._inner_dict.get('recursive')  # type: ignore
    
    @recursive.setter
    def recursive(self, value: bool) -> None:
        self._inner_dict['recursive'] = value
    
    
    @property
    def globalTags(self) -> Union[None, "GlobalTagsClass"]:
        """Tags associated with the field"""
        return self._inner_dict.get('globalTags')  # type: ignore
    
    @globalTags.setter
    def globalTags(self, value: Union[None, "GlobalTagsClass"]) -> None:
        self._inner_dict['globalTags'] = value
    
    
    @property
    def glossaryTerms(self) -> Union[None, "GlossaryTermsClass"]:
        """Glossary terms associated with the field"""
        return self._inner_dict.get('glossaryTerms')  # type: ignore
    
    @glossaryTerms.setter
    def glossaryTerms(self, value: Union[None, "GlossaryTermsClass"]) -> None:
        self._inner_dict['glossaryTerms'] = value
    
    
    @property
    def isPartOfKey(self) -> bool:
        """For schema fields that are part of complex keys, set this field to true
    We do this to easily distinguish between value and key fields"""
        return self._inner_dict.get('isPartOfKey')  # type: ignore
    
    @isPartOfKey.setter
    def isPartOfKey(self, value: bool) -> None:
        self._inner_dict['isPartOfKey'] = value
    
    
    @property
    def isPartitioningKey(self) -> Union[None, bool]:
        """For Datasets which are partitioned, this determines the partitioning key.
    Note that multiple columns can be part of a partitioning key, but currently we do not support
    rendering the ordered partitioning key."""
        return self._inner_dict.get('isPartitioningKey')  # type: ignore
    
    @isPartitioningKey.setter
    def isPartitioningKey(self, value: Union[None, bool]) -> None:
        self._inner_dict['isPartitioningKey'] = value
    
    
    @property
    def jsonProps(self) -> Union[None, str]:
        """For schema fields that have other properties that are not modeled explicitly,
    use this field to serialize those properties into a JSON string"""
        return self._inner_dict.get('jsonProps')  # type: ignore
    
    @jsonProps.setter
    def jsonProps(self, value: Union[None, str]) -> None:
        self._inner_dict['jsonProps'] = value
    
    
class SchemaFieldDataTypeClass(DictWrapper):
    """Schema field data types"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.SchemaFieldDataType")
    def __init__(self,
        type: Union["BooleanTypeClass", "FixedTypeClass", "StringTypeClass", "BytesTypeClass", "NumberTypeClass", "DateTypeClass", "TimeTypeClass", "EnumTypeClass", "NullTypeClass", "MapTypeClass", "ArrayTypeClass", "UnionTypeClass", "RecordTypeClass"],
    ):
        super().__init__()
        
        self.type = type
    
    def _restore_defaults(self) -> None:
        self.type = BooleanTypeClass._construct_with_defaults()
    
    
    @property
    def type(self) -> Union["BooleanTypeClass", "FixedTypeClass", "StringTypeClass", "BytesTypeClass", "NumberTypeClass", "DateTypeClass", "TimeTypeClass", "EnumTypeClass", "NullTypeClass", "MapTypeClass", "ArrayTypeClass", "UnionTypeClass", "RecordTypeClass"]:
        """Data platform specific types"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union["BooleanTypeClass", "FixedTypeClass", "StringTypeClass", "BytesTypeClass", "NumberTypeClass", "DateTypeClass", "TimeTypeClass", "EnumTypeClass", "NullTypeClass", "MapTypeClass", "ArrayTypeClass", "UnionTypeClass", "RecordTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class SchemaFieldSpecClass(DictWrapper):
    """Lightweight spec used for referencing a particular schema field."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.SchemaFieldSpec")
    def __init__(self,
        path: str,
        type: str,
        nativeType: str,
    ):
        super().__init__()
        
        self.path = path
        self.type = type
        self.nativeType = nativeType
    
    def _restore_defaults(self) -> None:
        self.path = str()
        self.type = str()
        self.nativeType = str()
    
    
    @property
    def path(self) -> str:
        """The field path"""
        return self._inner_dict.get('path')  # type: ignore
    
    @path.setter
    def path(self, value: str) -> None:
        self._inner_dict['path'] = value
    
    
    @property
    def type(self) -> str:
        """The DataHub standard schema field type."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: str) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def nativeType(self) -> str:
        """The native field type"""
        return self._inner_dict.get('nativeType')  # type: ignore
    
    @nativeType.setter
    def nativeType(self, value: str) -> None:
        self._inner_dict['nativeType'] = value
    
    
class SchemaMetadataClass(_Aspect):
    """SchemaMetadata to describe metadata related to store schema"""


    ASPECT_NAME = 'schemaMetadata'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.SchemaMetadata")

    def __init__(self,
        schemaName: str,
        platform: str,
        version: int,
        hash: str,
        platformSchema: Union["EspressoSchemaClass", "OracleDDLClass", "MySqlDDLClass", "PrestoDDLClass", "KafkaSchemaClass", "BinaryJsonSchemaClass", "OrcSchemaClass", "SchemalessClass", "KeyValueSchemaClass", "OtherSchemaClass"],
        fields: List["SchemaFieldClass"],
        created: Optional["AuditStampClass"]=None,
        lastModified: Optional["AuditStampClass"]=None,
        deleted: Union[None, "AuditStampClass"]=None,
        dataset: Union[None, str]=None,
        cluster: Union[None, str]=None,
        primaryKeys: Union[None, List[str]]=None,
        foreignKeysSpecs: Union[None, Dict[str, "ForeignKeySpecClass"]]=None,
        foreignKeys: Union[None, List["ForeignKeyConstraintClass"]]=None,
    ):
        super().__init__()
        
        self.schemaName = schemaName
        self.platform = platform
        self.version = version
        if created is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        else:
            self.created = created
        if lastModified is None:
            # default: {'actor': 'urn:li:corpuser:unknown', 'impersonator': None, 'time': 0, 'message': None}
            self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        else:
            self.lastModified = lastModified
        self.deleted = deleted
        self.dataset = dataset
        self.cluster = cluster
        self.hash = hash
        self.platformSchema = platformSchema
        self.fields = fields
        self.primaryKeys = primaryKeys
        self.foreignKeysSpecs = foreignKeysSpecs
        self.foreignKeys = foreignKeys
    
    def _restore_defaults(self) -> None:
        self.schemaName = str()
        self.platform = str()
        self.version = int()
        self.created = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["created"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["created"].type)
        self.lastModified = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["lastModified"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["lastModified"].type)
        self.deleted = self.RECORD_SCHEMA.fields_dict["deleted"].default
        self.dataset = self.RECORD_SCHEMA.fields_dict["dataset"].default
        self.cluster = self.RECORD_SCHEMA.fields_dict["cluster"].default
        self.hash = str()
        self.platformSchema = EspressoSchemaClass._construct_with_defaults()
        self.fields = list()
        self.primaryKeys = self.RECORD_SCHEMA.fields_dict["primaryKeys"].default
        self.foreignKeysSpecs = self.RECORD_SCHEMA.fields_dict["foreignKeysSpecs"].default
        self.foreignKeys = self.RECORD_SCHEMA.fields_dict["foreignKeys"].default
    
    
    @property
    def schemaName(self) -> str:
        """Schema name e.g. PageViewEvent, identity.Profile, ams.account_management_tracking"""
        return self._inner_dict.get('schemaName')  # type: ignore
    
    @schemaName.setter
    def schemaName(self, value: str) -> None:
        self._inner_dict['schemaName'] = value
    
    
    @property
    def platform(self) -> str:
        """Standardized platform urn where schema is defined. The data platform Urn (urn:li:platform:{platform_name})"""
        return self._inner_dict.get('platform')  # type: ignore
    
    @platform.setter
    def platform(self, value: str) -> None:
        self._inner_dict['platform'] = value
    
    
    @property
    def version(self) -> int:
        """Every change to SchemaMetadata in the resource results in a new version. Version is server assigned. This version is differ from platform native schema version."""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: int) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def deleted(self) -> Union[None, "AuditStampClass"]:
        """An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics."""
        return self._inner_dict.get('deleted')  # type: ignore
    
    @deleted.setter
    def deleted(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['deleted'] = value
    
    
    @property
    def dataset(self) -> Union[None, str]:
        """Dataset this schema metadata is associated with."""
        return self._inner_dict.get('dataset')  # type: ignore
    
    @dataset.setter
    def dataset(self, value: Union[None, str]) -> None:
        self._inner_dict['dataset'] = value
    
    
    @property
    def cluster(self) -> Union[None, str]:
        """The cluster this schema metadata resides from"""
        return self._inner_dict.get('cluster')  # type: ignore
    
    @cluster.setter
    def cluster(self, value: Union[None, str]) -> None:
        self._inner_dict['cluster'] = value
    
    
    @property
    def hash(self) -> str:
        """the SHA1 hash of the schema content"""
        return self._inner_dict.get('hash')  # type: ignore
    
    @hash.setter
    def hash(self, value: str) -> None:
        self._inner_dict['hash'] = value
    
    
    @property
    def platformSchema(self) -> Union["EspressoSchemaClass", "OracleDDLClass", "MySqlDDLClass", "PrestoDDLClass", "KafkaSchemaClass", "BinaryJsonSchemaClass", "OrcSchemaClass", "SchemalessClass", "KeyValueSchemaClass", "OtherSchemaClass"]:
        """The native schema in the dataset's platform."""
        return self._inner_dict.get('platformSchema')  # type: ignore
    
    @platformSchema.setter
    def platformSchema(self, value: Union["EspressoSchemaClass", "OracleDDLClass", "MySqlDDLClass", "PrestoDDLClass", "KafkaSchemaClass", "BinaryJsonSchemaClass", "OrcSchemaClass", "SchemalessClass", "KeyValueSchemaClass", "OtherSchemaClass"]) -> None:
        self._inner_dict['platformSchema'] = value
    
    
    @property
    def fields(self) -> List["SchemaFieldClass"]:
        """Client provided a list of fields from document schema."""
        return self._inner_dict.get('fields')  # type: ignore
    
    @fields.setter
    def fields(self, value: List["SchemaFieldClass"]) -> None:
        self._inner_dict['fields'] = value
    
    
    @property
    def primaryKeys(self) -> Union[None, List[str]]:
        """Client provided list of fields that define primary keys to access record. Field order defines hierarchical espresso keys. Empty lists indicates absence of primary key access patter. Value is a SchemaField@fieldPath."""
        return self._inner_dict.get('primaryKeys')  # type: ignore
    
    @primaryKeys.setter
    def primaryKeys(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['primaryKeys'] = value
    
    
    @property
    def foreignKeysSpecs(self) -> Union[None, Dict[str, "ForeignKeySpecClass"]]:
        """Map captures all the references schema makes to external datasets. Map key is ForeignKeySpecName typeref."""
        return self._inner_dict.get('foreignKeysSpecs')  # type: ignore
    
    @foreignKeysSpecs.setter
    def foreignKeysSpecs(self, value: Union[None, Dict[str, "ForeignKeySpecClass"]]) -> None:
        self._inner_dict['foreignKeysSpecs'] = value
    
    
    @property
    def foreignKeys(self) -> Union[None, List["ForeignKeyConstraintClass"]]:
        """List of foreign key constraints for the schema"""
        return self._inner_dict.get('foreignKeys')  # type: ignore
    
    @foreignKeys.setter
    def foreignKeys(self, value: Union[None, List["ForeignKeyConstraintClass"]]) -> None:
        self._inner_dict['foreignKeys'] = value
    
    
class SchemaProposalClass(DictWrapper):
    """Schema proposal aspect for proposed schema tags and proposed schema glossary terms
    These are secondary indices and ActionRequests remain the source of truth."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.SchemaProposal")
    def __init__(self,
        fieldPath: str,
        proposedSchemaTags: Union[None, List[str]]=None,
        proposedSchemaGlossaryTerms: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.fieldPath = fieldPath
        self.proposedSchemaTags = proposedSchemaTags
        self.proposedSchemaGlossaryTerms = proposedSchemaGlossaryTerms
    
    def _restore_defaults(self) -> None:
        self.fieldPath = str()
        self.proposedSchemaTags = self.RECORD_SCHEMA.fields_dict["proposedSchemaTags"].default
        self.proposedSchemaGlossaryTerms = self.RECORD_SCHEMA.fields_dict["proposedSchemaGlossaryTerms"].default
    
    
    @property
    def fieldPath(self) -> str:
        """FieldPath uniquely identifying the SchemaField this metadata is associated with"""
        return self._inner_dict.get('fieldPath')  # type: ignore
    
    @fieldPath.setter
    def fieldPath(self, value: str) -> None:
        self._inner_dict['fieldPath'] = value
    
    
    @property
    def proposedSchemaTags(self) -> Union[None, List[str]]:
        """Proposed tags for a given entity"""
        return self._inner_dict.get('proposedSchemaTags')  # type: ignore
    
    @proposedSchemaTags.setter
    def proposedSchemaTags(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['proposedSchemaTags'] = value
    
    
    @property
    def proposedSchemaGlossaryTerms(self) -> Union[None, List[str]]:
        """Proposed glossary terms for a given entity"""
        return self._inner_dict.get('proposedSchemaGlossaryTerms')  # type: ignore
    
    @proposedSchemaGlossaryTerms.setter
    def proposedSchemaGlossaryTerms(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['proposedSchemaGlossaryTerms'] = value
    
    
class SchemaProposalsClass(_Aspect):
    """Schema proposals aspect for proposed tags and glossary terms on schema metadata."""


    ASPECT_NAME = 'schemaProposals'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.SchemaProposals")

    def __init__(self,
        schemaProposals: List["SchemaProposalClass"],
    ):
        super().__init__()
        
        self.schemaProposals = schemaProposals
    
    def _restore_defaults(self) -> None:
        self.schemaProposals = list()
    
    
    @property
    def schemaProposals(self) -> List["SchemaProposalClass"]:
        """Array of SchemaProposal"""
        return self._inner_dict.get('schemaProposals')  # type: ignore
    
    @schemaProposals.setter
    def schemaProposals(self, value: List["SchemaProposalClass"]) -> None:
        self._inner_dict['schemaProposals'] = value
    
    
class SchemalessClass(DictWrapper):
    """The dataset has no specific schema associated with it"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.Schemaless")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class StringTypeClass(DictWrapper):
    """String field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.StringType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class TimeTypeClass(DictWrapper):
    """Time field type. This should also be used for datetimes."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.TimeType")
    def __init__(self,
    ):
        super().__init__()
        
    
    def _restore_defaults(self) -> None:
        pass
    
    
class UnionTypeClass(DictWrapper):
    """Union field type."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.UnionType")
    def __init__(self,
        nestedTypes: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.nestedTypes = nestedTypes
    
    def _restore_defaults(self) -> None:
        self.nestedTypes = self.RECORD_SCHEMA.fields_dict["nestedTypes"].default
    
    
    @property
    def nestedTypes(self) -> Union[None, List[str]]:
        """List of types in union type."""
        return self._inner_dict.get('nestedTypes')  # type: ignore
    
    @nestedTypes.setter
    def nestedTypes(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['nestedTypes'] = value
    
    
class UrnForeignKeyClass(DictWrapper):
    """If SchemaMetadata fields make any external references and references are of type com.linkedin.pegasus2avro.common.Urn or any children, this models can be used to mark it."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schema.UrnForeignKey")
    def __init__(self,
        currentFieldPath: str,
    ):
        super().__init__()
        
        self.currentFieldPath = currentFieldPath
    
    def _restore_defaults(self) -> None:
        self.currentFieldPath = str()
    
    
    @property
    def currentFieldPath(self) -> str:
        """Field in hosting(current) SchemaMetadata."""
        return self._inner_dict.get('currentFieldPath')  # type: ignore
    
    @currentFieldPath.setter
    def currentFieldPath(self, value: str) -> None:
        self._inner_dict['currentFieldPath'] = value
    
    
class SchemaFieldAliasesClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'schemaFieldAliases'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schemafield.SchemaFieldAliases")

    def __init__(self,
        aliases: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.aliases = aliases
    
    def _restore_defaults(self) -> None:
        self.aliases = self.RECORD_SCHEMA.fields_dict["aliases"].default
    
    
    @property
    def aliases(self) -> Union[None, List[str]]:
        """Used to store aliases"""
        return self._inner_dict.get('aliases')  # type: ignore
    
    @aliases.setter
    def aliases(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['aliases'] = value
    
    
class SchemaFieldInfoClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'schemafieldInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.schemafield.SchemaFieldInfo")

    def __init__(self,
        name: Union[None, str]=None,
        schemaFieldAliases: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.name = name
        self.schemaFieldAliases = schemaFieldAliases
    
    def _restore_defaults(self) -> None:
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.schemaFieldAliases = self.RECORD_SCHEMA.fields_dict["schemaFieldAliases"].default
    
    
    @property
    def name(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def schemaFieldAliases(self) -> Union[None, List[str]]:
        """Used to store field path variations for the schemaField urn."""
        return self._inner_dict.get('schemaFieldAliases')  # type: ignore
    
    @schemaFieldAliases.setter
    def schemaFieldAliases(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['schemaFieldAliases'] = value
    
    
class DataHubSecretValueClass(_Aspect):
    """The value of a DataHub Secret"""


    ASPECT_NAME = 'dataHubSecretValue'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.secret.DataHubSecretValue")

    def __init__(self,
        name: str,
        value: str,
        description: Union[None, str]=None,
        created: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.name = name
        self.value = value
        self.description = description
        self.created = created
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.value = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
    
    
    @property
    def name(self) -> str:
        """The display name for the secret"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def value(self) -> str:
        """The AES-encrypted value of the DataHub secret."""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: str) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the secret"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
class NotificationSettingClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.NotificationSetting")
    def __init__(self,
        value: Union[str, "NotificationSettingValueClass"],
        params: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        self.value = value
        self.params = params
    
    def _restore_defaults(self) -> None:
        self.value = NotificationSettingValueClass.ENABLED
        self.params = self.RECORD_SCHEMA.fields_dict["params"].default
    
    
    @property
    def value(self) -> Union[str, "NotificationSettingValueClass"]:
        """Integrations between DataHub & other platforms."""
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: Union[str, "NotificationSettingValueClass"]) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def params(self) -> Union[None, Dict[str, str]]:
        """Custom set of setting parameters.
    Currently used to store sink enabled / disabled settings.
    E.g. slack.enabled = true, email.enabled = false"""
        return self._inner_dict.get('params')  # type: ignore
    
    @params.setter
    def params(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['params'] = value
    
    
class NotificationSettingValueClass(object):
    # No docs available.
    
    ENABLED = "ENABLED"
    """Setting is enabled."""
    
    DISABLED = "DISABLED"
    """Setting is disabled."""
    
    
    
class AssetSettingsClass(_Aspect):
    """Settings associated with this asset"""


    ASPECT_NAME = 'assetSettings'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.asset.AssetSettings")

    def __init__(self,
        assetSummary: Union[None, "AssetSummarySettingsClass"]=None,
    ):
        super().__init__()
        
        self.assetSummary = assetSummary
    
    def _restore_defaults(self) -> None:
        self.assetSummary = self.RECORD_SCHEMA.fields_dict["assetSummary"].default
    
    
    @property
    def assetSummary(self) -> Union[None, "AssetSummarySettingsClass"]:
        """Information related to the asset summary for this asset"""
        return self._inner_dict.get('assetSummary')  # type: ignore
    
    @assetSummary.setter
    def assetSummary(self, value: Union[None, "AssetSummarySettingsClass"]) -> None:
        self._inner_dict['assetSummary'] = value
    
    
class AssetSummarySettingsClass(DictWrapper):
    """Information related to the asset summary for this asset"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.asset.AssetSummarySettings")
    def __init__(self,
        templates: Optional[Union[List["AssetSummarySettingsTemplateClass"], None]]=None,
    ):
        super().__init__()
        
        if templates is None:
            # default: []
            self.templates = list()
        else:
            self.templates = templates
    
    def _restore_defaults(self) -> None:
        self.templates = list()
    
    
    @property
    def templates(self) -> Union[List["AssetSummarySettingsTemplateClass"], None]:
        """The list of templates applied to this asset in order. Right now we only expect one."""
        return self._inner_dict.get('templates')  # type: ignore
    
    @templates.setter
    def templates(self, value: Union[List["AssetSummarySettingsTemplateClass"], None]) -> None:
        self._inner_dict['templates'] = value
    
    
class AssetSummarySettingsTemplateClass(DictWrapper):
    """Object containing the template and any additional info for asset summary settings"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.asset.AssetSummarySettingsTemplate")
    def __init__(self,
        template: str,
    ):
        super().__init__()
        
        self.template = template
    
    def _restore_defaults(self) -> None:
        self.template = str()
    
    
    @property
    def template(self) -> str:
        """The urn of the template"""
        return self._inner_dict.get('template')  # type: ignore
    
    @template.setter
    def template(self, value: str) -> None:
        self._inner_dict['template'] = value
    
    
class AiAssistantSettingsClass(DictWrapper):
    """Settings related to the AI assistant (Ask DataHub) feature"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.AiAssistantSettings")
    def __init__(self,
        instructions: Optional[List["AiInstructionClass"]]=None,
    ):
        super().__init__()
        
        if instructions is None:
            # default: []
            self.instructions = list()
        else:
            self.instructions = instructions
    
    def _restore_defaults(self) -> None:
        self.instructions = list()
    
    
    @property
    def instructions(self) -> List["AiInstructionClass"]:
        """Custom instructions to inject into the AI assistant prompt"""
        return self._inner_dict.get('instructions')  # type: ignore
    
    @instructions.setter
    def instructions(self, value: List["AiInstructionClass"]) -> None:
        self._inner_dict['instructions'] = value
    
    
class AiInstructionClass(DictWrapper):
    """An object representing custom AI instructions for the AI assistant.
    Generally, these are injected into the prompt sent to the AI model.
    
    In the future we extend this to include positive examples, negative examples,
    and other parameters to customize the AI model's behavior."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.AiInstruction")
    def __init__(self,
        id: str,
        type: Union[str, "AiInstructionTypeClass"],
        state: Union[str, "AiInstructionStateClass"],
        instruction: str,
        created: "AuditStampClass",
        lastModified: "AuditStampClass",
    ):
        super().__init__()
        
        self.id = id
        self.type = type
        self.state = state
        self.instruction = instruction
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.type = AiInstructionTypeClass.GENERAL_CONTEXT
        self.state = AiInstructionStateClass.ACTIVE
        self.instruction = str()
        self.created = AuditStampClass._construct_with_defaults()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def id(self) -> str:
        """A unique identifier for this instruction.
    This will enable users to manage multiple versions of the same instruction in the future."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def type(self) -> Union[str, "AiInstructionTypeClass"]:
        """A unique identifier for this instruction.
    This will enable users to manage multiple versions of the same instruction in the future."""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "AiInstructionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def state(self) -> Union[str, "AiInstructionStateClass"]:
        """The state of the instruction"""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[str, "AiInstructionStateClass"]) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def instruction(self) -> str:
        """Custom instruction text to be sent to the AI model."""
        return self._inner_dict.get('instruction')  # type: ignore
    
    @instruction.setter
    def instruction(self, value: str) -> None:
        self._inner_dict['instruction'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """The actor + timestamp of when this instruction was created."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """The actor + timestamp of when this instruction was last modified."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class AiInstructionStateClass(object):
    # No docs available.
    
    ACTIVE = "ACTIVE"
    """The instruction is active and will be used by the AI assistant."""
    
    INACTIVE = "INACTIVE"
    """The instruction is inactive and will not be used by the AI assistant."""
    
    
    
class AiInstructionTypeClass(object):
    # No docs available.
    
    GENERAL_CONTEXT = "GENERAL_CONTEXT"
    """General context to customize the AI assistant's behavior globally or personally. This is the only supported type currently."""
    
    
    
class ApplicationsSettingsClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.ApplicationsSettings")
    def __init__(self,
        enabled: bool,
        config: Union[None, str]=None,
        configVersion: Union[None, str]=None,
    ):
        super().__init__()
        
        self.enabled = enabled
        self.config = config
        self.configVersion = configVersion
    
    def _restore_defaults(self) -> None:
        self.enabled = bool()
        self.config = self.RECORD_SCHEMA.fields_dict["config"].default
        self.configVersion = self.RECORD_SCHEMA.fields_dict["configVersion"].default
    
    
    @property
    def enabled(self) -> bool:
        # No docs available.
        return self._inner_dict.get('enabled')  # type: ignore
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        self._inner_dict['enabled'] = value
    
    
    @property
    def config(self) -> Union[None, str]:
        """The configuration for the feature, in JSON format."""
        return self._inner_dict.get('config')  # type: ignore
    
    @config.setter
    def config(self, value: Union[None, str]) -> None:
        self._inner_dict['config'] = value
    
    
    @property
    def configVersion(self) -> Union[None, str]:
        """The version of the configuration schema that has been used to serialize
           the config.
    If not provided, the version is assumed to be the latest version."""
        return self._inner_dict.get('configVersion')  # type: ignore
    
    @configVersion.setter
    def configVersion(self, value: Union[None, str]) -> None:
        self._inner_dict['configVersion'] = value
    
    
class DocPropagationFeatureSettingsClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.DocPropagationFeatureSettings")
    def __init__(self,
        enabled: bool,
        config: Union[None, str]=None,
        configVersion: Union[None, str]=None,
        columnPropagationEnabled: Optional[bool]=None,
    ):
        super().__init__()
        
        self.enabled = enabled
        self.config = config
        self.configVersion = configVersion
        if columnPropagationEnabled is None:
            # default: True
            self.columnPropagationEnabled = self.RECORD_SCHEMA.fields_dict["columnPropagationEnabled"].default
        else:
            self.columnPropagationEnabled = columnPropagationEnabled
    
    def _restore_defaults(self) -> None:
        self.enabled = bool()
        self.config = self.RECORD_SCHEMA.fields_dict["config"].default
        self.configVersion = self.RECORD_SCHEMA.fields_dict["configVersion"].default
        self.columnPropagationEnabled = self.RECORD_SCHEMA.fields_dict["columnPropagationEnabled"].default
    
    
    @property
    def enabled(self) -> bool:
        # No docs available.
        return self._inner_dict.get('enabled')  # type: ignore
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        self._inner_dict['enabled'] = value
    
    
    @property
    def config(self) -> Union[None, str]:
        """The configuration for the feature, in JSON format."""
        return self._inner_dict.get('config')  # type: ignore
    
    @config.setter
    def config(self, value: Union[None, str]) -> None:
        self._inner_dict['config'] = value
    
    
    @property
    def configVersion(self) -> Union[None, str]:
        """The version of the configuration schema that has been used to serialize
           the config.
    If not provided, the version is assumed to be the latest version."""
        return self._inner_dict.get('configVersion')  # type: ignore
    
    @configVersion.setter
    def configVersion(self, value: Union[None, str]) -> None:
        self._inner_dict['configVersion'] = value
    
    
    @property
    def columnPropagationEnabled(self) -> bool:
        # No docs available.
        return self._inner_dict.get('columnPropagationEnabled')  # type: ignore
    
    @columnPropagationEnabled.setter
    def columnPropagationEnabled(self, value: bool) -> None:
        self._inner_dict['columnPropagationEnabled'] = value
    
    
class DocumentationAiSettingsClass(DictWrapper):
    """Settings related to AI-powered documentation."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.DocumentationAiSettings")
    def __init__(self,
        enabled: Optional[bool]=None,
        instructions: Optional[List["AiInstructionClass"]]=None,
    ):
        super().__init__()
        
        if enabled is None:
            # default: True
            self.enabled = self.RECORD_SCHEMA.fields_dict["enabled"].default
        else:
            self.enabled = enabled
        if instructions is None:
            # default: []
            self.instructions = list()
        else:
            self.instructions = instructions
    
    def _restore_defaults(self) -> None:
        self.enabled = self.RECORD_SCHEMA.fields_dict["enabled"].default
        self.instructions = list()
    
    
    @property
    def enabled(self) -> bool:
        """Whether or not AI-generated documentation is enabled."""
        return self._inner_dict.get('enabled')  # type: ignore
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        self._inner_dict['enabled'] = value
    
    
    @property
    def instructions(self) -> List["AiInstructionClass"]:
        """Custom instructions to inject into the AI documentation model prompt."""
        return self._inner_dict.get('instructions')  # type: ignore
    
    @instructions.setter
    def instructions(self, value: List["AiInstructionClass"]) -> None:
        self._inner_dict['instructions'] = value
    
    
class EmailIntegrationSettingsClass(DictWrapper):
    """Email integration settings. Enabled by default and only disable-able via the application configs."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.EmailIntegrationSettings")
    def __init__(self,
        defaultEmail: Union[None, str]=None,
    ):
        super().__init__()
        
        self.defaultEmail = defaultEmail
    
    def _restore_defaults(self) -> None:
        self.defaultEmail = self.RECORD_SCHEMA.fields_dict["defaultEmail"].default
    
    
    @property
    def defaultEmail(self) -> Union[None, str]:
        """The default email address to use for global notifications."""
        return self._inner_dict.get('defaultEmail')  # type: ignore
    
    @defaultEmail.setter
    def defaultEmail(self, value: Union[None, str]) -> None:
        self._inner_dict['defaultEmail'] = value
    
    
class GlobalHomePageSettingsClass(DictWrapper):
    """Global settings related to the home page for an instance"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.GlobalHomePageSettings")
    def __init__(self,
        defaultTemplate: str,
    ):
        super().__init__()
        
        self.defaultTemplate = defaultTemplate
    
    def _restore_defaults(self) -> None:
        self.defaultTemplate = str()
    
    
    @property
    def defaultTemplate(self) -> str:
        """The urn that will be rendered in the UI by default for all users"""
        return self._inner_dict.get('defaultTemplate')  # type: ignore
    
    @defaultTemplate.setter
    def defaultTemplate(self, value: str) -> None:
        self._inner_dict['defaultTemplate'] = value
    
    
class GlobalIncidentsSettingsClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.GlobalIncidentsSettings")
    def __init__(self,
        broadcastNewIncidentNotification: "NotificationSettingClass",
        broadcastIncidentStatusChangeNotification: "NotificationSettingClass",
    ):
        super().__init__()
        
        self.broadcastNewIncidentNotification = broadcastNewIncidentNotification
        self.broadcastIncidentStatusChangeNotification = broadcastIncidentStatusChangeNotification
    
    def _restore_defaults(self) -> None:
        self.broadcastNewIncidentNotification = NotificationSettingClass._construct_with_defaults()
        self.broadcastIncidentStatusChangeNotification = NotificationSettingClass._construct_with_defaults()
    
    
    @property
    def broadcastNewIncidentNotification(self) -> "NotificationSettingClass":
        """Send a 'broadcast' notification when a new incident has been created. A broadcast is a notification that
    is sent to a general purpose channel, as opposed to a specific user or group member directly."""
        return self._inner_dict.get('broadcastNewIncidentNotification')  # type: ignore
    
    @broadcastNewIncidentNotification.setter
    def broadcastNewIncidentNotification(self, value: "NotificationSettingClass") -> None:
        self._inner_dict['broadcastNewIncidentNotification'] = value
    
    
    @property
    def broadcastIncidentStatusChangeNotification(self) -> "NotificationSettingClass":
        """Send a 'broadcast' notification when an incident status has changed. A broadcast is a notification that
    is sent to a general purpose channel, as opposed to a specific user or group member directly."""
        return self._inner_dict.get('broadcastIncidentStatusChangeNotification')  # type: ignore
    
    @broadcastIncidentStatusChangeNotification.setter
    def broadcastIncidentStatusChangeNotification(self, value: "NotificationSettingClass") -> None:
        self._inner_dict['broadcastIncidentStatusChangeNotification'] = value
    
    
class GlobalIntegrationSettingsClass(DictWrapper):
    """Native DataHub Integrations, supported on the UI."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.GlobalIntegrationSettings")
    def __init__(self,
        slackSettings: Union[None, "SlackIntegrationSettingsClass"]=None,
        emailSettings: Union[None, "EmailIntegrationSettingsClass"]=None,
        teamsSettings: Union[None, "TeamsIntegrationSettingsClass"]=None,
    ):
        super().__init__()
        
        self.slackSettings = slackSettings
        self.emailSettings = emailSettings
        self.teamsSettings = teamsSettings
    
    def _restore_defaults(self) -> None:
        self.slackSettings = self.RECORD_SCHEMA.fields_dict["slackSettings"].default
        self.emailSettings = self.RECORD_SCHEMA.fields_dict["emailSettings"].default
        self.teamsSettings = self.RECORD_SCHEMA.fields_dict["teamsSettings"].default
    
    
    @property
    def slackSettings(self) -> Union[None, "SlackIntegrationSettingsClass"]:
        """Slack integration settings."""
        return self._inner_dict.get('slackSettings')  # type: ignore
    
    @slackSettings.setter
    def slackSettings(self, value: Union[None, "SlackIntegrationSettingsClass"]) -> None:
        self._inner_dict['slackSettings'] = value
    
    
    @property
    def emailSettings(self) -> Union[None, "EmailIntegrationSettingsClass"]:
        """Email integration settings."""
        return self._inner_dict.get('emailSettings')  # type: ignore
    
    @emailSettings.setter
    def emailSettings(self, value: Union[None, "EmailIntegrationSettingsClass"]) -> None:
        self._inner_dict['emailSettings'] = value
    
    
    @property
    def teamsSettings(self) -> Union[None, "TeamsIntegrationSettingsClass"]:
        """Teams integration settings."""
        return self._inner_dict.get('teamsSettings')  # type: ignore
    
    @teamsSettings.setter
    def teamsSettings(self, value: Union[None, "TeamsIntegrationSettingsClass"]) -> None:
        self._inner_dict['teamsSettings'] = value
    
    
class GlobalNotificationSettingsClass(DictWrapper):
    """DataHub global notification settings"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.GlobalNotificationSettings")
    def __init__(self,
        settings: Union[None, Dict[str, "NotificationSettingClass"]]=None,
        incidents: Union[None, "GlobalIncidentsSettingsClass"]=None,
    ):
        super().__init__()
        
        self.settings = settings
        self.incidents = incidents
    
    def _restore_defaults(self) -> None:
        self.settings = self.RECORD_SCHEMA.fields_dict["settings"].default
        self.incidents = self.RECORD_SCHEMA.fields_dict["incidents"].default
    
    
    @property
    def settings(self) -> Union[None, Dict[str, "NotificationSettingClass"]]:
        """Global / platform notification settings.
    A map of notification scenario type to the settings associated with it.
    For a list of all scenario types to notify on, check out NotificationScenarioType enum."""
        return self._inner_dict.get('settings')  # type: ignore
    
    @settings.setter
    def settings(self, value: Union[None, Dict[str, "NotificationSettingClass"]]) -> None:
        self._inner_dict['settings'] = value
    
    
    @property
    def incidents(self) -> Union[None, "GlobalIncidentsSettingsClass"]:
        """Settings related to asset incidents.
    Deprecated! Use 'settings' for configuring incidents settings instead."""
        return self._inner_dict.get('incidents')  # type: ignore
    
    @incidents.setter
    def incidents(self, value: Union[None, "GlobalIncidentsSettingsClass"]) -> None:
        self._inner_dict['incidents'] = value
    
    
class GlobalSettingsInfoClass(_Aspect):
    """DataHub Global platform settings. Careful - these should not be modified by the outside world!"""


    ASPECT_NAME = 'globalSettingsInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.GlobalSettingsInfo")

    def __init__(self,
        integrations: Union[None, "GlobalIntegrationSettingsClass"]=None,
        notifications: Union[None, "GlobalNotificationSettingsClass"]=None,
        sso: Union[None, "SsoSettingsClass"]=None,
        oauth: Union[None, "OAuthSettingsClass"]=None,
        views: Union[None, "GlobalViewsSettingsClass"]=None,
        docPropagation: Optional[Union["DocPropagationFeatureSettingsClass", None]]=None,
        homePage: Union[None, "GlobalHomePageSettingsClass"]=None,
        applications: Union[None, "ApplicationsSettingsClass"]=None,
        documentationAi: Union[None, "DocumentationAiSettingsClass"]=None,
        aiAssistant: Union[None, "AiAssistantSettingsClass"]=None,
        visual: Union[None, "GlobalVisualSettingsClass"]=None,
    ):
        super().__init__()
        
        self.integrations = integrations
        self.notifications = notifications
        self.sso = sso
        self.oauth = oauth
        self.views = views
        if docPropagation is None:
            # default: {'configVersion': None, 'config': None, 'enabled': True, 'columnPropagationEnabled': True}
            self.docPropagation = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["docPropagation"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["docPropagation"].type)
        else:
            self.docPropagation = docPropagation
        self.homePage = homePage
        self.applications = applications
        self.documentationAi = documentationAi
        self.aiAssistant = aiAssistant
        self.visual = visual
    
    def _restore_defaults(self) -> None:
        self.integrations = self.RECORD_SCHEMA.fields_dict["integrations"].default
        self.notifications = self.RECORD_SCHEMA.fields_dict["notifications"].default
        self.sso = self.RECORD_SCHEMA.fields_dict["sso"].default
        self.oauth = self.RECORD_SCHEMA.fields_dict["oauth"].default
        self.views = self.RECORD_SCHEMA.fields_dict["views"].default
        self.docPropagation = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["docPropagation"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["docPropagation"].type)
        self.homePage = self.RECORD_SCHEMA.fields_dict["homePage"].default
        self.applications = self.RECORD_SCHEMA.fields_dict["applications"].default
        self.documentationAi = self.RECORD_SCHEMA.fields_dict["documentationAi"].default
        self.aiAssistant = self.RECORD_SCHEMA.fields_dict["aiAssistant"].default
        self.visual = self.RECORD_SCHEMA.fields_dict["visual"].default
    
    
    @property
    def integrations(self) -> Union[None, "GlobalIntegrationSettingsClass"]:
        """Integrations between DataHub & other platforms."""
        return self._inner_dict.get('integrations')  # type: ignore
    
    @integrations.setter
    def integrations(self, value: Union[None, "GlobalIntegrationSettingsClass"]) -> None:
        self._inner_dict['integrations'] = value
    
    
    @property
    def notifications(self) -> Union[None, "GlobalNotificationSettingsClass"]:
        """Global notifications settings"""
        return self._inner_dict.get('notifications')  # type: ignore
    
    @notifications.setter
    def notifications(self, value: Union[None, "GlobalNotificationSettingsClass"]) -> None:
        self._inner_dict['notifications'] = value
    
    
    @property
    def sso(self) -> Union[None, "SsoSettingsClass"]:
        """SSO integrations between DataHub and identity providers"""
        return self._inner_dict.get('sso')  # type: ignore
    
    @sso.setter
    def sso(self, value: Union[None, "SsoSettingsClass"]) -> None:
        self._inner_dict['sso'] = value
    
    
    @property
    def oauth(self) -> Union[None, "OAuthSettingsClass"]:
        """Settings related to the oauth authentication provider"""
        return self._inner_dict.get('oauth')  # type: ignore
    
    @oauth.setter
    def oauth(self, value: Union[None, "OAuthSettingsClass"]) -> None:
        self._inner_dict['oauth'] = value
    
    
    @property
    def views(self) -> Union[None, "GlobalViewsSettingsClass"]:
        """Settings related to the Views Feature"""
        return self._inner_dict.get('views')  # type: ignore
    
    @views.setter
    def views(self, value: Union[None, "GlobalViewsSettingsClass"]) -> None:
        self._inner_dict['views'] = value
    
    
    @property
    def docPropagation(self) -> Union["DocPropagationFeatureSettingsClass", None]:
        """Settings related to the documentation propagation feature"""
        return self._inner_dict.get('docPropagation')  # type: ignore
    
    @docPropagation.setter
    def docPropagation(self, value: Union["DocPropagationFeatureSettingsClass", None]) -> None:
        self._inner_dict['docPropagation'] = value
    
    
    @property
    def homePage(self) -> Union[None, "GlobalHomePageSettingsClass"]:
        """Global settings related to the home page for an instance"""
        return self._inner_dict.get('homePage')  # type: ignore
    
    @homePage.setter
    def homePage(self, value: Union[None, "GlobalHomePageSettingsClass"]) -> None:
        self._inner_dict['homePage'] = value
    
    
    @property
    def applications(self) -> Union[None, "ApplicationsSettingsClass"]:
        """Settings related to applications. If not enabled, applications won't show up in navigation"""
        return self._inner_dict.get('applications')  # type: ignore
    
    @applications.setter
    def applications(self, value: Union[None, "ApplicationsSettingsClass"]) -> None:
        self._inner_dict['applications'] = value
    
    
    @property
    def documentationAi(self) -> Union[None, "DocumentationAiSettingsClass"]:
        """Settings related to AI-powered documentation."""
        return self._inner_dict.get('documentationAi')  # type: ignore
    
    @documentationAi.setter
    def documentationAi(self, value: Union[None, "DocumentationAiSettingsClass"]) -> None:
        self._inner_dict['documentationAi'] = value
    
    
    @property
    def aiAssistant(self) -> Union[None, "AiAssistantSettingsClass"]:
        """Settings related to AI-powered chat assistant (Ask DataHub)."""
        return self._inner_dict.get('aiAssistant')  # type: ignore
    
    @aiAssistant.setter
    def aiAssistant(self, value: Union[None, "AiAssistantSettingsClass"]) -> None:
        self._inner_dict['aiAssistant'] = value
    
    
    @property
    def visual(self) -> Union[None, "GlobalVisualSettingsClass"]:
        """Global settings related to the UI and what's displayed in the app"""
        return self._inner_dict.get('visual')  # type: ignore
    
    @visual.setter
    def visual(self, value: Union[None, "GlobalVisualSettingsClass"]) -> None:
        self._inner_dict['visual'] = value
    
    
class GlobalViewsSettingsClass(DictWrapper):
    """Settings for DataHub Views feature."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.GlobalViewsSettings")
    def __init__(self,
        defaultView: Union[None, str]=None,
    ):
        super().__init__()
        
        self.defaultView = defaultView
    
    def _restore_defaults(self) -> None:
        self.defaultView = self.RECORD_SCHEMA.fields_dict["defaultView"].default
    
    
    @property
    def defaultView(self) -> Union[None, str]:
        """The default View for the instance, or organization."""
        return self._inner_dict.get('defaultView')  # type: ignore
    
    @defaultView.setter
    def defaultView(self, value: Union[None, str]) -> None:
        self._inner_dict['defaultView'] = value
    
    
class GlobalVisualSettingsClass(DictWrapper):
    """Global settings for the UI"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.GlobalVisualSettings")
    def __init__(self,
        helpLink: Union[None, "HelpLinkClass"]=None,
        customLogoUrl: Union[None, str]=None,
        customOrgName: Union[None, str]=None,
        sampleDataSettings: Union[None, "SampleDataSettingsClass"]=None,
    ):
        super().__init__()
        
        self.helpLink = helpLink
        self.customLogoUrl = customLogoUrl
        self.customOrgName = customOrgName
        self.sampleDataSettings = sampleDataSettings
    
    def _restore_defaults(self) -> None:
        self.helpLink = self.RECORD_SCHEMA.fields_dict["helpLink"].default
        self.customLogoUrl = self.RECORD_SCHEMA.fields_dict["customLogoUrl"].default
        self.customOrgName = self.RECORD_SCHEMA.fields_dict["customOrgName"].default
        self.sampleDataSettings = self.RECORD_SCHEMA.fields_dict["sampleDataSettings"].default
    
    
    @property
    def helpLink(self) -> Union[None, "HelpLinkClass"]:
        """The configurable help link shown in the UI"""
        return self._inner_dict.get('helpLink')  # type: ignore
    
    @helpLink.setter
    def helpLink(self, value: Union[None, "HelpLinkClass"]) -> None:
        self._inner_dict['helpLink'] = value
    
    
    @property
    def customLogoUrl(self) -> Union[None, str]:
        """The Url for a custom logo to display in the UI"""
        return self._inner_dict.get('customLogoUrl')  # type: ignore
    
    @customLogoUrl.setter
    def customLogoUrl(self, value: Union[None, str]) -> None:
        self._inner_dict['customLogoUrl'] = value
    
    
    @property
    def customOrgName(self) -> Union[None, str]:
        """A customized name for organization display preferences"""
        return self._inner_dict.get('customOrgName')  # type: ignore
    
    @customOrgName.setter
    def customOrgName(self, value: Union[None, str]) -> None:
        self._inner_dict['customOrgName'] = value
    
    
    @property
    def sampleDataSettings(self) -> Union[None, "SampleDataSettingsClass"]:
        """Settings related to sample data, used to aid in initial onboarding."""
        return self._inner_dict.get('sampleDataSettings')  # type: ignore
    
    @sampleDataSettings.setter
    def sampleDataSettings(self, value: Union[None, "SampleDataSettingsClass"]) -> None:
        self._inner_dict['sampleDataSettings'] = value
    
    
class HelpLinkClass(DictWrapper):
    """Information regarding the help link dislayed in the UI"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.HelpLink")
    def __init__(self,
        isEnabled: bool,
        label: str,
        link: str,
    ):
        super().__init__()
        
        self.isEnabled = isEnabled
        self.label = label
        self.link = link
    
    def _restore_defaults(self) -> None:
        self.isEnabled = bool()
        self.label = str()
        self.link = str()
    
    
    @property
    def isEnabled(self) -> bool:
        """Whether or not this link should be shown in the UI"""
        return self._inner_dict.get('isEnabled')  # type: ignore
    
    @isEnabled.setter
    def isEnabled(self, value: bool) -> None:
        self._inner_dict['isEnabled'] = value
    
    
    @property
    def label(self) -> str:
        """The label of this help link"""
        return self._inner_dict.get('label')  # type: ignore
    
    @label.setter
    def label(self, value: str) -> None:
        self._inner_dict['label'] = value
    
    
    @property
    def link(self) -> str:
        """The url or mailto link that this links to"""
        return self._inner_dict.get('link')  # type: ignore
    
    @link.setter
    def link(self, value: str) -> None:
        self._inner_dict['link'] = value
    
    
class OAuthProviderClass(DictWrapper):
    """An OAuth Provider. This provides information required to validate inbound
    requests with OAuth 2.0 bearer tokens."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.OAuthProvider")
    def __init__(self,
        enabled: bool,
        name: str,
        issuer: str,
        audience: str,
        jwksUri: Union[None, str]=None,
        algorithm: Optional[str]=None,
        userIdClaim: Optional[str]=None,
    ):
        super().__init__()
        
        self.enabled = enabled
        self.name = name
        self.jwksUri = jwksUri
        self.issuer = issuer
        self.audience = audience
        if algorithm is None:
            # default: 'RS256'
            self.algorithm = self.RECORD_SCHEMA.fields_dict["algorithm"].default
        else:
            self.algorithm = algorithm
        if userIdClaim is None:
            # default: 'sub'
            self.userIdClaim = self.RECORD_SCHEMA.fields_dict["userIdClaim"].default
        else:
            self.userIdClaim = userIdClaim
    
    def _restore_defaults(self) -> None:
        self.enabled = bool()
        self.name = str()
        self.jwksUri = self.RECORD_SCHEMA.fields_dict["jwksUri"].default
        self.issuer = str()
        self.audience = str()
        self.algorithm = self.RECORD_SCHEMA.fields_dict["algorithm"].default
        self.userIdClaim = self.RECORD_SCHEMA.fields_dict["userIdClaim"].default
    
    
    @property
    def enabled(self) -> bool:
        """Whether this OAuth provider is enabled."""
        return self._inner_dict.get('enabled')  # type: ignore
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        self._inner_dict['enabled'] = value
    
    
    @property
    def name(self) -> str:
        """The name of this OAuth provider. This is used for display purposes only."""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def jwksUri(self) -> Union[None, str]:
        """The URI of the JSON Web Key Set (JWKS) endpoint for this OAuth provider."""
        return self._inner_dict.get('jwksUri')  # type: ignore
    
    @jwksUri.setter
    def jwksUri(self, value: Union[None, str]) -> None:
        self._inner_dict['jwksUri'] = value
    
    
    @property
    def issuer(self) -> str:
        """The expected issuer (iss) claim in the JWTs issued by this OAuth provider."""
        return self._inner_dict.get('issuer')  # type: ignore
    
    @issuer.setter
    def issuer(self, value: str) -> None:
        self._inner_dict['issuer'] = value
    
    
    @property
    def audience(self) -> str:
        """The expected audience (aud) claim in the JWTs issued by this OAuth provider."""
        return self._inner_dict.get('audience')  # type: ignore
    
    @audience.setter
    def audience(self, value: str) -> None:
        self._inner_dict['audience'] = value
    
    
    @property
    def algorithm(self) -> str:
        """The JWT signing algorithm required for this provider.
    Prevents algorithm confusion attacks. Common values: RS256, RS384, RS512, PS256, ES256"""
        return self._inner_dict.get('algorithm')  # type: ignore
    
    @algorithm.setter
    def algorithm(self, value: str) -> None:
        self._inner_dict['algorithm'] = value
    
    
    @property
    def userIdClaim(self) -> str:
        """The JWT claim to use as the user identifier for this provider.
    Different providers use different claims (sub, email, preferred_username, etc.)"""
        return self._inner_dict.get('userIdClaim')  # type: ignore
    
    @userIdClaim.setter
    def userIdClaim(self, value: str) -> None:
        self._inner_dict['userIdClaim'] = value
    
    
class OAuthSettingsClass(DictWrapper):
    """Trust oauth providers to use for authentication."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.OAuthSettings")
    def __init__(self,
        providers: List["OAuthProviderClass"],
    ):
        super().__init__()
        
        self.providers = providers
    
    def _restore_defaults(self) -> None:
        self.providers = list()
    
    
    @property
    def providers(self) -> List["OAuthProviderClass"]:
        """Trusted OAuth Providers"""
        return self._inner_dict.get('providers')  # type: ignore
    
    @providers.setter
    def providers(self, value: List["OAuthProviderClass"]) -> None:
        self._inner_dict['providers'] = value
    
    
class OidcSettingsClass(DictWrapper):
    """Settings for OIDC SSO integration."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.OidcSettings")
    def __init__(self,
        enabled: bool,
        clientId: str,
        clientSecret: str,
        discoveryUri: str,
        userNameClaim: Union[None, str]=None,
        userNameClaimRegex: Union[None, str]=None,
        scope: Union[None, str]=None,
        clientAuthenticationMethod: Union[None, str]=None,
        jitProvisioningEnabled: Union[None, bool]=None,
        preProvisioningRequired: Union[None, bool]=None,
        extractGroupsEnabled: Union[None, bool]=None,
        groupsClaim: Union[None, str]=None,
        responseType: Union[None, str]=None,
        responseMode: Union[None, str]=None,
        useNonce: Union[None, bool]=None,
        readTimeout: Union[None, int]=None,
        extractJwtAccessTokenClaims: Union[None, bool]=None,
        preferredJwsAlgorithm: Union[None, str]=None,
        preferredJwsAlgorithm2: Union[None, str]=None,
    ):
        super().__init__()
        
        self.enabled = enabled
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.discoveryUri = discoveryUri
        self.userNameClaim = userNameClaim
        self.userNameClaimRegex = userNameClaimRegex
        self.scope = scope
        self.clientAuthenticationMethod = clientAuthenticationMethod
        self.jitProvisioningEnabled = jitProvisioningEnabled
        self.preProvisioningRequired = preProvisioningRequired
        self.extractGroupsEnabled = extractGroupsEnabled
        self.groupsClaim = groupsClaim
        self.responseType = responseType
        self.responseMode = responseMode
        self.useNonce = useNonce
        self.readTimeout = readTimeout
        self.extractJwtAccessTokenClaims = extractJwtAccessTokenClaims
        self.preferredJwsAlgorithm = preferredJwsAlgorithm
        self.preferredJwsAlgorithm2 = preferredJwsAlgorithm2
    
    def _restore_defaults(self) -> None:
        self.enabled = bool()
        self.clientId = str()
        self.clientSecret = str()
        self.discoveryUri = str()
        self.userNameClaim = self.RECORD_SCHEMA.fields_dict["userNameClaim"].default
        self.userNameClaimRegex = self.RECORD_SCHEMA.fields_dict["userNameClaimRegex"].default
        self.scope = self.RECORD_SCHEMA.fields_dict["scope"].default
        self.clientAuthenticationMethod = self.RECORD_SCHEMA.fields_dict["clientAuthenticationMethod"].default
        self.jitProvisioningEnabled = self.RECORD_SCHEMA.fields_dict["jitProvisioningEnabled"].default
        self.preProvisioningRequired = self.RECORD_SCHEMA.fields_dict["preProvisioningRequired"].default
        self.extractGroupsEnabled = self.RECORD_SCHEMA.fields_dict["extractGroupsEnabled"].default
        self.groupsClaim = self.RECORD_SCHEMA.fields_dict["groupsClaim"].default
        self.responseType = self.RECORD_SCHEMA.fields_dict["responseType"].default
        self.responseMode = self.RECORD_SCHEMA.fields_dict["responseMode"].default
        self.useNonce = self.RECORD_SCHEMA.fields_dict["useNonce"].default
        self.readTimeout = self.RECORD_SCHEMA.fields_dict["readTimeout"].default
        self.extractJwtAccessTokenClaims = self.RECORD_SCHEMA.fields_dict["extractJwtAccessTokenClaims"].default
        self.preferredJwsAlgorithm = self.RECORD_SCHEMA.fields_dict["preferredJwsAlgorithm"].default
        self.preferredJwsAlgorithm2 = self.RECORD_SCHEMA.fields_dict["preferredJwsAlgorithm2"].default
    
    
    @property
    def enabled(self) -> bool:
        """Whether OIDC SSO is enabled."""
        return self._inner_dict.get('enabled')  # type: ignore
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        self._inner_dict['enabled'] = value
    
    
    @property
    def clientId(self) -> str:
        """Unique client id issued by the identity provider."""
        return self._inner_dict.get('clientId')  # type: ignore
    
    @clientId.setter
    def clientId(self, value: str) -> None:
        self._inner_dict['clientId'] = value
    
    
    @property
    def clientSecret(self) -> str:
        """Unique client secret issued by the identity provider."""
        return self._inner_dict.get('clientSecret')  # type: ignore
    
    @clientSecret.setter
    def clientSecret(self, value: str) -> None:
        self._inner_dict['clientSecret'] = value
    
    
    @property
    def discoveryUri(self) -> str:
        """The IdP OIDC discovery url."""
        return self._inner_dict.get('discoveryUri')  # type: ignore
    
    @discoveryUri.setter
    def discoveryUri(self, value: str) -> None:
        self._inner_dict['discoveryUri'] = value
    
    
    @property
    def userNameClaim(self) -> Union[None, str]:
        """ADVANCED. The attribute / claim used to derive the DataHub username. Defaults to "preferred_username"."""
        return self._inner_dict.get('userNameClaim')  # type: ignore
    
    @userNameClaim.setter
    def userNameClaim(self, value: Union[None, str]) -> None:
        self._inner_dict['userNameClaim'] = value
    
    
    @property
    def userNameClaimRegex(self) -> Union[None, str]:
        """ADVANCED. TThe regex used to parse the DataHub username from the user name claim. Defaults to (.*) (all)."""
        return self._inner_dict.get('userNameClaimRegex')  # type: ignore
    
    @userNameClaimRegex.setter
    def userNameClaimRegex(self, value: Union[None, str]) -> None:
        self._inner_dict['userNameClaimRegex'] = value
    
    
    @property
    def scope(self) -> Union[None, str]:
        """ADVANCED. String representing the requested scope from the IdP. Defaults to "oidc email profile"."""
        return self._inner_dict.get('scope')  # type: ignore
    
    @scope.setter
    def scope(self, value: Union[None, str]) -> None:
        self._inner_dict['scope'] = value
    
    
    @property
    def clientAuthenticationMethod(self) -> Union[None, str]:
        """ADVANCED. Which authentication method to use to pass credentials (clientId and clientSecret) to the token endpoint: Defaults to "client_secret_basic"."""
        return self._inner_dict.get('clientAuthenticationMethod')  # type: ignore
    
    @clientAuthenticationMethod.setter
    def clientAuthenticationMethod(self, value: Union[None, str]) -> None:
        self._inner_dict['clientAuthenticationMethod'] = value
    
    
    @property
    def jitProvisioningEnabled(self) -> Union[None, bool]:
        """ADVANCED. Whether DataHub users should be provisioned on login if they do not exist. Defaults to true."""
        return self._inner_dict.get('jitProvisioningEnabled')  # type: ignore
    
    @jitProvisioningEnabled.setter
    def jitProvisioningEnabled(self, value: Union[None, bool]) -> None:
        self._inner_dict['jitProvisioningEnabled'] = value
    
    
    @property
    def preProvisioningRequired(self) -> Union[None, bool]:
        """ADVANCED. Whether the user should already exist in DataHub on login, failing login if they are not. Defaults to false."""
        return self._inner_dict.get('preProvisioningRequired')  # type: ignore
    
    @preProvisioningRequired.setter
    def preProvisioningRequired(self, value: Union[None, bool]) -> None:
        self._inner_dict['preProvisioningRequired'] = value
    
    
    @property
    def extractGroupsEnabled(self) -> Union[None, bool]:
        """ADVANCED. Whether groups should be extracted from a claim in the OIDC profile. Only applies if JIT provisioning is enabled. Groups will be created if they do not exist. Defaults to true."""
        return self._inner_dict.get('extractGroupsEnabled')  # type: ignore
    
    @extractGroupsEnabled.setter
    def extractGroupsEnabled(self, value: Union[None, bool]) -> None:
        self._inner_dict['extractGroupsEnabled'] = value
    
    
    @property
    def groupsClaim(self) -> Union[None, str]:
        """ADVANCED. The OIDC claim to extract groups information from. Defaults to 'groups'."""
        return self._inner_dict.get('groupsClaim')  # type: ignore
    
    @groupsClaim.setter
    def groupsClaim(self, value: Union[None, str]) -> None:
        self._inner_dict['groupsClaim'] = value
    
    
    @property
    def responseType(self) -> Union[None, str]:
        """ADVANCED. Response type."""
        return self._inner_dict.get('responseType')  # type: ignore
    
    @responseType.setter
    def responseType(self, value: Union[None, str]) -> None:
        self._inner_dict['responseType'] = value
    
    
    @property
    def responseMode(self) -> Union[None, str]:
        """ADVANCED. Response mode."""
        return self._inner_dict.get('responseMode')  # type: ignore
    
    @responseMode.setter
    def responseMode(self, value: Union[None, str]) -> None:
        self._inner_dict['responseMode'] = value
    
    
    @property
    def useNonce(self) -> Union[None, bool]:
        """ADVANCED. Use Nonce."""
        return self._inner_dict.get('useNonce')  # type: ignore
    
    @useNonce.setter
    def useNonce(self, value: Union[None, bool]) -> None:
        self._inner_dict['useNonce'] = value
    
    
    @property
    def readTimeout(self) -> Union[None, int]:
        """ADVANCED. Read timeout."""
        return self._inner_dict.get('readTimeout')  # type: ignore
    
    @readTimeout.setter
    def readTimeout(self, value: Union[None, int]) -> None:
        self._inner_dict['readTimeout'] = value
    
    
    @property
    def extractJwtAccessTokenClaims(self) -> Union[None, bool]:
        """ADVANCED. Whether to extract claims from JWT access token.  Defaults to false."""
        return self._inner_dict.get('extractJwtAccessTokenClaims')  # type: ignore
    
    @extractJwtAccessTokenClaims.setter
    def extractJwtAccessTokenClaims(self, value: Union[None, bool]) -> None:
        self._inner_dict['extractJwtAccessTokenClaims'] = value
    
    
    @property
    def preferredJwsAlgorithm(self) -> Union[None, str]:
        """ ADVANCED. Which jws algorithm to use. Unused."""
        return self._inner_dict.get('preferredJwsAlgorithm')  # type: ignore
    
    @preferredJwsAlgorithm.setter
    def preferredJwsAlgorithm(self, value: Union[None, str]) -> None:
        self._inner_dict['preferredJwsAlgorithm'] = value
    
    
    @property
    def preferredJwsAlgorithm2(self) -> Union[None, str]:
        """ ADVANCED. Which jws algorithm to use."""
        return self._inner_dict.get('preferredJwsAlgorithm2')  # type: ignore
    
    @preferredJwsAlgorithm2.setter
    def preferredJwsAlgorithm2(self, value: Union[None, str]) -> None:
        self._inner_dict['preferredJwsAlgorithm2'] = value
    
    
class SampleDataSettingsClass(DictWrapper):
    """Settings related to sample data, used to aid in initial onboarding."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.SampleDataSettings")
    def __init__(self,
        sampleDataStatus: Union[str, "SampleDataStatusClass"],
    ):
        super().__init__()
        
        self.sampleDataStatus = sampleDataStatus
    
    def _restore_defaults(self) -> None:
        self.sampleDataStatus = SampleDataStatusClass.ENABLED
    
    
    @property
    def sampleDataStatus(self) -> Union[str, "SampleDataStatusClass"]:
        """Status of sample data visibility in the platform.
    Controls which types of sample data entities are visible.
    Only applicable for free trial instances."""
        return self._inner_dict.get('sampleDataStatus')  # type: ignore
    
    @sampleDataStatus.setter
    def sampleDataStatus(self, value: Union[str, "SampleDataStatusClass"]) -> None:
        self._inner_dict['sampleDataStatus'] = value
    
    
class SampleDataStatusClass(object):
    # No docs available.
    
    ENABLED = "ENABLED"
    """Sample data is enabled and visible throughout the platform."""
    
    DISABLED = "DISABLED"
    """Sample data is disabled and hidden from the platform."""
    
    
    
class SlackIntegrationSettingsClass(DictWrapper):
    """Slack integration settings."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.SlackIntegrationSettings")
    def __init__(self,
        enabled: Optional[bool]=None,
        encryptedBotToken: Union[None, str]=None,
        defaultChannelName: Union[None, str]=None,
        datahubAtMentionEnabled: Union[None, bool]=None,
    ):
        super().__init__()
        
        if enabled is None:
            # default: True
            self.enabled = self.RECORD_SCHEMA.fields_dict["enabled"].default
        else:
            self.enabled = enabled
        self.encryptedBotToken = encryptedBotToken
        self.defaultChannelName = defaultChannelName
        self.datahubAtMentionEnabled = datahubAtMentionEnabled
    
    def _restore_defaults(self) -> None:
        self.enabled = self.RECORD_SCHEMA.fields_dict["enabled"].default
        self.encryptedBotToken = self.RECORD_SCHEMA.fields_dict["encryptedBotToken"].default
        self.defaultChannelName = self.RECORD_SCHEMA.fields_dict["defaultChannelName"].default
        self.datahubAtMentionEnabled = self.RECORD_SCHEMA.fields_dict["datahubAtMentionEnabled"].default
    
    
    @property
    def enabled(self) -> bool:
        """Whether the slack integration is enabled or not.
    Deprecated! This is no longer used in favor of using the connections abstraction.
    If a connection is present, then this is enabled."""
        return self._inner_dict.get('enabled')  # type: ignore
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        self._inner_dict['enabled'] = value
    
    
    @property
    def encryptedBotToken(self) -> Union[None, str]:
        """An encrypted bot token.
    Deprecated! This is no longer used in favor of using the connections abstraction."""
        return self._inner_dict.get('encryptedBotToken')  # type: ignore
    
    @encryptedBotToken.setter
    def encryptedBotToken(self, value: Union[None, str]) -> None:
        self._inner_dict['encryptedBotToken'] = value
    
    
    @property
    def defaultChannelName(self) -> Union[None, str]:
        """A default slack channel to use."""
        return self._inner_dict.get('defaultChannelName')  # type: ignore
    
    @defaultChannelName.setter
    def defaultChannelName(self, value: Union[None, str]) -> None:
        self._inner_dict['defaultChannelName'] = value
    
    
    @property
    def datahubAtMentionEnabled(self) -> Union[None, bool]:
        """Whether the Slack @DataHub bot mention functionality is enabled.
    If null, use the default value from feature flags."""
        return self._inner_dict.get('datahubAtMentionEnabled')  # type: ignore
    
    @datahubAtMentionEnabled.setter
    def datahubAtMentionEnabled(self, value: Union[None, bool]) -> None:
        self._inner_dict['datahubAtMentionEnabled'] = value
    
    
class SsoSettingsClass(DictWrapper):
    """SSO Integrations, supported on the UI."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.SsoSettings")
    def __init__(self,
        baseUrl: str,
        oidcSettings: Union[None, "OidcSettingsClass"]=None,
    ):
        super().__init__()
        
        self.baseUrl = baseUrl
        self.oidcSettings = oidcSettings
    
    def _restore_defaults(self) -> None:
        self.baseUrl = str()
        self.oidcSettings = self.RECORD_SCHEMA.fields_dict["oidcSettings"].default
    
    
    @property
    def baseUrl(self) -> str:
        """Auth base URL."""
        return self._inner_dict.get('baseUrl')  # type: ignore
    
    @baseUrl.setter
    def baseUrl(self, value: str) -> None:
        self._inner_dict['baseUrl'] = value
    
    
    @property
    def oidcSettings(self) -> Union[None, "OidcSettingsClass"]:
        """Optional OIDC SSO settings."""
        return self._inner_dict.get('oidcSettings')  # type: ignore
    
    @oidcSettings.setter
    def oidcSettings(self, value: Union[None, "OidcSettingsClass"]) -> None:
        self._inner_dict['oidcSettings'] = value
    
    
class TeamsChannelClass(DictWrapper):
    """Teams channel information with cached display name."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.TeamsChannel")
    def __init__(self,
        id: str,
        name: Union[None, str]=None,
        lastUpdated: Union[None, int]=None,
    ):
        super().__init__()
        
        self.id = id
        self.name = name
        self.lastUpdated = lastUpdated
    
    def _restore_defaults(self) -> None:
        self.id = str()
        self.name = self.RECORD_SCHEMA.fields_dict["name"].default
        self.lastUpdated = self.RECORD_SCHEMA.fields_dict["lastUpdated"].default
    
    
    @property
    def id(self) -> str:
        """The Teams channel ID (internal Teams identifier)."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
    @property
    def name(self) -> Union[None, str]:
        """The Teams channel display name (cached value, may be stale)."""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: Union[None, str]) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def lastUpdated(self) -> Union[None, int]:
        """The timestamp when the cached name was last updated.
    Used for TTL-based cache invalidation."""
        return self._inner_dict.get('lastUpdated')  # type: ignore
    
    @lastUpdated.setter
    def lastUpdated(self, value: Union[None, int]) -> None:
        self._inner_dict['lastUpdated'] = value
    
    
class TeamsIntegrationSettingsClass(DictWrapper):
    """Teams integration settings."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.TeamsIntegrationSettings")
    def __init__(self,
        enabled: Optional[bool]=None,
        encryptedBotToken: Union[None, str]=None,
        defaultChannelName: Union[None, str]=None,
        defaultChannel: Union[None, "TeamsChannelClass"]=None,
    ):
        super().__init__()
        
        if enabled is None:
            # default: True
            self.enabled = self.RECORD_SCHEMA.fields_dict["enabled"].default
        else:
            self.enabled = enabled
        self.encryptedBotToken = encryptedBotToken
        self.defaultChannelName = defaultChannelName
        self.defaultChannel = defaultChannel
    
    def _restore_defaults(self) -> None:
        self.enabled = self.RECORD_SCHEMA.fields_dict["enabled"].default
        self.encryptedBotToken = self.RECORD_SCHEMA.fields_dict["encryptedBotToken"].default
        self.defaultChannelName = self.RECORD_SCHEMA.fields_dict["defaultChannelName"].default
        self.defaultChannel = self.RECORD_SCHEMA.fields_dict["defaultChannel"].default
    
    
    @property
    def enabled(self) -> bool:
        """Whether the Teams integration is enabled or not.
    Deprecated! This is no longer used in favor of using the connections abstraction.
    If a connection is present, then this is enabled."""
        return self._inner_dict.get('enabled')  # type: ignore
    
    @enabled.setter
    def enabled(self, value: bool) -> None:
        self._inner_dict['enabled'] = value
    
    
    @property
    def encryptedBotToken(self) -> Union[None, str]:
        """An encrypted bot token.
    Deprecated! This is no longer used in favor of using the connections abstraction."""
        return self._inner_dict.get('encryptedBotToken')  # type: ignore
    
    @encryptedBotToken.setter
    def encryptedBotToken(self, value: Union[None, str]) -> None:
        self._inner_dict['encryptedBotToken'] = value
    
    
    @property
    def defaultChannelName(self) -> Union[None, str]:
        """A default Teams channel to use.
    Deprecated! Use defaultChannel instead."""
        return self._inner_dict.get('defaultChannelName')  # type: ignore
    
    @defaultChannelName.setter
    def defaultChannelName(self, value: Union[None, str]) -> None:
        self._inner_dict['defaultChannelName'] = value
    
    
    @property
    def defaultChannel(self) -> Union[None, "TeamsChannelClass"]:
        """A default Teams channel to route notifications to."""
        return self._inner_dict.get('defaultChannel')  # type: ignore
    
    @defaultChannel.setter
    def defaultChannel(self, value: Union[None, "TeamsChannelClass"]) -> None:
        self._inner_dict['defaultChannel'] = value
    
    
class TeamsUserClass(DictWrapper):
    """Teams user information with cached display name and multiple ID support.
    Follows the same caching pattern as TeamsChannel for consistency."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.settings.global.TeamsUser")
    def __init__(self,
        teamsUserId: Union[None, str]=None,
        azureUserId: Union[None, str]=None,
        email: Union[None, str]=None,
        displayName: Union[None, str]=None,
        lastUpdated: Union[None, int]=None,
    ):
        super().__init__()
        
        self.teamsUserId = teamsUserId
        self.azureUserId = azureUserId
        self.email = email
        self.displayName = displayName
        self.lastUpdated = lastUpdated
    
    def _restore_defaults(self) -> None:
        self.teamsUserId = self.RECORD_SCHEMA.fields_dict["teamsUserId"].default
        self.azureUserId = self.RECORD_SCHEMA.fields_dict["azureUserId"].default
        self.email = self.RECORD_SCHEMA.fields_dict["email"].default
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.lastUpdated = self.RECORD_SCHEMA.fields_dict["lastUpdated"].default
    
    
    @property
    def teamsUserId(self) -> Union[None, str]:
        """The Teams user ID (internal Teams identifier).
    This is the primary identifier used for Teams messaging."""
        return self._inner_dict.get('teamsUserId')  # type: ignore
    
    @teamsUserId.setter
    def teamsUserId(self, value: Union[None, str]) -> None:
        self._inner_dict['teamsUserId'] = value
    
    
    @property
    def azureUserId(self) -> Union[None, str]:
        """The Azure AD user ID (Azure Active Directory object ID).
    This is the primary identifier for Azure AD operations and Microsoft Graph API calls."""
        return self._inner_dict.get('azureUserId')  # type: ignore
    
    @azureUserId.setter
    def azureUserId(self, value: Union[None, str]) -> None:
        self._inner_dict['azureUserId'] = value
    
    
    @property
    def email(self) -> Union[None, str]:
        """The user's email address (fallback identifier).
    Used when other IDs are not available or for email-based user resolution."""
        return self._inner_dict.get('email')  # type: ignore
    
    @email.setter
    def email(self, value: Union[None, str]) -> None:
        self._inner_dict['email'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """The user's display name (cached value, may be stale).
    Retrieved from Microsoft Graph API and cached for performance."""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def lastUpdated(self) -> Union[None, int]:
        """The timestamp when the cached display name was last updated.
    Used for TTL-based cache invalidation (milliseconds since epoch)."""
        return self._inner_dict.get('lastUpdated')  # type: ignore
    
    @lastUpdated.setter
    def lastUpdated(self, value: Union[None, int]) -> None:
        self._inner_dict['lastUpdated'] = value
    
    
class DataHubStepStatePropertiesClass(_Aspect):
    """The properties associated with a DataHub step state"""


    ASPECT_NAME = 'dataHubStepStateProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.step.DataHubStepStateProperties")

    def __init__(self,
        lastModified: "AuditStampClass",
        properties: Optional[Dict[str, str]]=None,
    ):
        super().__init__()
        
        if properties is None:
            # default: {}
            self.properties = dict()
        else:
            self.properties = properties
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.properties = dict()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def properties(self) -> Dict[str, str]:
        """Description of the secret"""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: Dict[str, str]) -> None:
        self._inner_dict['properties'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp describing the last person to update it."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class PropertyCardinalityClass(object):
    # No docs available.
    
    SINGLE = "SINGLE"
    MULTIPLE = "MULTIPLE"
    
    
class PropertyValueClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.structured.PropertyValue")
    def __init__(self,
        value: Union[str, float],
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.value = value
        self.description = description
    
    def _restore_defaults(self) -> None:
        self.value = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
    
    
    @property
    def value(self) -> Union[str, float]:
        # No docs available.
        return self._inner_dict.get('value')  # type: ignore
    
    @value.setter
    def value(self, value: Union[str, float]) -> None:
        self._inner_dict['value'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Optional description of the property value"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
class StructuredPropertiesClass(_Aspect):
    """Properties about an entity governed by StructuredPropertyDefinition"""


    ASPECT_NAME = 'structuredProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.structured.StructuredProperties")

    def __init__(self,
        properties: List["StructuredPropertyValueAssignmentClass"],
    ):
        super().__init__()
        
        self.properties = properties
    
    def _restore_defaults(self) -> None:
        self.properties = list()
    
    
    @property
    def properties(self) -> List["StructuredPropertyValueAssignmentClass"]:
        """Custom property bag."""
        return self._inner_dict.get('properties')  # type: ignore
    
    @properties.setter
    def properties(self, value: List["StructuredPropertyValueAssignmentClass"]) -> None:
        self._inner_dict['properties'] = value
    
    
class StructuredPropertyDefinitionClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'propertyDefinition'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.structured.StructuredPropertyDefinition")

    def __init__(self,
        qualifiedName: str,
        valueType: str,
        entityTypes: List[str],
        displayName: Union[None, str]=None,
        typeQualifier: Union[None, Dict[str, List[str]]]=None,
        allowedValues: Union[None, List["PropertyValueClass"]]=None,
        cardinality: Optional[Union[Union[str, "PropertyCardinalityClass"], None]]=None,
        description: Union[None, str]=None,
        searchConfiguration: Union[None, "DataHubSearchConfigClass"]=None,
        immutable: Optional[bool]=None,
        version: Union[None, str]=None,
        created: Union[None, "AuditStampClass"]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
        filterStatus: Optional[Union[Union[str, "StructuredPropertyFilterStatusClass"], None]]=None,
    ):
        super().__init__()
        
        self.qualifiedName = qualifiedName
        self.displayName = displayName
        self.valueType = valueType
        self.typeQualifier = typeQualifier
        self.allowedValues = allowedValues
        if cardinality is None:
            # default: 'SINGLE'
            self.cardinality = self.RECORD_SCHEMA.fields_dict["cardinality"].default
        else:
            self.cardinality = cardinality
        self.entityTypes = entityTypes
        self.description = description
        self.searchConfiguration = searchConfiguration
        if immutable is None:
            # default: False
            self.immutable = self.RECORD_SCHEMA.fields_dict["immutable"].default
        else:
            self.immutable = immutable
        self.version = version
        self.created = created
        self.lastModified = lastModified
        if filterStatus is None:
            # default: 'DISABLED'
            self.filterStatus = self.RECORD_SCHEMA.fields_dict["filterStatus"].default
        else:
            self.filterStatus = filterStatus
    
    def _restore_defaults(self) -> None:
        self.qualifiedName = str()
        self.displayName = self.RECORD_SCHEMA.fields_dict["displayName"].default
        self.valueType = str()
        self.typeQualifier = self.RECORD_SCHEMA.fields_dict["typeQualifier"].default
        self.allowedValues = self.RECORD_SCHEMA.fields_dict["allowedValues"].default
        self.cardinality = self.RECORD_SCHEMA.fields_dict["cardinality"].default
        self.entityTypes = list()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.searchConfiguration = self.RECORD_SCHEMA.fields_dict["searchConfiguration"].default
        self.immutable = self.RECORD_SCHEMA.fields_dict["immutable"].default
        self.version = self.RECORD_SCHEMA.fields_dict["version"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.filterStatus = self.RECORD_SCHEMA.fields_dict["filterStatus"].default
    
    
    @property
    def qualifiedName(self) -> str:
        """The fully qualified name of the property. e.g. io.acryl.datahub.myProperty"""
        return self._inner_dict.get('qualifiedName')  # type: ignore
    
    @qualifiedName.setter
    def qualifiedName(self, value: str) -> None:
        self._inner_dict['qualifiedName'] = value
    
    
    @property
    def displayName(self) -> Union[None, str]:
        """The display name of the property. This is the name that will be shown in the UI and can be used to look up the property id."""
        return self._inner_dict.get('displayName')  # type: ignore
    
    @displayName.setter
    def displayName(self, value: Union[None, str]) -> None:
        self._inner_dict['displayName'] = value
    
    
    @property
    def valueType(self) -> str:
        """The value type of the property. Must be a dataType.
    e.g. To indicate that the property is of type DATE, use urn:li:dataType:datahub.date"""
        return self._inner_dict.get('valueType')  # type: ignore
    
    @valueType.setter
    def valueType(self, value: str) -> None:
        self._inner_dict['valueType'] = value
    
    
    @property
    def typeQualifier(self) -> Union[None, Dict[str, List[str]]]:
        """A map that allows for type specialization of the valueType.
    e.g. a valueType of urn:li:dataType:datahub.urn
    can be specialized to be a USER or GROUP URN by adding a typeQualifier like 
    { "allowedTypes": ["urn:li:entityType:datahub.corpuser", "urn:li:entityType:datahub.corpGroup"] }"""
        return self._inner_dict.get('typeQualifier')  # type: ignore
    
    @typeQualifier.setter
    def typeQualifier(self, value: Union[None, Dict[str, List[str]]]) -> None:
        self._inner_dict['typeQualifier'] = value
    
    
    @property
    def allowedValues(self) -> Union[None, List["PropertyValueClass"]]:
        """A list of allowed values that the property is allowed to take. 
    If this is not specified, then the property can take any value of given type."""
        return self._inner_dict.get('allowedValues')  # type: ignore
    
    @allowedValues.setter
    def allowedValues(self, value: Union[None, List["PropertyValueClass"]]) -> None:
        self._inner_dict['allowedValues'] = value
    
    
    @property
    def cardinality(self) -> Union[Union[str, "PropertyCardinalityClass"], None]:
        """The cardinality of the property. If not specified, then the property is assumed to be single valued.."""
        return self._inner_dict.get('cardinality')  # type: ignore
    
    @cardinality.setter
    def cardinality(self, value: Union[Union[str, "PropertyCardinalityClass"], None]) -> None:
        self._inner_dict['cardinality'] = value
    
    
    @property
    def entityTypes(self) -> List[str]:
        # No docs available.
        return self._inner_dict.get('entityTypes')  # type: ignore
    
    @entityTypes.setter
    def entityTypes(self, value: List[str]) -> None:
        self._inner_dict['entityTypes'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """The description of the property. This is the description that will be shown in the UI."""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def searchConfiguration(self) -> Union[None, "DataHubSearchConfigClass"]:
        """Search configuration for this property. If not specified, then the property is indexed using the default mapping.
    from the logical type."""
        return self._inner_dict.get('searchConfiguration')  # type: ignore
    
    @searchConfiguration.setter
    def searchConfiguration(self, value: Union[None, "DataHubSearchConfigClass"]) -> None:
        self._inner_dict['searchConfiguration'] = value
    
    
    @property
    def immutable(self) -> bool:
        """Whether the structured property value is immutable once applied to an entity."""
        return self._inner_dict.get('immutable')  # type: ignore
    
    @immutable.setter
    def immutable(self, value: bool) -> None:
        self._inner_dict['immutable'] = value
    
    
    @property
    def version(self) -> Union[None, str]:
        """Definition version - Allows breaking schema changes. String is compared case-insensitive and new
                         versions must be monotonically increasing. Cannot use periods/dots.
                         Suggestions: v1, v2
                                      20240610, 20240611"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: Union[None, str]) -> None:
        self._inner_dict['version'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """Last Modified Audit stamp"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def filterStatus(self) -> Union[Union[str, "StructuredPropertyFilterStatusClass"], None]:
        """The filter status of this structured property - whether it will show up in search filters or not
    Deprecated! Use structuredPropertySettings.showInSearchFilters instead"""
        return self._inner_dict.get('filterStatus')  # type: ignore
    
    @filterStatus.setter
    def filterStatus(self, value: Union[Union[str, "StructuredPropertyFilterStatusClass"], None]) -> None:
        self._inner_dict['filterStatus'] = value
    
    
class StructuredPropertyFilterStatusClass(object):
    # No docs available.
    
    ENABLED = "ENABLED"
    """This structured property will show up in search filters"""
    
    DISABLED = "DISABLED"
    """This structured property will not show up in search filters"""
    
    
    
class StructuredPropertyKeyClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'structuredPropertyKey'
    ASPECT_INFO = {'keyForEntity': 'structuredProperty', 'entityCategory': 'core', 'entityAspects': ['propertyDefinition', 'structuredPropertySettings', 'institutionalMemory', 'status', 'share', 'origin'], 'entityDoc': 'Structured Property represents a property meant for extending the core model of a logical entity'}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.structured.StructuredPropertyKey")

    def __init__(self,
        id: str,
    ):
        super().__init__()
        
        self.id = id
    
    def _restore_defaults(self) -> None:
        self.id = str()
    
    
    @property
    def id(self) -> str:
        """The id for a structured proeprty."""
        return self._inner_dict.get('id')  # type: ignore
    
    @id.setter
    def id(self, value: str) -> None:
        self._inner_dict['id'] = value
    
    
class StructuredPropertySettingsClass(_Aspect):
    """Settings specific to a structured property entity"""


    ASPECT_NAME = 'structuredPropertySettings'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.structured.StructuredPropertySettings")

    def __init__(self,
        isHidden: Optional[bool]=None,
        showInSearchFilters: Optional[bool]=None,
        showInAssetSummary: Optional[bool]=None,
        hideInAssetSummaryWhenEmpty: Optional[bool]=None,
        showAsAssetBadge: Optional[bool]=None,
        showInColumnsTable: Optional[bool]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        if isHidden is None:
            # default: False
            self.isHidden = self.RECORD_SCHEMA.fields_dict["isHidden"].default
        else:
            self.isHidden = isHidden
        if showInSearchFilters is None:
            # default: False
            self.showInSearchFilters = self.RECORD_SCHEMA.fields_dict["showInSearchFilters"].default
        else:
            self.showInSearchFilters = showInSearchFilters
        if showInAssetSummary is None:
            # default: False
            self.showInAssetSummary = self.RECORD_SCHEMA.fields_dict["showInAssetSummary"].default
        else:
            self.showInAssetSummary = showInAssetSummary
        if hideInAssetSummaryWhenEmpty is None:
            # default: False
            self.hideInAssetSummaryWhenEmpty = self.RECORD_SCHEMA.fields_dict["hideInAssetSummaryWhenEmpty"].default
        else:
            self.hideInAssetSummaryWhenEmpty = hideInAssetSummaryWhenEmpty
        if showAsAssetBadge is None:
            # default: False
            self.showAsAssetBadge = self.RECORD_SCHEMA.fields_dict["showAsAssetBadge"].default
        else:
            self.showAsAssetBadge = showAsAssetBadge
        if showInColumnsTable is None:
            # default: False
            self.showInColumnsTable = self.RECORD_SCHEMA.fields_dict["showInColumnsTable"].default
        else:
            self.showInColumnsTable = showInColumnsTable
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.isHidden = self.RECORD_SCHEMA.fields_dict["isHidden"].default
        self.showInSearchFilters = self.RECORD_SCHEMA.fields_dict["showInSearchFilters"].default
        self.showInAssetSummary = self.RECORD_SCHEMA.fields_dict["showInAssetSummary"].default
        self.hideInAssetSummaryWhenEmpty = self.RECORD_SCHEMA.fields_dict["hideInAssetSummaryWhenEmpty"].default
        self.showAsAssetBadge = self.RECORD_SCHEMA.fields_dict["showAsAssetBadge"].default
        self.showInColumnsTable = self.RECORD_SCHEMA.fields_dict["showInColumnsTable"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
    
    
    @property
    def isHidden(self) -> bool:
        """Whether or not this asset should be hidden in the main application"""
        return self._inner_dict.get('isHidden')  # type: ignore
    
    @isHidden.setter
    def isHidden(self, value: bool) -> None:
        self._inner_dict['isHidden'] = value
    
    
    @property
    def showInSearchFilters(self) -> bool:
        """Whether or not this asset should be displayed as a search filter"""
        return self._inner_dict.get('showInSearchFilters')  # type: ignore
    
    @showInSearchFilters.setter
    def showInSearchFilters(self, value: bool) -> None:
        self._inner_dict['showInSearchFilters'] = value
    
    
    @property
    def showInAssetSummary(self) -> bool:
        """Whether or not this asset should be displayed in the asset sidebar"""
        return self._inner_dict.get('showInAssetSummary')  # type: ignore
    
    @showInAssetSummary.setter
    def showInAssetSummary(self, value: bool) -> None:
        self._inner_dict['showInAssetSummary'] = value
    
    
    @property
    def hideInAssetSummaryWhenEmpty(self) -> bool:
        """Whether or not this asset should be hidden in the asset sidebar (showInAssetSummary should be enabled)
    when its value is empty"""
        return self._inner_dict.get('hideInAssetSummaryWhenEmpty')  # type: ignore
    
    @hideInAssetSummaryWhenEmpty.setter
    def hideInAssetSummaryWhenEmpty(self, value: bool) -> None:
        self._inner_dict['hideInAssetSummaryWhenEmpty'] = value
    
    
    @property
    def showAsAssetBadge(self) -> bool:
        """Whether or not this asset should be displayed as an asset badge on other
    asset's headers"""
        return self._inner_dict.get('showAsAssetBadge')  # type: ignore
    
    @showAsAssetBadge.setter
    def showAsAssetBadge(self, value: bool) -> None:
        self._inner_dict['showAsAssetBadge'] = value
    
    
    @property
    def showInColumnsTable(self) -> bool:
        """Whether or not this asset should be displayed as a column in the schema field table
    in a Dataset's "Columns" tab."""
        return self._inner_dict.get('showInColumnsTable')  # type: ignore
    
    @showInColumnsTable.setter
    def showInColumnsTable(self, value: bool) -> None:
        self._inner_dict['showInColumnsTable'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """Last Modified Audit stamp"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
class StructuredPropertyValueAssignmentClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.structured.StructuredPropertyValueAssignment")
    def __init__(self,
        propertyUrn: str,
        values: List[Union[str, float]],
        created: Union[None, "AuditStampClass"]=None,
        lastModified: Union[None, "AuditStampClass"]=None,
        attribution: Union[None, "MetadataAttributionClass"]=None,
    ):
        super().__init__()
        
        self.propertyUrn = propertyUrn
        self.values = values
        self.created = created
        self.lastModified = lastModified
        self.attribution = attribution
    
    def _restore_defaults(self) -> None:
        self.propertyUrn = str()
        self.values = list()
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastModified = self.RECORD_SCHEMA.fields_dict["lastModified"].default
        self.attribution = self.RECORD_SCHEMA.fields_dict["attribution"].default
    
    
    @property
    def propertyUrn(self) -> str:
        """The property that is being assigned a value."""
        return self._inner_dict.get('propertyUrn')  # type: ignore
    
    @propertyUrn.setter
    def propertyUrn(self, value: str) -> None:
        self._inner_dict['propertyUrn'] = value
    
    
    @property
    def values(self) -> List[Union[str, float]]:
        """The value assigned to the property."""
        return self._inner_dict.get('values')  # type: ignore
    
    @values.setter
    def values(self, value: List[Union[str, float]]) -> None:
        self._inner_dict['values'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp containing who created this relationship edge and when"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> Union[None, "AuditStampClass"]:
        """Audit stamp containing who last modified this relationship edge and when"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastModified'] = value
    
    
    @property
    def attribution(self) -> Union[None, "MetadataAttributionClass"]:
        """Information about who, why, and how this metadata was applied"""
        return self._inner_dict.get('attribution')  # type: ignore
    
    @attribution.setter
    def attribution(self, value: Union[None, "MetadataAttributionClass"]) -> None:
        self._inner_dict['attribution'] = value
    
    
class EntityChangeDetailsClass(DictWrapper):
    """Details involving an EntityChangeType. Used by Subscriptions to determine which
    change types should trigger a notification."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.subscription.EntityChangeDetails")
    def __init__(self,
        entityChangeType: Union[str, "EntityChangeTypeClass"],
        filter: Union[None, "EntityChangeDetailsFilterClass"]=None,
    ):
        super().__init__()
        
        self.entityChangeType = entityChangeType
        self.filter = filter
    
    def _restore_defaults(self) -> None:
        self.entityChangeType = EntityChangeTypeClass.OPERATION_COLUMN_ADDED
        self.filter = self.RECORD_SCHEMA.fields_dict["filter"].default
    
    
    @property
    def entityChangeType(self) -> Union[str, "EntityChangeTypeClass"]:
        """Change type that triggers a notification for the subscription."""
        return self._inner_dict.get('entityChangeType')  # type: ignore
    
    @entityChangeType.setter
    def entityChangeType(self, value: Union[str, "EntityChangeTypeClass"]) -> None:
        self._inner_dict['entityChangeType'] = value
    
    
    @property
    def filter(self) -> Union[None, "EntityChangeDetailsFilterClass"]:
        """Optional filter that can be applied to exclude or include specific entity change events"""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: Union[None, "EntityChangeDetailsFilterClass"]) -> None:
        self._inner_dict['filter'] = value
    
    
class EntityChangeDetailsFilterClass(DictWrapper):
    """Details for filtering notifications relating to an EntityChangeType. Used by Subscriptions to determine how to
    filter out change types when triggering a notification."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.subscription.EntityChangeDetailsFilter")
    def __init__(self,
        includeAssertions: Union[None, List[str]]=None,
    ):
        super().__init__()
        
        self.includeAssertions = includeAssertions
    
    def _restore_defaults(self) -> None:
        self.includeAssertions = self.RECORD_SCHEMA.fields_dict["includeAssertions"].default
    
    
    @property
    def includeAssertions(self) -> Union[None, List[str]]:
        """A list of assertions to inclusively filter when generating notifications.
    Used for EntityChangeType values of ASSERTION_PASSED, ASSERTION_FAILED, ASSERTION_ERROR.
    Effectively allows for 'assertion level subscriptions'"""
        return self._inner_dict.get('includeAssertions')  # type: ignore
    
    @includeAssertions.setter
    def includeAssertions(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['includeAssertions'] = value
    
    
class EntityChangeTypeClass(object):
    """Enum to define change types that can trigger a notification for a subscription."""
    
    OPERATION_COLUMN_ADDED = "OPERATION_COLUMN_ADDED"
    """Schema changes."""
    
    OPERATION_COLUMN_REMOVED = "OPERATION_COLUMN_REMOVED"
    
    OPERATION_COLUMN_MODIFIED = "OPERATION_COLUMN_MODIFIED"
    
    OPERATION_ROWS_INSERTED = "OPERATION_ROWS_INSERTED"
    """Operational metadata changes."""
    
    OPERATION_ROWS_UPDATED = "OPERATION_ROWS_UPDATED"
    
    OPERATION_ROWS_REMOVED = "OPERATION_ROWS_REMOVED"
    
    ASSERTION_PASSED = "ASSERTION_PASSED"
    """Assertion run event created with specified states."""
    
    ASSERTION_FAILED = "ASSERTION_FAILED"
    
    ASSERTION_ERROR = "ASSERTION_ERROR"
    
    INCIDENT_RAISED = "INCIDENT_RAISED"
    """Incident status changes."""
    
    INCIDENT_RESOLVED = "INCIDENT_RESOLVED"
    
    TEST_PASSED = "TEST_PASSED"
    """Test status changes."""
    
    TEST_FAILED = "TEST_FAILED"
    
    DEPRECATED = "DEPRECATED"
    """Deprecation status changes."""
    
    UNDEPRECATED = "UNDEPRECATED"
    
    INGESTION_SUCCEEDED = "INGESTION_SUCCEEDED"
    """Ingestion status changes."""
    
    INGESTION_FAILED = "INGESTION_FAILED"
    
    DOCUMENTATION_CHANGE = "DOCUMENTATION_CHANGE"
    """Documentation change."""
    
    OWNER_ADDED = "OWNER_ADDED"
    """Ownership changes. Added or removed."""
    
    OWNER_REMOVED = "OWNER_REMOVED"
    
    GLOSSARY_TERM_ADDED = "GLOSSARY_TERM_ADDED"
    """Glossary term changes. Added, removed or proposed."""
    
    GLOSSARY_TERM_REMOVED = "GLOSSARY_TERM_REMOVED"
    
    GLOSSARY_TERM_PROPOSED = "GLOSSARY_TERM_PROPOSED"
    
    TAG_ADDED = "TAG_ADDED"
    """Tag changes. Added, removed or proposed."""
    
    TAG_REMOVED = "TAG_REMOVED"
    
    TAG_PROPOSED = "TAG_PROPOSED"
    
    
    
class SubscriptionInfoClass(_Aspect):
    """Subscription info."""


    ASPECT_NAME = 'subscriptionInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.subscription.SubscriptionInfo")

    def __init__(self,
        actorUrn: str,
        actorType: str,
        types: List[Union[str, "SubscriptionTypeClass"]],
        createdOn: "AuditStampClass",
        updatedOn: "AuditStampClass",
        entityUrn: Union[None, str]=None,
        entityChangeTypes: Union[None, List["EntityChangeDetailsClass"]]=None,
        notificationConfig: Union[None, "SubscriptionNotificationConfigClass"]=None,
    ):
        super().__init__()
        
        self.actorUrn = actorUrn
        self.actorType = actorType
        self.types = types
        self.createdOn = createdOn
        self.updatedOn = updatedOn
        self.entityUrn = entityUrn
        self.entityChangeTypes = entityChangeTypes
        self.notificationConfig = notificationConfig
    
    def _restore_defaults(self) -> None:
        self.actorUrn = str()
        self.actorType = str()
        self.types = list()
        self.createdOn = AuditStampClass._construct_with_defaults()
        self.updatedOn = AuditStampClass._construct_with_defaults()
        self.entityUrn = self.RECORD_SCHEMA.fields_dict["entityUrn"].default
        self.entityChangeTypes = self.RECORD_SCHEMA.fields_dict["entityChangeTypes"].default
        self.notificationConfig = self.RECORD_SCHEMA.fields_dict["notificationConfig"].default
    
    
    @property
    def actorUrn(self) -> str:
        """Actor Urn who will be notified """
        return self._inner_dict.get('actorUrn')  # type: ignore
    
    @actorUrn.setter
    def actorUrn(self, value: str) -> None:
        self._inner_dict['actorUrn'] = value
    
    
    @property
    def actorType(self) -> str:
        """Actor type"""
        return self._inner_dict.get('actorType')  # type: ignore
    
    @actorType.setter
    def actorType(self, value: str) -> None:
        self._inner_dict['actorType'] = value
    
    
    @property
    def types(self) -> List[Union[str, "SubscriptionTypeClass"]]:
        """The subscription types."""
        return self._inner_dict.get('types')  # type: ignore
    
    @types.setter
    def types(self, value: List[Union[str, "SubscriptionTypeClass"]]) -> None:
        self._inner_dict['types'] = value
    
    
    @property
    def createdOn(self) -> "AuditStampClass":
        """AuditStamp for when the subscription was created"""
        return self._inner_dict.get('createdOn')  # type: ignore
    
    @createdOn.setter
    def createdOn(self, value: "AuditStampClass") -> None:
        self._inner_dict['createdOn'] = value
    
    
    @property
    def updatedOn(self) -> "AuditStampClass":
        """AuditStamp for when the subscription was updated"""
        return self._inner_dict.get('updatedOn')  # type: ignore
    
    @updatedOn.setter
    def updatedOn(self, value: "AuditStampClass") -> None:
        self._inner_dict['updatedOn'] = value
    
    
    @property
    def entityUrn(self) -> Union[None, str]:
        """Optional entity Urn - top level for now (Dataset, container etc. )"""
        return self._inner_dict.get('entityUrn')  # type: ignore
    
    @entityUrn.setter
    def entityUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['entityUrn'] = value
    
    
    @property
    def entityChangeTypes(self) -> Union[None, List["EntityChangeDetailsClass"]]:
        """Change types that trigger a notification for the subscription."""
        return self._inner_dict.get('entityChangeTypes')  # type: ignore
    
    @entityChangeTypes.setter
    def entityChangeTypes(self, value: Union[None, List["EntityChangeDetailsClass"]]) -> None:
        self._inner_dict['entityChangeTypes'] = value
    
    
    @property
    def notificationConfig(self) -> Union[None, "SubscriptionNotificationConfigClass"]:
        """Optional notification config."""
        return self._inner_dict.get('notificationConfig')  # type: ignore
    
    @notificationConfig.setter
    def notificationConfig(self, value: Union[None, "SubscriptionNotificationConfigClass"]) -> None:
        self._inner_dict['notificationConfig'] = value
    
    
class SubscriptionNotificationConfigClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.subscription.SubscriptionNotificationConfig")
    def __init__(self,
        notificationSettings: Union[None, "NotificationSettingsClass"]=None,
    ):
        super().__init__()
        
        self.notificationSettings = notificationSettings
    
    def _restore_defaults(self) -> None:
        self.notificationSettings = self.RECORD_SCHEMA.fields_dict["notificationSettings"].default
    
    
    @property
    def notificationSettings(self) -> Union[None, "NotificationSettingsClass"]:
        """Notification settings for the subscription."""
        return self._inner_dict.get('notificationSettings')  # type: ignore
    
    @notificationSettings.setter
    def notificationSettings(self, value: Union[None, "NotificationSettingsClass"]) -> None:
        self._inner_dict['notificationSettings'] = value
    
    
class SubscriptionTypeClass(object):
    """Enum to define the different types of subscriptions."""
    
    ENTITY_CHANGE = "ENTITY_CHANGE"
    """Triggered via direct changes on an entity."""
    
    UPSTREAM_ENTITY_CHANGE = "UPSTREAM_ENTITY_CHANGE"
    """Triggered via upstream changes on an entity."""
    
    
    
class TagPropertiesClass(_Aspect):
    """Properties associated with a Tag"""


    ASPECT_NAME = 'tagProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.tag.TagProperties")

    def __init__(self,
        name: str,
        description: Union[None, str]=None,
        colorHex: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.description = description
        self.colorHex = colorHex
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.colorHex = self.RECORD_SCHEMA.fields_dict["colorHex"].default
    
    
    @property
    def name(self) -> str:
        """Display name of the tag"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Documentation of the tag"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def colorHex(self) -> Union[None, str]:
        """The color associated with the Tag in Hex. For example #FFFFFF."""
        return self._inner_dict.get('colorHex')  # type: ignore
    
    @colorHex.setter
    def colorHex(self, value: Union[None, str]) -> None:
        self._inner_dict['colorHex'] = value
    
    
class TelemetryClientIdClass(_Aspect):
    """A simple wrapper around a String to persist the client ID for telemetry in DataHub's backend DB"""


    ASPECT_NAME = 'telemetryClientId'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.telemetry.TelemetryClientId")

    def __init__(self,
        clientId: str,
    ):
        super().__init__()
        
        self.clientId = clientId
    
    def _restore_defaults(self) -> None:
        self.clientId = str()
    
    
    @property
    def clientId(self) -> str:
        """A string representing the telemetry client ID"""
        return self._inner_dict.get('clientId')  # type: ignore
    
    @clientId.setter
    def clientId(self, value: str) -> None:
        self._inner_dict['clientId'] = value
    
    
class DataHubPageTemplateAssetSummaryClass(DictWrapper):
    """The page template info for asset summaries"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.template.DataHubPageTemplateAssetSummary")
    def __init__(self,
        summaryElements: Union[None, List["SummaryElementClass"]]=None,
    ):
        super().__init__()
        
        self.summaryElements = summaryElements
    
    def _restore_defaults(self) -> None:
        self.summaryElements = self.RECORD_SCHEMA.fields_dict["summaryElements"].default
    
    
    @property
    def summaryElements(self) -> Union[None, List["SummaryElementClass"]]:
        """The optional list of properties shown on an asset summary page header."""
        return self._inner_dict.get('summaryElements')  # type: ignore
    
    @summaryElements.setter
    def summaryElements(self, value: Union[None, List["SummaryElementClass"]]) -> None:
        self._inner_dict['summaryElements'] = value
    
    
class DataHubPageTemplatePropertiesClass(_Aspect):
    """The main properties of a DataHub page template"""


    ASPECT_NAME = 'dataHubPageTemplateProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.template.DataHubPageTemplateProperties")

    def __init__(self,
        rows: List["DataHubPageTemplateRowClass"],
        surface: "DataHubPageTemplateSurfaceClass",
        visibility: "DataHubPageTemplateVisibilityClass",
        created: "AuditStampClass",
        lastModified: "AuditStampClass",
        assetSummary: Union[None, "DataHubPageTemplateAssetSummaryClass"]=None,
    ):
        super().__init__()
        
        self.rows = rows
        self.assetSummary = assetSummary
        self.surface = surface
        self.visibility = visibility
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.rows = list()
        self.assetSummary = self.RECORD_SCHEMA.fields_dict["assetSummary"].default
        self.surface = DataHubPageTemplateSurfaceClass._construct_with_defaults()
        self.visibility = DataHubPageTemplateVisibilityClass._construct_with_defaults()
        self.created = AuditStampClass._construct_with_defaults()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def rows(self) -> List["DataHubPageTemplateRowClass"]:
        """The rows of modules contained in this template"""
        return self._inner_dict.get('rows')  # type: ignore
    
    @rows.setter
    def rows(self, value: List["DataHubPageTemplateRowClass"]) -> None:
        self._inner_dict['rows'] = value
    
    
    @property
    def assetSummary(self) -> Union[None, "DataHubPageTemplateAssetSummaryClass"]:
        """The optional info for asset summaries. Should be populated if surfaceType is ASSET_SUMMARY"""
        return self._inner_dict.get('assetSummary')  # type: ignore
    
    @assetSummary.setter
    def assetSummary(self, value: Union[None, "DataHubPageTemplateAssetSummaryClass"]) -> None:
        self._inner_dict['assetSummary'] = value
    
    
    @property
    def surface(self) -> "DataHubPageTemplateSurfaceClass":
        """Info about the surface area of the product that this template is deployed in"""
        return self._inner_dict.get('surface')  # type: ignore
    
    @surface.setter
    def surface(self, value: "DataHubPageTemplateSurfaceClass") -> None:
        self._inner_dict['surface'] = value
    
    
    @property
    def visibility(self) -> "DataHubPageTemplateVisibilityClass":
        """Info about the visibility of this template"""
        return self._inner_dict.get('visibility')  # type: ignore
    
    @visibility.setter
    def visibility(self, value: "DataHubPageTemplateVisibilityClass") -> None:
        self._inner_dict['visibility'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp for when and by whom this template was created"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp for when and by whom this template was last updated"""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class DataHubPageTemplateRowClass(DictWrapper):
    """A row of modules contained in a template"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.template.DataHubPageTemplateRow")
    def __init__(self,
        modules: List[str],
    ):
        super().__init__()
        
        self.modules = modules
    
    def _restore_defaults(self) -> None:
        self.modules = list()
    
    
    @property
    def modules(self) -> List[str]:
        """The modules that exist in this template row"""
        return self._inner_dict.get('modules')  # type: ignore
    
    @modules.setter
    def modules(self, value: List[str]) -> None:
        self._inner_dict['modules'] = value
    
    
class DataHubPageTemplateSurfaceClass(DictWrapper):
    """Info about the surface area of the product that this template is deployed in"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.template.DataHubPageTemplateSurface")
    def __init__(self,
        surfaceType: Union[str, "PageTemplateSurfaceTypeClass"],
    ):
        super().__init__()
        
        self.surfaceType = surfaceType
    
    def _restore_defaults(self) -> None:
        self.surfaceType = PageTemplateSurfaceTypeClass.HOME_PAGE
    
    
    @property
    def surfaceType(self) -> Union[str, "PageTemplateSurfaceTypeClass"]:
        """Where exactly is this template being used"""
        return self._inner_dict.get('surfaceType')  # type: ignore
    
    @surfaceType.setter
    def surfaceType(self, value: Union[str, "PageTemplateSurfaceTypeClass"]) -> None:
        self._inner_dict['surfaceType'] = value
    
    
class DataHubPageTemplateVisibilityClass(DictWrapper):
    """Info about the visibility of this template"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.template.DataHubPageTemplateVisibility")
    def __init__(self,
        scope: Union[str, "PageTemplateScopeClass"],
    ):
        super().__init__()
        
        self.scope = scope
    
    def _restore_defaults(self) -> None:
        self.scope = PageTemplateScopeClass.PERSONAL
    
    
    @property
    def scope(self) -> Union[str, "PageTemplateScopeClass"]:
        """The scope of this template and who can use/see it"""
        return self._inner_dict.get('scope')  # type: ignore
    
    @scope.setter
    def scope(self, value: Union[str, "PageTemplateScopeClass"]) -> None:
        self._inner_dict['scope'] = value
    
    
class PageTemplateScopeClass(object):
    # No docs available.
    
    PERSONAL = "PERSONAL"
    """This template is used for individual use only"""
    
    GLOBAL = "GLOBAL"
    """This template is used across users"""
    
    
    
class PageTemplateSurfaceTypeClass(object):
    # No docs available.
    
    HOME_PAGE = "HOME_PAGE"
    """This template applies to what to display on the home page for users."""
    
    ASSET_SUMMARY = "ASSET_SUMMARY"
    """This template applies to what to display on asset summary pages"""
    
    
    
class SummaryElementClass(DictWrapper):
    """Info for a given asset summary element"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.template.SummaryElement")
    def __init__(self,
        elementType: Union[str, "SummaryElementTypeClass"],
        structuredPropertyUrn: Union[None, str]=None,
    ):
        super().__init__()
        
        self.elementType = elementType
        self.structuredPropertyUrn = structuredPropertyUrn
    
    def _restore_defaults(self) -> None:
        self.elementType = SummaryElementTypeClass.CREATED
        self.structuredPropertyUrn = self.RECORD_SCHEMA.fields_dict["structuredPropertyUrn"].default
    
    
    @property
    def elementType(self) -> Union[str, "SummaryElementTypeClass"]:
        """The type of element/property"""
        return self._inner_dict.get('elementType')  # type: ignore
    
    @elementType.setter
    def elementType(self, value: Union[str, "SummaryElementTypeClass"]) -> None:
        self._inner_dict['elementType'] = value
    
    
    @property
    def structuredPropertyUrn(self) -> Union[None, str]:
        """The urn of the structured property shown. Required if propertyType is STRUCTURED_PROPERTY"""
        return self._inner_dict.get('structuredPropertyUrn')  # type: ignore
    
    @structuredPropertyUrn.setter
    def structuredPropertyUrn(self, value: Union[None, str]) -> None:
        self._inner_dict['structuredPropertyUrn'] = value
    
    
class SummaryElementTypeClass(object):
    # No docs available.
    
    CREATED = "CREATED"
    TAGS = "TAGS"
    GLOSSARY_TERMS = "GLOSSARY_TERMS"
    OWNERS = "OWNERS"
    DOMAIN = "DOMAIN"
    STRUCTURED_PROPERTY = "STRUCTURED_PROPERTY"
    
    
class BatchTestRunEventClass(_Aspect):
    """An event representing the current status of evaluating a batch metadata test (run offline)"""


    ASPECT_NAME = 'batchTestRunEvent'
    ASPECT_TYPE = 'timeseries'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.BatchTestRunEvent")

    def __init__(self,
        timestampMillis: int,
        status: Union[str, "BatchTestRunStatusClass"],
        result: Union[None, "BatchTestRunResultClass"]=None,
        eventGranularity: Union[None, "TimeWindowSizeClass"]=None,
        partitionSpec: Optional[Union["PartitionSpecClass", None]]=None,
        messageId: Union[None, str]=None,
    ):
        super().__init__()
        
        self.timestampMillis = timestampMillis
        self.status = status
        self.result = result
        self.eventGranularity = eventGranularity
        if partitionSpec is None:
            # default: {'partition': 'FULL_TABLE_SNAPSHOT', 'type': 'FULL_TABLE', 'timePartition': None}
            self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        else:
            self.partitionSpec = partitionSpec
        self.messageId = messageId
    
    def _restore_defaults(self) -> None:
        self.timestampMillis = int()
        self.status = BatchTestRunStatusClass.RUNNING
        self.result = self.RECORD_SCHEMA.fields_dict["result"].default
        self.eventGranularity = self.RECORD_SCHEMA.fields_dict["eventGranularity"].default
        self.partitionSpec = _json_converter.from_json_object(self.RECORD_SCHEMA.fields_dict["partitionSpec"].default, writers_schema=self.RECORD_SCHEMA.fields_dict["partitionSpec"].type)
        self.messageId = self.RECORD_SCHEMA.fields_dict["messageId"].default
    
    
    @property
    def timestampMillis(self) -> int:
        """The event timestamp field as epoch at UTC in milli seconds."""
        return self._inner_dict.get('timestampMillis')  # type: ignore
    
    @timestampMillis.setter
    def timestampMillis(self, value: int) -> None:
        self._inner_dict['timestampMillis'] = value
    
    
    @property
    def status(self) -> Union[str, "BatchTestRunStatusClass"]:
        """The status of the Test run as per this timeseries event."""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[str, "BatchTestRunStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def result(self) -> Union[None, "BatchTestRunResultClass"]:
        """Results of test, present if the status is COMPLETE"""
        return self._inner_dict.get('result')  # type: ignore
    
    @result.setter
    def result(self, value: Union[None, "BatchTestRunResultClass"]) -> None:
        self._inner_dict['result'] = value
    
    
    @property
    def eventGranularity(self) -> Union[None, "TimeWindowSizeClass"]:
        """Granularity of the event if applicable"""
        return self._inner_dict.get('eventGranularity')  # type: ignore
    
    @eventGranularity.setter
    def eventGranularity(self, value: Union[None, "TimeWindowSizeClass"]) -> None:
        self._inner_dict['eventGranularity'] = value
    
    
    @property
    def partitionSpec(self) -> Union["PartitionSpecClass", None]:
        """The optional partition specification."""
        return self._inner_dict.get('partitionSpec')  # type: ignore
    
    @partitionSpec.setter
    def partitionSpec(self, value: Union["PartitionSpecClass", None]) -> None:
        self._inner_dict['partitionSpec'] = value
    
    
    @property
    def messageId(self) -> Union[None, str]:
        """The optional messageId, if provided serves as a custom user-defined unique identifier for an aspect value."""
        return self._inner_dict.get('messageId')  # type: ignore
    
    @messageId.setter
    def messageId(self, value: Union[None, str]) -> None:
        self._inner_dict['messageId'] = value
    
    
class BatchTestRunResultClass(DictWrapper):
    """The result of running a batch metadata test"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.BatchTestRunResult")
    def __init__(self,
        passingCount: int,
        failingCount: int,
        testDefinition: Union[None, str]=None,
        report: Union[None, "TestReportClass"]=None,
    ):
        super().__init__()
        
        self.passingCount = passingCount
        self.failingCount = failingCount
        self.testDefinition = testDefinition
        self.report = report
    
    def _restore_defaults(self) -> None:
        self.passingCount = int()
        self.failingCount = int()
        self.testDefinition = self.RECORD_SCHEMA.fields_dict["testDefinition"].default
        self.report = self.RECORD_SCHEMA.fields_dict["report"].default
    
    
    @property
    def passingCount(self) -> int:
        """Number of assets that were passing the test."""
        return self._inner_dict.get('passingCount')  # type: ignore
    
    @passingCount.setter
    def passingCount(self, value: int) -> None:
        self._inner_dict['passingCount'] = value
    
    
    @property
    def failingCount(self) -> int:
        """Number of assets that were failing the test."""
        return self._inner_dict.get('failingCount')  # type: ignore
    
    @failingCount.setter
    def failingCount(self, value: int) -> None:
        self._inner_dict['failingCount'] = value
    
    
    @property
    def testDefinition(self) -> Union[None, str]:
        """Test definition that was used to run the test."""
        return self._inner_dict.get('testDefinition')  # type: ignore
    
    @testDefinition.setter
    def testDefinition(self, value: Union[None, str]) -> None:
        self._inner_dict['testDefinition'] = value
    
    
    @property
    def report(self) -> Union[None, "TestReportClass"]:
        """Reporting information about the run event of this metadata test"""
        return self._inner_dict.get('report')  # type: ignore
    
    @report.setter
    def report(self, value: Union[None, "TestReportClass"]) -> None:
        self._inner_dict['report'] = value
    
    
class BatchTestRunStatusClass(object):
    # No docs available.
    
    RUNNING = "RUNNING"
    """The Test is currently in progress"""
    
    COMPLETE = "COMPLETE"
    """The Test Run has completed"""
    
    
    
class TestActionsErrorClass(DictWrapper):
    """Error related to the actions applied in this test"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestActionsError")
    def __init__(self,
        actionType: str,
        urn: Union[None, str]=None,
        message: Union[None, str]=None,
    ):
        super().__init__()
        
        self.actionType = actionType
        self.urn = urn
        self.message = message
    
    def _restore_defaults(self) -> None:
        self.actionType = str()
        self.urn = self.RECORD_SCHEMA.fields_dict["urn"].default
        self.message = self.RECORD_SCHEMA.fields_dict["message"].default
    
    
    @property
    def actionType(self) -> str:
        """The type of action being taken in this test"""
        return self._inner_dict.get('actionType')  # type: ignore
    
    @actionType.setter
    def actionType(self, value: str) -> None:
        self._inner_dict['actionType'] = value
    
    
    @property
    def urn(self) -> Union[None, str]:
        """The asset urn related to this error"""
        return self._inner_dict.get('urn')  # type: ignore
    
    @urn.setter
    def urn(self, value: Union[None, str]) -> None:
        self._inner_dict['urn'] = value
    
    
    @property
    def message(self) -> Union[None, str]:
        """Any additional info about this error"""
        return self._inner_dict.get('message')  # type: ignore
    
    @message.setter
    def message(self, value: Union[None, str]) -> None:
        self._inner_dict['message'] = value
    
    
class TestActionsReportClass(DictWrapper):
    """Report related to the actions applied in this test"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestActionsReport")
    def __init__(self,
        errors: Union[None, List["TestActionsErrorClass"]]=None,
        totalEntityCount: Union[None, int]=None,
        processedEntityCount: Union[None, int]=None,
    ):
        super().__init__()
        
        self.errors = errors
        self.totalEntityCount = totalEntityCount
        self.processedEntityCount = processedEntityCount
    
    def _restore_defaults(self) -> None:
        self.errors = self.RECORD_SCHEMA.fields_dict["errors"].default
        self.totalEntityCount = self.RECORD_SCHEMA.fields_dict["totalEntityCount"].default
        self.processedEntityCount = self.RECORD_SCHEMA.fields_dict["processedEntityCount"].default
    
    
    @property
    def errors(self) -> Union[None, List["TestActionsErrorClass"]]:
        """Errors related to the actions applied in this test"""
        return self._inner_dict.get('errors')  # type: ignore
    
    @errors.setter
    def errors(self, value: Union[None, List["TestActionsErrorClass"]]) -> None:
        self._inner_dict['errors'] = value
    
    
    @property
    def totalEntityCount(self) -> Union[None, int]:
        """The total number of entities that are affected by the actions of this test"""
        return self._inner_dict.get('totalEntityCount')  # type: ignore
    
    @totalEntityCount.setter
    def totalEntityCount(self, value: Union[None, int]) -> None:
        self._inner_dict['totalEntityCount'] = value
    
    
    @property
    def processedEntityCount(self) -> Union[None, int]:
        """The number of entities that have already been acted upon by this test automation"""
        return self._inner_dict.get('processedEntityCount')  # type: ignore
    
    @processedEntityCount.setter
    def processedEntityCount(self, value: Union[None, int]) -> None:
        self._inner_dict['processedEntityCount'] = value
    
    
class TestDefinitionClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestDefinition")
    def __init__(self,
        type: Union[str, "TestDefinitionTypeClass"],
        json: Union[None, str]=None,
        md5: Union[None, str]=None,
        onQuery: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.json = json
        self.md5 = md5
        self.onQuery = onQuery
    
    def _restore_defaults(self) -> None:
        self.type = TestDefinitionTypeClass.JSON
        self.json = self.RECORD_SCHEMA.fields_dict["json"].default
        self.md5 = self.RECORD_SCHEMA.fields_dict["md5"].default
        self.onQuery = self.RECORD_SCHEMA.fields_dict["onQuery"].default
    
    
    @property
    def type(self) -> Union[str, "TestDefinitionTypeClass"]:
        """The Test Definition Type"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "TestDefinitionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def json(self) -> Union[None, str]:
        """JSON format configuration for the test"""
        return self._inner_dict.get('json')  # type: ignore
    
    @json.setter
    def json(self, value: Union[None, str]) -> None:
        self._inner_dict['json'] = value
    
    
    @property
    def md5(self) -> Union[None, str]:
        """MD5 hash of the test definition.
    Computed by the server.
    Used to stamp test results accurately.
    See TestResult for more details."""
        return self._inner_dict.get('md5')  # type: ignore
    
    @md5.setter
    def md5(self, value: Union[None, str]) -> None:
        self._inner_dict['md5'] = value
    
    
    @property
    def onQuery(self) -> Union[None, str]:
        """Optional search query to execute to get the assets this test applies to.
    This only works with elastic search test executor and when evaluating a single test."""
        return self._inner_dict.get('onQuery')  # type: ignore
    
    @onQuery.setter
    def onQuery(self, value: Union[None, str]) -> None:
        self._inner_dict['onQuery'] = value
    
    
class TestDefinitionTypeClass(object):
    # No docs available.
    
    JSON = "JSON"
    """JSON / YAML test def"""
    
    
    
class TestInfoClass(_Aspect):
    """Information about a DataHub Test"""


    ASPECT_NAME = 'testInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestInfo")

    def __init__(self,
        name: str,
        category: str,
        definition: "TestDefinitionClass",
        description: Union[None, str]=None,
        lastUpdatedTimestamp: Union[None, int]=None,
        created: Union[None, "AuditStampClass"]=None,
        lastUpdated: Union[None, "AuditStampClass"]=None,
        status: Union[None, "TestStatusClass"]=None,
        source: Union[None, "TestSourceClass"]=None,
        schedule: Union[None, "TestScheduleClass"]=None,
    ):
        super().__init__()
        
        self.name = name
        self.category = category
        self.description = description
        self.definition = definition
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.created = created
        self.lastUpdated = lastUpdated
        self.status = status
        self.source = source
        self.schedule = schedule
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.category = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.definition = TestDefinitionClass._construct_with_defaults()
        self.lastUpdatedTimestamp = self.RECORD_SCHEMA.fields_dict["lastUpdatedTimestamp"].default
        self.created = self.RECORD_SCHEMA.fields_dict["created"].default
        self.lastUpdated = self.RECORD_SCHEMA.fields_dict["lastUpdated"].default
        self.status = self.RECORD_SCHEMA.fields_dict["status"].default
        self.source = self.RECORD_SCHEMA.fields_dict["source"].default
        self.schedule = self.RECORD_SCHEMA.fields_dict["schedule"].default
    
    
    @property
    def name(self) -> str:
        """The name of the test"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def category(self) -> str:
        """Category of the test - Operational, Governance, etc."""
        return self._inner_dict.get('category')  # type: ignore
    
    @category.setter
    def category(self, value: str) -> None:
        self._inner_dict['category'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the test"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def definition(self) -> "TestDefinitionClass":
        """Configuration for the Test"""
        return self._inner_dict.get('definition')  # type: ignore
    
    @definition.setter
    def definition(self, value: "TestDefinitionClass") -> None:
        self._inner_dict['definition'] = value
    
    
    @property
    def lastUpdatedTimestamp(self) -> Union[None, int]:
        """Timestamp when the test was last updated"""
        return self._inner_dict.get('lastUpdatedTimestamp')  # type: ignore
    
    @lastUpdatedTimestamp.setter
    def lastUpdatedTimestamp(self, value: Union[None, int]) -> None:
        self._inner_dict['lastUpdatedTimestamp'] = value
    
    
    @property
    def created(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastUpdated(self) -> Union[None, "AuditStampClass"]:
        """Created Audit stamp"""
        return self._inner_dict.get('lastUpdated')  # type: ignore
    
    @lastUpdated.setter
    def lastUpdated(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastUpdated'] = value
    
    
    @property
    def status(self) -> Union[None, "TestStatusClass"]:
        """The current status of the Metadata Test, e.g. whether it is actively running."""
        return self._inner_dict.get('status')  # type: ignore
    
    @status.setter
    def status(self, value: Union[None, "TestStatusClass"]) -> None:
        self._inner_dict['status'] = value
    
    
    @property
    def source(self) -> Union[None, "TestSourceClass"]:
        """The source of the metadata test, e.g. whether the test is user generated or system generated."""
        return self._inner_dict.get('source')  # type: ignore
    
    @source.setter
    def source(self, value: Union[None, "TestSourceClass"]) -> None:
        self._inner_dict['source'] = value
    
    
    @property
    def schedule(self) -> Union[None, "TestScheduleClass"]:
        """Information about the schedule at which this test runs"""
        return self._inner_dict.get('schedule')  # type: ignore
    
    @schedule.setter
    def schedule(self, value: Union[None, "TestScheduleClass"]) -> None:
        self._inner_dict['schedule'] = value
    
    
class TestIntervalClass(object):
    # No docs available.
    
    DAILY = "DAILY"
    """This test runs once a day"""
    
    NONE = "NONE"
    """This test does not run on a schedule"""
    
    
    
class TestModeClass(object):
    # No docs available.
    
    ACTIVE = "ACTIVE"
    """The test is running on a schedule in the default running mode."""
    
    INACTIVE = "INACTIVE"
    """The test is paused, disabled, not running."""
    
    
    
class TestReportClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestReport")
    def __init__(self,
        actions: Union[None, "TestActionsReportClass"]=None,
    ):
        super().__init__()
        
        self.actions = actions
    
    def _restore_defaults(self) -> None:
        self.actions = self.RECORD_SCHEMA.fields_dict["actions"].default
    
    
    @property
    def actions(self) -> Union[None, "TestActionsReportClass"]:
        """Report related to the actions applied in this test"""
        return self._inner_dict.get('actions')  # type: ignore
    
    @actions.setter
    def actions(self, value: Union[None, "TestActionsReportClass"]) -> None:
        self._inner_dict['actions'] = value
    
    
class TestResultClass(DictWrapper):
    """Information about a Test Result"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestResult")
    def __init__(self,
        test: str,
        type: Union[str, "TestResultTypeClass"],
        testDefinitionMd5: Union[None, str]=None,
        lastComputed: Union[None, "AuditStampClass"]=None,
    ):
        super().__init__()
        
        self.test = test
        self.type = type
        self.testDefinitionMd5 = testDefinitionMd5
        self.lastComputed = lastComputed
    
    def _restore_defaults(self) -> None:
        self.test = str()
        self.type = TestResultTypeClass.SUCCESS
        self.testDefinitionMd5 = self.RECORD_SCHEMA.fields_dict["testDefinitionMd5"].default
        self.lastComputed = self.RECORD_SCHEMA.fields_dict["lastComputed"].default
    
    
    @property
    def test(self) -> str:
        """The urn of the test"""
        return self._inner_dict.get('test')  # type: ignore
    
    @test.setter
    def test(self, value: str) -> None:
        self._inner_dict['test'] = value
    
    
    @property
    def type(self) -> Union[str, "TestResultTypeClass"]:
        """The type of the result"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "TestResultTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def testDefinitionMd5(self) -> Union[None, str]:
        """The md5 of the test definition that was used to compute this result.
    See TestInfo.testDefinition.md5 for more information."""
        return self._inner_dict.get('testDefinitionMd5')  # type: ignore
    
    @testDefinitionMd5.setter
    def testDefinitionMd5(self, value: Union[None, str]) -> None:
        self._inner_dict['testDefinitionMd5'] = value
    
    
    @property
    def lastComputed(self) -> Union[None, "AuditStampClass"]:
        """The audit stamp of when the result was computed, including the actor who computed it."""
        return self._inner_dict.get('lastComputed')  # type: ignore
    
    @lastComputed.setter
    def lastComputed(self, value: Union[None, "AuditStampClass"]) -> None:
        self._inner_dict['lastComputed'] = value
    
    
class TestResultTypeClass(object):
    # No docs available.
    
    SUCCESS = "SUCCESS"
    """ The Test Succeeded"""
    
    FAILURE = "FAILURE"
    """ The Test Failed"""
    
    
    
class TestResultsClass(_Aspect):
    """Information about a Test Result"""


    ASPECT_NAME = 'testResults'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestResults")

    def __init__(self,
        failing: List["TestResultClass"],
        passing: List["TestResultClass"],
    ):
        super().__init__()
        
        self.failing = failing
        self.passing = passing
    
    def _restore_defaults(self) -> None:
        self.failing = list()
        self.passing = list()
    
    
    @property
    def failing(self) -> List["TestResultClass"]:
        """Results that are failing"""
        return self._inner_dict.get('failing')  # type: ignore
    
    @failing.setter
    def failing(self, value: List["TestResultClass"]) -> None:
        self._inner_dict['failing'] = value
    
    
    @property
    def passing(self) -> List["TestResultClass"]:
        """Results that are passing"""
        return self._inner_dict.get('passing')  # type: ignore
    
    @passing.setter
    def passing(self, value: List["TestResultClass"]) -> None:
        self._inner_dict['passing'] = value
    
    
class TestScheduleClass(DictWrapper):
    """The result of running a batch metadata test"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestSchedule")
    def __init__(self,
        interval: Optional[Union[str, "TestIntervalClass"]]=None,
    ):
        super().__init__()
        
        if interval is None:
            # default: 'DAILY'
            self.interval = self.RECORD_SCHEMA.fields_dict["interval"].default
        else:
            self.interval = interval
    
    def _restore_defaults(self) -> None:
        self.interval = self.RECORD_SCHEMA.fields_dict["interval"].default
    
    
    @property
    def interval(self) -> Union[str, "TestIntervalClass"]:
        """The interval at which this metadata test is scheduled"""
        return self._inner_dict.get('interval')  # type: ignore
    
    @interval.setter
    def interval(self, value: Union[str, "TestIntervalClass"]) -> None:
        self._inner_dict['interval'] = value
    
    
class TestSourceClass(DictWrapper):
    """The source of a metadata test"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestSource")
    def __init__(self,
        type: Union[str, "TestSourceTypeClass"],
        sourceEntity: Union[None, str]=None,
    ):
        super().__init__()
        
        self.type = type
        self.sourceEntity = sourceEntity
    
    def _restore_defaults(self) -> None:
        self.type = TestSourceTypeClass.FORMS
        self.sourceEntity = self.RECORD_SCHEMA.fields_dict["sourceEntity"].default
    
    
    @property
    def type(self) -> Union[str, "TestSourceTypeClass"]:
        """The source type of the metadata test"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "TestSourceTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def sourceEntity(self) -> Union[None, str]:
        """An optional source 'entity' that is responsible for this test.
    
    This is currently only used for keeping track of the Form which owns a set of metadata tests."""
        return self._inner_dict.get('sourceEntity')  # type: ignore
    
    @sourceEntity.setter
    def sourceEntity(self, value: Union[None, str]) -> None:
        self._inner_dict['sourceEntity'] = value
    
    
class TestSourceTypeClass(object):
    # No docs available.
    
    FORMS = "FORMS"
    """The test was system-generated by the system for the FORMs feature."""
    
    BULK_FORM_SUBMISSION = "BULK_FORM_SUBMISSION"
    """The test was system-generated to complete a bulk form submission task"""
    
    FORM_PROMPT = "FORM_PROMPT"
    """The test was system-generated by the system for the FORMs feature to test
    for form prompt completion."""
    
    
    
class TestStatusClass(DictWrapper):
    """The status of a Metadata Test"""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.test.TestStatus")
    def __init__(self,
        mode: Union[str, "TestModeClass"],
    ):
        super().__init__()
        
        self.mode = mode
    
    def _restore_defaults(self) -> None:
        self.mode = TestModeClass.ACTIVE
    
    
    @property
    def mode(self) -> Union[str, "TestModeClass"]:
        """The evaluation mode of the Metadata Test."""
        return self._inner_dict.get('mode')  # type: ignore
    
    @mode.setter
    def mode(self, value: Union[str, "TestModeClass"]) -> None:
        self._inner_dict['mode'] = value
    
    
class AbsoluteTimeWindowClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.timeseries.AbsoluteTimeWindow")
    def __init__(self,
        startTimeMillis: int,
        endTimeMillis: int,
    ):
        super().__init__()
        
        self.startTimeMillis = startTimeMillis
        self.endTimeMillis = endTimeMillis
    
    def _restore_defaults(self) -> None:
        self.startTimeMillis = int()
        self.endTimeMillis = int()
    
    
    @property
    def startTimeMillis(self) -> int:
        """Start time as epoch at UTC."""
        return self._inner_dict.get('startTimeMillis')  # type: ignore
    
    @startTimeMillis.setter
    def startTimeMillis(self, value: int) -> None:
        self._inner_dict['startTimeMillis'] = value
    
    
    @property
    def endTimeMillis(self) -> int:
        """End time as epoch at UTC."""
        return self._inner_dict.get('endTimeMillis')  # type: ignore
    
    @endTimeMillis.setter
    def endTimeMillis(self, value: int) -> None:
        self._inner_dict['endTimeMillis'] = value
    
    
class CalendarIntervalClass(object):
    # No docs available.
    
    SECOND = "SECOND"
    MINUTE = "MINUTE"
    HOUR = "HOUR"
    DAY = "DAY"
    WEEK = "WEEK"
    MONTH = "MONTH"
    QUARTER = "QUARTER"
    YEAR = "YEAR"
    
    
class DayOfWeekClass(object):
    # No docs available.
    
    MONDAY = "MONDAY"
    TUESDAY = "TUESDAY"
    WEDNESDAY = "WEDNESDAY"
    THURSDAY = "THURSDAY"
    FRIDAY = "FRIDAY"
    SATURDAY = "SATURDAY"
    SUNDAY = "SUNDAY"
    
    
class HolidayWindowClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.timeseries.HolidayWindow")
    def __init__(self,
        name: str,
        region: Union[None, str]=None,
        timezone: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.region = region
        self.timezone = timezone
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.region = self.RECORD_SCHEMA.fields_dict["region"].default
        self.timezone = self.RECORD_SCHEMA.fields_dict["timezone"].default
    
    
    @property
    def name(self) -> str:
        """The name of the holiday."""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def region(self) -> Union[None, str]:
        """The region of the holiday.
    Example: 'US'"""
        return self._inner_dict.get('region')  # type: ignore
    
    @region.setter
    def region(self, value: Union[None, str]) -> None:
        self._inner_dict['region'] = value
    
    
    @property
    def timezone(self) -> Union[None, str]:
        """The timezone of the holiday.
    Example: 'America/New_York'"""
        return self._inner_dict.get('timezone')  # type: ignore
    
    @timezone.setter
    def timezone(self, value: Union[None, str]) -> None:
        self._inner_dict['timezone'] = value
    
    
class PartitionSpecClass(DictWrapper):
    """A reference to a specific partition in a dataset."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.timeseries.PartitionSpec")
    def __init__(self,
        partition: str,
        timePartition: Union[None, "TimeWindowClass"]=None,
        type: Optional[Union[str, "PartitionTypeClass"]]=None,
    ):
        super().__init__()
        
        self.partition = partition
        self.timePartition = timePartition
        if type is None:
            # default: 'PARTITION'
            self.type = self.RECORD_SCHEMA.fields_dict["type"].default
        else:
            self.type = type
    
    def _restore_defaults(self) -> None:
        self.partition = str()
        self.timePartition = self.RECORD_SCHEMA.fields_dict["timePartition"].default
        self.type = self.RECORD_SCHEMA.fields_dict["type"].default
    
    
    @property
    def partition(self) -> str:
        """A unique id / value for the partition for which statistics were collected,
    generated by applying the key definition to a given row."""
        return self._inner_dict.get('partition')  # type: ignore
    
    @partition.setter
    def partition(self, value: str) -> None:
        self._inner_dict['partition'] = value
    
    
    @property
    def timePartition(self) -> Union[None, "TimeWindowClass"]:
        """Time window of the partition, if we are able to extract it from the partition key."""
        return self._inner_dict.get('timePartition')  # type: ignore
    
    @timePartition.setter
    def timePartition(self, value: Union[None, "TimeWindowClass"]) -> None:
        self._inner_dict['timePartition'] = value
    
    
    @property
    def type(self) -> Union[str, "PartitionTypeClass"]:
        """Unused!"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "PartitionTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
class PartitionTypeClass(object):
    # No docs available.
    
    FULL_TABLE = "FULL_TABLE"
    QUERY = "QUERY"
    PARTITION = "PARTITION"
    
    
class TimeWindowClass(DictWrapper):
    # No docs available.
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.timeseries.TimeWindow")
    def __init__(self,
        startTimeMillis: int,
        length: "TimeWindowSizeClass",
    ):
        super().__init__()
        
        self.startTimeMillis = startTimeMillis
        self.length = length
    
    def _restore_defaults(self) -> None:
        self.startTimeMillis = int()
        self.length = TimeWindowSizeClass._construct_with_defaults()
    
    
    @property
    def startTimeMillis(self) -> int:
        """Start time as epoch at UTC."""
        return self._inner_dict.get('startTimeMillis')  # type: ignore
    
    @startTimeMillis.setter
    def startTimeMillis(self, value: int) -> None:
        self._inner_dict['startTimeMillis'] = value
    
    
    @property
    def length(self) -> "TimeWindowSizeClass":
        """The length of the window."""
        return self._inner_dict.get('length')  # type: ignore
    
    @length.setter
    def length(self, value: "TimeWindowSizeClass") -> None:
        self._inner_dict['length'] = value
    
    
class TimeWindowSizeClass(DictWrapper):
    """Defines the size of a time window."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.timeseries.TimeWindowSize")
    def __init__(self,
        unit: Union[str, "CalendarIntervalClass"],
        multiple: Optional[int]=None,
    ):
        super().__init__()
        
        self.unit = unit
        if multiple is None:
            # default: 1
            self.multiple = self.RECORD_SCHEMA.fields_dict["multiple"].default
        else:
            self.multiple = multiple
    
    def _restore_defaults(self) -> None:
        self.unit = CalendarIntervalClass.SECOND
        self.multiple = self.RECORD_SCHEMA.fields_dict["multiple"].default
    
    
    @property
    def unit(self) -> Union[str, "CalendarIntervalClass"]:
        """Interval unit such as minute/hour/day etc."""
        return self._inner_dict.get('unit')  # type: ignore
    
    @unit.setter
    def unit(self, value: Union[str, "CalendarIntervalClass"]) -> None:
        self._inner_dict['unit'] = value
    
    
    @property
    def multiple(self) -> int:
        """How many units. Defaults to 1."""
        return self._inner_dict.get('multiple')  # type: ignore
    
    @multiple.setter
    def multiple(self, value: int) -> None:
        self._inner_dict['multiple'] = value
    
    
class WeeklyWindowClass(DictWrapper):
    """Represents a recurring time window that repeats weekly.
    Used to define exclusion periods for model training based on day of week and time of day."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.timeseries.WeeklyWindow")
    def __init__(self,
        daysOfWeek: List[Union[str, "DayOfWeekClass"]],
        startTime: Union[None, str]=None,
        endTime: Union[None, str]=None,
        timezone: Union[None, str]=None,
    ):
        super().__init__()
        
        self.daysOfWeek = daysOfWeek
        self.startTime = startTime
        self.endTime = endTime
        self.timezone = timezone
    
    def _restore_defaults(self) -> None:
        self.daysOfWeek = list()
        self.startTime = self.RECORD_SCHEMA.fields_dict["startTime"].default
        self.endTime = self.RECORD_SCHEMA.fields_dict["endTime"].default
        self.timezone = self.RECORD_SCHEMA.fields_dict["timezone"].default
    
    
    @property
    def daysOfWeek(self) -> List[Union[str, "DayOfWeekClass"]]:
        """Days of the week to include in the window.
    If not specified, all days are included."""
        return self._inner_dict.get('daysOfWeek')  # type: ignore
    
    @daysOfWeek.setter
    def daysOfWeek(self, value: List[Union[str, "DayOfWeekClass"]]) -> None:
        self._inner_dict['daysOfWeek'] = value
    
    
    @property
    def startTime(self) -> Union[None, str]:
        """Start time for the window on each specified day.
    Format: "HH:MM" in 24-hour format (e.g., "09:00" for 9am, "17:30" for 5:30pm).
    If not specified, defaults to start of day ("00:00")."""
        return self._inner_dict.get('startTime')  # type: ignore
    
    @startTime.setter
    def startTime(self, value: Union[None, str]) -> None:
        self._inner_dict['startTime'] = value
    
    
    @property
    def endTime(self) -> Union[None, str]:
        """End time for the window on each specified day.
    Format: "HH:MM" in 24-hour format (e.g., "17:00" for 5pm, "23:59" for end of day).
    If not specified, defaults to end of day ("23:59")."""
        return self._inner_dict.get('endTime')  # type: ignore
    
    @endTime.setter
    def endTime(self, value: Union[None, str]) -> None:
        self._inner_dict['endTime'] = value
    
    
    @property
    def timezone(self) -> Union[None, str]:
        """Time zone to interpret start and end times in.
    Uses standard time zone identifiers (e.g., "America/Los_Angeles", "UTC").
    If not specified, defaults to UTC."""
        return self._inner_dict.get('timezone')  # type: ignore
    
    @timezone.setter
    def timezone(self, value: Union[None, str]) -> None:
        self._inner_dict['timezone'] = value
    
    
class DataHubUpgradeRequestClass(_Aspect):
    """Information collected when kicking off a DataHubUpgrade"""


    ASPECT_NAME = 'dataHubUpgradeRequest'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.upgrade.DataHubUpgradeRequest")

    def __init__(self,
        timestampMs: int,
        version: str,
    ):
        super().__init__()
        
        self.timestampMs = timestampMs
        self.version = version
    
    def _restore_defaults(self) -> None:
        self.timestampMs = int()
        self.version = str()
    
    
    @property
    def timestampMs(self) -> int:
        """Timestamp when we started this DataHubUpgrade"""
        return self._inner_dict.get('timestampMs')  # type: ignore
    
    @timestampMs.setter
    def timestampMs(self, value: int) -> None:
        self._inner_dict['timestampMs'] = value
    
    
    @property
    def version(self) -> str:
        """Version of this upgrade"""
        return self._inner_dict.get('version')  # type: ignore
    
    @version.setter
    def version(self, value: str) -> None:
        self._inner_dict['version'] = value
    
    
class DataHubUpgradeResultClass(_Aspect):
    """Information collected when a DataHubUpgrade successfully finishes"""


    ASPECT_NAME = 'dataHubUpgradeResult'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.upgrade.DataHubUpgradeResult")

    def __init__(self,
        timestampMs: int,
        state: Optional[Union[Union[str, "DataHubUpgradeStateClass"], None]]=None,
        result: Union[None, Dict[str, str]]=None,
    ):
        super().__init__()
        
        if state is None:
            # default: 'SUCCEEDED'
            self.state = self.RECORD_SCHEMA.fields_dict["state"].default
        else:
            self.state = state
        self.timestampMs = timestampMs
        self.result = result
    
    def _restore_defaults(self) -> None:
        self.state = self.RECORD_SCHEMA.fields_dict["state"].default
        self.timestampMs = int()
        self.result = self.RECORD_SCHEMA.fields_dict["result"].default
    
    
    @property
    def state(self) -> Union[Union[str, "DataHubUpgradeStateClass"], None]:
        """Upgrade state  UpgradeResult.Result"""
        return self._inner_dict.get('state')  # type: ignore
    
    @state.setter
    def state(self, value: Union[Union[str, "DataHubUpgradeStateClass"], None]) -> None:
        self._inner_dict['state'] = value
    
    
    @property
    def timestampMs(self) -> int:
        """Timestamp when we started this DataHubUpgrade"""
        return self._inner_dict.get('timestampMs')  # type: ignore
    
    @timestampMs.setter
    def timestampMs(self, value: int) -> None:
        self._inner_dict['timestampMs'] = value
    
    
    @property
    def result(self) -> Union[None, Dict[str, str]]:
        """Result map to place helpful information about this upgrade job"""
        return self._inner_dict.get('result')  # type: ignore
    
    @result.setter
    def result(self, value: Union[None, Dict[str, str]]) -> None:
        self._inner_dict['result'] = value
    
    
class DataHubUpgradeStateClass(object):
    # No docs available.
    
    IN_PROGRESS = "IN_PROGRESS"
    """Upgrade in progress."""
    
    SUCCEEDED = "SUCCEEDED"
    """Upgrade was successful."""
    
    FAILED = "FAILED"
    """Upgrade with an error state, however the upgrade should be re-run."""
    
    ABORTED = "ABORTED"
    """Upgrade with an error state and should not be re-run."""
    
    
    
class FieldUsageCountsClass(DictWrapper):
    """ Records field-level usage counts for a given resource """
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.usage.FieldUsageCounts")
    def __init__(self,
        fieldName: str,
        count: int,
    ):
        super().__init__()
        
        self.fieldName = fieldName
        self.count = count
    
    def _restore_defaults(self) -> None:
        self.fieldName = str()
        self.count = int()
    
    
    @property
    def fieldName(self) -> str:
        # No docs available.
        return self._inner_dict.get('fieldName')  # type: ignore
    
    @fieldName.setter
    def fieldName(self, value: str) -> None:
        self._inner_dict['fieldName'] = value
    
    
    @property
    def count(self) -> int:
        # No docs available.
        return self._inner_dict.get('count')  # type: ignore
    
    @count.setter
    def count(self, value: int) -> None:
        self._inner_dict['count'] = value
    
    
class UsageAggregationClass(DictWrapper):
    """Usage data for a given resource, rolled up into a bucket."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.usage.UsageAggregation")
    def __init__(self,
        bucket: int,
        duration: Union[str, "WindowDurationClass"],
        resource: str,
        metrics: "UsageAggregationMetricsClass",
    ):
        super().__init__()
        
        self.bucket = bucket
        self.duration = duration
        self.resource = resource
        self.metrics = metrics
    
    def _restore_defaults(self) -> None:
        self.bucket = int()
        self.duration = WindowDurationClass.YEAR
        self.resource = str()
        self.metrics = UsageAggregationMetricsClass._construct_with_defaults()
    
    
    @property
    def bucket(self) -> int:
        """ Bucket start time in milliseconds """
        return self._inner_dict.get('bucket')  # type: ignore
    
    @bucket.setter
    def bucket(self, value: int) -> None:
        self._inner_dict['bucket'] = value
    
    
    @property
    def duration(self) -> Union[str, "WindowDurationClass"]:
        """ Bucket duration """
        return self._inner_dict.get('duration')  # type: ignore
    
    @duration.setter
    def duration(self, value: Union[str, "WindowDurationClass"]) -> None:
        self._inner_dict['duration'] = value
    
    
    @property
    def resource(self) -> str:
        """ Resource associated with these usage stats """
        return self._inner_dict.get('resource')  # type: ignore
    
    @resource.setter
    def resource(self, value: str) -> None:
        self._inner_dict['resource'] = value
    
    
    @property
    def metrics(self) -> "UsageAggregationMetricsClass":
        """ Metrics associated with this bucket """
        return self._inner_dict.get('metrics')  # type: ignore
    
    @metrics.setter
    def metrics(self, value: "UsageAggregationMetricsClass") -> None:
        self._inner_dict['metrics'] = value
    
    
class UsageAggregationMetricsClass(DictWrapper):
    """Metrics for usage data for a given resource and bucket. Not all fields
    make sense for all buckets, so every field is optional."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.usage.UsageAggregationMetrics")
    def __init__(self,
        uniqueUserCount: Union[None, int]=None,
        users: Union[None, List["UserUsageCountsClass"]]=None,
        totalSqlQueries: Union[None, int]=None,
        topSqlQueries: Union[None, List[str]]=None,
        fields: Union[None, List["FieldUsageCountsClass"]]=None,
    ):
        super().__init__()
        
        self.uniqueUserCount = uniqueUserCount
        self.users = users
        self.totalSqlQueries = totalSqlQueries
        self.topSqlQueries = topSqlQueries
        self.fields = fields
    
    def _restore_defaults(self) -> None:
        self.uniqueUserCount = self.RECORD_SCHEMA.fields_dict["uniqueUserCount"].default
        self.users = self.RECORD_SCHEMA.fields_dict["users"].default
        self.totalSqlQueries = self.RECORD_SCHEMA.fields_dict["totalSqlQueries"].default
        self.topSqlQueries = self.RECORD_SCHEMA.fields_dict["topSqlQueries"].default
        self.fields = self.RECORD_SCHEMA.fields_dict["fields"].default
    
    
    @property
    def uniqueUserCount(self) -> Union[None, int]:
        """ Unique user count """
        return self._inner_dict.get('uniqueUserCount')  # type: ignore
    
    @uniqueUserCount.setter
    def uniqueUserCount(self, value: Union[None, int]) -> None:
        self._inner_dict['uniqueUserCount'] = value
    
    
    @property
    def users(self) -> Union[None, List["UserUsageCountsClass"]]:
        """ Users within this bucket, with frequency counts """
        return self._inner_dict.get('users')  # type: ignore
    
    @users.setter
    def users(self, value: Union[None, List["UserUsageCountsClass"]]) -> None:
        self._inner_dict['users'] = value
    
    
    @property
    def totalSqlQueries(self) -> Union[None, int]:
        """ Total SQL query count """
        return self._inner_dict.get('totalSqlQueries')  # type: ignore
    
    @totalSqlQueries.setter
    def totalSqlQueries(self, value: Union[None, int]) -> None:
        self._inner_dict['totalSqlQueries'] = value
    
    
    @property
    def topSqlQueries(self) -> Union[None, List[str]]:
        """ Frequent SQL queries; mostly makes sense for datasets in SQL databases """
        return self._inner_dict.get('topSqlQueries')  # type: ignore
    
    @topSqlQueries.setter
    def topSqlQueries(self, value: Union[None, List[str]]) -> None:
        self._inner_dict['topSqlQueries'] = value
    
    
    @property
    def fields(self) -> Union[None, List["FieldUsageCountsClass"]]:
        """ Field-level usage stats """
        return self._inner_dict.get('fields')  # type: ignore
    
    @fields.setter
    def fields(self, value: Union[None, List["FieldUsageCountsClass"]]) -> None:
        self._inner_dict['fields'] = value
    
    
class UserUsageCountsClass(DictWrapper):
    """ Records a single user's usage counts for a given resource """
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.usage.UserUsageCounts")
    def __init__(self,
        count: int,
        user: Union[None, str]=None,
        userEmail: Union[None, str]=None,
    ):
        super().__init__()
        
        self.user = user
        self.count = count
        self.userEmail = userEmail
    
    def _restore_defaults(self) -> None:
        self.user = self.RECORD_SCHEMA.fields_dict["user"].default
        self.count = int()
        self.userEmail = self.RECORD_SCHEMA.fields_dict["userEmail"].default
    
    
    @property
    def user(self) -> Union[None, str]:
        # No docs available.
        return self._inner_dict.get('user')  # type: ignore
    
    @user.setter
    def user(self, value: Union[None, str]) -> None:
        self._inner_dict['user'] = value
    
    
    @property
    def count(self) -> int:
        # No docs available.
        return self._inner_dict.get('count')  # type: ignore
    
    @count.setter
    def count(self, value: int) -> None:
        self._inner_dict['count'] = value
    
    
    @property
    def userEmail(self) -> Union[None, str]:
        """ If user_email is set, we attempt to resolve the user's urn upon ingest """
        return self._inner_dict.get('userEmail')  # type: ignore
    
    @userEmail.setter
    def userEmail(self, value: Union[None, str]) -> None:
        self._inner_dict['userEmail'] = value
    
    
class VersionSetPropertiesClass(_Aspect):
    # No docs available.


    ASPECT_NAME = 'versionSetProperties'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.versionset.VersionSetProperties")

    def __init__(self,
        latest: str,
        versioningScheme: Union[str, "VersioningSchemeClass"],
        customProperties: Optional[Dict[str, str]]=None,
    ):
        super().__init__()
        
        if customProperties is None:
            # default: {}
            self.customProperties = dict()
        else:
            self.customProperties = customProperties
        self.latest = latest
        self.versioningScheme = versioningScheme
    
    def _restore_defaults(self) -> None:
        self.customProperties = dict()
        self.latest = str()
        self.versioningScheme = VersioningSchemeClass.LEXICOGRAPHIC_STRING
    
    
    @property
    def customProperties(self) -> Dict[str, str]:
        """Custom property bag."""
        return self._inner_dict.get('customProperties')  # type: ignore
    
    @customProperties.setter
    def customProperties(self, value: Dict[str, str]) -> None:
        self._inner_dict['customProperties'] = value
    
    
    @property
    def latest(self) -> str:
        """The latest versioned entity linked to in this version set"""
        return self._inner_dict.get('latest')  # type: ignore
    
    @latest.setter
    def latest(self, value: str) -> None:
        self._inner_dict['latest'] = value
    
    
    @property
    def versioningScheme(self) -> Union[str, "VersioningSchemeClass"]:
        """What versioning scheme is being utilized for the versioned entities sort criterion. Static once set"""
        return self._inner_dict.get('versioningScheme')  # type: ignore
    
    @versioningScheme.setter
    def versioningScheme(self, value: Union[str, "VersioningSchemeClass"]) -> None:
        self._inner_dict['versioningScheme'] = value
    
    
class VersioningSchemeClass(object):
    # No docs available.
    
    LEXICOGRAPHIC_STRING = "LEXICOGRAPHIC_STRING"
    """String sorted lexicographically."""
    
    ALPHANUMERIC_GENERATED_BY_DATAHUB = "ALPHANUMERIC_GENERATED_BY_DATAHUB"
    """String managed by DataHub. Currently, an 8 character alphabetical string."""
    
    
    
class DataHubViewDefinitionClass(DictWrapper):
    """A View definition."""
    
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.view.DataHubViewDefinition")
    def __init__(self,
        entityTypes: List[str],
        filter: "FilterClass",
    ):
        super().__init__()
        
        self.entityTypes = entityTypes
        self.filter = filter
    
    def _restore_defaults(self) -> None:
        self.entityTypes = list()
        self.filter = FilterClass._construct_with_defaults()
    
    
    @property
    def entityTypes(self) -> List[str]:
        """The Entity Types in the scope of the View."""
        return self._inner_dict.get('entityTypes')  # type: ignore
    
    @entityTypes.setter
    def entityTypes(self, value: List[str]) -> None:
        self._inner_dict['entityTypes'] = value
    
    
    @property
    def filter(self) -> "FilterClass":
        """The filter criteria, which represents the view itself"""
        return self._inner_dict.get('filter')  # type: ignore
    
    @filter.setter
    def filter(self, value: "FilterClass") -> None:
        self._inner_dict['filter'] = value
    
    
class DataHubViewInfoClass(_Aspect):
    """Information about a DataHub View. -- TODO: Understand whether an entity type filter is required."""


    ASPECT_NAME = 'dataHubViewInfo'
    ASPECT_INFO = {}
    RECORD_SCHEMA = get_schema_type("com.linkedin.pegasus2avro.view.DataHubViewInfo")

    def __init__(self,
        name: str,
        type: Union[str, "DataHubViewTypeClass"],
        definition: "DataHubViewDefinitionClass",
        created: "AuditStampClass",
        lastModified: "AuditStampClass",
        description: Union[None, str]=None,
    ):
        super().__init__()
        
        self.name = name
        self.description = description
        self.type = type
        self.definition = definition
        self.created = created
        self.lastModified = lastModified
    
    def _restore_defaults(self) -> None:
        self.name = str()
        self.description = self.RECORD_SCHEMA.fields_dict["description"].default
        self.type = DataHubViewTypeClass.PERSONAL
        self.definition = DataHubViewDefinitionClass._construct_with_defaults()
        self.created = AuditStampClass._construct_with_defaults()
        self.lastModified = AuditStampClass._construct_with_defaults()
    
    
    @property
    def name(self) -> str:
        """The name of the View"""
        return self._inner_dict.get('name')  # type: ignore
    
    @name.setter
    def name(self, value: str) -> None:
        self._inner_dict['name'] = value
    
    
    @property
    def description(self) -> Union[None, str]:
        """Description of the view"""
        return self._inner_dict.get('description')  # type: ignore
    
    @description.setter
    def description(self, value: Union[None, str]) -> None:
        self._inner_dict['description'] = value
    
    
    @property
    def type(self) -> Union[str, "DataHubViewTypeClass"]:
        """The type of View"""
        return self._inner_dict.get('type')  # type: ignore
    
    @type.setter
    def type(self, value: Union[str, "DataHubViewTypeClass"]) -> None:
        self._inner_dict['type'] = value
    
    
    @property
    def definition(self) -> "DataHubViewDefinitionClass":
        """The view itself"""
        return self._inner_dict.get('definition')  # type: ignore
    
    @definition.setter
    def definition(self, value: "DataHubViewDefinitionClass") -> None:
        self._inner_dict['definition'] = value
    
    
    @property
    def created(self) -> "AuditStampClass":
        """Audit stamp capturing the time and actor who created the View."""
        return self._inner_dict.get('created')  # type: ignore
    
    @created.setter
    def created(self, value: "AuditStampClass") -> None:
        self._inner_dict['created'] = value
    
    
    @property
    def lastModified(self) -> "AuditStampClass":
        """Audit stamp capturing the time and actor who last modified the View."""
        return self._inner_dict.get('lastModified')  # type: ignore
    
    @lastModified.setter
    def lastModified(self, value: "AuditStampClass") -> None:
        self._inner_dict['lastModified'] = value
    
    
class DataHubViewTypeClass(object):
    # No docs available.
    
    PERSONAL = "PERSONAL"
    """A view private for a specific person."""
    
    GLOBAL = "GLOBAL"
    """A global view, which all users can see and use."""
    
    
    
__SCHEMA_TYPES = {
    'com.linkedin.events.KafkaAuditHeader': KafkaAuditHeaderClass,
    'com.linkedin.pegasus2avro.access.token.DataHubAccessTokenInfo': DataHubAccessTokenInfoClass,
    'com.linkedin.pegasus2avro.action.DataHubActionConfig': DataHubActionConfigClass,
    'com.linkedin.pegasus2avro.action.DataHubActionInfo': DataHubActionInfoClass,
    'com.linkedin.pegasus2avro.action.DataHubActionRequestSource': DataHubActionRequestSourceClass,
    'com.linkedin.pegasus2avro.action.DataHubActionSource': DataHubActionSourceClass,
    'com.linkedin.pegasus2avro.action.DataHubActionStageStatus': DataHubActionStageStatusClass,
    'com.linkedin.pegasus2avro.action.DataHubActionStageStatusCode': DataHubActionStageStatusCodeClass,
    'com.linkedin.pegasus2avro.action.DataHubActionState': DataHubActionStateClass,
    'com.linkedin.pegasus2avro.action.DataHubActionStatus': DataHubActionStatusClass,
    'com.linkedin.pegasus2avro.actionrequest.ActionRequestArchived': ActionRequestArchivedClass,
    'com.linkedin.pegasus2avro.actionrequest.ActionRequestInfo': ActionRequestInfoClass,
    'com.linkedin.pegasus2avro.actionrequest.ActionRequestOrigin': ActionRequestOriginClass,
    'com.linkedin.pegasus2avro.actionrequest.ActionRequestParams': ActionRequestParamsClass,
    'com.linkedin.pegasus2avro.actionrequest.ActionRequestStatus': ActionRequestStatusClass,
    'com.linkedin.pegasus2avro.actionrequest.CreateGlossaryNodeProposal': CreateGlossaryNodeProposalClass,
    'com.linkedin.pegasus2avro.actionrequest.CreateGlossaryTermProposal': CreateGlossaryTermProposalClass,
    'com.linkedin.pegasus2avro.actionrequest.DataContractProposal': DataContractProposalClass,
    'com.linkedin.pegasus2avro.actionrequest.DataContractProposalOperationType': DataContractProposalOperationTypeClass,
    'com.linkedin.pegasus2avro.actionrequest.DescriptionProposal': DescriptionProposalClass,
    'com.linkedin.pegasus2avro.actionrequest.DomainProposal': DomainProposalClass,
    'com.linkedin.pegasus2avro.actionrequest.GlossaryTermProposal': GlossaryTermProposalClass,
    'com.linkedin.pegasus2avro.actionrequest.OwnerProposal': OwnerProposalClass,
    'com.linkedin.pegasus2avro.actionrequest.StructuredPropertyProposal': StructuredPropertyProposalClass,
    'com.linkedin.pegasus2avro.actionrequest.TagProposal': TagProposalClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowCategory': ActionWorkflowCategoryClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowEntrypoint': ActionWorkflowEntrypointClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowEntrypointType': ActionWorkflowEntrypointTypeClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowField': ActionWorkflowFieldClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowFieldCondition': ActionWorkflowFieldConditionClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowFieldConditionType': ActionWorkflowFieldConditionTypeClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowForm': ActionWorkflowFormClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowFormRequest': ActionWorkflowFormRequestClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowFormRequestField': ActionWorkflowFormRequestFieldClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowInfo': ActionWorkflowInfoClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowRequestAccess': ActionWorkflowRequestAccessClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowRequestStepState': ActionWorkflowRequestStepStateClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowSingleFieldValueCondition': ActionWorkflowSingleFieldValueConditionClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowStep': ActionWorkflowStepClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowStepActors': ActionWorkflowStepActorsClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowStepDynamicAssignment': ActionWorkflowStepDynamicAssignmentClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowStepDynamicAssignmentType': ActionWorkflowStepDynamicAssignmentTypeClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowStepType': ActionWorkflowStepTypeClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowTrigger': ActionWorkflowTriggerClass,
    'com.linkedin.pegasus2avro.actionworkflow.ActionWorkflowTriggerType': ActionWorkflowTriggerTypeClass,
    'com.linkedin.pegasus2avro.ai.AiInferenceMetadata': AiInferenceMetadataClass,
    'com.linkedin.pegasus2avro.ai.EntityInferenceMetadata': EntityInferenceMetadataClass,
    'com.linkedin.pegasus2avro.ai.GlossaryTermsInferenceMetadata': GlossaryTermsInferenceMetadataClass,
    'com.linkedin.pegasus2avro.ai.InferenceGroupMetadata': InferenceGroupMetadataClass,
    'com.linkedin.pegasus2avro.ai.InferenceMetadata': InferenceMetadataClass,
    'com.linkedin.pegasus2avro.anomaly.AnomalyReviewState': AnomalyReviewStateClass,
    'com.linkedin.pegasus2avro.anomaly.AnomalySource': AnomalySourceClass,
    'com.linkedin.pegasus2avro.anomaly.AnomalySourceProperties': AnomalySourcePropertiesClass,
    'com.linkedin.pegasus2avro.anomaly.AnomalySourceType': AnomalySourceTypeClass,
    'com.linkedin.pegasus2avro.anomaly.MonitorAnomalyEvent': MonitorAnomalyEventClass,
    'com.linkedin.pegasus2avro.anomaly.OperationRange': OperationRangeClass,
    'com.linkedin.pegasus2avro.application.ApplicationKey': ApplicationKeyClass,
    'com.linkedin.pegasus2avro.application.ApplicationProperties': ApplicationPropertiesClass,
    'com.linkedin.pegasus2avro.application.Applications': ApplicationsClass,
    'com.linkedin.pegasus2avro.assertion.AdjustmentAlgorithm': AdjustmentAlgorithmClass,
    'com.linkedin.pegasus2avro.assertion.AssertionAction': AssertionActionClass,
    'com.linkedin.pegasus2avro.assertion.AssertionActionType': AssertionActionTypeClass,
    'com.linkedin.pegasus2avro.assertion.AssertionActions': AssertionActionsClass,
    'com.linkedin.pegasus2avro.assertion.AssertionAdjustmentSettings': AssertionAdjustmentSettingsClass,
    'com.linkedin.pegasus2avro.assertion.AssertionAnalyticsRunEvent': AssertionAnalyticsRunEventClass,
    'com.linkedin.pegasus2avro.assertion.AssertionDryRunEvent': AssertionDryRunEventClass,
    'com.linkedin.pegasus2avro.assertion.AssertionDryRunResult': AssertionDryRunResultClass,
    'com.linkedin.pegasus2avro.assertion.AssertionExclusionWindow': AssertionExclusionWindowClass,
    'com.linkedin.pegasus2avro.assertion.AssertionExclusionWindowType': AssertionExclusionWindowTypeClass,
    'com.linkedin.pegasus2avro.assertion.AssertionInferenceDetails': AssertionInferenceDetailsClass,
    'com.linkedin.pegasus2avro.assertion.AssertionInfo': AssertionInfoClass,
    'com.linkedin.pegasus2avro.assertion.AssertionMetric': AssertionMetricClass,
    'com.linkedin.pegasus2avro.assertion.AssertionMonitorSensitivity': AssertionMonitorSensitivityClass,
    'com.linkedin.pegasus2avro.assertion.AssertionNote': AssertionNoteClass,
    'com.linkedin.pegasus2avro.assertion.AssertionResult': AssertionResultClass,
    'com.linkedin.pegasus2avro.assertion.AssertionResultError': AssertionResultErrorClass,
    'com.linkedin.pegasus2avro.assertion.AssertionResultErrorType': AssertionResultErrorTypeClass,
    'com.linkedin.pegasus2avro.assertion.AssertionResultType': AssertionResultTypeClass,
    'com.linkedin.pegasus2avro.assertion.AssertionRunEvent': AssertionRunEventClass,
    'com.linkedin.pegasus2avro.assertion.AssertionRunStatus': AssertionRunStatusClass,
    'com.linkedin.pegasus2avro.assertion.AssertionRunSummary': AssertionRunSummaryClass,
    'com.linkedin.pegasus2avro.assertion.AssertionSource': AssertionSourceClass,
    'com.linkedin.pegasus2avro.assertion.AssertionSourceType': AssertionSourceTypeClass,
    'com.linkedin.pegasus2avro.assertion.AssertionStdAggregation': AssertionStdAggregationClass,
    'com.linkedin.pegasus2avro.assertion.AssertionStdOperator': AssertionStdOperatorClass,
    'com.linkedin.pegasus2avro.assertion.AssertionStdParameter': AssertionStdParameterClass,
    'com.linkedin.pegasus2avro.assertion.AssertionStdParameterType': AssertionStdParameterTypeClass,
    'com.linkedin.pegasus2avro.assertion.AssertionStdParameters': AssertionStdParametersClass,
    'com.linkedin.pegasus2avro.assertion.AssertionType': AssertionTypeClass,
    'com.linkedin.pegasus2avro.assertion.AssertionValueChangeType': AssertionValueChangeTypeClass,
    'com.linkedin.pegasus2avro.assertion.BatchSpec': BatchSpecClass,
    'com.linkedin.pegasus2avro.assertion.CustomAssertionInfo': CustomAssertionInfoClass,
    'com.linkedin.pegasus2avro.assertion.DatasetAssertionInfo': DatasetAssertionInfoClass,
    'com.linkedin.pegasus2avro.assertion.DatasetAssertionScope': DatasetAssertionScopeClass,
    'com.linkedin.pegasus2avro.assertion.FieldAssertionInfo': FieldAssertionInfoClass,
    'com.linkedin.pegasus2avro.assertion.FieldAssertionType': FieldAssertionTypeClass,
    'com.linkedin.pegasus2avro.assertion.FieldMetricAssertion': FieldMetricAssertionClass,
    'com.linkedin.pegasus2avro.assertion.FieldMetricType': FieldMetricTypeClass,
    'com.linkedin.pegasus2avro.assertion.FieldTransform': FieldTransformClass,
    'com.linkedin.pegasus2avro.assertion.FieldTransformType': FieldTransformTypeClass,
    'com.linkedin.pegasus2avro.assertion.FieldValuesAssertion': FieldValuesAssertionClass,
    'com.linkedin.pegasus2avro.assertion.FieldValuesFailThreshold': FieldValuesFailThresholdClass,
    'com.linkedin.pegasus2avro.assertion.FieldValuesFailThresholdType': FieldValuesFailThresholdTypeClass,
    'com.linkedin.pegasus2avro.assertion.FixedIntervalSchedule': FixedIntervalScheduleClass,
    'com.linkedin.pegasus2avro.assertion.FreshnessAssertionInfo': FreshnessAssertionInfoClass,
    'com.linkedin.pegasus2avro.assertion.FreshnessAssertionSchedule': FreshnessAssertionScheduleClass,
    'com.linkedin.pegasus2avro.assertion.FreshnessAssertionScheduleType': FreshnessAssertionScheduleTypeClass,
    'com.linkedin.pegasus2avro.assertion.FreshnessAssertionType': FreshnessAssertionTypeClass,
    'com.linkedin.pegasus2avro.assertion.FreshnessCronSchedule': FreshnessCronScheduleClass,
    'com.linkedin.pegasus2avro.assertion.FreshnessFieldKind': FreshnessFieldKindClass,
    'com.linkedin.pegasus2avro.assertion.FreshnessFieldSpec': FreshnessFieldSpecClass,
    'com.linkedin.pegasus2avro.assertion.IncrementingSegmentFieldTransformer': IncrementingSegmentFieldTransformerClass,
    'com.linkedin.pegasus2avro.assertion.IncrementingSegmentFieldTransformerType': IncrementingSegmentFieldTransformerTypeClass,
    'com.linkedin.pegasus2avro.assertion.IncrementingSegmentRowCountChange': IncrementingSegmentRowCountChangeClass,
    'com.linkedin.pegasus2avro.assertion.IncrementingSegmentRowCountTotal': IncrementingSegmentRowCountTotalClass,
    'com.linkedin.pegasus2avro.assertion.IncrementingSegmentSpec': IncrementingSegmentSpecClass,
    'com.linkedin.pegasus2avro.assertion.RowCountChange': RowCountChangeClass,
    'com.linkedin.pegasus2avro.assertion.RowCountTotal': RowCountTotalClass,
    'com.linkedin.pegasus2avro.assertion.SchemaAssertionCompatibility': SchemaAssertionCompatibilityClass,
    'com.linkedin.pegasus2avro.assertion.SchemaAssertionInfo': SchemaAssertionInfoClass,
    'com.linkedin.pegasus2avro.assertion.SqlAssertionInfo': SqlAssertionInfoClass,
    'com.linkedin.pegasus2avro.assertion.SqlAssertionType': SqlAssertionTypeClass,
    'com.linkedin.pegasus2avro.assertion.VolumeAssertionInfo': VolumeAssertionInfoClass,
    'com.linkedin.pegasus2avro.assertion.VolumeAssertionType': VolumeAssertionTypeClass,
    'com.linkedin.pegasus2avro.businessattribute.BusinessAttributeAssociation': BusinessAttributeAssociationClass,
    'com.linkedin.pegasus2avro.businessattribute.BusinessAttributeInfo': BusinessAttributeInfoClass,
    'com.linkedin.pegasus2avro.businessattribute.BusinessAttributeKey': BusinessAttributeKeyClass,
    'com.linkedin.pegasus2avro.businessattribute.BusinessAttributes': BusinessAttributesClass,
    'com.linkedin.pegasus2avro.chart.ChartInfo': ChartInfoClass,
    'com.linkedin.pegasus2avro.chart.ChartQuery': ChartQueryClass,
    'com.linkedin.pegasus2avro.chart.ChartQueryType': ChartQueryTypeClass,
    'com.linkedin.pegasus2avro.chart.ChartType': ChartTypeClass,
    'com.linkedin.pegasus2avro.chart.ChartUsageStatistics': ChartUsageStatisticsClass,
    'com.linkedin.pegasus2avro.chart.ChartUserUsageCounts': ChartUserUsageCountsClass,
    'com.linkedin.pegasus2avro.chart.EditableChartProperties': EditableChartPropertiesClass,
    'com.linkedin.pegasus2avro.common.Access': AccessClass,
    'com.linkedin.pegasus2avro.common.AccessLevel': AccessLevelClass,
    'com.linkedin.pegasus2avro.common.AnomaliesSummary': AnomaliesSummaryClass,
    'com.linkedin.pegasus2avro.common.AnomalySummaryDetails': AnomalySummaryDetailsClass,
    'com.linkedin.pegasus2avro.common.AssertionSummaryDetails': AssertionSummaryDetailsClass,
    'com.linkedin.pegasus2avro.common.AssertionsSummary': AssertionsSummaryClass,
    'com.linkedin.pegasus2avro.common.AuditStamp': AuditStampClass,
    'com.linkedin.pegasus2avro.common.BrowsePathEntry': BrowsePathEntryClass,
    'com.linkedin.pegasus2avro.common.BrowsePaths': BrowsePathsClass,
    'com.linkedin.pegasus2avro.common.BrowsePathsV2': BrowsePathsV2Class,
    'com.linkedin.pegasus2avro.common.ChangeAuditStamps': ChangeAuditStampsClass,
    'com.linkedin.pegasus2avro.common.Cost': CostClass,
    'com.linkedin.pegasus2avro.common.CostCost': CostCostClass,
    'com.linkedin.pegasus2avro.common.CostCostDiscriminator': CostCostDiscriminatorClass,
    'com.linkedin.pegasus2avro.common.CostType': CostTypeClass,
    'com.linkedin.pegasus2avro.common.CronSchedule': CronScheduleClass,
    'com.linkedin.pegasus2avro.common.DataPlatformInstance': DataPlatformInstanceClass,
    'com.linkedin.pegasus2avro.common.DataTransform': DataTransformClass,
    'com.linkedin.pegasus2avro.common.DataTransformLogic': DataTransformLogicClass,
    'com.linkedin.pegasus2avro.common.Deprecation': DeprecationClass,
    'com.linkedin.pegasus2avro.common.DisplayProperties': DisplayPropertiesClass,
    'com.linkedin.pegasus2avro.common.Documentation': DocumentationClass,
    'com.linkedin.pegasus2avro.common.DocumentationAssociation': DocumentationAssociationClass,
    'com.linkedin.pegasus2avro.common.DocumentationPromptResponse': DocumentationPromptResponseClass,
    'com.linkedin.pegasus2avro.common.DomainPromptResponse': DomainPromptResponseClass,
    'com.linkedin.pegasus2avro.common.Edge': EdgeClass,
    'com.linkedin.pegasus2avro.common.Embed': EmbedClass,
    'com.linkedin.pegasus2avro.common.EmbeddingChunk': EmbeddingChunkClass,
    'com.linkedin.pegasus2avro.common.EmbeddingModelData': EmbeddingModelDataClass,
    'com.linkedin.pegasus2avro.common.FabricType': FabricTypeClass,
    'com.linkedin.pegasus2avro.common.FieldFormPromptAssociation': FieldFormPromptAssociationClass,
    'com.linkedin.pegasus2avro.common.FormAssociation': FormAssociationClass,
    'com.linkedin.pegasus2avro.common.FormPromptAssociation': FormPromptAssociationClass,
    'com.linkedin.pegasus2avro.common.FormPromptFieldAssociations': FormPromptFieldAssociationsClass,
    'com.linkedin.pegasus2avro.common.FormPromptResponse': FormPromptResponseClass,
    'com.linkedin.pegasus2avro.common.FormVerificationAssociation': FormVerificationAssociationClass,
    'com.linkedin.pegasus2avro.common.Forms': FormsClass,
    'com.linkedin.pegasus2avro.common.GlobalTags': GlobalTagsClass,
    'com.linkedin.pegasus2avro.common.GlossaryTermAssociation': GlossaryTermAssociationClass,
    'com.linkedin.pegasus2avro.common.GlossaryTerms': GlossaryTermsClass,
    'com.linkedin.pegasus2avro.common.GlossaryTermsPromptResponse': GlossaryTermsPromptResponseClass,
    'com.linkedin.pegasus2avro.common.IconLibrary': IconLibraryClass,
    'com.linkedin.pegasus2avro.common.IconProperties': IconPropertiesClass,
    'com.linkedin.pegasus2avro.common.IncidentSummaryDetails': IncidentSummaryDetailsClass,
    'com.linkedin.pegasus2avro.common.IncidentsSummary': IncidentsSummaryClass,
    'com.linkedin.pegasus2avro.common.InputField': InputFieldClass,
    'com.linkedin.pegasus2avro.common.InputFields': InputFieldsClass,
    'com.linkedin.pegasus2avro.common.InstitutionalMemory': InstitutionalMemoryClass,
    'com.linkedin.pegasus2avro.common.InstitutionalMemoryMetadata': InstitutionalMemoryMetadataClass,
    'com.linkedin.pegasus2avro.common.InstitutionalMemoryMetadataSettings': InstitutionalMemoryMetadataSettingsClass,
    'com.linkedin.pegasus2avro.common.MLFeatureDataType': MLFeatureDataTypeClass,
    'com.linkedin.pegasus2avro.common.Media': MediaClass,
    'com.linkedin.pegasus2avro.common.MediaType': MediaTypeClass,
    'com.linkedin.pegasus2avro.common.MetadataAttribution': MetadataAttributionClass,
    'com.linkedin.pegasus2avro.common.MetadataProducerType': MetadataProducerTypeClass,
    'com.linkedin.pegasus2avro.common.Operation': OperationClass,
    'com.linkedin.pegasus2avro.common.OperationSourceDetails': OperationSourceDetailsClass,
    'com.linkedin.pegasus2avro.common.OperationSourceOriginType': OperationSourceOriginTypeClass,
    'com.linkedin.pegasus2avro.common.OperationSourceType': OperationSourceTypeClass,
    'com.linkedin.pegasus2avro.common.OperationType': OperationTypeClass,
    'com.linkedin.pegasus2avro.common.Origin': OriginClass,
    'com.linkedin.pegasus2avro.common.OriginType': OriginTypeClass,
    'com.linkedin.pegasus2avro.common.Owner': OwnerClass,
    'com.linkedin.pegasus2avro.common.Ownership': OwnershipClass,
    'com.linkedin.pegasus2avro.common.OwnershipPromptResponse': OwnershipPromptResponseClass,
    'com.linkedin.pegasus2avro.common.OwnershipSource': OwnershipSourceClass,
    'com.linkedin.pegasus2avro.common.OwnershipSourceType': OwnershipSourceTypeClass,
    'com.linkedin.pegasus2avro.common.OwnershipType': OwnershipTypeClass,
    'com.linkedin.pegasus2avro.common.Proposals': ProposalsClass,
    'com.linkedin.pegasus2avro.common.RoleAssociation': RoleAssociationClass,
    'com.linkedin.pegasus2avro.common.SemanticContent': SemanticContentClass,
    'com.linkedin.pegasus2avro.common.SerializedValue': SerializedValueClass,
    'com.linkedin.pegasus2avro.common.SerializedValueContentType': SerializedValueContentTypeClass,
    'com.linkedin.pegasus2avro.common.SerializedValueSchemaType': SerializedValueSchemaTypeClass,
    'com.linkedin.pegasus2avro.common.Share': ShareClass,
    'com.linkedin.pegasus2avro.common.ShareConfig': ShareConfigClass,
    'com.linkedin.pegasus2avro.common.ShareResult': ShareResultClass,
    'com.linkedin.pegasus2avro.common.ShareResultState': ShareResultStateClass,
    'com.linkedin.pegasus2avro.common.Siblings': SiblingsClass,
    'com.linkedin.pegasus2avro.common.SourceDetails': SourceDetailsClass,
    'com.linkedin.pegasus2avro.common.Status': StatusClass,
    'com.linkedin.pegasus2avro.common.StructuredPropertyPromptResponse': StructuredPropertyPromptResponseClass,
    'com.linkedin.pegasus2avro.common.SubTypes': SubTypesClass,
    'com.linkedin.pegasus2avro.common.SyncMechanism': SyncMechanismClass,
    'com.linkedin.pegasus2avro.common.TagAssociation': TagAssociationClass,
    'com.linkedin.pegasus2avro.common.TimeStamp': TimeStampClass,
    'com.linkedin.pegasus2avro.common.VersionProperties': VersionPropertiesClass,
    'com.linkedin.pegasus2avro.common.VersionTag': VersionTagClass,
    'com.linkedin.pegasus2avro.common.WindowDuration': WindowDurationClass,
    'com.linkedin.pegasus2avro.common.fieldtransformer.TransformationType': TransformationTypeClass,
    'com.linkedin.pegasus2avro.common.fieldtransformer.UDFTransformer': UDFTransformerClass,
    'com.linkedin.pegasus2avro.connection.DataHubConnectionDetails': DataHubConnectionDetailsClass,
    'com.linkedin.pegasus2avro.connection.DataHubConnectionDetailsType': DataHubConnectionDetailsTypeClass,
    'com.linkedin.pegasus2avro.connection.DataHubJsonConnection': DataHubJsonConnectionClass,
    'com.linkedin.pegasus2avro.constraint.ConstraintInfo': ConstraintInfoClass,
    'com.linkedin.pegasus2avro.constraint.ConstraintParams': ConstraintParamsClass,
    'com.linkedin.pegasus2avro.constraint.GlossaryTermInNodeConstraint': GlossaryTermInNodeConstraintClass,
    'com.linkedin.pegasus2avro.container.Container': ContainerClass,
    'com.linkedin.pegasus2avro.container.ContainerProperties': ContainerPropertiesClass,
    'com.linkedin.pegasus2avro.container.EditableContainerProperties': EditableContainerPropertiesClass,
    'com.linkedin.pegasus2avro.conversation.DataHubAiConversationActor': DataHubAiConversationActorClass,
    'com.linkedin.pegasus2avro.conversation.DataHubAiConversationActorType': DataHubAiConversationActorTypeClass,
    'com.linkedin.pegasus2avro.conversation.DataHubAiConversationContext': DataHubAiConversationContextClass,
    'com.linkedin.pegasus2avro.conversation.DataHubAiConversationInfo': DataHubAiConversationInfoClass,
    'com.linkedin.pegasus2avro.conversation.DataHubAiConversationMessage': DataHubAiConversationMessageClass,
    'com.linkedin.pegasus2avro.conversation.DataHubAiConversationMessageContent': DataHubAiConversationMessageContentClass,
    'com.linkedin.pegasus2avro.conversation.DataHubAiConversationMessageType': DataHubAiConversationMessageTypeClass,
    'com.linkedin.pegasus2avro.conversation.DataHubAiConversationOriginType': DataHubAiConversationOriginTypeClass,
    'com.linkedin.pegasus2avro.dashboard.DashboardInfo': DashboardInfoClass,
    'com.linkedin.pegasus2avro.dashboard.DashboardUsageStatistics': DashboardUsageStatisticsClass,
    'com.linkedin.pegasus2avro.dashboard.DashboardUserUsageCounts': DashboardUserUsageCountsClass,
    'com.linkedin.pegasus2avro.dashboard.EditableDashboardProperties': EditableDashboardPropertiesClass,
    'com.linkedin.pegasus2avro.datacontract.DataContractProperties': DataContractPropertiesClass,
    'com.linkedin.pegasus2avro.datacontract.DataContractState': DataContractStateClass,
    'com.linkedin.pegasus2avro.datacontract.DataContractStatus': DataContractStatusClass,
    'com.linkedin.pegasus2avro.datacontract.DataQualityContract': DataQualityContractClass,
    'com.linkedin.pegasus2avro.datacontract.FreshnessContract': FreshnessContractClass,
    'com.linkedin.pegasus2avro.datacontract.SchemaContract': SchemaContractClass,
    'com.linkedin.pegasus2avro.datacontract.SlaContract': SlaContractClass,
    'com.linkedin.pegasus2avro.datahub.DataHubSearchConfig': DataHubSearchConfigClass,
    'com.linkedin.pegasus2avro.datahub.SearchFieldType': SearchFieldTypeClass,
    'com.linkedin.pegasus2avro.datajob.DataFlowInfo': DataFlowInfoClass,
    'com.linkedin.pegasus2avro.datajob.DataJobInfo': DataJobInfoClass,
    'com.linkedin.pegasus2avro.datajob.DataJobInputOutput': DataJobInputOutputClass,
    'com.linkedin.pegasus2avro.datajob.EditableDataFlowProperties': EditableDataFlowPropertiesClass,
    'com.linkedin.pegasus2avro.datajob.EditableDataJobProperties': EditableDataJobPropertiesClass,
    'com.linkedin.pegasus2avro.datajob.JobStatus': JobStatusClass,
    'com.linkedin.pegasus2avro.datajob.VersionInfo': VersionInfoClass,
    'com.linkedin.pegasus2avro.datajob.azkaban.AzkabanJobType': AzkabanJobTypeClass,
    'com.linkedin.pegasus2avro.datajob.datahub.DatahubIngestionCheckpoint': DatahubIngestionCheckpointClass,
    'com.linkedin.pegasus2avro.datajob.datahub.DatahubIngestionRunSummary': DatahubIngestionRunSummaryClass,
    'com.linkedin.pegasus2avro.datajob.datahub.IngestionCheckpointState': IngestionCheckpointStateClass,
    'com.linkedin.pegasus2avro.dataplatform.DataPlatformInfo': DataPlatformInfoClass,
    'com.linkedin.pegasus2avro.dataplatform.PlatformType': PlatformTypeClass,
    'com.linkedin.pegasus2avro.dataplatform.slack.SlackUserInfo': SlackUserInfoClass,
    'com.linkedin.pegasus2avro.dataplatforminstance.DataPlatformInstanceProperties': DataPlatformInstancePropertiesClass,
    'com.linkedin.pegasus2avro.dataplatforminstance.IcebergWarehouseInfo': IcebergWarehouseInfoClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessInfo': DataProcessInfoClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceInput': DataProcessInstanceInputClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceOutput': DataProcessInstanceOutputClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceProperties': DataProcessInstancePropertiesClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceRelationships': DataProcessInstanceRelationshipsClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceRunEvent': DataProcessInstanceRunEventClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessInstanceRunResult': DataProcessInstanceRunResultClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessRunStatus': DataProcessRunStatusClass,
    'com.linkedin.pegasus2avro.dataprocess.DataProcessType': DataProcessTypeClass,
    'com.linkedin.pegasus2avro.dataprocess.RunResultType': RunResultTypeClass,
    'com.linkedin.pegasus2avro.dataproduct.DataProductAssociation': DataProductAssociationClass,
    'com.linkedin.pegasus2avro.dataproduct.DataProductKey': DataProductKeyClass,
    'com.linkedin.pegasus2avro.dataproduct.DataProductProperties': DataProductPropertiesClass,
    'com.linkedin.pegasus2avro.dataset.DatasetDeprecation': DatasetDeprecationClass,
    'com.linkedin.pegasus2avro.dataset.DatasetFieldMapping': DatasetFieldMappingClass,
    'com.linkedin.pegasus2avro.dataset.DatasetFieldProfile': DatasetFieldProfileClass,
    'com.linkedin.pegasus2avro.dataset.DatasetFieldUsageCounts': DatasetFieldUsageCountsClass,
    'com.linkedin.pegasus2avro.dataset.DatasetFilter': DatasetFilterClass,
    'com.linkedin.pegasus2avro.dataset.DatasetFilterType': DatasetFilterTypeClass,
    'com.linkedin.pegasus2avro.dataset.DatasetLineageType': DatasetLineageTypeClass,
    'com.linkedin.pegasus2avro.dataset.DatasetMetricsOriginType': DatasetMetricsOriginTypeClass,
    'com.linkedin.pegasus2avro.dataset.DatasetMetricsSourceDetails': DatasetMetricsSourceDetailsClass,
    'com.linkedin.pegasus2avro.dataset.DatasetProfile': DatasetProfileClass,
    'com.linkedin.pegasus2avro.dataset.DatasetProperties': DatasetPropertiesClass,
    'com.linkedin.pegasus2avro.dataset.DatasetUpstreamLineage': DatasetUpstreamLineageClass,
    'com.linkedin.pegasus2avro.dataset.DatasetUsageStatistics': DatasetUsageStatisticsClass,
    'com.linkedin.pegasus2avro.dataset.DatasetUserUsageCounts': DatasetUserUsageCountsClass,
    'com.linkedin.pegasus2avro.dataset.EditableDatasetProperties': EditableDatasetPropertiesClass,
    'com.linkedin.pegasus2avro.dataset.FineGrainedLineage': FineGrainedLineageClass,
    'com.linkedin.pegasus2avro.dataset.FineGrainedLineageDownstreamType': FineGrainedLineageDownstreamTypeClass,
    'com.linkedin.pegasus2avro.dataset.FineGrainedLineageUpstreamType': FineGrainedLineageUpstreamTypeClass,
    'com.linkedin.pegasus2avro.dataset.Histogram': HistogramClass,
    'com.linkedin.pegasus2avro.dataset.IcebergCatalogInfo': IcebergCatalogInfoClass,
    'com.linkedin.pegasus2avro.dataset.PartitionSummary': PartitionSummaryClass,
    'com.linkedin.pegasus2avro.dataset.PartitionsSummary': PartitionsSummaryClass,
    'com.linkedin.pegasus2avro.dataset.Quantile': QuantileClass,
    'com.linkedin.pegasus2avro.dataset.SchemaFieldProfile': SchemaFieldProfileClass,
    'com.linkedin.pegasus2avro.dataset.Upstream': UpstreamClass,
    'com.linkedin.pegasus2avro.dataset.UpstreamLineage': UpstreamLineageClass,
    'com.linkedin.pegasus2avro.dataset.ValueFrequency': ValueFrequencyClass,
    'com.linkedin.pegasus2avro.dataset.ViewProperties': ViewPropertiesClass,
    'com.linkedin.pegasus2avro.datatype.DataTypeInfo': DataTypeInfoClass,
    'com.linkedin.pegasus2avro.datatype.DataTypeKey': DataTypeKeyClass,
    'com.linkedin.pegasus2avro.domain.DomainProperties': DomainPropertiesClass,
    'com.linkedin.pegasus2avro.domain.Domains': DomainsClass,
    'com.linkedin.pegasus2avro.entitytype.EntityTypeInfo': EntityTypeInfoClass,
    'com.linkedin.pegasus2avro.entitytype.EntityTypeKey': EntityTypeKeyClass,
    'com.linkedin.pegasus2avro.ermodelrelation.ERModelRelationshipCardinality': ERModelRelationshipCardinalityClass,
    'com.linkedin.pegasus2avro.ermodelrelation.ERModelRelationshipProperties': ERModelRelationshipPropertiesClass,
    'com.linkedin.pegasus2avro.ermodelrelation.EditableERModelRelationshipProperties': EditableERModelRelationshipPropertiesClass,
    'com.linkedin.pegasus2avro.ermodelrelation.RelationshipFieldMapping': RelationshipFieldMappingClass,
    'com.linkedin.pegasus2avro.event.notification.NotificationContext': NotificationContextClass,
    'com.linkedin.pegasus2avro.event.notification.NotificationMessage': NotificationMessageClass,
    'com.linkedin.pegasus2avro.event.notification.NotificationRecipient': NotificationRecipientClass,
    'com.linkedin.pegasus2avro.event.notification.NotificationRecipientOriginType': NotificationRecipientOriginTypeClass,
    'com.linkedin.pegasus2avro.event.notification.NotificationRecipientType': NotificationRecipientTypeClass,
    'com.linkedin.pegasus2avro.event.notification.NotificationRequest': NotificationRequestClass,
    'com.linkedin.pegasus2avro.event.notification.NotificationSink': NotificationSinkClass,
    'com.linkedin.pegasus2avro.event.notification.NotificationSinkType': NotificationSinkTypeClass,
    'com.linkedin.pegasus2avro.event.notification.settings.EmailNotificationSettings': EmailNotificationSettingsClass,
    'com.linkedin.pegasus2avro.event.notification.settings.NotificationSettings': NotificationSettingsClass,
    'com.linkedin.pegasus2avro.event.notification.settings.SlackNotificationSettings': SlackNotificationSettingsClass,
    'com.linkedin.pegasus2avro.event.notification.settings.TeamsNotificationSettings': TeamsNotificationSettingsClass,
    'com.linkedin.pegasus2avro.event.notification.template.NotificationTemplateType': NotificationTemplateTypeClass,
    'com.linkedin.pegasus2avro.event.notification.template.OwnershipParameters': OwnershipParametersClass,
    'com.linkedin.pegasus2avro.events.metadata.ChangeType': ChangeTypeClass,
    'com.linkedin.pegasus2avro.execution.ExecutionRequestArtifactsLocation': ExecutionRequestArtifactsLocationClass,
    'com.linkedin.pegasus2avro.execution.ExecutionRequestInput': ExecutionRequestInputClass,
    'com.linkedin.pegasus2avro.execution.ExecutionRequestResult': ExecutionRequestResultClass,
    'com.linkedin.pegasus2avro.execution.ExecutionRequestSignal': ExecutionRequestSignalClass,
    'com.linkedin.pegasus2avro.execution.ExecutionRequestSource': ExecutionRequestSourceClass,
    'com.linkedin.pegasus2avro.execution.StructuredExecutionReport': StructuredExecutionReportClass,
    'com.linkedin.pegasus2avro.executor.RemoteExecutorStatus': RemoteExecutorStatusClass,
    'com.linkedin.pegasus2avro.executorglobalconfig.RemoteExecutorPoolGlobalConfig': RemoteExecutorPoolGlobalConfigClass,
    'com.linkedin.pegasus2avro.executorpool.RemoteExecutorPoolInfo': RemoteExecutorPoolInfoClass,
    'com.linkedin.pegasus2avro.executorpool.RemoteExecutorPoolState': RemoteExecutorPoolStateClass,
    'com.linkedin.pegasus2avro.executorpool.RemoteExecutorPoolStatus': RemoteExecutorPoolStatusClass,
    'com.linkedin.pegasus2avro.file.BucketStorageLocation': BucketStorageLocationClass,
    'com.linkedin.pegasus2avro.file.DataHubFileInfo': DataHubFileInfoClass,
    'com.linkedin.pegasus2avro.file.FileUploadScenario': FileUploadScenarioClass,
    'com.linkedin.pegasus2avro.form.AssignmentStatus': AssignmentStatusClass,
    'com.linkedin.pegasus2avro.form.DomainParams': DomainParamsClass,
    'com.linkedin.pegasus2avro.form.DynamicFormAssignment': DynamicFormAssignmentClass,
    'com.linkedin.pegasus2avro.form.FormActorAssignment': FormActorAssignmentClass,
    'com.linkedin.pegasus2avro.form.FormAssignmentStatus': FormAssignmentStatusClass,
    'com.linkedin.pegasus2avro.form.FormInfo': FormInfoClass,
    'com.linkedin.pegasus2avro.form.FormNotificationSettings': FormNotificationSettingsClass,
    'com.linkedin.pegasus2avro.form.FormPrompt': FormPromptClass,
    'com.linkedin.pegasus2avro.form.FormPromptType': FormPromptTypeClass,
    'com.linkedin.pegasus2avro.form.FormSettings': FormSettingsClass,
    'com.linkedin.pegasus2avro.form.FormState': FormStateClass,
    'com.linkedin.pegasus2avro.form.FormStatus': FormStatusClass,
    'com.linkedin.pegasus2avro.form.FormType': FormTypeClass,
    'com.linkedin.pegasus2avro.form.GlossaryTermsParams': GlossaryTermsParamsClass,
    'com.linkedin.pegasus2avro.form.OwnershipParams': OwnershipParamsClass,
    'com.linkedin.pegasus2avro.form.PromptCardinality': PromptCardinalityClass,
    'com.linkedin.pegasus2avro.form.StructuredPropertyParams': StructuredPropertyParamsClass,
    'com.linkedin.pegasus2avro.glossary.GlossaryNodeInfo': GlossaryNodeInfoClass,
    'com.linkedin.pegasus2avro.glossary.GlossaryRelatedTerms': GlossaryRelatedTermsClass,
    'com.linkedin.pegasus2avro.glossary.GlossaryTermInfo': GlossaryTermInfoClass,
    'com.linkedin.pegasus2avro.identity.CorpGroupEditableInfo': CorpGroupEditableInfoClass,
    'com.linkedin.pegasus2avro.identity.CorpGroupInfo': CorpGroupInfoClass,
    'com.linkedin.pegasus2avro.identity.CorpGroupSettings': CorpGroupSettingsClass,
    'com.linkedin.pegasus2avro.identity.CorpUserAppearanceSettings': CorpUserAppearanceSettingsClass,
    'com.linkedin.pegasus2avro.identity.CorpUserCredentials': CorpUserCredentialsClass,
    'com.linkedin.pegasus2avro.identity.CorpUserEditableInfo': CorpUserEditableInfoClass,
    'com.linkedin.pegasus2avro.identity.CorpUserHomePageSettings': CorpUserHomePageSettingsClass,
    'com.linkedin.pegasus2avro.identity.CorpUserInfo': CorpUserInfoClass,
    'com.linkedin.pegasus2avro.identity.CorpUserInvitationStatus': CorpUserInvitationStatusClass,
    'com.linkedin.pegasus2avro.identity.CorpUserSettings': CorpUserSettingsClass,
    'com.linkedin.pegasus2avro.identity.CorpUserStatus': CorpUserStatusClass,
    'com.linkedin.pegasus2avro.identity.CorpUserViewsSettings': CorpUserViewsSettingsClass,
    'com.linkedin.pegasus2avro.identity.GroupMembership': GroupMembershipClass,
    'com.linkedin.pegasus2avro.identity.InvitationStatus': InvitationStatusClass,
    'com.linkedin.pegasus2avro.identity.InviteToken': InviteTokenClass,
    'com.linkedin.pegasus2avro.identity.NativeGroupMembership': NativeGroupMembershipClass,
    'com.linkedin.pegasus2avro.identity.RoleMembership': RoleMembershipClass,
    'com.linkedin.pegasus2avro.identity.TokenType': TokenTypeClass,
    'com.linkedin.pegasus2avro.incident.IncidentActivityChange': IncidentActivityChangeClass,
    'com.linkedin.pegasus2avro.incident.IncidentActivityChangeType': IncidentActivityChangeTypeClass,
    'com.linkedin.pegasus2avro.incident.IncidentActivityEvent': IncidentActivityEventClass,
    'com.linkedin.pegasus2avro.incident.IncidentAssignee': IncidentAssigneeClass,
    'com.linkedin.pegasus2avro.incident.IncidentInfo': IncidentInfoClass,
    'com.linkedin.pegasus2avro.incident.IncidentNotificationDetails': IncidentNotificationDetailsClass,
    'com.linkedin.pegasus2avro.incident.IncidentSource': IncidentSourceClass,
    'com.linkedin.pegasus2avro.incident.IncidentSourceType': IncidentSourceTypeClass,
    'com.linkedin.pegasus2avro.incident.IncidentStage': IncidentStageClass,
    'com.linkedin.pegasus2avro.incident.IncidentState': IncidentStateClass,
    'com.linkedin.pegasus2avro.incident.IncidentStatus': IncidentStatusClass,
    'com.linkedin.pegasus2avro.incident.IncidentType': IncidentTypeClass,
    'com.linkedin.pegasus2avro.incident.SlackIncidentDetails': SlackIncidentDetailsClass,
    'com.linkedin.pegasus2avro.incident.SlackMessageDetails': SlackMessageDetailsClass,
    'com.linkedin.pegasus2avro.inferred.InferredDescription': InferredDescriptionClass,
    'com.linkedin.pegasus2avro.inferred.InferredGlossaryTerms': InferredGlossaryTermsClass,
    'com.linkedin.pegasus2avro.inferred.InferredMetadata': InferredMetadataClass,
    'com.linkedin.pegasus2avro.inferred.InferredMetadataSource': InferredMetadataSourceClass,
    'com.linkedin.pegasus2avro.inferred.InferredNeighbor': InferredNeighborClass,
    'com.linkedin.pegasus2avro.inferred.InferredNeighbors': InferredNeighborsClass,
    'com.linkedin.pegasus2avro.inferred.InferredOwners': InferredOwnersClass,
    'com.linkedin.pegasus2avro.inferred.InferredTags': InferredTagsClass,
    'com.linkedin.pegasus2avro.inferred.SchemaFieldInferredMetadata': SchemaFieldInferredMetadataClass,
    'com.linkedin.pegasus2avro.inferred.SchemaFieldInferredNeighbors': SchemaFieldInferredNeighborsClass,
    'com.linkedin.pegasus2avro.inferred.SchemaFieldsInferredMetadata': SchemaFieldsInferredMetadataClass,
    'com.linkedin.pegasus2avro.inferred.SchemaFieldsInferredNeighbors': SchemaFieldsInferredNeighborsClass,
    'com.linkedin.pegasus2avro.inferred.SimilarityFactor': SimilarityFactorClass,
    'com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceConfig': DataHubIngestionSourceConfigClass,
    'com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceInfo': DataHubIngestionSourceInfoClass,
    'com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceSchedule': DataHubIngestionSourceScheduleClass,
    'com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceSource': DataHubIngestionSourceSourceClass,
    'com.linkedin.pegasus2avro.ingestion.DataHubIngestionSourceSourceType': DataHubIngestionSourceSourceTypeClass,
    'com.linkedin.pegasus2avro.knowledge.DocumentContents': DocumentContentsClass,
    'com.linkedin.pegasus2avro.knowledge.DocumentInfo': DocumentInfoClass,
    'com.linkedin.pegasus2avro.knowledge.DocumentSettings': DocumentSettingsClass,
    'com.linkedin.pegasus2avro.knowledge.DocumentSource': DocumentSourceClass,
    'com.linkedin.pegasus2avro.knowledge.DocumentSourceType': DocumentSourceTypeClass,
    'com.linkedin.pegasus2avro.knowledge.DocumentState': DocumentStateClass,
    'com.linkedin.pegasus2avro.knowledge.DocumentStatus': DocumentStatusClass,
    'com.linkedin.pegasus2avro.knowledge.ParentDocument': ParentDocumentClass,
    'com.linkedin.pegasus2avro.knowledge.RelatedAsset': RelatedAssetClass,
    'com.linkedin.pegasus2avro.knowledge.RelatedDocument': RelatedDocumentClass,
    'com.linkedin.pegasus2avro.link.LinkPreviewInfo': LinkPreviewInfoClass,
    'com.linkedin.pegasus2avro.link.LinkPreviewType': LinkPreviewTypeClass,
    'com.linkedin.pegasus2avro.logical.LogicalParent': LogicalParentClass,
    'com.linkedin.pegasus2avro.metadata.key.ActionRequestKey': ActionRequestKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.ActionWorkflowKey': ActionWorkflowKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.AnomalyKey': AnomalyKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.AssertionKey': AssertionKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.ChartKey': ChartKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.ConstraintKey': ConstraintKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.ContainerKey': ContainerKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.CorpGroupKey': CorpGroupKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.CorpUserKey': CorpUserKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DashboardKey': DashboardKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataContractKey': DataContractKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataFlowKey': DataFlowKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubAccessTokenKey': DataHubAccessTokenKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubActionKey': DataHubActionKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubAiConversationKey': DataHubAiConversationKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubConnectionKey': DataHubConnectionKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubFileKey': DataHubFileKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubIngestionSourceKey': DataHubIngestionSourceKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubMetricCubeKey': DataHubMetricCubeKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubOpenAPISchemaKey': DataHubOpenAPISchemaKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubPageModuleKey': DataHubPageModuleKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubPageTemplateKey': DataHubPageTemplateKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubPersonaKey': DataHubPersonaKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubPolicyKey': DataHubPolicyKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubRetentionKey': DataHubRetentionKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubRoleKey': DataHubRoleKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubSecretKey': DataHubSecretKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubStepStateKey': DataHubStepStateKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubUpgradeKey': DataHubUpgradeKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataHubViewKey': DataHubViewKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataJobKey': DataJobKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataPlatformInstanceKey': DataPlatformInstanceKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataPlatformKey': DataPlatformKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataProcessInstanceKey': DataProcessInstanceKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DataProcessKey': DataProcessKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DatasetKey': DatasetKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DocumentKey': DocumentKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.DomainKey': DomainKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.ERModelRelationshipKey': ERModelRelationshipKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.ExecutionRequestKey': ExecutionRequestKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.FormKey': FormKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.GenericEntityKey': GenericEntityKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.GlobalSettingsKey': GlobalSettingsKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.GlossaryNodeKey': GlossaryNodeKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.GlossaryTermKey': GlossaryTermKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.IncidentKey': IncidentKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.InviteTokenKey': InviteTokenKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.LinkPreviewKey': LinkPreviewKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.MLFeatureKey': MLFeatureKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.MLFeatureTableKey': MLFeatureTableKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.MLModelDeploymentKey': MLModelDeploymentKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.MLModelGroupKey': MLModelGroupKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.MLModelKey': MLModelKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.MLPrimaryKeyKey': MLPrimaryKeyKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.MonitorKey': MonitorKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.MonitorSuiteKey': MonitorSuiteKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.NotebookKey': NotebookKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.OwnershipTypeKey': OwnershipTypeKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.PostKey': PostKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.QueryKey': QueryKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.RecommendationModuleKey': RecommendationModuleKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.RemoteExecutorGlobalConfigKey': RemoteExecutorGlobalConfigKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.RemoteExecutorKey': RemoteExecutorKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.RemoteExecutorPoolKey': RemoteExecutorPoolKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.RoleKey': RoleKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.SchemaFieldKey': SchemaFieldKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.SubscriptionKey': SubscriptionKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.TagKey': TagKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.TelemetryKey': TelemetryKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.TestKey': TestKeyClass,
    'com.linkedin.pegasus2avro.metadata.key.VersionSetKey': VersionSetKeyClass,
    'com.linkedin.pegasus2avro.metadata.query.filter.Condition': ConditionClass,
    'com.linkedin.pegasus2avro.metadata.query.filter.ConjunctiveCriterion': ConjunctiveCriterionClass,
    'com.linkedin.pegasus2avro.metadata.query.filter.Criterion': CriterionClass,
    'com.linkedin.pegasus2avro.metadata.query.filter.Filter': FilterClass,
    'com.linkedin.pegasus2avro.metadata.recommendation.ContentParams': ContentParamsClass,
    'com.linkedin.pegasus2avro.metadata.recommendation.EntityProfileParams': EntityProfileParamsClass,
    'com.linkedin.pegasus2avro.metadata.recommendation.RecommendationContent': RecommendationContentClass,
    'com.linkedin.pegasus2avro.metadata.recommendation.RecommendationModule': RecommendationModuleClass,
    'com.linkedin.pegasus2avro.metadata.recommendation.RecommendationParams': RecommendationParamsClass,
    'com.linkedin.pegasus2avro.metadata.recommendation.RecommendationRenderType': RecommendationRenderTypeClass,
    'com.linkedin.pegasus2avro.metadata.recommendation.SearchParams': SearchParamsClass,
    'com.linkedin.pegasus2avro.metadata.search.features.CorpUserUsageFeatures': CorpUserUsageFeaturesClass,
    'com.linkedin.pegasus2avro.metadata.search.features.CostCurrencyCode': CostCurrencyCodeClass,
    'com.linkedin.pegasus2avro.metadata.search.features.CostFeatures': CostFeaturesClass,
    'com.linkedin.pegasus2avro.metadata.search.features.LineageFeatures': LineageFeaturesClass,
    'com.linkedin.pegasus2avro.metadata.search.features.StorageFeatures': StorageFeaturesClass,
    'com.linkedin.pegasus2avro.metadata.search.features.UsageFeatures': UsageFeaturesClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.ActionRequestSnapshot': ActionRequestSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.ChartSnapshot': ChartSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.CorpGroupSnapshot': CorpGroupSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.CorpUserSnapshot': CorpUserSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.DashboardSnapshot': DashboardSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.DataFlowSnapshot': DataFlowSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.DataHubPolicySnapshot': DataHubPolicySnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.DataHubRetentionSnapshot': DataHubRetentionSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.DataJobSnapshot': DataJobSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.DataPlatformSnapshot': DataPlatformSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.DataProcessSnapshot': DataProcessSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.DatasetSnapshot': DatasetSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.GlossaryNodeSnapshot': GlossaryNodeSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.GlossaryTermSnapshot': GlossaryTermSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.MLFeatureSnapshot': MLFeatureSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.MLFeatureTableSnapshot': MLFeatureTableSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.MLModelDeploymentSnapshot': MLModelDeploymentSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.MLModelGroupSnapshot': MLModelGroupSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.MLModelSnapshot': MLModelSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.MLPrimaryKeySnapshot': MLPrimaryKeySnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.SchemaFieldSnapshot': SchemaFieldSnapshotClass,
    'com.linkedin.pegasus2avro.metadata.snapshot.TagSnapshot': TagSnapshotClass,
    'com.linkedin.pegasus2avro.metric.DataHubMetricCubeDefinition': DataHubMetricCubeDefinitionClass,
    'com.linkedin.pegasus2avro.metric.DataHubMetricCubeDimension': DataHubMetricCubeDimensionClass,
    'com.linkedin.pegasus2avro.metric.DataHubMetricCubeDimensions': DataHubMetricCubeDimensionsClass,
    'com.linkedin.pegasus2avro.metric.DataHubMetricCubeEvent': DataHubMetricCubeEventClass,
    'com.linkedin.pegasus2avro.metric.DataHubMetricCubeMeasure': DataHubMetricCubeMeasureClass,
    'com.linkedin.pegasus2avro.metric.DataHubMetricCubeMeasures': DataHubMetricCubeMeasuresClass,
    'com.linkedin.pegasus2avro.metric.DataHubMetricCubeOrigin': DataHubMetricCubeOriginClass,
    'com.linkedin.pegasus2avro.metric.DataHubMetricSourceType': DataHubMetricSourceTypeClass,
    'com.linkedin.pegasus2avro.ml.metadata.BaseData': BaseDataClass,
    'com.linkedin.pegasus2avro.ml.metadata.CaveatDetails': CaveatDetailsClass,
    'com.linkedin.pegasus2avro.ml.metadata.CaveatsAndRecommendations': CaveatsAndRecommendationsClass,
    'com.linkedin.pegasus2avro.ml.metadata.DeploymentStatus': DeploymentStatusClass,
    'com.linkedin.pegasus2avro.ml.metadata.EditableMLFeatureProperties': EditableMLFeaturePropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.EditableMLFeatureTableProperties': EditableMLFeatureTablePropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.EditableMLModelGroupProperties': EditableMLModelGroupPropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.EditableMLModelProperties': EditableMLModelPropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.EditableMLPrimaryKeyProperties': EditableMLPrimaryKeyPropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.EthicalConsiderations': EthicalConsiderationsClass,
    'com.linkedin.pegasus2avro.ml.metadata.EvaluationData': EvaluationDataClass,
    'com.linkedin.pegasus2avro.ml.metadata.IntendedUse': IntendedUseClass,
    'com.linkedin.pegasus2avro.ml.metadata.IntendedUserType': IntendedUserTypeClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLFeatureProperties': MLFeaturePropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLFeatureTableProperties': MLFeatureTablePropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLHyperParam': MLHyperParamClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLMetric': MLMetricClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLModelDeploymentProperties': MLModelDeploymentPropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLModelFactorPrompts': MLModelFactorPromptsClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLModelFactors': MLModelFactorsClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLModelGroupProperties': MLModelGroupPropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLModelProperties': MLModelPropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLPrimaryKeyProperties': MLPrimaryKeyPropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.MLTrainingRunProperties': MLTrainingRunPropertiesClass,
    'com.linkedin.pegasus2avro.ml.metadata.Metrics': MetricsClass,
    'com.linkedin.pegasus2avro.ml.metadata.QuantitativeAnalyses': QuantitativeAnalysesClass,
    'com.linkedin.pegasus2avro.ml.metadata.SourceCode': SourceCodeClass,
    'com.linkedin.pegasus2avro.ml.metadata.SourceCodeUrl': SourceCodeUrlClass,
    'com.linkedin.pegasus2avro.ml.metadata.SourceCodeUrlType': SourceCodeUrlTypeClass,
    'com.linkedin.pegasus2avro.ml.metadata.TrainingData': TrainingDataClass,
    'com.linkedin.pegasus2avro.module.AssetCollectionModuleParams': AssetCollectionModuleParamsClass,
    'com.linkedin.pegasus2avro.module.DataHubPageModuleParams': DataHubPageModuleParamsClass,
    'com.linkedin.pegasus2avro.module.DataHubPageModuleProperties': DataHubPageModulePropertiesClass,
    'com.linkedin.pegasus2avro.module.DataHubPageModuleType': DataHubPageModuleTypeClass,
    'com.linkedin.pegasus2avro.module.DataHubPageModuleVisibility': DataHubPageModuleVisibilityClass,
    'com.linkedin.pegasus2avro.module.HierarchyModuleParams': HierarchyModuleParamsClass,
    'com.linkedin.pegasus2avro.module.LinkModuleParams': LinkModuleParamsClass,
    'com.linkedin.pegasus2avro.module.PageModuleScope': PageModuleScopeClass,
    'com.linkedin.pegasus2avro.module.RichTextModuleParams': RichTextModuleParamsClass,
    'com.linkedin.pegasus2avro.monitor.AssertionEvaluationContext': AssertionEvaluationContextClass,
    'com.linkedin.pegasus2avro.monitor.AssertionEvaluationParameters': AssertionEvaluationParametersClass,
    'com.linkedin.pegasus2avro.monitor.AssertionEvaluationParametersType': AssertionEvaluationParametersTypeClass,
    'com.linkedin.pegasus2avro.monitor.AssertionEvaluationSpec': AssertionEvaluationSpecClass,
    'com.linkedin.pegasus2avro.monitor.AssertionMonitor': AssertionMonitorClass,
    'com.linkedin.pegasus2avro.monitor.AssertionMonitorBootstrapStatus': AssertionMonitorBootstrapStatusClass,
    'com.linkedin.pegasus2avro.monitor.AssertionMonitorCapability': AssertionMonitorCapabilityClass,
    'com.linkedin.pegasus2avro.monitor.AssertionMonitorMetricsCubeBootstrapState': AssertionMonitorMetricsCubeBootstrapStateClass,
    'com.linkedin.pegasus2avro.monitor.AssertionMonitorMetricsCubeBootstrapStatus': AssertionMonitorMetricsCubeBootstrapStatusClass,
    'com.linkedin.pegasus2avro.monitor.AssertionMonitorSettings': AssertionMonitorSettingsClass,
    'com.linkedin.pegasus2avro.monitor.AuditLogSpec': AuditLogSpecClass,
    'com.linkedin.pegasus2avro.monitor.DataHubOperationSpec': DataHubOperationSpecClass,
    'com.linkedin.pegasus2avro.monitor.DatasetFieldAssertionParameters': DatasetFieldAssertionParametersClass,
    'com.linkedin.pegasus2avro.monitor.DatasetFieldAssertionSourceType': DatasetFieldAssertionSourceTypeClass,
    'com.linkedin.pegasus2avro.monitor.DatasetFreshnessAssertionParameters': DatasetFreshnessAssertionParametersClass,
    'com.linkedin.pegasus2avro.monitor.DatasetFreshnessSourceType': DatasetFreshnessSourceTypeClass,
    'com.linkedin.pegasus2avro.monitor.DatasetSchemaAssertionParameters': DatasetSchemaAssertionParametersClass,
    'com.linkedin.pegasus2avro.monitor.DatasetSchemaSourceType': DatasetSchemaSourceTypeClass,
    'com.linkedin.pegasus2avro.monitor.DatasetVolumeAssertionParameters': DatasetVolumeAssertionParametersClass,
    'com.linkedin.pegasus2avro.monitor.DatasetVolumeSourceType': DatasetVolumeSourceTypeClass,
    'com.linkedin.pegasus2avro.monitor.EmbeddedAssertion': EmbeddedAssertionClass,
    'com.linkedin.pegasus2avro.monitor.MonitorError': MonitorErrorClass,
    'com.linkedin.pegasus2avro.monitor.MonitorErrorType': MonitorErrorTypeClass,
    'com.linkedin.pegasus2avro.monitor.MonitorInfo': MonitorInfoClass,
    'com.linkedin.pegasus2avro.monitor.MonitorMode': MonitorModeClass,
    'com.linkedin.pegasus2avro.monitor.MonitorState': MonitorStateClass,
    'com.linkedin.pegasus2avro.monitor.MonitorStatus': MonitorStatusClass,
    'com.linkedin.pegasus2avro.monitor.MonitorSuiteAssertionSettings': MonitorSuiteAssertionSettingsClass,
    'com.linkedin.pegasus2avro.monitor.MonitorSuiteAssignmentSpec': MonitorSuiteAssignmentSpecClass,
    'com.linkedin.pegasus2avro.monitor.MonitorSuiteInfo': MonitorSuiteInfoClass,
    'com.linkedin.pegasus2avro.monitor.MonitorSuiteNotificationSettings': MonitorSuiteNotificationSettingsClass,
    'com.linkedin.pegasus2avro.monitor.MonitorSuiteType': MonitorSuiteTypeClass,
    'com.linkedin.pegasus2avro.monitor.MonitorTimeseriesState': MonitorTimeseriesStateClass,
    'com.linkedin.pegasus2avro.monitor.MonitorType': MonitorTypeClass,
    'com.linkedin.pegasus2avro.mxe.GenericAspect': GenericAspectClass,
    'com.linkedin.pegasus2avro.mxe.GenericPayload': GenericPayloadClass,
    'com.linkedin.pegasus2avro.mxe.MetadataChangeEvent': MetadataChangeEventClass,
    'com.linkedin.pegasus2avro.mxe.MetadataChangeLog': MetadataChangeLogClass,
    'com.linkedin.pegasus2avro.mxe.MetadataChangeProposal': MetadataChangeProposalClass,
    'com.linkedin.pegasus2avro.mxe.PlatformEvent': PlatformEventClass,
    'com.linkedin.pegasus2avro.mxe.PlatformEventHeader': PlatformEventHeaderClass,
    'com.linkedin.pegasus2avro.mxe.SystemMetadata': SystemMetadataClass,
    'com.linkedin.pegasus2avro.notebook.ChartCell': ChartCellClass,
    'com.linkedin.pegasus2avro.notebook.EditableNotebookProperties': EditableNotebookPropertiesClass,
    'com.linkedin.pegasus2avro.notebook.NotebookCell': NotebookCellClass,
    'com.linkedin.pegasus2avro.notebook.NotebookCellType': NotebookCellTypeClass,
    'com.linkedin.pegasus2avro.notebook.NotebookContent': NotebookContentClass,
    'com.linkedin.pegasus2avro.notebook.NotebookInfo': NotebookInfoClass,
    'com.linkedin.pegasus2avro.notebook.QueryCell': QueryCellClass,
    'com.linkedin.pegasus2avro.notebook.TextCell': TextCellClass,
    'com.linkedin.pegasus2avro.notification.FormNotificationDetails': FormNotificationDetailsClass,
    'com.linkedin.pegasus2avro.notification.FormNotificationEntry': FormNotificationEntryClass,
    'com.linkedin.pegasus2avro.notification.FormNotifications': FormNotificationsClass,
    'com.linkedin.pegasus2avro.ownership.OwnershipTypeInfo': OwnershipTypeInfoClass,
    'com.linkedin.pegasus2avro.persona.DataHubPersonaInfo': DataHubPersonaInfoClass,
    'com.linkedin.pegasus2avro.platform.event.v1.EntityChangeEvent': EntityChangeEventClass,
    'com.linkedin.pegasus2avro.platform.event.v1.Parameters': ParametersClass,
    'com.linkedin.pegasus2avro.platform.event.v1.RelationshipChangeEvent': RelationshipChangeEventClass,
    'com.linkedin.pegasus2avro.platform.event.v1.RelationshipChangeOperation': RelationshipChangeOperationClass,
    'com.linkedin.pegasus2avro.platformresource.PlatformResourceInfo': PlatformResourceInfoClass,
    'com.linkedin.pegasus2avro.platformresource.PlatformResourceKey': PlatformResourceKeyClass,
    'com.linkedin.pegasus2avro.policy.DataHubActorFilter': DataHubActorFilterClass,
    'com.linkedin.pegasus2avro.policy.DataHubPolicyInfo': DataHubPolicyInfoClass,
    'com.linkedin.pegasus2avro.policy.DataHubResourceFilter': DataHubResourceFilterClass,
    'com.linkedin.pegasus2avro.policy.DataHubRoleInfo': DataHubRoleInfoClass,
    'com.linkedin.pegasus2avro.policy.PolicyMatchCondition': PolicyMatchConditionClass,
    'com.linkedin.pegasus2avro.policy.PolicyMatchCriterion': PolicyMatchCriterionClass,
    'com.linkedin.pegasus2avro.policy.PolicyMatchFilter': PolicyMatchFilterClass,
    'com.linkedin.pegasus2avro.post.PostContent': PostContentClass,
    'com.linkedin.pegasus2avro.post.PostContentType': PostContentTypeClass,
    'com.linkedin.pegasus2avro.post.PostInfo': PostInfoClass,
    'com.linkedin.pegasus2avro.post.PostType': PostTypeClass,
    'com.linkedin.pegasus2avro.query.QueryLanguage': QueryLanguageClass,
    'com.linkedin.pegasus2avro.query.QueryProperties': QueryPropertiesClass,
    'com.linkedin.pegasus2avro.query.QuerySource': QuerySourceClass,
    'com.linkedin.pegasus2avro.query.QueryStatement': QueryStatementClass,
    'com.linkedin.pegasus2avro.query.QuerySubject': QuerySubjectClass,
    'com.linkedin.pegasus2avro.query.QuerySubjects': QuerySubjectsClass,
    'com.linkedin.pegasus2avro.query.QueryUsageFeatures': QueryUsageFeaturesClass,
    'com.linkedin.pegasus2avro.query.QueryUsageStatistics': QueryUsageStatisticsClass,
    'com.linkedin.pegasus2avro.retention.DataHubRetentionConfig': DataHubRetentionConfigClass,
    'com.linkedin.pegasus2avro.retention.Retention': RetentionClass,
    'com.linkedin.pegasus2avro.retention.TimeBasedRetention': TimeBasedRetentionClass,
    'com.linkedin.pegasus2avro.retention.VersionBasedRetention': VersionBasedRetentionClass,
    'com.linkedin.pegasus2avro.role.Actors': ActorsClass,
    'com.linkedin.pegasus2avro.role.RoleGroup': RoleGroupClass,
    'com.linkedin.pegasus2avro.role.RoleProperties': RolePropertiesClass,
    'com.linkedin.pegasus2avro.role.RoleUser': RoleUserClass,
    'com.linkedin.pegasus2avro.schema.ArrayType': ArrayTypeClass,
    'com.linkedin.pegasus2avro.schema.BinaryJsonSchema': BinaryJsonSchemaClass,
    'com.linkedin.pegasus2avro.schema.BooleanType': BooleanTypeClass,
    'com.linkedin.pegasus2avro.schema.BytesType': BytesTypeClass,
    'com.linkedin.pegasus2avro.schema.DatasetFieldForeignKey': DatasetFieldForeignKeyClass,
    'com.linkedin.pegasus2avro.schema.DateType': DateTypeClass,
    'com.linkedin.pegasus2avro.schema.EditableSchemaFieldInfo': EditableSchemaFieldInfoClass,
    'com.linkedin.pegasus2avro.schema.EditableSchemaMetadata': EditableSchemaMetadataClass,
    'com.linkedin.pegasus2avro.schema.EnumType': EnumTypeClass,
    'com.linkedin.pegasus2avro.schema.EspressoSchema': EspressoSchemaClass,
    'com.linkedin.pegasus2avro.schema.FixedType': FixedTypeClass,
    'com.linkedin.pegasus2avro.schema.ForeignKeyConstraint': ForeignKeyConstraintClass,
    'com.linkedin.pegasus2avro.schema.ForeignKeySpec': ForeignKeySpecClass,
    'com.linkedin.pegasus2avro.schema.KafkaSchema': KafkaSchemaClass,
    'com.linkedin.pegasus2avro.schema.KeyValueSchema': KeyValueSchemaClass,
    'com.linkedin.pegasus2avro.schema.MapType': MapTypeClass,
    'com.linkedin.pegasus2avro.schema.MySqlDDL': MySqlDDLClass,
    'com.linkedin.pegasus2avro.schema.NullType': NullTypeClass,
    'com.linkedin.pegasus2avro.schema.NumberType': NumberTypeClass,
    'com.linkedin.pegasus2avro.schema.OracleDDL': OracleDDLClass,
    'com.linkedin.pegasus2avro.schema.OrcSchema': OrcSchemaClass,
    'com.linkedin.pegasus2avro.schema.OtherSchema': OtherSchemaClass,
    'com.linkedin.pegasus2avro.schema.PrestoDDL': PrestoDDLClass,
    'com.linkedin.pegasus2avro.schema.RecordType': RecordTypeClass,
    'com.linkedin.pegasus2avro.schema.SchemaField': SchemaFieldClass,
    'com.linkedin.pegasus2avro.schema.SchemaFieldDataType': SchemaFieldDataTypeClass,
    'com.linkedin.pegasus2avro.schema.SchemaFieldSpec': SchemaFieldSpecClass,
    'com.linkedin.pegasus2avro.schema.SchemaMetadata': SchemaMetadataClass,
    'com.linkedin.pegasus2avro.schema.SchemaProposal': SchemaProposalClass,
    'com.linkedin.pegasus2avro.schema.SchemaProposals': SchemaProposalsClass,
    'com.linkedin.pegasus2avro.schema.Schemaless': SchemalessClass,
    'com.linkedin.pegasus2avro.schema.StringType': StringTypeClass,
    'com.linkedin.pegasus2avro.schema.TimeType': TimeTypeClass,
    'com.linkedin.pegasus2avro.schema.UnionType': UnionTypeClass,
    'com.linkedin.pegasus2avro.schema.UrnForeignKey': UrnForeignKeyClass,
    'com.linkedin.pegasus2avro.schemafield.SchemaFieldAliases': SchemaFieldAliasesClass,
    'com.linkedin.pegasus2avro.schemafield.SchemaFieldInfo': SchemaFieldInfoClass,
    'com.linkedin.pegasus2avro.secret.DataHubSecretValue': DataHubSecretValueClass,
    'com.linkedin.pegasus2avro.settings.NotificationSetting': NotificationSettingClass,
    'com.linkedin.pegasus2avro.settings.NotificationSettingValue': NotificationSettingValueClass,
    'com.linkedin.pegasus2avro.settings.asset.AssetSettings': AssetSettingsClass,
    'com.linkedin.pegasus2avro.settings.asset.AssetSummarySettings': AssetSummarySettingsClass,
    'com.linkedin.pegasus2avro.settings.asset.AssetSummarySettingsTemplate': AssetSummarySettingsTemplateClass,
    'com.linkedin.pegasus2avro.settings.global.AiAssistantSettings': AiAssistantSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.AiInstruction': AiInstructionClass,
    'com.linkedin.pegasus2avro.settings.global.AiInstructionState': AiInstructionStateClass,
    'com.linkedin.pegasus2avro.settings.global.AiInstructionType': AiInstructionTypeClass,
    'com.linkedin.pegasus2avro.settings.global.ApplicationsSettings': ApplicationsSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.DocPropagationFeatureSettings': DocPropagationFeatureSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.DocumentationAiSettings': DocumentationAiSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.EmailIntegrationSettings': EmailIntegrationSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.GlobalHomePageSettings': GlobalHomePageSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.GlobalIncidentsSettings': GlobalIncidentsSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.GlobalIntegrationSettings': GlobalIntegrationSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.GlobalNotificationSettings': GlobalNotificationSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.GlobalSettingsInfo': GlobalSettingsInfoClass,
    'com.linkedin.pegasus2avro.settings.global.GlobalViewsSettings': GlobalViewsSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.GlobalVisualSettings': GlobalVisualSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.HelpLink': HelpLinkClass,
    'com.linkedin.pegasus2avro.settings.global.OAuthProvider': OAuthProviderClass,
    'com.linkedin.pegasus2avro.settings.global.OAuthSettings': OAuthSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.OidcSettings': OidcSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.SampleDataSettings': SampleDataSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.SampleDataStatus': SampleDataStatusClass,
    'com.linkedin.pegasus2avro.settings.global.SlackIntegrationSettings': SlackIntegrationSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.SsoSettings': SsoSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.TeamsChannel': TeamsChannelClass,
    'com.linkedin.pegasus2avro.settings.global.TeamsIntegrationSettings': TeamsIntegrationSettingsClass,
    'com.linkedin.pegasus2avro.settings.global.TeamsUser': TeamsUserClass,
    'com.linkedin.pegasus2avro.step.DataHubStepStateProperties': DataHubStepStatePropertiesClass,
    'com.linkedin.pegasus2avro.structured.PropertyCardinality': PropertyCardinalityClass,
    'com.linkedin.pegasus2avro.structured.PropertyValue': PropertyValueClass,
    'com.linkedin.pegasus2avro.structured.StructuredProperties': StructuredPropertiesClass,
    'com.linkedin.pegasus2avro.structured.StructuredPropertyDefinition': StructuredPropertyDefinitionClass,
    'com.linkedin.pegasus2avro.structured.StructuredPropertyFilterStatus': StructuredPropertyFilterStatusClass,
    'com.linkedin.pegasus2avro.structured.StructuredPropertyKey': StructuredPropertyKeyClass,
    'com.linkedin.pegasus2avro.structured.StructuredPropertySettings': StructuredPropertySettingsClass,
    'com.linkedin.pegasus2avro.structured.StructuredPropertyValueAssignment': StructuredPropertyValueAssignmentClass,
    'com.linkedin.pegasus2avro.subscription.EntityChangeDetails': EntityChangeDetailsClass,
    'com.linkedin.pegasus2avro.subscription.EntityChangeDetailsFilter': EntityChangeDetailsFilterClass,
    'com.linkedin.pegasus2avro.subscription.EntityChangeType': EntityChangeTypeClass,
    'com.linkedin.pegasus2avro.subscription.SubscriptionInfo': SubscriptionInfoClass,
    'com.linkedin.pegasus2avro.subscription.SubscriptionNotificationConfig': SubscriptionNotificationConfigClass,
    'com.linkedin.pegasus2avro.subscription.SubscriptionType': SubscriptionTypeClass,
    'com.linkedin.pegasus2avro.tag.TagProperties': TagPropertiesClass,
    'com.linkedin.pegasus2avro.telemetry.TelemetryClientId': TelemetryClientIdClass,
    'com.linkedin.pegasus2avro.template.DataHubPageTemplateAssetSummary': DataHubPageTemplateAssetSummaryClass,
    'com.linkedin.pegasus2avro.template.DataHubPageTemplateProperties': DataHubPageTemplatePropertiesClass,
    'com.linkedin.pegasus2avro.template.DataHubPageTemplateRow': DataHubPageTemplateRowClass,
    'com.linkedin.pegasus2avro.template.DataHubPageTemplateSurface': DataHubPageTemplateSurfaceClass,
    'com.linkedin.pegasus2avro.template.DataHubPageTemplateVisibility': DataHubPageTemplateVisibilityClass,
    'com.linkedin.pegasus2avro.template.PageTemplateScope': PageTemplateScopeClass,
    'com.linkedin.pegasus2avro.template.PageTemplateSurfaceType': PageTemplateSurfaceTypeClass,
    'com.linkedin.pegasus2avro.template.SummaryElement': SummaryElementClass,
    'com.linkedin.pegasus2avro.template.SummaryElementType': SummaryElementTypeClass,
    'com.linkedin.pegasus2avro.test.BatchTestRunEvent': BatchTestRunEventClass,
    'com.linkedin.pegasus2avro.test.BatchTestRunResult': BatchTestRunResultClass,
    'com.linkedin.pegasus2avro.test.BatchTestRunStatus': BatchTestRunStatusClass,
    'com.linkedin.pegasus2avro.test.TestActionsError': TestActionsErrorClass,
    'com.linkedin.pegasus2avro.test.TestActionsReport': TestActionsReportClass,
    'com.linkedin.pegasus2avro.test.TestDefinition': TestDefinitionClass,
    'com.linkedin.pegasus2avro.test.TestDefinitionType': TestDefinitionTypeClass,
    'com.linkedin.pegasus2avro.test.TestInfo': TestInfoClass,
    'com.linkedin.pegasus2avro.test.TestInterval': TestIntervalClass,
    'com.linkedin.pegasus2avro.test.TestMode': TestModeClass,
    'com.linkedin.pegasus2avro.test.TestReport': TestReportClass,
    'com.linkedin.pegasus2avro.test.TestResult': TestResultClass,
    'com.linkedin.pegasus2avro.test.TestResultType': TestResultTypeClass,
    'com.linkedin.pegasus2avro.test.TestResults': TestResultsClass,
    'com.linkedin.pegasus2avro.test.TestSchedule': TestScheduleClass,
    'com.linkedin.pegasus2avro.test.TestSource': TestSourceClass,
    'com.linkedin.pegasus2avro.test.TestSourceType': TestSourceTypeClass,
    'com.linkedin.pegasus2avro.test.TestStatus': TestStatusClass,
    'com.linkedin.pegasus2avro.timeseries.AbsoluteTimeWindow': AbsoluteTimeWindowClass,
    'com.linkedin.pegasus2avro.timeseries.CalendarInterval': CalendarIntervalClass,
    'com.linkedin.pegasus2avro.timeseries.DayOfWeek': DayOfWeekClass,
    'com.linkedin.pegasus2avro.timeseries.HolidayWindow': HolidayWindowClass,
    'com.linkedin.pegasus2avro.timeseries.PartitionSpec': PartitionSpecClass,
    'com.linkedin.pegasus2avro.timeseries.PartitionType': PartitionTypeClass,
    'com.linkedin.pegasus2avro.timeseries.TimeWindow': TimeWindowClass,
    'com.linkedin.pegasus2avro.timeseries.TimeWindowSize': TimeWindowSizeClass,
    'com.linkedin.pegasus2avro.timeseries.WeeklyWindow': WeeklyWindowClass,
    'com.linkedin.pegasus2avro.upgrade.DataHubUpgradeRequest': DataHubUpgradeRequestClass,
    'com.linkedin.pegasus2avro.upgrade.DataHubUpgradeResult': DataHubUpgradeResultClass,
    'com.linkedin.pegasus2avro.upgrade.DataHubUpgradeState': DataHubUpgradeStateClass,
    'com.linkedin.pegasus2avro.usage.FieldUsageCounts': FieldUsageCountsClass,
    'com.linkedin.pegasus2avro.usage.UsageAggregation': UsageAggregationClass,
    'com.linkedin.pegasus2avro.usage.UsageAggregationMetrics': UsageAggregationMetricsClass,
    'com.linkedin.pegasus2avro.usage.UserUsageCounts': UserUsageCountsClass,
    'com.linkedin.pegasus2avro.versionset.VersionSetProperties': VersionSetPropertiesClass,
    'com.linkedin.pegasus2avro.versionset.VersioningScheme': VersioningSchemeClass,
    'com.linkedin.pegasus2avro.view.DataHubViewDefinition': DataHubViewDefinitionClass,
    'com.linkedin.pegasus2avro.view.DataHubViewInfo': DataHubViewInfoClass,
    'com.linkedin.pegasus2avro.view.DataHubViewType': DataHubViewTypeClass,
    'KafkaAuditHeader': KafkaAuditHeaderClass,
    'DataHubAccessTokenInfo': DataHubAccessTokenInfoClass,
    'DataHubActionConfig': DataHubActionConfigClass,
    'DataHubActionInfo': DataHubActionInfoClass,
    'DataHubActionRequestSource': DataHubActionRequestSourceClass,
    'DataHubActionSource': DataHubActionSourceClass,
    'DataHubActionStageStatus': DataHubActionStageStatusClass,
    'DataHubActionStageStatusCode': DataHubActionStageStatusCodeClass,
    'DataHubActionState': DataHubActionStateClass,
    'DataHubActionStatus': DataHubActionStatusClass,
    'ActionRequestArchived': ActionRequestArchivedClass,
    'ActionRequestInfo': ActionRequestInfoClass,
    'ActionRequestOrigin': ActionRequestOriginClass,
    'ActionRequestParams': ActionRequestParamsClass,
    'ActionRequestStatus': ActionRequestStatusClass,
    'CreateGlossaryNodeProposal': CreateGlossaryNodeProposalClass,
    'CreateGlossaryTermProposal': CreateGlossaryTermProposalClass,
    'DataContractProposal': DataContractProposalClass,
    'DataContractProposalOperationType': DataContractProposalOperationTypeClass,
    'DescriptionProposal': DescriptionProposalClass,
    'DomainProposal': DomainProposalClass,
    'GlossaryTermProposal': GlossaryTermProposalClass,
    'OwnerProposal': OwnerProposalClass,
    'StructuredPropertyProposal': StructuredPropertyProposalClass,
    'TagProposal': TagProposalClass,
    'ActionWorkflowCategory': ActionWorkflowCategoryClass,
    'ActionWorkflowEntrypoint': ActionWorkflowEntrypointClass,
    'ActionWorkflowEntrypointType': ActionWorkflowEntrypointTypeClass,
    'ActionWorkflowField': ActionWorkflowFieldClass,
    'ActionWorkflowFieldCondition': ActionWorkflowFieldConditionClass,
    'ActionWorkflowFieldConditionType': ActionWorkflowFieldConditionTypeClass,
    'ActionWorkflowForm': ActionWorkflowFormClass,
    'ActionWorkflowFormRequest': ActionWorkflowFormRequestClass,
    'ActionWorkflowFormRequestField': ActionWorkflowFormRequestFieldClass,
    'ActionWorkflowInfo': ActionWorkflowInfoClass,
    'ActionWorkflowRequestAccess': ActionWorkflowRequestAccessClass,
    'ActionWorkflowRequestStepState': ActionWorkflowRequestStepStateClass,
    'ActionWorkflowSingleFieldValueCondition': ActionWorkflowSingleFieldValueConditionClass,
    'ActionWorkflowStep': ActionWorkflowStepClass,
    'ActionWorkflowStepActors': ActionWorkflowStepActorsClass,
    'ActionWorkflowStepDynamicAssignment': ActionWorkflowStepDynamicAssignmentClass,
    'ActionWorkflowStepDynamicAssignmentType': ActionWorkflowStepDynamicAssignmentTypeClass,
    'ActionWorkflowStepType': ActionWorkflowStepTypeClass,
    'ActionWorkflowTrigger': ActionWorkflowTriggerClass,
    'ActionWorkflowTriggerType': ActionWorkflowTriggerTypeClass,
    'AiInferenceMetadata': AiInferenceMetadataClass,
    'EntityInferenceMetadata': EntityInferenceMetadataClass,
    'GlossaryTermsInferenceMetadata': GlossaryTermsInferenceMetadataClass,
    'InferenceGroupMetadata': InferenceGroupMetadataClass,
    'InferenceMetadata': InferenceMetadataClass,
    'AnomalyReviewState': AnomalyReviewStateClass,
    'AnomalySource': AnomalySourceClass,
    'AnomalySourceProperties': AnomalySourcePropertiesClass,
    'AnomalySourceType': AnomalySourceTypeClass,
    'MonitorAnomalyEvent': MonitorAnomalyEventClass,
    'OperationRange': OperationRangeClass,
    'ApplicationKey': ApplicationKeyClass,
    'ApplicationProperties': ApplicationPropertiesClass,
    'Applications': ApplicationsClass,
    'AdjustmentAlgorithm': AdjustmentAlgorithmClass,
    'AssertionAction': AssertionActionClass,
    'AssertionActionType': AssertionActionTypeClass,
    'AssertionActions': AssertionActionsClass,
    'AssertionAdjustmentSettings': AssertionAdjustmentSettingsClass,
    'AssertionAnalyticsRunEvent': AssertionAnalyticsRunEventClass,
    'AssertionDryRunEvent': AssertionDryRunEventClass,
    'AssertionDryRunResult': AssertionDryRunResultClass,
    'AssertionExclusionWindow': AssertionExclusionWindowClass,
    'AssertionExclusionWindowType': AssertionExclusionWindowTypeClass,
    'AssertionInferenceDetails': AssertionInferenceDetailsClass,
    'AssertionInfo': AssertionInfoClass,
    'AssertionMetric': AssertionMetricClass,
    'AssertionMonitorSensitivity': AssertionMonitorSensitivityClass,
    'AssertionNote': AssertionNoteClass,
    'AssertionResult': AssertionResultClass,
    'AssertionResultError': AssertionResultErrorClass,
    'AssertionResultErrorType': AssertionResultErrorTypeClass,
    'AssertionResultType': AssertionResultTypeClass,
    'AssertionRunEvent': AssertionRunEventClass,
    'AssertionRunStatus': AssertionRunStatusClass,
    'AssertionRunSummary': AssertionRunSummaryClass,
    'AssertionSource': AssertionSourceClass,
    'AssertionSourceType': AssertionSourceTypeClass,
    'AssertionStdAggregation': AssertionStdAggregationClass,
    'AssertionStdOperator': AssertionStdOperatorClass,
    'AssertionStdParameter': AssertionStdParameterClass,
    'AssertionStdParameterType': AssertionStdParameterTypeClass,
    'AssertionStdParameters': AssertionStdParametersClass,
    'AssertionType': AssertionTypeClass,
    'AssertionValueChangeType': AssertionValueChangeTypeClass,
    'BatchSpec': BatchSpecClass,
    'CustomAssertionInfo': CustomAssertionInfoClass,
    'DatasetAssertionInfo': DatasetAssertionInfoClass,
    'DatasetAssertionScope': DatasetAssertionScopeClass,
    'FieldAssertionInfo': FieldAssertionInfoClass,
    'FieldAssertionType': FieldAssertionTypeClass,
    'FieldMetricAssertion': FieldMetricAssertionClass,
    'FieldMetricType': FieldMetricTypeClass,
    'FieldTransform': FieldTransformClass,
    'FieldTransformType': FieldTransformTypeClass,
    'FieldValuesAssertion': FieldValuesAssertionClass,
    'FieldValuesFailThreshold': FieldValuesFailThresholdClass,
    'FieldValuesFailThresholdType': FieldValuesFailThresholdTypeClass,
    'FixedIntervalSchedule': FixedIntervalScheduleClass,
    'FreshnessAssertionInfo': FreshnessAssertionInfoClass,
    'FreshnessAssertionSchedule': FreshnessAssertionScheduleClass,
    'FreshnessAssertionScheduleType': FreshnessAssertionScheduleTypeClass,
    'FreshnessAssertionType': FreshnessAssertionTypeClass,
    'FreshnessCronSchedule': FreshnessCronScheduleClass,
    'FreshnessFieldKind': FreshnessFieldKindClass,
    'FreshnessFieldSpec': FreshnessFieldSpecClass,
    'IncrementingSegmentFieldTransformer': IncrementingSegmentFieldTransformerClass,
    'IncrementingSegmentFieldTransformerType': IncrementingSegmentFieldTransformerTypeClass,
    'IncrementingSegmentRowCountChange': IncrementingSegmentRowCountChangeClass,
    'IncrementingSegmentRowCountTotal': IncrementingSegmentRowCountTotalClass,
    'IncrementingSegmentSpec': IncrementingSegmentSpecClass,
    'RowCountChange': RowCountChangeClass,
    'RowCountTotal': RowCountTotalClass,
    'SchemaAssertionCompatibility': SchemaAssertionCompatibilityClass,
    'SchemaAssertionInfo': SchemaAssertionInfoClass,
    'SqlAssertionInfo': SqlAssertionInfoClass,
    'SqlAssertionType': SqlAssertionTypeClass,
    'VolumeAssertionInfo': VolumeAssertionInfoClass,
    'VolumeAssertionType': VolumeAssertionTypeClass,
    'BusinessAttributeAssociation': BusinessAttributeAssociationClass,
    'BusinessAttributeInfo': BusinessAttributeInfoClass,
    'BusinessAttributeKey': BusinessAttributeKeyClass,
    'BusinessAttributes': BusinessAttributesClass,
    'ChartInfo': ChartInfoClass,
    'ChartQuery': ChartQueryClass,
    'ChartQueryType': ChartQueryTypeClass,
    'ChartType': ChartTypeClass,
    'ChartUsageStatistics': ChartUsageStatisticsClass,
    'ChartUserUsageCounts': ChartUserUsageCountsClass,
    'EditableChartProperties': EditableChartPropertiesClass,
    'Access': AccessClass,
    'AccessLevel': AccessLevelClass,
    'AnomaliesSummary': AnomaliesSummaryClass,
    'AnomalySummaryDetails': AnomalySummaryDetailsClass,
    'AssertionSummaryDetails': AssertionSummaryDetailsClass,
    'AssertionsSummary': AssertionsSummaryClass,
    'AuditStamp': AuditStampClass,
    'BrowsePathEntry': BrowsePathEntryClass,
    'BrowsePaths': BrowsePathsClass,
    'BrowsePathsV2': BrowsePathsV2Class,
    'ChangeAuditStamps': ChangeAuditStampsClass,
    'Cost': CostClass,
    'CostCost': CostCostClass,
    'CostCostDiscriminator': CostCostDiscriminatorClass,
    'CostType': CostTypeClass,
    'CronSchedule': CronScheduleClass,
    'DataPlatformInstance': DataPlatformInstanceClass,
    'DataTransform': DataTransformClass,
    'DataTransformLogic': DataTransformLogicClass,
    'Deprecation': DeprecationClass,
    'DisplayProperties': DisplayPropertiesClass,
    'Documentation': DocumentationClass,
    'DocumentationAssociation': DocumentationAssociationClass,
    'DocumentationPromptResponse': DocumentationPromptResponseClass,
    'DomainPromptResponse': DomainPromptResponseClass,
    'Edge': EdgeClass,
    'Embed': EmbedClass,
    'EmbeddingChunk': EmbeddingChunkClass,
    'EmbeddingModelData': EmbeddingModelDataClass,
    'FabricType': FabricTypeClass,
    'FieldFormPromptAssociation': FieldFormPromptAssociationClass,
    'FormAssociation': FormAssociationClass,
    'FormPromptAssociation': FormPromptAssociationClass,
    'FormPromptFieldAssociations': FormPromptFieldAssociationsClass,
    'FormPromptResponse': FormPromptResponseClass,
    'FormVerificationAssociation': FormVerificationAssociationClass,
    'Forms': FormsClass,
    'GlobalTags': GlobalTagsClass,
    'GlossaryTermAssociation': GlossaryTermAssociationClass,
    'GlossaryTerms': GlossaryTermsClass,
    'GlossaryTermsPromptResponse': GlossaryTermsPromptResponseClass,
    'IconLibrary': IconLibraryClass,
    'IconProperties': IconPropertiesClass,
    'IncidentSummaryDetails': IncidentSummaryDetailsClass,
    'IncidentsSummary': IncidentsSummaryClass,
    'InputField': InputFieldClass,
    'InputFields': InputFieldsClass,
    'InstitutionalMemory': InstitutionalMemoryClass,
    'InstitutionalMemoryMetadata': InstitutionalMemoryMetadataClass,
    'InstitutionalMemoryMetadataSettings': InstitutionalMemoryMetadataSettingsClass,
    'MLFeatureDataType': MLFeatureDataTypeClass,
    'Media': MediaClass,
    'MediaType': MediaTypeClass,
    'MetadataAttribution': MetadataAttributionClass,
    'MetadataProducerType': MetadataProducerTypeClass,
    'Operation': OperationClass,
    'OperationSourceDetails': OperationSourceDetailsClass,
    'OperationSourceOriginType': OperationSourceOriginTypeClass,
    'OperationSourceType': OperationSourceTypeClass,
    'OperationType': OperationTypeClass,
    'Origin': OriginClass,
    'OriginType': OriginTypeClass,
    'Owner': OwnerClass,
    'Ownership': OwnershipClass,
    'OwnershipPromptResponse': OwnershipPromptResponseClass,
    'OwnershipSource': OwnershipSourceClass,
    'OwnershipSourceType': OwnershipSourceTypeClass,
    'OwnershipType': OwnershipTypeClass,
    'Proposals': ProposalsClass,
    'RoleAssociation': RoleAssociationClass,
    'SemanticContent': SemanticContentClass,
    'SerializedValue': SerializedValueClass,
    'SerializedValueContentType': SerializedValueContentTypeClass,
    'SerializedValueSchemaType': SerializedValueSchemaTypeClass,
    'Share': ShareClass,
    'ShareConfig': ShareConfigClass,
    'ShareResult': ShareResultClass,
    'ShareResultState': ShareResultStateClass,
    'Siblings': SiblingsClass,
    'SourceDetails': SourceDetailsClass,
    'Status': StatusClass,
    'StructuredPropertyPromptResponse': StructuredPropertyPromptResponseClass,
    'SubTypes': SubTypesClass,
    'SyncMechanism': SyncMechanismClass,
    'TagAssociation': TagAssociationClass,
    'TimeStamp': TimeStampClass,
    'VersionProperties': VersionPropertiesClass,
    'VersionTag': VersionTagClass,
    'WindowDuration': WindowDurationClass,
    'TransformationType': TransformationTypeClass,
    'UDFTransformer': UDFTransformerClass,
    'DataHubConnectionDetails': DataHubConnectionDetailsClass,
    'DataHubConnectionDetailsType': DataHubConnectionDetailsTypeClass,
    'DataHubJsonConnection': DataHubJsonConnectionClass,
    'ConstraintInfo': ConstraintInfoClass,
    'ConstraintParams': ConstraintParamsClass,
    'GlossaryTermInNodeConstraint': GlossaryTermInNodeConstraintClass,
    'Container': ContainerClass,
    'ContainerProperties': ContainerPropertiesClass,
    'EditableContainerProperties': EditableContainerPropertiesClass,
    'DataHubAiConversationActor': DataHubAiConversationActorClass,
    'DataHubAiConversationActorType': DataHubAiConversationActorTypeClass,
    'DataHubAiConversationContext': DataHubAiConversationContextClass,
    'DataHubAiConversationInfo': DataHubAiConversationInfoClass,
    'DataHubAiConversationMessage': DataHubAiConversationMessageClass,
    'DataHubAiConversationMessageContent': DataHubAiConversationMessageContentClass,
    'DataHubAiConversationMessageType': DataHubAiConversationMessageTypeClass,
    'DataHubAiConversationOriginType': DataHubAiConversationOriginTypeClass,
    'DashboardInfo': DashboardInfoClass,
    'DashboardUsageStatistics': DashboardUsageStatisticsClass,
    'DashboardUserUsageCounts': DashboardUserUsageCountsClass,
    'EditableDashboardProperties': EditableDashboardPropertiesClass,
    'DataContractProperties': DataContractPropertiesClass,
    'DataContractState': DataContractStateClass,
    'DataContractStatus': DataContractStatusClass,
    'DataQualityContract': DataQualityContractClass,
    'FreshnessContract': FreshnessContractClass,
    'SchemaContract': SchemaContractClass,
    'SlaContract': SlaContractClass,
    'DataHubSearchConfig': DataHubSearchConfigClass,
    'SearchFieldType': SearchFieldTypeClass,
    'DataFlowInfo': DataFlowInfoClass,
    'DataJobInfo': DataJobInfoClass,
    'DataJobInputOutput': DataJobInputOutputClass,
    'EditableDataFlowProperties': EditableDataFlowPropertiesClass,
    'EditableDataJobProperties': EditableDataJobPropertiesClass,
    'JobStatus': JobStatusClass,
    'VersionInfo': VersionInfoClass,
    'AzkabanJobType': AzkabanJobTypeClass,
    'DatahubIngestionCheckpoint': DatahubIngestionCheckpointClass,
    'DatahubIngestionRunSummary': DatahubIngestionRunSummaryClass,
    'IngestionCheckpointState': IngestionCheckpointStateClass,
    'DataPlatformInfo': DataPlatformInfoClass,
    'PlatformType': PlatformTypeClass,
    'SlackUserInfo': SlackUserInfoClass,
    'DataPlatformInstanceProperties': DataPlatformInstancePropertiesClass,
    'IcebergWarehouseInfo': IcebergWarehouseInfoClass,
    'DataProcessInfo': DataProcessInfoClass,
    'DataProcessInstanceInput': DataProcessInstanceInputClass,
    'DataProcessInstanceOutput': DataProcessInstanceOutputClass,
    'DataProcessInstanceProperties': DataProcessInstancePropertiesClass,
    'DataProcessInstanceRelationships': DataProcessInstanceRelationshipsClass,
    'DataProcessInstanceRunEvent': DataProcessInstanceRunEventClass,
    'DataProcessInstanceRunResult': DataProcessInstanceRunResultClass,
    'DataProcessRunStatus': DataProcessRunStatusClass,
    'DataProcessType': DataProcessTypeClass,
    'RunResultType': RunResultTypeClass,
    'DataProductAssociation': DataProductAssociationClass,
    'DataProductKey': DataProductKeyClass,
    'DataProductProperties': DataProductPropertiesClass,
    'DatasetDeprecation': DatasetDeprecationClass,
    'DatasetFieldMapping': DatasetFieldMappingClass,
    'DatasetFieldProfile': DatasetFieldProfileClass,
    'DatasetFieldUsageCounts': DatasetFieldUsageCountsClass,
    'DatasetFilter': DatasetFilterClass,
    'DatasetFilterType': DatasetFilterTypeClass,
    'DatasetLineageType': DatasetLineageTypeClass,
    'DatasetMetricsOriginType': DatasetMetricsOriginTypeClass,
    'DatasetMetricsSourceDetails': DatasetMetricsSourceDetailsClass,
    'DatasetProfile': DatasetProfileClass,
    'DatasetProperties': DatasetPropertiesClass,
    'DatasetUpstreamLineage': DatasetUpstreamLineageClass,
    'DatasetUsageStatistics': DatasetUsageStatisticsClass,
    'DatasetUserUsageCounts': DatasetUserUsageCountsClass,
    'EditableDatasetProperties': EditableDatasetPropertiesClass,
    'FineGrainedLineage': FineGrainedLineageClass,
    'FineGrainedLineageDownstreamType': FineGrainedLineageDownstreamTypeClass,
    'FineGrainedLineageUpstreamType': FineGrainedLineageUpstreamTypeClass,
    'Histogram': HistogramClass,
    'IcebergCatalogInfo': IcebergCatalogInfoClass,
    'PartitionSummary': PartitionSummaryClass,
    'PartitionsSummary': PartitionsSummaryClass,
    'Quantile': QuantileClass,
    'SchemaFieldProfile': SchemaFieldProfileClass,
    'Upstream': UpstreamClass,
    'UpstreamLineage': UpstreamLineageClass,
    'ValueFrequency': ValueFrequencyClass,
    'ViewProperties': ViewPropertiesClass,
    'DataTypeInfo': DataTypeInfoClass,
    'DataTypeKey': DataTypeKeyClass,
    'DomainProperties': DomainPropertiesClass,
    'Domains': DomainsClass,
    'EntityTypeInfo': EntityTypeInfoClass,
    'EntityTypeKey': EntityTypeKeyClass,
    'ERModelRelationshipCardinality': ERModelRelationshipCardinalityClass,
    'ERModelRelationshipProperties': ERModelRelationshipPropertiesClass,
    'EditableERModelRelationshipProperties': EditableERModelRelationshipPropertiesClass,
    'RelationshipFieldMapping': RelationshipFieldMappingClass,
    'NotificationContext': NotificationContextClass,
    'NotificationMessage': NotificationMessageClass,
    'NotificationRecipient': NotificationRecipientClass,
    'NotificationRecipientOriginType': NotificationRecipientOriginTypeClass,
    'NotificationRecipientType': NotificationRecipientTypeClass,
    'NotificationRequest': NotificationRequestClass,
    'NotificationSink': NotificationSinkClass,
    'NotificationSinkType': NotificationSinkTypeClass,
    'EmailNotificationSettings': EmailNotificationSettingsClass,
    'NotificationSettings': NotificationSettingsClass,
    'SlackNotificationSettings': SlackNotificationSettingsClass,
    'TeamsNotificationSettings': TeamsNotificationSettingsClass,
    'NotificationTemplateType': NotificationTemplateTypeClass,
    'OwnershipParameters': OwnershipParametersClass,
    'ChangeType': ChangeTypeClass,
    'ExecutionRequestArtifactsLocation': ExecutionRequestArtifactsLocationClass,
    'ExecutionRequestInput': ExecutionRequestInputClass,
    'ExecutionRequestResult': ExecutionRequestResultClass,
    'ExecutionRequestSignal': ExecutionRequestSignalClass,
    'ExecutionRequestSource': ExecutionRequestSourceClass,
    'StructuredExecutionReport': StructuredExecutionReportClass,
    'RemoteExecutorStatus': RemoteExecutorStatusClass,
    'RemoteExecutorPoolGlobalConfig': RemoteExecutorPoolGlobalConfigClass,
    'RemoteExecutorPoolInfo': RemoteExecutorPoolInfoClass,
    'RemoteExecutorPoolState': RemoteExecutorPoolStateClass,
    'RemoteExecutorPoolStatus': RemoteExecutorPoolStatusClass,
    'BucketStorageLocation': BucketStorageLocationClass,
    'DataHubFileInfo': DataHubFileInfoClass,
    'FileUploadScenario': FileUploadScenarioClass,
    'AssignmentStatus': AssignmentStatusClass,
    'DomainParams': DomainParamsClass,
    'DynamicFormAssignment': DynamicFormAssignmentClass,
    'FormActorAssignment': FormActorAssignmentClass,
    'FormAssignmentStatus': FormAssignmentStatusClass,
    'FormInfo': FormInfoClass,
    'FormNotificationSettings': FormNotificationSettingsClass,
    'FormPrompt': FormPromptClass,
    'FormPromptType': FormPromptTypeClass,
    'FormSettings': FormSettingsClass,
    'FormState': FormStateClass,
    'FormStatus': FormStatusClass,
    'FormType': FormTypeClass,
    'GlossaryTermsParams': GlossaryTermsParamsClass,
    'OwnershipParams': OwnershipParamsClass,
    'PromptCardinality': PromptCardinalityClass,
    'StructuredPropertyParams': StructuredPropertyParamsClass,
    'GlossaryNodeInfo': GlossaryNodeInfoClass,
    'GlossaryRelatedTerms': GlossaryRelatedTermsClass,
    'GlossaryTermInfo': GlossaryTermInfoClass,
    'CorpGroupEditableInfo': CorpGroupEditableInfoClass,
    'CorpGroupInfo': CorpGroupInfoClass,
    'CorpGroupSettings': CorpGroupSettingsClass,
    'CorpUserAppearanceSettings': CorpUserAppearanceSettingsClass,
    'CorpUserCredentials': CorpUserCredentialsClass,
    'CorpUserEditableInfo': CorpUserEditableInfoClass,
    'CorpUserHomePageSettings': CorpUserHomePageSettingsClass,
    'CorpUserInfo': CorpUserInfoClass,
    'CorpUserInvitationStatus': CorpUserInvitationStatusClass,
    'CorpUserSettings': CorpUserSettingsClass,
    'CorpUserStatus': CorpUserStatusClass,
    'CorpUserViewsSettings': CorpUserViewsSettingsClass,
    'GroupMembership': GroupMembershipClass,
    'InvitationStatus': InvitationStatusClass,
    'InviteToken': InviteTokenClass,
    'NativeGroupMembership': NativeGroupMembershipClass,
    'RoleMembership': RoleMembershipClass,
    'TokenType': TokenTypeClass,
    'IncidentActivityChange': IncidentActivityChangeClass,
    'IncidentActivityChangeType': IncidentActivityChangeTypeClass,
    'IncidentActivityEvent': IncidentActivityEventClass,
    'IncidentAssignee': IncidentAssigneeClass,
    'IncidentInfo': IncidentInfoClass,
    'IncidentNotificationDetails': IncidentNotificationDetailsClass,
    'IncidentSource': IncidentSourceClass,
    'IncidentSourceType': IncidentSourceTypeClass,
    'IncidentStage': IncidentStageClass,
    'IncidentState': IncidentStateClass,
    'IncidentStatus': IncidentStatusClass,
    'IncidentType': IncidentTypeClass,
    'SlackIncidentDetails': SlackIncidentDetailsClass,
    'SlackMessageDetails': SlackMessageDetailsClass,
    'InferredDescription': InferredDescriptionClass,
    'InferredGlossaryTerms': InferredGlossaryTermsClass,
    'InferredMetadata': InferredMetadataClass,
    'InferredMetadataSource': InferredMetadataSourceClass,
    'InferredNeighbor': InferredNeighborClass,
    'InferredNeighbors': InferredNeighborsClass,
    'InferredOwners': InferredOwnersClass,
    'InferredTags': InferredTagsClass,
    'SchemaFieldInferredMetadata': SchemaFieldInferredMetadataClass,
    'SchemaFieldInferredNeighbors': SchemaFieldInferredNeighborsClass,
    'SchemaFieldsInferredMetadata': SchemaFieldsInferredMetadataClass,
    'SchemaFieldsInferredNeighbors': SchemaFieldsInferredNeighborsClass,
    'SimilarityFactor': SimilarityFactorClass,
    'DataHubIngestionSourceConfig': DataHubIngestionSourceConfigClass,
    'DataHubIngestionSourceInfo': DataHubIngestionSourceInfoClass,
    'DataHubIngestionSourceSchedule': DataHubIngestionSourceScheduleClass,
    'DataHubIngestionSourceSource': DataHubIngestionSourceSourceClass,
    'DataHubIngestionSourceSourceType': DataHubIngestionSourceSourceTypeClass,
    'DocumentContents': DocumentContentsClass,
    'DocumentInfo': DocumentInfoClass,
    'DocumentSettings': DocumentSettingsClass,
    'DocumentSource': DocumentSourceClass,
    'DocumentSourceType': DocumentSourceTypeClass,
    'DocumentState': DocumentStateClass,
    'DocumentStatus': DocumentStatusClass,
    'ParentDocument': ParentDocumentClass,
    'RelatedAsset': RelatedAssetClass,
    'RelatedDocument': RelatedDocumentClass,
    'LinkPreviewInfo': LinkPreviewInfoClass,
    'LinkPreviewType': LinkPreviewTypeClass,
    'LogicalParent': LogicalParentClass,
    'ActionRequestKey': ActionRequestKeyClass,
    'ActionWorkflowKey': ActionWorkflowKeyClass,
    'AnomalyKey': AnomalyKeyClass,
    'AssertionKey': AssertionKeyClass,
    'ChartKey': ChartKeyClass,
    'ConstraintKey': ConstraintKeyClass,
    'ContainerKey': ContainerKeyClass,
    'CorpGroupKey': CorpGroupKeyClass,
    'CorpUserKey': CorpUserKeyClass,
    'DashboardKey': DashboardKeyClass,
    'DataContractKey': DataContractKeyClass,
    'DataFlowKey': DataFlowKeyClass,
    'DataHubAccessTokenKey': DataHubAccessTokenKeyClass,
    'DataHubActionKey': DataHubActionKeyClass,
    'DataHubAiConversationKey': DataHubAiConversationKeyClass,
    'DataHubConnectionKey': DataHubConnectionKeyClass,
    'DataHubFileKey': DataHubFileKeyClass,
    'DataHubIngestionSourceKey': DataHubIngestionSourceKeyClass,
    'DataHubMetricCubeKey': DataHubMetricCubeKeyClass,
    'DataHubOpenAPISchemaKey': DataHubOpenAPISchemaKeyClass,
    'DataHubPageModuleKey': DataHubPageModuleKeyClass,
    'DataHubPageTemplateKey': DataHubPageTemplateKeyClass,
    'DataHubPersonaKey': DataHubPersonaKeyClass,
    'DataHubPolicyKey': DataHubPolicyKeyClass,
    'DataHubRetentionKey': DataHubRetentionKeyClass,
    'DataHubRoleKey': DataHubRoleKeyClass,
    'DataHubSecretKey': DataHubSecretKeyClass,
    'DataHubStepStateKey': DataHubStepStateKeyClass,
    'DataHubUpgradeKey': DataHubUpgradeKeyClass,
    'DataHubViewKey': DataHubViewKeyClass,
    'DataJobKey': DataJobKeyClass,
    'DataPlatformInstanceKey': DataPlatformInstanceKeyClass,
    'DataPlatformKey': DataPlatformKeyClass,
    'DataProcessInstanceKey': DataProcessInstanceKeyClass,
    'DataProcessKey': DataProcessKeyClass,
    'DatasetKey': DatasetKeyClass,
    'DocumentKey': DocumentKeyClass,
    'DomainKey': DomainKeyClass,
    'ERModelRelationshipKey': ERModelRelationshipKeyClass,
    'ExecutionRequestKey': ExecutionRequestKeyClass,
    'FormKey': FormKeyClass,
    'GenericEntityKey': GenericEntityKeyClass,
    'GlobalSettingsKey': GlobalSettingsKeyClass,
    'GlossaryNodeKey': GlossaryNodeKeyClass,
    'GlossaryTermKey': GlossaryTermKeyClass,
    'IncidentKey': IncidentKeyClass,
    'InviteTokenKey': InviteTokenKeyClass,
    'LinkPreviewKey': LinkPreviewKeyClass,
    'MLFeatureKey': MLFeatureKeyClass,
    'MLFeatureTableKey': MLFeatureTableKeyClass,
    'MLModelDeploymentKey': MLModelDeploymentKeyClass,
    'MLModelGroupKey': MLModelGroupKeyClass,
    'MLModelKey': MLModelKeyClass,
    'MLPrimaryKeyKey': MLPrimaryKeyKeyClass,
    'MonitorKey': MonitorKeyClass,
    'MonitorSuiteKey': MonitorSuiteKeyClass,
    'NotebookKey': NotebookKeyClass,
    'OwnershipTypeKey': OwnershipTypeKeyClass,
    'PostKey': PostKeyClass,
    'QueryKey': QueryKeyClass,
    'RecommendationModuleKey': RecommendationModuleKeyClass,
    'RemoteExecutorGlobalConfigKey': RemoteExecutorGlobalConfigKeyClass,
    'RemoteExecutorKey': RemoteExecutorKeyClass,
    'RemoteExecutorPoolKey': RemoteExecutorPoolKeyClass,
    'RoleKey': RoleKeyClass,
    'SchemaFieldKey': SchemaFieldKeyClass,
    'SubscriptionKey': SubscriptionKeyClass,
    'TagKey': TagKeyClass,
    'TelemetryKey': TelemetryKeyClass,
    'TestKey': TestKeyClass,
    'VersionSetKey': VersionSetKeyClass,
    'Condition': ConditionClass,
    'ConjunctiveCriterion': ConjunctiveCriterionClass,
    'Criterion': CriterionClass,
    'Filter': FilterClass,
    'ContentParams': ContentParamsClass,
    'EntityProfileParams': EntityProfileParamsClass,
    'RecommendationContent': RecommendationContentClass,
    'RecommendationModule': RecommendationModuleClass,
    'RecommendationParams': RecommendationParamsClass,
    'RecommendationRenderType': RecommendationRenderTypeClass,
    'SearchParams': SearchParamsClass,
    'CorpUserUsageFeatures': CorpUserUsageFeaturesClass,
    'CostCurrencyCode': CostCurrencyCodeClass,
    'CostFeatures': CostFeaturesClass,
    'LineageFeatures': LineageFeaturesClass,
    'StorageFeatures': StorageFeaturesClass,
    'UsageFeatures': UsageFeaturesClass,
    'ActionRequestSnapshot': ActionRequestSnapshotClass,
    'ChartSnapshot': ChartSnapshotClass,
    'CorpGroupSnapshot': CorpGroupSnapshotClass,
    'CorpUserSnapshot': CorpUserSnapshotClass,
    'DashboardSnapshot': DashboardSnapshotClass,
    'DataFlowSnapshot': DataFlowSnapshotClass,
    'DataHubPolicySnapshot': DataHubPolicySnapshotClass,
    'DataHubRetentionSnapshot': DataHubRetentionSnapshotClass,
    'DataJobSnapshot': DataJobSnapshotClass,
    'DataPlatformSnapshot': DataPlatformSnapshotClass,
    'DataProcessSnapshot': DataProcessSnapshotClass,
    'DatasetSnapshot': DatasetSnapshotClass,
    'GlossaryNodeSnapshot': GlossaryNodeSnapshotClass,
    'GlossaryTermSnapshot': GlossaryTermSnapshotClass,
    'MLFeatureSnapshot': MLFeatureSnapshotClass,
    'MLFeatureTableSnapshot': MLFeatureTableSnapshotClass,
    'MLModelDeploymentSnapshot': MLModelDeploymentSnapshotClass,
    'MLModelGroupSnapshot': MLModelGroupSnapshotClass,
    'MLModelSnapshot': MLModelSnapshotClass,
    'MLPrimaryKeySnapshot': MLPrimaryKeySnapshotClass,
    'SchemaFieldSnapshot': SchemaFieldSnapshotClass,
    'TagSnapshot': TagSnapshotClass,
    'DataHubMetricCubeDefinition': DataHubMetricCubeDefinitionClass,
    'DataHubMetricCubeDimension': DataHubMetricCubeDimensionClass,
    'DataHubMetricCubeDimensions': DataHubMetricCubeDimensionsClass,
    'DataHubMetricCubeEvent': DataHubMetricCubeEventClass,
    'DataHubMetricCubeMeasure': DataHubMetricCubeMeasureClass,
    'DataHubMetricCubeMeasures': DataHubMetricCubeMeasuresClass,
    'DataHubMetricCubeOrigin': DataHubMetricCubeOriginClass,
    'DataHubMetricSourceType': DataHubMetricSourceTypeClass,
    'BaseData': BaseDataClass,
    'CaveatDetails': CaveatDetailsClass,
    'CaveatsAndRecommendations': CaveatsAndRecommendationsClass,
    'DeploymentStatus': DeploymentStatusClass,
    'EditableMLFeatureProperties': EditableMLFeaturePropertiesClass,
    'EditableMLFeatureTableProperties': EditableMLFeatureTablePropertiesClass,
    'EditableMLModelGroupProperties': EditableMLModelGroupPropertiesClass,
    'EditableMLModelProperties': EditableMLModelPropertiesClass,
    'EditableMLPrimaryKeyProperties': EditableMLPrimaryKeyPropertiesClass,
    'EthicalConsiderations': EthicalConsiderationsClass,
    'EvaluationData': EvaluationDataClass,
    'IntendedUse': IntendedUseClass,
    'IntendedUserType': IntendedUserTypeClass,
    'MLFeatureProperties': MLFeaturePropertiesClass,
    'MLFeatureTableProperties': MLFeatureTablePropertiesClass,
    'MLHyperParam': MLHyperParamClass,
    'MLMetric': MLMetricClass,
    'MLModelDeploymentProperties': MLModelDeploymentPropertiesClass,
    'MLModelFactorPrompts': MLModelFactorPromptsClass,
    'MLModelFactors': MLModelFactorsClass,
    'MLModelGroupProperties': MLModelGroupPropertiesClass,
    'MLModelProperties': MLModelPropertiesClass,
    'MLPrimaryKeyProperties': MLPrimaryKeyPropertiesClass,
    'MLTrainingRunProperties': MLTrainingRunPropertiesClass,
    'Metrics': MetricsClass,
    'QuantitativeAnalyses': QuantitativeAnalysesClass,
    'SourceCode': SourceCodeClass,
    'SourceCodeUrl': SourceCodeUrlClass,
    'SourceCodeUrlType': SourceCodeUrlTypeClass,
    'TrainingData': TrainingDataClass,
    'AssetCollectionModuleParams': AssetCollectionModuleParamsClass,
    'DataHubPageModuleParams': DataHubPageModuleParamsClass,
    'DataHubPageModuleProperties': DataHubPageModulePropertiesClass,
    'DataHubPageModuleType': DataHubPageModuleTypeClass,
    'DataHubPageModuleVisibility': DataHubPageModuleVisibilityClass,
    'HierarchyModuleParams': HierarchyModuleParamsClass,
    'LinkModuleParams': LinkModuleParamsClass,
    'PageModuleScope': PageModuleScopeClass,
    'RichTextModuleParams': RichTextModuleParamsClass,
    'AssertionEvaluationContext': AssertionEvaluationContextClass,
    'AssertionEvaluationParameters': AssertionEvaluationParametersClass,
    'AssertionEvaluationParametersType': AssertionEvaluationParametersTypeClass,
    'AssertionEvaluationSpec': AssertionEvaluationSpecClass,
    'AssertionMonitor': AssertionMonitorClass,
    'AssertionMonitorBootstrapStatus': AssertionMonitorBootstrapStatusClass,
    'AssertionMonitorCapability': AssertionMonitorCapabilityClass,
    'AssertionMonitorMetricsCubeBootstrapState': AssertionMonitorMetricsCubeBootstrapStateClass,
    'AssertionMonitorMetricsCubeBootstrapStatus': AssertionMonitorMetricsCubeBootstrapStatusClass,
    'AssertionMonitorSettings': AssertionMonitorSettingsClass,
    'AuditLogSpec': AuditLogSpecClass,
    'DataHubOperationSpec': DataHubOperationSpecClass,
    'DatasetFieldAssertionParameters': DatasetFieldAssertionParametersClass,
    'DatasetFieldAssertionSourceType': DatasetFieldAssertionSourceTypeClass,
    'DatasetFreshnessAssertionParameters': DatasetFreshnessAssertionParametersClass,
    'DatasetFreshnessSourceType': DatasetFreshnessSourceTypeClass,
    'DatasetSchemaAssertionParameters': DatasetSchemaAssertionParametersClass,
    'DatasetSchemaSourceType': DatasetSchemaSourceTypeClass,
    'DatasetVolumeAssertionParameters': DatasetVolumeAssertionParametersClass,
    'DatasetVolumeSourceType': DatasetVolumeSourceTypeClass,
    'EmbeddedAssertion': EmbeddedAssertionClass,
    'MonitorError': MonitorErrorClass,
    'MonitorErrorType': MonitorErrorTypeClass,
    'MonitorInfo': MonitorInfoClass,
    'MonitorMode': MonitorModeClass,
    'MonitorState': MonitorStateClass,
    'MonitorStatus': MonitorStatusClass,
    'MonitorSuiteAssertionSettings': MonitorSuiteAssertionSettingsClass,
    'MonitorSuiteAssignmentSpec': MonitorSuiteAssignmentSpecClass,
    'MonitorSuiteInfo': MonitorSuiteInfoClass,
    'MonitorSuiteNotificationSettings': MonitorSuiteNotificationSettingsClass,
    'MonitorSuiteType': MonitorSuiteTypeClass,
    'MonitorTimeseriesState': MonitorTimeseriesStateClass,
    'MonitorType': MonitorTypeClass,
    'GenericAspect': GenericAspectClass,
    'GenericPayload': GenericPayloadClass,
    'MetadataChangeEvent': MetadataChangeEventClass,
    'MetadataChangeLog': MetadataChangeLogClass,
    'MetadataChangeProposal': MetadataChangeProposalClass,
    'PlatformEvent': PlatformEventClass,
    'PlatformEventHeader': PlatformEventHeaderClass,
    'SystemMetadata': SystemMetadataClass,
    'ChartCell': ChartCellClass,
    'EditableNotebookProperties': EditableNotebookPropertiesClass,
    'NotebookCell': NotebookCellClass,
    'NotebookCellType': NotebookCellTypeClass,
    'NotebookContent': NotebookContentClass,
    'NotebookInfo': NotebookInfoClass,
    'QueryCell': QueryCellClass,
    'TextCell': TextCellClass,
    'FormNotificationDetails': FormNotificationDetailsClass,
    'FormNotificationEntry': FormNotificationEntryClass,
    'FormNotifications': FormNotificationsClass,
    'OwnershipTypeInfo': OwnershipTypeInfoClass,
    'DataHubPersonaInfo': DataHubPersonaInfoClass,
    'EntityChangeEvent': EntityChangeEventClass,
    'Parameters': ParametersClass,
    'RelationshipChangeEvent': RelationshipChangeEventClass,
    'RelationshipChangeOperation': RelationshipChangeOperationClass,
    'PlatformResourceInfo': PlatformResourceInfoClass,
    'PlatformResourceKey': PlatformResourceKeyClass,
    'DataHubActorFilter': DataHubActorFilterClass,
    'DataHubPolicyInfo': DataHubPolicyInfoClass,
    'DataHubResourceFilter': DataHubResourceFilterClass,
    'DataHubRoleInfo': DataHubRoleInfoClass,
    'PolicyMatchCondition': PolicyMatchConditionClass,
    'PolicyMatchCriterion': PolicyMatchCriterionClass,
    'PolicyMatchFilter': PolicyMatchFilterClass,
    'PostContent': PostContentClass,
    'PostContentType': PostContentTypeClass,
    'PostInfo': PostInfoClass,
    'PostType': PostTypeClass,
    'QueryLanguage': QueryLanguageClass,
    'QueryProperties': QueryPropertiesClass,
    'QuerySource': QuerySourceClass,
    'QueryStatement': QueryStatementClass,
    'QuerySubject': QuerySubjectClass,
    'QuerySubjects': QuerySubjectsClass,
    'QueryUsageFeatures': QueryUsageFeaturesClass,
    'QueryUsageStatistics': QueryUsageStatisticsClass,
    'DataHubRetentionConfig': DataHubRetentionConfigClass,
    'Retention': RetentionClass,
    'TimeBasedRetention': TimeBasedRetentionClass,
    'VersionBasedRetention': VersionBasedRetentionClass,
    'Actors': ActorsClass,
    'RoleGroup': RoleGroupClass,
    'RoleProperties': RolePropertiesClass,
    'RoleUser': RoleUserClass,
    'ArrayType': ArrayTypeClass,
    'BinaryJsonSchema': BinaryJsonSchemaClass,
    'BooleanType': BooleanTypeClass,
    'BytesType': BytesTypeClass,
    'DatasetFieldForeignKey': DatasetFieldForeignKeyClass,
    'DateType': DateTypeClass,
    'EditableSchemaFieldInfo': EditableSchemaFieldInfoClass,
    'EditableSchemaMetadata': EditableSchemaMetadataClass,
    'EnumType': EnumTypeClass,
    'EspressoSchema': EspressoSchemaClass,
    'FixedType': FixedTypeClass,
    'ForeignKeyConstraint': ForeignKeyConstraintClass,
    'ForeignKeySpec': ForeignKeySpecClass,
    'KafkaSchema': KafkaSchemaClass,
    'KeyValueSchema': KeyValueSchemaClass,
    'MapType': MapTypeClass,
    'MySqlDDL': MySqlDDLClass,
    'NullType': NullTypeClass,
    'NumberType': NumberTypeClass,
    'OracleDDL': OracleDDLClass,
    'OrcSchema': OrcSchemaClass,
    'OtherSchema': OtherSchemaClass,
    'PrestoDDL': PrestoDDLClass,
    'RecordType': RecordTypeClass,
    'SchemaField': SchemaFieldClass,
    'SchemaFieldDataType': SchemaFieldDataTypeClass,
    'SchemaFieldSpec': SchemaFieldSpecClass,
    'SchemaMetadata': SchemaMetadataClass,
    'SchemaProposal': SchemaProposalClass,
    'SchemaProposals': SchemaProposalsClass,
    'Schemaless': SchemalessClass,
    'StringType': StringTypeClass,
    'TimeType': TimeTypeClass,
    'UnionType': UnionTypeClass,
    'UrnForeignKey': UrnForeignKeyClass,
    'SchemaFieldAliases': SchemaFieldAliasesClass,
    'SchemaFieldInfo': SchemaFieldInfoClass,
    'DataHubSecretValue': DataHubSecretValueClass,
    'NotificationSetting': NotificationSettingClass,
    'NotificationSettingValue': NotificationSettingValueClass,
    'AssetSettings': AssetSettingsClass,
    'AssetSummarySettings': AssetSummarySettingsClass,
    'AssetSummarySettingsTemplate': AssetSummarySettingsTemplateClass,
    'AiAssistantSettings': AiAssistantSettingsClass,
    'AiInstruction': AiInstructionClass,
    'AiInstructionState': AiInstructionStateClass,
    'AiInstructionType': AiInstructionTypeClass,
    'ApplicationsSettings': ApplicationsSettingsClass,
    'DocPropagationFeatureSettings': DocPropagationFeatureSettingsClass,
    'DocumentationAiSettings': DocumentationAiSettingsClass,
    'EmailIntegrationSettings': EmailIntegrationSettingsClass,
    'GlobalHomePageSettings': GlobalHomePageSettingsClass,
    'GlobalIncidentsSettings': GlobalIncidentsSettingsClass,
    'GlobalIntegrationSettings': GlobalIntegrationSettingsClass,
    'GlobalNotificationSettings': GlobalNotificationSettingsClass,
    'GlobalSettingsInfo': GlobalSettingsInfoClass,
    'GlobalViewsSettings': GlobalViewsSettingsClass,
    'GlobalVisualSettings': GlobalVisualSettingsClass,
    'HelpLink': HelpLinkClass,
    'OAuthProvider': OAuthProviderClass,
    'OAuthSettings': OAuthSettingsClass,
    'OidcSettings': OidcSettingsClass,
    'SampleDataSettings': SampleDataSettingsClass,
    'SampleDataStatus': SampleDataStatusClass,
    'SlackIntegrationSettings': SlackIntegrationSettingsClass,
    'SsoSettings': SsoSettingsClass,
    'TeamsChannel': TeamsChannelClass,
    'TeamsIntegrationSettings': TeamsIntegrationSettingsClass,
    'TeamsUser': TeamsUserClass,
    'DataHubStepStateProperties': DataHubStepStatePropertiesClass,
    'PropertyCardinality': PropertyCardinalityClass,
    'PropertyValue': PropertyValueClass,
    'StructuredProperties': StructuredPropertiesClass,
    'StructuredPropertyDefinition': StructuredPropertyDefinitionClass,
    'StructuredPropertyFilterStatus': StructuredPropertyFilterStatusClass,
    'StructuredPropertyKey': StructuredPropertyKeyClass,
    'StructuredPropertySettings': StructuredPropertySettingsClass,
    'StructuredPropertyValueAssignment': StructuredPropertyValueAssignmentClass,
    'EntityChangeDetails': EntityChangeDetailsClass,
    'EntityChangeDetailsFilter': EntityChangeDetailsFilterClass,
    'EntityChangeType': EntityChangeTypeClass,
    'SubscriptionInfo': SubscriptionInfoClass,
    'SubscriptionNotificationConfig': SubscriptionNotificationConfigClass,
    'SubscriptionType': SubscriptionTypeClass,
    'TagProperties': TagPropertiesClass,
    'TelemetryClientId': TelemetryClientIdClass,
    'DataHubPageTemplateAssetSummary': DataHubPageTemplateAssetSummaryClass,
    'DataHubPageTemplateProperties': DataHubPageTemplatePropertiesClass,
    'DataHubPageTemplateRow': DataHubPageTemplateRowClass,
    'DataHubPageTemplateSurface': DataHubPageTemplateSurfaceClass,
    'DataHubPageTemplateVisibility': DataHubPageTemplateVisibilityClass,
    'PageTemplateScope': PageTemplateScopeClass,
    'PageTemplateSurfaceType': PageTemplateSurfaceTypeClass,
    'SummaryElement': SummaryElementClass,
    'SummaryElementType': SummaryElementTypeClass,
    'BatchTestRunEvent': BatchTestRunEventClass,
    'BatchTestRunResult': BatchTestRunResultClass,
    'BatchTestRunStatus': BatchTestRunStatusClass,
    'TestActionsError': TestActionsErrorClass,
    'TestActionsReport': TestActionsReportClass,
    'TestDefinition': TestDefinitionClass,
    'TestDefinitionType': TestDefinitionTypeClass,
    'TestInfo': TestInfoClass,
    'TestInterval': TestIntervalClass,
    'TestMode': TestModeClass,
    'TestReport': TestReportClass,
    'TestResult': TestResultClass,
    'TestResultType': TestResultTypeClass,
    'TestResults': TestResultsClass,
    'TestSchedule': TestScheduleClass,
    'TestSource': TestSourceClass,
    'TestSourceType': TestSourceTypeClass,
    'TestStatus': TestStatusClass,
    'AbsoluteTimeWindow': AbsoluteTimeWindowClass,
    'CalendarInterval': CalendarIntervalClass,
    'DayOfWeek': DayOfWeekClass,
    'HolidayWindow': HolidayWindowClass,
    'PartitionSpec': PartitionSpecClass,
    'PartitionType': PartitionTypeClass,
    'TimeWindow': TimeWindowClass,
    'TimeWindowSize': TimeWindowSizeClass,
    'WeeklyWindow': WeeklyWindowClass,
    'DataHubUpgradeRequest': DataHubUpgradeRequestClass,
    'DataHubUpgradeResult': DataHubUpgradeResultClass,
    'DataHubUpgradeState': DataHubUpgradeStateClass,
    'FieldUsageCounts': FieldUsageCountsClass,
    'UsageAggregation': UsageAggregationClass,
    'UsageAggregationMetrics': UsageAggregationMetricsClass,
    'UserUsageCounts': UserUsageCountsClass,
    'VersionSetProperties': VersionSetPropertiesClass,
    'VersioningScheme': VersioningSchemeClass,
    'DataHubViewDefinition': DataHubViewDefinitionClass,
    'DataHubViewInfo': DataHubViewInfoClass,
    'DataHubViewType': DataHubViewTypeClass,
}

_json_converter = avrojson.AvroJsonConverter(use_logical_types=False, schema_types=__SCHEMA_TYPES)
avrojson.set_global_json_converter(_json_converter)


    

ASPECT_CLASSES: List[Type[_Aspect]] = [
    DataHubActionInfoClass,
    DataHubActionStatusClass,
    MonitorAnomalyEventClass,
    QuerySubjectsClass,
    QueryUsageFeaturesClass,
    QueryPropertiesClass,
    QueryUsageStatisticsClass,
    SchemaMetadataClass,
    SchemaProposalsClass,
    EditableSchemaMetadataClass,
    ConstraintInfoClass,
    FormNotificationsClass,
    DataHubPolicyInfoClass,
    DataHubRoleInfoClass,
    SchemaFieldsInferredMetadataClass,
    InferredMetadataClass,
    SchemaFieldsInferredNeighborsClass,
    InferredNeighborsClass,
    StorageFeaturesClass,
    CostFeaturesClass,
    LineageFeaturesClass,
    UsageFeaturesClass,
    CorpUserUsageFeaturesClass,
    TagKeyClass,
    IncidentKeyClass,
    QueryKeyClass,
    DataHubStepStateKeyClass,
    DataJobKeyClass,
    DataHubIngestionSourceKeyClass,
    ActionRequestKeyClass,
    CorpUserKeyClass,
    MLFeatureTableKeyClass,
    GlobalSettingsKeyClass,
    LinkPreviewKeyClass,
    MLFeatureKeyClass,
    DataPlatformInstanceKeyClass,
    AssertionKeyClass,
    TelemetryKeyClass,
    DataHubRoleKeyClass,
    RemoteExecutorKeyClass,
    ActionWorkflowKeyClass,
    RecommendationModuleKeyClass,
    SubscriptionKeyClass,
    DataFlowKeyClass,
    DataHubMetricCubeKeyClass,
    ConstraintKeyClass,
    DataHubAccessTokenKeyClass,
    ExecutionRequestKeyClass,
    DataHubFileKeyClass,
    DataHubPolicyKeyClass,
    MLModelKeyClass,
    MLModelGroupKeyClass,
    PostKeyClass,
    NotebookKeyClass,
    RemoteExecutorGlobalConfigKeyClass,
    DashboardKeyClass,
    DataHubViewKeyClass,
    DataHubPersonaKeyClass,
    DataHubRetentionKeyClass,
    DomainKeyClass,
    RemoteExecutorPoolKeyClass,
    MonitorSuiteKeyClass,
    DataHubOpenAPISchemaKeyClass,
    RoleKeyClass,
    SchemaFieldKeyClass,
    DataHubUpgradeKeyClass,
    OwnershipTypeKeyClass,
    GenericEntityKeyClass,
    DataProcessKeyClass,
    CorpGroupKeyClass,
    MLModelDeploymentKeyClass,
    DataHubPageTemplateKeyClass,
    DataContractKeyClass,
    ERModelRelationshipKeyClass,
    DataPlatformKeyClass,
    DataHubPageModuleKeyClass,
    MonitorKeyClass,
    VersionSetKeyClass,
    TestKeyClass,
    InviteTokenKeyClass,
    DataHubAiConversationKeyClass,
    ChartKeyClass,
    DataHubConnectionKeyClass,
    MLPrimaryKeyKeyClass,
    DataHubSecretKeyClass,
    DataHubActionKeyClass,
    DatasetKeyClass,
    FormKeyClass,
    DocumentKeyClass,
    ContainerKeyClass,
    GlossaryNodeKeyClass,
    DataProcessInstanceKeyClass,
    GlossaryTermKeyClass,
    AnomalyKeyClass,
    RecommendationModuleClass,
    SystemMetadataClass,
    DataJobInputOutputClass,
    EditableDataFlowPropertiesClass,
    DataFlowInfoClass,
    DataJobInfoClass,
    EditableDataJobPropertiesClass,
    VersionInfoClass,
    DatahubIngestionCheckpointClass,
    DatahubIngestionRunSummaryClass,
    DataHubRetentionConfigClass,
    MonitorTimeseriesStateClass,
    MonitorSuiteInfoClass,
    MonitorInfoClass,
    RemoteExecutorPoolGlobalConfigClass,
    DataHubAccessTokenInfoClass,
    DomainsClass,
    DomainPropertiesClass,
    NotebookInfoClass,
    EditableNotebookPropertiesClass,
    NotebookContentClass,
    DataHubIngestionSourceInfoClass,
    DataProductKeyClass,
    DataProductPropertiesClass,
    DataHubAiConversationInfoClass,
    EntityTypeKeyClass,
    EntityTypeInfoClass,
    ChartInfoClass,
    ChartQueryClass,
    EditableChartPropertiesClass,
    ChartUsageStatisticsClass,
    DataHubFileInfoClass,
    LinkPreviewInfoClass,
    DataHubPageTemplatePropertiesClass,
    AssertionRunEventClass,
    AssertionActionsClass,
    AssertionRunSummaryClass,
    AssertionInferenceDetailsClass,
    AssertionInfoClass,
    AssertionDryRunEventClass,
    AssertionAnalyticsRunEventClass,
    DataHubPageModulePropertiesClass,
    TagPropertiesClass,
    IncidentNotificationDetailsClass,
    IncidentActivityEventClass,
    IncidentInfoClass,
    IncidentSourceClass,
    SubscriptionInfoClass,
    TelemetryClientIdClass,
    OwnershipTypeInfoClass,
    LogicalParentClass,
    ApplicationPropertiesClass,
    ApplicationsClass,
    ApplicationKeyClass,
    DashboardUsageStatisticsClass,
    DashboardInfoClass,
    EditableDashboardPropertiesClass,
    ActionRequestInfoClass,
    ActionRequestStatusClass,
    ActionRequestArchivedClass,
    DatasetPropertiesClass,
    DatasetProfileClass,
    SchemaFieldProfileClass,
    DatasetDeprecationClass,
    DatasetUsageStatisticsClass,
    PartitionsSummaryClass,
    ViewPropertiesClass,
    DatasetUpstreamLineageClass,
    IcebergCatalogInfoClass,
    EditableDatasetPropertiesClass,
    UpstreamLineageClass,
    DataContractStatusClass,
    DataContractPropertiesClass,
    DataHubStepStatePropertiesClass,
    ActionWorkflowInfoClass,
    DataHubPersonaInfoClass,
    VersionSetPropertiesClass,
    BatchTestRunEventClass,
    TestResultsClass,
    TestInfoClass,
    BusinessAttributesClass,
    BusinessAttributeKeyClass,
    BusinessAttributeInfoClass,
    DocumentationClass,
    DataPlatformInstanceClass,
    SubTypesClass,
    StatusClass,
    ProposalsClass,
    FormsClass,
    IncidentsSummaryClass,
    InstitutionalMemoryClass,
    OperationClass,
    BrowsePathsClass,
    BrowsePathsV2Class,
    GlobalTagsClass,
    GlossaryTermsClass,
    CostClass,
    OriginClass,
    DeprecationClass,
    VersionPropertiesClass,
    SemanticContentClass,
    AccessClass,
    ShareClass,
    DataTransformLogicClass,
    DisplayPropertiesClass,
    EmbedClass,
    AssertionsSummaryClass,
    AnomaliesSummaryClass,
    SiblingsClass,
    InputFieldsClass,
    OwnershipClass,
    DataHubSecretValueClass,
    DataPlatformInstancePropertiesClass,
    IcebergWarehouseInfoClass,
    PlatformResourceKeyClass,
    PlatformResourceInfoClass,
    DataHubViewInfoClass,
    RemoteExecutorPoolInfoClass,
    RolePropertiesClass,
    ActorsClass,
    CaveatsAndRecommendationsClass,
    MLModelPropertiesClass,
    IntendedUseClass,
    EditableMLModelPropertiesClass,
    MLFeaturePropertiesClass,
    MLHyperParamClass,
    MLTrainingRunPropertiesClass,
    TrainingDataClass,
    SourceCodeClass,
    EditableMLFeatureTablePropertiesClass,
    EditableMLPrimaryKeyPropertiesClass,
    EthicalConsiderationsClass,
    MLModelDeploymentPropertiesClass,
    MLModelFactorPromptsClass,
    MLMetricClass,
    EditableMLModelGroupPropertiesClass,
    QuantitativeAnalysesClass,
    MLPrimaryKeyPropertiesClass,
    EvaluationDataClass,
    MLFeatureTablePropertiesClass,
    EditableMLFeaturePropertiesClass,
    MetricsClass,
    MLModelGroupPropertiesClass,
    ERModelRelationshipPropertiesClass,
    EditableERModelRelationshipPropertiesClass,
    GlossaryTermInfoClass,
    GlossaryRelatedTermsClass,
    GlossaryNodeInfoClass,
    DataHubConnectionDetailsClass,
    DataProcessInstanceRelationshipsClass,
    DataProcessInfoClass,
    DataProcessInstancePropertiesClass,
    DataProcessInstanceInputClass,
    DataProcessInstanceOutputClass,
    DataProcessInstanceRunEventClass,
    DocumentInfoClass,
    DocumentSettingsClass,
    FormSettingsClass,
    FormInfoClass,
    DynamicFormAssignmentClass,
    FormAssignmentStatusClass,
    DataTypeInfoClass,
    DataTypeKeyClass,
    GlobalSettingsInfoClass,
    AssetSettingsClass,
    ExecutionRequestArtifactsLocationClass,
    ExecutionRequestInputClass,
    ExecutionRequestSignalClass,
    ExecutionRequestResultClass,
    DataHubMetricCubeDefinitionClass,
    DataHubMetricCubeEventClass,
    SchemaFieldAliasesClass,
    SchemaFieldInfoClass,
    PostInfoClass,
    EntityInferenceMetadataClass,
    AiInferenceMetadataClass,
    DataHubUpgradeRequestClass,
    DataHubUpgradeResultClass,
    StructuredPropertiesClass,
    StructuredPropertySettingsClass,
    StructuredPropertyKeyClass,
    StructuredPropertyDefinitionClass,
    RemoteExecutorStatusClass,
    CorpUserStatusClass,
    CorpUserSettingsClass,
    CorpGroupEditableInfoClass,
    InviteTokenClass,
    CorpUserEditableInfoClass,
    CorpUserInfoClass,
    CorpGroupInfoClass,
    CorpGroupSettingsClass,
    CorpUserCredentialsClass,
    GroupMembershipClass,
    CorpUserInvitationStatusClass,
    RoleMembershipClass,
    NativeGroupMembershipClass,
    ContainerClass,
    EditableContainerPropertiesClass,
    ContainerPropertiesClass,
    DataPlatformInfoClass,
    SlackUserInfoClass
]

ASPECT_NAME_MAP: Dict[str, Type[_Aspect]] = {
    aspect.get_aspect_name(): aspect
    for aspect in ASPECT_CLASSES
}

from typing import Literal, Set
from typing_extensions import TypedDict

class AspectBag(TypedDict, total=False):
    dataHubActionInfo: DataHubActionInfoClass
    dataHubActionStatus: DataHubActionStatusClass
    monitorAnomalyEvent: MonitorAnomalyEventClass
    querySubjects: QuerySubjectsClass
    queryUsageFeatures: QueryUsageFeaturesClass
    queryProperties: QueryPropertiesClass
    queryUsageStatistics: QueryUsageStatisticsClass
    schemaMetadata: SchemaMetadataClass
    schemaProposals: SchemaProposalsClass
    editableSchemaMetadata: EditableSchemaMetadataClass
    constraintInfo: ConstraintInfoClass
    formNotifications: FormNotificationsClass
    dataHubPolicyInfo: DataHubPolicyInfoClass
    dataHubRoleInfo: DataHubRoleInfoClass
    schemaFieldsInferredMetadata: SchemaFieldsInferredMetadataClass
    inferredMetadata: InferredMetadataClass
    schemaFieldsInferredNeighbors: SchemaFieldsInferredNeighborsClass
    inferredNeighbors: InferredNeighborsClass
    storageFeatures: StorageFeaturesClass
    costFeatures: CostFeaturesClass
    lineageFeatures: LineageFeaturesClass
    usageFeatures: UsageFeaturesClass
    corpUserUsageFeatures: CorpUserUsageFeaturesClass
    tagKey: TagKeyClass
    incidentKey: IncidentKeyClass
    queryKey: QueryKeyClass
    dataHubStepStateKey: DataHubStepStateKeyClass
    dataJobKey: DataJobKeyClass
    dataHubIngestionSourceKey: DataHubIngestionSourceKeyClass
    actionRequestKey: ActionRequestKeyClass
    corpUserKey: CorpUserKeyClass
    mlFeatureTableKey: MLFeatureTableKeyClass
    globalSettingsKey: GlobalSettingsKeyClass
    linkPreviewKey: LinkPreviewKeyClass
    mlFeatureKey: MLFeatureKeyClass
    dataPlatformInstanceKey: DataPlatformInstanceKeyClass
    assertionKey: AssertionKeyClass
    telemetryKey: TelemetryKeyClass
    dataHubRoleKey: DataHubRoleKeyClass
    dataHubRemoteExecutorKey: RemoteExecutorKeyClass
    actionWorkflowKey: ActionWorkflowKeyClass
    recommendationModuleKey: RecommendationModuleKeyClass
    subscriptionKey: SubscriptionKeyClass
    dataFlowKey: DataFlowKeyClass
    dataHubMetricCubeKey: DataHubMetricCubeKeyClass
    constraintKey: ConstraintKeyClass
    dataHubAccessTokenKey: DataHubAccessTokenKeyClass
    dataHubExecutionRequestKey: ExecutionRequestKeyClass
    dataHubFileKey: DataHubFileKeyClass
    dataHubPolicyKey: DataHubPolicyKeyClass
    mlModelKey: MLModelKeyClass
    mlModelGroupKey: MLModelGroupKeyClass
    postKey: PostKeyClass
    notebookKey: NotebookKeyClass
    dataHubRemoteExecutorGlobalConfigKey: RemoteExecutorGlobalConfigKeyClass
    dashboardKey: DashboardKeyClass
    dataHubViewKey: DataHubViewKeyClass
    dataHubPersonaKey: DataHubPersonaKeyClass
    dataHubRetentionKey: DataHubRetentionKeyClass
    domainKey: DomainKeyClass
    dataHubRemoteExecutorPoolKey: RemoteExecutorPoolKeyClass
    monitorSuiteKey: MonitorSuiteKeyClass
    dataHubOpenAPISchemaKey: DataHubOpenAPISchemaKeyClass
    roleKey: RoleKeyClass
    schemaFieldKey: SchemaFieldKeyClass
    dataHubUpgradeKey: DataHubUpgradeKeyClass
    ownershipTypeKey: OwnershipTypeKeyClass
    genericEntityKey: GenericEntityKeyClass
    dataProcessKey: DataProcessKeyClass
    corpGroupKey: CorpGroupKeyClass
    mlModelDeploymentKey: MLModelDeploymentKeyClass
    dataHubPageTemplateKey: DataHubPageTemplateKeyClass
    dataContractKey: DataContractKeyClass
    erModelRelationshipKey: ERModelRelationshipKeyClass
    dataPlatformKey: DataPlatformKeyClass
    dataHubPageModuleKey: DataHubPageModuleKeyClass
    monitorKey: MonitorKeyClass
    versionSetKey: VersionSetKeyClass
    testKey: TestKeyClass
    inviteTokenKey: InviteTokenKeyClass
    dataHubAiConversationKey: DataHubAiConversationKeyClass
    chartKey: ChartKeyClass
    dataHubConnectionKey: DataHubConnectionKeyClass
    mlPrimaryKeyKey: MLPrimaryKeyKeyClass
    dataHubSecretKey: DataHubSecretKeyClass
    dataHubActionKey: DataHubActionKeyClass
    datasetKey: DatasetKeyClass
    formKey: FormKeyClass
    documentKey: DocumentKeyClass
    containerKey: ContainerKeyClass
    glossaryNodeKey: GlossaryNodeKeyClass
    dataProcessInstanceKey: DataProcessInstanceKeyClass
    glossaryTermKey: GlossaryTermKeyClass
    anomalyKey: AnomalyKeyClass
    recommendationModule: RecommendationModuleClass
    systemMetadata: SystemMetadataClass
    dataJobInputOutput: DataJobInputOutputClass
    editableDataFlowProperties: EditableDataFlowPropertiesClass
    dataFlowInfo: DataFlowInfoClass
    dataJobInfo: DataJobInfoClass
    editableDataJobProperties: EditableDataJobPropertiesClass
    versionInfo: VersionInfoClass
    datahubIngestionCheckpoint: DatahubIngestionCheckpointClass
    datahubIngestionRunSummary: DatahubIngestionRunSummaryClass
    dataHubRetentionConfig: DataHubRetentionConfigClass
    monitorTimeseriesState: MonitorTimeseriesStateClass
    monitorSuiteInfo: MonitorSuiteInfoClass
    monitorInfo: MonitorInfoClass
    dataHubRemoteExecutorPoolGlobalConfig: RemoteExecutorPoolGlobalConfigClass
    dataHubAccessTokenInfo: DataHubAccessTokenInfoClass
    domains: DomainsClass
    domainProperties: DomainPropertiesClass
    notebookInfo: NotebookInfoClass
    editableNotebookProperties: EditableNotebookPropertiesClass
    notebookContent: NotebookContentClass
    dataHubIngestionSourceInfo: DataHubIngestionSourceInfoClass
    dataProductKey: DataProductKeyClass
    dataProductProperties: DataProductPropertiesClass
    dataHubAiConversationInfo: DataHubAiConversationInfoClass
    entityTypeKey: EntityTypeKeyClass
    entityTypeInfo: EntityTypeInfoClass
    chartInfo: ChartInfoClass
    chartQuery: ChartQueryClass
    editableChartProperties: EditableChartPropertiesClass
    chartUsageStatistics: ChartUsageStatisticsClass
    dataHubFileInfo: DataHubFileInfoClass
    linkPreviewInfo: LinkPreviewInfoClass
    dataHubPageTemplateProperties: DataHubPageTemplatePropertiesClass
    assertionRunEvent: AssertionRunEventClass
    assertionActions: AssertionActionsClass
    assertionRunSummary: AssertionRunSummaryClass
    assertionInferenceDetails: AssertionInferenceDetailsClass
    assertionInfo: AssertionInfoClass
    assertionDryRunEvent: AssertionDryRunEventClass
    assertionAnalyticsRunEvent: AssertionAnalyticsRunEventClass
    dataHubPageModuleProperties: DataHubPageModulePropertiesClass
    tagProperties: TagPropertiesClass
    incidentNotificationDetails: IncidentNotificationDetailsClass
    incidentActivityEvent: IncidentActivityEventClass
    incidentInfo: IncidentInfoClass
    incidentSource: IncidentSourceClass
    subscriptionInfo: SubscriptionInfoClass
    telemetryClientId: TelemetryClientIdClass
    ownershipTypeInfo: OwnershipTypeInfoClass
    logicalParent: LogicalParentClass
    applicationProperties: ApplicationPropertiesClass
    applications: ApplicationsClass
    applicationKey: ApplicationKeyClass
    dashboardUsageStatistics: DashboardUsageStatisticsClass
    dashboardInfo: DashboardInfoClass
    editableDashboardProperties: EditableDashboardPropertiesClass
    actionRequestInfo: ActionRequestInfoClass
    actionRequestStatus: ActionRequestStatusClass
    actionRequestArchived: ActionRequestArchivedClass
    datasetProperties: DatasetPropertiesClass
    datasetProfile: DatasetProfileClass
    schemaFieldProfile: SchemaFieldProfileClass
    datasetDeprecation: DatasetDeprecationClass
    datasetUsageStatistics: DatasetUsageStatisticsClass
    partitionsSummary: PartitionsSummaryClass
    viewProperties: ViewPropertiesClass
    datasetUpstreamLineage: DatasetUpstreamLineageClass
    icebergCatalogInfo: IcebergCatalogInfoClass
    editableDatasetProperties: EditableDatasetPropertiesClass
    upstreamLineage: UpstreamLineageClass
    dataContractStatus: DataContractStatusClass
    dataContractProperties: DataContractPropertiesClass
    dataHubStepStateProperties: DataHubStepStatePropertiesClass
    actionWorkflowInfo: ActionWorkflowInfoClass
    dataHubPersonaInfo: DataHubPersonaInfoClass
    versionSetProperties: VersionSetPropertiesClass
    batchTestRunEvent: BatchTestRunEventClass
    testResults: TestResultsClass
    testInfo: TestInfoClass
    businessAttributes: BusinessAttributesClass
    businessAttributeKey: BusinessAttributeKeyClass
    businessAttributeInfo: BusinessAttributeInfoClass
    documentation: DocumentationClass
    dataPlatformInstance: DataPlatformInstanceClass
    subTypes: SubTypesClass
    status: StatusClass
    proposals: ProposalsClass
    forms: FormsClass
    incidentsSummary: IncidentsSummaryClass
    institutionalMemory: InstitutionalMemoryClass
    operation: OperationClass
    browsePaths: BrowsePathsClass
    browsePathsV2: BrowsePathsV2Class
    globalTags: GlobalTagsClass
    glossaryTerms: GlossaryTermsClass
    cost: CostClass
    origin: OriginClass
    deprecation: DeprecationClass
    versionProperties: VersionPropertiesClass
    semanticContent: SemanticContentClass
    access: AccessClass
    share: ShareClass
    dataTransformLogic: DataTransformLogicClass
    displayProperties: DisplayPropertiesClass
    embed: EmbedClass
    assertionsSummary: AssertionsSummaryClass
    anomaliesSummary: AnomaliesSummaryClass
    siblings: SiblingsClass
    inputFields: InputFieldsClass
    ownership: OwnershipClass
    dataHubSecretValue: DataHubSecretValueClass
    dataPlatformInstanceProperties: DataPlatformInstancePropertiesClass
    icebergWarehouseInfo: IcebergWarehouseInfoClass
    platformResourceKey: PlatformResourceKeyClass
    platformResourceInfo: PlatformResourceInfoClass
    dataHubViewInfo: DataHubViewInfoClass
    dataHubRemoteExecutorPoolInfo: RemoteExecutorPoolInfoClass
    roleProperties: RolePropertiesClass
    actors: ActorsClass
    mlModelCaveatsAndRecommendations: CaveatsAndRecommendationsClass
    mlModelProperties: MLModelPropertiesClass
    intendedUse: IntendedUseClass
    editableMlModelProperties: EditableMLModelPropertiesClass
    mlFeatureProperties: MLFeaturePropertiesClass
    mlHyperParam: MLHyperParamClass
    mlTrainingRunProperties: MLTrainingRunPropertiesClass
    mlModelTrainingData: TrainingDataClass
    sourceCode: SourceCodeClass
    editableMlFeatureTableProperties: EditableMLFeatureTablePropertiesClass
    editableMlPrimaryKeyProperties: EditableMLPrimaryKeyPropertiesClass
    mlModelEthicalConsiderations: EthicalConsiderationsClass
    mlModelDeploymentProperties: MLModelDeploymentPropertiesClass
    mlModelFactorPrompts: MLModelFactorPromptsClass
    mlMetric: MLMetricClass
    editableMlModelGroupProperties: EditableMLModelGroupPropertiesClass
    mlModelQuantitativeAnalyses: QuantitativeAnalysesClass
    mlPrimaryKeyProperties: MLPrimaryKeyPropertiesClass
    mlModelEvaluationData: EvaluationDataClass
    mlFeatureTableProperties: MLFeatureTablePropertiesClass
    editableMlFeatureProperties: EditableMLFeaturePropertiesClass
    mlModelMetrics: MetricsClass
    mlModelGroupProperties: MLModelGroupPropertiesClass
    erModelRelationshipProperties: ERModelRelationshipPropertiesClass
    editableERModelRelationshipProperties: EditableERModelRelationshipPropertiesClass
    glossaryTermInfo: GlossaryTermInfoClass
    glossaryRelatedTerms: GlossaryRelatedTermsClass
    glossaryNodeInfo: GlossaryNodeInfoClass
    dataHubConnectionDetails: DataHubConnectionDetailsClass
    dataProcessInstanceRelationships: DataProcessInstanceRelationshipsClass
    dataProcessInfo: DataProcessInfoClass
    dataProcessInstanceProperties: DataProcessInstancePropertiesClass
    dataProcessInstanceInput: DataProcessInstanceInputClass
    dataProcessInstanceOutput: DataProcessInstanceOutputClass
    dataProcessInstanceRunEvent: DataProcessInstanceRunEventClass
    documentInfo: DocumentInfoClass
    documentSettings: DocumentSettingsClass
    formSettings: FormSettingsClass
    formInfo: FormInfoClass
    dynamicFormAssignment: DynamicFormAssignmentClass
    formAssignmentStatus: FormAssignmentStatusClass
    dataTypeInfo: DataTypeInfoClass
    dataTypeKey: DataTypeKeyClass
    globalSettingsInfo: GlobalSettingsInfoClass
    assetSettings: AssetSettingsClass
    dataHubExecutionRequestArtifactsLocation: ExecutionRequestArtifactsLocationClass
    dataHubExecutionRequestInput: ExecutionRequestInputClass
    dataHubExecutionRequestSignal: ExecutionRequestSignalClass
    dataHubExecutionRequestResult: ExecutionRequestResultClass
    dataHubMetricCubeDefinition: DataHubMetricCubeDefinitionClass
    dataHubMetricCubeEvent: DataHubMetricCubeEventClass
    schemaFieldAliases: SchemaFieldAliasesClass
    schemafieldInfo: SchemaFieldInfoClass
    postInfo: PostInfoClass
    entityInferenceMetadata: EntityInferenceMetadataClass
    aiInferenceMetadata: AiInferenceMetadataClass
    dataHubUpgradeRequest: DataHubUpgradeRequestClass
    dataHubUpgradeResult: DataHubUpgradeResultClass
    structuredProperties: StructuredPropertiesClass
    structuredPropertySettings: StructuredPropertySettingsClass
    structuredPropertyKey: StructuredPropertyKeyClass
    propertyDefinition: StructuredPropertyDefinitionClass
    dataHubRemoteExecutorStatus: RemoteExecutorStatusClass
    corpUserStatus: CorpUserStatusClass
    corpUserSettings: CorpUserSettingsClass
    corpGroupEditableInfo: CorpGroupEditableInfoClass
    inviteToken: InviteTokenClass
    corpUserEditableInfo: CorpUserEditableInfoClass
    corpUserInfo: CorpUserInfoClass
    corpGroupInfo: CorpGroupInfoClass
    corpGroupSettings: CorpGroupSettingsClass
    corpUserCredentials: CorpUserCredentialsClass
    groupMembership: GroupMembershipClass
    corpUserInvitationStatus: CorpUserInvitationStatusClass
    roleMembership: RoleMembershipClass
    nativeGroupMembership: NativeGroupMembershipClass
    container: ContainerClass
    editableContainerProperties: EditableContainerPropertiesClass
    containerProperties: ContainerPropertiesClass
    dataPlatformInfo: DataPlatformInfoClass
    slackUserInfo: SlackUserInfoClass


KEY_ASPECTS: Dict[str, Type[_Aspect]] = {
    'tag': TagKeyClass,
    'incident': IncidentKeyClass,
    'query': QueryKeyClass,
    'dataHubStepState': DataHubStepStateKeyClass,
    'dataJob': DataJobKeyClass,
    'dataHubIngestionSource': DataHubIngestionSourceKeyClass,
    'actionRequest': ActionRequestKeyClass,
    'corpuser': CorpUserKeyClass,
    'mlFeatureTable': MLFeatureTableKeyClass,
    'globalSettings': GlobalSettingsKeyClass,
    'linkPreview': LinkPreviewKeyClass,
    'mlFeature': MLFeatureKeyClass,
    'dataPlatformInstance': DataPlatformInstanceKeyClass,
    'assertion': AssertionKeyClass,
    'telemetry': TelemetryKeyClass,
    'dataHubRole': DataHubRoleKeyClass,
    'dataHubRemoteExecutor': RemoteExecutorKeyClass,
    'actionWorkflow': ActionWorkflowKeyClass,
    'recommendationModule': RecommendationModuleKeyClass,
    'subscription': SubscriptionKeyClass,
    'dataFlow': DataFlowKeyClass,
    'dataHubMetricCube': DataHubMetricCubeKeyClass,
    'constraint': ConstraintKeyClass,
    'dataHubAccessToken': DataHubAccessTokenKeyClass,
    'dataHubExecutionRequest': ExecutionRequestKeyClass,
    'dataHubFile': DataHubFileKeyClass,
    'dataHubPolicy': DataHubPolicyKeyClass,
    'mlModel': MLModelKeyClass,
    'mlModelGroup': MLModelGroupKeyClass,
    'post': PostKeyClass,
    'notebook': NotebookKeyClass,
    'dataHubRemoteExecutorGlobalConfig': RemoteExecutorGlobalConfigKeyClass,
    'dashboard': DashboardKeyClass,
    'dataHubView': DataHubViewKeyClass,
    'dataHubPersona': DataHubPersonaKeyClass,
    'dataHubRetention': DataHubRetentionKeyClass,
    'domain': DomainKeyClass,
    'dataHubRemoteExecutorPool': RemoteExecutorPoolKeyClass,
    'monitorSuite': MonitorSuiteKeyClass,
    'dataHubOpenAPISchema': DataHubOpenAPISchemaKeyClass,
    'role': RoleKeyClass,
    'schemaField': SchemaFieldKeyClass,
    'dataHubUpgrade': DataHubUpgradeKeyClass,
    'ownershipType': OwnershipTypeKeyClass,
    'dataProcess': DataProcessKeyClass,
    'corpGroup': CorpGroupKeyClass,
    'mlModelDeployment': MLModelDeploymentKeyClass,
    'dataHubPageTemplate': DataHubPageTemplateKeyClass,
    'dataContract': DataContractKeyClass,
    'erModelRelationship': ERModelRelationshipKeyClass,
    'dataPlatform': DataPlatformKeyClass,
    'dataHubPageModule': DataHubPageModuleKeyClass,
    'monitor': MonitorKeyClass,
    'versionSet': VersionSetKeyClass,
    'test': TestKeyClass,
    'inviteToken': InviteTokenKeyClass,
    'dataHubAiConversation': DataHubAiConversationKeyClass,
    'chart': ChartKeyClass,
    'dataHubConnection': DataHubConnectionKeyClass,
    'mlPrimaryKey': MLPrimaryKeyKeyClass,
    'dataHubSecret': DataHubSecretKeyClass,
    'dataHubAction': DataHubActionKeyClass,
    'dataset': DatasetKeyClass,
    'form': FormKeyClass,
    'document': DocumentKeyClass,
    'container': ContainerKeyClass,
    'glossaryNode': GlossaryNodeKeyClass,
    'dataProcessInstance': DataProcessInstanceKeyClass,
    'glossaryTerm': GlossaryTermKeyClass,
    'dataProduct': DataProductKeyClass,
    'entityType': EntityTypeKeyClass,
    'application': ApplicationKeyClass,
    'businessAttribute': BusinessAttributeKeyClass,
    'platformResource': PlatformResourceKeyClass,
    'dataType': DataTypeKeyClass,
    'structuredProperty': StructuredPropertyKeyClass
}

KEY_ASPECT_NAMES: Set[str] = {cls.ASPECT_NAME for cls in KEY_ASPECTS.values()}

ENTITY_TYPE_NAMES: List[str] = [
    'tag',
    'incident',
    'query',
    'dataHubStepState',
    'dataJob',
    'dataHubIngestionSource',
    'actionRequest',
    'corpuser',
    'mlFeatureTable',
    'globalSettings',
    'linkPreview',
    'mlFeature',
    'dataPlatformInstance',
    'assertion',
    'telemetry',
    'dataHubRole',
    'dataHubRemoteExecutor',
    'actionWorkflow',
    'recommendationModule',
    'subscription',
    'dataFlow',
    'dataHubMetricCube',
    'constraint',
    'dataHubAccessToken',
    'dataHubExecutionRequest',
    'dataHubFile',
    'dataHubPolicy',
    'mlModel',
    'mlModelGroup',
    'post',
    'notebook',
    'dataHubRemoteExecutorGlobalConfig',
    'dashboard',
    'dataHubView',
    'dataHubPersona',
    'dataHubRetention',
    'domain',
    'dataHubRemoteExecutorPool',
    'monitorSuite',
    'dataHubOpenAPISchema',
    'role',
    'schemaField',
    'dataHubUpgrade',
    'ownershipType',
    'dataProcess',
    'corpGroup',
    'mlModelDeployment',
    'dataHubPageTemplate',
    'dataContract',
    'erModelRelationship',
    'dataPlatform',
    'dataHubPageModule',
    'monitor',
    'versionSet',
    'test',
    'inviteToken',
    'dataHubAiConversation',
    'chart',
    'dataHubConnection',
    'mlPrimaryKey',
    'dataHubSecret',
    'dataHubAction',
    'dataset',
    'form',
    'document',
    'container',
    'glossaryNode',
    'dataProcessInstance',
    'glossaryTerm',
    'dataProduct',
    'entityType',
    'application',
    'businessAttribute',
    'platformResource',
    'dataType',
    'structuredProperty'
]
EntityTypeName = Literal[
    'tag',
    'incident',
    'query',
    'dataHubStepState',
    'dataJob',
    'dataHubIngestionSource',
    'actionRequest',
    'corpuser',
    'mlFeatureTable',
    'globalSettings',
    'linkPreview',
    'mlFeature',
    'dataPlatformInstance',
    'assertion',
    'telemetry',
    'dataHubRole',
    'dataHubRemoteExecutor',
    'actionWorkflow',
    'recommendationModule',
    'subscription',
    'dataFlow',
    'dataHubMetricCube',
    'constraint',
    'dataHubAccessToken',
    'dataHubExecutionRequest',
    'dataHubFile',
    'dataHubPolicy',
    'mlModel',
    'mlModelGroup',
    'post',
    'notebook',
    'dataHubRemoteExecutorGlobalConfig',
    'dashboard',
    'dataHubView',
    'dataHubPersona',
    'dataHubRetention',
    'domain',
    'dataHubRemoteExecutorPool',
    'monitorSuite',
    'dataHubOpenAPISchema',
    'role',
    'schemaField',
    'dataHubUpgrade',
    'ownershipType',
    'dataProcess',
    'corpGroup',
    'mlModelDeployment',
    'dataHubPageTemplate',
    'dataContract',
    'erModelRelationship',
    'dataPlatform',
    'dataHubPageModule',
    'monitor',
    'versionSet',
    'test',
    'inviteToken',
    'dataHubAiConversation',
    'chart',
    'dataHubConnection',
    'mlPrimaryKey',
    'dataHubSecret',
    'dataHubAction',
    'dataset',
    'form',
    'document',
    'container',
    'glossaryNode',
    'dataProcessInstance',
    'glossaryTerm',
    'dataProduct',
    'entityType',
    'application',
    'businessAttribute',
    'platformResource',
    'dataType',
    'structuredProperty'
]

# fmt: on
