"""
CLAUDE.md generator for Claude Code integration.

Generates a comprehensive CLAUDE.md file from .vk/ configuration that
Claude Code reads to understand project context, rules, and current work.
"""

from datetime import datetime
from pathlib import Path
from typing import Optional

import yaml


class ClaudeMdGenerator:
    """
    Generator for CLAUDE.md file.

    Reads all configuration from .vk/ folder and generates a unified
    CLAUDE.md that Claude Code uses for project context.

    Usage:
        generator = ClaudeMdGenerator(project_root)
        generator.generate()
    """

    def __init__(self, project_root: Optional[Path] = None):
        """
        Initialize generator.

        Args:
            project_root: Root directory of the project (default: cwd)
        """
        self.project_root = project_root or Path.cwd()
        self.vk_dir = self.project_root / ".vk"
        self.output_file = self.project_root / "CLAUDE.md"

    def generate(self) -> Path:
        """
        Generate CLAUDE.md from .vk/ configuration.

        Returns:
            Path to generated CLAUDE.md file
        """
        content = self._build_content()
        self.output_file.write_text(content)
        return self.output_file

    def _build_content(self) -> str:
        """Build complete CLAUDE.md content."""
        sections = [
            self._generate_header(),
            self._generate_project_section(),
            self._generate_roadmap_section(),
            self._generate_sprint_section(),
            self._generate_rules_section(),
            self._generate_tools_section(),
            self._generate_agents_section(),
            self._generate_agent_routing_section(),
            self._generate_footer(),
        ]

        return "\n\n".join(filter(None, sections))

    def _generate_header(self) -> str:
        """Generate header section."""
        project_name = self._get_project_name()
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

        return f"""# Project: {project_name}

> Auto-generated by VibeKit on {timestamp}
> DO NOT EDIT MANUALLY - Run `vk pull` to update

This file provides Claude Code with project context, rules, and current sprint information.
Follow the guidelines and rules defined here when working on this project."""

    def _generate_project_section(self) -> str:
        """Generate project overview section."""
        config = self._load_config()
        if not config:
            return ""

        lines = ["## Project Overview"]

        if config.get("description"):
            lines.append(f"\n{config['description']}")

        # Tech stack
        tech_stack = config.get("tech_stack", {})
        if tech_stack:
            lines.append("\n### Tech Stack")
            if tech_stack.get("languages"):
                lines.append(f"- **Languages**: {', '.join(tech_stack['languages'])}")
            if tech_stack.get("frameworks"):
                lines.append(f"- **Frameworks**: {', '.join(tech_stack['frameworks'])}")
            if tech_stack.get("databases"):
                lines.append(f"- **Databases**: {', '.join(tech_stack['databases'])}")
            if tech_stack.get("tools"):
                lines.append(f"- **Tools**: {', '.join(tech_stack['tools'])}")

        # Objectives
        objectives = config.get("objectives", [])
        if objectives:
            lines.append("\n### Objectives")
            for obj in objectives:
                lines.append(f"- {obj}")

        # Success criteria
        criteria = config.get("success_criteria", [])
        if criteria:
            lines.append("\n### Success Criteria")
            for crit in criteria:
                lines.append(f"- {crit}")

        return "\n".join(lines)

    def _generate_roadmap_section(self) -> str:
        """Generate project roadmap section."""
        roadmap = self._load_roadmap()
        if not roadmap:
            return ""

        lines = ["## Project Roadmap"]

        # Find current phase
        current_phase = None
        for phase in roadmap:
            if phase.get("status") == "in_progress":
                current_phase = phase
                break

        if current_phase:
            lines.append(
                f"\n**Current Phase**: Phase {current_phase.get('phase_number', '')} - {current_phase.get('name', '')} (In Progress)"
            )
            if current_phase.get("target_date"):
                lines.append(
                    f"**Target**: {current_phase['target_date'][:10] if isinstance(current_phase['target_date'], str) else current_phase['target_date']}"
                )

        lines.append("\n### Phases")
        for phase in roadmap:
            status = phase.get("status", "planned")
            if status == "completed":
                status_mark = "[x]"
            elif status == "in_progress":
                status_mark = "[~]"
            else:
                status_mark = "[ ]"

            phase_line = (
                f"{phase.get('phase_number', '')}. {status_mark} **{phase.get('name', '')}**"
            )
            if status == "completed":
                phase_line += " - Completed"
            elif status == "in_progress":
                phase_line += " - In Progress"
                if phase.get("target_date"):
                    target = (
                        phase["target_date"][:10]
                        if isinstance(phase["target_date"], str)
                        else phase["target_date"]
                    )
                    phase_line += f" (Target: {target})"
            else:
                phase_line += " - Planned"

            lines.append(phase_line)

            # Show milestones for current phase
            if status == "in_progress" and phase.get("milestones"):
                for m in phase["milestones"]:
                    m_status = "[x]" if m.get("completed") else "[ ]"
                    lines.append(f"   - {m_status} {m.get('name', '')}")

        return "\n".join(lines)

    def _generate_sprint_section(self) -> str:
        """Generate current sprint section."""
        sprint = self._load_sprint()
        if not sprint:
            return ""

        lines = [f"## Current Sprint: {sprint.get('name', 'Unnamed Sprint')}"]

        if sprint.get("goal"):
            lines.append(f"\n**Goal**: {sprint['goal']}")

        if sprint.get("status"):
            lines.append(f"**Status**: {sprint['status']}")

        # Date range
        if sprint.get("start_date") or sprint.get("end_date"):
            start = sprint.get("start_date", "TBD")
            end = sprint.get("end_date", "TBD")
            lines.append(f"**Duration**: {start} - {end}")

        # Requirements and tasks
        requirements = sprint.get("requirements", [])
        if requirements:
            lines.append("\n### Priority Tasks")

            # Sort by priority
            priority_order = {"high": 0, "medium": 1, "low": 2}
            sorted_reqs = sorted(
                requirements, key=lambda r: priority_order.get(r.get("priority", "medium"), 1)
            )

            for req in sorted_reqs:
                status_emoji = self._get_status_emoji(req.get("status", "pending"))
                priority_label = req.get("priority", "medium").upper()
                lines.append(
                    f"\n#### {status_emoji} [{req.get('requirement_id', 'REQ')}] "
                    f"{req.get('title', 'Untitled')} ({priority_label})"
                )

                if req.get("description"):
                    lines.append(f"\n{req['description']}")

                # Tasks
                tasks = req.get("tasks", [])
                if tasks:
                    lines.append("\n**Tasks:**")
                    for task in tasks:
                        task_status = self._get_status_emoji(task.get("status", "pending"))
                        lines.append(
                            f"- {task_status} `{task.get('task_id', 'TASK')}`: "
                            f"{task.get('title', 'Untitled')}"
                        )

        return "\n".join(lines)

    def _generate_rules_section(self) -> str:
        """Generate project rules section."""
        rules_dir = self.vk_dir / "rules"
        if not rules_dir.exists():
            return ""

        lines = ["## Project Rules"]

        # Coding standards
        coding_file = rules_dir / "coding_standards.md"
        if coding_file.exists():
            content = self._extract_rules_content(coding_file)
            if content:
                lines.append("\n### Coding Standards")
                lines.append(content)

        # Architecture rules
        arch_file = rules_dir / "architecture.md"
        if arch_file.exists():
            content = self._extract_rules_content(arch_file)
            if content:
                lines.append("\n### Architecture Rules")
                lines.append(content)

        # Security rules
        security_file = rules_dir / "security.md"
        if security_file.exists():
            content = self._extract_rules_content(security_file)
            if content:
                lines.append("\n### Security Rules")
                lines.append(content)

        # Testing rules
        testing_file = rules_dir / "testing.md"
        if testing_file.exists():
            content = self._extract_rules_content(testing_file)
            if content:
                lines.append("\n### Testing Rules")
                lines.append(content)

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_tools_section(self) -> str:
        """Generate tools configuration section."""
        tools_dir = self.vk_dir / "tools"
        if not tools_dir.exists():
            return ""

        lines = ["## Tools"]

        # LSP configuration
        lsp_file = tools_dir / "lsp.yaml"
        if lsp_file.exists():
            lsp = self._load_yaml(lsp_file)
            if lsp and lsp.get("enabled", True):
                lines.append("\n### LSP Configuration")
                if lsp.get("languages"):
                    lines.append(f"- **Languages**: {', '.join(lsp['languages'])}")
                if lsp.get("symbol_operations"):
                    lines.append("- **Symbol Operations**: Enabled")
                if lsp.get("auto_import"):
                    lines.append("- **Auto-Import**: Enabled")

        # Linters
        linters_file = tools_dir / "linters.yaml"
        if linters_file.exists():
            linters = self._load_yaml(linters_file)
            if linters:
                lines.append("\n### Linters")
                for linter in linters:
                    if linter.get("enabled", True):
                        lines.append(f"- **{linter.get('name', 'Unknown')}**: Enabled")

        # Quality gates
        gates_file = tools_dir / "quality_gates.yaml"
        if gates_file.exists():
            gates = self._load_yaml(gates_file)
            if gates:
                lines.append("\n### Quality Gates")
                lines.append("The following checks must pass before commit:")
                for gate in gates:
                    if gate.get("enabled", True):
                        required = " (REQUIRED)" if gate.get("required") else ""
                        lines.append(f"- {gate.get('name', 'Unknown')}{required}")

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_agents_section(self) -> str:
        """Generate agents configuration section."""
        agents_dir = self.vk_dir / "agents"
        if not agents_dir.exists():
            return ""

        lines = ["## Agents"]

        for agent_file in agents_dir.glob("*.yaml"):
            agent = self._load_yaml(agent_file)
            if agent and agent.get("enabled", True):
                lines.append(f"\n### {agent.get('name', agent_file.stem)}")
                if agent.get("description"):
                    lines.append(agent["description"])
                if agent.get("triggers"):
                    lines.append(f"\n**Triggers**: {', '.join(agent['triggers'])}")
                if agent.get("rules"):
                    lines.append("\n**Rules**:")
                    for rule in agent["rules"]:
                        lines.append(f"- {rule}")

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_agent_routing_section(self) -> str:
        """Generate intelligent agent routing guide section - only if agents exist."""
        # Only generate if agents are configured
        agents_dir = self.vk_dir / "agents"
        if not agents_dir.exists() or not list(agents_dir.glob("*.yaml")):
            return ""

        # Load configured agents
        agents = []
        for agent_file in agents_dir.glob("*.yaml"):
            agent = self._load_yaml(agent_file)
            if agent and agent.get("enabled", True):
                agents.append({
                    "name": agent.get("name", agent_file.stem),
                    "model": agent.get("model", "sonnet"),
                    "description": agent.get("description", ""),
                })

        if not agents:
            return ""

        lines = ["## Agent Selection Guide"]
        lines.append("\nWhen executing tasks, use the configured agents:")
        lines.append("\n### Available Agents")
        lines.append("\n| Agent | Model | Description |")
        lines.append("|-------|-------|-------------|")

        for agent in agents:
            lines.append(f"| `{agent['name']}` | {agent['model']} | {agent['description'][:50]}... |")

        return "\n".join(lines)

    def _generate_footer(self) -> str:
        """Generate footer section."""
        return """---

## Commands

Use these CLI commands to manage the project:

| Command | Description |
|---------|-------------|
| `vk pull` | Sync latest config from SaaS |
| `vk push` | Push task status to SaaS |
| `vk status` | View current sprint status |
| `vk open` | Open project in browser |

---

*Generated by [VibeKit](https://vkcli.com) - Configure in SaaS, execute locally*"""

    # ========================================================================
    # Helper Methods
    # ========================================================================

    def _get_project_name(self) -> str:
        """Get project name from config or folder name."""
        config = self._load_config()
        if config and config.get("name"):
            return config["name"]
        return self.project_root.name

    def _load_config(self) -> Optional[dict]:
        """Load project config from .vk/config.yaml."""
        config_file = self.vk_dir / "config.yaml"
        if not config_file.exists():
            return None
        return self._load_yaml(config_file)

    def _load_sprint(self) -> Optional[dict]:
        """Load current sprint from .vk/sprints/current.yaml."""
        sprint_file = self.vk_dir / "sprints" / "current.yaml"
        if not sprint_file.exists():
            return None
        return self._load_yaml(sprint_file)

    def _load_roadmap(self) -> Optional[list]:
        """Load roadmap phases from .vk/roadmap/phases.yaml."""
        roadmap_file = self.vk_dir / "roadmap" / "phases.yaml"
        if not roadmap_file.exists():
            return None
        data = self._load_yaml(roadmap_file)
        return data if isinstance(data, list) else None

    def _load_yaml(self, path: Path) -> Optional[dict]:
        """Load YAML file safely."""
        try:
            with open(path) as f:
                return yaml.safe_load(f)
        except Exception:
            return None

    def _extract_rules_content(self, path: Path) -> str:
        """Extract rules content from markdown file, removing the header."""
        try:
            content = path.read_text()
            # Skip the first heading line
            lines = content.strip().split("\n")
            if lines and lines[0].startswith("#"):
                lines = lines[1:]
            return "\n".join(lines).strip()
        except Exception:
            return ""

    def _get_status_emoji(self, status: str) -> str:
        """Get emoji for task/requirement status."""
        status_emojis = {
            "pending": "[ ]",
            "in_progress": "[~]",
            "completed": "[x]",
            "blocked": "[!]",
        }
        return status_emojis.get(status.lower(), "[ ]")
