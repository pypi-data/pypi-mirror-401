"""Handles parsing and validation of RDF (.xvg) files generated by GROMACS."""

import os
import re
from pathlib import Path
from typing import Optional

import matplotlib.pyplot as plt
import numpy as np
from numpy.typing import NDArray

from kbkit.config.mplstyle import load_mplstyle
from kbkit.utils.validation import validate_path

load_mplstyle()  # load mpl figure configuration


class RDFParser:
    """
    Class to handle RDF (Radial Distribution Function) data.

    Reads RDF data from a file, checks for convergence, and provides methods to plot the RDF and extract molecular information.

    Parameters
    ----------
    rdf_file : str
        Path to the RDF file containing radial distances and corresponding g(r) values.
    use_fixed_rmin : bool, optional
        Used fixed rmin (last 0.5 nm) for fitting running KBI. (default: False)
    """

    def __init__(
        self, rdf_file: str | Path, use_fixed_rmin: bool = False, convergence_threshold: float = 0.005
    ) -> None:
        self.rdf_file = validate_path(rdf_file, suffix=".xvg")
        # read rdf_file
        self._read()
        # make sure rdf is converged
        self.is_converged = self.convergence_check(convergence_threshold=convergence_threshold)
        # optionally fix rmin to max possible value
        if use_fixed_rmin:
            self._rmin = self.rmax - 1

    def _read(self) -> None:
        """Read RDF file and extracts radial distances (r) and g(r) values.

        The file is expected to have two columns: r and g(r).
        It filters out noise from the tail of the RDF curve.
        """
        try:
            r, g = np.loadtxt(self.rdf_file, comments=["@", "#"], unpack=True)
        except FileNotFoundError as e:
            raise FileNotFoundError(f"RDF file '{self.rdf_file}' not found.") from e
        except IOError as ioe:
            raise IOError(f"Error reading file '{self.rdf_file}': {ioe}.") from ioe
        except ValueError as ve:
            raise ValueError(f"Failed to parse RDF data from '{self.rdf_file}': {ve}.") from ve
        except Exception as e:
            raise RuntimeError(f"Unexpected error reading '{self.rdf_file}': {e}") from e

        self._r = r[:-3]
        self._g = g[:-3]
        self._rmin = self._r.max() - 1

    @property
    def r(self) -> NDArray[np.float64]:
        """np.ndarray: Radial distances in nm."""
        if isinstance(self._r, np.ndarray):
            return self._r
        else:
            raise TypeError(f"Expected an np.ndarray, r type({type(self._r)})")

    @property
    def rmax(self) -> float:
        """float: Maximum radial distance in nm."""
        r_max = self._r.max()
        if isinstance(r_max, float):
            return r_max
        else:
            raise TypeError(f"Expected an np.ndarray, r-max type({type(r_max)})")

    @property
    def g(self) -> NDArray[np.float64]:
        """np.ndarray: g(r) values corresponding to the radial distances."""
        if isinstance(self._g, np.ndarray):
            return self._g
        else:
            raise TypeError(f"Expected an np.ndarray, g type({type(self._g)})")

    @property
    def rmin(self) -> float:
        """float: Lower bound for the radial distance, used in convergence checks."""
        if isinstance(self._rmin, float):
            return self._rmin
        else:
            raise TypeError(f"Expected an np.ndarray, r-min type({type(self._rmin)})")

    @rmin.setter
    def rmin(self, value: float) -> None:
        if not isinstance(value, (int, float)):
            raise TypeError(f"Value must be float or int, type {type(value)} detected.")
        if value < 0:
            raise ValueError("Lower bound must be non-negative.")
        if value > self.rmax:
            raise ValueError(f"Lower bound {value} exceeds rmax {self.rmax}.")
        self._rmin = value

    @property
    def r_mask(self) -> NDArray[np.bool]:
        """np.ndarray: Boolean mask for radial distances within the range [rmin, rmax]."""
        return (self.r >= self.rmin) & (self.r <= self.rmax)

    @property
    def r_fit(self) -> NDArray[np.float64]:
        """np.ndarray: Radial distances within the range [rmin, rmax]."""
        return self.r[self.r_mask]

    @property
    def g_fit(self) -> NDArray[np.float64]:
        """np.ndarray: g(r) values within the range [rmin, rmax]."""
        return self.g[self.r_mask]

    def convergence_check(
        self,
        convergence_threshold: float = 5e-3,
        max_attempts: int = 10,
    ) -> bool:
        """
        Check if the RDF is converged based on the slope of g(r) and its standard deviation.

        Parameters
        ----------
        convergence_threshold : float, optional
            Threshold for the slope of g(r) to determine convergence. Default is 5e-3.
        flatness_threshold : float, optional
            Threshold for the standard deviation of g(r) to determine flatness. Default is 5e-3.
        max_attempts : int, optional
            Maximum number of attempts to check convergence by adjusting the lower bound (rmin). Default is 10.

        Returns
        -------
        bool
            True if the RDF is converged, False otherwise.
        """
        MIN_PTS = 3  # min # points accepted for tail check

        for _ in range(max_attempts):
            r = self._r[self.r_mask]
            g = self._g[self.r_mask]

            if len(r) < MIN_PTS:
                raise ValueError("Not enough points for convergence check.")

            # get slope of tail
            try:
                slope, _ = np.polyfit(r, g, 1)
            except Exception as e:
                raise RuntimeError(f"Failed to cpute slope via polyfit: {e}") from e

            # perform checks
            if abs(slope) < convergence_threshold:
                return True

            # Adjust rmin to expand cutoff region slightly
            self.rmin += 0.1 * (self.rmax - self.rmin)

            # if rmin too close to rmax stop iterating
            if self.rmin >= self.rmax - 0.5:
                break

        # if convergence not acheived
        print(
            f"Convergence not achieved after {max_attempts} attempts for {self.rdf_file.name} "
            f"in system {self.rdf_file.parent.parent.name}; "
            f"slope (thresh={convergence_threshold:.4g}) {slope:.4g}, "
        )
        self.rmin = self.rmax - 0.5  # reset rmin to max possible safe value
        return False

    def plot(
        self,
        xlim: tuple[float, float] = (4, 5),
        ylim: tuple[float, float] = (0.99, 1.01),
        line: bool = False,
        save_dir: Optional[str] = None,
    ) -> None:
        """
        Plot RDF with an inset showing a zoomed-in view of the specified region.

        Parameters
        ----------
        xlim : list of float, optional
            x-axis limits for the inset plot. Default is [4, 5].
        ylim : list of float, optional
            y-axis limits for the inset plot. Default is [0.99, 1.01].
        line : bool, optional
            If True, adds a horizontal line at y=1. Default is False.
        save_dir : str, optional
            Directory to save the plot. If None, the plot is displayed but not saved. Default is None.
        """
        # set up main fig/axes
        fig, main_ax = plt.subplots(figsize=(6, 6))
        main_ax.set_box_aspect(0.8)
        inset_ax = main_ax.inset_axes(
            (0.65, 0.12, 0.3, 0.3),  # x, y, width, height
            xlim=xlim,
            ylim=ylim,  # sets viewport &amp; tells relation to main axes
            # xticklabels=[], yticklabels=[]
        )
        inset_ax.tick_params(axis="x", labelsize=11)
        inset_ax.tick_params(axis="y", labelsize=11)

        # add plot content
        for ax in main_ax, inset_ax:
            ax.plot(self.r, self.g)  # first example line
        if line:
            inset_ax.axhline(1.0, c="k", ls="--", lw=1.5)

        # add zoom leaders
        main_ax.indicate_inset_zoom(inset_ax, edgecolor="black")
        main_ax.set_xlabel(r"$r$ [$nm$]")
        main_ax.set_ylabel(r"$g(r)$")
        if save_dir is not None:
            rdf_name = str(self.rdf_file.name).strip(".xvg")
            fig.savefig(os.path.join(save_dir, rdf_name + ".pdf"))

    @staticmethod
    def extract_molecules(text: str, mol_list: list[str]) -> list[str]:
        """
        Extract molecule names used in RDF from the RDF file name.

        Parameters
        ----------
        rdf_file : str
            Path to the RDF file.
        mol_list : list of str
            List of molecule names to search for in the file name.

        Returns
        -------
        list[str]
            List of molecule names found in the RDF file name.
        """
        if not isinstance(text, str):
            try:
                text = str(text)
            except TypeError as e:
                raise TypeError("Could not convert filename to type str.") from e

        # define pattern for mol in mol_list
        pattern = r"(" + "|".join(re.escape(mol) for mol in mol_list) + r")"

        # find matches of pattern in filename
        matches = re.findall(pattern, text)
        return matches
