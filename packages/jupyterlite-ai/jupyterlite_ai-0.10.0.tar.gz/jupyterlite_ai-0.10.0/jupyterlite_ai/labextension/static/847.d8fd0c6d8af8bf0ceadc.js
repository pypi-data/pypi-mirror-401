"use strict";(self.webpackChunk_jupyterlite_ai=self.webpackChunk_jupyterlite_ai||[]).push([[847],{7847:(t,e,r)=>{r.r(e),r.d(e,{ElicitResultSchema:()=>B,ElicitationRequestSchema:()=>G,UnauthorizedError:()=>yt,auth:()=>Ut,createMCPClient:()=>jt,experimental_createMCPClient:()=>jt});var o=r(116),n=r(2100),s=r(1408),i=r(337);let a;async function c(t){const e=await(await a).subtle.digest("SHA-256",(new TextEncoder).encode(t));return btoa(String.fromCharCode(...new Uint8Array(e))).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,"")}async function l(t){if(t||(t=43),t<43||t>128)throw`Expected a length between 43 and 128. Received ${t}.`;const e=await async function(t){return await async function(t){let e="";const r=await async function(t){return(await a).getRandomValues(new Uint8Array(t))}(t);for(let o=0;o<t;o++)e+="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"[r[o]%66];return e}(t)}(t);return{code_verifier:e,code_challenge:await c(e)}}a=globalThis.crypto;var u,p,h,d,m="vercel.ai.error.AI_MCPClientError",g=Symbol.for(m),w=class extends(p=n.bD,u=g,p){constructor({name:t="MCPClientError",message:e,cause:r,data:o,code:n}){super({name:t,message:e,cause:r}),this[u]=!0,this.data=o,this.code=n}static isInstance(t){return n.bD.hasMarker(t,m)}},z="2025-06-18",f=[z,"2025-03-26","2024-11-05"],_=i.z.optional(i.z.record(i.z.string(),i.z.unknown())),y=i.z.looseObject({name:i.z.string(),version:i.z.string()}),v=i.z.looseObject({_meta:i.z.optional(i.z.object({}).loose())}),b=v,C=i.z.object({method:i.z.string(),params:i.z.optional(v)}),R=i.z.object({applyDefaults:i.z.optional(i.z.boolean())}).loose(),T=i.z.looseObject({experimental:i.z.optional(i.z.object({}).loose()),logging:i.z.optional(i.z.object({}).loose()),prompts:i.z.optional(i.z.looseObject({listChanged:i.z.optional(i.z.boolean())})),resources:i.z.optional(i.z.looseObject({subscribe:i.z.optional(i.z.boolean()),listChanged:i.z.optional(i.z.boolean())})),tools:i.z.optional(i.z.looseObject({listChanged:i.z.optional(i.z.boolean())})),elicitation:i.z.optional(R)}),E=(i.z.object({elicitation:i.z.optional(R)}).loose(),b.extend({protocolVersion:i.z.string(),capabilities:T,serverInfo:y,instructions:i.z.optional(i.z.string())})),U=b.extend({nextCursor:i.z.optional(i.z.string())}),P=i.z.object({name:i.z.string(),description:i.z.optional(i.z.string()),inputSchema:i.z.object({type:i.z.literal("object"),properties:i.z.optional(i.z.object({}).loose())}).loose(),annotations:i.z.optional(i.z.object({title:i.z.optional(i.z.string())}).loose()),_meta:_}).loose(),S=U.extend({tools:i.z.array(P)}),k=i.z.object({type:i.z.literal("text"),text:i.z.string()}).loose(),j=i.z.object({type:i.z.literal("image"),data:i.z.base64(),mimeType:i.z.string()}).loose(),I=i.z.object({uri:i.z.string(),name:i.z.string(),title:i.z.optional(i.z.string()),description:i.z.optional(i.z.string()),mimeType:i.z.optional(i.z.string()),size:i.z.optional(i.z.number())}).loose(),x=U.extend({resources:i.z.array(I)}),A=i.z.object({uri:i.z.string(),name:i.z.optional(i.z.string()),title:i.z.optional(i.z.string()),mimeType:i.z.optional(i.z.string())}).loose(),M=A.extend({text:i.z.string()}),$=A.extend({blob:i.z.base64()}),O=i.z.object({type:i.z.literal("resource"),resource:i.z.union([M,$])}).loose(),q=b.extend({content:i.z.array(i.z.union([k,j,O])),isError:i.z.boolean().default(!1).optional()}).or(b.extend({toolResult:i.z.unknown()})),H=i.z.object({uriTemplate:i.z.string(),name:i.z.string(),title:i.z.optional(i.z.string()),description:i.z.optional(i.z.string()),mimeType:i.z.optional(i.z.string())}).loose(),L=b.extend({resourceTemplates:i.z.array(H)}),D=b.extend({contents:i.z.array(i.z.union([M,$]))}),V=i.z.object({name:i.z.string(),description:i.z.optional(i.z.string()),required:i.z.optional(i.z.boolean())}).loose(),N=i.z.object({name:i.z.string(),title:i.z.optional(i.z.string()),description:i.z.optional(i.z.string()),arguments:i.z.optional(i.z.array(V))}).loose(),F=U.extend({prompts:i.z.array(N)}),Z=i.z.object({role:i.z.union([i.z.literal("user"),i.z.literal("assistant")]),content:i.z.union([k,j,O])}).loose(),J=b.extend({description:i.z.optional(i.z.string()),messages:i.z.array(Z)}),W=v.extend({message:i.z.string(),requestedSchema:i.z.unknown()}),G=C.extend({method:i.z.literal("elicitation/create"),params:W}),B=b.extend({action:i.z.union([i.z.literal("accept"),i.z.literal("decline"),i.z.literal("cancel")]),content:i.z.optional(i.z.record(i.z.string(),i.z.unknown()))}),K="2.0",Q=i.z.object({jsonrpc:i.z.literal(K),id:i.z.union([i.z.string(),i.z.number().int()])}).merge(C).strict(),X=i.z.object({jsonrpc:i.z.literal(K),id:i.z.union([i.z.string(),i.z.number().int()]),result:b}).strict(),Y=i.z.object({jsonrpc:i.z.literal(K),id:i.z.union([i.z.string(),i.z.number().int()]),error:i.z.object({code:i.z.number().int(),message:i.z.string(),data:i.z.optional(i.z.unknown())})}).strict(),tt=i.z.object({jsonrpc:i.z.literal(K)}).merge(i.z.object({method:i.z.string(),params:i.z.optional(v)})).strict(),et=i.z.union([Q,tt,X,Y]),rt="undefined"!=typeof __PACKAGE_VERSION__?__PACKAGE_VERSION__:"0.0.0-test",ot=i.z.object({access_token:i.z.string(),id_token:i.z.string().optional(),token_type:i.z.string(),expires_in:i.z.number().optional(),scope:i.z.string().optional(),refresh_token:i.z.string().optional()}).strip(),nt=i.z.string().url().superRefine((t,e)=>{if(!URL.canParse(t))return e.addIssue({code:i.z.ZodIssueCode.custom,message:"URL must be parseable",fatal:!0}),i.z.NEVER}).refine(t=>{const e=new URL(t);return"javascript:"!==e.protocol&&"data:"!==e.protocol&&"vbscript:"!==e.protocol},{message:"URL cannot use javascript:, data:, or vbscript: scheme"}),st=i.z.object({resource:i.z.string().url(),authorization_servers:i.z.array(nt).optional(),jwks_uri:i.z.string().url().optional(),scopes_supported:i.z.array(i.z.string()).optional(),bearer_methods_supported:i.z.array(i.z.string()).optional(),resource_signing_alg_values_supported:i.z.array(i.z.string()).optional(),resource_name:i.z.string().optional(),resource_documentation:i.z.string().optional(),resource_policy_uri:i.z.string().url().optional(),resource_tos_uri:i.z.string().url().optional(),tls_client_certificate_bound_access_tokens:i.z.boolean().optional(),authorization_details_types_supported:i.z.array(i.z.string()).optional(),dpop_signing_alg_values_supported:i.z.array(i.z.string()).optional(),dpop_bound_access_tokens_required:i.z.boolean().optional()}).passthrough(),it=i.z.object({issuer:i.z.string(),authorization_endpoint:nt,token_endpoint:nt,registration_endpoint:nt.optional(),scopes_supported:i.z.array(i.z.string()).optional(),response_types_supported:i.z.array(i.z.string()),grant_types_supported:i.z.array(i.z.string()).optional(),code_challenge_methods_supported:i.z.array(i.z.string()),token_endpoint_auth_methods_supported:i.z.array(i.z.string()).optional(),token_endpoint_auth_signing_alg_values_supported:i.z.array(i.z.string()).optional()}).passthrough(),at=i.z.object({issuer:i.z.string(),authorization_endpoint:nt,token_endpoint:nt,userinfo_endpoint:nt.optional(),jwks_uri:nt,registration_endpoint:nt.optional(),scopes_supported:i.z.array(i.z.string()).optional(),response_types_supported:i.z.array(i.z.string()),grant_types_supported:i.z.array(i.z.string()).optional(),subject_types_supported:i.z.array(i.z.string()),id_token_signing_alg_values_supported:i.z.array(i.z.string()),claims_supported:i.z.array(i.z.string()).optional(),token_endpoint_auth_methods_supported:i.z.array(i.z.string()).optional()}).passthrough().merge(it.pick({code_challenge_methods_supported:!0})),ct=i.z.object({client_id:i.z.string(),client_secret:i.z.string().optional(),client_id_issued_at:i.z.number().optional(),client_secret_expires_at:i.z.number().optional()}).strip(),lt=i.z.object({redirect_uris:i.z.array(nt),token_endpoint_auth_method:i.z.string().optional(),grant_types:i.z.array(i.z.string()).optional(),response_types:i.z.array(i.z.string()).optional(),client_name:i.z.string().optional(),client_uri:nt.optional(),logo_uri:nt.optional(),scope:i.z.string().optional(),contacts:i.z.array(i.z.string()).optional(),tos_uri:nt.optional(),policy_uri:i.z.string().optional(),jwks_uri:nt.optional(),jwks:i.z.any().optional(),software_id:i.z.string().optional(),software_version:i.z.string().optional(),software_statement:i.z.string().optional()}).strip(),ut=i.z.object({error:i.z.string(),error_description:i.z.string().optional(),error_uri:i.z.string().optional()}),pt=lt.merge(ct),ht="vercel.ai.error.AI_MCPClientOAuthError",dt=Symbol.for(ht),mt=class extends(d=n.bD,h=dt,d){constructor({name:t="MCPClientOAuthError",message:e,cause:r}){super({name:t,message:e,cause:r}),this[h]=!0}static isInstance(t){return n.bD.hasMarker(t,ht)}},gt=class extends mt{};gt.errorCode="server_error";var wt=class extends mt{};wt.errorCode="invalid_client";var zt=class extends mt{};zt.errorCode="invalid_grant";var ft=class extends mt{};ft.errorCode="unauthorized_client";var _t={[gt.errorCode]:gt,[wt.errorCode]:wt,[zt.errorCode]:zt,[ft.errorCode]:ft},yt=class extends Error{constructor(t="Unauthorized"){super(t),this.name="UnauthorizedError"}};function vt(t){var e;const r=null!=(e=t.headers.get("www-authenticate"))?e:t.headers.get("WWW-Authenticate");if(!r)return;const[o,n]=r.split(" ");if("bearer"!==o.toLowerCase()||!n)return;const s=r.match(/resource_metadata="([^"]*)"/);if(s)try{return new URL(s[1])}catch(t){return}}async function bt(t,e,r=fetch){try{return await r(t,{headers:e})}catch(o){if(o instanceof TypeError)return e?bt(t,void 0,r):void 0;throw o}}async function Ct(t,e,r=fetch){const o={"MCP-Protocol-Version":e};return await bt(t,o,r)}function Rt(t,e){const r=void 0!==t.client_secret;return 0===e.length?r?"client_secret_post":"none":r&&e.includes("client_secret_basic")?"client_secret_basic":r&&e.includes("client_secret_post")?"client_secret_post":e.includes("none")?"none":r?"client_secret_post":"none"}function Tt(t,e,r,o){const{client_id:n,client_secret:s}=e;switch(t){case"client_secret_basic":return void function(t,e,r){if(!e)throw new Error("client_secret_basic authentication requires a client_secret");const o=btoa(`${t}:${e}`);r.set("Authorization",`Basic ${o}`)}(n,s,r);case"client_secret_post":return void function(t,e,r){r.set("client_id",t),e&&r.set("client_secret",e)}(n,s,o);case"none":return void function(t,e){e.set("client_id",t)}(n,o);default:throw new Error(`Unsupported client authentication method: ${t}`)}}async function Et(t){const e=t instanceof Response?t.status:void 0,r=t instanceof Response?await t.text():t;try{const t=ut.parse(JSON.parse(r)),{error:e,error_description:o,error_uri:n}=t;return new(_t[e]||gt)({message:o||"",cause:n})}catch(t){return new gt({message:`${e?`HTTP ${e}: `:""}Invalid OAuth error response: ${t}. Raw body: ${r}`})}}async function Ut(t,e){var r,o;try{return await Pt(t,e)}catch(n){if(n instanceof wt||n instanceof ft)return await(null==(r=t.invalidateCredentials)?void 0:r.call(t,"all")),await Pt(t,e);if(n instanceof zt)return await(null==(o=t.invalidateCredentials)?void 0:o.call(t,"tokens")),await Pt(t,e);throw n}}async function Pt(t,{serverUrl:e,authorizationCode:r,scope:o,resourceMetadataUrl:n,fetchFn:s}){let i,a;try{i=await async function(t,e,r=fetch){const o=await async function(t,e,r,o){var n,s;const i=new URL(t),a=null!=(n=null==o?void 0:o.protocolVersion)?n:z;let c;if(null==o?void 0:o.metadataUrl)c=new URL(o.metadataUrl);else{const t=function(t,e="",r={}){return e.endsWith("/")&&(e=e.slice(0,-1)),r.prependPathname?`${e}/.well-known/${t}`:`/.well-known/${t}${e}`}(e,i.pathname);c=new URL(t,null!=(s=null==o?void 0:o.metadataServerUrl)?s:i),c.search=i.search}let l=await Ct(c,a,r);if(!(null==o?void 0:o.metadataUrl)&&function(t,e){return!t||t.status>=400&&t.status<500&&"/"!==e}(l,i.pathname)){const t=new URL(`/.well-known/${e}`,i);l=await Ct(t,a,r)}return l}(t,"oauth-protected-resource",r,{protocolVersion:null==e?void 0:e.protocolVersion,metadataUrl:null==e?void 0:e.resourceMetadataUrl});if(!o||404===o.status)throw new Error("Resource server does not implement OAuth 2.0 Protected Resource Metadata.");if(!o.ok)throw new Error(`HTTP ${o.status} trying to load well-known OAuth protected resource metadata.`);return st.parse(await o.json())}(e,{resourceMetadataUrl:n},s),i.authorization_servers&&i.authorization_servers.length>0&&(a=i.authorization_servers[0])}catch(t){}a||(a=e);const c=await async function(t,e,r){const o=function(t){const e="string"==typeof t?new URL(t):new URL(t.href);return e.hash="",e}(t);if(e.validateResourceURL)return await e.validateResourceURL(o,null==r?void 0:r.resource);if(r){if(!function({requestedResource:t,configuredResource:e}){const r="string"==typeof t?new URL(t):new URL(t.href),o="string"==typeof e?new URL(e):new URL(e.href);if(r.origin!==o.origin)return!1;if(r.pathname.length<o.pathname.length)return!1;const n=r.pathname.endsWith("/")?r.pathname:r.pathname+"/",s=o.pathname.endsWith("/")?o.pathname:o.pathname+"/";return n.startsWith(s)}({requestedResource:o,configuredResource:r.resource}))throw new Error(`Protected resource ${r.resource} does not match expected ${o} (or origin)`);return new URL(r.resource)}}(e,t,i),u=await async function(t,{fetchFn:e=fetch,protocolVersion:r=z}={}){var o;const n={"MCP-Protocol-Version":r},s=function(t){const e="string"==typeof t?new URL(t):t,r=[];if("/"===e.pathname)return r.push({url:new URL("/.well-known/oauth-authorization-server",e.origin),type:"oauth"}),r.push({url:new URL("/.well-known/openid-configuration",e.origin),type:"oidc"}),r;let o=e.pathname;return o.endsWith("/")&&(o=o.slice(0,-1)),r.push({url:new URL(`/.well-known/oauth-authorization-server${o}`,e.origin),type:"oauth"}),r.push({url:new URL("/.well-known/oauth-authorization-server",e.origin),type:"oauth"}),r.push({url:new URL(`/.well-known/openid-configuration${o}`,e.origin),type:"oidc"}),r.push({url:new URL(`${o}/.well-known/openid-configuration`,e.origin),type:"oidc"}),r}(t);for(const{url:t,type:r}of s){const s=await bt(t,n,e);if(s){if(!s.ok){if(s.status>=400&&s.status<500)continue;throw new Error(`HTTP ${s.status} trying to load ${"oauth"===r?"OAuth":"OpenID provider"} metadata from ${t}`)}if("oauth"===r)return it.parse(await s.json());{const e=at.parse(await s.json());if(!(null==(o=e.code_challenge_methods_supported)?void 0:o.includes("S256")))throw new Error(`Incompatible OIDC provider at ${t}: does not support S256 code challenge method required by MCP specification`);return e}}}}(a,{fetchFn:s});let p=await Promise.resolve(t.clientInformation());if(!p){if(void 0!==r)throw new Error("Existing OAuth client information is required when exchanging an authorization code");if(!t.saveClientInformation)throw new Error("OAuth client information must be saveable for dynamic registration");const e=await async function(t,{metadata:e,clientMetadata:r,fetchFn:o}){let n;if(e){if(!e.registration_endpoint)throw new Error("Incompatible auth server: does not support dynamic client registration");n=new URL(e.registration_endpoint)}else n=new URL("/register",t);const s=await(null!=o?o:fetch)(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!s.ok)throw await Et(s);return pt.parse(await s.json())}(a,{metadata:u,clientMetadata:t.clientMetadata,fetchFn:s});await t.saveClientInformation(e),p=e}if(void 0!==r){const e=await t.codeVerifier(),o=await async function(t,{metadata:e,clientInformation:r,authorizationCode:o,codeVerifier:n,redirectUri:s,resource:i,addClientAuthentication:a,fetchFn:c}){var l;const u="authorization_code",p=(null==e?void 0:e.token_endpoint)?new URL(e.token_endpoint):new URL("/token",t);if((null==e?void 0:e.grant_types_supported)&&!e.grant_types_supported.includes(u))throw new Error(`Incompatible auth server: does not support grant type ${u}`);const h=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"}),d=new URLSearchParams({grant_type:u,code:o,code_verifier:n,redirect_uri:String(s)});a?a(h,d,t,e):Tt(Rt(r,null!=(l=null==e?void 0:e.token_endpoint_auth_methods_supported)?l:[]),r,h,d),i&&d.set("resource",i.href);const m=await(null!=c?c:fetch)(p,{method:"POST",headers:h,body:d});if(!m.ok)throw await Et(m);return ot.parse(await m.json())}(a,{metadata:u,clientInformation:p,authorizationCode:r,codeVerifier:e,redirectUri:t.redirectUrl,resource:c,addClientAuthentication:t.addClientAuthentication,fetchFn:s});return await t.saveTokens(o),"AUTHORIZED"}const h=await t.tokens();if(null==h?void 0:h.refresh_token)try{const e=await async function(t,{metadata:e,clientInformation:r,refreshToken:o,resource:n,addClientAuthentication:s,fetchFn:i}){var a;const c="refresh_token";let l;if(e){if(l=new URL(e.token_endpoint),e.grant_types_supported&&!e.grant_types_supported.includes(c))throw new Error(`Incompatible auth server: does not support grant type ${c}`)}else l=new URL("/token",t);const u=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"}),p=new URLSearchParams({grant_type:c,refresh_token:o});s?s(u,p,t,e):Tt(Rt(r,null!=(a=null==e?void 0:e.token_endpoint_auth_methods_supported)?a:[]),r,u,p),n&&p.set("resource",n.href);const h=await(null!=i?i:fetch)(l,{method:"POST",headers:u,body:p});if(!h.ok)throw await Et(h);return ot.parse({refresh_token:o,...await h.json()})}(a,{metadata:u,clientInformation:p,refreshToken:h.refresh_token,resource:c,addClientAuthentication:t.addClientAuthentication,fetchFn:s});return await t.saveTokens(e),"AUTHORIZED"}catch(t){if(t instanceof mt&&!(t instanceof gt))throw t}const d=t.state?await t.state():void 0,{authorizationUrl:m,codeVerifier:g}=await async function(t,{metadata:e,clientInformation:r,redirectUrl:o,scope:n,state:s,resource:i}){const a="code",c="S256";let u;if(e){if(u=new URL(e.authorization_endpoint),!e.response_types_supported.includes(a))throw new Error(`Incompatible auth server: does not support response type ${a}`);if(!e.code_challenge_methods_supported||!e.code_challenge_methods_supported.includes(c))throw new Error(`Incompatible auth server: does not support code challenge method ${c}`)}else u=new URL("/authorize",t);const p=await l(),h=p.code_verifier,d=p.code_challenge;return u.searchParams.set("response_type",a),u.searchParams.set("client_id",r.client_id),u.searchParams.set("code_challenge",d),u.searchParams.set("code_challenge_method",c),u.searchParams.set("redirect_uri",String(o)),s&&u.searchParams.set("state",s),n&&u.searchParams.set("scope",n),(null==n?void 0:n.includes("offline_access"))&&u.searchParams.append("prompt","consent"),i&&u.searchParams.set("resource",i.href),{authorizationUrl:u,codeVerifier:h}}(a,{metadata:u,clientInformation:p,state:d,redirectUrl:t.redirectUrl,scope:o||t.clientMetadata.scope,resource:c});return await t.saveCodeVerifier(g),await t.redirectToAuthorization(m),"REDIRECT"}var St=class{constructor({url:t,headers:e,authProvider:r}){this.connected=!1,this.url=new URL(t),this.headers=e,this.authProvider=r}async commonHeaders(t){const e={...this.headers,...t,"mcp-protocol-version":z};if(this.authProvider){const t=await this.authProvider.tokens();(null==t?void 0:t.access_token)&&(e.Authorization=`Bearer ${t.access_token}`)}return(0,o.withUserAgentSuffix)(e,`ai-sdk/${rt}`,(0,o.getRuntimeEnvironmentUserAgent)())}async start(){return new Promise((t,e)=>{if(this.connected)return t();this.abortController=new AbortController;const r=async(o=!1)=>{var n,i,a,c,l;try{const l=await this.commonHeaders({Accept:"text/event-stream"}),u=await fetch(this.url.href,{headers:l,signal:null==(n=this.abortController)?void 0:n.signal});if(401===u.status&&this.authProvider&&!o){this.resourceMetadataUrl=vt(u);try{if("AUTHORIZED"!==await Ut(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})){const t=new yt;return null==(i=this.onerror)||i.call(this,t),e(t)}}catch(t){return null==(a=this.onerror)||a.call(this,t),e(t)}return r(!0)}if(!u.ok||!u.body){let t=`MCP SSE Transport Error: ${u.status} ${u.statusText}`;405===u.status&&(t+=". This server does not support SSE transport. Try using `http` transport instead");const r=new w({message:t});return null==(c=this.onerror)||c.call(this,r),e(r)}const p=u.body.pipeThrough(new TextDecoderStream).pipeThrough(new s.Z).getReader(),h=async()=>{var r,o,n;try{for(;;){const{done:e,value:n}=await p.read();if(e){if(this.connected)throw this.connected=!1,new w({message:"MCP SSE Transport Error: Connection closed unexpectedly"});return}const{event:s,data:i}=n;if("endpoint"===s){if(this.endpoint=new URL(i,this.url),this.endpoint.origin!==this.url.origin)throw new w({message:`MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`});this.connected=!0,t()}else if("message"===s)try{const t=et.parse(JSON.parse(i));null==(r=this.onmessage)||r.call(this,t)}catch(t){const e=new w({message:"MCP SSE Transport Error: Failed to parse message",cause:t});null==(o=this.onerror)||o.call(this,e)}}}catch(t){if(t instanceof Error&&"AbortError"===t.name)return;null==(n=this.onerror)||n.call(this,t),e(t)}};this.sseConnection={close:()=>p.cancel()},h()}catch(t){if(t instanceof Error&&"AbortError"===t.name)return;null==(l=this.onerror)||l.call(this,t),e(t)}};r()})}async close(){var t,e,r;this.connected=!1,null==(t=this.sseConnection)||t.close(),null==(e=this.abortController)||e.abort(),null==(r=this.onclose)||r.call(this)}async send(t){if(!this.endpoint||!this.connected)throw new w({message:"MCP SSE Transport Error: Not connected"});const e=this.endpoint,r=async(o=!1)=>{var n,s,i,a,c;try{const c={method:"POST",headers:await this.commonHeaders({"Content-Type":"application/json"}),body:JSON.stringify(t),signal:null==(n=this.abortController)?void 0:n.signal},l=await fetch(e,c);if(401===l.status&&this.authProvider&&!o){this.resourceMetadataUrl=vt(l);try{if("AUTHORIZED"!==await Ut(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})){const t=new yt;return void(null==(s=this.onerror)||s.call(this,t))}}catch(t){return void(null==(i=this.onerror)||i.call(this,t))}return r(!0)}if(!l.ok){const t=await l.text().catch(()=>null),e=new w({message:`MCP SSE Transport Error: POSTing to endpoint (HTTP ${l.status}): ${t}`});return void(null==(a=this.onerror)||a.call(this,e))}}catch(t){return void(null==(c=this.onerror)||c.call(this,t))}};await r()}},kt=class{constructor({url:t,headers:e,authProvider:r}){this.inboundReconnectAttempts=0,this.reconnectionOptions={initialReconnectionDelay:1e3,maxReconnectionDelay:3e4,reconnectionDelayGrowFactor:1.5,maxRetries:2},this.url=new URL(t),this.headers=e,this.authProvider=r}async commonHeaders(t){const e={...this.headers,...t,"mcp-protocol-version":z};if(this.sessionId&&(e["mcp-session-id"]=this.sessionId),this.authProvider){const t=await this.authProvider.tokens();(null==t?void 0:t.access_token)&&(e.Authorization=`Bearer ${t.access_token}`)}return(0,o.withUserAgentSuffix)(e,`ai-sdk/${rt}`,(0,o.getRuntimeEnvironmentUserAgent)())}async start(){if(this.abortController)throw new w({message:"MCP HTTP Transport Error: Transport already started. Note: client.connect() calls start() automatically."});this.abortController=new AbortController,this.openInboundSse()}async close(){var t,e,r;null==(t=this.inboundSseConnection)||t.close();try{if(this.sessionId&&this.abortController&&!this.abortController.signal.aborted){const t=await this.commonHeaders({});await fetch(this.url,{method:"DELETE",headers:t,signal:this.abortController.signal}).catch(()=>{})}}catch(t){}null==(e=this.abortController)||e.abort(),null==(r=this.onclose)||r.call(this)}async send(t){const e=async(r=!1)=>{var o,n,i,a,c,l,u;try{const u={method:"POST",headers:await this.commonHeaders({"Content-Type":"application/json",Accept:"application/json, text/event-stream"}),body:JSON.stringify(t),signal:null==(o=this.abortController)?void 0:o.signal},p=await fetch(this.url,u),h=p.headers.get("mcp-session-id");if(h&&(this.sessionId=h),401===p.status&&this.authProvider&&!r){this.resourceMetadataUrl=vt(p);try{if("AUTHORIZED"!==await Ut(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl}))throw new yt}catch(t){throw null==(n=this.onerror)||n.call(this,t),t}return e(!0)}if(202===p.status)return void(this.inboundSseConnection||this.openInboundSse());if(!p.ok){const t=await p.text().catch(()=>null);let e=`MCP HTTP Transport Error: POSTing to endpoint (HTTP ${p.status}): ${t}`;404===p.status&&(e+=". This server does not support HTTP transport. Try using `sse` transport instead");const r=new w({message:e});throw null==(i=this.onerror)||i.call(this,r),r}const d=p.headers.get("content-type")||"";if(d.includes("application/json")){const t=await p.json(),e=Array.isArray(t)?t.map(t=>et.parse(t)):[et.parse(t)];for(const t of e)null==(a=this.onmessage)||a.call(this,t);return}if(d.includes("text/event-stream")){if(!p.body){const t=new w({message:"MCP HTTP Transport Error: text/event-stream response without body"});throw null==(c=this.onerror)||c.call(this,t),t}const t=p.body.pipeThrough(new TextDecoderStream).pipeThrough(new s.Z).getReader();return void(async()=>{var e,r,o;try{for(;;){const{done:o,value:n}=await t.read();if(o)return;const{event:s,data:i}=n;if("message"===s)try{const t=et.parse(JSON.parse(i));null==(e=this.onmessage)||e.call(this,t)}catch(t){const e=new w({message:"MCP HTTP Transport Error: Failed to parse message",cause:t});null==(r=this.onerror)||r.call(this,e)}}}catch(t){if(t instanceof Error&&"AbortError"===t.name)return;null==(o=this.onerror)||o.call(this,t)}})()}const m=new w({message:`MCP HTTP Transport Error: Unexpected content type: ${d}`});throw null==(l=this.onerror)||l.call(this,m),m}catch(t){throw null==(u=this.onerror)||u.call(this,t),t}};await e()}getNextReconnectionDelay(t){const{initialReconnectionDelay:e,reconnectionDelayGrowFactor:r,maxReconnectionDelay:o}=this.reconnectionOptions;return Math.min(e*Math.pow(r,t),o)}scheduleInboundSseReconnection(){var t;const{maxRetries:e}=this.reconnectionOptions;if(e>0&&this.inboundReconnectAttempts>=e)return void(null==(t=this.onerror)||t.call(this,new w({message:`MCP HTTP Transport Error: Maximum reconnection attempts (${e}) exceeded.`})));const r=this.getNextReconnectionDelay(this.inboundReconnectAttempts);this.inboundReconnectAttempts+=1,setTimeout(async()=>{var t;(null==(t=this.abortController)?void 0:t.signal.aborted)||await this.openInboundSse(!1,this.lastInboundEventId)},r)}async openInboundSse(t=!1,e){var r,o,n,i,a,c;try{const a=await this.commonHeaders({Accept:"text/event-stream"});e&&(a["last-event-id"]=e);const c=await fetch(this.url.href,{method:"GET",headers:a,signal:null==(r=this.abortController)?void 0:r.signal}),l=c.headers.get("mcp-session-id");if(l&&(this.sessionId=l),401===c.status&&this.authProvider&&!t){this.resourceMetadataUrl=vt(c);try{if("AUTHORIZED"!==await Ut(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})){const t=new yt;return void(null==(o=this.onerror)||o.call(this,t))}}catch(t){return void(null==(n=this.onerror)||n.call(this,t))}return this.openInboundSse(!0,e)}if(405===c.status)return;if(!c.ok||!c.body){const t=new w({message:`MCP HTTP Transport Error: GET SSE failed: ${c.status} ${c.statusText}`});return void(null==(i=this.onerror)||i.call(this,t))}const u=c.body.pipeThrough(new TextDecoderStream).pipeThrough(new s.Z).getReader(),p=async()=>{var t,e,r,o;try{for(;;){const{done:r,value:o}=await u.read();if(r)return;const{event:n,data:s,id:i}=o;if(i&&(this.lastInboundEventId=i),"message"===n)try{const e=et.parse(JSON.parse(s));null==(t=this.onmessage)||t.call(this,e)}catch(t){const r=new w({message:"MCP HTTP Transport Error: Failed to parse message",cause:t});null==(e=this.onerror)||e.call(this,r)}}}catch(t){if(t instanceof Error&&"AbortError"===t.name)return;null==(r=this.onerror)||r.call(this,t),(null==(o=this.abortController)?void 0:o.signal.aborted)||this.scheduleInboundSseReconnection()}};this.inboundSseConnection={close:()=>u.cancel()},this.inboundReconnectAttempts=0,p()}catch(t){if(t instanceof Error&&"AbortError"===t.name)return;null==(a=this.onerror)||a.call(this,t),(null==(c=this.abortController)?void 0:c.signal.aborted)||this.scheduleInboundSseReconnection()}}};async function jt(t){const e=new It(t);return await e.init(),e}var It=class{constructor({transport:t,name:e="ai-sdk-mcp-client",version:r="1.0.0",onUncaughtError:o,capabilities:n}){var s;this.requestMessageId=0,this.responseHandlers=new Map,this.serverCapabilities={},this.isClosed=!0,this.onUncaughtError=o,this.clientCapabilities=null!=n?n:{},"start"in(s=t)&&"function"==typeof s.start&&"send"in s&&"function"==typeof s.send&&"close"in s&&"function"==typeof s.close?this.transport=t:this.transport=function(t){switch(t.type){case"sse":return new St(t);case"http":return new kt(t);default:throw new w({message:"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface."})}}(t),this.transport.onclose=()=>this.onClose(),this.transport.onerror=t=>this.onError(t),this.transport.onmessage=t=>{"method"in t?"id"in t?this.onRequestMessage(t):this.onError(new w({message:"Unsupported message type"})):this.onResponse(t)},this.clientInfo={name:e,version:r}}async init(){try{await this.transport.start(),this.isClosed=!1;const t=await this.request({request:{method:"initialize",params:{protocolVersion:z,capabilities:this.clientCapabilities,clientInfo:this.clientInfo}},resultSchema:E});if(void 0===t)throw new w({message:"Server sent invalid initialize result"});if(!f.includes(t.protocolVersion))throw new w({message:`Server's protocol version is not supported: ${t.protocolVersion}`});return this.serverCapabilities=t.capabilities,await this.notification({method:"notifications/initialized"}),this}catch(t){throw await this.close(),t}}async close(){var t;this.isClosed||(await(null==(t=this.transport)?void 0:t.close()),this.onClose())}assertCapability(t){switch(t){case"initialize":break;case"tools/list":case"tools/call":if(!this.serverCapabilities.tools)throw new w({message:"Server does not support tools"});break;case"resources/list":case"resources/read":case"resources/templates/list":if(!this.serverCapabilities.resources)throw new w({message:"Server does not support resources"});break;case"prompts/list":case"prompts/get":if(!this.serverCapabilities.prompts)throw new w({message:"Server does not support prompts"});break;default:throw new w({message:`Unsupported method: ${t}`})}}async request({request:t,resultSchema:e,options:r}){return new Promise((o,n)=>{if(this.isClosed)return n(new w({message:"Attempted to send a request from a closed client"}));this.assertCapability(t.method);const s=null==r?void 0:r.signal;null==s||s.throwIfAborted();const i=this.requestMessageId++,a={...t,jsonrpc:"2.0",id:i},c=()=>{this.responseHandlers.delete(i)};this.responseHandlers.set(i,t=>{if(null==s?void 0:s.aborted)return n(new w({message:"Request was aborted",cause:s.reason}));if(t instanceof Error)return n(t);try{const r=e.parse(t.result);o(r)}catch(t){const e=new w({message:"Failed to parse server response",cause:t});n(e)}}),this.transport.send(a).catch(t=>{c(),n(t)})})}async listTools({params:t,options:e}={}){try{return this.request({request:{method:"tools/list",params:t},resultSchema:S,options:e})}catch(t){throw t}}async callTool({name:t,args:e,options:r}){try{return this.request({request:{method:"tools/call",params:{name:t,arguments:e}},resultSchema:q,options:{signal:null==r?void 0:r.abortSignal}})}catch(t){throw t}}async listResourcesInternal({params:t,options:e}={}){try{return this.request({request:{method:"resources/list",params:t},resultSchema:x,options:e})}catch(t){throw t}}async readResourceInternal({uri:t,options:e}){try{return this.request({request:{method:"resources/read",params:{uri:t}},resultSchema:D,options:e})}catch(t){throw t}}async listResourceTemplatesInternal({options:t}={}){try{return this.request({request:{method:"resources/templates/list"},resultSchema:L,options:t})}catch(t){throw t}}async listPromptsInternal({params:t,options:e}={}){try{return this.request({request:{method:"prompts/list",params:t},resultSchema:F,options:e})}catch(t){throw t}}async getPromptInternal({name:t,args:e,options:r}){try{return this.request({request:{method:"prompts/get",params:{name:t,arguments:e}},resultSchema:J,options:r})}catch(t){throw t}}async notification(t){const e={...t,jsonrpc:"2.0"};await this.transport.send(e)}async tools({schemas:t="automatic"}={}){var e;const r={};try{const n=await this.listTools();for(const{name:s,description:i,inputSchema:a,annotations:c,_meta:l}of n.tools){const n=null==c?void 0:c.title;if("automatic"!==t&&!(s in t))continue;const u=this,p=async(t,e)=>{var r;return null==(r=null==e?void 0:e.abortSignal)||r.throwIfAborted(),u.callTool({name:s,args:t,options:e})},h="automatic"===t?(0,o.dynamicTool)({description:i,title:n,inputSchema:(0,o.jsonSchema)({...a,properties:null!=(e=a.properties)?e:{},additionalProperties:!1}),execute:p}):(0,o.tool)({description:i,title:n,inputSchema:t[s].inputSchema,execute:p});r[s]={...h,_meta:l}}return r}catch(t){throw t}}listResources({params:t,options:e}={}){return this.listResourcesInternal({params:t,options:e})}readResource({uri:t,options:e}){return this.readResourceInternal({uri:t,options:e})}listResourceTemplates({options:t}={}){return this.listResourceTemplatesInternal({options:t})}experimental_listPrompts({params:t,options:e}={}){return this.listPromptsInternal({params:t,options:e})}experimental_getPrompt({name:t,arguments:e,options:r}){return this.getPromptInternal({name:t,args:e,options:r})}onElicitationRequest(t,e){if(t!==G)throw new w({message:"Unsupported request schema. Only ElicitationRequestSchema is supported."});this.elicitationRequestHandler=e}async onRequestMessage(t){try{if("elicitation/create"!==t.method)return void await this.transport.send({jsonrpc:"2.0",id:t.id,error:{code:-32601,message:`Unsupported request method: ${t.method}`}});if(!this.elicitationRequestHandler)return void await this.transport.send({jsonrpc:"2.0",id:t.id,error:{code:-32601,message:"No elicitation handler registered on client"}});const e=G.safeParse({method:t.method,params:t.params});if(!e.success)return void await this.transport.send({jsonrpc:"2.0",id:t.id,error:{code:-32602,message:`Invalid elicitation request: ${e.error.message}`,data:e.error.issues}});try{const r=await this.elicitationRequestHandler(e.data),o=B.parse(r);await this.transport.send({jsonrpc:"2.0",id:t.id,result:o})}catch(e){await this.transport.send({jsonrpc:"2.0",id:t.id,error:{code:-32603,message:e instanceof Error?e.message:"Failed to handle elicitation request"}}),this.onError(e)}}catch(t){this.onError(t)}}onClose(){if(this.isClosed)return;this.isClosed=!0;const t=new w({message:"Connection closed"});for(const e of this.responseHandlers.values())e(t);this.responseHandlers.clear()}onError(t){this.onUncaughtError&&this.onUncaughtError(t)}onResponse(t){const e=Number(t.id),r=this.responseHandlers.get(e);if(void 0===r)throw new w({message:`Protocol error: Received a response for an unknown message ID: ${JSON.stringify(t)}`});this.responseHandlers.delete(e),r("result"in t?t:new w({message:t.error.message,code:t.error.code,data:t.error.data,cause:t.error}))}}}}]);