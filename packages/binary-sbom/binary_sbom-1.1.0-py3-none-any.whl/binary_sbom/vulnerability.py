"""
Vulnerability database client module for Binary SBOM Generator.

This module provides a base class and API clients for querying vulnerability
databases including NVD (National Vulnerability Database), OSV (Open Source
Vulnerabilities), and GitHub Security Advisories. It handles secure API key
management, rate limiting, and error handling for vulnerability lookups.
"""

import time
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, Dict, List, Optional

if TYPE_CHECKING:
    import requests

try:
    import requests  # noqa: F811
except ImportError:
    requests = None  # type: ignore  # pragma: no cover

try:
    from src.binary_sbom.secrets import load_secret, redact_secret
except ImportError:
    # Secrets module is optional for base client functionality
    load_secret = None  # type: ignore
    redact_secret = None  # type: ignore


class VulnDBError(Exception):
    """Exception raised when vulnerability database operations fail."""

    pass


class VulnDBClient(ABC):
    """
    Base class for vulnerability database API clients.

    This abstract base class provides common functionality for querying
    vulnerability databases including:
    - Secure API key management using the secrets module
    - Configurable rate limiting
    - HTTP request handling with error management
    - Response validation and parsing

    Subclasses must implement the abstract methods to provide database-specific
    query logic and URL formatting.

    Attributes:
        api_key: API key for authentication (loaded securely from environment).
        base_url: Base URL for the vulnerability database API.
        rate_limit_delay: Delay in seconds between API requests to respect rate limits.
        timeout: Request timeout in seconds.

    Example:
        >>> class MyClient(VulnDBClient):
        ...     def build_query_url(self, package_name, version):
        ...         return f"{self.base_url}/{package_name}/{version}"
        ...     def parse_response(self, response):
        ...         return response.json()
        >>> client = MyClient(api_key_env_var="MY_API_KEY")
        >>> vulnerabilities = client.query("openssl", "1.1.1")
    """

    def __init__(
        self,
        api_key_env_var: Optional[str] = None,
        base_url: str = "",
        rate_limit_delay: float = 0.5,
        timeout: int = 30,
    ):
        """
        Initialize vulnerability database client.

        Args:
            api_key_env_var: Environment variable name containing the API key.
                If None, no API key will be used. The key is loaded securely
                using the secrets module.
            base_url: Base URL for the vulnerability database API.
            rate_limit_delay: Delay in seconds between API requests to avoid
                hitting rate limits (default: 0.5).
            timeout: HTTP request timeout in seconds (default: 30).

        Raises:
            ImportError: If requests library is not installed.
        """
        if requests is None:
            raise ImportError(
                "requests library is required for vulnerability database clients. "
                "Install it with: pip install requests"
            )

        self.api_key: Optional[str] = None
        if api_key_env_var:
            if load_secret is not None:
                self.api_key = load_secret(api_key_env_var)
            else:
                # Fallback to environment variable if secrets module unavailable
                import os
                self.api_key = os.environ.get(api_key_env_var)

        self.base_url = base_url
        self.rate_limit_delay = rate_limit_delay
        self.timeout = timeout
        self._last_request_time: float = 0

    @abstractmethod
    def build_query_url(
        self, package_name: str, version: Optional[str] = None
    ) -> str:
        """
        Build API query URL for a specific package and version.

        This method must be implemented by subclasses to construct the
        appropriate URL for their specific vulnerability database API.

        Args:
            package_name: Name of the package to query.
            version: Optional version string. If None, queries all versions.

        Returns:
            Complete URL for the API query.

        Example:
            >>> def build_query_url(self, package_name, version):
            ...     if version:
            ...         return f"{self.base_url}/vulnerabilities?package={package_name}&version={version}"
            ...     return f"{self.base_url}/vulnerabilities?package={package_name}"
        """
        pass

    @abstractmethod
    def parse_response(self, response: "requests.Response") -> List[Dict[str, Any]]:
        """
        Parse API response and extract vulnerability data.

        This method must be implemented by subclasses to parse the
        database-specific response format and extract vulnerability information.

        Args:
            response: HTTP response object from the API.

        Returns:
            List of vulnerability dictionaries. Each dictionary should contain
            at minimum 'id', 'severity', and 'description' fields.

        Raises:
            VulnDBError: If the response cannot be parsed or contains an error.

        Example:
            >>> def parse_response(self, response):
            ...     data = response.json()
            ...     if response.status_code != 200:
            ...         raise VulnDBError(f"API error: {data.get('message', 'Unknown error')}")
            ...     return data.get('vulnerabilities', [])
        """
        pass

    def query(
        self, package_name: str, version: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Query vulnerability database for a package.

        This method performs the complete query workflow:
        1. Enforces rate limiting
        2. Builds the query URL
        3. Makes the HTTP request
        4. Parses and returns the response

        Args:
            package_name: Name of the package to query.
            version: Optional version string. If None, queries all versions.

        Returns:
            List of vulnerability dictionaries.

        Raises:
            VulnDBError: If the query fails or returns an error.

        Example:
            >>> client = NVDClient()
            >>> vulnerabilities = client.query("openssl", "1.1.1k")
            >>> len(vulnerabilities) > 0
            True
        """
        # Enforce rate limiting
        self._enforce_rate_limit()

        # Build query URL
        url = self.build_query_url(package_name, version)

        # Make request with error handling
        try:
            response = self._make_request(url)
        except requests.exceptions.RequestException as e:
            raise VulnDBError(f"Failed to query vulnerability database: {e}")

        # Parse and return response
        try:
            vulnerabilities = self.parse_response(response)
            return vulnerabilities
        except VulnDBError:
            raise
        except Exception as e:
            raise VulnDBError(f"Failed to parse vulnerability data: {e}")

    def _make_request(self, url: str) -> "requests.Response":
        """
        Make HTTP request to the vulnerability database API.

        Handles authentication headers and request timeout. Includes
        error handling for common HTTP errors.

        Args:
            url: Complete URL for the API request.

        Returns:
            HTTP response object.

        Raises:
            requests.exceptions.RequestException: If the request fails.
        """
        headers: Dict[str, str] = {
            "User-Agent": "Binary-SBOM-Generator/1.0",
            "Accept": "application/json",
        }

        # Add authentication header if API key is configured
        if self.api_key:
            headers.update(self._get_auth_headers())

        try:
            response = requests.get(url, headers=headers, timeout=self.timeout)
            response.raise_for_status()
            return response
        except requests.exceptions.Timeout:
            raise requests.exceptions.RequestException(
                f"Request timed out after {self.timeout} seconds"
            )
        except requests.exceptions.HTTPError as e:
            # Log error without exposing API key
            if self.api_key:
                if redact_secret is not None:
                    redacted_key = redact_secret(self.api_key)
                    raise requests.exceptions.RequestException(
                        f"HTTP error {e.response.status_code}. "
                        f"API key (redacted): {redacted_key}"
                    ) from e
                else:
                    # Fallback if redact_secret unavailable
                    raise requests.exceptions.RequestException(
                        f"HTTP error {e.response.status_code}. "
                        f"API key configured (details hidden)"
                    ) from e
            raise
        except requests.exceptions.RequestException as e:
            raise requests.exceptions.RequestException(f"Request failed: {e}") from e

    def _get_auth_headers(self) -> Dict[str, str]:
        """
        Get authentication headers for API requests.

        This method can be overridden by subclasses to provide custom
        authentication schemes. The default implementation uses a
        Bearer token scheme.

        Returns:
            Dictionary of authentication headers.

        Example:
            >>> def _get_auth_headers(self):
            ...     return {"Authorization": f"Bearer {self.api_key}"}
        """
        return {"Authorization": f"Bearer {self.api_key}"}

    def _enforce_rate_limit(self) -> None:
        """
        Enforce rate limiting by sleeping if necessary.

        Calculates the time elapsed since the last request and sleeps
        for the remaining duration to meet the configured rate limit delay.
        This helps prevent hitting API rate limits.

        Example:
            >>> client = NVDClient(rate_limit_delay=1.0)
            >>> client._enforce_rate_limit()  # Will sleep if last request < 1s ago
        """
        current_time = time.time()
        time_since_last_request = current_time - self._last_request_time

        if time_since_last_request < self.rate_limit_delay:
            sleep_time = self.rate_limit_delay - time_since_last_request
            time.sleep(sleep_time)

        self._last_request_time = time.time()

    def set_api_key(self, api_key: str) -> None:
        """
        Set or update the API key.

        This method allows updating the API key after initialization,
        useful for testing or key rotation scenarios.

        Args:
            api_key: New API key to use for authentication.

        Example:
            >>> client = NVDClient()
            >>> client.set_api_key("new-api-key-12345")
        """
        self.api_key = api_key

    def set_rate_limit(self, delay: float) -> None:
        """
        Update the rate limit delay between requests.

        Args:
            delay: New delay in seconds between API requests.

        Example:
            >>> client = NVDClient()
            >>> client.set_rate_limit(1.0)  # 1 second between requests
        """
        if delay < 0:
            raise ValueError("Rate limit delay must be non-negative")
        self.rate_limit_delay = delay


class NVDClient(VulnDBClient):
    """
    Client for the National Vulnerability Database (NVD) API.

    This client queries the NIST National Vulnerability Database (NVD)
    API v2.0 to retrieve CVE (Common Vulnerabilities and Exposures)
    information for specific software packages and versions.

    The NVD API requires an API key for higher rate limits:
    - Without API key: 5 requests per rolling 30 seconds
    - With API key: 50 requests per rolling 30 seconds

    The API key should be stored in the NVD_API_KEY environment variable
    and will be loaded securely using the secrets module.

    Attributes:
        api_key: NVD API key for authentication (optional but recommended).
        base_url: NVD API v2.0 base URL.
        rate_limit_delay: Delay between requests (default: 0.6s for API key,
            6.0s without API key to respect rate limits).

    Example:
        >>> client = NVDClient()  # Uses NVD_API_KEY environment variable
        >>> vulnerabilities = client.query("openssl", "1.1.1k")
        >>> for vuln in vulnerabilities:
        ...     print(f"{vuln['id']}: {vuln['severity']}")
    """

    # NVD API v2.0 endpoint
    NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    # Rate limits: 50 req/30s with API key, 5 req/30s without
    RATE_LIMIT_WITH_KEY = 0.6  # 30s / 50 requests
    RATE_LIMIT_WITHOUT_KEY = 6.0  # 30s / 5 requests

    def __init__(
        self,
        api_key_env_var: str = "NVD_API_KEY",
        rate_limit_delay: Optional[float] = None,
        timeout: int = 30,
    ):
        """
        Initialize NVD API client.

        Args:
            api_key_env_var: Environment variable name containing the NVD API key
                (default: "NVD_API_KEY"). The key is loaded securely using the
                secrets module.
            rate_limit_delay: Delay in seconds between requests. If None, automatically
                set based on whether an API key is available (0.6s with key, 6.0s without).
            timeout: HTTP request timeout in seconds (default: 30).

        Raises:
            ImportError: If requests library is not installed.
        """
        # Initialize with NVD base URL
        super().__init__(
            api_key_env_var=api_key_env_var,
            base_url=self.NVD_API_URL,
            rate_limit_delay=rate_limit_delay
            if rate_limit_delay is not None
            else (self.RATE_LIMIT_WITH_KEY if self._has_api_key(api_key_env_var) else self.RATE_LIMIT_WITHOUT_KEY),
            timeout=timeout,
        )

    def _has_api_key(self, api_key_env_var: str) -> bool:
        """Check if API key is available in environment."""
        import os

        # Check using secrets module if available, otherwise fallback to os.environ
        if load_secret is not None:
            return load_secret(api_key_env_var) is not None
        return os.environ.get(api_key_env_var) is not None

    def build_query_url(
        self, package_name: str, version: Optional[str] = None
    ) -> str:
        """
        Build NVD API query URL for a specific package and version.

        Constructs a CPE (Common Platform Enumeration) string to query
        vulnerabilities for a specific software package and version.

        Args:
            package_name: Name of the package to query (e.g., "openssl").
            version: Optional version string (e.g., "1.1.1k"). If None, queries
                all versions of the package.

        Returns:
            Complete URL for the NVD API query with CPE filter parameters.

        Example:
            >>> client = NVDClient()
            >>> url = client.build_query_url("openssl", "1.1.1k")
            >>> "cpeName" in url
            True
        """
        # Build CPE (Common Platform Enumeration) string
        # Format: cpe:2.3:a:vendor:product:version:*:*:*:*:*:*:*
        # For general queries, we use a simplified search
        if version:
            # Search for specific version
            cpe_string = f"cpe:2.3:a:*:{package_name}:{version}:*:*:*:*:*:*:*"
        else:
            # Search for all versions
            cpe_string = f"cpe:2.3:a:*:{package_name}:*:*:*:*:*:*:*:*"

        # Build URL with query parameters
        import urllib.parse

        params = {"cpeName": cpe_string, "resultsPerPage": 20}
        query_string = urllib.parse.urlencode(params)
        return f"{self.base_url}?{query_string}"

    def parse_response(self, response: "requests.Response") -> List[Dict[str, Any]]:
        """
        Parse NVD API response and extract vulnerability data.

        Extracts CVE information from the NVD API v2.0 JSON response format,
        including CVE ID, severity score (CVSS), description, and references.

        Args:
            response: HTTP response object from the NVD API.

        Returns:
            List of vulnerability dictionaries. Each dictionary contains:
            - id (str): CVE identifier (e.g., "CVE-2021-1234")
            - severity (str): CVSS severity rating (LOW, MEDIUM, HIGH, CRITICAL)
            - score (Optional[float]): CVSS score (0.0-10.0)
            - description (str): Vulnerability description
            - references (List[str]): URLs to advisory and patch information
            - published (str): Date the CVE was published
            - modified (str): Date the CVE was last modified

        Raises:
            VulnDBError: If the response indicates an error or cannot be parsed.

        Example:
            >>> client = NVDClient()
            >>> response = client._make_request(client.build_query_url("openssl", "1.1.1k"))
            >>> vulnerabilities = client.parse_response(response)
            >>> len(vulnerabilities) > 0
            True
        """
        try:
            data = response.json()
        except ValueError as e:
            raise VulnDBError(f"Invalid JSON response from NVD API: {e}")

        # Check for API errors
        if response.status_code != 200:
            error_message = data.get("message", "Unknown error")
            raise VulnDBError(f"NVD API error ({response.status_code}): {error_message}")

        # Extract vulnerability data from NVD API v2.0 format
        vulnerabilities: List[Dict[str, Any]] = []

        # NVD API v2.0 format: {"vulnerabilities": [{"cve": {...}}]}
        vuln_list = data.get("vulnerabilities", [])

        for item in vuln_list:
            cve = item.get("cve", {})
            vuln_data = self._extract_cve_data(cve)
            vulnerabilities.append(vuln_data)

        return vulnerabilities

    def _extract_cve_data(self, cve: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract relevant data from a CVE entry.

        Parses the NVD CVE JSON structure to extract commonly used fields
        including ID, severity, description, and references.

        Args:
            cve: CVE dictionary from NVD API response.

        Returns:
            Dictionary with extracted vulnerability data.
        """
        # Extract CVE ID
        cve_id = cve.get("id", "UNKNOWN")

        # Extract descriptions (English only)
        descriptions = cve.get("descriptions", [])
        description = ""
        for desc in descriptions:
            if desc.get("lang") == "en":
                description = desc.get("value", "")
                break

        # Extract CVSS metrics and severity
        # NVD API v2.0 provides multiple metrics (V2, V3.0, V3.1)
        metrics = cve.get("metrics", {})
        score = None
        severity = "UNKNOWN"

        # Try CVSS v3.1 first, then v3.0, then v2
        if "cvssMetricV31" in metrics:
            cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
            score = cvss_data.get("baseScore")
            severity = cvss_data.get("baseSeverity", "UNKNOWN")
        elif "cvssMetricV30" in metrics:
            cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
            score = cvss_data.get("baseScore")
            severity = cvss_data.get("baseSeverity", "UNKNOWN")
        elif "cvssMetricV2" in metrics:
            cvss_data = metrics["cvssMetricV2"][0]["cvssData"]
            score = cvss_data.get("baseScore")
            # V2 doesn't have severity, derive from score
            if score is not None:
                if score >= 7.0:
                    severity = "HIGH"
                elif score >= 4.0:
                    severity = "MEDIUM"
                else:
                    severity = "LOW"

        # Extract references
        references = cve.get("references", [])
        reference_urls = []
        for ref in references:
            url = ref.get("url", "")
            if url:
                reference_urls.append(url)

        # Extract dates
        published = cve.get("published", "")
        modified = cve.get("lastModified", "")

        return {
            "id": cve_id,
            "severity": severity,
            "score": score,
            "description": description,
            "references": reference_urls,
            "published": published,
            "modified": modified,
        }

    def _get_auth_headers(self) -> Dict[str, str]:
        """
        Get authentication headers for NVD API requests.

        NVD API uses a custom 'apiKey' header rather than the standard
        Bearer token scheme.

        Returns:
            Dictionary with the API key header if configured.

        Example:
            >>> client = NVDClient()
            >>> headers = client._get_auth_headers()
            >>> 'apiKey' in headers or len(headers) == 0
            True
        """
        if self.api_key:
            return {"apiKey": self.api_key}
        return {}


class OSVClient(VulnDBClient):
    """
    Client for the Open Source Vulnerabilities (OSV) API.

    This client queries the OSV API to retrieve vulnerability information
    for open source packages. OSV is a distributed vulnerability database
    that aggregates data from multiple sources including GitHub Security
    Advisories, PyPA, and more.

    The OSV API does not require authentication for basic usage, but supports
    optional API keys for higher rate limits.

    Attributes:
        api_key: OSV API key for authentication (optional).
        base_url: OSV API base URL.
        rate_limit_delay: Delay between requests (default: 0.2s).

    Example:
        >>> client = OSVClient()
        >>> vulnerabilities = client.query("numpy", "1.21.0", ecosystem="PyPI")
        >>> for vuln in vulnerabilities:
        ...     print(f"{vuln['id']}: {vuln['summary']}")
    """

    # OSV API endpoint
    OSV_API_URL = "https://api.osv.dev/v1"

    # Default rate limit for OSV (generous limits, but still be polite)
    DEFAULT_RATE_LIMIT = 0.2

    def __init__(
        self,
        api_key_env_var: Optional[str] = None,
        rate_limit_delay: float = DEFAULT_RATE_LIMIT,
        timeout: int = 30,
    ):
        """
        Initialize OSV API client.

        Args:
            api_key_env_var: Environment variable name containing the OSV API key
                (optional). The key is loaded securely using the secrets module.
                OSV API does not require authentication for basic usage.
            rate_limit_delay: Delay in seconds between requests (default: 0.2).
            timeout: HTTP request timeout in seconds (default: 30).

        Raises:
            ImportError: If requests library is not installed.

        Example:
            >>> client = OSVClient()  # No API key required for basic usage
            >>> vulnerabilities = client.query("numpy", "1.21.0", ecosystem="PyPI")
        """
        # Initialize with OSV base URL
        super().__init__(
            api_key_env_var=api_key_env_var,
            base_url=self.OSV_API_URL,
            rate_limit_delay=rate_limit_delay,
            timeout=timeout,
        )

    def build_query_url(
        self, package_name: str, version: Optional[str] = None
    ) -> str:
        """
        Build OSV API query URL.

        Note: OSV uses POST requests with a JSON body, so this method
        returns the query endpoint URL. The actual query parameters are
        constructed in the query method.

        Args:
            package_name: Name of the package to query (e.g., "numpy").
            version: Optional version string (e.g., "1.21.0"). If None, queries
                all versions of the package.

        Returns:
            URL for the OSV query endpoint.

        Example:
            >>> client = OSVClient()
            >>> url = client.build_query_url("numpy", "1.21.0")
            >>> "api.osv.dev/v1/query" in url
            True
        """
        return f"{self.base_url}/query"

    def query(
        self,
        package_name: str,
        version: Optional[str] = None,
        ecosystem: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """
        Query OSV database for a package.

        OSV requires specifying the package ecosystem (e.g., PyPI, npm, Go, etc.).
        This method overrides the base query method to support OSV's POST-based
        API and ecosystem parameter.

        Args:
            package_name: Name of the package to query.
            version: Optional version string. If None, queries all versions.
            ecosystem: Package ecosystem (e.g., "PyPI", "npm", "Go", "crates.io").
                Required for accurate results.

        Returns:
            List of vulnerability dictionaries.

        Raises:
            VulnDBError: If the query fails or returns an error.

        Example:
            >>> client = OSVClient()
            >>> vulnerabilities = client.query("numpy", "1.21.0", ecosystem="PyPI")
            >>> len(vulnerabilities) >= 0
            True

        Example (without ecosystem, will query all):
            >>> client = OSVClient()
            >>> vulnerabilities = client.query("numpy", "1.21.0")
        """
        # Enforce rate limiting
        self._enforce_rate_limit()

        # Build request URL
        url = self.build_query_url(package_name, version)

        # Build request body for OSV's POST API
        request_body: Dict[str, Any] = {
            "package": {"name": package_name},
        }

        if version:
            request_body["version"] = version

        if ecosystem:
            request_body["package"]["ecosystem"] = ecosystem

        # Make POST request with error handling
        try:
            response = self._make_post_request(url, request_body)
        except requests.exceptions.RequestException as e:
            raise VulnDBError(f"Failed to query OSV database: {e}")

        # Parse and return response
        try:
            vulnerabilities = self.parse_response(response)
            return vulnerabilities
        except VulnDBError:
            raise
        except Exception as e:
            raise VulnDBError(f"Failed to parse OSV vulnerability data: {e}")

    def _make_post_request(
        self, url: str, data: Dict[str, Any]
    ) -> "requests.Response":
        """
        Make POST request to the OSV API.

        Overrides the base class's GET request method to support OSV's
        POST-based query API.

        Args:
            url: URL for the API request.
            data: Request body as dictionary (will be JSON-encoded).

        Returns:
            HTTP response object.

        Raises:
            requests.exceptions.RequestException: If the request fails.
        """
        headers: Dict[str, str] = {
            "User-Agent": "Binary-SBOM-Generator/1.0",
            "Accept": "application/json",
            "Content-Type": "application/json",
        }

        # Add authentication header if API key is configured
        if self.api_key:
            headers.update(self._get_auth_headers())

        try:
            response = requests.post(
                url, json=data, headers=headers, timeout=self.timeout
            )
            response.raise_for_status()
            return response
        except requests.exceptions.Timeout:
            raise requests.exceptions.RequestException(
                f"Request timed out after {self.timeout} seconds"
            )
        except requests.exceptions.HTTPError as e:
            # Log error without exposing API key
            if self.api_key:
                if redact_secret is not None:
                    redacted_key = redact_secret(self.api_key)
                    raise requests.exceptions.RequestException(
                        f"HTTP error {e.response.status_code}. "
                        f"API key (redacted): {redacted_key}"
                    ) from e
                else:
                    # Fallback if redact_secret unavailable
                    raise requests.exceptions.RequestException(
                        f"HTTP error {e.response.status_code}. "
                        f"API key configured (details hidden)"
                    ) from e
            raise
        except requests.exceptions.RequestException as e:
            raise requests.exceptions.RequestException(f"Request failed: {e}") from e

    def parse_response(self, response: "requests.Response") -> List[Dict[str, Any]]:
        """
        Parse OSV API response and extract vulnerability data.

        Extracts vulnerability information from the OSV API JSON response format,
        including vulnerability ID, aliases, severity, summary, and affected
        package versions.

        Args:
            response: HTTP response object from the OSV API.

        Returns:
            List of vulnerability dictionaries. Each dictionary contains:
            - id (str): OSV vulnerability ID (e.g., "OSV-2021-1234")
            - aliases (List[str]): List of alias IDs (e.g., CVE IDs)
            - summary (str): Brief vulnerability description
            - details (str): Detailed vulnerability description
            - severity (Optional[List[Dict]]): Severity information
            - affected (List[Dict]): Affected package versions
            - references (List[Dict]): References to advisories and patches
            - published (str): Date the vulnerability was published
            - modified (str): Date the vulnerability was last modified

        Raises:
            VulnDBError: If the response indicates an error or cannot be parsed.

        Example:
            >>> client = OSVClient()
            >>> response = client._make_post_request(
            ...     client.build_query_url("numpy", "1.21.0"),
            ...     {"package": {"name": "numpy", "ecosystem": "PyPI"}, "version": "1.21.0"}
            ... )
            >>> vulnerabilities = client.parse_response(response)
            >>> len(vulnerabilities) >= 0
            True
        """
        try:
            data = response.json()
        except ValueError as e:
            raise VulnDBError(f"Invalid JSON response from OSV API: {e}")

        # Check for API errors
        if response.status_code != 200:
            error_message = data.get("message", "Unknown error")
            raise VulnDBError(f"OSV API error ({response.status_code}): {error_message}")

        # Extract vulnerability data from OSV API format
        vulnerabilities: List[Dict[str, Any]] = []

        # OSV API format: {"vulns": [{...}]}
        vuln_list = data.get("vulns", [])

        for vuln in vuln_list:
            vuln_data = self._extract_osv_data(vuln)
            vulnerabilities.append(vuln_data)

        return vulnerabilities

    def _extract_osv_data(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract relevant data from an OSV vulnerability entry.

        Parses the OSV vulnerability JSON structure to extract commonly used
        fields including ID, aliases, severity, summary, and affected versions.

        Args:
            vuln: Vulnerability dictionary from OSV API response.

        Returns:
            Dictionary with extracted vulnerability data.
        """
        # Extract vulnerability ID
        vuln_id = vuln.get("id", "UNKNOWN")

        # Extract aliases (e.g., CVE IDs)
        aliases = vuln.get("aliases", [])

        # Extract summary and details
        summary = vuln.get("summary", "")
        details = vuln.get("details", "")

        # Extract severity information
        severity = vuln.get("severity", None)

        # Extract affected package versions
        affected = vuln.get("affected", [])

        # Extract references
        references = vuln.get("references", [])

        # Extract dates
        published = vuln.get("published", "")
        modified = vuln.get("modified", "")

        # Determine overall severity level (if available)
        severity_level = "UNKNOWN"
        if severity:
            # OSV severity format: [{"type": "CVSS_v3", "score": "CVSS:3.1/AV:N/..."}]
            for sev in severity:
                if sev.get("type") == "CVSS_v3":
                    score_str = sev.get("score", "")
                    # Extract base score from CVSS string
                    # Format: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
                    if score_str:
                        # Parse CVSS score if available
                        parts = score_str.split("/")
                        if len(parts) > 2:
                            severity_level = "HIGH"  # Simplified for now

        return {
            "id": vuln_id,
            "aliases": aliases,
            "summary": summary,
            "details": details,
            "severity": severity_level,
            "severity_info": severity,
            "affected": affected,
            "references": references,
            "published": published,
            "modified": modified,
        }


class GitHubAdvisoriesClient(VulnDBClient):
    """
    Client for the GitHub Security Advisories API.

    This client queries the GitHub Security Advisories API to retrieve
    vulnerability information for GitHub repositories and packages.
    GitHub Security Advisories (GHSA) provide vulnerability data for
    open source projects hosted on GitHub.

    The GitHub API requires authentication for higher rate limits:
    - Without authentication: 60 requests per hour
    - With authentication: 5,000 requests per hour

    The GitHub token should be stored in the GITHUB_TOKEN environment variable
    and will be loaded securely using the secrets module.

    Attributes:
        api_key: GitHub personal access token for authentication (optional but recommended).
        base_url: GitHub API base URL.
        rate_limit_delay: Delay between requests (default: 0.7s with auth, 60s without).

    Example:
        >>> client = GitHubAdvisoriesClient()  # Uses GITHUB_TOKEN environment variable
        >>> vulnerabilities = client.query("rails", "rails", "6.1.0")
        >>> for vuln in vulnerabilities:
        ...     print(f"{vuln['id']}: {vuln['severity']}")
    """

    # GitHub API endpoint
    GITHUB_API_URL = "https://api.github.com"

    # Rate limits: 5000 req/hour with auth, 60 req/hour without
    RATE_LIMIT_WITH_KEY = 0.72  # 3600s / 5000 requests
    RATE_LIMIT_WITHOUT_KEY = 60.0  # 3600s / 60 requests

    def __init__(
        self,
        api_key_env_var: str = "GITHUB_TOKEN",
        rate_limit_delay: Optional[float] = None,
        timeout: int = 30,
    ):
        """
        Initialize GitHub Advisories API client.

        Args:
            api_key_env_var: Environment variable name containing the GitHub token
                (default: "GITHUB_TOKEN"). The token is loaded securely using the
                secrets module.
            rate_limit_delay: Delay in seconds between requests. If None, automatically
                set based on whether a token is available (0.72s with token, 60s without).
            timeout: HTTP request timeout in seconds (default: 30).

        Raises:
            ImportError: If requests library is not installed.

        Example:
            >>> client = GitHubAdvisoriesClient()  # Uses GITHUB_TOKEN environment variable
        """
        # Initialize with GitHub base URL
        super().__init__(
            api_key_env_var=api_key_env_var,
            base_url=self.GITHUB_API_URL,
            rate_limit_delay=rate_limit_delay
            if rate_limit_delay is not None
            else (self.RATE_LIMIT_WITH_KEY if self._has_token(api_key_env_var) else self.RATE_LIMIT_WITHOUT_KEY),
            timeout=timeout,
        )

    def _has_token(self, token_env_var: str) -> bool:
        """Check if GitHub token is available in environment."""
        import os

        # Check using secrets module if available, otherwise fallback to os.environ
        if load_secret is not None:
            return load_secret(token_env_var) is not None
        return os.environ.get(token_env_var) is not None

    def build_query_url(
        self, package_name: str, version: Optional[str] = None
    ) -> str:
        """
        Build GitHub Advisories API query URL.

        Note: GitHub Advisories API uses a query endpoint with filters.
        This method constructs the base query URL. The actual query is
        performed via POST in the overridden query method.

        Args:
            package_name: Name of the package/ecosystem to query (e.g., "pip").
            version: Optional version string (e.g., "21.0"). If None, queries
                all versions of the package.

        Returns:
            URL for the GitHub Advisories query endpoint.

        Example:
            >>> client = GitHubAdvisoriesClient()
            >>> url = client.build_query_url("pip", "21.0")
            >>> "api.github.com/advisories" in url
            True
        """
        return f"{self.base_url}/advisories"

    def query(
        self,
        package_name: str,
        version: Optional[str] = None,
        ecosystem: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """
        Query GitHub Security Advisories database for a package.

        GitHub Advisories supports filtering by ecosystem (e.g., PyPI, npm, RUBYGEMS, etc.).
        This method overrides the base query method to support GitHub's query API
        with ecosystem filtering.

        Args:
            package_name: Name of the package to query (e.g., "numpy", "rails").
            version: Optional version string (e.g., "1.21.0", "6.1.0"). If None, queries
                all versions of the package.
            ecosystem: Package ecosystem (e.g., "PIP", "NPM", "RUBYGEMS", "MAVEN").
                Recommended for accurate results.

        Returns:
            List of vulnerability dictionaries.

        Raises:
            VulnDBError: If the query fails or returns an error.

        Example:
            >>> client = GitHubAdvisoriesClient()
            >>> vulnerabilities = client.query("numpy", "1.21.0", ecosystem="PIP")
            >>> len(vulnerabilities) >= 0
            True

        Example (without ecosystem, will query all):
            >>> client = GitHubAdvisoriesClient()
            >>> vulnerabilities = client.query("numpy", "1.21.0")
        """
        # Enforce rate limiting
        self._enforce_rate_limit()

        # Build request URL
        url = self.build_query_url(package_name, version)

        # Build query parameters for GitHub's API
        # GitHub uses GET with query parameters for advisories
        import urllib.parse

        params: Dict[str, Any] = {
            "state": "published",
            "sort": "updated",
            "direction": "desc",
            "per_page": 100,
        }

        # Add filters if provided
        if ecosystem:
            params["ecosystem"] = ecosystem.upper()

        # Build query string
        query_string = urllib.parse.urlencode(params)

        # Add package name filter to query
        # GitHub API supports filtering by affected package name
        if package_name:
            if query_string:
                query_string += f"&affected_package={urllib.parse.quote(package_name)}"
            else:
                query_string = f"affected_package={urllib.parse.quote(package_name)}"

        full_url = f"{url}?{query_string}"

        # Make GET request with error handling
        try:
            response = self._make_request(full_url)
        except requests.exceptions.RequestException as e:
            raise VulnDBError(f"Failed to query GitHub Advisories database: {e}")

        # Parse and return response
        try:
            vulnerabilities = self.parse_response(response)
            # Filter by version if specified (GitHub API doesn't support version filtering directly)
            if version and vulnerabilities:
                vulnerabilities = self._filter_by_version(vulnerabilities, version)
            return vulnerabilities
        except VulnDBError:
            raise
        except Exception as e:
            raise VulnDBError(f"Failed to parse GitHub Advisories vulnerability data: {e}")

    def _filter_by_version(
        self, vulnerabilities: List[Dict[str, Any]], version: str
    ) -> List[Dict[str, Any]]:
        """
        Filter vulnerabilities by affected version range.

        Since GitHub API doesn't support version filtering directly,
        we need to filter results locally based on the affected versions
        in each advisory.

        Args:
            vulnerabilities: List of vulnerability dictionaries from GitHub API.
            version: Version string to filter by.

        Returns:
            Filtered list of vulnerabilities affecting the specified version.

        Note:
            This is a simplified filter. For production use, consider implementing
            proper semantic version range parsing.
        """
        filtered = []
        for vuln in vulnerabilities:
            affected = vuln.get("affected", [])
            for affected_item in affected:
                # Check if version is in affected versions
                if self._version_matches(affected_item, version):
                    filtered.append(vuln)
                    break
        return filtered

    def _version_matches(self, affected_item: Dict[str, Any], version: str) -> bool:
        """
        Check if a version matches the affected version ranges.

        This is a simplified implementation that checks if the version
        is mentioned in the affected package versions.

        Args:
            affected_item: Affected package information from GitHub advisory.
            version: Version string to check.

        Returns:
            True if version appears to be affected, False otherwise.

        Note:
            This is a simplified check. A production implementation should
            use proper semantic version range parsing (e.g., using packaging library).
        """
        # Check if version is directly in affected versions list
        versions = affected_item.get("versions", [])
        if version in versions:
            return True

        # Check ranges (simplified - just check if version string appears)
        # A production implementation should parse semver ranges properly
        package = affected_item.get("package", {})
        ecosystem = package.get("ecosystem", "")

        # For now, be conservative and include if we can't determine
        return True

    def parse_response(self, response: "requests.Response") -> List[Dict[str, Any]]:
        """
        Parse GitHub Advisories API response and extract vulnerability data.

        Extracts vulnerability information from the GitHub Security Advisories
        API JSON response format, including GHSA ID, severity, description,
        and affected package versions.

        Args:
            response: HTTP response object from the GitHub Advisories API.

        Returns:
            List of vulnerability dictionaries. Each dictionary contains:
            - id (str): GHSA identifier (e.g., "GHSA-1234-5678-9012")
            - severity (str): Severity rating (LOW, MODERATE, HIGH, CRITICAL)
            - summary (str): Brief vulnerability description
            - description (str): Detailed vulnerability description
            - cvss (Optional[Dict]): CVSS score data
            - affected (List[Dict]): Affected package versions
            - references (List[Dict]): References to advisories and patches
            - published (str): Date the advisory was published
            - updated (str): Date the advisory was last updated
            - withdrawn (Optional[str]): Date the advisory was withdrawn (if applicable)

        Raises:
            VulnDBError: If the response indicates an error or cannot be parsed.

        Example:
            >>> client = GitHubAdvisoriesClient()
            >>> url = client.build_query_url("numpy", "1.21.0")
            >>> response = client._make_request(url)
            >>> vulnerabilities = client.parse_response(response)
            >>> len(vulnerabilities) >= 0
            True
        """
        try:
            data = response.json()
        except ValueError as e:
            raise VulnDBError(f"Invalid JSON response from GitHub Advisories API: {e}")

        # Check for API errors
        if response.status_code != 200:
            error_message = data.get("message", "Unknown error")
            raise VulnDBError(
                f"GitHub Advisories API error ({response.status_code}): {error_message}"
            )

        # Extract vulnerability data from GitHub API format
        vulnerabilities: List[Dict[str, Any]] = []

        # GitHub API format: array of advisory objects
        for advisory in data:
            vuln_data = self._extract_advisory_data(advisory)
            vulnerabilities.append(vuln_data)

        return vulnerabilities

    def _extract_advisory_data(self, advisory: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract relevant data from a GitHub Security Advisory entry.

        Parses the GitHub advisory JSON structure to extract commonly used
        fields including GHSA ID, severity, description, and affected versions.

        Args:
            advisory: Advisory dictionary from GitHub API response.

        Returns:
            Dictionary with extracted vulnerability data.
        """
        # Extract GHSA ID
        ghsa_id = advisory.get("ghsaId", "UNKNOWN")

        # Extract summary and description
        summary = advisory.get("summary", "")
        description = advisory.get("description", "")

        # Extract severity
        severity = advisory.get("severity", "UNKNOWN")

        # Extract CVSS score
        cvss = advisory.get("cvss", None)

        # Extract affected package versions
        affected = advisory.get("affected", [])

        # Extract references
        references = advisory.get("references", [])

        # Extract dates
        published = advisory.get("publishedAt", "")
        updated = advisory.get("updatedAt", "")
        withdrawn = advisory.get("withdrawnAt", None)

        return {
            "id": ghsa_id,
            "summary": summary,
            "description": description,
            "severity": severity,
            "cvss": cvss,
            "affected": affected,
            "references": references,
            "published": published,
            "updated": updated,
            "withdrawn": withdrawn,
        }


__all__ = [
    "VulnDBClient",
    "VulnDBError",
    "NVDClient",
    "OSVClient",
    "GitHubAdvisoriesClient",
]
