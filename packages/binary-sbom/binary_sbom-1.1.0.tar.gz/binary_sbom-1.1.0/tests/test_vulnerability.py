"""
Unit tests for the vulnerability database client module.

Tests vulnerability database clients including NVD, OSV, and GitHub.
Tests API queries, response parsing, error handling, and rate limiting.
"""

from unittest.mock import MagicMock, Mock, patch

import pytest

from binary_sbom.vulnerability import (
    GitHubAdvisoriesClient,
    NVDClient,
    OSVClient,
    VulnDBClient,
    VulnDBError,
)


class TestVulnDBClient:
    """Test base VulnDBClient functionality."""

    def test_vulndb_client_is_abstract(self):
        """Test that VulnDBClient cannot be instantiated directly."""
        with pytest.raises(TypeError):
            VulnDBClient()

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_without_requests(self, mock_requests):
        """Test that missing requests library raises ImportError."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        with patch('binary_sbom.vulnerability.requests', None):
            with pytest.raises(ImportError, match='requests library is required'):
                TestClient()

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_vulndb_client_init_with_api_key(self, mock_load_secret, mock_requests):
        """Test client initialization with API key."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        mock_load_secret.return_value = 'test-api-key-123'
        mock_requests.get = MagicMock()

        client = TestClient(api_key_env_var='TEST_API_KEY', base_url='http://api.test.com')

        assert client.api_key == 'test-api-key-123'
        assert client.base_url == 'http://api.test.com'
        assert client.rate_limit_delay == 0.5
        assert client.timeout == 30

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_vulndb_client_init_without_api_key(self, mock_load_secret, mock_requests):
        """Test client initialization without API key."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        mock_load_secret.return_value = None
        mock_requests.get = MagicMock()

        client = TestClient(api_key_env_var='TEST_API_KEY', base_url='http://api.test.com')

        assert client.api_key is None

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret', None)
    def test_vulndb_client_init_fallback_to_os_environ(self, mock_requests):
        """Test client falls back to os.environ when load_secret is unavailable."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        mock_requests.get = MagicMock()

        with patch.dict('os.environ', {'TEST_API_KEY': 'env-api-key'}):
            client = TestClient(api_key_env_var='TEST_API_KEY', base_url='http://api.test.com')

        assert client.api_key == 'env-api-key'

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_enforce_rate_limit(self, mock_requests):
        """Test rate limiting between requests."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        mock_requests.get = MagicMock()

        client = TestClient(base_url='http://api.test.com', rate_limit_delay=1.0)

        # First call should not sleep
        with patch('time.sleep') as mock_sleep:
            client._enforce_rate_limit()
            mock_sleep.assert_not_called()

        # Second immediate call should sleep
        with patch('time.sleep') as mock_sleep:
            client._enforce_rate_limit()
            mock_sleep.assert_called_once()
            # Check that sleep time is approximately 1 second
            sleep_arg = mock_sleep.call_args[0][0]
            assert 0.9 <= sleep_arg <= 1.1

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_set_api_key(self, mock_requests):
        """Test setting API key after initialization."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        mock_requests.get = MagicMock()

        client = TestClient(base_url='http://api.test.com')
        assert client.api_key is None

        client.set_api_key('new-api-key')
        assert client.api_key == 'new-api-key'

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_set_rate_limit(self, mock_requests):
        """Test setting rate limit delay."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        mock_requests.get = MagicMock()

        client = TestClient(base_url='http://api.test.com', rate_limit_delay=0.5)
        assert client.rate_limit_delay == 0.5

        client.set_rate_limit(1.5)
        assert client.rate_limit_delay == 1.5

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_set_rate_limit_negative(self, mock_requests):
        """Test that negative rate limit raises ValueError."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        mock_requests.get = MagicMock()

        client = TestClient(base_url='http://api.test.com')

        with pytest.raises(ValueError, match='Rate limit delay must be non-negative'):
            client.set_rate_limit(-1.0)

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_get_auth_headers_default(self, mock_requests):
        """Test default authentication headers (Bearer token)."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return response.json()

        mock_requests.get = MagicMock()

        client = TestClient(base_url='http://api.test.com')
        client.api_key = 'test-key'

        headers = client._get_auth_headers()
        assert headers == {'Authorization': 'Bearer test-key'}

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_query_success(self, mock_requests):
        """Test successful query."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return [{'id': 'VULN-001', 'severity': 'HIGH'}]

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_requests.get.return_value = mock_response
        mock_requests.exceptions.RequestException = Exception

        client = TestClient(base_url='http://api.test.com', rate_limit_delay=0)

        vulnerabilities = client.query('test-package')

        assert len(vulnerabilities) == 1
        assert vulnerabilities[0]['id'] == 'VULN-001'

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_query_request_exception(self, mock_requests):
        """Test query handles request exceptions."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return []

        mock_requests.get.side_effect = Exception('Connection failed')
        mock_requests.exceptions.RequestException = Exception

        client = TestClient(base_url='http://api.test.com', rate_limit_delay=0)

        with pytest.raises(VulnDBError, match='Failed to query vulnerability database'):
            client.query('test-package')

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_query_parse_exception(self, mock_requests):
        """Test query handles parse exceptions."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                raise ValueError('Parse failed')

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_requests.get.return_value = mock_response
        mock_requests.exceptions.RequestException = Exception

        client = TestClient(base_url='http://api.test.com', rate_limit_delay=0)

        with pytest.raises(VulnDBError, match='Failed to parse vulnerability data'):
            client.query('test-package')

    @patch('binary_sbom.vulnerability.requests')
    def test_vulndb_client_make_request_timeout(self, mock_requests):
        """Test request timeout handling."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return []

        # Create a proper Timeout exception
        timeout_exc = Exception('Request timed out')
        mock_requests.get.side_effect = timeout_exc
        mock_requests.exceptions.Timeout = type(timeout_exc)
        mock_requests.exceptions.RequestException = type(timeout_exc)

        client = TestClient(base_url='http://api.test.com', timeout=5)

        # Patch the Timeout check to recognize our exception
        with patch('binary_sbom.vulnerability.requests.exceptions.Timeout', type(timeout_exc)):
            with pytest.raises(Exception, match='Request timed out'):
                client._make_request('http://api.test.com/test')

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.redact_secret')
    def test_vulndb_client_make_request_http_error_with_api_key(self, mock_redact, mock_requests):
        """Test HTTP error handling with API key redaction."""

        class TestClient(VulnDBClient):
            def build_query_url(self, package_name, version=None):
                return f"http://api.test.com/{package_name}"

            def parse_response(self, response):
                return []

        mock_response = MagicMock()
        mock_response.status_code = 401

        # Create proper exception hierarchy
        class MockRequestException(Exception):
            pass

        class MockTimeout(Exception):
            pass

        class MockHTTPError(MockRequestException):
            def __init__(self):
                self.response = mock_response
                super().__init__('HTTP Error')

        http_error = MockHTTPError()
        mock_requests.get.side_effect = http_error
        mock_requests.exceptions.Timeout = MockTimeout
        mock_requests.exceptions.HTTPError = MockHTTPError
        mock_requests.exceptions.RequestException = MockRequestException

        mock_redact.return_value = ' REDACTED'

        client = TestClient(base_url='http://api.test.com')
        client.api_key = 'secret-key'

        with pytest.raises(MockRequestException, match='API key.*redacted'):
            client._make_request('http://api.test.com/test')


class TestNVDClient:
    """Test NVD API client functionality."""

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_init_with_api_key(self, mock_load_secret, mock_requests):
        """Test NVD client initialization with API key."""
        mock_load_secret.return_value = 'nvd-api-key'
        mock_requests.get = MagicMock()

        client = NVDClient()

        assert client.api_key == 'nvd-api-key'
        assert client.base_url == NVDClient.NVD_API_URL
        assert client.rate_limit_delay == NVDClient.RATE_LIMIT_WITH_KEY

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_init_without_api_key(self, mock_load_secret, mock_requests):
        """Test NVD client initialization without API key."""
        mock_load_secret.return_value = None
        mock_requests.get = MagicMock()

        client = NVDClient()

        assert client.api_key is None
        assert client.rate_limit_delay == NVDClient.RATE_LIMIT_WITHOUT_KEY

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_init_custom_rate_limit(self, mock_load_secret, mock_requests):
        """Test NVD client initialization with custom rate limit."""
        mock_load_secret.return_value = 'nvd-api-key'
        mock_requests.get = MagicMock()

        client = NVDClient(rate_limit_delay=2.0)

        assert client.rate_limit_delay == 2.0

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_build_query_url_with_version(self, mock_load_secret, mock_requests):
        """Test building NVD query URL with version."""
        mock_load_secret.return_value = 'test-key'
        mock_requests.get = MagicMock()

        client = NVDClient()
        url = client.build_query_url('openssl', '1.1.1k')

        assert 'cpeName' in url
        assert 'openssl' in url
        assert '1.1.1k' in url
        assert 'resultsPerPage=20' in url

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_build_query_url_without_version(self, mock_load_secret, mock_requests):
        """Test building NVD query URL without version."""
        mock_load_secret.return_value = 'test-key'
        mock_requests.get = MagicMock()

        client = NVDClient()
        url = client.build_query_url('openssl', None)

        assert 'cpeName' in url
        assert 'openssl' in url
        # Should use wildcard for version (URL-encoded as %2A)
        assert '%2A' in url

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_parse_response_success(self, mock_load_secret, mock_requests):
        """Test parsing NVD API response successfully."""
        mock_load_secret.return_value = 'test-key'
        mock_requests.get = MagicMock()

        client = NVDClient()

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'vulnerabilities': [
                {
                    'cve': {
                        'id': 'CVE-2021-1234',
                        'descriptions': [{'lang': 'en', 'value': 'Test vulnerability'}],
                        'metrics': {
                            'cvssMetricV31': [
                                {
                                    'cvssData': {
                                        'baseScore': 9.8,
                                        'baseSeverity': 'CRITICAL'
                                    }
                                }
                            ]
                        },
                        'references': [{'url': 'https://example.com/ref1'}],
                        'published': '2021-01-01T00:00:00Z',
                        'lastModified': '2021-01-02T00:00:00Z'
                    }
                }
            ]
        }

        vulnerabilities = client.parse_response(mock_response)

        assert len(vulnerabilities) == 1
        assert vulnerabilities[0]['id'] == 'CVE-2021-1234'
        assert vulnerabilities[0]['severity'] == 'CRITICAL'
        assert vulnerabilities[0]['score'] == 9.8
        assert vulnerabilities[0]['description'] == 'Test vulnerability'
        assert len(vulnerabilities[0]['references']) == 1

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_parse_response_cvss_v2(self, mock_load_secret, mock_requests):
        """Test parsing NVD response with CVSS v2 metrics."""
        mock_load_secret.return_value = 'test-key'
        mock_requests.get = MagicMock()

        client = NVDClient()

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'vulnerabilities': [
                {
                    'cve': {
                        'id': 'CVE-2021-1234',
                        'descriptions': [{'lang': 'en', 'value': 'Test'}],
                        'metrics': {
                            'cvssMetricV2': [
                                {
                                    'cvssData': {
                                        'baseScore': 5.0
                                    }
                                }
                            ]
                        },
                        'references': [],
                        'published': '2021-01-01T00:00:00Z',
                        'lastModified': '2021-01-02T00:00:00Z'
                    }
                }
            ]
        }

        vulnerabilities = client.parse_response(mock_response)

        assert vulnerabilities[0]['score'] == 5.0
        assert vulnerabilities[0]['severity'] == 'MEDIUM'

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_parse_response_no_metrics(self, mock_load_secret, mock_requests):
        """Test parsing NVD response without metrics."""
        mock_load_secret.return_value = 'test-key'
        mock_requests.get = MagicMock()

        client = NVDClient()

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'vulnerabilities': [
                {
                    'cve': {
                        'id': 'CVE-2021-1234',
                        'descriptions': [{'lang': 'en', 'value': 'Test'}],
                        'references': [],
                        'published': '2021-01-01T00:00:00Z',
                        'lastModified': '2021-01-02T00:00:00Z'
                    }
                }
            ]
        }

        vulnerabilities = client.parse_response(mock_response)

        assert vulnerabilities[0]['score'] is None
        assert vulnerabilities[0]['severity'] == 'UNKNOWN'

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_parse_response_invalid_json(self, mock_load_secret, mock_requests):
        """Test parsing invalid JSON response."""
        mock_load_secret.return_value = 'test-key'
        mock_requests.get = MagicMock()

        client = NVDClient()

        mock_response = MagicMock()
        mock_response.json.side_effect = ValueError('Invalid JSON')

        with pytest.raises(VulnDBError, match='Invalid JSON response'):
            client.parse_response(mock_response)

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_parse_response_api_error(self, mock_load_secret, mock_requests):
        """Test parsing NVD API error response."""
        mock_load_secret.return_value = 'test-key'
        mock_requests.get = MagicMock()

        client = NVDClient()

        mock_response = MagicMock()
        mock_response.status_code = 403
        mock_response.json.return_value = {'message': 'Rate limit exceeded'}

        with pytest.raises(VulnDBError, match='NVD API error.*403'):
            client.parse_response(mock_response)

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_get_auth_headers(self, mock_load_secret, mock_requests):
        """Test NVD client authentication headers."""
        mock_load_secret.return_value = 'test-key'
        mock_requests.get = MagicMock()

        client = NVDClient()
        client.api_key = 'nvd-key-123'

        headers = client._get_auth_headers()

        assert headers == {'apiKey': 'nvd-key-123'}

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_nvd_client_get_auth_headers_no_key(self, mock_load_secret, mock_requests):
        """Test NVD client authentication headers without API key."""
        mock_load_secret.return_value = None
        mock_requests.get = MagicMock()

        client = NVDClient()

        headers = client._get_auth_headers()

        assert headers == {}


class TestOSVClient:
    """Test OSV API client functionality."""

    @patch('binary_sbom.vulnerability.requests')
    def test_osv_client_init(self, mock_requests):
        """Test OSV client initialization."""
        mock_requests.get = MagicMock()
        mock_requests.post = MagicMock()

        client = OSVClient()

        assert client.api_key is None
        assert client.base_url == OSVClient.OSV_API_URL
        assert client.rate_limit_delay == OSVClient.DEFAULT_RATE_LIMIT

    @patch('binary_sbom.vulnerability.requests')
    def test_osv_client_build_query_url(self, mock_requests):
        """Test building OSV query URL."""
        mock_requests.get = MagicMock()
        mock_requests.post = MagicMock()

        client = OSVClient()
        url = client.build_query_url('numpy', '1.21.0')

        assert 'api.osv.dev/v1/query' in url

    @patch('binary_sbom.vulnerability.requests')
    def test_osv_client_query_with_ecosystem(self, mock_requests):
        """Test OSV query with ecosystem parameter."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {'vulns': []}
        mock_requests.post.return_value = mock_response
        mock_requests.exceptions.RequestException = Exception

        client = OSVClient(rate_limit_delay=0)

        vulnerabilities = client.query('numpy', '1.21.0', ecosystem='PyPI')

        # Verify POST request was made with correct body
        assert mock_requests.post.called
        call_args = mock_requests.post.call_args
        assert 'PyPI' in str(call_args)

    @patch('binary_sbom.vulnerability.requests')
    def test_osv_client_query_without_ecosystem(self, mock_requests):
        """Test OSV query without ecosystem parameter."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {'vulns': []}
        mock_requests.post.return_value = mock_response
        mock_requests.exceptions.RequestException = Exception

        client = OSVClient(rate_limit_delay=0)

        vulnerabilities = client.query('numpy', '1.21.0')

        assert len(vulnerabilities) == 0

    @patch('binary_sbom.vulnerability.requests')
    def test_osv_client_parse_response_success(self, mock_requests):
        """Test parsing OSV API response successfully."""
        mock_requests.get = MagicMock()
        mock_requests.post = MagicMock()

        client = OSVClient()

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'vulns': [
                {
                    'id': 'OSV-2021-1234',
                    'aliases': ['CVE-2021-1234'],
                    'summary': 'Test vulnerability',
                    'details': 'Detailed description',
                    'severity': [
                        {
                            'type': 'CVSS_v3',
                            'score': 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
                        }
                    ],
                    'affected': [{'package': {'name': 'numpy'}, 'versions': ['1.21.0']}],
                    'references': [{'url': 'https://example.com/ref1'}],
                    'published': '2021-01-01T00:00:00Z',
                    'modified': '2021-01-02T00:00:00Z'
                }
            ]
        }

        vulnerabilities = client.parse_response(mock_response)

        assert len(vulnerabilities) == 1
        assert vulnerabilities[0]['id'] == 'OSV-2021-1234'
        assert 'CVE-2021-1234' in vulnerabilities[0]['aliases']
        assert vulnerabilities[0]['summary'] == 'Test vulnerability'
        assert vulnerabilities[0]['details'] == 'Detailed description'
        assert vulnerabilities[0]['severity'] == 'HIGH'

    @patch('binary_sbom.vulnerability.requests')
    def test_osv_client_parse_response_no_severity(self, mock_requests):
        """Test parsing OSV response without severity."""
        mock_requests.get = MagicMock()
        mock_requests.post = MagicMock()

        client = OSVClient()

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'vulns': [
                {
                    'id': 'OSV-2021-1234',
                    'aliases': [],
                    'summary': 'Test',
                    'details': 'Details',
                    'affected': [],
                    'references': [],
                    'published': '2021-01-01T00:00:00Z',
                    'modified': '2021-01-02T00:00:00Z'
                }
            ]
        }

        vulnerabilities = client.parse_response(mock_response)

        assert vulnerabilities[0]['severity'] == 'UNKNOWN'

    @patch('binary_sbom.vulnerability.requests')
    def test_osv_client_parse_response_invalid_json(self, mock_requests):
        """Test parsing invalid JSON response."""
        mock_requests.get = MagicMock()
        mock_requests.post = MagicMock()

        client = OSVClient()

        mock_response = MagicMock()
        mock_response.json.side_effect = ValueError('Invalid JSON')

        with pytest.raises(VulnDBError, match='Invalid JSON response'):
            client.parse_response(mock_response)

    @patch('binary_sbom.vulnerability.requests')
    def test_osv_client_make_post_request_timeout(self, mock_requests):
        """Test POST request timeout handling."""
        mock_requests.get = MagicMock()

        # Create a proper Timeout exception
        timeout_exc = Exception('Request timed out')
        mock_requests.post.side_effect = timeout_exc
        mock_requests.exceptions.Timeout = type(timeout_exc)
        mock_requests.exceptions.RequestException = type(timeout_exc)

        client = OSVClient(timeout=5)

        # Patch the Timeout check to recognize our exception
        with patch('binary_sbom.vulnerability.requests.exceptions.Timeout', type(timeout_exc)):
            with pytest.raises(Exception, match='Request timed out'):
                client._make_post_request('http://api.osv.dev/v1/query', {})


class TestGitHubAdvisoriesClient:
    """Test GitHub Security Advisories client functionality."""

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_init_with_token(self, mock_load_secret, mock_requests):
        """Test GitHub client initialization with token."""
        mock_load_secret.return_value = 'github-token'
        mock_requests.get = MagicMock()

        client = GitHubAdvisoriesClient()

        assert client.api_key == 'github-token'
        assert client.base_url == GitHubAdvisoriesClient.GITHUB_API_URL
        assert client.rate_limit_delay == GitHubAdvisoriesClient.RATE_LIMIT_WITH_KEY

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_init_without_token(self, mock_load_secret, mock_requests):
        """Test GitHub client initialization without token."""
        mock_load_secret.return_value = None
        mock_requests.get = MagicMock()

        client = GitHubAdvisoriesClient()

        assert client.api_key is None
        assert client.rate_limit_delay == GitHubAdvisoriesClient.RATE_LIMIT_WITHOUT_KEY

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_build_query_url(self, mock_load_secret, mock_requests):
        """Test building GitHub query URL."""
        mock_load_secret.return_value = 'test-token'
        mock_requests.get = MagicMock()

        client = GitHubAdvisoriesClient()
        url = client.build_query_url('numpy', '1.21.0')

        assert 'api.github.com/advisories' in url

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_query_with_ecosystem(self, mock_load_secret, mock_requests):
        """Test GitHub query with ecosystem parameter."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = []
        mock_requests.get.return_value = mock_response
        mock_requests.exceptions.RequestException = Exception

        mock_load_secret.return_value = 'test-token'

        client = GitHubAdvisoriesClient(rate_limit_delay=0)

        vulnerabilities = client.query('numpy', '1.21.0', ecosystem='PIP')

        # Verify GET request was made with ecosystem filter
        assert mock_requests.get.called

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_parse_response_success(self, mock_load_secret, mock_requests):
        """Test parsing GitHub API response successfully."""
        mock_load_secret.return_value = 'test-token'
        mock_requests.get = MagicMock()

        client = GitHubAdvisoriesClient()

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = [
            {
                'ghsaId': 'GHSA-1234-5678-9012',
                'summary': 'Test vulnerability',
                'description': 'Detailed description',
                'severity': 'HIGH',
                'cvss': {'score': 8.5},
                'affected': [
                    {
                        'package': {'name': 'numpy', 'ecosystem': 'PyPI'},
                        'versions': ['1.21.0', '1.21.1']
                    }
                ],
                'references': [{'url': 'https://example.com/ref1'}],
                'publishedAt': '2021-01-01T00:00:00Z',
                'updatedAt': '2021-01-02T00:00:00Z'
            }
        ]

        vulnerabilities = client.parse_response(mock_response)

        assert len(vulnerabilities) == 1
        assert vulnerabilities[0]['id'] == 'GHSA-1234-5678-9012'
        assert vulnerabilities[0]['summary'] == 'Test vulnerability'
        assert vulnerabilities[0]['severity'] == 'HIGH'
        assert vulnerabilities[0]['cvss']['score'] == 8.5
        assert len(vulnerabilities[0]['affected']) == 1

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_parse_response_with_withdrawn(self, mock_load_secret, mock_requests):
        """Test parsing GitHub response with withdrawn advisory."""
        mock_load_secret.return_value = 'test-token'
        mock_requests.get = MagicMock()

        client = GitHubAdvisoriesClient()

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = [
            {
                'ghsaId': 'GHSA-1234-5678-9012',
                'summary': 'Test',
                'description': 'Details',
                'severity': 'HIGH',
                'affected': [],
                'references': [],
                'publishedAt': '2021-01-01T00:00:00Z',
                'updatedAt': '2021-01-02T00:00:00Z',
                'withdrawnAt': '2021-01-03T00:00:00Z'
            }
        ]

        vulnerabilities = client.parse_response(mock_response)

        assert vulnerabilities[0]['withdrawn'] == '2021-01-03T00:00:00Z'

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_parse_response_invalid_json(self, mock_load_secret, mock_requests):
        """Test parsing invalid JSON response."""
        mock_load_secret.return_value = 'test-token'
        mock_requests.get = MagicMock()

        client = GitHubAdvisoriesClient()

        mock_response = MagicMock()
        mock_response.json.side_effect = ValueError('Invalid JSON')

        with pytest.raises(VulnDBError, match='Invalid JSON response'):
            client.parse_response(mock_response)

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_filter_by_version(self, mock_load_secret, mock_requests):
        """Test filtering vulnerabilities by version."""
        mock_load_secret.return_value = 'test-token'
        mock_requests.get = MagicMock()

        client = GitHubAdvisoriesClient()

        vulnerabilities = [
            {
                'id': 'GHSA-0001',
                'affected': [
                    {'package': {'name': 'numpy'}, 'versions': ['1.21.0', '1.21.1']}
                ]
            },
            {
                'id': 'GHSA-0002',
                'affected': [
                    {'package': {'name': 'numpy'}, 'versions': ['1.22.0']}
                ]
            }
        ]

        filtered = client._filter_by_version(vulnerabilities, '1.21.0')

        # Should include GHSA-0001 (has 1.21.0 in versions) and GHSA-0002 (fallback)
        assert len(filtered) >= 1

    @patch('binary_sbom.vulnerability.requests')
    @patch('binary_sbom.vulnerability.load_secret')
    def test_github_client_version_matches(self, mock_load_secret, mock_requests):
        """Test version matching logic."""
        mock_load_secret.return_value = 'test-token'
        mock_requests.get = MagicMock()

        client = GitHubAdvisoriesClient()

        affected_item = {
            'package': {'name': 'numpy', 'ecosystem': 'PyPI'},
            'versions': ['1.21.0', '1.21.1', '1.21.2']
        }

        # Should match version in list
        assert client._version_matches(affected_item, '1.21.0') is True

        # Conservative approach: returns True when version not found
        # (implementation is conservative to avoid missing vulnerabilities)
        assert client._version_matches(affected_item, '1.22.0') is True


class TestVulnDBError:
    """Test VulnDBError exception."""

    def test_vulndb_error_is_exception(self):
        """Test that VulnDBError is an Exception subclass."""
        assert issubclass(VulnDBError, Exception)

    def test_vulndb_error_can_be_raised(self):
        """Test that VulnDBError can be raised and caught."""
        with pytest.raises(VulnDBError):
            raise VulnDBError("Test error")

    def test_vulndb_error_message(self):
        """Test that VulnDBError preserves error message."""
        error_msg = "Test vulnerability database error"
        with pytest.raises(VulnDBError, match=error_msg):
            raise VulnDBError(error_msg)
